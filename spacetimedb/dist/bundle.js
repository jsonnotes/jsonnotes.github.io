import * as _syscalls1_0 from "spacetime:sys@1.0";
import { register_hooks } from "spacetime:sys@1.0";
import { register_hooks as register_hooks$1 } from "spacetime:sys@1.1";
import * as _syscalls1_2 from "spacetime:sys@1.2";
import { register_hooks as register_hooks$2 } from "spacetime:sys@1.2";

//#region rolldown:runtime
var __create$2 = Object.create;
var __defProp$2 = Object.defineProperty;
var __getOwnPropDesc$2 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames$2 = Object.getOwnPropertyNames;
var __getProtoOf$2 = Object.getPrototypeOf;
var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
var __commonJS$2 = (cb, mod) => function() {
	return mod || (0, cb[__getOwnPropNames$2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps$2 = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") for (var keys = __getOwnPropNames$2(from), i = 0, n = keys.length, key; i < n; i++) {
		key = keys[i];
		if (!__hasOwnProp$2.call(to, key) && key !== except) __defProp$2(to, key, {
			get: ((k) => from[k]).bind(null, key),
			enumerable: !(desc = __getOwnPropDesc$2(from, key)) || desc.enumerable
		});
	}
	return to;
};
var __toESM$2 = (mod, isNodeMode, target) => (target = mod != null ? __create$2(__getProtoOf$2(mod)) : {}, __copyProps$2(isNodeMode || !mod || !mod.__esModule ? __defProp$2(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));

//#endregion
//#region node_modules/headers-polyfill/lib/index.mjs
var __create$1 = Object.create;
var __defProp$1 = Object.defineProperty;
var __getOwnPropDesc$1 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames$1 = Object.getOwnPropertyNames;
var __getProtoOf$1 = Object.getPrototypeOf;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __commonJS$1 = (cb, mod) => function __require() {
	return mod || (0, cb[__getOwnPropNames$1(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps$1 = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") {
		for (let key of __getOwnPropNames$1(from)) if (!__hasOwnProp$1.call(to, key) && key !== except) __defProp$1(to, key, {
			get: () => from[key],
			enumerable: !(desc = __getOwnPropDesc$1(from, key)) || desc.enumerable
		});
	}
	return to;
};
var __toESM$1 = (mod, isNodeMode, target) => (target = mod != null ? __create$1(__getProtoOf$1(mod)) : {}, __copyProps$1(isNodeMode || !mod || !mod.__esModule ? __defProp$1(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));
var import_set_cookie_parser = __toESM$1(__commonJS$1({ "node_modules/set-cookie-parser/lib/set-cookie.js"(exports$1, module$1) {
	var defaultParseOptions = {
		decodeValues: true,
		map: false,
		silent: false
	};
	function isNonEmptyString(str$1) {
		return typeof str$1 === "string" && !!str$1.trim();
	}
	function parseString(setCookieValue, options) {
		var parts = setCookieValue.split(";").filter(isNonEmptyString);
		var parsed = parseNameValuePair(parts.shift());
		var name = parsed.name;
		var value = parsed.value;
		options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
		try {
			value = options.decodeValues ? decodeURIComponent(value) : value;
		} catch (e) {
			console.error("set-cookie-parser encountered an error while decoding a cookie with value '" + value + "'. Set options.decodeValues to false to disable this feature.", e);
		}
		var cookie = {
			name,
			value
		};
		parts.forEach(function(part) {
			var sides = part.split("=");
			var key = sides.shift().trimLeft().toLowerCase();
			var value2 = sides.join("=");
			if (key === "expires") cookie.expires = new Date(value2);
			else if (key === "max-age") cookie.maxAge = parseInt(value2, 10);
			else if (key === "secure") cookie.secure = true;
			else if (key === "httponly") cookie.httpOnly = true;
			else if (key === "samesite") cookie.sameSite = value2;
			else cookie[key] = value2;
		});
		return cookie;
	}
	function parseNameValuePair(nameValuePairStr) {
		var name = "";
		var value = "";
		var nameValueArr = nameValuePairStr.split("=");
		if (nameValueArr.length > 1) {
			name = nameValueArr.shift();
			value = nameValueArr.join("=");
		} else value = nameValuePairStr;
		return {
			name,
			value
		};
	}
	function parse$1(input, options) {
		options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
		if (!input) if (!options.map) return [];
		else return {};
		if (input.headers) if (typeof input.headers.getSetCookie === "function") input = input.headers.getSetCookie();
		else if (input.headers["set-cookie"]) input = input.headers["set-cookie"];
		else {
			var sch = input.headers[Object.keys(input.headers).find(function(key) {
				return key.toLowerCase() === "set-cookie";
			})];
			if (!sch && input.headers.cookie && !options.silent) console.warn("Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning.");
			input = sch;
		}
		if (!Array.isArray(input)) input = [input];
		options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
		if (!options.map) return input.filter(isNonEmptyString).map(function(str$1) {
			return parseString(str$1, options);
		});
		else return input.filter(isNonEmptyString).reduce(function(cookies2, str$1) {
			var cookie = parseString(str$1, options);
			cookies2[cookie.name] = cookie;
			return cookies2;
		}, {});
	}
	function splitCookiesString2(cookiesString) {
		if (Array.isArray(cookiesString)) return cookiesString;
		if (typeof cookiesString !== "string") return [];
		var cookiesStrings = [];
		var pos = 0;
		var start;
		var ch;
		var lastComma;
		var nextStart;
		var cookiesSeparatorFound;
		function skipWhitespace() {
			while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) pos += 1;
			return pos < cookiesString.length;
		}
		function notSpecialChar() {
			ch = cookiesString.charAt(pos);
			return ch !== "=" && ch !== ";" && ch !== ",";
		}
		while (pos < cookiesString.length) {
			start = pos;
			cookiesSeparatorFound = false;
			while (skipWhitespace()) {
				ch = cookiesString.charAt(pos);
				if (ch === ",") {
					lastComma = pos;
					pos += 1;
					skipWhitespace();
					nextStart = pos;
					while (pos < cookiesString.length && notSpecialChar()) pos += 1;
					if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
						cookiesSeparatorFound = true;
						pos = nextStart;
						cookiesStrings.push(cookiesString.substring(start, lastComma));
						start = pos;
					} else pos = lastComma + 1;
				} else pos += 1;
			}
			if (!cookiesSeparatorFound || pos >= cookiesString.length) cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
		}
		return cookiesStrings;
	}
	module$1.exports = parse$1;
	module$1.exports.parse = parse$1;
	module$1.exports.parseString = parseString;
	module$1.exports.splitCookiesString = splitCookiesString2;
} })());
var HEADERS_INVALID_CHARACTERS = /[^a-z0-9\-#$%&'*+.^_`|~]/i;
function normalizeHeaderName(name) {
	if (HEADERS_INVALID_CHARACTERS.test(name) || name.trim() === "") throw new TypeError("Invalid character in header field name");
	return name.trim().toLowerCase();
}
var charCodesToRemove = [
	String.fromCharCode(10),
	String.fromCharCode(13),
	String.fromCharCode(9),
	String.fromCharCode(32)
];
var HEADER_VALUE_REMOVE_REGEXP = new RegExp(`(^[${charCodesToRemove.join("")}]|$[${charCodesToRemove.join("")}])`, "g");
function normalizeHeaderValue(value) {
	return value.replace(HEADER_VALUE_REMOVE_REGEXP, "");
}
function isValidHeaderName(value) {
	if (typeof value !== "string") return false;
	if (value.length === 0) return false;
	for (let i = 0; i < value.length; i++) {
		const character = value.charCodeAt(i);
		if (character > 127 || !isToken(character)) return false;
	}
	return true;
}
function isToken(value) {
	return ![
		127,
		32,
		"(",
		")",
		"<",
		">",
		"@",
		",",
		";",
		":",
		"\\",
		"\"",
		"/",
		"[",
		"]",
		"?",
		"=",
		"{",
		"}"
	].includes(value);
}
function isValidHeaderValue(value) {
	if (typeof value !== "string") return false;
	if (value.trim() !== value) return false;
	for (let i = 0; i < value.length; i++) {
		const character = value.charCodeAt(i);
		if (character === 0 || character === 10 || character === 13) return false;
	}
	return true;
}
var NORMALIZED_HEADERS = Symbol("normalizedHeaders");
var RAW_HEADER_NAMES = Symbol("rawHeaderNames");
var HEADER_VALUE_DELIMITER = ", ";
var _a, _b, _c;
var Headers = class _Headers {
	constructor(init$1) {
		this[_a] = {};
		this[_b] = /* @__PURE__ */ new Map();
		this[_c] = "Headers";
		if (["Headers", "HeadersPolyfill"].includes(init$1?.constructor.name) || init$1 instanceof _Headers || typeof globalThis.Headers !== "undefined" && init$1 instanceof globalThis.Headers) init$1.forEach((value, name) => {
			this.append(name, value);
		}, this);
		else if (Array.isArray(init$1)) init$1.forEach(([name, value]) => {
			this.append(name, Array.isArray(value) ? value.join(HEADER_VALUE_DELIMITER) : value);
		});
		else if (init$1) Object.getOwnPropertyNames(init$1).forEach((name) => {
			const value = init$1[name];
			this.append(name, Array.isArray(value) ? value.join(HEADER_VALUE_DELIMITER) : value);
		});
	}
	[(_a = NORMALIZED_HEADERS, _b = RAW_HEADER_NAMES, _c = Symbol.toStringTag, Symbol.iterator)]() {
		return this.entries();
	}
	*keys() {
		for (const [name] of this.entries()) yield name;
	}
	*values() {
		for (const [, value] of this.entries()) yield value;
	}
	*entries() {
		let sortedKeys = Object.keys(this[NORMALIZED_HEADERS]).sort((a, b) => a.localeCompare(b));
		for (const name of sortedKeys) if (name === "set-cookie") for (const value of this.getSetCookie()) yield [name, value];
		else yield [name, this.get(name)];
	}
	/**
	* Returns a boolean stating whether a `Headers` object contains a certain header.
	*/
	has(name) {
		if (!isValidHeaderName(name)) throw new TypeError(`Invalid header name "${name}"`);
		return this[NORMALIZED_HEADERS].hasOwnProperty(normalizeHeaderName(name));
	}
	/**
	* Returns a `ByteString` sequence of all the values of a header with a given name.
	*/
	get(name) {
		if (!isValidHeaderName(name)) throw TypeError(`Invalid header name "${name}"`);
		return this[NORMALIZED_HEADERS][normalizeHeaderName(name)] ?? null;
	}
	/**
	* Sets a new value for an existing header inside a `Headers` object, or adds the header if it does not already exist.
	*/
	set(name, value) {
		if (!isValidHeaderName(name) || !isValidHeaderValue(value)) return;
		const normalizedName = normalizeHeaderName(name);
		const normalizedValue = normalizeHeaderValue(value);
		this[NORMALIZED_HEADERS][normalizedName] = normalizeHeaderValue(normalizedValue);
		this[RAW_HEADER_NAMES].set(normalizedName, name);
	}
	/**
	* Appends a new value onto an existing header inside a `Headers` object, or adds the header if it does not already exist.
	*/
	append(name, value) {
		if (!isValidHeaderName(name) || !isValidHeaderValue(value)) return;
		const normalizedName = normalizeHeaderName(name);
		const normalizedValue = normalizeHeaderValue(value);
		let resolvedValue = this.has(normalizedName) ? `${this.get(normalizedName)}, ${normalizedValue}` : normalizedValue;
		this.set(name, resolvedValue);
	}
	/**
	* Deletes a header from the `Headers` object.
	*/
	delete(name) {
		if (!isValidHeaderName(name)) return;
		if (!this.has(name)) return;
		const normalizedName = normalizeHeaderName(name);
		delete this[NORMALIZED_HEADERS][normalizedName];
		this[RAW_HEADER_NAMES].delete(normalizedName);
	}
	/**
	* Traverses the `Headers` object,
	* calling the given callback for each header.
	*/
	forEach(callback, thisArg) {
		for (const [name, value] of this.entries()) callback.call(thisArg, value, name, this);
	}
	/**
	* Returns an array containing the values
	* of all Set-Cookie headers associated
	* with a response
	*/
	getSetCookie() {
		const setCookieHeader = this.get("set-cookie");
		if (setCookieHeader === null) return [];
		if (setCookieHeader === "") return [""];
		return (0, import_set_cookie_parser.splitCookiesString)(setCookieHeader);
	}
};
function headersToList(headers) {
	const headersList = [];
	headers.forEach((value, name) => {
		const resolvedValue = value.includes(",") ? value.split(",").map((value2) => value2.trim()) : value;
		headersList.push([name, resolvedValue]);
	});
	return headersList;
}

//#endregion
//#region node_modules/spacetimedb/dist/server/index.mjs
typeof globalThis !== "undefined" && (globalThis.global = globalThis.global || globalThis, globalThis.window = globalThis.window || globalThis);
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError = (msg) => {
	throw TypeError(msg);
};
var __commonJS = (cb, mod) => function __require() {
	return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") {
		for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
			get: () => from[key],
			enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
		});
	}
	return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(__defProp(target, "default", {
	value: mod,
	enumerable: true
}), mod));
var __using = (stack, value, async) => {
	if (value != null) {
		if (typeof value !== "object" && typeof value !== "function") __typeError("Object expected");
		var dispose, inner;
		if (dispose === void 0) dispose = value[__knownSymbol("dispose")];
		if (typeof dispose !== "function") __typeError("Object not disposable");
		if (inner) dispose = function() {
			try {
				inner.call(this);
			} catch (e) {
				return Promise.reject(e);
			}
		};
		stack.push([
			async,
			dispose,
			value
		]);
	}
	return value;
};
var __callDispose = (stack, error, hasError) => {
	var E$1 = typeof SuppressedError === "function" ? SuppressedError : function(e, s, m, _$1) {
		return _$1 = Error(m), _$1.name = "SuppressedError", _$1.error = e, _$1.suppressed = s, _$1;
	};
	var fail = (e) => error = hasError ? new E$1(e, error, "An error was suppressed during disposal") : (hasError = true, e);
	var next = (it) => {
		while (it = stack.pop()) try {
			var result = it[1] && it[1].call(it[2]);
			if (it[0]) return Promise.resolve(result).then(next, (e) => (fail(e), next()));
		} catch (e) {
			fail(e);
		}
		if (hasError) throw error;
	};
	return next();
};
var require_base64_js = __commonJS({ "../../node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js"(exports$1) {
	exports$1.byteLength = byteLength;
	exports$1.toByteArray = toByteArray;
	exports$1.fromByteArray = fromByteArray2;
	var lookup = [];
	var revLookup = [];
	var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
	var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	for (i = 0, len = code.length; i < len; ++i) {
		lookup[i] = code[i];
		revLookup[code.charCodeAt(i)] = i;
	}
	var i;
	var len;
	revLookup["-".charCodeAt(0)] = 62;
	revLookup["_".charCodeAt(0)] = 63;
	function getLens(b64) {
		var len2 = b64.length;
		if (len2 % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
		var validLen = b64.indexOf("=");
		if (validLen === -1) validLen = len2;
		var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
		return [validLen, placeHoldersLen];
	}
	function byteLength(b64) {
		var lens = getLens(b64);
		var validLen = lens[0];
		var placeHoldersLen = lens[1];
		return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
	}
	function _byteLength(b64, validLen, placeHoldersLen) {
		return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
	}
	function toByteArray(b64) {
		var tmp;
		var lens = getLens(b64);
		var validLen = lens[0];
		var placeHoldersLen = lens[1];
		var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
		var curByte = 0;
		var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
		var i2;
		for (i2 = 0; i2 < len2; i2 += 4) {
			tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
			arr[curByte++] = tmp >> 16 & 255;
			arr[curByte++] = tmp >> 8 & 255;
			arr[curByte++] = tmp & 255;
		}
		if (placeHoldersLen === 2) {
			tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
			arr[curByte++] = tmp & 255;
		}
		if (placeHoldersLen === 1) {
			tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
			arr[curByte++] = tmp >> 8 & 255;
			arr[curByte++] = tmp & 255;
		}
		return arr;
	}
	function tripletToBase64(num) {
		return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
	}
	function encodeChunk(uint8, start, end) {
		var tmp;
		var output = [];
		for (var i2 = start; i2 < end; i2 += 3) {
			tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
			output.push(tripletToBase64(tmp));
		}
		return output.join("");
	}
	function fromByteArray2(uint8) {
		var tmp;
		var len2 = uint8.length;
		var extraBytes = len2 % 3;
		var parts = [];
		var maxChunkLength = 16383;
		for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
		if (extraBytes === 1) {
			tmp = uint8[len2 - 1];
			parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
		} else if (extraBytes === 2) {
			tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
			parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
		}
		return parts.join("");
	}
} });
var require_text_min = __commonJS({ "../../node_modules/.pnpm/fast-text-encoding@1.0.6/node_modules/fast-text-encoding/text.min.js"(exports$1) {
	(function(scope) {
		function B(r, e) {
			var f;
			return r instanceof Buffer ? f = r : f = Buffer.from(r.buffer, r.byteOffset, r.byteLength), f.toString(e);
		}
		var w = function(r) {
			return Buffer.from(r);
		};
		function h(r) {
			for (var e = 0, f = Math.min(256 * 256, r.length + 1), n = new Uint16Array(f), i = [], o = 0;;) {
				var t2 = e < r.length;
				if (!t2 || o >= f - 1) {
					var m = n.subarray(0, o);
					if (i.push(String.fromCharCode.apply(null, m)), !t2) return i.join("");
					r = r.subarray(e), e = 0, o = 0;
				}
				var a = r[e++];
				if ((a & 128) === 0) n[o++] = a;
				else if ((a & 224) === 192) {
					var d = r[e++] & 63;
					n[o++] = (a & 31) << 6 | d;
				} else if ((a & 240) === 224) {
					var d = r[e++] & 63, l = r[e++] & 63;
					n[o++] = (a & 31) << 12 | d << 6 | l;
				} else if ((a & 248) === 240) {
					var d = r[e++] & 63, l = r[e++] & 63, R = r[e++] & 63, c = (a & 7) << 18 | d << 12 | l << 6 | R;
					c > 65535 && (c -= 65536, n[o++] = c >>> 10 & 1023 | 55296, c = 56320 | c & 1023), n[o++] = c;
				}
			}
		}
		function F(r) {
			for (var e = 0, f = r.length, n = 0, i = Math.max(32, f + (f >>> 1) + 7), o = new Uint8Array(i >>> 3 << 3); e < f;) {
				var t2 = r.charCodeAt(e++);
				if (t2 >= 55296 && t2 <= 56319) {
					if (e < f) {
						var s = r.charCodeAt(e);
						(s & 64512) === 56320 && (++e, t2 = ((t2 & 1023) << 10) + (s & 1023) + 65536);
					}
					if (t2 >= 55296 && t2 <= 56319) continue;
				}
				if (n + 4 > o.length) {
					i += 8, i *= 1 + e / r.length * 2, i = i >>> 3 << 3;
					var m = new Uint8Array(i);
					m.set(o), o = m;
				}
				if ((t2 & 4294967168) === 0) {
					o[n++] = t2;
					continue;
				} else if ((t2 & 4294965248) === 0) o[n++] = t2 >>> 6 & 31 | 192;
				else if ((t2 & 4294901760) === 0) o[n++] = t2 >>> 12 & 15 | 224, o[n++] = t2 >>> 6 & 63 | 128;
				else if ((t2 & 4292870144) === 0) o[n++] = t2 >>> 18 & 7 | 240, o[n++] = t2 >>> 12 & 63 | 128, o[n++] = t2 >>> 6 & 63 | 128;
				else continue;
				o[n++] = t2 & 63 | 128;
			}
			return o.slice ? o.slice(0, n) : o.subarray(0, n);
		}
		var u = "Failed to ", p = function(r, e, f) {
			if (r) throw new Error("".concat(u).concat(e, ": the '").concat(f, "' option is unsupported."));
		};
		var x = typeof Buffer == "function" && Buffer.from;
		var A = x ? w : F;
		function v() {
			this.encoding = "utf-8";
		}
		v.prototype.encode = function(r, e) {
			return p(e && e.stream, "encode", "stream"), A(r);
		};
		function U(r) {
			var e;
			try {
				var f = new Blob([r], { type: "text/plain;charset=UTF-8" });
				e = URL.createObjectURL(f);
				var n = new XMLHttpRequest();
				return n.open("GET", e, false), n.send(), n.responseText;
			} finally {
				e && URL.revokeObjectURL(e);
			}
		}
		var O = !x && typeof Blob == "function" && typeof URL == "function" && typeof URL.createObjectURL == "function", S = [
			"utf-8",
			"utf8",
			"unicode-1-1-utf-8"
		], T = h;
		x ? T = B : O && (T = function(r) {
			try {
				return U(r);
			} catch (e) {
				return h(r);
			}
		});
		var y = "construct 'TextDecoder'", E$1 = "".concat(u, " ").concat(y, ": the ");
		function g(r, e) {
			p(e && e.fatal, y, "fatal"), r = r || "utf-8";
			var f;
			if (x ? f = Buffer.isEncoding(r) : f = S.indexOf(r.toLowerCase()) !== -1, !f) throw new RangeError("".concat(E$1, " encoding label provided ('").concat(r, "') is invalid."));
			this.encoding = r, this.fatal = false, this.ignoreBOM = false;
		}
		g.prototype.decode = function(r, e) {
			p(e && e.stream, "decode", "stream");
			var f;
			return r instanceof Uint8Array ? f = r : r.buffer instanceof ArrayBuffer ? f = new Uint8Array(r.buffer) : f = new Uint8Array(r), T(f, this.encoding);
		};
		scope.TextEncoder = scope.TextEncoder || v;
		scope.TextDecoder = scope.TextDecoder || g;
	})(typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : exports$1);
} });
var require_codes = __commonJS({ "../../node_modules/.pnpm/statuses@2.0.2/node_modules/statuses/codes.json"(exports$1, module$1) {
	module$1.exports = {
		"100": "Continue",
		"101": "Switching Protocols",
		"102": "Processing",
		"103": "Early Hints",
		"200": "OK",
		"201": "Created",
		"202": "Accepted",
		"203": "Non-Authoritative Information",
		"204": "No Content",
		"205": "Reset Content",
		"206": "Partial Content",
		"207": "Multi-Status",
		"208": "Already Reported",
		"226": "IM Used",
		"300": "Multiple Choices",
		"301": "Moved Permanently",
		"302": "Found",
		"303": "See Other",
		"304": "Not Modified",
		"305": "Use Proxy",
		"307": "Temporary Redirect",
		"308": "Permanent Redirect",
		"400": "Bad Request",
		"401": "Unauthorized",
		"402": "Payment Required",
		"403": "Forbidden",
		"404": "Not Found",
		"405": "Method Not Allowed",
		"406": "Not Acceptable",
		"407": "Proxy Authentication Required",
		"408": "Request Timeout",
		"409": "Conflict",
		"410": "Gone",
		"411": "Length Required",
		"412": "Precondition Failed",
		"413": "Payload Too Large",
		"414": "URI Too Long",
		"415": "Unsupported Media Type",
		"416": "Range Not Satisfiable",
		"417": "Expectation Failed",
		"418": "I'm a Teapot",
		"421": "Misdirected Request",
		"422": "Unprocessable Entity",
		"423": "Locked",
		"424": "Failed Dependency",
		"425": "Too Early",
		"426": "Upgrade Required",
		"428": "Precondition Required",
		"429": "Too Many Requests",
		"431": "Request Header Fields Too Large",
		"451": "Unavailable For Legal Reasons",
		"500": "Internal Server Error",
		"501": "Not Implemented",
		"502": "Bad Gateway",
		"503": "Service Unavailable",
		"504": "Gateway Timeout",
		"505": "HTTP Version Not Supported",
		"506": "Variant Also Negotiates",
		"507": "Insufficient Storage",
		"508": "Loop Detected",
		"509": "Bandwidth Limit Exceeded",
		"510": "Not Extended",
		"511": "Network Authentication Required"
	};
} });
var require_statuses = __commonJS({ "../../node_modules/.pnpm/statuses@2.0.2/node_modules/statuses/index.js"(exports$1, module$1) {
	var codes = require_codes();
	module$1.exports = status2;
	status2.message = codes;
	status2.code = createMessageToStatusCodeMap(codes);
	status2.codes = createStatusCodeList(codes);
	status2.redirect = {
		300: true,
		301: true,
		302: true,
		303: true,
		305: true,
		307: true,
		308: true
	};
	status2.empty = {
		204: true,
		205: true,
		304: true
	};
	status2.retry = {
		502: true,
		503: true,
		504: true
	};
	function createMessageToStatusCodeMap(codes2) {
		var map = {};
		Object.keys(codes2).forEach(function forEachCode(code) {
			var message = codes2[code];
			var status3 = Number(code);
			map[message.toLowerCase()] = status3;
		});
		return map;
	}
	function createStatusCodeList(codes2) {
		return Object.keys(codes2).map(function mapCode(code) {
			return Number(code);
		});
	}
	function getStatusCode(message) {
		var msg = message.toLowerCase();
		if (!Object.prototype.hasOwnProperty.call(status2.code, msg)) throw new Error("invalid status message: \"" + message + "\"");
		return status2.code[msg];
	}
	function getStatusMessage(code) {
		if (!Object.prototype.hasOwnProperty.call(status2.message, code)) throw new Error("invalid status code: " + code);
		return status2.message[code];
	}
	function status2(code) {
		if (typeof code === "number") return getStatusMessage(code);
		if (typeof code !== "string") throw new TypeError("code must be a number or string");
		var n = parseInt(code, 10);
		if (!isNaN(n)) return getStatusMessage(n);
		return getStatusCode(code);
	}
} });
var TimeDuration = class _TimeDuration {
	__time_duration_micros__;
	static MICROS_PER_MILLIS = 1000n;
	/**
	* Get the algebraic type representation of the {@link TimeDuration} type.
	* @returns The algebraic type representation of the type.
	*/
	static getAlgebraicType() {
		return AlgebraicType.Product({ elements: [{
			name: "__time_duration_micros__",
			algebraicType: AlgebraicType.I64
		}] });
	}
	static isTimeDuration(algebraicType) {
		if (algebraicType.tag !== "Product") return false;
		const elements = algebraicType.value.elements;
		if (elements.length !== 1) return false;
		const microsElement = elements[0];
		return microsElement.name === "__time_duration_micros__" && microsElement.algebraicType.tag === "I64";
	}
	get micros() {
		return this.__time_duration_micros__;
	}
	get millis() {
		return Number(this.micros / _TimeDuration.MICROS_PER_MILLIS);
	}
	constructor(micros) {
		this.__time_duration_micros__ = micros;
	}
	static fromMillis(millis) {
		return new _TimeDuration(BigInt(millis) * _TimeDuration.MICROS_PER_MILLIS);
	}
	/** This outputs the same string format that we use in the host and in Rust modules */
	toString() {
		const micros = this.micros;
		const sign = micros < 0 ? "-" : "+";
		const pos = micros < 0 ? -micros : micros;
		const secs = pos / 1000000n;
		const micros_remaining = pos % 1000000n;
		return `${sign}${secs}.${String(micros_remaining).padStart(6, "0")}`;
	}
};
var Timestamp = class _Timestamp {
	__timestamp_micros_since_unix_epoch__;
	static MICROS_PER_MILLIS = 1000n;
	get microsSinceUnixEpoch() {
		return this.__timestamp_micros_since_unix_epoch__;
	}
	constructor(micros) {
		this.__timestamp_micros_since_unix_epoch__ = micros;
	}
	/**
	* Get the algebraic type representation of the {@link Timestamp} type.
	* @returns The algebraic type representation of the type.
	*/
	static getAlgebraicType() {
		return AlgebraicType.Product({ elements: [{
			name: "__timestamp_micros_since_unix_epoch__",
			algebraicType: AlgebraicType.I64
		}] });
	}
	static isTimestamp(algebraicType) {
		if (algebraicType.tag !== "Product") return false;
		const elements = algebraicType.value.elements;
		if (elements.length !== 1) return false;
		const microsElement = elements[0];
		return microsElement.name === "__timestamp_micros_since_unix_epoch__" && microsElement.algebraicType.tag === "I64";
	}
	/**
	* The Unix epoch, the midnight at the beginning of January 1, 1970, UTC.
	*/
	static UNIX_EPOCH = new _Timestamp(0n);
	/**
	* Get a `Timestamp` representing the execution environment's belief of the current moment in time.
	*/
	static now() {
		return _Timestamp.fromDate(/* @__PURE__ */ new Date());
	}
	/** Convert to milliseconds since Unix epoch. */
	toMillis() {
		return this.microsSinceUnixEpoch / 1000n;
	}
	/**
	* Get a `Timestamp` representing the same point in time as `date`.
	*/
	static fromDate(date) {
		const millis = date.getTime();
		return new _Timestamp(BigInt(millis) * _Timestamp.MICROS_PER_MILLIS);
	}
	/**
	* Get a `Date` representing approximately the same point in time as `this`.
	*
	* This method truncates to millisecond precision,
	* and throws `RangeError` if the `Timestamp` is outside the range representable as a `Date`.
	*/
	toDate() {
		const millis = this.__timestamp_micros_since_unix_epoch__ / _Timestamp.MICROS_PER_MILLIS;
		if (millis > BigInt(Number.MAX_SAFE_INTEGER) || millis < BigInt(Number.MIN_SAFE_INTEGER)) throw new RangeError("Timestamp is outside of the representable range of JS's Date");
		return new Date(Number(millis));
	}
	since(other) {
		return new TimeDuration(this.__timestamp_micros_since_unix_epoch__ - other.__timestamp_micros_since_unix_epoch__);
	}
};
var Uuid = class _Uuid {
	__uuid__;
	/**
	* The nil UUID (all zeros).
	*
	* @example
	* ```ts
	* const uuid = Uuid.NIL;
	* console.assert(
	*   uuid.toString() === "00000000-0000-0000-0000-000000000000"
	* );
	* ```
	*/
	static NIL = new _Uuid(0n);
	static MAX_UUID_BIGINT = 340282366920938463463374607431768211455n;
	/**
	* The max UUID (all ones).
	*
	* @example
	* ```ts
	* const uuid = Uuid.MAX;
	* console.assert(
	*   uuid.toString() === "ffffffff-ffff-ffff-ffff-ffffffffffff"
	* );
	* ```
	*/
	static MAX = new _Uuid(_Uuid.MAX_UUID_BIGINT);
	/**
	* Create a UUID from a raw 128-bit value.
	*
	* @param u - Unsigned 128-bit integer
	* @throws {Error} If the value is outside the valid UUID range
	*/
	constructor(u) {
		if (u < 0n || u > _Uuid.MAX_UUID_BIGINT) throw new Error("Invalid UUID: must be between 0 and `MAX_UUID_BIGINT`");
		this.__uuid__ = u;
	}
	/**
	* Create a UUID `v4` from explicit random bytes.
	*
	* This method assumes the bytes are already sufficiently random.
	* It only sets the appropriate bits for the UUID version and variant.
	*
	* @param bytes - Exactly 16 random bytes
	* @returns A UUID `v4`
	* @throws {Error} If `bytes.length !== 16`
	*
	* @example
	* ```ts
	* const randomBytes = new Uint8Array(16);
	* const uuid = Uuid.fromRandomBytesV4(randomBytes);
	*
	* console.assert(
	*   uuid.toString() === "00000000-0000-4000-8000-000000000000"
	* );
	* ```
	*/
	static fromRandomBytesV4(bytes) {
		if (bytes.length !== 16) throw new Error("UUID v4 requires 16 bytes");
		const arr = new Uint8Array(bytes);
		arr[6] = arr[6] & 15 | 64;
		arr[8] = arr[8] & 63 | 128;
		return new _Uuid(_Uuid.bytesToBigInt(arr));
	}
	/**
	* Generate a UUID `v7` using a monotonic counter from `0` to `2^31 - 1`,
	* a timestamp, and 4 random bytes.
	*
	* The counter wraps around on overflow.
	*
	* The UUID `v7` is structured as follows:
	*
	* ```ascii
	* ┌───────────────────────────────────────────────┬───────────────────┐
	* | B0  | B1  | B2  | B3  | B4  | B5              |         B6        |
	* ├───────────────────────────────────────────────┼───────────────────┤
	* |                 unix_ts_ms                    |      version 7    |
	* └───────────────────────────────────────────────┴───────────────────┘
	* ┌──────────────┬─────────┬──────────────────┬───────────────────────┐
	* | B7           | B8      | B9  | B10 | B11  | B12 | B13 | B14 | B15 |
	* ├──────────────┼─────────┼──────────────────┼───────────────────────┤
	* | counter_high | variant |    counter_low   |        random         |
	* └──────────────┴─────────┴──────────────────┴───────────────────────┘
	* ```
	*
	* @param counter - Mutable monotonic counter (31-bit)
	* @param now - Timestamp since the Unix epoch
	* @param randomBytes - Exactly 4 random bytes
	* @returns A UUID `v7`
	*
	* @throws {Error} If the `counter` is negative
	* @throws {Error} If the `timestamp` is before the Unix epoch
	* @throws {Error} If `randomBytes.length !== 4`
	*
	* @example
	* ```ts
	* const now = Timestamp.fromMillis(1_686_000_000_000n);
	* const counter = { value: 1 };
	* const randomBytes = new Uint8Array(4);
	*
	* const uuid = Uuid.fromCounterV7(counter, now, randomBytes);
	*
	* console.assert(
	*   uuid.toString() === "0000647e-5180-7000-8000-000200000000"
	* );
	* ```
	*/
	static fromCounterV7(counter, now, randomBytes) {
		if (randomBytes.length !== 4) throw new Error("`fromCounterV7` requires `randomBytes.length == 4`");
		if (counter.value < 0) throw new Error("`fromCounterV7` uuid `counter` must be non-negative");
		if (now.__timestamp_micros_since_unix_epoch__ < 0) throw new Error("`fromCounterV7` `timestamp` before unix epoch");
		const counterVal = counter.value;
		counter.value = counterVal + 1 & 2147483647;
		const tsMs = now.toMillis() & 281474976710655n;
		const bytes = new Uint8Array(16);
		bytes[0] = Number(tsMs >> 40n & 255n);
		bytes[1] = Number(tsMs >> 32n & 255n);
		bytes[2] = Number(tsMs >> 24n & 255n);
		bytes[3] = Number(tsMs >> 16n & 255n);
		bytes[4] = Number(tsMs >> 8n & 255n);
		bytes[5] = Number(tsMs & 255n);
		bytes[7] = counterVal >>> 23 & 255;
		bytes[9] = counterVal >>> 15 & 255;
		bytes[10] = counterVal >>> 7 & 255;
		bytes[11] = (counterVal & 127) << 1 & 255;
		bytes[12] |= randomBytes[0] & 127;
		bytes[13] = randomBytes[1];
		bytes[14] = randomBytes[2];
		bytes[15] = randomBytes[3];
		bytes[6] = bytes[6] & 15 | 112;
		bytes[8] = bytes[8] & 63 | 128;
		return new _Uuid(_Uuid.bytesToBigInt(bytes));
	}
	/**
	* Parse a UUID from a string representation.
	*
	* @param s - UUID string
	* @returns Parsed UUID
	* @throws {Error} If the string is not a valid UUID
	*
	* @example
	* ```ts
	* const s = "01888d6e-5c00-7000-8000-000000000000";
	* const uuid = Uuid.parse(s);
	*
	* console.assert(uuid.toString() === s);
	* ```
	*/
	static parse(s) {
		const hex = s.replace(/-/g, "");
		if (hex.length !== 32) throw new Error("Invalid hex UUID");
		let v = 0n;
		for (let i = 0; i < 32; i += 2) v = v << 8n | BigInt(parseInt(hex.slice(i, i + 2), 16));
		return new _Uuid(v);
	}
	/** Convert to string (hyphenated form). */
	toString() {
		const hex = [..._Uuid.bigIntToBytes(this.__uuid__)].map((b) => b.toString(16).padStart(2, "0")).join("");
		return hex.slice(0, 8) + "-" + hex.slice(8, 12) + "-" + hex.slice(12, 16) + "-" + hex.slice(16, 20) + "-" + hex.slice(20);
	}
	/** Convert to bigint (u128). */
	asBigInt() {
		return this.__uuid__;
	}
	/** Return a `Uint8Array` of 16 bytes. */
	toBytes() {
		return _Uuid.bigIntToBytes(this.__uuid__);
	}
	static bytesToBigInt(bytes) {
		let result = 0n;
		for (const b of bytes) result = result << 8n | BigInt(b);
		return result;
	}
	static bigIntToBytes(value) {
		const bytes = new Uint8Array(16);
		for (let i = 15; i >= 0; i--) {
			bytes[i] = Number(value & 255n);
			value >>= 8n;
		}
		return bytes;
	}
	/**
	* Returns the version of this UUID.
	*
	* This represents the algorithm used to generate the value.
	*
	* @returns A `UuidVersion`
	* @throws {Error} If the version field is not recognized
	*/
	getVersion() {
		const version = this.toBytes()[6] >> 4 & 15;
		switch (version) {
			case 4: return "V4";
			case 7: return "V7";
			default:
				if (this == _Uuid.NIL) return "Nil";
				if (this == _Uuid.MAX) return "Max";
				throw new Error(`Unsupported UUID version: ${version}`);
		}
	}
	/**
	* Extract the monotonic counter from a UUIDv7.
	*
	* Intended for testing and diagnostics.
	* Behavior is undefined if called on a non-V7 UUID.
	*
	* @returns 31-bit counter value
	*/
	getCounter() {
		const bytes = this.toBytes();
		const high = bytes[7];
		const mid1 = bytes[9];
		const mid2 = bytes[10];
		const low = bytes[11] >>> 1;
		return high << 23 | mid1 << 15 | mid2 << 7 | low | 0;
	}
	compareTo(other) {
		if (this.__uuid__ < other.__uuid__) return -1;
		if (this.__uuid__ > other.__uuid__) return 1;
		return 0;
	}
	static getAlgebraicType() {
		return AlgebraicType.Product({ elements: [{
			name: "__uuid__",
			algebraicType: AlgebraicType.U128
		}] });
	}
};
var BinaryReader = class {
	/**
	* The DataView used to read values from the binary data.
	*
	* Note: The DataView's `byteOffset` is relative to the beginning of the
	* underlying ArrayBuffer, not the start of the provided Uint8Array input.
	* This `BinaryReader`'s `#offset` field is used to track the current read position
	* relative to the start of the provided Uint8Array input.
	*/
	#view;
	/**
	* Represents the offset (in bytes) relative to the start of the DataView
	* and provided Uint8Array input.
	*
	* Note: This is *not* the absolute byte offset within the underlying ArrayBuffer.
	*/
	#offset = 0;
	constructor(input) {
		this.#view = new DataView(input.buffer, input.byteOffset, input.byteLength);
		this.#offset = 0;
	}
	get offset() {
		return this.#offset;
	}
	get remaining() {
		return this.#view.byteLength - this.#offset;
	}
	/** Ensure we have at least `n` bytes left to read */
	#ensure(n) {
		if (this.#offset + n > this.#view.byteLength) throw new RangeError(`Tried to read ${n} byte(s) at relative offset ${this.#offset}, but only ${this.remaining} byte(s) remain`);
	}
	readUInt8Array() {
		const length = this.readU32();
		this.#ensure(length);
		return this.readBytes(length);
	}
	readBool() {
		const value = this.#view.getUint8(this.#offset);
		this.#offset += 1;
		return value !== 0;
	}
	readByte() {
		const value = this.#view.getUint8(this.#offset);
		this.#offset += 1;
		return value;
	}
	readBytes(length) {
		const array = new Uint8Array(this.#view.buffer, this.#view.byteOffset + this.#offset, length);
		this.#offset += length;
		return array;
	}
	readI8() {
		const value = this.#view.getInt8(this.#offset);
		this.#offset += 1;
		return value;
	}
	readU8() {
		return this.readByte();
	}
	readI16() {
		const value = this.#view.getInt16(this.#offset, true);
		this.#offset += 2;
		return value;
	}
	readU16() {
		const value = this.#view.getUint16(this.#offset, true);
		this.#offset += 2;
		return value;
	}
	readI32() {
		const value = this.#view.getInt32(this.#offset, true);
		this.#offset += 4;
		return value;
	}
	readU32() {
		const value = this.#view.getUint32(this.#offset, true);
		this.#offset += 4;
		return value;
	}
	readI64() {
		const value = this.#view.getBigInt64(this.#offset, true);
		this.#offset += 8;
		return value;
	}
	readU64() {
		const value = this.#view.getBigUint64(this.#offset, true);
		this.#offset += 8;
		return value;
	}
	readU128() {
		const lowerPart = this.#view.getBigUint64(this.#offset, true);
		const upperPart = this.#view.getBigUint64(this.#offset + 8, true);
		this.#offset += 16;
		return (upperPart << BigInt(64)) + lowerPart;
	}
	readI128() {
		const lowerPart = this.#view.getBigUint64(this.#offset, true);
		const upperPart = this.#view.getBigInt64(this.#offset + 8, true);
		this.#offset += 16;
		return (upperPart << BigInt(64)) + lowerPart;
	}
	readU256() {
		const p0 = this.#view.getBigUint64(this.#offset, true);
		const p1 = this.#view.getBigUint64(this.#offset + 8, true);
		const p2 = this.#view.getBigUint64(this.#offset + 16, true);
		const p3 = this.#view.getBigUint64(this.#offset + 24, true);
		this.#offset += 32;
		return (p3 << BigInt(192)) + (p2 << BigInt(128)) + (p1 << BigInt(64)) + p0;
	}
	readI256() {
		const p0 = this.#view.getBigUint64(this.#offset, true);
		const p1 = this.#view.getBigUint64(this.#offset + 8, true);
		const p2 = this.#view.getBigUint64(this.#offset + 16, true);
		const p3 = this.#view.getBigInt64(this.#offset + 24, true);
		this.#offset += 32;
		return (p3 << BigInt(192)) + (p2 << BigInt(128)) + (p1 << BigInt(64)) + p0;
	}
	readF32() {
		const value = this.#view.getFloat32(this.#offset, true);
		this.#offset += 4;
		return value;
	}
	readF64() {
		const value = this.#view.getFloat64(this.#offset, true);
		this.#offset += 8;
		return value;
	}
	readString() {
		const uint8Array = this.readUInt8Array();
		return new TextDecoder("utf-8").decode(uint8Array);
	}
};
var import_base64_js = __toESM(require_base64_js());
var BinaryWriter = class {
	#buffer;
	#view;
	#offset = 0;
	constructor(size) {
		this.#buffer = new Uint8Array(size);
		this.#view = new DataView(this.#buffer.buffer);
	}
	#expandBuffer(additionalCapacity) {
		const minCapacity = this.#offset + additionalCapacity + 1;
		if (minCapacity <= this.#buffer.length) return;
		let newCapacity = this.#buffer.length * 2;
		if (newCapacity < minCapacity) newCapacity = minCapacity;
		const newBuffer = new Uint8Array(newCapacity);
		newBuffer.set(this.#buffer);
		this.#buffer = newBuffer;
		this.#view = new DataView(this.#buffer.buffer);
	}
	toBase64() {
		return (0, import_base64_js.fromByteArray)(this.#buffer.subarray(0, this.#offset));
	}
	getBuffer() {
		return this.#buffer.slice(0, this.#offset);
	}
	get offset() {
		return this.#offset;
	}
	writeUInt8Array(value) {
		const length = value.length;
		this.#expandBuffer(4 + length);
		this.writeU32(length);
		this.#buffer.set(value, this.#offset);
		this.#offset += value.length;
	}
	writeBool(value) {
		this.#expandBuffer(1);
		this.#view.setUint8(this.#offset, value ? 1 : 0);
		this.#offset += 1;
	}
	writeByte(value) {
		this.#expandBuffer(1);
		this.#view.setUint8(this.#offset, value);
		this.#offset += 1;
	}
	writeI8(value) {
		this.#expandBuffer(1);
		this.#view.setInt8(this.#offset, value);
		this.#offset += 1;
	}
	writeU8(value) {
		this.#expandBuffer(1);
		this.#view.setUint8(this.#offset, value);
		this.#offset += 1;
	}
	writeI16(value) {
		this.#expandBuffer(2);
		this.#view.setInt16(this.#offset, value, true);
		this.#offset += 2;
	}
	writeU16(value) {
		this.#expandBuffer(2);
		this.#view.setUint16(this.#offset, value, true);
		this.#offset += 2;
	}
	writeI32(value) {
		this.#expandBuffer(4);
		this.#view.setInt32(this.#offset, value, true);
		this.#offset += 4;
	}
	writeU32(value) {
		this.#expandBuffer(4);
		this.#view.setUint32(this.#offset, value, true);
		this.#offset += 4;
	}
	writeI64(value) {
		this.#expandBuffer(8);
		this.#view.setBigInt64(this.#offset, value, true);
		this.#offset += 8;
	}
	writeU64(value) {
		this.#expandBuffer(8);
		this.#view.setBigUint64(this.#offset, value, true);
		this.#offset += 8;
	}
	writeU128(value) {
		this.#expandBuffer(16);
		const lowerPart = value & BigInt("0xFFFFFFFFFFFFFFFF");
		const upperPart = value >> BigInt(64);
		this.#view.setBigUint64(this.#offset, lowerPart, true);
		this.#view.setBigUint64(this.#offset + 8, upperPart, true);
		this.#offset += 16;
	}
	writeI128(value) {
		this.#expandBuffer(16);
		const lowerPart = value & BigInt("0xFFFFFFFFFFFFFFFF");
		const upperPart = value >> BigInt(64);
		this.#view.setBigInt64(this.#offset, lowerPart, true);
		this.#view.setBigInt64(this.#offset + 8, upperPart, true);
		this.#offset += 16;
	}
	writeU256(value) {
		this.#expandBuffer(32);
		const low_64_mask = BigInt("0xFFFFFFFFFFFFFFFF");
		const p0 = value & low_64_mask;
		const p1 = value >> BigInt(64) & low_64_mask;
		const p2 = value >> BigInt(128) & low_64_mask;
		const p3 = value >> BigInt(192);
		this.#view.setBigUint64(this.#offset + 0, p0, true);
		this.#view.setBigUint64(this.#offset + 8, p1, true);
		this.#view.setBigUint64(this.#offset + 16, p2, true);
		this.#view.setBigUint64(this.#offset + 24, p3, true);
		this.#offset += 32;
	}
	writeI256(value) {
		this.#expandBuffer(32);
		const low_64_mask = BigInt("0xFFFFFFFFFFFFFFFF");
		const p0 = value & low_64_mask;
		const p1 = value >> BigInt(64) & low_64_mask;
		const p2 = value >> BigInt(128) & low_64_mask;
		const p3 = value >> BigInt(192);
		this.#view.setBigUint64(this.#offset + 0, p0, true);
		this.#view.setBigUint64(this.#offset + 8, p1, true);
		this.#view.setBigUint64(this.#offset + 16, p2, true);
		this.#view.setBigInt64(this.#offset + 24, p3, true);
		this.#offset += 32;
	}
	writeF32(value) {
		this.#expandBuffer(4);
		this.#view.setFloat32(this.#offset, value, true);
		this.#offset += 4;
	}
	writeF64(value) {
		this.#expandBuffer(8);
		this.#view.setFloat64(this.#offset, value, true);
		this.#offset += 8;
	}
	writeString(value) {
		const encodedString = new TextEncoder().encode(value);
		this.writeU32(encodedString.length);
		this.#expandBuffer(encodedString.length);
		this.#buffer.set(encodedString, this.#offset);
		this.#offset += encodedString.length;
	}
};
function toPascalCase(s) {
	const str$1 = s.replace(/([-_][a-z])/gi, ($1) => {
		return $1.toUpperCase().replace("-", "").replace("_", "");
	});
	return str$1.charAt(0).toUpperCase() + str$1.slice(1);
}
function uint8ArrayToHexString(array) {
	return Array.prototype.map.call(array.reverse(), (x) => ("00" + x.toString(16)).slice(-2)).join("");
}
function uint8ArrayToU128(array) {
	if (array.length != 16) throw new Error(`Uint8Array is not 16 bytes long: ${array}`);
	return new BinaryReader(array).readU128();
}
function uint8ArrayToU256(array) {
	if (array.length != 32) throw new Error(`Uint8Array is not 32 bytes long: [${array}]`);
	return new BinaryReader(array).readU256();
}
function hexStringToUint8Array(str$1) {
	if (str$1.startsWith("0x")) str$1 = str$1.slice(2);
	const matches = str$1.match(/.{1,2}/g) || [];
	return Uint8Array.from(matches.map((byte) => parseInt(byte, 16))).reverse();
}
function hexStringToU128(str$1) {
	return uint8ArrayToU128(hexStringToUint8Array(str$1));
}
function hexStringToU256(str$1) {
	return uint8ArrayToU256(hexStringToUint8Array(str$1));
}
function u128ToUint8Array(data) {
	const writer = new BinaryWriter(16);
	writer.writeU128(data);
	return writer.getBuffer();
}
function u128ToHexString(data) {
	return uint8ArrayToHexString(u128ToUint8Array(data));
}
function u256ToUint8Array(data) {
	const writer = new BinaryWriter(32);
	writer.writeU256(data);
	return writer.getBuffer();
}
function u256ToHexString(data) {
	return uint8ArrayToHexString(u256ToUint8Array(data));
}
function toCamelCase(str$1) {
	return str$1.replace(/[-_]+/g, "_").replace(/_([a-zA-Z0-9])/g, (_$1, c) => c.toUpperCase());
}
function bsatnBaseSize(typespace, ty) {
	const assumedArrayLength = 4;
	while (ty.tag === "Ref") ty = typespace.types[ty.value];
	if (ty.tag === "Product") {
		let sum = 0;
		for (const { algebraicType: elem } of ty.value.elements) sum += bsatnBaseSize(typespace, elem);
		return sum;
	} else if (ty.tag === "Sum") {
		let min = Infinity;
		for (const { algebraicType: vari } of ty.value.variants) {
			const vSize = bsatnBaseSize(typespace, vari);
			if (vSize < min) min = vSize;
		}
		if (min === Infinity) min = 0;
		return 4 + min;
	} else if (ty.tag == "Array") return 4 + assumedArrayLength * bsatnBaseSize(typespace, ty.value);
	return {
		String: 4 + assumedArrayLength,
		Sum: 1,
		Bool: 1,
		I8: 1,
		U8: 1,
		I16: 2,
		U16: 2,
		I32: 4,
		U32: 4,
		F32: 4,
		I64: 8,
		U64: 8,
		F64: 8,
		I128: 16,
		U128: 16,
		I256: 32,
		U256: 32
	}[ty.tag];
}
var ConnectionId = class _ConnectionId {
	__connection_id__;
	/**
	* Creates a new `ConnectionId`.
	*/
	constructor(data) {
		this.__connection_id__ = data;
	}
	/**
	* Get the algebraic type representation of the {@link ConnectionId} type.
	* @returns The algebraic type representation of the type.
	*/
	static getAlgebraicType() {
		return AlgebraicType.Product({ elements: [{
			name: "__connection_id__",
			algebraicType: AlgebraicType.U128
		}] });
	}
	isZero() {
		return this.__connection_id__ === BigInt(0);
	}
	static nullIfZero(addr) {
		if (addr.isZero()) return null;
		else return addr;
	}
	static random() {
		function randomU8() {
			return Math.floor(Math.random() * 255);
		}
		let result = BigInt(0);
		for (let i = 0; i < 16; i++) result = result << BigInt(8) | BigInt(randomU8());
		return new _ConnectionId(result);
	}
	/**
	* Compare two connection IDs for equality.
	*/
	isEqual(other) {
		return this.__connection_id__ == other.__connection_id__;
	}
	/**
	* Check if two connection IDs are equal.
	*/
	equals(other) {
		return this.isEqual(other);
	}
	/**
	* Print the connection ID as a hexadecimal string.
	*/
	toHexString() {
		return u128ToHexString(this.__connection_id__);
	}
	/**
	* Convert the connection ID to a Uint8Array.
	*/
	toUint8Array() {
		return u128ToUint8Array(this.__connection_id__);
	}
	/**
	* Parse a connection ID from a hexadecimal string.
	*/
	static fromString(str$1) {
		return new _ConnectionId(hexStringToU128(str$1));
	}
	static fromStringOrNull(str$1) {
		const addr = _ConnectionId.fromString(str$1);
		if (addr.isZero()) return null;
		else return addr;
	}
};
var Identity = class _Identity {
	__identity__;
	/**
	* Creates a new `Identity`.
	*
	* `data` can be a hexadecimal string or a `bigint`.
	*/
	constructor(data) {
		this.__identity__ = typeof data === "string" ? hexStringToU256(data) : data;
	}
	/**
	* Get the algebraic type representation of the {@link Identity} type.
	* @returns The algebraic type representation of the type.
	*/
	static getAlgebraicType() {
		return AlgebraicType.Product({ elements: [{
			name: "__identity__",
			algebraicType: AlgebraicType.U256
		}] });
	}
	/**
	* Check if two identities are equal.
	*/
	isEqual(other) {
		return this.toHexString() === other.toHexString();
	}
	/**
	* Check if two identities are equal.
	*/
	equals(other) {
		return this.isEqual(other);
	}
	/**
	* Print the identity as a hexadecimal string.
	*/
	toHexString() {
		return u256ToHexString(this.__identity__);
	}
	/**
	* Convert the address to a Uint8Array.
	*/
	toUint8Array() {
		return u256ToUint8Array(this.__identity__);
	}
	/**
	* Parse an Identity from a hexadecimal string.
	*/
	static fromString(str$1) {
		return new _Identity(str$1);
	}
	/**
	* Zero identity (0x0000000000000000000000000000000000000000000000000000000000000000)
	*/
	static zero() {
		return new _Identity(0n);
	}
	toString() {
		return this.toHexString();
	}
};
var AlgebraicType = {
	Ref: (value) => ({
		tag: "Ref",
		value
	}),
	Sum: (value) => ({
		tag: "Sum",
		value
	}),
	Product: (value) => ({
		tag: "Product",
		value
	}),
	Array: (value) => ({
		tag: "Array",
		value
	}),
	String: { tag: "String" },
	Bool: { tag: "Bool" },
	I8: { tag: "I8" },
	U8: { tag: "U8" },
	I16: { tag: "I16" },
	U16: { tag: "U16" },
	I32: { tag: "I32" },
	U32: { tag: "U32" },
	I64: { tag: "I64" },
	U64: { tag: "U64" },
	I128: { tag: "I128" },
	U128: { tag: "U128" },
	I256: { tag: "I256" },
	U256: { tag: "U256" },
	F32: { tag: "F32" },
	F64: { tag: "F64" },
	serializeValue(writer, ty, value, typespace) {
		if (ty.tag === "Ref") {
			if (!typespace) throw new Error("cannot serialize refs without a typespace");
			while (ty.tag === "Ref") ty = typespace.types[ty.value];
		}
		switch (ty.tag) {
			case "Product":
				ProductType.serializeValue(writer, ty.value, value, typespace);
				break;
			case "Sum":
				SumType.serializeValue(writer, ty.value, value, typespace);
				break;
			case "Array":
				if (ty.value.tag === "U8") writer.writeUInt8Array(value);
				else {
					const elemType = ty.value;
					writer.writeU32(value.length);
					for (const elem of value) AlgebraicType.serializeValue(writer, elemType, elem, typespace);
				}
				break;
			case "Bool":
				writer.writeBool(value);
				break;
			case "I8":
				writer.writeI8(value);
				break;
			case "U8":
				writer.writeU8(value);
				break;
			case "I16":
				writer.writeI16(value);
				break;
			case "U16":
				writer.writeU16(value);
				break;
			case "I32":
				writer.writeI32(value);
				break;
			case "U32":
				writer.writeU32(value);
				break;
			case "I64":
				writer.writeI64(value);
				break;
			case "U64":
				writer.writeU64(value);
				break;
			case "I128":
				writer.writeI128(value);
				break;
			case "U128":
				writer.writeU128(value);
				break;
			case "I256":
				writer.writeI256(value);
				break;
			case "U256":
				writer.writeU256(value);
				break;
			case "F32":
				writer.writeF32(value);
				break;
			case "F64":
				writer.writeF64(value);
				break;
			case "String":
				writer.writeString(value);
				break;
		}
	},
	deserializeValue: function(reader, ty, typespace) {
		if (ty.tag === "Ref") {
			if (!typespace) throw new Error("cannot deserialize refs without a typespace");
			while (ty.tag === "Ref") ty = typespace.types[ty.value];
		}
		switch (ty.tag) {
			case "Product": return ProductType.deserializeValue(reader, ty.value, typespace);
			case "Sum": return SumType.deserializeValue(reader, ty.value, typespace);
			case "Array": if (ty.value.tag === "U8") return reader.readUInt8Array();
			else {
				const elemType = ty.value;
				const length = reader.readU32();
				const result = [];
				for (let i = 0; i < length; i++) result.push(AlgebraicType.deserializeValue(reader, elemType, typespace));
				return result;
			}
			case "Bool": return reader.readBool();
			case "I8": return reader.readI8();
			case "U8": return reader.readU8();
			case "I16": return reader.readI16();
			case "U16": return reader.readU16();
			case "I32": return reader.readI32();
			case "U32": return reader.readU32();
			case "I64": return reader.readI64();
			case "U64": return reader.readU64();
			case "I128": return reader.readI128();
			case "U128": return reader.readU128();
			case "I256": return reader.readI256();
			case "U256": return reader.readU256();
			case "F32": return reader.readF32();
			case "F64": return reader.readF64();
			case "String": return reader.readString();
		}
	},
	intoMapKey: function(ty, value) {
		switch (ty.tag) {
			case "U8":
			case "U16":
			case "U32":
			case "U64":
			case "U128":
			case "U256":
			case "I8":
			case "I16":
			case "I32":
			case "I64":
			case "I128":
			case "I256":
			case "F32":
			case "F64":
			case "String":
			case "Bool": return value;
			case "Product": return ProductType.intoMapKey(ty.value, value);
			default: {
				const writer = new BinaryWriter(10);
				AlgebraicType.serializeValue(writer, ty, value);
				return writer.toBase64();
			}
		}
	}
};
var ProductType = {
	serializeValue(writer, ty, value, typespace) {
		for (const element of ty.elements) AlgebraicType.serializeValue(writer, element.algebraicType, value[element.name], typespace);
	},
	deserializeValue(reader, ty, typespace) {
		const result = {};
		if (ty.elements.length === 1) {
			if (ty.elements[0].name === "__time_duration_micros__") return new TimeDuration(reader.readI64());
			if (ty.elements[0].name === "__timestamp_micros_since_unix_epoch__") return new Timestamp(reader.readI64());
			if (ty.elements[0].name === "__identity__") return new Identity(reader.readU256());
			if (ty.elements[0].name === "__connection_id__") return new ConnectionId(reader.readU128());
			if (ty.elements[0].name === "__uuid__") return new Uuid(reader.readU128());
		}
		for (const element of ty.elements) result[element.name] = AlgebraicType.deserializeValue(reader, element.algebraicType, typespace);
		return result;
	},
	intoMapKey(ty, value) {
		if (ty.elements.length === 1) {
			if (ty.elements[0].name === "__time_duration_micros__") return value.__time_duration_micros__;
			if (ty.elements[0].name === "__timestamp_micros_since_unix_epoch__") return value.__timestamp_micros_since_unix_epoch__;
			if (ty.elements[0].name === "__identity__") return value.__identity__;
			if (ty.elements[0].name === "__connection_id__") return value.__connection_id__;
			if (ty.elements[0].name === "__uuid__") return value.__uuid__;
		}
		const writer = new BinaryWriter(10);
		AlgebraicType.serializeValue(writer, AlgebraicType.Product(ty), value);
		return writer.toBase64();
	}
};
var SumType = {
	serializeValue: function(writer, ty, value, typespace) {
		if (ty.variants.length == 2 && ty.variants[0].name === "some" && ty.variants[1].name === "none") if (value !== null && value !== void 0) {
			writer.writeByte(0);
			AlgebraicType.serializeValue(writer, ty.variants[0].algebraicType, value, typespace);
		} else writer.writeByte(1);
		else if (ty.variants.length == 2 && ty.variants[0].name === "ok" && ty.variants[1].name === "err") {
			let variantName;
			let innerValue;
			let index;
			if ("ok" in value) {
				variantName = "ok";
				innerValue = value.ok;
				index = 0;
			} else {
				variantName = "err";
				innerValue = value.err;
				index = 1;
			}
			if (index < 0) throw `Result serialization error: variant '${variantName}' not found in ${JSON.stringify(ty)}`;
			writer.writeU8(index);
			AlgebraicType.serializeValue(writer, ty.variants[index].algebraicType, innerValue, typespace);
		} else {
			const variant = value["tag"];
			const index = ty.variants.findIndex((v) => v.name === variant);
			if (index < 0) throw `Can't serialize a sum type, couldn't find ${value.tag} tag ${JSON.stringify(value)} in variants ${JSON.stringify(ty)}`;
			writer.writeU8(index);
			AlgebraicType.serializeValue(writer, ty.variants[index].algebraicType, value["value"], typespace);
		}
	},
	deserializeValue: function(reader, ty, typespace) {
		const tag = reader.readU8();
		if (ty.variants.length == 2 && ty.variants[0].name === "some" && ty.variants[1].name === "none") if (tag === 0) return AlgebraicType.deserializeValue(reader, ty.variants[0].algebraicType, typespace);
		else if (tag === 1) return;
		else throw `Can't deserialize an option type, couldn't find ${tag} tag`;
		else if (ty.variants.length == 2 && ty.variants[0].name === "ok" && ty.variants[1].name === "err") if (tag === 0) return { ok: AlgebraicType.deserializeValue(reader, ty.variants[0].algebraicType, typespace) };
		else if (tag === 1) return { err: AlgebraicType.deserializeValue(reader, ty.variants[1].algebraicType, typespace) };
		else throw `Can't deserialize a result type, couldn't find ${tag} tag`;
		else {
			const variant = ty.variants[tag];
			const value = AlgebraicType.deserializeValue(reader, variant.algebraicType, typespace);
			return {
				tag: variant.name,
				value
			};
		}
	}
};
var Option = { getAlgebraicType(innerType) {
	return AlgebraicType.Sum({ variants: [{
		name: "some",
		algebraicType: innerType
	}, {
		name: "none",
		algebraicType: AlgebraicType.Product({ elements: [] })
	}] });
} };
var Result = { getAlgebraicType(okType, errType) {
	return AlgebraicType.Sum({ variants: [{
		name: "ok",
		algebraicType: okType
	}, {
		name: "err",
		algebraicType: errType
	}] });
} };
var ScheduleAt = {
	interval(value) {
		return Interval(value);
	},
	time(value) {
		return Time(value);
	},
	getAlgebraicType() {
		return AlgebraicType.Sum({ variants: [{
			name: "Interval",
			algebraicType: TimeDuration.getAlgebraicType()
		}, {
			name: "Time",
			algebraicType: Timestamp.getAlgebraicType()
		}] });
	},
	isScheduleAt(algebraicType) {
		if (algebraicType.tag !== "Sum") return false;
		const variants = algebraicType.value.variants;
		if (variants.length !== 2) return false;
		const intervalVariant = variants.find((v) => v.name === "Interval");
		const timeVariant = variants.find((v) => v.name === "Time");
		if (!intervalVariant || !timeVariant) return false;
		return TimeDuration.isTimeDuration(intervalVariant.algebraicType) && Timestamp.isTimestamp(timeVariant.algebraicType);
	}
};
var Interval = (micros) => ({
	tag: "Interval",
	value: new TimeDuration(micros)
});
var Time = (microsSinceUnixEpoch) => ({
	tag: "Time",
	value: new Timestamp(microsSinceUnixEpoch)
});
var schedule_at_default = ScheduleAt;
function set(x, t2) {
	return {
		...x,
		...t2
	};
}
var TypeBuilder = class {
	/**
	* The TypeScript phantom type. This is not stored at runtime,
	* but is visible to the compiler
	*/
	type;
	/**
	* The SpacetimeDB algebraic type (run‑time value). In addition to storing
	* the runtime representation of the `AlgebraicType`, it also captures
	* the TypeScript type information of the `AlgebraicType`. That is to say
	* the value is not merely an `AlgebraicType`, but is constructed to be
	* the corresponding concrete `AlgebraicType` for the TypeScript type `Type`.
	*
	* e.g. `string` corresponds to `AlgebraicType.String`
	*/
	algebraicType;
	constructor(algebraicType) {
		this.algebraicType = algebraicType;
	}
	optional() {
		return new OptionBuilder(this);
	}
	serialize(writer, value) {
		AlgebraicType.serializeValue(writer, this.algebraicType, value);
	}
	deserialize(reader) {
		return AlgebraicType.deserializeValue(reader, this.algebraicType);
	}
};
var U8Builder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.U8);
	}
	index(algorithm = "btree") {
		return new U8ColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new U8ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new U8ColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new U8ColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new U8ColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new U8ColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var U16Builder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.U16);
	}
	index(algorithm = "btree") {
		return new U16ColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new U16ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new U16ColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new U16ColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new U16ColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new U16ColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var U32Builder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.U32);
	}
	index(algorithm = "btree") {
		return new U32ColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new U32ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new U32ColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new U32ColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new U32ColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new U32ColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var U64Builder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.U64);
	}
	index(algorithm = "btree") {
		return new U64ColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new U64ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new U64ColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new U64ColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new U64ColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new U64ColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var U128Builder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.U128);
	}
	index(algorithm = "btree") {
		return new U128ColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new U128ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new U128ColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new U128ColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new U128ColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new U128ColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var U256Builder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.U256);
	}
	index(algorithm = "btree") {
		return new U256ColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new U256ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new U256ColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new U256ColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new U256ColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new U256ColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var I8Builder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.I8);
	}
	index(algorithm = "btree") {
		return new I8ColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new I8ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new I8ColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new I8ColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new I8ColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new I8ColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var I16Builder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.I16);
	}
	index(algorithm = "btree") {
		return new I16ColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new I16ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new I16ColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new I16ColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new I16ColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new I16ColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var I32Builder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.I32);
	}
	index(algorithm = "btree") {
		return new I32ColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new I32ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new I32ColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new I32ColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new I32ColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new I32ColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var I64Builder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.I64);
	}
	index(algorithm = "btree") {
		return new I64ColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new I64ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new I64ColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new I64ColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new I64ColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new I64ColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var I128Builder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.I128);
	}
	index(algorithm = "btree") {
		return new I128ColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new I128ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new I128ColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new I128ColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new I128ColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new I128ColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var I256Builder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.I256);
	}
	index(algorithm = "btree") {
		return new I256ColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new I256ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new I256ColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new I256ColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new I256ColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new I256ColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var F32Builder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.F32);
	}
	default(value) {
		return new F32ColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new F32ColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var F64Builder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.F64);
	}
	default(value) {
		return new F64ColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new F64ColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var BoolBuilder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.Bool);
	}
	index(algorithm = "btree") {
		return new BoolColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new BoolColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new BoolColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	default(value) {
		return new BoolColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new BoolColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var StringBuilder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.String);
	}
	index(algorithm = "btree") {
		return new StringColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new StringColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new StringColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	default(value) {
		return new StringColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new StringColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var ArrayBuilder = class extends TypeBuilder {
	element;
	constructor(element) {
		super(AlgebraicType.Array(element.algebraicType));
		this.element = element;
	}
	default(value) {
		return new ArrayColumnBuilder(this.element, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new ArrayColumnBuilder(this.element, set(defaultMetadata, { name }));
	}
};
var ByteArrayBuilder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.Array(AlgebraicType.U8));
	}
	default(value) {
		return new ByteArrayColumnBuilder(set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new ByteArrayColumnBuilder(set(defaultMetadata, { name }));
	}
};
var OptionBuilder = class extends TypeBuilder {
	value;
	constructor(value) {
		super(Option.getAlgebraicType(value.algebraicType));
		this.value = value;
	}
	default(value) {
		return new OptionColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new OptionColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var ProductBuilder = class extends TypeBuilder {
	typeName;
	elements;
	constructor(elements, name) {
		function elementsArrayFromElementsObj(obj) {
			return Object.keys(obj).map((key) => ({
				name: key,
				get algebraicType() {
					return obj[key].algebraicType;
				}
			}));
		}
		super(AlgebraicType.Product({ elements: elementsArrayFromElementsObj(elements) }));
		this.typeName = name;
		this.elements = elements;
	}
	default(value) {
		return new ProductColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new ProductColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var ResultBuilder = class extends TypeBuilder {
	ok;
	err;
	constructor(ok, err) {
		super(Result.getAlgebraicType(ok.algebraicType, err.algebraicType));
		this.ok = ok;
		this.err = err;
	}
	default(value) {
		return new ResultColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
};
var UnitBuilder = class extends TypeBuilder {
	constructor() {
		super({
			tag: "Product",
			value: { elements: [] }
		});
	}
};
var RowBuilder = class extends TypeBuilder {
	row;
	typeName;
	constructor(row, name) {
		const mappedRow = Object.fromEntries(Object.entries(row).map(([colName, builder]) => [colName, builder instanceof ColumnBuilder ? builder : new ColumnBuilder(builder, {})]));
		const elements = Object.keys(mappedRow).map((name2) => ({
			name: name2,
			get algebraicType() {
				return mappedRow[name2].typeBuilder.algebraicType;
			}
		}));
		super(AlgebraicType.Product({ elements }));
		this.row = mappedRow;
		this.typeName = name;
	}
};
var SumBuilderImpl = class extends TypeBuilder {
	variants;
	typeName;
	constructor(variants, name) {
		function variantsArrayFromVariantsObj(variants2) {
			return Object.keys(variants2).map((key) => ({
				name: key,
				get algebraicType() {
					return variants2[key].algebraicType;
				}
			}));
		}
		super(AlgebraicType.Sum({ variants: variantsArrayFromVariantsObj(variants) }));
		this.variants = variants;
		this.typeName = name;
		for (const key of Object.keys(variants)) {
			const desc = Object.getOwnPropertyDescriptor(variants, key);
			const isAccessor = !!desc && (typeof desc.get === "function" || typeof desc.set === "function");
			let isUnit2 = false;
			if (!isAccessor) isUnit2 = variants[key] instanceof UnitBuilder;
			if (isUnit2) {
				const constant = this.create(key);
				Object.defineProperty(this, key, {
					value: constant,
					writable: false,
					enumerable: true,
					configurable: false
				});
			} else {
				const fn = ((value) => this.create(key, value));
				Object.defineProperty(this, key, {
					value: fn,
					writable: false,
					enumerable: true,
					configurable: false
				});
			}
		}
	}
	create(tag, value) {
		return value === void 0 ? { tag } : {
			tag,
			value
		};
	}
	default(value) {
		return new SumColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new SumColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var SumBuilder = SumBuilderImpl;
var SimpleSumBuilderImpl = class extends SumBuilderImpl {
	index(algorithm = "btree") {
		return new SimpleSumColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	primaryKey() {
		return new SimpleSumColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
};
var ScheduleAtBuilder = class extends TypeBuilder {
	constructor() {
		super(schedule_at_default.getAlgebraicType());
	}
	default(value) {
		return new ScheduleAtColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new ScheduleAtColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var IdentityBuilder = class extends TypeBuilder {
	constructor() {
		super(Identity.getAlgebraicType());
	}
	index(algorithm = "btree") {
		return new IdentityColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new IdentityColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new IdentityColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new IdentityColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new IdentityColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new IdentityColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var ConnectionIdBuilder = class extends TypeBuilder {
	constructor() {
		super(ConnectionId.getAlgebraicType());
	}
	index(algorithm = "btree") {
		return new ConnectionIdColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new ConnectionIdColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new ConnectionIdColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new ConnectionIdColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new ConnectionIdColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new ConnectionIdColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var TimestampBuilder = class extends TypeBuilder {
	constructor() {
		super(Timestamp.getAlgebraicType());
	}
	index(algorithm = "btree") {
		return new TimestampColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new TimestampColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new TimestampColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new TimestampColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new TimestampColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new TimestampColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var TimeDurationBuilder = class extends TypeBuilder {
	constructor() {
		super(TimeDuration.getAlgebraicType());
	}
	index(algorithm = "btree") {
		return new TimeDurationColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new TimeDurationColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new TimeDurationColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new TimeDurationColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new TimeDurationColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new TimeDurationColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var UuidBuilder = class extends TypeBuilder {
	constructor() {
		super(Uuid.getAlgebraicType());
	}
	index(algorithm = "btree") {
		return new UuidColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new UuidColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new UuidColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new UuidColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new UuidColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
};
var defaultMetadata = {};
var ColumnBuilder = class {
	typeBuilder;
	columnMetadata;
	constructor(typeBuilder, metadata) {
		this.typeBuilder = typeBuilder;
		this.columnMetadata = metadata;
	}
	serialize(writer, value) {
		AlgebraicType.serializeValue(writer, this.typeBuilder.algebraicType, value);
	}
	deserialize(reader) {
		return AlgebraicType.deserializeValue(reader, this.typeBuilder.algebraicType);
	}
};
var U8ColumnBuilder = class _U8ColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _U8ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _U8ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _U8ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new _U8ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new _U8ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _U8ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var U16ColumnBuilder = class _U16ColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _U16ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _U16ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _U16ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new _U16ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new _U16ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _U16ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var U32ColumnBuilder = class _U32ColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _U32ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _U32ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _U32ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new _U32ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new _U32ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _U32ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var U64ColumnBuilder = class _U64ColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _U64ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _U64ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _U64ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new _U64ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new _U64ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _U64ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var U128ColumnBuilder = class _U128ColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _U128ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _U128ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _U128ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new _U128ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new _U128ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _U128ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var U256ColumnBuilder = class _U256ColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _U256ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _U256ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _U256ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new _U256ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new _U256ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _U256ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var I8ColumnBuilder = class _I8ColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _I8ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _I8ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _I8ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new _I8ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new _I8ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _I8ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var I16ColumnBuilder = class _I16ColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _I16ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _I16ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _I16ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new _I16ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new _I16ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _I16ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var I32ColumnBuilder = class _I32ColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _I32ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _I32ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _I32ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new _I32ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new _I32ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _I32ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var I64ColumnBuilder = class _I64ColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _I64ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _I64ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _I64ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new _I64ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new _I64ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _I64ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var I128ColumnBuilder = class _I128ColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _I128ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _I128ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _I128ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new _I128ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new _I128ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _I128ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var I256ColumnBuilder = class _I256ColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _I256ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _I256ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _I256ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new _I256ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new _I256ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _I256ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var F32ColumnBuilder = class _F32ColumnBuilder extends ColumnBuilder {
	default(value) {
		return new _F32ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _F32ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var F64ColumnBuilder = class _F64ColumnBuilder extends ColumnBuilder {
	default(value) {
		return new _F64ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _F64ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var BoolColumnBuilder = class _BoolColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _BoolColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _BoolColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _BoolColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	default(value) {
		return new _BoolColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _BoolColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var StringColumnBuilder = class _StringColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _StringColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _StringColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _StringColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	default(value) {
		return new _StringColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _StringColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var ArrayColumnBuilder = class _ArrayColumnBuilder extends ColumnBuilder {
	default(value) {
		return new _ArrayColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _ArrayColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var ByteArrayColumnBuilder = class _ByteArrayColumnBuilder extends ColumnBuilder {
	constructor(metadata) {
		super(new TypeBuilder(AlgebraicType.Array(AlgebraicType.U8)), metadata);
	}
	default(value) {
		return new _ByteArrayColumnBuilder(set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _ByteArrayColumnBuilder(set(this.columnMetadata, { name }));
	}
};
var OptionColumnBuilder = class _OptionColumnBuilder extends ColumnBuilder {
	default(value) {
		return new _OptionColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _OptionColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var ResultColumnBuilder = class _ResultColumnBuilder extends ColumnBuilder {
	constructor(typeBuilder, metadata) {
		super(typeBuilder, metadata);
	}
	default(value) {
		return new _ResultColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
};
var ProductColumnBuilder = class _ProductColumnBuilder extends ColumnBuilder {
	default(value) {
		return new _ProductColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _ProductColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var SumColumnBuilder = class _SumColumnBuilder extends ColumnBuilder {
	default(value) {
		return new _SumColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _SumColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var SimpleSumColumnBuilder = class _SimpleSumColumnBuilder extends SumColumnBuilder {
	index(algorithm = "btree") {
		return new _SimpleSumColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	primaryKey() {
		return new _SimpleSumColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
};
var ScheduleAtColumnBuilder = class _ScheduleAtColumnBuilder extends ColumnBuilder {
	default(value) {
		return new _ScheduleAtColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _ScheduleAtColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var IdentityColumnBuilder = class _IdentityColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _IdentityColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _IdentityColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _IdentityColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	default(value) {
		return new _IdentityColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _IdentityColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var ConnectionIdColumnBuilder = class _ConnectionIdColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _ConnectionIdColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _ConnectionIdColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _ConnectionIdColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	default(value) {
		return new _ConnectionIdColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _ConnectionIdColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var TimestampColumnBuilder = class _TimestampColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _TimestampColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _TimestampColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _TimestampColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	default(value) {
		return new _TimestampColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _TimestampColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var TimeDurationColumnBuilder = class _TimeDurationColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _TimeDurationColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _TimeDurationColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _TimeDurationColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	default(value) {
		return new _TimeDurationColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _TimeDurationColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var UuidColumnBuilder = class _UuidColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _UuidColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _UuidColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _UuidColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	default(value) {
		return new _UuidColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
};
var RefBuilder = class extends TypeBuilder {
	ref;
	/** The phantom type of the pointee of this ref. */
	__spacetimeType;
	constructor(ref) {
		super(AlgebraicType.Ref(ref));
		this.ref = ref;
	}
};
var enumImpl = ((nameOrObj, maybeObj) => {
	let obj = nameOrObj;
	let name = void 0;
	if (typeof nameOrObj === "string") {
		if (!maybeObj) throw new TypeError("When providing a name, you must also provide the variants object or array.");
		obj = maybeObj;
		name = nameOrObj;
	}
	if (Array.isArray(obj)) {
		const simpleVariantsObj = {};
		for (const variant of obj) simpleVariantsObj[variant] = new UnitBuilder();
		return new SimpleSumBuilderImpl(simpleVariantsObj, name);
	}
	return new SumBuilder(obj, name);
});
var t = {
	bool: () => new BoolBuilder(),
	string: () => new StringBuilder(),
	number: () => new F64Builder(),
	i8: () => new I8Builder(),
	u8: () => new U8Builder(),
	i16: () => new I16Builder(),
	u16: () => new U16Builder(),
	i32: () => new I32Builder(),
	u32: () => new U32Builder(),
	i64: () => new I64Builder(),
	u64: () => new U64Builder(),
	i128: () => new I128Builder(),
	u128: () => new U128Builder(),
	i256: () => new I256Builder(),
	u256: () => new U256Builder(),
	f32: () => new F32Builder(),
	f64: () => new F64Builder(),
	object: ((nameOrObj, maybeObj) => {
		if (typeof nameOrObj === "string") {
			if (!maybeObj) throw new TypeError("When providing a name, you must also provide the object.");
			return new ProductBuilder(maybeObj, nameOrObj);
		}
		return new ProductBuilder(nameOrObj, void 0);
	}),
	row: ((nameOrObj, maybeObj) => {
		const [obj, name] = typeof nameOrObj === "string" ? [maybeObj, nameOrObj] : [nameOrObj, void 0];
		return new RowBuilder(obj, name);
	}),
	array(e) {
		return new ArrayBuilder(e);
	},
	enum: enumImpl,
	unit() {
		return new UnitBuilder();
	},
	lazy(thunk) {
		let cached = null;
		const get = () => cached ??= thunk();
		return new Proxy({}, {
			get(_t, prop, recv) {
				const target = get();
				const val = Reflect.get(target, prop, recv);
				return typeof val === "function" ? val.bind(target) : val;
			},
			set(_t, prop, value, recv) {
				return Reflect.set(get(), prop, value, recv);
			},
			has(_t, prop) {
				return prop in get();
			},
			ownKeys() {
				return Reflect.ownKeys(get());
			},
			getOwnPropertyDescriptor(_t, prop) {
				return Object.getOwnPropertyDescriptor(get(), prop);
			},
			getPrototypeOf() {
				return Object.getPrototypeOf(get());
			}
		});
	},
	scheduleAt: () => {
		return new ScheduleAtBuilder();
	},
	option(value) {
		return new OptionBuilder(value);
	},
	result(ok, err) {
		return new ResultBuilder(ok, err);
	},
	identity: () => {
		return new IdentityBuilder();
	},
	connectionId: () => {
		return new ConnectionIdBuilder();
	},
	timestamp: () => {
		return new TimestampBuilder();
	},
	timeDuration: () => {
		return new TimeDurationBuilder();
	},
	uuid: () => {
		return new UuidBuilder();
	},
	byteArray: () => {
		return new ByteArrayBuilder();
	}
};
var lifecycle_type_default = t.enum("Lifecycle", {
	Init: t.unit(),
	OnConnect: t.unit(),
	OnDisconnect: t.unit()
});
function pushReducer(name, params, fn, lifecycle) {
	if (existingReducers.has(name)) throw new TypeError(`There is already a reducer with the name '${name}'`);
	existingReducers.add(name);
	if (!(params instanceof RowBuilder)) params = new RowBuilder(params);
	if (params.typeName === void 0) params.typeName = toPascalCase(name);
	const ref = registerTypesRecursively(params);
	const paramsType = resolveType(MODULE_DEF.typespace, ref).value;
	MODULE_DEF.reducers.push({
		name,
		params: paramsType,
		lifecycle
	});
	if (!fn.name) Object.defineProperty(fn, "name", {
		value: name,
		writable: false
	});
	REDUCERS.push(fn);
}
var existingReducers = /* @__PURE__ */ new Set();
var REDUCERS = [];
function reducer(name, params, fn) {
	pushReducer(name, params, fn);
}
function init(name, params, fn) {
	pushReducer(name, params, fn, lifecycle_type_default.Init);
}
function clientConnected(name, params, fn) {
	pushReducer(name, params, fn, lifecycle_type_default.OnConnect);
}
function clientDisconnected(name, params, fn) {
	pushReducer(name, params, fn, lifecycle_type_default.OnDisconnect);
}
var QueryBrand = Symbol("QueryBrand");
var isRowTypedQuery = (val) => !!val && typeof val === "object" && QueryBrand in val;
function toSql(q) {
	return q.toSql();
}
var SemijoinImpl = class _SemijoinImpl {
	constructor(sourceQuery, filterQuery, joinCondition) {
		this.sourceQuery = sourceQuery;
		this.filterQuery = filterQuery;
		this.joinCondition = joinCondition;
		if (sourceQuery.table.name === filterQuery.table.name) throw new Error("Cannot semijoin a table to itself");
	}
	[QueryBrand] = true;
	type = "semijoin";
	build() {
		return this;
	}
	where(predicate) {
		return new _SemijoinImpl(this.sourceQuery.where(predicate), this.filterQuery, this.joinCondition);
	}
	toSql() {
		const left = this.filterQuery;
		const right = this.sourceQuery;
		const leftTable = quoteIdentifier(left.table.name);
		const rightTable = quoteIdentifier(right.table.name);
		let sql = `SELECT ${rightTable}.* FROM ${leftTable} JOIN ${rightTable} ON ${booleanExprToSql(this.joinCondition)}`;
		const clauses = [];
		if (left.whereClause) clauses.push(booleanExprToSql(left.whereClause));
		if (right.whereClause) clauses.push(booleanExprToSql(right.whereClause));
		if (clauses.length > 0) {
			const whereSql = clauses.length === 1 ? clauses[0] : clauses.map(wrapInParens).join(" AND ");
			sql += ` WHERE ${whereSql}`;
		}
		return sql;
	}
};
var FromBuilder = class _FromBuilder {
	constructor(table2, whereClause) {
		this.table = table2;
		this.whereClause = whereClause;
	}
	[QueryBrand] = true;
	where(predicate) {
		const newCondition = predicate(this.table.cols);
		const nextWhere = this.whereClause ? and$1(this.whereClause, newCondition) : newCondition;
		return new _FromBuilder(this.table, nextWhere);
	}
	rightSemijoin(right, on) {
		const sourceQuery = new _FromBuilder(right);
		const joinCondition = on(this.table.indexedCols, right.indexedCols);
		return new SemijoinImpl(sourceQuery, this, joinCondition);
	}
	leftSemijoin(right, on) {
		const filterQuery = new _FromBuilder(right);
		const joinCondition = on(this.table.indexedCols, right.indexedCols);
		return new SemijoinImpl(this, filterQuery, joinCondition);
	}
	toSql() {
		return renderSelectSqlWithJoins(this.table, this.whereClause);
	}
	build() {
		return this;
	}
};
var TableRefImpl = class {
	type = "table";
	name;
	cols;
	indexedCols;
	tableDef;
	constructor(tableDef) {
		this.name = tableDef.name;
		this.cols = createRowExpr(tableDef);
		this.indexedCols = this.cols;
		this.tableDef = tableDef;
		Object.freeze(this);
	}
	asFrom() {
		return new FromBuilder(this);
	}
	rightSemijoin(other, on) {
		return this.asFrom().rightSemijoin(other, on);
	}
	leftSemijoin(other, on) {
		return this.asFrom().leftSemijoin(other, on);
	}
	build() {
		return this.asFrom().build();
	}
	toSql() {
		return this.asFrom().toSql();
	}
	where(predicate) {
		return this.asFrom().where(predicate);
	}
};
function createTableRefFromDef(tableDef) {
	return new TableRefImpl(tableDef);
}
function makeQueryBuilder(schema2) {
	const qb = /* @__PURE__ */ Object.create(null);
	for (const table2 of schema2.tables) {
		const ref = createTableRefFromDef(table2);
		qb[table2.name] = ref;
	}
	return Object.freeze(qb);
}
function createRowExpr(tableDef) {
	const row = {};
	for (const columnName of Object.keys(tableDef.columns)) {
		const columnBuilder = tableDef.columns[columnName];
		const column = new ColumnExpression(tableDef.name, columnName, columnBuilder.typeBuilder.algebraicType);
		row[columnName] = Object.freeze(column);
	}
	return Object.freeze(row);
}
function renderSelectSqlWithJoins(table2, where, extraClauses = []) {
	const sql = `SELECT * FROM ${quoteIdentifier(table2.name)}`;
	const clauses = [];
	if (where) clauses.push(booleanExprToSql(where));
	clauses.push(...extraClauses);
	if (clauses.length === 0) return sql;
	return `${sql} WHERE ${clauses.length === 1 ? clauses[0] : clauses.map(wrapInParens).join(" AND ")}`;
}
var ColumnExpression = class {
	type = "column";
	column;
	table;
	tsValueType;
	spacetimeType;
	constructor(table2, column, spacetimeType) {
		this.table = table2;
		this.column = column;
		this.spacetimeType = spacetimeType;
	}
	eq(x) {
		return {
			type: "eq",
			left: this,
			right: normalizeValue(x)
		};
	}
	lt(x) {
		return {
			type: "lt",
			left: this,
			right: normalizeValue(x)
		};
	}
	lte(x) {
		return {
			type: "lte",
			left: this,
			right: normalizeValue(x)
		};
	}
	gt(x) {
		return {
			type: "gt",
			left: this,
			right: normalizeValue(x)
		};
	}
	gte(x) {
		return {
			type: "gte",
			left: this,
			right: normalizeValue(x)
		};
	}
};
function literal(value) {
	return {
		type: "literal",
		value
	};
}
function normalizeValue(val) {
	if (val.type === "literal") return val;
	if (typeof val === "object" && val != null && "type" in val && val.type === "column") return val;
	return literal(val);
}
function and$1(...clauses) {
	return {
		type: "and",
		clauses
	};
}
function booleanExprToSql(expr, tableAlias) {
	switch (expr.type) {
		case "eq": return `${valueExprToSql(expr.left)} = ${valueExprToSql(expr.right)}`;
		case "ne": return `${valueExprToSql(expr.left)} <> ${valueExprToSql(expr.right)}`;
		case "gt": return `${valueExprToSql(expr.left)} > ${valueExprToSql(expr.right)}`;
		case "gte": return `${valueExprToSql(expr.left)} >= ${valueExprToSql(expr.right)}`;
		case "lt": return `${valueExprToSql(expr.left)} < ${valueExprToSql(expr.right)}`;
		case "lte": return `${valueExprToSql(expr.left)} <= ${valueExprToSql(expr.right)}`;
		case "and": return expr.clauses.map((c) => booleanExprToSql(c)).map(wrapInParens).join(" AND ");
		case "or": return expr.clauses.map((c) => booleanExprToSql(c)).map(wrapInParens).join(" OR ");
		case "not": return `NOT ${wrapInParens(booleanExprToSql(expr.clause))}`;
	}
}
function wrapInParens(sql) {
	return `(${sql})`;
}
function valueExprToSql(expr, tableAlias) {
	if (isLiteralExpr(expr)) return literalValueToSql(expr.value);
	const table2 = expr.table;
	return `${quoteIdentifier(table2)}.${quoteIdentifier(expr.column)}`;
}
function literalValueToSql(value) {
	if (value === null || value === void 0) return "NULL";
	if (value instanceof Identity || value instanceof ConnectionId) return `0x${value.toHexString()}`;
	switch (typeof value) {
		case "number":
		case "bigint": return String(value);
		case "boolean": return value ? "TRUE" : "FALSE";
		case "string": return `'${value.replace(/'/g, "''")}'`;
		default: return `'${JSON.stringify(value).replace(/'/g, "''")}'`;
	}
}
function quoteIdentifier(name) {
	return `"${name.replace(/"/g, "\"\"")}"`;
}
function isLiteralExpr(expr) {
	return expr.type === "literal";
}
function defineView(opts, anon, params, ret, fn) {
	const paramsBuilder = new RowBuilder(params, toPascalCase(opts.name));
	let returnType = registerTypesRecursively(ret).algebraicType;
	const { value: paramType } = resolveType(MODULE_DEF.typespace, registerTypesRecursively(paramsBuilder));
	MODULE_DEF.miscExports.push({
		tag: "View",
		value: {
			name: opts.name,
			index: (anon ? ANON_VIEWS : VIEWS).length,
			isPublic: opts.public,
			isAnonymous: anon,
			params: paramType,
			returnType
		}
	});
	if (returnType.tag == "Sum") {
		const originalFn = fn;
		fn = ((ctx, args) => {
			const ret2 = originalFn(ctx, args);
			return ret2 == null ? [] : [ret2];
		});
		returnType = AlgebraicType.Array(returnType.value.variants[0].algebraicType);
	}
	(anon ? ANON_VIEWS : VIEWS).push({
		fn,
		params: paramType,
		returnType,
		returnTypeBaseSize: bsatnBaseSize(MODULE_DEF.typespace, returnType)
	});
}
var VIEWS = [];
var ANON_VIEWS = [];
function procedure(name, params, ret, fn) {
	const paramsType = { elements: Object.entries(params).map(([n, c]) => ({
		name: n,
		algebraicType: registerTypesRecursively("typeBuilder" in c ? c.typeBuilder : c).algebraicType
	})) };
	const returnType = registerTypesRecursively(ret).algebraicType;
	MODULE_DEF.miscExports.push({
		tag: "Procedure",
		value: {
			name,
			params: paramsType,
			returnType
		}
	});
	PROCEDURES.push({
		fn,
		paramsType,
		returnType,
		returnTypeBaseSize: bsatnBaseSize(MODULE_DEF.typespace, returnType)
	});
}
var PROCEDURES = [];
var REGISTERED_SCHEMA = null;
function getRegisteredSchema() {
	if (REGISTERED_SCHEMA == null) throw new Error("Schema has not been registered yet. Call schema() first.");
	return REGISTERED_SCHEMA;
}
function tablesToSchema(tables) {
	return { tables: tables.map(tableToSchema) };
}
function tableToSchema(schema2) {
	const getColName = (i) => schema2.rowType.algebraicType.value.elements[i].name;
	return {
		name: schema2.tableName,
		accessorName: toCamelCase(schema2.tableName),
		columns: schema2.rowType.row,
		rowType: schema2.rowSpacetimeType,
		constraints: schema2.tableDef.constraints.map((c) => ({
			name: c.name,
			constraint: "unique",
			columns: c.data.value.columns.map(getColName)
		})),
		indexes: schema2.tableDef.indexes.map((idx) => {
			const columnIds = idx.algorithm.tag === "Direct" ? [idx.algorithm.value] : idx.algorithm.value;
			return {
				name: idx.accessorName,
				unique: schema2.tableDef.constraints.some((c) => c.data.value.columns.every((col) => columnIds.includes(col))),
				algorithm: idx.algorithm.tag.toLowerCase(),
				columns: columnIds.map(getColName)
			};
		})
	};
}
var MODULE_DEF = {
	typespace: { types: [] },
	tables: [],
	reducers: [],
	types: [],
	miscExports: [],
	rowLevelSecurity: []
};
var COMPOUND_TYPES = /* @__PURE__ */ new Map();
function resolveType(typespace, typeBuilder) {
	let ty = typeBuilder.algebraicType;
	while (ty.tag === "Ref") ty = typespace.types[ty.value];
	return ty;
}
function registerTypesRecursively(typeBuilder) {
	if (typeBuilder instanceof ProductBuilder && !isUnit(typeBuilder) || typeBuilder instanceof SumBuilder || typeBuilder instanceof RowBuilder) return registerCompoundTypeRecursively(typeBuilder);
	else if (typeBuilder instanceof OptionBuilder) return new OptionBuilder(registerTypesRecursively(typeBuilder.value));
	else if (typeBuilder instanceof ResultBuilder) return new ResultBuilder(registerTypesRecursively(typeBuilder.ok), registerTypesRecursively(typeBuilder.err));
	else if (typeBuilder instanceof ArrayBuilder) return new ArrayBuilder(registerTypesRecursively(typeBuilder.element));
	else return typeBuilder;
}
function registerCompoundTypeRecursively(typeBuilder) {
	const ty = typeBuilder.algebraicType;
	const name = typeBuilder.typeName;
	if (name === void 0) throw new Error(`Missing type name for ${typeBuilder.constructor.name ?? "TypeBuilder"} ${JSON.stringify(typeBuilder)}`);
	let r = COMPOUND_TYPES.get(ty);
	if (r != null) return r;
	const newTy = typeBuilder instanceof RowBuilder || typeBuilder instanceof ProductBuilder ? {
		tag: "Product",
		value: { elements: [] }
	} : {
		tag: "Sum",
		value: { variants: [] }
	};
	r = new RefBuilder(MODULE_DEF.typespace.types.length);
	MODULE_DEF.typespace.types.push(newTy);
	COMPOUND_TYPES.set(ty, r);
	if (typeBuilder instanceof RowBuilder) for (const [name2, elem] of Object.entries(typeBuilder.row)) newTy.value.elements.push({
		name: name2,
		algebraicType: registerTypesRecursively(elem.typeBuilder).algebraicType
	});
	else if (typeBuilder instanceof ProductBuilder) for (const [name2, elem] of Object.entries(typeBuilder.elements)) newTy.value.elements.push({
		name: name2,
		algebraicType: registerTypesRecursively(elem).algebraicType
	});
	else if (typeBuilder instanceof SumBuilder) for (const [name2, variant] of Object.entries(typeBuilder.variants)) newTy.value.variants.push({
		name: name2,
		algebraicType: registerTypesRecursively(variant).algebraicType
	});
	MODULE_DEF.types.push({
		name: splitName(name),
		ty: r.ref,
		customOrdering: true
	});
	return r;
}
function isUnit(typeBuilder) {
	return typeBuilder.typeName == null && typeBuilder.algebraicType.value.elements.length === 0;
}
function splitName(name) {
	const scope = name.split(".");
	return {
		name: scope.pop(),
		scope
	};
}
var Schema = class {
	tablesDef;
	typespace;
	schemaType;
	constructor(tables, typespace, handles) {
		this.tablesDef = { tables };
		this.typespace = typespace;
		this.schemaType = tablesToSchema(handles);
	}
	reducer(name, paramsOrFn, fn) {
		if (typeof paramsOrFn === "function") {
			reducer(name, {}, paramsOrFn);
			return paramsOrFn;
		} else {
			reducer(name, paramsOrFn, fn);
			return fn;
		}
	}
	init(nameOrFn, maybeFn) {
		const [name, fn] = typeof nameOrFn === "string" ? [nameOrFn, maybeFn] : ["init", nameOrFn];
		init(name, {}, fn);
	}
	clientConnected(nameOrFn, maybeFn) {
		const [name, fn] = typeof nameOrFn === "string" ? [nameOrFn, maybeFn] : ["on_connect", nameOrFn];
		clientConnected(name, {}, fn);
	}
	clientDisconnected(nameOrFn, maybeFn) {
		const [name, fn] = typeof nameOrFn === "string" ? [nameOrFn, maybeFn] : ["on_disconnect", nameOrFn];
		clientDisconnected(name, {}, fn);
	}
	view(opts, ret, fn) {
		defineView(opts, false, {}, ret, fn);
	}
	anonymousView(opts, ret, fn) {
		defineView(opts, true, {}, ret, fn);
	}
	procedure(name, paramsOrRet, retOrFn, maybeFn) {
		if (typeof retOrFn === "function") {
			procedure(name, {}, paramsOrRet, retOrFn);
			return retOrFn;
		} else {
			procedure(name, paramsOrRet, retOrFn, maybeFn);
			return maybeFn;
		}
	}
	clientVisibilityFilter = { sql(filter) {
		MODULE_DEF.rowLevelSecurity.push({ sql: filter });
	} };
};
function schema(...args) {
	const handles = args.length === 1 && Array.isArray(args[0]) ? args[0] : args;
	const tableDefs = handles.map((h) => h.tableDef);
	MODULE_DEF.tables.push(...tableDefs);
	REGISTERED_SCHEMA = { tables: handles.map((handle) => ({
		name: handle.tableName,
		accessorName: handle.tableName,
		columns: handle.rowType.row,
		rowType: handle.rowSpacetimeType,
		indexes: handle.idxs,
		constraints: handle.constraints
	})) };
	return new Schema(tableDefs, MODULE_DEF.typespace, handles);
}
var raw_index_algorithm_type_default = t.enum("RawIndexAlgorithm", {
	BTree: t.array(t.u16()),
	Hash: t.array(t.u16()),
	Direct: t.u16()
});
function table(opts, row) {
	const { name, public: isPublic = false, indexes: userIndexes = [], scheduled } = opts;
	const colIds = /* @__PURE__ */ new Map();
	const colNameList = [];
	if (!(row instanceof RowBuilder)) row = new RowBuilder(row);
	if (row.typeName === void 0) row.typeName = toPascalCase(name);
	const rowTypeRef = registerTypesRecursively(row);
	row.algebraicType.value.elements.forEach((elem, i) => {
		colIds.set(elem.name, i);
		colNameList.push(elem.name);
	});
	const pk = [];
	const indexes = [];
	const constraints = [];
	const sequences = [];
	let scheduleAtCol;
	for (const [name2, builder] of Object.entries(row.row)) {
		const meta = builder.columnMetadata;
		if (meta.isPrimaryKey) pk.push(colIds.get(name2));
		const isUnique = meta.isUnique || meta.isPrimaryKey;
		if (meta.indexType || isUnique) {
			const algo = meta.indexType ?? "btree";
			const id = colIds.get(name2);
			let algorithm;
			switch (algo) {
				case "btree":
					algorithm = raw_index_algorithm_type_default.BTree([id]);
					break;
				case "direct":
					algorithm = raw_index_algorithm_type_default.Direct(id);
					break;
			}
			indexes.push({
				name: void 0,
				accessorName: name2,
				algorithm
			});
		}
		if (isUnique) constraints.push({
			name: void 0,
			data: {
				tag: "Unique",
				value: { columns: [colIds.get(name2)] }
			}
		});
		if (meta.isAutoIncrement) sequences.push({
			name: void 0,
			start: void 0,
			minValue: void 0,
			maxValue: void 0,
			column: colIds.get(name2),
			increment: 1n
		});
		if (scheduled) {
			const algebraicType = builder.typeBuilder.algebraicType;
			if (schedule_at_default.isScheduleAt(algebraicType)) scheduleAtCol = colIds.get(name2);
		}
	}
	for (const indexOpts of userIndexes ?? []) {
		let algorithm;
		switch (indexOpts.algorithm) {
			case "btree":
				algorithm = {
					tag: "BTree",
					value: indexOpts.columns.map((c) => colIds.get(c))
				};
				break;
			case "direct":
				algorithm = {
					tag: "Direct",
					value: colIds.get(indexOpts.column)
				};
				break;
		}
		indexes.push({
			name: void 0,
			accessorName: indexOpts.name,
			algorithm
		});
	}
	for (const constraintOpts of opts.constraints ?? []) if (constraintOpts.constraint === "unique") {
		const data = {
			tag: "Unique",
			value: { columns: constraintOpts.columns.map((c) => colIds.get(c)) }
		};
		constraints.push({
			name: constraintOpts.name,
			data
		});
		continue;
	}
	for (const index of indexes) index.name = `${name}_${(index.algorithm.tag === "Direct" ? [index.algorithm.value] : index.algorithm.value).map((i) => colNameList[i]).join("_")}_idx_${index.algorithm.tag.toLowerCase()}`;
	const tableDef = {
		name,
		productTypeRef: rowTypeRef.ref,
		primaryKey: pk,
		indexes,
		constraints,
		sequences,
		schedule: scheduled && scheduleAtCol !== void 0 ? {
			name: void 0,
			reducerName: scheduled,
			scheduledAtColumn: scheduleAtCol
		} : void 0,
		tableType: { tag: "User" },
		tableAccess: { tag: isPublic ? "Public" : "Private" }
	};
	const productType = row.algebraicType.value;
	return {
		rowType: row,
		tableName: name,
		rowSpacetimeType: productType,
		tableDef,
		idxs: {},
		constraints
	};
}
var SpacetimeHostError = class _SpacetimeHostError extends Error {
	code;
	message;
	constructor(code, message) {
		super();
		const proto = Object.getPrototypeOf(this);
		let cls;
		if (errorProtoypes.has(proto)) {
			cls = proto.constructor;
			if (code !== cls.CODE) throw new TypeError(`invalid error code for ${cls.name}`);
		} else if (proto === _SpacetimeHostError.prototype) {
			cls = errnoToClass.get(code);
			if (!cls) throw new RangeError(`unknown error code ${code}`);
		} else throw new TypeError("cannot subclass SpacetimeError");
		Object.setPrototypeOf(this, cls.prototype);
		this.code = cls.CODE;
		this.message = message ?? cls.MESSAGE;
	}
	get name() {
		return errnoToClass.get(this.code)?.name ?? "SpacetimeHostError";
	}
};
var SenderError = class extends Error {
	constructor(message) {
		super(message);
	}
	get name() {
		return "SenderError";
	}
};
var errorData = {
	HostCallFailure: [1, "ABI called by host returned an error"],
	NotInTransaction: [2, "ABI call can only be made while in a transaction"],
	BsatnDecodeError: [3, "Couldn't decode the BSATN to the expected type"],
	NoSuchTable: [4, "No such table"],
	NoSuchIndex: [5, "No such index"],
	NoSuchIter: [6, "The provided row iterator is not valid"],
	NoSuchConsoleTimer: [7, "The provided console timer does not exist"],
	NoSuchBytes: [8, "The provided bytes source or sink is not valid"],
	NoSpace: [9, "The provided sink has no more space left"],
	BufferTooSmall: [11, "The provided buffer is not large enough to store the data"],
	UniqueAlreadyExists: [12, "Value with given unique identifier already exists"],
	ScheduleAtDelayTooLong: [13, "Specified delay in scheduling row was too long"],
	IndexNotUnique: [14, "The index was not unique"],
	NoSuchRow: [15, "The row was not found, e.g., in an update call"],
	AutoIncOverflow: [16, "The auto-increment sequence overflowed"],
	WouldBlockTransaction: [17, "Attempted async or blocking op while holding open a transaction"],
	TransactionNotAnonymous: [18, "Not in an anonymous transaction. Called by a reducer?"],
	TransactionIsReadOnly: [19, "ABI call can only be made while within a mutable transaction"],
	TransactionIsMut: [20, "ABI call can only be made while within a read-only transaction"],
	HttpError: [21, "The HTTP request failed"]
};
function mapEntries(x, f) {
	return Object.fromEntries(Object.entries(x).map(([k, v]) => [k, f(k, v)]));
}
var errors = Object.freeze(mapEntries(errorData, (name, [code, message]) => Object.defineProperty(class extends SpacetimeHostError {
	static CODE = code;
	static MESSAGE = message;
	constructor() {
		super(code);
	}
}, "name", {
	value: name,
	writable: false
})));
var errorProtoypes = new Set(Object.values(errors).map((cls) => cls.prototype));
var errnoToClass = new Map(Object.values(errors).map((cls) => [cls.CODE, cls]));
__toESM(require_text_min());
var sum_type_variant_type_default = t.object("SumTypeVariant", {
	name: t.option(t.string()),
	get algebraicType() {
		return algebraic_type_type_default;
	}
});
var sum_type_type_default = t.object("SumType", { get variants() {
	return t.array(sum_type_variant_type_default);
} });
var product_type_element_type_default = t.object("ProductTypeElement", {
	name: t.option(t.string()),
	get algebraicType() {
		return algebraic_type_type_default;
	}
});
var product_type_type_default = t.object("ProductType", { get elements() {
	return t.array(product_type_element_type_default);
} });
var AlgebraicType2 = t.enum("AlgebraicType", {
	Ref: t.u32(),
	get Sum() {
		return sum_type_type_default;
	},
	get Product() {
		return product_type_type_default;
	},
	get Array() {
		return AlgebraicType2;
	},
	String: t.unit(),
	Bool: t.unit(),
	I8: t.unit(),
	U8: t.unit(),
	I16: t.unit(),
	U16: t.unit(),
	I32: t.unit(),
	U32: t.unit(),
	I64: t.unit(),
	U64: t.unit(),
	I128: t.unit(),
	U128: t.unit(),
	I256: t.unit(),
	U256: t.unit(),
	F32: t.unit(),
	F64: t.unit()
});
var algebraic_type_type_default = AlgebraicType2;
var typespace_type_default = t.object("Typespace", { get types() {
	return t.array(algebraic_type_type_default);
} });
var raw_column_def_v_8_type_default = t.object("RawColumnDefV8", {
	colName: t.string(),
	get colType() {
		return algebraic_type_type_default;
	}
});
var index_type_type_default = t.enum("IndexType", {
	BTree: t.unit(),
	Hash: t.unit()
});
var raw_index_def_v_8_type_default = t.object("RawIndexDefV8", {
	indexName: t.string(),
	isUnique: t.bool(),
	get indexType() {
		return index_type_type_default;
	},
	columns: t.array(t.u16())
});
var raw_constraint_def_v_8_type_default = t.object("RawConstraintDefV8", {
	constraintName: t.string(),
	constraints: t.u8(),
	columns: t.array(t.u16())
});
var raw_sequence_def_v_8_type_default = t.object("RawSequenceDefV8", {
	sequenceName: t.string(),
	colPos: t.u16(),
	increment: t.i128(),
	start: t.option(t.i128()),
	minValue: t.option(t.i128()),
	maxValue: t.option(t.i128()),
	allocated: t.i128()
});
var raw_table_def_v_8_type_default = t.object("RawTableDefV8", {
	tableName: t.string(),
	get columns() {
		return t.array(raw_column_def_v_8_type_default);
	},
	get indexes() {
		return t.array(raw_index_def_v_8_type_default);
	},
	get constraints() {
		return t.array(raw_constraint_def_v_8_type_default);
	},
	get sequences() {
		return t.array(raw_sequence_def_v_8_type_default);
	},
	tableType: t.string(),
	tableAccess: t.string(),
	scheduled: t.option(t.string())
});
var table_desc_type_default = t.object("TableDesc", {
	get schema() {
		return raw_table_def_v_8_type_default;
	},
	data: t.u32()
});
var reducer_def_type_default = t.object("ReducerDef", {
	name: t.string(),
	get args() {
		return t.array(product_type_element_type_default);
	}
});
var type_alias_type_default = t.object("TypeAlias", {
	name: t.string(),
	ty: t.u32()
});
var misc_module_export_type_default = t.enum("MiscModuleExport", { get TypeAlias() {
	return type_alias_type_default;
} });
var raw_module_def_v_8_type_default = t.object("RawModuleDefV8", {
	get typespace() {
		return typespace_type_default;
	},
	get tables() {
		return t.array(table_desc_type_default);
	},
	get reducers() {
		return t.array(reducer_def_type_default);
	},
	get miscExports() {
		return t.array(misc_module_export_type_default);
	}
});
var raw_index_def_v_9_type_default = t.object("RawIndexDefV9", {
	name: t.option(t.string()),
	accessorName: t.option(t.string()),
	get algorithm() {
		return raw_index_algorithm_type_default;
	}
});
var raw_unique_constraint_data_v_9_type_default = t.object("RawUniqueConstraintDataV9", { columns: t.array(t.u16()) });
var raw_constraint_data_v_9_type_default = t.enum("RawConstraintDataV9", { get Unique() {
	return raw_unique_constraint_data_v_9_type_default;
} });
var raw_constraint_def_v_9_type_default = t.object("RawConstraintDefV9", {
	name: t.option(t.string()),
	get data() {
		return raw_constraint_data_v_9_type_default;
	}
});
var raw_sequence_def_v_9_type_default = t.object("RawSequenceDefV9", {
	name: t.option(t.string()),
	column: t.u16(),
	start: t.option(t.i128()),
	minValue: t.option(t.i128()),
	maxValue: t.option(t.i128()),
	increment: t.i128()
});
var raw_schedule_def_v_9_type_default = t.object("RawScheduleDefV9", {
	name: t.option(t.string()),
	reducerName: t.string(),
	scheduledAtColumn: t.u16()
});
var table_type_type_default = t.enum("TableType", {
	System: t.unit(),
	User: t.unit()
});
var table_access_type_default = t.enum("TableAccess", {
	Public: t.unit(),
	Private: t.unit()
});
var raw_table_def_v_9_type_default = t.object("RawTableDefV9", {
	name: t.string(),
	productTypeRef: t.u32(),
	primaryKey: t.array(t.u16()),
	get indexes() {
		return t.array(raw_index_def_v_9_type_default);
	},
	get constraints() {
		return t.array(raw_constraint_def_v_9_type_default);
	},
	get sequences() {
		return t.array(raw_sequence_def_v_9_type_default);
	},
	get schedule() {
		return t.option(raw_schedule_def_v_9_type_default);
	},
	get tableType() {
		return table_type_type_default;
	},
	get tableAccess() {
		return table_access_type_default;
	}
});
var raw_reducer_def_v_9_type_default = t.object("RawReducerDefV9", {
	name: t.string(),
	get params() {
		return product_type_type_default;
	},
	get lifecycle() {
		return t.option(lifecycle_type_default);
	}
});
var raw_scoped_type_name_v_9_type_default = t.object("RawScopedTypeNameV9", {
	scope: t.array(t.string()),
	name: t.string()
});
var raw_type_def_v_9_type_default = t.object("RawTypeDefV9", {
	get name() {
		return raw_scoped_type_name_v_9_type_default;
	},
	ty: t.u32(),
	customOrdering: t.bool()
});
var raw_column_default_value_v_9_type_default = t.object("RawColumnDefaultValueV9", {
	table: t.string(),
	colId: t.u16(),
	value: t.byteArray()
});
var raw_procedure_def_v_9_type_default = t.object("RawProcedureDefV9", {
	name: t.string(),
	get params() {
		return product_type_type_default;
	},
	get returnType() {
		return algebraic_type_type_default;
	}
});
var raw_view_def_v_9_type_default = t.object("RawViewDefV9", {
	name: t.string(),
	index: t.u32(),
	isPublic: t.bool(),
	isAnonymous: t.bool(),
	get params() {
		return product_type_type_default;
	},
	get returnType() {
		return algebraic_type_type_default;
	}
});
var raw_misc_module_export_v_9_type_default = t.enum("RawMiscModuleExportV9", {
	get ColumnDefaultValue() {
		return raw_column_default_value_v_9_type_default;
	},
	get Procedure() {
		return raw_procedure_def_v_9_type_default;
	},
	get View() {
		return raw_view_def_v_9_type_default;
	}
});
var raw_row_level_security_def_v_9_type_default = t.object("RawRowLevelSecurityDefV9", { sql: t.string() });
var raw_module_def_v_9_type_default = t.object("RawModuleDefV9", {
	get typespace() {
		return typespace_type_default;
	},
	get tables() {
		return t.array(raw_table_def_v_9_type_default);
	},
	get reducers() {
		return t.array(raw_reducer_def_v_9_type_default);
	},
	get types() {
		return t.array(raw_type_def_v_9_type_default);
	},
	get miscExports() {
		return t.array(raw_misc_module_export_v_9_type_default);
	},
	get rowLevelSecurity() {
		return t.array(raw_row_level_security_def_v_9_type_default);
	}
});
var raw_module_def_type_default = t.enum("RawModuleDef", {
	get V8BackCompat() {
		return raw_module_def_v_8_type_default;
	},
	get V9() {
		return raw_module_def_v_9_type_default;
	}
});
var Range = class {
	#from;
	#to;
	constructor(from, to) {
		this.#from = from ?? { tag: "unbounded" };
		this.#to = to ?? { tag: "unbounded" };
	}
	get from() {
		return this.#from;
	}
	get to() {
		return this.#to;
	}
};
var import_statuses = __toESM(require_statuses());
var http_header_pair_type_default = t.object("HttpHeaderPair", {
	name: t.string(),
	value: t.byteArray()
});
var http_headers_type_default = t.object("HttpHeaders", { get entries() {
	return t.array(http_header_pair_type_default);
} });
var http_method_type_default = t.enum("HttpMethod", {
	Get: t.unit(),
	Head: t.unit(),
	Post: t.unit(),
	Put: t.unit(),
	Delete: t.unit(),
	Connect: t.unit(),
	Options: t.unit(),
	Trace: t.unit(),
	Patch: t.unit(),
	Extension: t.string()
});
var http_version_type_default = t.enum("HttpVersion", {
	Http09: t.unit(),
	Http10: t.unit(),
	Http11: t.unit(),
	Http2: t.unit(),
	Http3: t.unit()
});
var http_request_type_default = t.object("HttpRequest", {
	get method() {
		return http_method_type_default;
	},
	get headers() {
		return http_headers_type_default;
	},
	timeout: t.option(t.timeDuration()),
	uri: t.string(),
	get version() {
		return http_version_type_default;
	}
});
var http_response_type_default = t.object("HttpResponse", {
	get headers() {
		return http_headers_type_default;
	},
	get version() {
		return http_version_type_default;
	},
	code: t.u16()
});
var { freeze } = Object;
var textEncoder = new TextEncoder();
var textDecoder = new TextDecoder("utf-8");
var makeResponse = Symbol("makeResponse");
var SyncResponse = class _SyncResponse {
	#body;
	#inner;
	constructor(body, init2) {
		if (body == null) this.#body = null;
		else if (typeof body === "string") this.#body = body;
		else this.#body = new Uint8Array(body).buffer;
		this.#inner = {
			headers: new Headers(init2?.headers),
			status: init2?.status ?? 200,
			statusText: init2?.statusText ?? "",
			type: "default",
			url: null,
			aborted: false
		};
	}
	static [makeResponse](body, inner) {
		const me = new _SyncResponse(body);
		me.#inner = inner;
		return me;
	}
	get headers() {
		return this.#inner.headers;
	}
	get status() {
		return this.#inner.status;
	}
	get statusText() {
		return this.#inner.statusText;
	}
	get ok() {
		return 200 <= this.#inner.status && this.#inner.status <= 299;
	}
	get url() {
		return this.#inner.url ?? "";
	}
	get type() {
		return this.#inner.type;
	}
	arrayBuffer() {
		return this.bytes().buffer;
	}
	bytes() {
		if (this.#body == null) return new Uint8Array();
		else if (typeof this.#body === "string") return textEncoder.encode(this.#body);
		else return new Uint8Array(this.#body);
	}
	json() {
		return JSON.parse(this.text());
	}
	text() {
		if (this.#body == null) return "";
		else if (typeof this.#body === "string") return this.#body;
		else return textDecoder.decode(this.#body);
	}
};
var requestBaseSize = bsatnBaseSize({ types: [] }, http_request_type_default.algebraicType);
var methods = /* @__PURE__ */ new Map([
	["GET", { tag: "Get" }],
	["HEAD", { tag: "Head" }],
	["POST", { tag: "Post" }],
	["PUT", { tag: "Put" }],
	["DELETE", { tag: "Delete" }],
	["CONNECT", { tag: "Connect" }],
	["OPTIONS", { tag: "Options" }],
	["TRACE", { tag: "Trace" }],
	["PATCH", { tag: "Patch" }]
]);
function fetch(url, init2 = {}) {
	const method = methods.get(init2.method?.toUpperCase() ?? "GET") ?? {
		tag: "Extension",
		value: init2.method
	};
	const headers = { entries: headersToList(new Headers(init2.headers)).flatMap(([k, v]) => Array.isArray(v) ? v.map((v2) => [k, v2]) : [[k, v]]).map(([name, value]) => ({
		name,
		value: textEncoder.encode(value)
	})) };
	const uri$1 = "" + url;
	const request = freeze({
		method,
		headers,
		timeout: init2.timeout,
		uri: uri$1,
		version: { tag: "Http11" }
	});
	const requestBuf = new BinaryWriter(requestBaseSize);
	http_request_type_default.serialize(requestBuf, request);
	const body = init2.body == null ? new Uint8Array() : typeof init2.body === "string" ? init2.body : new Uint8Array(init2.body);
	const [responseBuf, responseBody] = sys.procedure_http_request(requestBuf.getBuffer(), body);
	const response = http_response_type_default.deserialize(new BinaryReader(responseBuf));
	return SyncResponse[makeResponse](responseBody, {
		type: "basic",
		url: uri$1,
		status: response.code,
		statusText: (0, import_statuses.default)(response.code),
		headers: new Headers(),
		aborted: false
	});
}
freeze(fetch);
var httpClient = freeze({ fetch });
var { freeze: freeze2 } = Object;
function callProcedure(id, sender, connectionId, timestamp, argsBuf) {
	const { fn, paramsType, returnType, returnTypeBaseSize } = PROCEDURES[id];
	const args = ProductType.deserializeValue(new BinaryReader(argsBuf), paramsType, MODULE_DEF.typespace);
	const ctx = {
		sender,
		timestamp,
		connectionId,
		http: httpClient,
		counter_uuid: { value: 0 },
		get identity() {
			return new Identity(sys.identity().__identity__);
		},
		withTx(body) {
			const run = () => {
				const timestamp2 = sys.procedure_start_mut_tx();
				try {
					return body(new ReducerCtxImpl(sender, new Timestamp(timestamp2), connectionId));
				} catch (e) {
					sys.procedure_abort_mut_tx();
					throw e;
				}
			};
			let res = run();
			try {
				sys.procedure_commit_mut_tx();
				return res;
			} catch {}
			console.warn("committing anonymous transaction failed");
			res = run();
			try {
				sys.procedure_commit_mut_tx();
				return res;
			} catch (e) {
				throw new Error("transaction retry failed again", { cause: e });
			}
		},
		newUuidV4() {
			const bytes = crypto.getRandomValues(new Uint8Array(16));
			return Uuid.fromRandomBytesV4(bytes);
		},
		newUuidV7() {
			const bytes = crypto.getRandomValues(new Uint8Array(10));
			return Uuid.fromCounterV7(this.counter_uuid, this.timestamp, bytes);
		}
	};
	freeze2(ctx);
	const ret = callUserFunction(fn, ctx, args);
	const retBuf = new BinaryWriter(returnTypeBaseSize);
	AlgebraicType.serializeValue(retBuf, returnType, ret, MODULE_DEF.typespace);
	return retBuf.getBuffer();
}
var view_result_header_type_default = t.enum("ViewResultHeader", {
	RowData: t.unit(),
	RawSql: t.string()
});
var { freeze: freeze3 } = Object;
var sys = freeze3(wrapSyscalls(_syscalls1_0, _syscalls1_2));
function parseJsonObject(json) {
	let value;
	try {
		value = JSON.parse(json);
	} catch {
		throw new Error("Invalid JSON: failed to parse string");
	}
	if (value === null || typeof value !== "object" || Array.isArray(value)) throw new Error("Expected a JSON object at the top level");
	return value;
}
var JwtClaimsImpl = class {
	/**
	* Creates a new JwtClaims instance.
	* @param rawPayload The JWT payload as a raw JSON string.
	* @param identity The identity for this JWT. We are only taking this because we don't have a blake3 implementation (which we need to compute it).
	*/
	constructor(rawPayload, identity) {
		this.rawPayload = rawPayload;
		this.fullPayload = parseJsonObject(rawPayload);
		this._identity = identity;
	}
	fullPayload;
	_identity;
	get identity() {
		return this._identity;
	}
	get subject() {
		return this.fullPayload["sub"];
	}
	get issuer() {
		return this.fullPayload["iss"];
	}
	get audience() {
		const aud = this.fullPayload["aud"];
		if (aud == null) return [];
		return typeof aud === "string" ? [aud] : aud;
	}
};
var AuthCtxImpl = class _AuthCtxImpl {
	isInternal;
	_jwtSource;
	_initializedJWT = false;
	_jwtClaims;
	_senderIdentity;
	constructor(opts) {
		this.isInternal = opts.isInternal;
		this._jwtSource = opts.jwtSource;
		this._senderIdentity = opts.senderIdentity;
	}
	_initializeJWT() {
		if (this._initializedJWT) return;
		this._initializedJWT = true;
		const token = this._jwtSource();
		if (!token) this._jwtClaims = null;
		else this._jwtClaims = new JwtClaimsImpl(token, this._senderIdentity);
		Object.freeze(this);
	}
	/** Lazily compute whether a JWT exists and is parseable. */
	get hasJWT() {
		this._initializeJWT();
		return this._jwtClaims !== null;
	}
	/** Lazily parse the JwtClaims only when accessed. */
	get jwt() {
		this._initializeJWT();
		return this._jwtClaims;
	}
	/** Create a context representing internal (non-user) requests. */
	static internal() {
		return new _AuthCtxImpl({
			isInternal: true,
			jwtSource: () => null,
			senderIdentity: Identity.zero()
		});
	}
	/** If there is a connection id, look up the JWT payload from the system tables. */
	static fromSystemTables(connectionId, sender) {
		if (connectionId === null) return new _AuthCtxImpl({
			isInternal: false,
			jwtSource: () => null,
			senderIdentity: sender
		});
		return new _AuthCtxImpl({
			isInternal: false,
			jwtSource: () => {
				const payloadBuf = sys.get_jwt_payload(connectionId.__connection_id__);
				if (payloadBuf.length === 0) return null;
				return new TextDecoder().decode(payloadBuf);
			},
			senderIdentity: sender
		});
	}
};
var ReducerCtxImpl = class ReducerCtx {
	#identity;
	#senderAuth;
	#uuidCounter;
	sender;
	timestamp;
	connectionId;
	db;
	constructor(sender, timestamp, connectionId) {
		Object.seal(this);
		this.sender = sender;
		this.timestamp = timestamp;
		this.connectionId = connectionId;
		this.db = getDbView();
	}
	get identity() {
		return this.#identity ??= new Identity(sys.identity().__identity__);
	}
	get senderAuth() {
		return this.#senderAuth ??= AuthCtxImpl.fromSystemTables(this.connectionId, this.sender);
	}
	/**
	* Create a new random {@link Uuid} `v4` using the {@link crypto} RNG.
	*
	* WARN: Until we use a spacetime RNG this make calls non-deterministic.
	*/
	newUuidV4() {
		const bytes = crypto.getRandomValues(new Uint8Array(16));
		return Uuid.fromRandomBytesV4(bytes);
	}
	/**
	* Create a new sortable {@link Uuid} `v7` using the {@link crypto} RNG, counter,
	* and the timestamp.
	*
	* WARN: Until we use a spacetime RNG this make calls non-deterministic.
	*/
	newUuidV7() {
		const bytes = crypto.getRandomValues(new Uint8Array(4));
		const counter = this.#uuidCounter ??= { value: 0 };
		return Uuid.fromCounterV7(counter, this.timestamp, bytes);
	}
};
var callUserFunction = function __spacetimedb_end_short_backtrace(fn, ...args) {
	return fn(...args);
};
var hooks = {
	__describe_module__() {
		const writer = new BinaryWriter(128);
		AlgebraicType.serializeValue(writer, raw_module_def_type_default.algebraicType, raw_module_def_type_default.V9(MODULE_DEF));
		return writer.getBuffer();
	},
	__call_reducer__(reducerId, sender, connId, timestamp, argsBuf) {
		const argsType = AlgebraicType.Product(MODULE_DEF.reducers[reducerId].params);
		const args = AlgebraicType.deserializeValue(new BinaryReader(argsBuf), argsType, MODULE_DEF.typespace);
		const ctx = new ReducerCtxImpl(new Identity(sender), new Timestamp(timestamp), ConnectionId.nullIfZero(new ConnectionId(connId)));
		try {
			return callUserFunction(REDUCERS[reducerId], ctx, args) ?? { tag: "ok" };
		} catch (e) {
			if (e instanceof SenderError) return {
				tag: "err",
				value: e.message
			};
			throw e;
		}
	}
};
var hooks_v1_1 = {
	__call_view__(id, sender, argsBuf) {
		const { fn, params, returnType, returnTypeBaseSize } = VIEWS[id];
		const ret = callUserFunction(fn, freeze3({
			sender: new Identity(sender),
			db: getDbView(),
			from: makeQueryBuilder(getRegisteredSchema())
		}), ProductType.deserializeValue(new BinaryReader(argsBuf), params, MODULE_DEF.typespace));
		const retBuf = new BinaryWriter(returnTypeBaseSize);
		if (isRowTypedQuery(ret)) {
			const query = toSql(ret);
			const v = view_result_header_type_default.RawSql(query);
			AlgebraicType.serializeValue(retBuf, view_result_header_type_default.algebraicType, v, MODULE_DEF.typespace);
			return { data: retBuf.getBuffer() };
		} else {
			AlgebraicType.serializeValue(retBuf, view_result_header_type_default.algebraicType, view_result_header_type_default.RowData, MODULE_DEF.typespace);
			AlgebraicType.serializeValue(retBuf, returnType, ret, MODULE_DEF.typespace);
			return { data: retBuf.getBuffer() };
		}
	},
	__call_view_anon__(id, argsBuf) {
		const { fn, params, returnType, returnTypeBaseSize } = ANON_VIEWS[id];
		const ret = callUserFunction(fn, freeze3({
			db: getDbView(),
			from: makeQueryBuilder(getRegisteredSchema())
		}), ProductType.deserializeValue(new BinaryReader(argsBuf), params, MODULE_DEF.typespace));
		const retBuf = new BinaryWriter(returnTypeBaseSize);
		if (isRowTypedQuery(ret)) {
			const query = toSql(ret);
			const v = view_result_header_type_default.RawSql(query);
			AlgebraicType.serializeValue(retBuf, view_result_header_type_default.algebraicType, v, MODULE_DEF.typespace);
			return { data: retBuf.getBuffer() };
		} else {
			AlgebraicType.serializeValue(retBuf, view_result_header_type_default.algebraicType, view_result_header_type_default.RowData, MODULE_DEF.typespace);
			AlgebraicType.serializeValue(retBuf, returnType, ret, MODULE_DEF.typespace);
			return { data: retBuf.getBuffer() };
		}
	}
};
var hooks_v1_2 = { __call_procedure__(id, sender, connection_id, timestamp, args) {
	return callProcedure(id, new Identity(sender), ConnectionId.nullIfZero(new ConnectionId(connection_id)), new Timestamp(timestamp), args);
} };
var DB_VIEW = null;
function getDbView() {
	DB_VIEW ??= makeDbView(MODULE_DEF);
	return DB_VIEW;
}
function makeDbView(moduleDef) {
	return freeze3(Object.fromEntries(moduleDef.tables.map((table2) => [toCamelCase(table2.name), makeTableView(moduleDef.typespace, table2)])));
}
function makeTableView(typespace, table2) {
	const table_id = sys.table_id_from_name(table2.name);
	const rowType = typespace.types[table2.productTypeRef];
	if (rowType.tag !== "Product") throw "impossible";
	const baseSize = bsatnBaseSize(typespace, rowType);
	const sequences = table2.sequences.map((seq) => {
		const col = rowType.value.elements[seq.column];
		const colType = col.algebraicType;
		let sequenceTrigger;
		switch (colType.tag) {
			case "U8":
			case "I8":
			case "U16":
			case "I16":
			case "U32":
			case "I32":
				sequenceTrigger = 0;
				break;
			case "U64":
			case "I64":
			case "U128":
			case "I128":
			case "U256":
			case "I256":
				sequenceTrigger = 0n;
				break;
			default: throw new TypeError("invalid sequence type");
		}
		return {
			colName: col.name,
			sequenceTrigger,
			read: (reader) => AlgebraicType.deserializeValue(reader, colType, typespace)
		};
	});
	const hasAutoIncrement = sequences.length > 0;
	const iter = () => tableIterator(sys.datastore_table_scan_bsatn(table_id), rowType);
	const integrateGeneratedColumns = hasAutoIncrement ? (row, ret_buf) => {
		const reader = new BinaryReader(ret_buf);
		for (const { colName, read, sequenceTrigger } of sequences) if (row[colName] === sequenceTrigger) row[colName] = read(reader);
	} : null;
	const tableMethods = {
		count: () => sys.datastore_table_row_count(table_id),
		iter,
		[Symbol.iterator]: () => iter(),
		insert: (row) => {
			const writer = new BinaryWriter(baseSize);
			AlgebraicType.serializeValue(writer, rowType, row, typespace);
			const ret_buf = sys.datastore_insert_bsatn(table_id, writer.getBuffer());
			const ret = { ...row };
			integrateGeneratedColumns?.(ret, ret_buf);
			return ret;
		},
		delete: (row) => {
			const writer = new BinaryWriter(4 + baseSize);
			writer.writeU32(1);
			AlgebraicType.serializeValue(writer, rowType, row, typespace);
			return sys.datastore_delete_all_by_eq_bsatn(table_id, writer.getBuffer()) > 0;
		}
	};
	const tableView = Object.assign(/* @__PURE__ */ Object.create(null), tableMethods);
	for (const indexDef of table2.indexes) {
		const index_id = sys.index_id_from_name(indexDef.name);
		let column_ids;
		switch (indexDef.algorithm.tag) {
			case "BTree":
				column_ids = indexDef.algorithm.value;
				break;
			case "Hash": throw new Error("impossible");
			case "Direct":
				column_ids = [indexDef.algorithm.value];
				break;
		}
		const numColumns = column_ids.length;
		const columnSet = new Set(column_ids);
		const isUnique = table2.constraints.filter((x) => x.data.tag === "Unique").some((x) => columnSet.isSubsetOf(new Set(x.data.value.columns)));
		const indexType = AlgebraicType.Product({ elements: column_ids.map((id) => rowType.value.elements[id]) });
		const baseSize2 = bsatnBaseSize(typespace, indexType);
		const serializePrefix = (writer, prefix, prefix_elems) => {
			if (prefix_elems > numColumns - 1) throw new TypeError("too many elements in prefix");
			for (let i = 0; i < prefix_elems; i++) {
				const elemType = indexType.value.elements[i].algebraicType;
				AlgebraicType.serializeValue(writer, elemType, prefix[i], typespace);
			}
			return writer;
		};
		let index;
		if (isUnique) {
			const serializeBound = (colVal) => {
				if (colVal.length !== numColumns) throw new TypeError("wrong number of elements");
				const writer = new BinaryWriter(baseSize2 + 1);
				const prefix_elems = numColumns - 1;
				serializePrefix(writer, colVal, prefix_elems);
				const rstartOffset = writer.offset;
				writer.writeU8(0);
				AlgebraicType.serializeValue(writer, indexType.value.elements[numColumns - 1].algebraicType, colVal[numColumns - 1], typespace);
				const buffer = writer.getBuffer();
				const prefix = buffer.slice(0, rstartOffset);
				const rstart = buffer.slice(rstartOffset);
				return [
					prefix,
					prefix_elems,
					rstart,
					rstart
				];
			};
			index = {
				find: (colVal) => {
					if (numColumns === 1) colVal = [colVal];
					const args = serializeBound(colVal);
					const iter2 = tableIterator(sys.datastore_index_scan_range_bsatn(index_id, ...args), rowType);
					const { value, done } = iter2.next();
					if (done) return null;
					if (!iter2.next().done) throw new Error("`datastore_index_scan_range_bsatn` on unique field cannot return >1 rows");
					return value;
				},
				delete: (colVal) => {
					if (numColumns === 1) colVal = [colVal];
					const args = serializeBound(colVal);
					return sys.datastore_delete_by_index_scan_range_bsatn(index_id, ...args) > 0;
				},
				update: (row) => {
					const writer = new BinaryWriter(baseSize2);
					AlgebraicType.serializeValue(writer, rowType, row, typespace);
					const ret_buf = sys.datastore_update_bsatn(table_id, index_id, writer.getBuffer());
					integrateGeneratedColumns?.(row, ret_buf);
					return row;
				}
			};
		} else {
			const serializeRange = (range) => {
				if (range.length > numColumns) throw new TypeError("too many elements");
				const writer = new BinaryWriter(baseSize2 + 1);
				const prefix_elems = range.length - 1;
				serializePrefix(writer, range, prefix_elems);
				const rstartOffset = writer.offset;
				const term = range[range.length - 1];
				const termType = indexType.value.elements[range.length - 1].algebraicType;
				let rstart, rend;
				if (term instanceof Range) {
					const writeBound = (bound) => {
						writer.writeU8({
							included: 0,
							excluded: 1,
							unbounded: 2
						}[bound.tag]);
						if (bound.tag !== "unbounded") AlgebraicType.serializeValue(writer, termType, bound.value, typespace);
					};
					writeBound(term.from);
					const rendOffset = writer.offset;
					writeBound(term.to);
					rstart = writer.getBuffer().slice(rstartOffset, rendOffset);
					rend = writer.getBuffer().slice(rendOffset);
				} else {
					writer.writeU8(0);
					AlgebraicType.serializeValue(writer, termType, term, typespace);
					rstart = rend = writer.getBuffer().slice(rstartOffset);
				}
				return [
					writer.getBuffer().slice(0, rstartOffset),
					prefix_elems,
					rstart,
					rend
				];
			};
			index = {
				filter: (range) => {
					if (numColumns === 1) range = [range];
					const args = serializeRange(range);
					return tableIterator(sys.datastore_index_scan_range_bsatn(index_id, ...args), rowType);
				},
				delete: (range) => {
					if (numColumns === 1) range = [range];
					const args = serializeRange(range);
					return sys.datastore_delete_by_index_scan_range_bsatn(index_id, ...args);
				}
			};
		}
		if (Object.hasOwn(tableView, indexDef.accessorName)) freeze3(Object.assign(tableView[indexDef.accessorName], index));
		else tableView[indexDef.accessorName] = freeze3(index);
	}
	return freeze3(tableView);
}
function hasOwn(o, k) {
	return Object.hasOwn(o, k);
}
function* tableIterator(id, ty) {
	var _stack = [];
	try {
		const iter = __using(_stack, new IteratorHandle(id));
		const { typespace } = MODULE_DEF;
		let buf;
		while ((buf = advanceIter(iter)) != null) {
			const reader = new BinaryReader(buf);
			while (reader.remaining > 0) yield AlgebraicType.deserializeValue(reader, ty, typespace);
		}
	} catch (_$1) {
		var _error = _$1, _hasError = true;
	} finally {
		__callDispose(_stack, _error, _hasError);
	}
}
function advanceIter(iter) {
	let buf_max_len = 65536;
	while (true) try {
		return iter.advance(buf_max_len);
	} catch (e) {
		if (e && typeof e === "object" && hasOwn(e, "__buffer_too_small__")) {
			buf_max_len = e.__buffer_too_small__;
			continue;
		}
		throw e;
	}
}
var IteratorHandle = class _IteratorHandle {
	#id;
	static #finalizationRegistry = new FinalizationRegistry(sys.row_iter_bsatn_close);
	constructor(id) {
		this.#id = id;
		_IteratorHandle.#finalizationRegistry.register(this, id, this);
	}
	/** Unregister this object with the finalization registry and return the id */
	#detach() {
		const id = this.#id;
		this.#id = -1;
		_IteratorHandle.#finalizationRegistry.unregister(this);
		return id;
	}
	/** Call `row_iter_bsatn_advance`, returning null if this iterator was already exhausted. */
	advance(buf_max_len) {
		if (this.#id === -1) return null;
		const { 0: done, 1: buf } = sys.row_iter_bsatn_advance(this.#id, buf_max_len);
		if (done) this.#detach();
		return buf;
	}
	[Symbol.dispose]() {
		if (this.#id >= 0) {
			const id = this.#detach();
			sys.row_iter_bsatn_close(id);
		}
	}
};
function wrapSyscalls(...modules) {
	return Object.fromEntries(modules.flatMap(Object.entries).map(([k, v]) => [k, wrapSyscall(v)]));
}
function wrapSyscall(func) {
	const name = func.name;
	return { [name](...args) {
		try {
			return func(...args);
		} catch (e) {
			if (e !== null && typeof e === "object" && hasOwn(e, "__code_error__") && typeof e.__code_error__ == "number") {
				const message = hasOwn(e, "__error_message__") && typeof e.__error_message__ === "string" ? e.__error_message__ : void 0;
				throw new SpacetimeHostError(e.__code_error__, message);
			}
			throw e;
		}
	} }[name];
}
function fmtLog(...data) {
	return data.join(" ");
}
var console_level_error = 0;
var console_level_warn = 1;
var console_level_info = 2;
var console_level_debug = 3;
var console_level_trace = 4;
var timerMap = /* @__PURE__ */ new Map();
var console2 = {
	__proto__: {},
	[Symbol.toStringTag]: "console",
	assert: (condition = false, ...data) => {
		if (!condition) sys.console_log(console_level_error, fmtLog(...data));
	},
	clear: () => {},
	debug: (...data) => {
		sys.console_log(console_level_debug, fmtLog(...data));
	},
	error: (...data) => {
		sys.console_log(console_level_error, fmtLog(...data));
	},
	info: (...data) => {
		sys.console_log(console_level_info, fmtLog(...data));
	},
	log: (...data) => {
		sys.console_log(console_level_info, fmtLog(...data));
	},
	table: (tabularData, _properties) => {
		sys.console_log(console_level_info, fmtLog(tabularData));
	},
	trace: (...data) => {
		sys.console_log(console_level_trace, fmtLog(...data));
	},
	warn: (...data) => {
		sys.console_log(console_level_warn, fmtLog(...data));
	},
	dir: (_item, _options) => {},
	dirxml: (..._data) => {},
	count: (_label = "default") => {},
	countReset: (_label = "default") => {},
	group: (..._data) => {},
	groupCollapsed: (..._data) => {},
	groupEnd: () => {},
	time: (label = "default") => {
		if (timerMap.has(label)) {
			sys.console_log(console_level_warn, `Timer '${label}' already exists.`);
			return;
		}
		timerMap.set(label, sys.console_timer_start(label));
	},
	timeLog: (label = "default", ...data) => {
		sys.console_log(console_level_info, fmtLog(label, ...data));
	},
	timeEnd: (label = "default") => {
		const spanId = timerMap.get(label);
		if (spanId === void 0) {
			sys.console_log(console_level_warn, `Timer '${label}' does not exist.`);
			return;
		}
		sys.console_timer_end(spanId);
		timerMap.delete(label);
	},
	timeStamp: () => {},
	profile: () => {},
	profileEnd: () => {}
};
console2.Console = console2;
globalThis.console = console2;
register_hooks(hooks);
register_hooks$1(hooks_v1_1);
register_hooks$2(hooks_v1_2);

//#endregion
//#region node_modules/ajv/dist/compile/codegen/code.js
var require_code$1 = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/compile/codegen/code.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;
	var _CodeOrName = class {};
	exports._CodeOrName = _CodeOrName;
	exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
	var Name = class extends _CodeOrName {
		constructor(s) {
			super();
			if (!exports.IDENTIFIER.test(s)) throw new Error("CodeGen: name must be a valid identifier");
			this.str = s;
		}
		toString() {
			return this.str;
		}
		emptyStr() {
			return false;
		}
		get names() {
			return { [this.str]: 1 };
		}
	};
	exports.Name = Name;
	var _Code = class extends _CodeOrName {
		constructor(code) {
			super();
			this._items = typeof code === "string" ? [code] : code;
		}
		toString() {
			return this.str;
		}
		emptyStr() {
			if (this._items.length > 1) return false;
			const item = this._items[0];
			return item === "" || item === "\"\"";
		}
		get str() {
			var _a$1;
			return (_a$1 = this._str) !== null && _a$1 !== void 0 ? _a$1 : this._str = this._items.reduce((s, c) => `${s}${c}`, "");
		}
		get names() {
			var _a$1;
			return (_a$1 = this._names) !== null && _a$1 !== void 0 ? _a$1 : this._names = this._items.reduce((names$1, c) => {
				if (c instanceof Name) names$1[c.str] = (names$1[c.str] || 0) + 1;
				return names$1;
			}, {});
		}
	};
	exports._Code = _Code;
	exports.nil = new _Code("");
	function _(strs, ...args) {
		const code = [strs[0]];
		let i = 0;
		while (i < args.length) {
			addCodeArg(code, args[i]);
			code.push(strs[++i]);
		}
		return new _Code(code);
	}
	exports._ = _;
	const plus = new _Code("+");
	function str(strs, ...args) {
		const expr = [safeStringify(strs[0])];
		let i = 0;
		while (i < args.length) {
			expr.push(plus);
			addCodeArg(expr, args[i]);
			expr.push(plus, safeStringify(strs[++i]));
		}
		optimize(expr);
		return new _Code(expr);
	}
	exports.str = str;
	function addCodeArg(code, arg) {
		if (arg instanceof _Code) code.push(...arg._items);
		else if (arg instanceof Name) code.push(arg);
		else code.push(interpolate(arg));
	}
	exports.addCodeArg = addCodeArg;
	function optimize(expr) {
		let i = 1;
		while (i < expr.length - 1) {
			if (expr[i] === plus) {
				const res = mergeExprItems(expr[i - 1], expr[i + 1]);
				if (res !== void 0) {
					expr.splice(i - 1, 3, res);
					continue;
				}
				expr[i++] = "+";
			}
			i++;
		}
	}
	function mergeExprItems(a, b) {
		if (b === "\"\"") return a;
		if (a === "\"\"") return b;
		if (typeof a == "string") {
			if (b instanceof Name || a[a.length - 1] !== "\"") return;
			if (typeof b != "string") return `${a.slice(0, -1)}${b}"`;
			if (b[0] === "\"") return a.slice(0, -1) + b.slice(1);
			return;
		}
		if (typeof b == "string" && b[0] === "\"" && !(a instanceof Name)) return `"${a}${b.slice(1)}`;
	}
	function strConcat(c1, c2) {
		return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
	}
	exports.strConcat = strConcat;
	function interpolate(x) {
		return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
	}
	function stringify(x) {
		return new _Code(safeStringify(x));
	}
	exports.stringify = stringify;
	function safeStringify(x) {
		return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
	}
	exports.safeStringify = safeStringify;
	function getProperty(key) {
		return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
	}
	exports.getProperty = getProperty;
	function getEsmExportName(key) {
		if (typeof key == "string" && exports.IDENTIFIER.test(key)) return new _Code(`${key}`);
		throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
	}
	exports.getEsmExportName = getEsmExportName;
	function regexpCode(rx) {
		return new _Code(rx.toString());
	}
	exports.regexpCode = regexpCode;
}) });

//#endregion
//#region node_modules/ajv/dist/compile/codegen/scope.js
var require_scope = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/compile/codegen/scope.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;
	const code_1$12 = require_code$1();
	var ValueError = class extends Error {
		constructor(name) {
			super(`CodeGen: "code" for ${name} not defined`);
			this.value = name.value;
		}
	};
	var UsedValueState;
	(function(UsedValueState$1) {
		UsedValueState$1[UsedValueState$1["Started"] = 0] = "Started";
		UsedValueState$1[UsedValueState$1["Completed"] = 1] = "Completed";
	})(UsedValueState || (exports.UsedValueState = UsedValueState = {}));
	exports.varKinds = {
		const: new code_1$12.Name("const"),
		let: new code_1$12.Name("let"),
		var: new code_1$12.Name("var")
	};
	var Scope = class {
		constructor({ prefixes, parent } = {}) {
			this._names = {};
			this._prefixes = prefixes;
			this._parent = parent;
		}
		toName(nameOrPrefix) {
			return nameOrPrefix instanceof code_1$12.Name ? nameOrPrefix : this.name(nameOrPrefix);
		}
		name(prefix) {
			return new code_1$12.Name(this._newName(prefix));
		}
		_newName(prefix) {
			const ng = this._names[prefix] || this._nameGroup(prefix);
			return `${prefix}${ng.index++}`;
		}
		_nameGroup(prefix) {
			var _a$1, _b$1;
			if (((_b$1 = (_a$1 = this._parent) === null || _a$1 === void 0 ? void 0 : _a$1._prefixes) === null || _b$1 === void 0 ? void 0 : _b$1.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
			return this._names[prefix] = {
				prefix,
				index: 0
			};
		}
	};
	exports.Scope = Scope;
	var ValueScopeName = class extends code_1$12.Name {
		constructor(prefix, nameStr) {
			super(nameStr);
			this.prefix = prefix;
		}
		setValue(value, { property, itemIndex }) {
			this.value = value;
			this.scopePath = (0, code_1$12._)`.${new code_1$12.Name(property)}[${itemIndex}]`;
		}
	};
	exports.ValueScopeName = ValueScopeName;
	const line = (0, code_1$12._)`\n`;
	var ValueScope = class extends Scope {
		constructor(opts) {
			super(opts);
			this._values = {};
			this._scope = opts.scope;
			this.opts = {
				...opts,
				_n: opts.lines ? line : code_1$12.nil
			};
		}
		get() {
			return this._scope;
		}
		name(prefix) {
			return new ValueScopeName(prefix, this._newName(prefix));
		}
		value(nameOrPrefix, value) {
			var _a$1;
			if (value.ref === void 0) throw new Error("CodeGen: ref must be passed in value");
			const name = this.toName(nameOrPrefix);
			const { prefix } = name;
			const valueKey = (_a$1 = value.key) !== null && _a$1 !== void 0 ? _a$1 : value.ref;
			let vs = this._values[prefix];
			if (vs) {
				const _name = vs.get(valueKey);
				if (_name) return _name;
			} else vs = this._values[prefix] = /* @__PURE__ */ new Map();
			vs.set(valueKey, name);
			const s = this._scope[prefix] || (this._scope[prefix] = []);
			const itemIndex = s.length;
			s[itemIndex] = value.ref;
			name.setValue(value, {
				property: prefix,
				itemIndex
			});
			return name;
		}
		getValue(prefix, keyOrRef) {
			const vs = this._values[prefix];
			if (!vs) return;
			return vs.get(keyOrRef);
		}
		scopeRefs(scopeName, values = this._values) {
			return this._reduceValues(values, (name) => {
				if (name.scopePath === void 0) throw new Error(`CodeGen: name "${name}" has no value`);
				return (0, code_1$12._)`${scopeName}${name.scopePath}`;
			});
		}
		scopeCode(values = this._values, usedValues, getCode) {
			return this._reduceValues(values, (name) => {
				if (name.value === void 0) throw new Error(`CodeGen: name "${name}" has no value`);
				return name.value.code;
			}, usedValues, getCode);
		}
		_reduceValues(values, valueCode, usedValues = {}, getCode) {
			let code = code_1$12.nil;
			for (const prefix in values) {
				const vs = values[prefix];
				if (!vs) continue;
				const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
				vs.forEach((name) => {
					if (nameSet.has(name)) return;
					nameSet.set(name, UsedValueState.Started);
					let c = valueCode(name);
					if (c) {
						const def$30 = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
						code = (0, code_1$12._)`${code}${def$30} ${name} = ${c};${this.opts._n}`;
					} else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) code = (0, code_1$12._)`${code}${c}${this.opts._n}`;
					else throw new ValueError(name);
					nameSet.set(name, UsedValueState.Completed);
				});
			}
			return code;
		}
	};
	exports.ValueScope = ValueScope;
}) });

//#endregion
//#region node_modules/ajv/dist/compile/codegen/index.js
var require_codegen = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/compile/codegen/index.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;
	const code_1$11 = require_code$1();
	const scope_1 = require_scope();
	var code_2 = require_code$1();
	Object.defineProperty(exports, "_", {
		enumerable: true,
		get: function() {
			return code_2._;
		}
	});
	Object.defineProperty(exports, "str", {
		enumerable: true,
		get: function() {
			return code_2.str;
		}
	});
	Object.defineProperty(exports, "strConcat", {
		enumerable: true,
		get: function() {
			return code_2.strConcat;
		}
	});
	Object.defineProperty(exports, "nil", {
		enumerable: true,
		get: function() {
			return code_2.nil;
		}
	});
	Object.defineProperty(exports, "getProperty", {
		enumerable: true,
		get: function() {
			return code_2.getProperty;
		}
	});
	Object.defineProperty(exports, "stringify", {
		enumerable: true,
		get: function() {
			return code_2.stringify;
		}
	});
	Object.defineProperty(exports, "regexpCode", {
		enumerable: true,
		get: function() {
			return code_2.regexpCode;
		}
	});
	Object.defineProperty(exports, "Name", {
		enumerable: true,
		get: function() {
			return code_2.Name;
		}
	});
	var scope_2 = require_scope();
	Object.defineProperty(exports, "Scope", {
		enumerable: true,
		get: function() {
			return scope_2.Scope;
		}
	});
	Object.defineProperty(exports, "ValueScope", {
		enumerable: true,
		get: function() {
			return scope_2.ValueScope;
		}
	});
	Object.defineProperty(exports, "ValueScopeName", {
		enumerable: true,
		get: function() {
			return scope_2.ValueScopeName;
		}
	});
	Object.defineProperty(exports, "varKinds", {
		enumerable: true,
		get: function() {
			return scope_2.varKinds;
		}
	});
	exports.operators = {
		GT: new code_1$11._Code(">"),
		GTE: new code_1$11._Code(">="),
		LT: new code_1$11._Code("<"),
		LTE: new code_1$11._Code("<="),
		EQ: new code_1$11._Code("==="),
		NEQ: new code_1$11._Code("!=="),
		NOT: new code_1$11._Code("!"),
		OR: new code_1$11._Code("||"),
		AND: new code_1$11._Code("&&"),
		ADD: new code_1$11._Code("+")
	};
	var Node = class {
		optimizeNodes() {
			return this;
		}
		optimizeNames(_names, _constants) {
			return this;
		}
	};
	var Def = class extends Node {
		constructor(varKind, name, rhs) {
			super();
			this.varKind = varKind;
			this.name = name;
			this.rhs = rhs;
		}
		render({ es5, _n }) {
			const varKind = es5 ? scope_1.varKinds.var : this.varKind;
			const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
			return `${varKind} ${this.name}${rhs};` + _n;
		}
		optimizeNames(names$1, constants) {
			if (!names$1[this.name.str]) return;
			if (this.rhs) this.rhs = optimizeExpr(this.rhs, names$1, constants);
			return this;
		}
		get names() {
			return this.rhs instanceof code_1$11._CodeOrName ? this.rhs.names : {};
		}
	};
	var Assign = class extends Node {
		constructor(lhs, rhs, sideEffects) {
			super();
			this.lhs = lhs;
			this.rhs = rhs;
			this.sideEffects = sideEffects;
		}
		render({ _n }) {
			return `${this.lhs} = ${this.rhs};` + _n;
		}
		optimizeNames(names$1, constants) {
			if (this.lhs instanceof code_1$11.Name && !names$1[this.lhs.str] && !this.sideEffects) return;
			this.rhs = optimizeExpr(this.rhs, names$1, constants);
			return this;
		}
		get names() {
			return addExprNames(this.lhs instanceof code_1$11.Name ? {} : { ...this.lhs.names }, this.rhs);
		}
	};
	var AssignOp = class extends Assign {
		constructor(lhs, op, rhs, sideEffects) {
			super(lhs, rhs, sideEffects);
			this.op = op;
		}
		render({ _n }) {
			return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
		}
	};
	var Label = class extends Node {
		constructor(label) {
			super();
			this.label = label;
			this.names = {};
		}
		render({ _n }) {
			return `${this.label}:` + _n;
		}
	};
	var Break = class extends Node {
		constructor(label) {
			super();
			this.label = label;
			this.names = {};
		}
		render({ _n }) {
			return `break${this.label ? ` ${this.label}` : ""};` + _n;
		}
	};
	var Throw = class extends Node {
		constructor(error) {
			super();
			this.error = error;
		}
		render({ _n }) {
			return `throw ${this.error};` + _n;
		}
		get names() {
			return this.error.names;
		}
	};
	var AnyCode = class extends Node {
		constructor(code) {
			super();
			this.code = code;
		}
		render({ _n }) {
			return `${this.code};` + _n;
		}
		optimizeNodes() {
			return `${this.code}` ? this : void 0;
		}
		optimizeNames(names$1, constants) {
			this.code = optimizeExpr(this.code, names$1, constants);
			return this;
		}
		get names() {
			return this.code instanceof code_1$11._CodeOrName ? this.code.names : {};
		}
	};
	var ParentNode = class extends Node {
		constructor(nodes = []) {
			super();
			this.nodes = nodes;
		}
		render(opts) {
			return this.nodes.reduce((code, n) => code + n.render(opts), "");
		}
		optimizeNodes() {
			const { nodes } = this;
			let i = nodes.length;
			while (i--) {
				const n = nodes[i].optimizeNodes();
				if (Array.isArray(n)) nodes.splice(i, 1, ...n);
				else if (n) nodes[i] = n;
				else nodes.splice(i, 1);
			}
			return nodes.length > 0 ? this : void 0;
		}
		optimizeNames(names$1, constants) {
			const { nodes } = this;
			let i = nodes.length;
			while (i--) {
				const n = nodes[i];
				if (n.optimizeNames(names$1, constants)) continue;
				subtractNames(names$1, n.names);
				nodes.splice(i, 1);
			}
			return nodes.length > 0 ? this : void 0;
		}
		get names() {
			return this.nodes.reduce((names$1, n) => addNames(names$1, n.names), {});
		}
	};
	var BlockNode = class extends ParentNode {
		render(opts) {
			return "{" + opts._n + super.render(opts) + "}" + opts._n;
		}
	};
	var Root = class extends ParentNode {};
	var Else = class extends BlockNode {};
	Else.kind = "else";
	var If = class If extends BlockNode {
		constructor(condition, nodes) {
			super(nodes);
			this.condition = condition;
		}
		render(opts) {
			let code = `if(${this.condition})` + super.render(opts);
			if (this.else) code += "else " + this.else.render(opts);
			return code;
		}
		optimizeNodes() {
			super.optimizeNodes();
			const cond = this.condition;
			if (cond === true) return this.nodes;
			let e = this.else;
			if (e) {
				const ns = e.optimizeNodes();
				e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
			}
			if (e) {
				if (cond === false) return e instanceof If ? e : e.nodes;
				if (this.nodes.length) return this;
				return new If(not(cond), e instanceof If ? [e] : e.nodes);
			}
			if (cond === false || !this.nodes.length) return void 0;
			return this;
		}
		optimizeNames(names$1, constants) {
			var _a$1;
			this.else = (_a$1 = this.else) === null || _a$1 === void 0 ? void 0 : _a$1.optimizeNames(names$1, constants);
			if (!(super.optimizeNames(names$1, constants) || this.else)) return;
			this.condition = optimizeExpr(this.condition, names$1, constants);
			return this;
		}
		get names() {
			const names$1 = super.names;
			addExprNames(names$1, this.condition);
			if (this.else) addNames(names$1, this.else.names);
			return names$1;
		}
	};
	If.kind = "if";
	var For = class extends BlockNode {};
	For.kind = "for";
	var ForLoop = class extends For {
		constructor(iteration) {
			super();
			this.iteration = iteration;
		}
		render(opts) {
			return `for(${this.iteration})` + super.render(opts);
		}
		optimizeNames(names$1, constants) {
			if (!super.optimizeNames(names$1, constants)) return;
			this.iteration = optimizeExpr(this.iteration, names$1, constants);
			return this;
		}
		get names() {
			return addNames(super.names, this.iteration.names);
		}
	};
	var ForRange = class extends For {
		constructor(varKind, name, from, to) {
			super();
			this.varKind = varKind;
			this.name = name;
			this.from = from;
			this.to = to;
		}
		render(opts) {
			const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
			const { name, from, to } = this;
			return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
		}
		get names() {
			return addExprNames(addExprNames(super.names, this.from), this.to);
		}
	};
	var ForIter = class extends For {
		constructor(loop, varKind, name, iterable) {
			super();
			this.loop = loop;
			this.varKind = varKind;
			this.name = name;
			this.iterable = iterable;
		}
		render(opts) {
			return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
		}
		optimizeNames(names$1, constants) {
			if (!super.optimizeNames(names$1, constants)) return;
			this.iterable = optimizeExpr(this.iterable, names$1, constants);
			return this;
		}
		get names() {
			return addNames(super.names, this.iterable.names);
		}
	};
	var Func = class extends BlockNode {
		constructor(name, args, async) {
			super();
			this.name = name;
			this.args = args;
			this.async = async;
		}
		render(opts) {
			return `${this.async ? "async " : ""}function ${this.name}(${this.args})` + super.render(opts);
		}
	};
	Func.kind = "func";
	var Return = class extends ParentNode {
		render(opts) {
			return "return " + super.render(opts);
		}
	};
	Return.kind = "return";
	var Try = class extends BlockNode {
		render(opts) {
			let code = "try" + super.render(opts);
			if (this.catch) code += this.catch.render(opts);
			if (this.finally) code += this.finally.render(opts);
			return code;
		}
		optimizeNodes() {
			var _a$1, _b$1;
			super.optimizeNodes();
			(_a$1 = this.catch) === null || _a$1 === void 0 || _a$1.optimizeNodes();
			(_b$1 = this.finally) === null || _b$1 === void 0 || _b$1.optimizeNodes();
			return this;
		}
		optimizeNames(names$1, constants) {
			var _a$1, _b$1;
			super.optimizeNames(names$1, constants);
			(_a$1 = this.catch) === null || _a$1 === void 0 || _a$1.optimizeNames(names$1, constants);
			(_b$1 = this.finally) === null || _b$1 === void 0 || _b$1.optimizeNames(names$1, constants);
			return this;
		}
		get names() {
			const names$1 = super.names;
			if (this.catch) addNames(names$1, this.catch.names);
			if (this.finally) addNames(names$1, this.finally.names);
			return names$1;
		}
	};
	var Catch = class extends BlockNode {
		constructor(error) {
			super();
			this.error = error;
		}
		render(opts) {
			return `catch(${this.error})` + super.render(opts);
		}
	};
	Catch.kind = "catch";
	var Finally = class extends BlockNode {
		render(opts) {
			return "finally" + super.render(opts);
		}
	};
	Finally.kind = "finally";
	var CodeGen = class {
		constructor(extScope, opts = {}) {
			this._values = {};
			this._blockStarts = [];
			this._constants = {};
			this.opts = {
				...opts,
				_n: opts.lines ? "\n" : ""
			};
			this._extScope = extScope;
			this._scope = new scope_1.Scope({ parent: extScope });
			this._nodes = [new Root()];
		}
		toString() {
			return this._root.render(this.opts);
		}
		name(prefix) {
			return this._scope.name(prefix);
		}
		scopeName(prefix) {
			return this._extScope.name(prefix);
		}
		scopeValue(prefixOrName, value) {
			const name = this._extScope.value(prefixOrName, value);
			(this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set())).add(name);
			return name;
		}
		getScopeValue(prefix, keyOrRef) {
			return this._extScope.getValue(prefix, keyOrRef);
		}
		scopeRefs(scopeName) {
			return this._extScope.scopeRefs(scopeName, this._values);
		}
		scopeCode() {
			return this._extScope.scopeCode(this._values);
		}
		_def(varKind, nameOrPrefix, rhs, constant) {
			const name = this._scope.toName(nameOrPrefix);
			if (rhs !== void 0 && constant) this._constants[name.str] = rhs;
			this._leafNode(new Def(varKind, name, rhs));
			return name;
		}
		const(nameOrPrefix, rhs, _constant) {
			return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
		}
		let(nameOrPrefix, rhs, _constant) {
			return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
		}
		var(nameOrPrefix, rhs, _constant) {
			return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
		}
		assign(lhs, rhs, sideEffects) {
			return this._leafNode(new Assign(lhs, rhs, sideEffects));
		}
		add(lhs, rhs) {
			return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
		}
		code(c) {
			if (typeof c == "function") c();
			else if (c !== code_1$11.nil) this._leafNode(new AnyCode(c));
			return this;
		}
		object(...keyValues) {
			const code = ["{"];
			for (const [key, value] of keyValues) {
				if (code.length > 1) code.push(",");
				code.push(key);
				if (key !== value || this.opts.es5) {
					code.push(":");
					(0, code_1$11.addCodeArg)(code, value);
				}
			}
			code.push("}");
			return new code_1$11._Code(code);
		}
		if(condition, thenBody, elseBody) {
			this._blockNode(new If(condition));
			if (thenBody && elseBody) this.code(thenBody).else().code(elseBody).endIf();
			else if (thenBody) this.code(thenBody).endIf();
			else if (elseBody) throw new Error("CodeGen: \"else\" body without \"then\" body");
			return this;
		}
		elseIf(condition) {
			return this._elseNode(new If(condition));
		}
		else() {
			return this._elseNode(new Else());
		}
		endIf() {
			return this._endBlockNode(If, Else);
		}
		_for(node, forBody) {
			this._blockNode(node);
			if (forBody) this.code(forBody).endFor();
			return this;
		}
		for(iteration, forBody) {
			return this._for(new ForLoop(iteration), forBody);
		}
		forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
			const name = this._scope.toName(nameOrPrefix);
			return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
		}
		forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
			const name = this._scope.toName(nameOrPrefix);
			if (this.opts.es5) {
				const arr = iterable instanceof code_1$11.Name ? iterable : this.var("_arr", iterable);
				return this.forRange("_i", 0, (0, code_1$11._)`${arr}.length`, (i) => {
					this.var(name, (0, code_1$11._)`${arr}[${i}]`);
					forBody(name);
				});
			}
			return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
		}
		forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
			if (this.opts.ownProperties) return this.forOf(nameOrPrefix, (0, code_1$11._)`Object.keys(${obj})`, forBody);
			const name = this._scope.toName(nameOrPrefix);
			return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
		}
		endFor() {
			return this._endBlockNode(For);
		}
		label(label) {
			return this._leafNode(new Label(label));
		}
		break(label) {
			return this._leafNode(new Break(label));
		}
		return(value) {
			const node = new Return();
			this._blockNode(node);
			this.code(value);
			if (node.nodes.length !== 1) throw new Error("CodeGen: \"return\" should have one node");
			return this._endBlockNode(Return);
		}
		try(tryBody, catchCode, finallyCode) {
			if (!catchCode && !finallyCode) throw new Error("CodeGen: \"try\" without \"catch\" and \"finally\"");
			const node = new Try();
			this._blockNode(node);
			this.code(tryBody);
			if (catchCode) {
				const error = this.name("e");
				this._currNode = node.catch = new Catch(error);
				catchCode(error);
			}
			if (finallyCode) {
				this._currNode = node.finally = new Finally();
				this.code(finallyCode);
			}
			return this._endBlockNode(Catch, Finally);
		}
		throw(error) {
			return this._leafNode(new Throw(error));
		}
		block(body, nodeCount) {
			this._blockStarts.push(this._nodes.length);
			if (body) this.code(body).endBlock(nodeCount);
			return this;
		}
		endBlock(nodeCount) {
			const len = this._blockStarts.pop();
			if (len === void 0) throw new Error("CodeGen: not in self-balancing block");
			const toClose = this._nodes.length - len;
			if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
			this._nodes.length = len;
			return this;
		}
		func(name, args = code_1$11.nil, async, funcBody) {
			this._blockNode(new Func(name, args, async));
			if (funcBody) this.code(funcBody).endFunc();
			return this;
		}
		endFunc() {
			return this._endBlockNode(Func);
		}
		optimize(n = 1) {
			while (n-- > 0) {
				this._root.optimizeNodes();
				this._root.optimizeNames(this._root.names, this._constants);
			}
		}
		_leafNode(node) {
			this._currNode.nodes.push(node);
			return this;
		}
		_blockNode(node) {
			this._currNode.nodes.push(node);
			this._nodes.push(node);
		}
		_endBlockNode(N1, N2) {
			const n = this._currNode;
			if (n instanceof N1 || N2 && n instanceof N2) {
				this._nodes.pop();
				return this;
			}
			throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
		}
		_elseNode(node) {
			const n = this._currNode;
			if (!(n instanceof If)) throw new Error("CodeGen: \"else\" without \"if\"");
			this._currNode = n.else = node;
			return this;
		}
		get _root() {
			return this._nodes[0];
		}
		get _currNode() {
			const ns = this._nodes;
			return ns[ns.length - 1];
		}
		set _currNode(node) {
			const ns = this._nodes;
			ns[ns.length - 1] = node;
		}
	};
	exports.CodeGen = CodeGen;
	function addNames(names$1, from) {
		for (const n in from) names$1[n] = (names$1[n] || 0) + (from[n] || 0);
		return names$1;
	}
	function addExprNames(names$1, from) {
		return from instanceof code_1$11._CodeOrName ? addNames(names$1, from.names) : names$1;
	}
	function optimizeExpr(expr, names$1, constants) {
		if (expr instanceof code_1$11.Name) return replaceName(expr);
		if (!canOptimize(expr)) return expr;
		return new code_1$11._Code(expr._items.reduce((items, c) => {
			if (c instanceof code_1$11.Name) c = replaceName(c);
			if (c instanceof code_1$11._Code) items.push(...c._items);
			else items.push(c);
			return items;
		}, []));
		function replaceName(n) {
			const c = constants[n.str];
			if (c === void 0 || names$1[n.str] !== 1) return n;
			delete names$1[n.str];
			return c;
		}
		function canOptimize(e) {
			return e instanceof code_1$11._Code && e._items.some((c) => c instanceof code_1$11.Name && names$1[c.str] === 1 && constants[c.str] !== void 0);
		}
	}
	function subtractNames(names$1, from) {
		for (const n in from) names$1[n] = (names$1[n] || 0) - (from[n] || 0);
	}
	function not(x) {
		return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1$11._)`!${par(x)}`;
	}
	exports.not = not;
	const andCode = mappend(exports.operators.AND);
	function and(...args) {
		return args.reduce(andCode);
	}
	exports.and = and;
	const orCode = mappend(exports.operators.OR);
	function or(...args) {
		return args.reduce(orCode);
	}
	exports.or = or;
	function mappend(op) {
		return (x, y) => x === code_1$11.nil ? y : y === code_1$11.nil ? x : (0, code_1$11._)`${par(x)} ${op} ${par(y)}`;
	}
	function par(x) {
		return x instanceof code_1$11.Name ? x : (0, code_1$11._)`(${x})`;
	}
}) });

//#endregion
//#region node_modules/ajv/dist/compile/util.js
var require_util = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/compile/util.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$35 = require_codegen();
	const code_1$10 = require_code$1();
	function toHash(arr) {
		const hash = {};
		for (const item of arr) hash[item] = true;
		return hash;
	}
	exports.toHash = toHash;
	function alwaysValidSchema(it, schema$1) {
		if (typeof schema$1 == "boolean") return schema$1;
		if (Object.keys(schema$1).length === 0) return true;
		checkUnknownRules(it, schema$1);
		return !schemaHasRules(schema$1, it.self.RULES.all);
	}
	exports.alwaysValidSchema = alwaysValidSchema;
	function checkUnknownRules(it, schema$1 = it.schema) {
		const { opts, self } = it;
		if (!opts.strictSchema) return;
		if (typeof schema$1 === "boolean") return;
		const rules = self.RULES.keywords;
		for (const key in schema$1) if (!rules[key]) checkStrictMode(it, `unknown keyword: "${key}"`);
	}
	exports.checkUnknownRules = checkUnknownRules;
	function schemaHasRules(schema$1, rules) {
		if (typeof schema$1 == "boolean") return !schema$1;
		for (const key in schema$1) if (rules[key]) return true;
		return false;
	}
	exports.schemaHasRules = schemaHasRules;
	function schemaHasRulesButRef(schema$1, RULES) {
		if (typeof schema$1 == "boolean") return !schema$1;
		for (const key in schema$1) if (key !== "$ref" && RULES.all[key]) return true;
		return false;
	}
	exports.schemaHasRulesButRef = schemaHasRulesButRef;
	function schemaRefOrVal({ topSchemaRef, schemaPath }, schema$1, keyword, $data) {
		if (!$data) {
			if (typeof schema$1 == "number" || typeof schema$1 == "boolean") return schema$1;
			if (typeof schema$1 == "string") return (0, codegen_1$35._)`${schema$1}`;
		}
		return (0, codegen_1$35._)`${topSchemaRef}${schemaPath}${(0, codegen_1$35.getProperty)(keyword)}`;
	}
	exports.schemaRefOrVal = schemaRefOrVal;
	function unescapeFragment(str$1) {
		return unescapeJsonPointer(decodeURIComponent(str$1));
	}
	exports.unescapeFragment = unescapeFragment;
	function escapeFragment(str$1) {
		return encodeURIComponent(escapeJsonPointer(str$1));
	}
	exports.escapeFragment = escapeFragment;
	function escapeJsonPointer(str$1) {
		if (typeof str$1 == "number") return `${str$1}`;
		return str$1.replace(/~/g, "~0").replace(/\//g, "~1");
	}
	exports.escapeJsonPointer = escapeJsonPointer;
	function unescapeJsonPointer(str$1) {
		return str$1.replace(/~1/g, "/").replace(/~0/g, "~");
	}
	exports.unescapeJsonPointer = unescapeJsonPointer;
	function eachItem(xs, f) {
		if (Array.isArray(xs)) for (const x of xs) f(x);
		else f(xs);
	}
	exports.eachItem = eachItem;
	function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName }) {
		return (gen, from, to, toName) => {
			const res = to === void 0 ? from : to instanceof codegen_1$35.Name ? (from instanceof codegen_1$35.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1$35.Name ? (mergeToName(gen, to, from), from) : mergeValues(from, to);
			return toName === codegen_1$35.Name && !(res instanceof codegen_1$35.Name) ? resultToName(gen, res) : res;
		};
	}
	exports.mergeEvaluated = {
		props: makeMergeEvaluated({
			mergeNames: (gen, from, to) => gen.if((0, codegen_1$35._)`${to} !== true && ${from} !== undefined`, () => {
				gen.if((0, codegen_1$35._)`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1$35._)`${to} || {}`).code((0, codegen_1$35._)`Object.assign(${to}, ${from})`));
			}),
			mergeToName: (gen, from, to) => gen.if((0, codegen_1$35._)`${to} !== true`, () => {
				if (from === true) gen.assign(to, true);
				else {
					gen.assign(to, (0, codegen_1$35._)`${to} || {}`);
					setEvaluated(gen, to, from);
				}
			}),
			mergeValues: (from, to) => from === true ? true : {
				...from,
				...to
			},
			resultToName: evaluatedPropsToName
		}),
		items: makeMergeEvaluated({
			mergeNames: (gen, from, to) => gen.if((0, codegen_1$35._)`${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1$35._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
			mergeToName: (gen, from, to) => gen.if((0, codegen_1$35._)`${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1$35._)`${to} > ${from} ? ${to} : ${from}`)),
			mergeValues: (from, to) => from === true ? true : Math.max(from, to),
			resultToName: (gen, items) => gen.var("items", items)
		})
	};
	function evaluatedPropsToName(gen, ps) {
		if (ps === true) return gen.var("props", true);
		const props = gen.var("props", (0, codegen_1$35._)`{}`);
		if (ps !== void 0) setEvaluated(gen, props, ps);
		return props;
	}
	exports.evaluatedPropsToName = evaluatedPropsToName;
	function setEvaluated(gen, props, ps) {
		Object.keys(ps).forEach((p) => gen.assign((0, codegen_1$35._)`${props}${(0, codegen_1$35.getProperty)(p)}`, true));
	}
	exports.setEvaluated = setEvaluated;
	const snippets = {};
	function useFunc(gen, f) {
		return gen.scopeValue("func", {
			ref: f,
			code: snippets[f.code] || (snippets[f.code] = new code_1$10._Code(f.code))
		});
	}
	exports.useFunc = useFunc;
	var Type;
	(function(Type$1) {
		Type$1[Type$1["Num"] = 0] = "Num";
		Type$1[Type$1["Str"] = 1] = "Str";
	})(Type || (exports.Type = Type = {}));
	function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
		if (dataProp instanceof codegen_1$35.Name) {
			const isNumber = dataPropType === Type.Num;
			return jsPropertySyntax ? isNumber ? (0, codegen_1$35._)`"[" + ${dataProp} + "]"` : (0, codegen_1$35._)`"['" + ${dataProp} + "']"` : isNumber ? (0, codegen_1$35._)`"/" + ${dataProp}` : (0, codegen_1$35._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
		}
		return jsPropertySyntax ? (0, codegen_1$35.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
	}
	exports.getErrorPath = getErrorPath;
	function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
		if (!mode) return;
		msg = `strict mode: ${msg}`;
		if (mode === true) throw new Error(msg);
		it.self.logger.warn(msg);
	}
	exports.checkStrictMode = checkStrictMode;
}) });

//#endregion
//#region node_modules/ajv/dist/compile/names.js
var require_names = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/compile/names.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$34 = require_codegen();
	const names = {
		data: new codegen_1$34.Name("data"),
		valCxt: new codegen_1$34.Name("valCxt"),
		instancePath: new codegen_1$34.Name("instancePath"),
		parentData: new codegen_1$34.Name("parentData"),
		parentDataProperty: new codegen_1$34.Name("parentDataProperty"),
		rootData: new codegen_1$34.Name("rootData"),
		dynamicAnchors: new codegen_1$34.Name("dynamicAnchors"),
		vErrors: new codegen_1$34.Name("vErrors"),
		errors: new codegen_1$34.Name("errors"),
		this: new codegen_1$34.Name("this"),
		self: new codegen_1$34.Name("self"),
		scope: new codegen_1$34.Name("scope"),
		json: new codegen_1$34.Name("json"),
		jsonPos: new codegen_1$34.Name("jsonPos"),
		jsonLen: new codegen_1$34.Name("jsonLen"),
		jsonPart: new codegen_1$34.Name("jsonPart")
	};
	exports.default = names;
}) });

//#endregion
//#region node_modules/ajv/dist/compile/errors.js
var require_errors = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/compile/errors.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;
	const codegen_1$33 = require_codegen();
	const util_1$29 = require_util();
	const names_1$7 = require_names();
	exports.keywordError = { message: ({ keyword }) => (0, codegen_1$33.str)`must pass "${keyword}" keyword validation` };
	exports.keyword$DataError = { message: ({ keyword, schemaType }) => schemaType ? (0, codegen_1$33.str)`"${keyword}" keyword must be ${schemaType} ($data)` : (0, codegen_1$33.str)`"${keyword}" keyword is invalid ($data)` };
	function reportError(cxt, error = exports.keywordError, errorPaths, overrideAllErrors) {
		const { it } = cxt;
		const { gen, compositeRule, allErrors } = it;
		const errObj = errorObjectCode(cxt, error, errorPaths);
		if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) addError(gen, errObj);
		else returnErrors(it, (0, codegen_1$33._)`[${errObj}]`);
	}
	exports.reportError = reportError;
	function reportExtraError(cxt, error = exports.keywordError, errorPaths) {
		const { it } = cxt;
		const { gen, compositeRule, allErrors } = it;
		addError(gen, errorObjectCode(cxt, error, errorPaths));
		if (!(compositeRule || allErrors)) returnErrors(it, names_1$7.default.vErrors);
	}
	exports.reportExtraError = reportExtraError;
	function resetErrorsCount(gen, errsCount) {
		gen.assign(names_1$7.default.errors, errsCount);
		gen.if((0, codegen_1$33._)`${names_1$7.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1$33._)`${names_1$7.default.vErrors}.length`, errsCount), () => gen.assign(names_1$7.default.vErrors, null)));
	}
	exports.resetErrorsCount = resetErrorsCount;
	function extendErrors({ gen, keyword, schemaValue, data, errsCount, it }) {
		/* istanbul ignore if */
		if (errsCount === void 0) throw new Error("ajv implementation error");
		const err = gen.name("err");
		gen.forRange("i", errsCount, names_1$7.default.errors, (i) => {
			gen.const(err, (0, codegen_1$33._)`${names_1$7.default.vErrors}[${i}]`);
			gen.if((0, codegen_1$33._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_1$33._)`${err}.instancePath`, (0, codegen_1$33.strConcat)(names_1$7.default.instancePath, it.errorPath)));
			gen.assign((0, codegen_1$33._)`${err}.schemaPath`, (0, codegen_1$33.str)`${it.errSchemaPath}/${keyword}`);
			if (it.opts.verbose) {
				gen.assign((0, codegen_1$33._)`${err}.schema`, schemaValue);
				gen.assign((0, codegen_1$33._)`${err}.data`, data);
			}
		});
	}
	exports.extendErrors = extendErrors;
	function addError(gen, errObj) {
		const err = gen.const("err", errObj);
		gen.if((0, codegen_1$33._)`${names_1$7.default.vErrors} === null`, () => gen.assign(names_1$7.default.vErrors, (0, codegen_1$33._)`[${err}]`), (0, codegen_1$33._)`${names_1$7.default.vErrors}.push(${err})`);
		gen.code((0, codegen_1$33._)`${names_1$7.default.errors}++`);
	}
	function returnErrors(it, errs) {
		const { gen, validateName, schemaEnv } = it;
		if (schemaEnv.$async) gen.throw((0, codegen_1$33._)`new ${it.ValidationError}(${errs})`);
		else {
			gen.assign((0, codegen_1$33._)`${validateName}.errors`, errs);
			gen.return(false);
		}
	}
	const E = {
		keyword: new codegen_1$33.Name("keyword"),
		schemaPath: new codegen_1$33.Name("schemaPath"),
		params: new codegen_1$33.Name("params"),
		propertyName: new codegen_1$33.Name("propertyName"),
		message: new codegen_1$33.Name("message"),
		schema: new codegen_1$33.Name("schema"),
		parentSchema: new codegen_1$33.Name("parentSchema")
	};
	function errorObjectCode(cxt, error, errorPaths) {
		const { createErrors } = cxt.it;
		if (createErrors === false) return (0, codegen_1$33._)`{}`;
		return errorObject(cxt, error, errorPaths);
	}
	function errorObject(cxt, error, errorPaths = {}) {
		const { gen, it } = cxt;
		const keyValues = [errorInstancePath(it, errorPaths), errorSchemaPath(cxt, errorPaths)];
		extraErrorProps(cxt, error, keyValues);
		return gen.object(...keyValues);
	}
	function errorInstancePath({ errorPath }, { instancePath }) {
		const instPath = instancePath ? (0, codegen_1$33.str)`${errorPath}${(0, util_1$29.getErrorPath)(instancePath, util_1$29.Type.Str)}` : errorPath;
		return [names_1$7.default.instancePath, (0, codegen_1$33.strConcat)(names_1$7.default.instancePath, instPath)];
	}
	function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
		let schPath = parentSchema ? errSchemaPath : (0, codegen_1$33.str)`${errSchemaPath}/${keyword}`;
		if (schemaPath) schPath = (0, codegen_1$33.str)`${schPath}${(0, util_1$29.getErrorPath)(schemaPath, util_1$29.Type.Str)}`;
		return [E.schemaPath, schPath];
	}
	function extraErrorProps(cxt, { params, message }, keyValues) {
		const { keyword, data, schemaValue, it } = cxt;
		const { opts, propertyName, topSchemaRef, schemaPath } = it;
		keyValues.push([E.keyword, keyword], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1$33._)`{}`]);
		if (opts.messages) keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
		if (opts.verbose) keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1$33._)`${topSchemaRef}${schemaPath}`], [names_1$7.default.data, data]);
		if (propertyName) keyValues.push([E.propertyName, propertyName]);
	}
}) });

//#endregion
//#region node_modules/ajv/dist/compile/validate/boolSchema.js
var require_boolSchema = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/compile/validate/boolSchema.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const errors_1$3 = require_errors();
	const codegen_1$32 = require_codegen();
	const names_1$6 = require_names();
	const boolError = { message: "boolean schema is false" };
	function topBoolOrEmptySchema(it) {
		const { gen, schema: schema$1, validateName } = it;
		if (schema$1 === false) falseSchemaError(it, false);
		else if (typeof schema$1 == "object" && schema$1.$async === true) gen.return(names_1$6.default.data);
		else {
			gen.assign((0, codegen_1$32._)`${validateName}.errors`, null);
			gen.return(true);
		}
	}
	exports.topBoolOrEmptySchema = topBoolOrEmptySchema;
	function boolOrEmptySchema(it, valid) {
		const { gen, schema: schema$1 } = it;
		if (schema$1 === false) {
			gen.var(valid, false);
			falseSchemaError(it);
		} else gen.var(valid, true);
	}
	exports.boolOrEmptySchema = boolOrEmptySchema;
	function falseSchemaError(it, overrideAllErrors) {
		const { gen, data } = it;
		const cxt = {
			gen,
			keyword: "false schema",
			data,
			schema: false,
			schemaCode: false,
			schemaValue: false,
			params: {},
			it
		};
		(0, errors_1$3.reportError)(cxt, boolError, void 0, overrideAllErrors);
	}
}) });

//#endregion
//#region node_modules/ajv/dist/compile/rules.js
var require_rules = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/compile/rules.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const jsonTypes = new Set([
		"string",
		"number",
		"integer",
		"boolean",
		"null",
		"object",
		"array"
	]);
	function isJSONType(x) {
		return typeof x == "string" && jsonTypes.has(x);
	}
	exports.isJSONType = isJSONType;
	function getRules() {
		const groups = {
			number: {
				type: "number",
				rules: []
			},
			string: {
				type: "string",
				rules: []
			},
			array: {
				type: "array",
				rules: []
			},
			object: {
				type: "object",
				rules: []
			}
		};
		return {
			types: {
				...groups,
				integer: true,
				boolean: true,
				null: true
			},
			rules: [
				{ rules: [] },
				groups.number,
				groups.string,
				groups.array,
				groups.object
			],
			post: { rules: [] },
			all: {},
			keywords: {}
		};
	}
	exports.getRules = getRules;
}) });

//#endregion
//#region node_modules/ajv/dist/compile/validate/applicability.js
var require_applicability = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/compile/validate/applicability.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	function schemaHasRulesForType({ schema: schema$1, self }, type) {
		const group = self.RULES.types[type];
		return group && group !== true && shouldUseGroup(schema$1, group);
	}
	exports.schemaHasRulesForType = schemaHasRulesForType;
	function shouldUseGroup(schema$1, group) {
		return group.rules.some((rule) => shouldUseRule(schema$1, rule));
	}
	exports.shouldUseGroup = shouldUseGroup;
	function shouldUseRule(schema$1, rule) {
		var _a$1;
		return schema$1[rule.keyword] !== void 0 || ((_a$1 = rule.definition.implements) === null || _a$1 === void 0 ? void 0 : _a$1.some((kwd) => schema$1[kwd] !== void 0));
	}
	exports.shouldUseRule = shouldUseRule;
}) });

//#endregion
//#region node_modules/ajv/dist/compile/validate/dataType.js
var require_dataType = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/compile/validate/dataType.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const rules_1$1 = require_rules();
	const applicability_1$1 = require_applicability();
	const errors_1$2 = require_errors();
	const codegen_1$31 = require_codegen();
	const util_1$28 = require_util();
	var DataType;
	(function(DataType$1) {
		DataType$1[DataType$1["Correct"] = 0] = "Correct";
		DataType$1[DataType$1["Wrong"] = 1] = "Wrong";
	})(DataType || (exports.DataType = DataType = {}));
	function getSchemaTypes(schema$1) {
		const types = getJSONTypes(schema$1.type);
		if (types.includes("null")) {
			if (schema$1.nullable === false) throw new Error("type: null contradicts nullable: false");
		} else {
			if (!types.length && schema$1.nullable !== void 0) throw new Error("\"nullable\" cannot be used without \"type\"");
			if (schema$1.nullable === true) types.push("null");
		}
		return types;
	}
	exports.getSchemaTypes = getSchemaTypes;
	function getJSONTypes(ts) {
		const types = Array.isArray(ts) ? ts : ts ? [ts] : [];
		if (types.every(rules_1$1.isJSONType)) return types;
		throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
	}
	exports.getJSONTypes = getJSONTypes;
	function coerceAndCheckDataType(it, types) {
		const { gen, data, opts } = it;
		const coerceTo = coerceToTypes(types, opts.coerceTypes);
		const checkTypes = types.length > 0 && !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1$1.schemaHasRulesForType)(it, types[0]));
		if (checkTypes) {
			const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);
			gen.if(wrongType, () => {
				if (coerceTo.length) coerceData(it, types, coerceTo);
				else reportTypeError(it);
			});
		}
		return checkTypes;
	}
	exports.coerceAndCheckDataType = coerceAndCheckDataType;
	const COERCIBLE = new Set([
		"string",
		"number",
		"integer",
		"boolean",
		"null"
	]);
	function coerceToTypes(types, coerceTypes) {
		return coerceTypes ? types.filter((t$1) => COERCIBLE.has(t$1) || coerceTypes === "array" && t$1 === "array") : [];
	}
	function coerceData(it, types, coerceTo) {
		const { gen, data, opts } = it;
		const dataType = gen.let("dataType", (0, codegen_1$31._)`typeof ${data}`);
		const coerced = gen.let("coerced", (0, codegen_1$31._)`undefined`);
		if (opts.coerceTypes === "array") gen.if((0, codegen_1$31._)`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1$31._)`${data}[0]`).assign(dataType, (0, codegen_1$31._)`typeof ${data}`).if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));
		gen.if((0, codegen_1$31._)`${coerced} !== undefined`);
		for (const t$1 of coerceTo) if (COERCIBLE.has(t$1) || t$1 === "array" && opts.coerceTypes === "array") coerceSpecificType(t$1);
		gen.else();
		reportTypeError(it);
		gen.endIf();
		gen.if((0, codegen_1$31._)`${coerced} !== undefined`, () => {
			gen.assign(data, coerced);
			assignParentData(it, coerced);
		});
		function coerceSpecificType(t$1) {
			switch (t$1) {
				case "string":
					gen.elseIf((0, codegen_1$31._)`${dataType} == "number" || ${dataType} == "boolean"`).assign(coerced, (0, codegen_1$31._)`"" + ${data}`).elseIf((0, codegen_1$31._)`${data} === null`).assign(coerced, (0, codegen_1$31._)`""`);
					return;
				case "number":
					gen.elseIf((0, codegen_1$31._)`${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1$31._)`+${data}`);
					return;
				case "integer":
					gen.elseIf((0, codegen_1$31._)`${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1$31._)`+${data}`);
					return;
				case "boolean":
					gen.elseIf((0, codegen_1$31._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1$31._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
					return;
				case "null":
					gen.elseIf((0, codegen_1$31._)`${data} === "" || ${data} === 0 || ${data} === false`);
					gen.assign(coerced, null);
					return;
				case "array": gen.elseIf((0, codegen_1$31._)`${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1$31._)`[${data}]`);
			}
		}
	}
	function assignParentData({ gen, parentData, parentDataProperty }, expr) {
		gen.if((0, codegen_1$31._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1$31._)`${parentData}[${parentDataProperty}]`, expr));
	}
	function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
		const EQ = correct === DataType.Correct ? codegen_1$31.operators.EQ : codegen_1$31.operators.NEQ;
		let cond;
		switch (dataType) {
			case "null": return (0, codegen_1$31._)`${data} ${EQ} null`;
			case "array":
				cond = (0, codegen_1$31._)`Array.isArray(${data})`;
				break;
			case "object":
				cond = (0, codegen_1$31._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
				break;
			case "integer":
				cond = numCond((0, codegen_1$31._)`!(${data} % 1) && !isNaN(${data})`);
				break;
			case "number":
				cond = numCond();
				break;
			default: return (0, codegen_1$31._)`typeof ${data} ${EQ} ${dataType}`;
		}
		return correct === DataType.Correct ? cond : (0, codegen_1$31.not)(cond);
		function numCond(_cond = codegen_1$31.nil) {
			return (0, codegen_1$31.and)((0, codegen_1$31._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1$31._)`isFinite(${data})` : codegen_1$31.nil);
		}
	}
	exports.checkDataType = checkDataType;
	function checkDataTypes(dataTypes, data, strictNums, correct) {
		if (dataTypes.length === 1) return checkDataType(dataTypes[0], data, strictNums, correct);
		let cond;
		const types = (0, util_1$28.toHash)(dataTypes);
		if (types.array && types.object) {
			const notObj = (0, codegen_1$31._)`typeof ${data} != "object"`;
			cond = types.null ? notObj : (0, codegen_1$31._)`!${data} || ${notObj}`;
			delete types.null;
			delete types.array;
			delete types.object;
		} else cond = codegen_1$31.nil;
		if (types.number) delete types.integer;
		for (const t$1 in types) cond = (0, codegen_1$31.and)(cond, checkDataType(t$1, data, strictNums, correct));
		return cond;
	}
	exports.checkDataTypes = checkDataTypes;
	const typeError = {
		message: ({ schema: schema$1 }) => `must be ${schema$1}`,
		params: ({ schema: schema$1, schemaValue }) => typeof schema$1 == "string" ? (0, codegen_1$31._)`{type: ${schema$1}}` : (0, codegen_1$31._)`{type: ${schemaValue}}`
	};
	function reportTypeError(it) {
		const cxt = getTypeErrorContext(it);
		(0, errors_1$2.reportError)(cxt, typeError);
	}
	exports.reportTypeError = reportTypeError;
	function getTypeErrorContext(it) {
		const { gen, data, schema: schema$1 } = it;
		const schemaCode = (0, util_1$28.schemaRefOrVal)(it, schema$1, "type");
		return {
			gen,
			keyword: "type",
			data,
			schema: schema$1.type,
			schemaCode,
			schemaValue: schemaCode,
			parentSchema: schema$1,
			params: {},
			it
		};
	}
}) });

//#endregion
//#region node_modules/ajv/dist/compile/validate/defaults.js
var require_defaults = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/compile/validate/defaults.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$30 = require_codegen();
	const util_1$27 = require_util();
	function assignDefaults(it, ty) {
		const { properties, items } = it.schema;
		if (ty === "object" && properties) for (const key in properties) assignDefault(it, key, properties[key].default);
		else if (ty === "array" && Array.isArray(items)) items.forEach((sch, i) => assignDefault(it, i, sch.default));
	}
	exports.assignDefaults = assignDefaults;
	function assignDefault(it, prop, defaultValue) {
		const { gen, compositeRule, data, opts } = it;
		if (defaultValue === void 0) return;
		const childData = (0, codegen_1$30._)`${data}${(0, codegen_1$30.getProperty)(prop)}`;
		if (compositeRule) {
			(0, util_1$27.checkStrictMode)(it, `default is ignored for: ${childData}`);
			return;
		}
		let condition = (0, codegen_1$30._)`${childData} === undefined`;
		if (opts.useDefaults === "empty") condition = (0, codegen_1$30._)`${condition} || ${childData} === null || ${childData} === ""`;
		gen.if(condition, (0, codegen_1$30._)`${childData} = ${(0, codegen_1$30.stringify)(defaultValue)}`);
	}
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/code.js
var require_code = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/code.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$29 = require_codegen();
	const util_1$26 = require_util();
	const names_1$5 = require_names();
	const util_2$1 = require_util();
	function checkReportMissingProp(cxt, prop) {
		const { gen, data, it } = cxt;
		gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
			cxt.setParams({ missingProperty: (0, codegen_1$29._)`${prop}` }, true);
			cxt.error();
		});
	}
	exports.checkReportMissingProp = checkReportMissingProp;
	function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
		return (0, codegen_1$29.or)(...properties.map((prop) => (0, codegen_1$29.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1$29._)`${missing} = ${prop}`)));
	}
	exports.checkMissingProp = checkMissingProp;
	function reportMissingProp(cxt, missing) {
		cxt.setParams({ missingProperty: missing }, true);
		cxt.error();
	}
	exports.reportMissingProp = reportMissingProp;
	function hasPropFunc(gen) {
		return gen.scopeValue("func", {
			ref: Object.prototype.hasOwnProperty,
			code: (0, codegen_1$29._)`Object.prototype.hasOwnProperty`
		});
	}
	exports.hasPropFunc = hasPropFunc;
	function isOwnProperty(gen, data, property) {
		return (0, codegen_1$29._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
	}
	exports.isOwnProperty = isOwnProperty;
	function propertyInData(gen, data, property, ownProperties) {
		const cond = (0, codegen_1$29._)`${data}${(0, codegen_1$29.getProperty)(property)} !== undefined`;
		return ownProperties ? (0, codegen_1$29._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
	}
	exports.propertyInData = propertyInData;
	function noPropertyInData(gen, data, property, ownProperties) {
		const cond = (0, codegen_1$29._)`${data}${(0, codegen_1$29.getProperty)(property)} === undefined`;
		return ownProperties ? (0, codegen_1$29.or)(cond, (0, codegen_1$29.not)(isOwnProperty(gen, data, property))) : cond;
	}
	exports.noPropertyInData = noPropertyInData;
	function allSchemaProperties(schemaMap) {
		return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
	}
	exports.allSchemaProperties = allSchemaProperties;
	function schemaProperties(it, schemaMap) {
		return allSchemaProperties(schemaMap).filter((p) => !(0, util_1$26.alwaysValidSchema)(it, schemaMap[p]));
	}
	exports.schemaProperties = schemaProperties;
	function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
		const dataAndSchema = passSchema ? (0, codegen_1$29._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
		const valCxt = [
			[names_1$5.default.instancePath, (0, codegen_1$29.strConcat)(names_1$5.default.instancePath, errorPath)],
			[names_1$5.default.parentData, it.parentData],
			[names_1$5.default.parentDataProperty, it.parentDataProperty],
			[names_1$5.default.rootData, names_1$5.default.rootData]
		];
		if (it.opts.dynamicRef) valCxt.push([names_1$5.default.dynamicAnchors, names_1$5.default.dynamicAnchors]);
		const args = (0, codegen_1$29._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
		return context !== codegen_1$29.nil ? (0, codegen_1$29._)`${func}.call(${context}, ${args})` : (0, codegen_1$29._)`${func}(${args})`;
	}
	exports.callValidateCode = callValidateCode;
	const newRegExp = (0, codegen_1$29._)`new RegExp`;
	function usePattern({ gen, it: { opts } }, pattern) {
		const u = opts.unicodeRegExp ? "u" : "";
		const { regExp } = opts.code;
		const rx = regExp(pattern, u);
		return gen.scopeValue("pattern", {
			key: rx.toString(),
			ref: rx,
			code: (0, codegen_1$29._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2$1.useFunc)(gen, regExp)}(${pattern}, ${u})`
		});
	}
	exports.usePattern = usePattern;
	function validateArray(cxt) {
		const { gen, data, keyword, it } = cxt;
		const valid = gen.name("valid");
		if (it.allErrors) {
			const validArr = gen.let("valid", true);
			validateItems(() => gen.assign(validArr, false));
			return validArr;
		}
		gen.var(valid, true);
		validateItems(() => gen.break());
		return valid;
		function validateItems(notValid) {
			const len = gen.const("len", (0, codegen_1$29._)`${data}.length`);
			gen.forRange("i", 0, len, (i) => {
				cxt.subschema({
					keyword,
					dataProp: i,
					dataPropType: util_1$26.Type.Num
				}, valid);
				gen.if((0, codegen_1$29.not)(valid), notValid);
			});
		}
	}
	exports.validateArray = validateArray;
	function validateUnion(cxt) {
		const { gen, schema: schema$1, keyword, it } = cxt;
		/* istanbul ignore if */
		if (!Array.isArray(schema$1)) throw new Error("ajv implementation error");
		if (schema$1.some((sch) => (0, util_1$26.alwaysValidSchema)(it, sch)) && !it.opts.unevaluated) return;
		const valid = gen.let("valid", false);
		const schValid = gen.name("_valid");
		gen.block(() => schema$1.forEach((_sch, i) => {
			const schCxt = cxt.subschema({
				keyword,
				schemaProp: i,
				compositeRule: true
			}, schValid);
			gen.assign(valid, (0, codegen_1$29._)`${valid} || ${schValid}`);
			if (!cxt.mergeValidEvaluated(schCxt, schValid)) gen.if((0, codegen_1$29.not)(valid));
		}));
		cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
	}
	exports.validateUnion = validateUnion;
}) });

//#endregion
//#region node_modules/ajv/dist/compile/validate/keyword.js
var require_keyword = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/compile/validate/keyword.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$28 = require_codegen();
	const names_1$4 = require_names();
	const code_1$9 = require_code();
	const errors_1$1 = require_errors();
	function macroKeywordCode(cxt, def$30) {
		const { gen, keyword, schema: schema$1, parentSchema, it } = cxt;
		const macroSchema = def$30.macro.call(it.self, schema$1, parentSchema, it);
		const schemaRef = useKeyword(gen, keyword, macroSchema);
		if (it.opts.validateSchema !== false) it.self.validateSchema(macroSchema, true);
		const valid = gen.name("valid");
		cxt.subschema({
			schema: macroSchema,
			schemaPath: codegen_1$28.nil,
			errSchemaPath: `${it.errSchemaPath}/${keyword}`,
			topSchemaRef: schemaRef,
			compositeRule: true
		}, valid);
		cxt.pass(valid, () => cxt.error(true));
	}
	exports.macroKeywordCode = macroKeywordCode;
	function funcKeywordCode(cxt, def$30) {
		var _a$1;
		const { gen, keyword, schema: schema$1, parentSchema, $data, it } = cxt;
		checkAsyncKeyword(it, def$30);
		const validateRef = useKeyword(gen, keyword, !$data && def$30.compile ? def$30.compile.call(it.self, schema$1, parentSchema, it) : def$30.validate);
		const valid = gen.let("valid");
		cxt.block$data(valid, validateKeyword);
		cxt.ok((_a$1 = def$30.valid) !== null && _a$1 !== void 0 ? _a$1 : valid);
		function validateKeyword() {
			if (def$30.errors === false) {
				assignValid();
				if (def$30.modifying) modifyData(cxt);
				reportErrs(() => cxt.error());
			} else {
				const ruleErrs = def$30.async ? validateAsync() : validateSync();
				if (def$30.modifying) modifyData(cxt);
				reportErrs(() => addErrs(cxt, ruleErrs));
			}
		}
		function validateAsync() {
			const ruleErrs = gen.let("ruleErrs", null);
			gen.try(() => assignValid((0, codegen_1$28._)`await `), (e) => gen.assign(valid, false).if((0, codegen_1$28._)`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1$28._)`${e}.errors`), () => gen.throw(e)));
			return ruleErrs;
		}
		function validateSync() {
			const validateErrs = (0, codegen_1$28._)`${validateRef}.errors`;
			gen.assign(validateErrs, null);
			assignValid(codegen_1$28.nil);
			return validateErrs;
		}
		function assignValid(_await = def$30.async ? (0, codegen_1$28._)`await ` : codegen_1$28.nil) {
			const passCxt = it.opts.passContext ? names_1$4.default.this : names_1$4.default.self;
			const passSchema = !("compile" in def$30 && !$data || def$30.schema === false);
			gen.assign(valid, (0, codegen_1$28._)`${_await}${(0, code_1$9.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def$30.modifying);
		}
		function reportErrs(errors$1) {
			var _a$2;
			gen.if((0, codegen_1$28.not)((_a$2 = def$30.valid) !== null && _a$2 !== void 0 ? _a$2 : valid), errors$1);
		}
	}
	exports.funcKeywordCode = funcKeywordCode;
	function modifyData(cxt) {
		const { gen, data, it } = cxt;
		gen.if(it.parentData, () => gen.assign(data, (0, codegen_1$28._)`${it.parentData}[${it.parentDataProperty}]`));
	}
	function addErrs(cxt, errs) {
		const { gen } = cxt;
		gen.if((0, codegen_1$28._)`Array.isArray(${errs})`, () => {
			gen.assign(names_1$4.default.vErrors, (0, codegen_1$28._)`${names_1$4.default.vErrors} === null ? ${errs} : ${names_1$4.default.vErrors}.concat(${errs})`).assign(names_1$4.default.errors, (0, codegen_1$28._)`${names_1$4.default.vErrors}.length`);
			(0, errors_1$1.extendErrors)(cxt);
		}, () => cxt.error());
	}
	function checkAsyncKeyword({ schemaEnv }, def$30) {
		if (def$30.async && !schemaEnv.$async) throw new Error("async keyword in sync schema");
	}
	function useKeyword(gen, keyword, result) {
		if (result === void 0) throw new Error(`keyword "${keyword}" failed to compile`);
		return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : {
			ref: result,
			code: (0, codegen_1$28.stringify)(result)
		});
	}
	function validSchemaType(schema$1, schemaType, allowUndefined = false) {
		return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema$1) : st === "object" ? schema$1 && typeof schema$1 == "object" && !Array.isArray(schema$1) : typeof schema$1 == st || allowUndefined && typeof schema$1 == "undefined");
	}
	exports.validSchemaType = validSchemaType;
	function validateKeywordUsage({ schema: schema$1, opts, self, errSchemaPath }, def$30, keyword) {
		/* istanbul ignore if */
		if (Array.isArray(def$30.keyword) ? !def$30.keyword.includes(keyword) : def$30.keyword !== keyword) throw new Error("ajv implementation error");
		const deps = def$30.dependencies;
		if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema$1, kwd))) throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
		if (def$30.validateSchema) {
			if (!def$30.validateSchema(schema$1[keyword])) {
				const msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` + self.errorsText(def$30.validateSchema.errors);
				if (opts.validateSchema === "log") self.logger.error(msg);
				else throw new Error(msg);
			}
		}
	}
	exports.validateKeywordUsage = validateKeywordUsage;
}) });

//#endregion
//#region node_modules/ajv/dist/compile/validate/subschema.js
var require_subschema = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/compile/validate/subschema.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$27 = require_codegen();
	const util_1$25 = require_util();
	function getSubschema(it, { keyword, schemaProp, schema: schema$1, schemaPath, errSchemaPath, topSchemaRef }) {
		if (keyword !== void 0 && schema$1 !== void 0) throw new Error("both \"keyword\" and \"schema\" passed, only one allowed");
		if (keyword !== void 0) {
			const sch = it.schema[keyword];
			return schemaProp === void 0 ? {
				schema: sch,
				schemaPath: (0, codegen_1$27._)`${it.schemaPath}${(0, codegen_1$27.getProperty)(keyword)}`,
				errSchemaPath: `${it.errSchemaPath}/${keyword}`
			} : {
				schema: sch[schemaProp],
				schemaPath: (0, codegen_1$27._)`${it.schemaPath}${(0, codegen_1$27.getProperty)(keyword)}${(0, codegen_1$27.getProperty)(schemaProp)}`,
				errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1$25.escapeFragment)(schemaProp)}`
			};
		}
		if (schema$1 !== void 0) {
			if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) throw new Error("\"schemaPath\", \"errSchemaPath\" and \"topSchemaRef\" are required with \"schema\"");
			return {
				schema: schema$1,
				schemaPath,
				topSchemaRef,
				errSchemaPath
			};
		}
		throw new Error("either \"keyword\" or \"schema\" must be passed");
	}
	exports.getSubschema = getSubschema;
	function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
		if (data !== void 0 && dataProp !== void 0) throw new Error("both \"data\" and \"dataProp\" passed, only one allowed");
		const { gen } = it;
		if (dataProp !== void 0) {
			const { errorPath, dataPathArr, opts } = it;
			dataContextProps(gen.let("data", (0, codegen_1$27._)`${it.data}${(0, codegen_1$27.getProperty)(dataProp)}`, true));
			subschema.errorPath = (0, codegen_1$27.str)`${errorPath}${(0, util_1$25.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
			subschema.parentDataProperty = (0, codegen_1$27._)`${dataProp}`;
			subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
		}
		if (data !== void 0) {
			dataContextProps(data instanceof codegen_1$27.Name ? data : gen.let("data", data, true));
			if (propertyName !== void 0) subschema.propertyName = propertyName;
		}
		if (dataTypes) subschema.dataTypes = dataTypes;
		function dataContextProps(_nextData) {
			subschema.data = _nextData;
			subschema.dataLevel = it.dataLevel + 1;
			subschema.dataTypes = [];
			it.definedProperties = /* @__PURE__ */ new Set();
			subschema.parentData = it.data;
			subschema.dataNames = [...it.dataNames, _nextData];
		}
	}
	exports.extendSubschemaData = extendSubschemaData;
	function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
		if (compositeRule !== void 0) subschema.compositeRule = compositeRule;
		if (createErrors !== void 0) subschema.createErrors = createErrors;
		if (allErrors !== void 0) subschema.allErrors = allErrors;
		subschema.jtdDiscriminator = jtdDiscriminator;
		subschema.jtdMetadata = jtdMetadata;
	}
	exports.extendSubschemaMode = extendSubschemaMode;
}) });

//#endregion
//#region node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = /* @__PURE__ */ __commonJS$2({ "node_modules/fast-deep-equal/index.js": ((exports, module) => {
	module.exports = function equal$3(a, b) {
		if (a === b) return true;
		if (a && b && typeof a == "object" && typeof b == "object") {
			if (a.constructor !== b.constructor) return false;
			var length, i, keys;
			if (Array.isArray(a)) {
				length = a.length;
				if (length != b.length) return false;
				for (i = length; i-- !== 0;) if (!equal$3(a[i], b[i])) return false;
				return true;
			}
			if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
			if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
			if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
			keys = Object.keys(a);
			length = keys.length;
			if (length !== Object.keys(b).length) return false;
			for (i = length; i-- !== 0;) if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
			for (i = length; i-- !== 0;) {
				var key = keys[i];
				if (!equal$3(a[key], b[key])) return false;
			}
			return true;
		}
		return a !== a && b !== b;
	};
}) });

//#endregion
//#region node_modules/json-schema-traverse/index.js
var require_json_schema_traverse = /* @__PURE__ */ __commonJS$2({ "node_modules/json-schema-traverse/index.js": ((exports, module) => {
	var traverse$1 = module.exports = function(schema$1, opts, cb) {
		if (typeof opts == "function") {
			cb = opts;
			opts = {};
		}
		cb = opts.cb || cb;
		var pre = typeof cb == "function" ? cb : cb.pre || function() {};
		var post = cb.post || function() {};
		_traverse(opts, pre, post, schema$1, "", schema$1);
	};
	traverse$1.keywords = {
		additionalItems: true,
		items: true,
		contains: true,
		additionalProperties: true,
		propertyNames: true,
		not: true,
		if: true,
		then: true,
		else: true
	};
	traverse$1.arrayKeywords = {
		items: true,
		allOf: true,
		anyOf: true,
		oneOf: true
	};
	traverse$1.propsKeywords = {
		$defs: true,
		definitions: true,
		properties: true,
		patternProperties: true,
		dependencies: true
	};
	traverse$1.skipKeywords = {
		default: true,
		enum: true,
		const: true,
		required: true,
		maximum: true,
		minimum: true,
		exclusiveMaximum: true,
		exclusiveMinimum: true,
		multipleOf: true,
		maxLength: true,
		minLength: true,
		pattern: true,
		format: true,
		maxItems: true,
		minItems: true,
		uniqueItems: true,
		maxProperties: true,
		minProperties: true
	};
	function _traverse(opts, pre, post, schema$1, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
		if (schema$1 && typeof schema$1 == "object" && !Array.isArray(schema$1)) {
			pre(schema$1, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
			for (var key in schema$1) {
				var sch = schema$1[key];
				if (Array.isArray(sch)) {
					if (key in traverse$1.arrayKeywords) for (var i = 0; i < sch.length; i++) _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema$1, i);
				} else if (key in traverse$1.propsKeywords) {
					if (sch && typeof sch == "object") for (var prop in sch) _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema$1, prop);
				} else if (key in traverse$1.keywords || opts.allKeys && !(key in traverse$1.skipKeywords)) _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema$1);
			}
			post(schema$1, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
		}
	}
	function escapeJsonPtr(str$1) {
		return str$1.replace(/~/g, "~0").replace(/\//g, "~1");
	}
}) });

//#endregion
//#region node_modules/ajv/dist/compile/resolve.js
var require_resolve = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/compile/resolve.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const util_1$24 = require_util();
	const equal$2 = require_fast_deep_equal();
	const traverse = require_json_schema_traverse();
	const SIMPLE_INLINED = new Set([
		"type",
		"format",
		"pattern",
		"maxLength",
		"minLength",
		"maxProperties",
		"minProperties",
		"maxItems",
		"minItems",
		"maximum",
		"minimum",
		"uniqueItems",
		"multipleOf",
		"required",
		"enum",
		"const"
	]);
	function inlineRef(schema$1, limit = true) {
		if (typeof schema$1 == "boolean") return true;
		if (limit === true) return !hasRef(schema$1);
		if (!limit) return false;
		return countKeys(schema$1) <= limit;
	}
	exports.inlineRef = inlineRef;
	const REF_KEYWORDS = new Set([
		"$ref",
		"$recursiveRef",
		"$recursiveAnchor",
		"$dynamicRef",
		"$dynamicAnchor"
	]);
	function hasRef(schema$1) {
		for (const key in schema$1) {
			if (REF_KEYWORDS.has(key)) return true;
			const sch = schema$1[key];
			if (Array.isArray(sch) && sch.some(hasRef)) return true;
			if (typeof sch == "object" && hasRef(sch)) return true;
		}
		return false;
	}
	function countKeys(schema$1) {
		let count = 0;
		for (const key in schema$1) {
			if (key === "$ref") return Infinity;
			count++;
			if (SIMPLE_INLINED.has(key)) continue;
			if (typeof schema$1[key] == "object") (0, util_1$24.eachItem)(schema$1[key], (sch) => count += countKeys(sch));
			if (count === Infinity) return Infinity;
		}
		return count;
	}
	function getFullPath(resolver, id = "", normalize$1) {
		if (normalize$1 !== false) id = normalizeId(id);
		return _getFullPath(resolver, resolver.parse(id));
	}
	exports.getFullPath = getFullPath;
	function _getFullPath(resolver, p) {
		return resolver.serialize(p).split("#")[0] + "#";
	}
	exports._getFullPath = _getFullPath;
	const TRAILING_SLASH_HASH = /#\/?$/;
	function normalizeId(id) {
		return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
	}
	exports.normalizeId = normalizeId;
	function resolveUrl(resolver, baseId, id) {
		id = normalizeId(id);
		return resolver.resolve(baseId, id);
	}
	exports.resolveUrl = resolveUrl;
	const ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
	function getSchemaRefs(schema$1, baseId) {
		if (typeof schema$1 == "boolean") return {};
		const { schemaId, uriResolver } = this.opts;
		const schId = normalizeId(schema$1[schemaId] || baseId);
		const baseIds = { "": schId };
		const pathPrefix = getFullPath(uriResolver, schId, false);
		const localRefs = {};
		const schemaRefs = /* @__PURE__ */ new Set();
		traverse(schema$1, { allKeys: true }, (sch, jsonPtr, _$1, parentJsonPtr) => {
			if (parentJsonPtr === void 0) return;
			const fullPath = pathPrefix + jsonPtr;
			let innerBaseId = baseIds[parentJsonPtr];
			if (typeof sch[schemaId] == "string") innerBaseId = addRef.call(this, sch[schemaId]);
			addAnchor.call(this, sch.$anchor);
			addAnchor.call(this, sch.$dynamicAnchor);
			baseIds[jsonPtr] = innerBaseId;
			function addRef(ref) {
				const _resolve = this.opts.uriResolver.resolve;
				ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref);
				if (schemaRefs.has(ref)) throw ambiguos(ref);
				schemaRefs.add(ref);
				let schOrRef = this.refs[ref];
				if (typeof schOrRef == "string") schOrRef = this.refs[schOrRef];
				if (typeof schOrRef == "object") checkAmbiguosRef(sch, schOrRef.schema, ref);
				else if (ref !== normalizeId(fullPath)) if (ref[0] === "#") {
					checkAmbiguosRef(sch, localRefs[ref], ref);
					localRefs[ref] = sch;
				} else this.refs[ref] = fullPath;
				return ref;
			}
			function addAnchor(anchor) {
				if (typeof anchor == "string") {
					if (!ANCHOR.test(anchor)) throw new Error(`invalid anchor "${anchor}"`);
					addRef.call(this, `#${anchor}`);
				}
			}
		});
		return localRefs;
		function checkAmbiguosRef(sch1, sch2, ref) {
			if (sch2 !== void 0 && !equal$2(sch1, sch2)) throw ambiguos(ref);
		}
		function ambiguos(ref) {
			return /* @__PURE__ */ new Error(`reference "${ref}" resolves to more than one schema`);
		}
	}
	exports.getSchemaRefs = getSchemaRefs;
}) });

//#endregion
//#region node_modules/ajv/dist/compile/validate/index.js
var require_validate = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/compile/validate/index.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const boolSchema_1 = require_boolSchema();
	const dataType_1$2 = require_dataType();
	const applicability_1 = require_applicability();
	const dataType_2 = require_dataType();
	const defaults_1 = require_defaults();
	const keyword_1 = require_keyword();
	const subschema_1 = require_subschema();
	const codegen_1$26 = require_codegen();
	const names_1$3 = require_names();
	const resolve_1$3 = require_resolve();
	const util_1$23 = require_util();
	const errors_1 = require_errors();
	function validateFunctionCode(it) {
		if (isSchemaObj(it)) {
			checkKeywords(it);
			if (schemaCxtHasRules(it)) {
				topSchemaObjCode(it);
				return;
			}
		}
		validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
	}
	exports.validateFunctionCode = validateFunctionCode;
	function validateFunction({ gen, validateName, schema: schema$1, schemaEnv, opts }, body) {
		if (opts.code.es5) gen.func(validateName, (0, codegen_1$26._)`${names_1$3.default.data}, ${names_1$3.default.valCxt}`, schemaEnv.$async, () => {
			gen.code((0, codegen_1$26._)`"use strict"; ${funcSourceUrl(schema$1, opts)}`);
			destructureValCxtES5(gen, opts);
			gen.code(body);
		});
		else gen.func(validateName, (0, codegen_1$26._)`${names_1$3.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema$1, opts)).code(body));
	}
	function destructureValCxt(opts) {
		return (0, codegen_1$26._)`{${names_1$3.default.instancePath}="", ${names_1$3.default.parentData}, ${names_1$3.default.parentDataProperty}, ${names_1$3.default.rootData}=${names_1$3.default.data}${opts.dynamicRef ? (0, codegen_1$26._)`, ${names_1$3.default.dynamicAnchors}={}` : codegen_1$26.nil}}={}`;
	}
	function destructureValCxtES5(gen, opts) {
		gen.if(names_1$3.default.valCxt, () => {
			gen.var(names_1$3.default.instancePath, (0, codegen_1$26._)`${names_1$3.default.valCxt}.${names_1$3.default.instancePath}`);
			gen.var(names_1$3.default.parentData, (0, codegen_1$26._)`${names_1$3.default.valCxt}.${names_1$3.default.parentData}`);
			gen.var(names_1$3.default.parentDataProperty, (0, codegen_1$26._)`${names_1$3.default.valCxt}.${names_1$3.default.parentDataProperty}`);
			gen.var(names_1$3.default.rootData, (0, codegen_1$26._)`${names_1$3.default.valCxt}.${names_1$3.default.rootData}`);
			if (opts.dynamicRef) gen.var(names_1$3.default.dynamicAnchors, (0, codegen_1$26._)`${names_1$3.default.valCxt}.${names_1$3.default.dynamicAnchors}`);
		}, () => {
			gen.var(names_1$3.default.instancePath, (0, codegen_1$26._)`""`);
			gen.var(names_1$3.default.parentData, (0, codegen_1$26._)`undefined`);
			gen.var(names_1$3.default.parentDataProperty, (0, codegen_1$26._)`undefined`);
			gen.var(names_1$3.default.rootData, names_1$3.default.data);
			if (opts.dynamicRef) gen.var(names_1$3.default.dynamicAnchors, (0, codegen_1$26._)`{}`);
		});
	}
	function topSchemaObjCode(it) {
		const { schema: schema$1, opts, gen } = it;
		validateFunction(it, () => {
			if (opts.$comment && schema$1.$comment) commentKeyword(it);
			checkNoDefault(it);
			gen.let(names_1$3.default.vErrors, null);
			gen.let(names_1$3.default.errors, 0);
			if (opts.unevaluated) resetEvaluated(it);
			typeAndKeywords(it);
			returnResults(it);
		});
	}
	function resetEvaluated(it) {
		const { gen, validateName } = it;
		it.evaluated = gen.const("evaluated", (0, codegen_1$26._)`${validateName}.evaluated`);
		gen.if((0, codegen_1$26._)`${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1$26._)`${it.evaluated}.props`, (0, codegen_1$26._)`undefined`));
		gen.if((0, codegen_1$26._)`${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1$26._)`${it.evaluated}.items`, (0, codegen_1$26._)`undefined`));
	}
	function funcSourceUrl(schema$1, opts) {
		const schId = typeof schema$1 == "object" && schema$1[opts.schemaId];
		return schId && (opts.code.source || opts.code.process) ? (0, codegen_1$26._)`/*# sourceURL=${schId} */` : codegen_1$26.nil;
	}
	function subschemaCode(it, valid) {
		if (isSchemaObj(it)) {
			checkKeywords(it);
			if (schemaCxtHasRules(it)) {
				subSchemaObjCode(it, valid);
				return;
			}
		}
		(0, boolSchema_1.boolOrEmptySchema)(it, valid);
	}
	function schemaCxtHasRules({ schema: schema$1, self }) {
		if (typeof schema$1 == "boolean") return !schema$1;
		for (const key in schema$1) if (self.RULES.all[key]) return true;
		return false;
	}
	function isSchemaObj(it) {
		return typeof it.schema != "boolean";
	}
	function subSchemaObjCode(it, valid) {
		const { schema: schema$1, gen, opts } = it;
		if (opts.$comment && schema$1.$comment) commentKeyword(it);
		updateContext(it);
		checkAsyncSchema(it);
		const errsCount = gen.const("_errs", names_1$3.default.errors);
		typeAndKeywords(it, errsCount);
		gen.var(valid, (0, codegen_1$26._)`${errsCount} === ${names_1$3.default.errors}`);
	}
	function checkKeywords(it) {
		(0, util_1$23.checkUnknownRules)(it);
		checkRefsAndKeywords(it);
	}
	function typeAndKeywords(it, errsCount) {
		if (it.opts.jtd) return schemaKeywords(it, [], false, errsCount);
		const types = (0, dataType_1$2.getSchemaTypes)(it.schema);
		schemaKeywords(it, types, !(0, dataType_1$2.coerceAndCheckDataType)(it, types), errsCount);
	}
	function checkRefsAndKeywords(it) {
		const { schema: schema$1, errSchemaPath, opts, self } = it;
		if (schema$1.$ref && opts.ignoreKeywordsWithRef && (0, util_1$23.schemaHasRulesButRef)(schema$1, self.RULES)) self.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
	}
	function checkNoDefault(it) {
		const { schema: schema$1, opts } = it;
		if (schema$1.default !== void 0 && opts.useDefaults && opts.strictSchema) (0, util_1$23.checkStrictMode)(it, "default is ignored in the schema root");
	}
	function updateContext(it) {
		const schId = it.schema[it.opts.schemaId];
		if (schId) it.baseId = (0, resolve_1$3.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
	}
	function checkAsyncSchema(it) {
		if (it.schema.$async && !it.schemaEnv.$async) throw new Error("async schema in sync schema");
	}
	function commentKeyword({ gen, schemaEnv, schema: schema$1, errSchemaPath, opts }) {
		const msg = schema$1.$comment;
		if (opts.$comment === true) gen.code((0, codegen_1$26._)`${names_1$3.default.self}.logger.log(${msg})`);
		else if (typeof opts.$comment == "function") {
			const schemaPath = (0, codegen_1$26.str)`${errSchemaPath}/$comment`;
			const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
			gen.code((0, codegen_1$26._)`${names_1$3.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
		}
	}
	function returnResults(it) {
		const { gen, schemaEnv, validateName, ValidationError: ValidationError$1, opts } = it;
		if (schemaEnv.$async) gen.if((0, codegen_1$26._)`${names_1$3.default.errors} === 0`, () => gen.return(names_1$3.default.data), () => gen.throw((0, codegen_1$26._)`new ${ValidationError$1}(${names_1$3.default.vErrors})`));
		else {
			gen.assign((0, codegen_1$26._)`${validateName}.errors`, names_1$3.default.vErrors);
			if (opts.unevaluated) assignEvaluated(it);
			gen.return((0, codegen_1$26._)`${names_1$3.default.errors} === 0`);
		}
	}
	function assignEvaluated({ gen, evaluated, props, items }) {
		if (props instanceof codegen_1$26.Name) gen.assign((0, codegen_1$26._)`${evaluated}.props`, props);
		if (items instanceof codegen_1$26.Name) gen.assign((0, codegen_1$26._)`${evaluated}.items`, items);
	}
	function schemaKeywords(it, types, typeErrors, errsCount) {
		const { gen, schema: schema$1, data, allErrors, opts, self } = it;
		const { RULES } = self;
		if (schema$1.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1$23.schemaHasRulesButRef)(schema$1, RULES))) {
			gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
			return;
		}
		if (!opts.jtd) checkStrictTypes(it, types);
		gen.block(() => {
			for (const group of RULES.rules) groupKeywords(group);
			groupKeywords(RULES.post);
		});
		function groupKeywords(group) {
			if (!(0, applicability_1.shouldUseGroup)(schema$1, group)) return;
			if (group.type) {
				gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
				iterateKeywords(it, group);
				if (types.length === 1 && types[0] === group.type && typeErrors) {
					gen.else();
					(0, dataType_2.reportTypeError)(it);
				}
				gen.endIf();
			} else iterateKeywords(it, group);
			if (!allErrors) gen.if((0, codegen_1$26._)`${names_1$3.default.errors} === ${errsCount || 0}`);
		}
	}
	function iterateKeywords(it, group) {
		const { gen, schema: schema$1, opts: { useDefaults } } = it;
		if (useDefaults) (0, defaults_1.assignDefaults)(it, group.type);
		gen.block(() => {
			for (const rule of group.rules) if ((0, applicability_1.shouldUseRule)(schema$1, rule)) keywordCode(it, rule.keyword, rule.definition, group.type);
		});
	}
	function checkStrictTypes(it, types) {
		if (it.schemaEnv.meta || !it.opts.strictTypes) return;
		checkContextTypes(it, types);
		if (!it.opts.allowUnionTypes) checkMultipleTypes(it, types);
		checkKeywordTypes(it, it.dataTypes);
	}
	function checkContextTypes(it, types) {
		if (!types.length) return;
		if (!it.dataTypes.length) {
			it.dataTypes = types;
			return;
		}
		types.forEach((t$1) => {
			if (!includesType(it.dataTypes, t$1)) strictTypesError(it, `type "${t$1}" not allowed by context "${it.dataTypes.join(",")}"`);
		});
		narrowSchemaTypes(it, types);
	}
	function checkMultipleTypes(it, ts) {
		if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) strictTypesError(it, "use allowUnionTypes to allow union type keyword");
	}
	function checkKeywordTypes(it, ts) {
		const rules = it.self.RULES.all;
		for (const keyword in rules) {
			const rule = rules[keyword];
			if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
				const { type } = rule.definition;
				if (type.length && !type.some((t$1) => hasApplicableType(ts, t$1))) strictTypesError(it, `missing type "${type.join(",")}" for keyword "${keyword}"`);
			}
		}
	}
	function hasApplicableType(schTs, kwdT) {
		return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
	}
	function includesType(ts, t$1) {
		return ts.includes(t$1) || t$1 === "integer" && ts.includes("number");
	}
	function narrowSchemaTypes(it, withTypes) {
		const ts = [];
		for (const t$1 of it.dataTypes) if (includesType(withTypes, t$1)) ts.push(t$1);
		else if (withTypes.includes("integer") && t$1 === "number") ts.push("integer");
		it.dataTypes = ts;
	}
	function strictTypesError(it, msg) {
		const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
		msg += ` at "${schemaPath}" (strictTypes)`;
		(0, util_1$23.checkStrictMode)(it, msg, it.opts.strictTypes);
	}
	var KeywordCxt = class {
		constructor(it, def$30, keyword) {
			(0, keyword_1.validateKeywordUsage)(it, def$30, keyword);
			this.gen = it.gen;
			this.allErrors = it.allErrors;
			this.keyword = keyword;
			this.data = it.data;
			this.schema = it.schema[keyword];
			this.$data = def$30.$data && it.opts.$data && this.schema && this.schema.$data;
			this.schemaValue = (0, util_1$23.schemaRefOrVal)(it, this.schema, keyword, this.$data);
			this.schemaType = def$30.schemaType;
			this.parentSchema = it.schema;
			this.params = {};
			this.it = it;
			this.def = def$30;
			if (this.$data) this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
			else {
				this.schemaCode = this.schemaValue;
				if (!(0, keyword_1.validSchemaType)(this.schema, def$30.schemaType, def$30.allowUndefined)) throw new Error(`${keyword} value must be ${JSON.stringify(def$30.schemaType)}`);
			}
			if ("code" in def$30 ? def$30.trackErrors : def$30.errors !== false) this.errsCount = it.gen.const("_errs", names_1$3.default.errors);
		}
		result(condition, successAction, failAction) {
			this.failResult((0, codegen_1$26.not)(condition), successAction, failAction);
		}
		failResult(condition, successAction, failAction) {
			this.gen.if(condition);
			if (failAction) failAction();
			else this.error();
			if (successAction) {
				this.gen.else();
				successAction();
				if (this.allErrors) this.gen.endIf();
			} else if (this.allErrors) this.gen.endIf();
			else this.gen.else();
		}
		pass(condition, failAction) {
			this.failResult((0, codegen_1$26.not)(condition), void 0, failAction);
		}
		fail(condition) {
			if (condition === void 0) {
				this.error();
				if (!this.allErrors) this.gen.if(false);
				return;
			}
			this.gen.if(condition);
			this.error();
			if (this.allErrors) this.gen.endIf();
			else this.gen.else();
		}
		fail$data(condition) {
			if (!this.$data) return this.fail(condition);
			const { schemaCode } = this;
			this.fail((0, codegen_1$26._)`${schemaCode} !== undefined && (${(0, codegen_1$26.or)(this.invalid$data(), condition)})`);
		}
		error(append, errorParams, errorPaths) {
			if (errorParams) {
				this.setParams(errorParams);
				this._error(append, errorPaths);
				this.setParams({});
				return;
			}
			this._error(append, errorPaths);
		}
		_error(append, errorPaths) {
			(append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
		}
		$dataError() {
			(0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
		}
		reset() {
			if (this.errsCount === void 0) throw new Error("add \"trackErrors\" to keyword definition");
			(0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
		}
		ok(cond) {
			if (!this.allErrors) this.gen.if(cond);
		}
		setParams(obj, assign) {
			if (assign) Object.assign(this.params, obj);
			else this.params = obj;
		}
		block$data(valid, codeBlock, $dataValid = codegen_1$26.nil) {
			this.gen.block(() => {
				this.check$data(valid, $dataValid);
				codeBlock();
			});
		}
		check$data(valid = codegen_1$26.nil, $dataValid = codegen_1$26.nil) {
			if (!this.$data) return;
			const { gen, schemaCode, schemaType, def: def$30 } = this;
			gen.if((0, codegen_1$26.or)((0, codegen_1$26._)`${schemaCode} === undefined`, $dataValid));
			if (valid !== codegen_1$26.nil) gen.assign(valid, true);
			if (schemaType.length || def$30.validateSchema) {
				gen.elseIf(this.invalid$data());
				this.$dataError();
				if (valid !== codegen_1$26.nil) gen.assign(valid, false);
			}
			gen.else();
		}
		invalid$data() {
			const { gen, schemaCode, schemaType, def: def$30, it } = this;
			return (0, codegen_1$26.or)(wrong$DataType(), invalid$DataSchema());
			function wrong$DataType() {
				if (schemaType.length) {
					/* istanbul ignore if */
					if (!(schemaCode instanceof codegen_1$26.Name)) throw new Error("ajv implementation error");
					const st = Array.isArray(schemaType) ? schemaType : [schemaType];
					return (0, codegen_1$26._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
				}
				return codegen_1$26.nil;
			}
			function invalid$DataSchema() {
				if (def$30.validateSchema) {
					const validateSchemaRef = gen.scopeValue("validate$data", { ref: def$30.validateSchema });
					return (0, codegen_1$26._)`!${validateSchemaRef}(${schemaCode})`;
				}
				return codegen_1$26.nil;
			}
		}
		subschema(appl, valid) {
			const subschema = (0, subschema_1.getSubschema)(this.it, appl);
			(0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
			(0, subschema_1.extendSubschemaMode)(subschema, appl);
			const nextContext = {
				...this.it,
				...subschema,
				items: void 0,
				props: void 0
			};
			subschemaCode(nextContext, valid);
			return nextContext;
		}
		mergeEvaluated(schemaCxt, toName) {
			const { it, gen } = this;
			if (!it.opts.unevaluated) return;
			if (it.props !== true && schemaCxt.props !== void 0) it.props = util_1$23.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
			if (it.items !== true && schemaCxt.items !== void 0) it.items = util_1$23.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
		}
		mergeValidEvaluated(schemaCxt, valid) {
			const { it, gen } = this;
			if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
				gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1$26.Name));
				return true;
			}
		}
	};
	exports.KeywordCxt = KeywordCxt;
	function keywordCode(it, keyword, def$30, ruleType) {
		const cxt = new KeywordCxt(it, def$30, keyword);
		if ("code" in def$30) def$30.code(cxt, ruleType);
		else if (cxt.$data && def$30.validate) (0, keyword_1.funcKeywordCode)(cxt, def$30);
		else if ("macro" in def$30) (0, keyword_1.macroKeywordCode)(cxt, def$30);
		else if (def$30.compile || def$30.validate) (0, keyword_1.funcKeywordCode)(cxt, def$30);
	}
	const JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
	const RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
	function getData($data, { dataLevel, dataNames, dataPathArr }) {
		let jsonPointer;
		let data;
		if ($data === "") return names_1$3.default.rootData;
		if ($data[0] === "/") {
			if (!JSON_POINTER.test($data)) throw new Error(`Invalid JSON-pointer: ${$data}`);
			jsonPointer = $data;
			data = names_1$3.default.rootData;
		} else {
			const matches = RELATIVE_JSON_POINTER.exec($data);
			if (!matches) throw new Error(`Invalid JSON-pointer: ${$data}`);
			const up = +matches[1];
			jsonPointer = matches[2];
			if (jsonPointer === "#") {
				if (up >= dataLevel) throw new Error(errorMsg("property/index", up));
				return dataPathArr[dataLevel - up];
			}
			if (up > dataLevel) throw new Error(errorMsg("data", up));
			data = dataNames[dataLevel - up];
			if (!jsonPointer) return data;
		}
		let expr = data;
		const segments = jsonPointer.split("/");
		for (const segment of segments) if (segment) {
			data = (0, codegen_1$26._)`${data}${(0, codegen_1$26.getProperty)((0, util_1$23.unescapeJsonPointer)(segment))}`;
			expr = (0, codegen_1$26._)`${expr} && ${data}`;
		}
		return expr;
		function errorMsg(pointerType, up) {
			return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
		}
	}
	exports.getData = getData;
}) });

//#endregion
//#region node_modules/ajv/dist/runtime/validation_error.js
var require_validation_error = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/runtime/validation_error.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var ValidationError = class extends Error {
		constructor(errors$1) {
			super("validation failed");
			this.errors = errors$1;
			this.ajv = this.validation = true;
		}
	};
	exports.default = ValidationError;
}) });

//#endregion
//#region node_modules/ajv/dist/compile/ref_error.js
var require_ref_error = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/compile/ref_error.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const resolve_1$2 = require_resolve();
	var MissingRefError = class extends Error {
		constructor(resolver, baseId, ref, msg) {
			super(msg || `can't resolve reference ${ref} from id ${baseId}`);
			this.missingRef = (0, resolve_1$2.resolveUrl)(resolver, baseId, ref);
			this.missingSchema = (0, resolve_1$2.normalizeId)((0, resolve_1$2.getFullPath)(resolver, this.missingRef));
		}
	};
	exports.default = MissingRefError;
}) });

//#endregion
//#region node_modules/ajv/dist/compile/index.js
var require_compile = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/compile/index.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$25 = require_codegen();
	const validation_error_1$2 = require_validation_error();
	const names_1$2 = require_names();
	const resolve_1$1 = require_resolve();
	const util_1$22 = require_util();
	const validate_1$3 = require_validate();
	var SchemaEnv = class {
		constructor(env) {
			var _a$1;
			this.refs = {};
			this.dynamicAnchors = {};
			let schema$1;
			if (typeof env.schema == "object") schema$1 = env.schema;
			this.schema = env.schema;
			this.schemaId = env.schemaId;
			this.root = env.root || this;
			this.baseId = (_a$1 = env.baseId) !== null && _a$1 !== void 0 ? _a$1 : (0, resolve_1$1.normalizeId)(schema$1 === null || schema$1 === void 0 ? void 0 : schema$1[env.schemaId || "$id"]);
			this.schemaPath = env.schemaPath;
			this.localRefs = env.localRefs;
			this.meta = env.meta;
			this.$async = schema$1 === null || schema$1 === void 0 ? void 0 : schema$1.$async;
			this.refs = {};
		}
	};
	exports.SchemaEnv = SchemaEnv;
	function compileSchema(sch) {
		const _sch = getCompilingSchema.call(this, sch);
		if (_sch) return _sch;
		const rootId = (0, resolve_1$1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
		const { es5, lines } = this.opts.code;
		const { ownProperties } = this.opts;
		const gen = new codegen_1$25.CodeGen(this.scope, {
			es5,
			lines,
			ownProperties
		});
		let _ValidationError;
		if (sch.$async) _ValidationError = gen.scopeValue("Error", {
			ref: validation_error_1$2.default,
			code: (0, codegen_1$25._)`require("ajv/dist/runtime/validation_error").default`
		});
		const validateName = gen.scopeName("validate");
		sch.validateName = validateName;
		const schemaCxt = {
			gen,
			allErrors: this.opts.allErrors,
			data: names_1$2.default.data,
			parentData: names_1$2.default.parentData,
			parentDataProperty: names_1$2.default.parentDataProperty,
			dataNames: [names_1$2.default.data],
			dataPathArr: [codegen_1$25.nil],
			dataLevel: 0,
			dataTypes: [],
			definedProperties: /* @__PURE__ */ new Set(),
			topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? {
				ref: sch.schema,
				code: (0, codegen_1$25.stringify)(sch.schema)
			} : { ref: sch.schema }),
			validateName,
			ValidationError: _ValidationError,
			schema: sch.schema,
			schemaEnv: sch,
			rootId,
			baseId: sch.baseId || rootId,
			schemaPath: codegen_1$25.nil,
			errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
			errorPath: (0, codegen_1$25._)`""`,
			opts: this.opts,
			self: this
		};
		let sourceCode;
		try {
			this._compilations.add(sch);
			(0, validate_1$3.validateFunctionCode)(schemaCxt);
			gen.optimize(this.opts.code.optimize);
			const validateCode = gen.toString();
			sourceCode = `${gen.scopeRefs(names_1$2.default.scope)}return ${validateCode}`;
			if (this.opts.code.process) sourceCode = this.opts.code.process(sourceCode, sch);
			const validate = new Function(`${names_1$2.default.self}`, `${names_1$2.default.scope}`, sourceCode)(this, this.scope.get());
			this.scope.value(validateName, { ref: validate });
			validate.errors = null;
			validate.schema = sch.schema;
			validate.schemaEnv = sch;
			if (sch.$async) validate.$async = true;
			if (this.opts.code.source === true) validate.source = {
				validateName,
				validateCode,
				scopeValues: gen._values
			};
			if (this.opts.unevaluated) {
				const { props, items } = schemaCxt;
				validate.evaluated = {
					props: props instanceof codegen_1$25.Name ? void 0 : props,
					items: items instanceof codegen_1$25.Name ? void 0 : items,
					dynamicProps: props instanceof codegen_1$25.Name,
					dynamicItems: items instanceof codegen_1$25.Name
				};
				if (validate.source) validate.source.evaluated = (0, codegen_1$25.stringify)(validate.evaluated);
			}
			sch.validate = validate;
			return sch;
		} catch (e) {
			delete sch.validate;
			delete sch.validateName;
			if (sourceCode) this.logger.error("Error compiling schema, function code:", sourceCode);
			throw e;
		} finally {
			this._compilations.delete(sch);
		}
	}
	exports.compileSchema = compileSchema;
	function resolveRef(root, baseId, ref) {
		var _a$1;
		ref = (0, resolve_1$1.resolveUrl)(this.opts.uriResolver, baseId, ref);
		const schOrFunc = root.refs[ref];
		if (schOrFunc) return schOrFunc;
		let _sch = resolve$1.call(this, root, ref);
		if (_sch === void 0) {
			const schema$1 = (_a$1 = root.localRefs) === null || _a$1 === void 0 ? void 0 : _a$1[ref];
			const { schemaId } = this.opts;
			if (schema$1) _sch = new SchemaEnv({
				schema: schema$1,
				schemaId,
				root,
				baseId
			});
		}
		if (_sch === void 0) return;
		return root.refs[ref] = inlineOrCompile.call(this, _sch);
	}
	exports.resolveRef = resolveRef;
	function inlineOrCompile(sch) {
		if ((0, resolve_1$1.inlineRef)(sch.schema, this.opts.inlineRefs)) return sch.schema;
		return sch.validate ? sch : compileSchema.call(this, sch);
	}
	function getCompilingSchema(schEnv) {
		for (const sch of this._compilations) if (sameSchemaEnv(sch, schEnv)) return sch;
	}
	exports.getCompilingSchema = getCompilingSchema;
	function sameSchemaEnv(s1, s2) {
		return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
	}
	function resolve$1(root, ref) {
		let sch;
		while (typeof (sch = this.refs[ref]) == "string") ref = sch;
		return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
	}
	function resolveSchema(root, ref) {
		const p = this.opts.uriResolver.parse(ref);
		const refPath = (0, resolve_1$1._getFullPath)(this.opts.uriResolver, p);
		let baseId = (0, resolve_1$1.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
		if (Object.keys(root.schema).length > 0 && refPath === baseId) return getJsonPointer.call(this, p, root);
		const id = (0, resolve_1$1.normalizeId)(refPath);
		const schOrRef = this.refs[id] || this.schemas[id];
		if (typeof schOrRef == "string") {
			const sch = resolveSchema.call(this, root, schOrRef);
			if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object") return;
			return getJsonPointer.call(this, p, sch);
		}
		if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object") return;
		if (!schOrRef.validate) compileSchema.call(this, schOrRef);
		if (id === (0, resolve_1$1.normalizeId)(ref)) {
			const { schema: schema$1 } = schOrRef;
			const { schemaId } = this.opts;
			const schId = schema$1[schemaId];
			if (schId) baseId = (0, resolve_1$1.resolveUrl)(this.opts.uriResolver, baseId, schId);
			return new SchemaEnv({
				schema: schema$1,
				schemaId,
				root,
				baseId
			});
		}
		return getJsonPointer.call(this, p, schOrRef);
	}
	exports.resolveSchema = resolveSchema;
	const PREVENT_SCOPE_CHANGE = new Set([
		"properties",
		"patternProperties",
		"enum",
		"dependencies",
		"definitions"
	]);
	function getJsonPointer(parsedRef, { baseId, schema: schema$1, root }) {
		var _a$1;
		if (((_a$1 = parsedRef.fragment) === null || _a$1 === void 0 ? void 0 : _a$1[0]) !== "/") return;
		for (const part of parsedRef.fragment.slice(1).split("/")) {
			if (typeof schema$1 === "boolean") return;
			const partSchema = schema$1[(0, util_1$22.unescapeFragment)(part)];
			if (partSchema === void 0) return;
			schema$1 = partSchema;
			const schId = typeof schema$1 === "object" && schema$1[this.opts.schemaId];
			if (!PREVENT_SCOPE_CHANGE.has(part) && schId) baseId = (0, resolve_1$1.resolveUrl)(this.opts.uriResolver, baseId, schId);
		}
		let env;
		if (typeof schema$1 != "boolean" && schema$1.$ref && !(0, util_1$22.schemaHasRulesButRef)(schema$1, this.RULES)) {
			const $ref = (0, resolve_1$1.resolveUrl)(this.opts.uriResolver, baseId, schema$1.$ref);
			env = resolveSchema.call(this, root, $ref);
		}
		const { schemaId } = this.opts;
		env = env || new SchemaEnv({
			schema: schema$1,
			schemaId,
			root,
			baseId
		});
		if (env.schema !== env.root.schema) return env;
	}
}) });

//#endregion
//#region node_modules/ajv/dist/refs/data.json
var require_data = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/refs/data.json": ((exports, module) => {
	module.exports = {
		"$id": "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
		"description": "Meta-schema for $data reference (JSON AnySchema extension proposal)",
		"type": "object",
		"required": ["$data"],
		"properties": { "$data": {
			"type": "string",
			"anyOf": [{ "format": "relative-json-pointer" }, { "format": "json-pointer" }]
		} },
		"additionalProperties": false
	};
}) });

//#endregion
//#region node_modules/fast-uri/lib/utils.js
var require_utils = /* @__PURE__ */ __commonJS$2({ "node_modules/fast-uri/lib/utils.js": ((exports, module) => {
	/** @type {(value: string) => boolean} */
	const isUUID$1 = RegExp.prototype.test.bind(/^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu);
	/** @type {(value: string) => boolean} */
	const isIPv4$1 = RegExp.prototype.test.bind(/^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u);
	/**
	* @param {Array<string>} input
	* @returns {string}
	*/
	function stringArrayToHexStripped(input) {
		let acc = "";
		let code = 0;
		let i = 0;
		for (i = 0; i < input.length; i++) {
			code = input[i].charCodeAt(0);
			if (code === 48) continue;
			if (!(code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102)) return "";
			acc += input[i];
			break;
		}
		for (i += 1; i < input.length; i++) {
			code = input[i].charCodeAt(0);
			if (!(code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102)) return "";
			acc += input[i];
		}
		return acc;
	}
	/**
	* @typedef {Object} GetIPV6Result
	* @property {boolean} error - Indicates if there was an error parsing the IPv6 address.
	* @property {string} address - The parsed IPv6 address.
	* @property {string} [zone] - The zone identifier, if present.
	*/
	/**
	* @param {string} value
	* @returns {boolean}
	*/
	const nonSimpleDomain$1 = RegExp.prototype.test.bind(/[^!"$&'()*+,\-.;=_`a-z{}~]/u);
	/**
	* @param {Array<string>} buffer
	* @returns {boolean}
	*/
	function consumeIsZone(buffer) {
		buffer.length = 0;
		return true;
	}
	/**
	* @param {Array<string>} buffer
	* @param {Array<string>} address
	* @param {GetIPV6Result} output
	* @returns {boolean}
	*/
	function consumeHextets(buffer, address, output) {
		if (buffer.length) {
			const hex = stringArrayToHexStripped(buffer);
			if (hex !== "") address.push(hex);
			else {
				output.error = true;
				return false;
			}
			buffer.length = 0;
		}
		return true;
	}
	/**
	* @param {string} input
	* @returns {GetIPV6Result}
	*/
	function getIPV6(input) {
		let tokenCount = 0;
		const output = {
			error: false,
			address: "",
			zone: ""
		};
		/** @type {Array<string>} */
		const address = [];
		/** @type {Array<string>} */
		const buffer = [];
		let endipv6Encountered = false;
		let endIpv6 = false;
		let consume = consumeHextets;
		for (let i = 0; i < input.length; i++) {
			const cursor = input[i];
			if (cursor === "[" || cursor === "]") continue;
			if (cursor === ":") {
				if (endipv6Encountered === true) endIpv6 = true;
				if (!consume(buffer, address, output)) break;
				if (++tokenCount > 7) {
					output.error = true;
					break;
				}
				if (i > 0 && input[i - 1] === ":") endipv6Encountered = true;
				address.push(":");
				continue;
			} else if (cursor === "%") {
				if (!consume(buffer, address, output)) break;
				consume = consumeIsZone;
			} else {
				buffer.push(cursor);
				continue;
			}
		}
		if (buffer.length) if (consume === consumeIsZone) output.zone = buffer.join("");
		else if (endIpv6) address.push(buffer.join(""));
		else address.push(stringArrayToHexStripped(buffer));
		output.address = address.join("");
		return output;
	}
	/**
	* @typedef {Object} NormalizeIPv6Result
	* @property {string} host - The normalized host.
	* @property {string} [escapedHost] - The escaped host.
	* @property {boolean} isIPV6 - Indicates if the host is an IPv6 address.
	*/
	/**
	* @param {string} host
	* @returns {NormalizeIPv6Result}
	*/
	function normalizeIPv6$1(host) {
		if (findToken(host, ":") < 2) return {
			host,
			isIPV6: false
		};
		const ipv6 = getIPV6(host);
		if (!ipv6.error) {
			let newHost = ipv6.address;
			let escapedHost = ipv6.address;
			if (ipv6.zone) {
				newHost += "%" + ipv6.zone;
				escapedHost += "%25" + ipv6.zone;
			}
			return {
				host: newHost,
				isIPV6: true,
				escapedHost
			};
		} else return {
			host,
			isIPV6: false
		};
	}
	/**
	* @param {string} str
	* @param {string} token
	* @returns {number}
	*/
	function findToken(str$1, token) {
		let ind = 0;
		for (let i = 0; i < str$1.length; i++) if (str$1[i] === token) ind++;
		return ind;
	}
	/**
	* @param {string} path
	* @returns {string}
	*
	* @see https://datatracker.ietf.org/doc/html/rfc3986#section-5.2.4
	*/
	function removeDotSegments$1(path) {
		let input = path;
		const output = [];
		let nextSlash = -1;
		let len = 0;
		while (len = input.length) {
			if (len === 1) if (input === ".") break;
			else if (input === "/") {
				output.push("/");
				break;
			} else {
				output.push(input);
				break;
			}
			else if (len === 2) {
				if (input[0] === ".") {
					if (input[1] === ".") break;
					else if (input[1] === "/") {
						input = input.slice(2);
						continue;
					}
				} else if (input[0] === "/") {
					if (input[1] === "." || input[1] === "/") {
						output.push("/");
						break;
					}
				}
			} else if (len === 3) {
				if (input === "/..") {
					if (output.length !== 0) output.pop();
					output.push("/");
					break;
				}
			}
			if (input[0] === ".") {
				if (input[1] === ".") {
					if (input[2] === "/") {
						input = input.slice(3);
						continue;
					}
				} else if (input[1] === "/") {
					input = input.slice(2);
					continue;
				}
			} else if (input[0] === "/") {
				if (input[1] === ".") {
					if (input[2] === "/") {
						input = input.slice(2);
						continue;
					} else if (input[2] === ".") {
						if (input[3] === "/") {
							input = input.slice(3);
							if (output.length !== 0) output.pop();
							continue;
						}
					}
				}
			}
			if ((nextSlash = input.indexOf("/", 1)) === -1) {
				output.push(input);
				break;
			} else {
				output.push(input.slice(0, nextSlash));
				input = input.slice(nextSlash);
			}
		}
		return output.join("");
	}
	/**
	* @param {import('../types/index').URIComponent} component
	* @param {boolean} esc
	* @returns {import('../types/index').URIComponent}
	*/
	function normalizeComponentEncoding$1(component, esc) {
		const func = esc !== true ? escape : unescape;
		if (component.scheme !== void 0) component.scheme = func(component.scheme);
		if (component.userinfo !== void 0) component.userinfo = func(component.userinfo);
		if (component.host !== void 0) component.host = func(component.host);
		if (component.path !== void 0) component.path = func(component.path);
		if (component.query !== void 0) component.query = func(component.query);
		if (component.fragment !== void 0) component.fragment = func(component.fragment);
		return component;
	}
	/**
	* @param {import('../types/index').URIComponent} component
	* @returns {string|undefined}
	*/
	function recomposeAuthority$1(component) {
		const uriTokens = [];
		if (component.userinfo !== void 0) {
			uriTokens.push(component.userinfo);
			uriTokens.push("@");
		}
		if (component.host !== void 0) {
			let host = unescape(component.host);
			if (!isIPv4$1(host)) {
				const ipV6res = normalizeIPv6$1(host);
				if (ipV6res.isIPV6 === true) host = `[${ipV6res.escapedHost}]`;
				else host = component.host;
			}
			uriTokens.push(host);
		}
		if (typeof component.port === "number" || typeof component.port === "string") {
			uriTokens.push(":");
			uriTokens.push(String(component.port));
		}
		return uriTokens.length ? uriTokens.join("") : void 0;
	}
	module.exports = {
		nonSimpleDomain: nonSimpleDomain$1,
		recomposeAuthority: recomposeAuthority$1,
		normalizeComponentEncoding: normalizeComponentEncoding$1,
		removeDotSegments: removeDotSegments$1,
		isIPv4: isIPv4$1,
		isUUID: isUUID$1,
		normalizeIPv6: normalizeIPv6$1,
		stringArrayToHexStripped
	};
}) });

//#endregion
//#region node_modules/fast-uri/lib/schemes.js
var require_schemes = /* @__PURE__ */ __commonJS$2({ "node_modules/fast-uri/lib/schemes.js": ((exports, module) => {
	const { isUUID } = require_utils();
	const URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
	const supportedSchemeNames = [
		"http",
		"https",
		"ws",
		"wss",
		"urn",
		"urn:uuid"
	];
	/** @typedef {supportedSchemeNames[number]} SchemeName */
	/**
	* @param {string} name
	* @returns {name is SchemeName}
	*/
	function isValidSchemeName(name) {
		return supportedSchemeNames.indexOf(name) !== -1;
	}
	/**
	* @callback SchemeFn
	* @param {import('../types/index').URIComponent} component
	* @param {import('../types/index').Options} options
	* @returns {import('../types/index').URIComponent}
	*/
	/**
	* @typedef {Object} SchemeHandler
	* @property {SchemeName} scheme - The scheme name.
	* @property {boolean} [domainHost] - Indicates if the scheme supports domain hosts.
	* @property {SchemeFn} parse - Function to parse the URI component for this scheme.
	* @property {SchemeFn} serialize - Function to serialize the URI component for this scheme.
	* @property {boolean} [skipNormalize] - Indicates if normalization should be skipped for this scheme.
	* @property {boolean} [absolutePath] - Indicates if the scheme uses absolute paths.
	* @property {boolean} [unicodeSupport] - Indicates if the scheme supports Unicode.
	*/
	/**
	* @param {import('../types/index').URIComponent} wsComponent
	* @returns {boolean}
	*/
	function wsIsSecure(wsComponent) {
		if (wsComponent.secure === true) return true;
		else if (wsComponent.secure === false) return false;
		else if (wsComponent.scheme) return wsComponent.scheme.length === 3 && (wsComponent.scheme[0] === "w" || wsComponent.scheme[0] === "W") && (wsComponent.scheme[1] === "s" || wsComponent.scheme[1] === "S") && (wsComponent.scheme[2] === "s" || wsComponent.scheme[2] === "S");
		else return false;
	}
	/** @type {SchemeFn} */
	function httpParse(component) {
		if (!component.host) component.error = component.error || "HTTP URIs must have a host.";
		return component;
	}
	/** @type {SchemeFn} */
	function httpSerialize(component) {
		const secure = String(component.scheme).toLowerCase() === "https";
		if (component.port === (secure ? 443 : 80) || component.port === "") component.port = void 0;
		if (!component.path) component.path = "/";
		return component;
	}
	/** @type {SchemeFn} */
	function wsParse(wsComponent) {
		wsComponent.secure = wsIsSecure(wsComponent);
		wsComponent.resourceName = (wsComponent.path || "/") + (wsComponent.query ? "?" + wsComponent.query : "");
		wsComponent.path = void 0;
		wsComponent.query = void 0;
		return wsComponent;
	}
	/** @type {SchemeFn} */
	function wsSerialize(wsComponent) {
		if (wsComponent.port === (wsIsSecure(wsComponent) ? 443 : 80) || wsComponent.port === "") wsComponent.port = void 0;
		if (typeof wsComponent.secure === "boolean") {
			wsComponent.scheme = wsComponent.secure ? "wss" : "ws";
			wsComponent.secure = void 0;
		}
		if (wsComponent.resourceName) {
			const [path, query] = wsComponent.resourceName.split("?");
			wsComponent.path = path && path !== "/" ? path : void 0;
			wsComponent.query = query;
			wsComponent.resourceName = void 0;
		}
		wsComponent.fragment = void 0;
		return wsComponent;
	}
	/** @type {SchemeFn} */
	function urnParse(urnComponent, options) {
		if (!urnComponent.path) {
			urnComponent.error = "URN can not be parsed";
			return urnComponent;
		}
		const matches = urnComponent.path.match(URN_REG);
		if (matches) {
			const scheme = options.scheme || urnComponent.scheme || "urn";
			urnComponent.nid = matches[1].toLowerCase();
			urnComponent.nss = matches[2];
			const schemeHandler = getSchemeHandler$1(`${scheme}:${options.nid || urnComponent.nid}`);
			urnComponent.path = void 0;
			if (schemeHandler) urnComponent = schemeHandler.parse(urnComponent, options);
		} else urnComponent.error = urnComponent.error || "URN can not be parsed.";
		return urnComponent;
	}
	/** @type {SchemeFn} */
	function urnSerialize(urnComponent, options) {
		if (urnComponent.nid === void 0) throw new Error("URN without nid cannot be serialized");
		const scheme = options.scheme || urnComponent.scheme || "urn";
		const nid = urnComponent.nid.toLowerCase();
		const schemeHandler = getSchemeHandler$1(`${scheme}:${options.nid || nid}`);
		if (schemeHandler) urnComponent = schemeHandler.serialize(urnComponent, options);
		const uriComponent = urnComponent;
		const nss = urnComponent.nss;
		uriComponent.path = `${nid || options.nid}:${nss}`;
		options.skipEscape = true;
		return uriComponent;
	}
	/** @type {SchemeFn} */
	function urnuuidParse(urnComponent, options) {
		const uuidComponent = urnComponent;
		uuidComponent.uuid = uuidComponent.nss;
		uuidComponent.nss = void 0;
		if (!options.tolerant && (!uuidComponent.uuid || !isUUID(uuidComponent.uuid))) uuidComponent.error = uuidComponent.error || "UUID is not valid.";
		return uuidComponent;
	}
	/** @type {SchemeFn} */
	function urnuuidSerialize(uuidComponent) {
		const urnComponent = uuidComponent;
		urnComponent.nss = (uuidComponent.uuid || "").toLowerCase();
		return urnComponent;
	}
	const http = {
		scheme: "http",
		domainHost: true,
		parse: httpParse,
		serialize: httpSerialize
	};
	const https = {
		scheme: "https",
		domainHost: http.domainHost,
		parse: httpParse,
		serialize: httpSerialize
	};
	const ws = {
		scheme: "ws",
		domainHost: true,
		parse: wsParse,
		serialize: wsSerialize
	};
	const wss = {
		scheme: "wss",
		domainHost: ws.domainHost,
		parse: ws.parse,
		serialize: ws.serialize
	};
	const urn = {
		scheme: "urn",
		parse: urnParse,
		serialize: urnSerialize,
		skipNormalize: true
	};
	const urnuuid = {
		scheme: "urn:uuid",
		parse: urnuuidParse,
		serialize: urnuuidSerialize,
		skipNormalize: true
	};
	const SCHEMES$1 = {
		http,
		https,
		ws,
		wss,
		urn,
		"urn:uuid": urnuuid
	};
	Object.setPrototypeOf(SCHEMES$1, null);
	/**
	* @param {string|undefined} scheme
	* @returns {SchemeHandler|undefined}
	*/
	function getSchemeHandler$1(scheme) {
		return scheme && (SCHEMES$1[scheme] || SCHEMES$1[scheme.toLowerCase()]) || void 0;
	}
	module.exports = {
		wsIsSecure,
		SCHEMES: SCHEMES$1,
		isValidSchemeName,
		getSchemeHandler: getSchemeHandler$1
	};
}) });

//#endregion
//#region node_modules/fast-uri/index.js
var require_fast_uri = /* @__PURE__ */ __commonJS$2({ "node_modules/fast-uri/index.js": ((exports, module) => {
	const { normalizeIPv6, removeDotSegments, recomposeAuthority, normalizeComponentEncoding, isIPv4, nonSimpleDomain } = require_utils();
	const { SCHEMES, getSchemeHandler } = require_schemes();
	/**
	* @template {import('./types/index').URIComponent|string} T
	* @param {T} uri
	* @param {import('./types/index').Options} [options]
	* @returns {T}
	*/
	function normalize(uri$1, options) {
		if (typeof uri$1 === "string") uri$1 = serialize(parse(uri$1, options), options);
		else if (typeof uri$1 === "object") uri$1 = parse(serialize(uri$1, options), options);
		return uri$1;
	}
	/**
	* @param {string} baseURI
	* @param {string} relativeURI
	* @param {import('./types/index').Options} [options]
	* @returns {string}
	*/
	function resolve(baseURI, relativeURI, options) {
		const schemelessOptions = options ? Object.assign({ scheme: "null" }, options) : { scheme: "null" };
		const resolved = resolveComponent(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true);
		schemelessOptions.skipEscape = true;
		return serialize(resolved, schemelessOptions);
	}
	/**
	* @param {import ('./types/index').URIComponent} base
	* @param {import ('./types/index').URIComponent} relative
	* @param {import('./types/index').Options} [options]
	* @param {boolean} [skipNormalization=false]
	* @returns {import ('./types/index').URIComponent}
	*/
	function resolveComponent(base, relative, options, skipNormalization) {
		/** @type {import('./types/index').URIComponent} */
		const target = {};
		if (!skipNormalization) {
			base = parse(serialize(base, options), options);
			relative = parse(serialize(relative, options), options);
		}
		options = options || {};
		if (!options.tolerant && relative.scheme) {
			target.scheme = relative.scheme;
			target.userinfo = relative.userinfo;
			target.host = relative.host;
			target.port = relative.port;
			target.path = removeDotSegments(relative.path || "");
			target.query = relative.query;
		} else {
			if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
				target.userinfo = relative.userinfo;
				target.host = relative.host;
				target.port = relative.port;
				target.path = removeDotSegments(relative.path || "");
				target.query = relative.query;
			} else {
				if (!relative.path) {
					target.path = base.path;
					if (relative.query !== void 0) target.query = relative.query;
					else target.query = base.query;
				} else {
					if (relative.path[0] === "/") target.path = removeDotSegments(relative.path);
					else {
						if ((base.userinfo !== void 0 || base.host !== void 0 || base.port !== void 0) && !base.path) target.path = "/" + relative.path;
						else if (!base.path) target.path = relative.path;
						else target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
						target.path = removeDotSegments(target.path);
					}
					target.query = relative.query;
				}
				target.userinfo = base.userinfo;
				target.host = base.host;
				target.port = base.port;
			}
			target.scheme = base.scheme;
		}
		target.fragment = relative.fragment;
		return target;
	}
	/**
	* @param {import ('./types/index').URIComponent|string} uriA
	* @param {import ('./types/index').URIComponent|string} uriB
	* @param {import ('./types/index').Options} options
	* @returns {boolean}
	*/
	function equal$1(uriA, uriB, options) {
		if (typeof uriA === "string") {
			uriA = unescape(uriA);
			uriA = serialize(normalizeComponentEncoding(parse(uriA, options), true), {
				...options,
				skipEscape: true
			});
		} else if (typeof uriA === "object") uriA = serialize(normalizeComponentEncoding(uriA, true), {
			...options,
			skipEscape: true
		});
		if (typeof uriB === "string") {
			uriB = unescape(uriB);
			uriB = serialize(normalizeComponentEncoding(parse(uriB, options), true), {
				...options,
				skipEscape: true
			});
		} else if (typeof uriB === "object") uriB = serialize(normalizeComponentEncoding(uriB, true), {
			...options,
			skipEscape: true
		});
		return uriA.toLowerCase() === uriB.toLowerCase();
	}
	/**
	* @param {Readonly<import('./types/index').URIComponent>} cmpts
	* @param {import('./types/index').Options} [opts]
	* @returns {string}
	*/
	function serialize(cmpts, opts) {
		const component = {
			host: cmpts.host,
			scheme: cmpts.scheme,
			userinfo: cmpts.userinfo,
			port: cmpts.port,
			path: cmpts.path,
			query: cmpts.query,
			nid: cmpts.nid,
			nss: cmpts.nss,
			uuid: cmpts.uuid,
			fragment: cmpts.fragment,
			reference: cmpts.reference,
			resourceName: cmpts.resourceName,
			secure: cmpts.secure,
			error: ""
		};
		const options = Object.assign({}, opts);
		const uriTokens = [];
		const schemeHandler = getSchemeHandler(options.scheme || component.scheme);
		if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(component, options);
		if (component.path !== void 0) if (!options.skipEscape) {
			component.path = escape(component.path);
			if (component.scheme !== void 0) component.path = component.path.split("%3A").join(":");
		} else component.path = unescape(component.path);
		if (options.reference !== "suffix" && component.scheme) uriTokens.push(component.scheme, ":");
		const authority = recomposeAuthority(component);
		if (authority !== void 0) {
			if (options.reference !== "suffix") uriTokens.push("//");
			uriTokens.push(authority);
			if (component.path && component.path[0] !== "/") uriTokens.push("/");
		}
		if (component.path !== void 0) {
			let s = component.path;
			if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) s = removeDotSegments(s);
			if (authority === void 0 && s[0] === "/" && s[1] === "/") s = "/%2F" + s.slice(2);
			uriTokens.push(s);
		}
		if (component.query !== void 0) uriTokens.push("?", component.query);
		if (component.fragment !== void 0) uriTokens.push("#", component.fragment);
		return uriTokens.join("");
	}
	const URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
	/**
	* @param {string} uri
	* @param {import('./types/index').Options} [opts]
	* @returns
	*/
	function parse(uri$1, opts) {
		const options = Object.assign({}, opts);
		/** @type {import('./types/index').URIComponent} */
		const parsed = {
			scheme: void 0,
			userinfo: void 0,
			host: "",
			port: void 0,
			path: "",
			query: void 0,
			fragment: void 0
		};
		let isIP = false;
		if (options.reference === "suffix") if (options.scheme) uri$1 = options.scheme + ":" + uri$1;
		else uri$1 = "//" + uri$1;
		const matches = uri$1.match(URI_PARSE);
		if (matches) {
			parsed.scheme = matches[1];
			parsed.userinfo = matches[3];
			parsed.host = matches[4];
			parsed.port = parseInt(matches[5], 10);
			parsed.path = matches[6] || "";
			parsed.query = matches[7];
			parsed.fragment = matches[8];
			if (isNaN(parsed.port)) parsed.port = matches[5];
			if (parsed.host) if (isIPv4(parsed.host) === false) {
				const ipv6result = normalizeIPv6(parsed.host);
				parsed.host = ipv6result.host.toLowerCase();
				isIP = ipv6result.isIPV6;
			} else isIP = true;
			if (parsed.scheme === void 0 && parsed.userinfo === void 0 && parsed.host === void 0 && parsed.port === void 0 && parsed.query === void 0 && !parsed.path) parsed.reference = "same-document";
			else if (parsed.scheme === void 0) parsed.reference = "relative";
			else if (parsed.fragment === void 0) parsed.reference = "absolute";
			else parsed.reference = "uri";
			if (options.reference && options.reference !== "suffix" && options.reference !== parsed.reference) parsed.error = parsed.error || "URI is not a " + options.reference + " reference.";
			const schemeHandler = getSchemeHandler(options.scheme || parsed.scheme);
			if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
				if (parsed.host && (options.domainHost || schemeHandler && schemeHandler.domainHost) && isIP === false && nonSimpleDomain(parsed.host)) try {
					parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
				} catch (e) {
					parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e;
				}
			}
			if (!schemeHandler || schemeHandler && !schemeHandler.skipNormalize) {
				if (uri$1.indexOf("%") !== -1) {
					if (parsed.scheme !== void 0) parsed.scheme = unescape(parsed.scheme);
					if (parsed.host !== void 0) parsed.host = unescape(parsed.host);
				}
				if (parsed.path) parsed.path = escape(unescape(parsed.path));
				if (parsed.fragment) parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment));
			}
			if (schemeHandler && schemeHandler.parse) schemeHandler.parse(parsed, options);
		} else parsed.error = parsed.error || "URI can not be parsed.";
		return parsed;
	}
	const fastUri = {
		SCHEMES,
		normalize,
		resolve,
		resolveComponent,
		equal: equal$1,
		serialize,
		parse
	};
	module.exports = fastUri;
	module.exports.default = fastUri;
	module.exports.fastUri = fastUri;
}) });

//#endregion
//#region node_modules/ajv/dist/runtime/uri.js
var require_uri = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/runtime/uri.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const uri = require_fast_uri();
	uri.code = "require(\"ajv/dist/runtime/uri\").default";
	exports.default = uri;
}) });

//#endregion
//#region node_modules/ajv/dist/core.js
var require_core$1 = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/core.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
	var validate_1$2 = require_validate();
	Object.defineProperty(exports, "KeywordCxt", {
		enumerable: true,
		get: function() {
			return validate_1$2.KeywordCxt;
		}
	});
	var codegen_1$24 = require_codegen();
	Object.defineProperty(exports, "_", {
		enumerable: true,
		get: function() {
			return codegen_1$24._;
		}
	});
	Object.defineProperty(exports, "str", {
		enumerable: true,
		get: function() {
			return codegen_1$24.str;
		}
	});
	Object.defineProperty(exports, "stringify", {
		enumerable: true,
		get: function() {
			return codegen_1$24.stringify;
		}
	});
	Object.defineProperty(exports, "nil", {
		enumerable: true,
		get: function() {
			return codegen_1$24.nil;
		}
	});
	Object.defineProperty(exports, "Name", {
		enumerable: true,
		get: function() {
			return codegen_1$24.Name;
		}
	});
	Object.defineProperty(exports, "CodeGen", {
		enumerable: true,
		get: function() {
			return codegen_1$24.CodeGen;
		}
	});
	const validation_error_1$1 = require_validation_error();
	const ref_error_1$3 = require_ref_error();
	const rules_1 = require_rules();
	const compile_1$2 = require_compile();
	const codegen_2 = require_codegen();
	const resolve_1 = require_resolve();
	const dataType_1$1 = require_dataType();
	const util_1$21 = require_util();
	const $dataRefSchema = require_data();
	const uri_1 = require_uri();
	const defaultRegExp = (str$1, flags) => new RegExp(str$1, flags);
	defaultRegExp.code = "new RegExp";
	const META_IGNORE_OPTIONS = [
		"removeAdditional",
		"useDefaults",
		"coerceTypes"
	];
	const EXT_SCOPE_NAMES = new Set([
		"validate",
		"serialize",
		"parse",
		"wrapper",
		"root",
		"schema",
		"keyword",
		"pattern",
		"formats",
		"validate$data",
		"func",
		"obj",
		"Error"
	]);
	const removedOptions = {
		errorDataPath: "",
		format: "`validateFormats: false` can be used instead.",
		nullable: "\"nullable\" keyword is supported by default.",
		jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
		extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
		missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
		processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
		sourceCode: "Use option `code: {source: true}`",
		strictDefaults: "It is default now, see option `strict`.",
		strictKeywords: "It is default now, see option `strict`.",
		uniqueItems: "\"uniqueItems\" keyword is always validated.",
		unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
		cache: "Map is used as cache, schema object as key.",
		serialize: "Map is used as cache, schema object as key.",
		ajvErrors: "It is default now."
	};
	const deprecatedOptions = {
		ignoreKeywordsWithRef: "",
		jsPropertySyntax: "",
		unicode: "\"minLength\"/\"maxLength\" account for unicode characters by default."
	};
	const MAX_EXPRESSION = 200;
	function requiredOptions(o) {
		var _a$1, _b$1, _c$1, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
		const s = o.strict;
		const _optz = (_a$1 = o.code) === null || _a$1 === void 0 ? void 0 : _a$1.optimize;
		const optimize$1 = _optz === true || _optz === void 0 ? 1 : _optz || 0;
		const regExp = (_c$1 = (_b$1 = o.code) === null || _b$1 === void 0 ? void 0 : _b$1.regExp) !== null && _c$1 !== void 0 ? _c$1 : defaultRegExp;
		const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
		return {
			strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
			strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
			strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
			strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
			strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
			code: o.code ? {
				...o.code,
				optimize: optimize$1,
				regExp
			} : {
				optimize: optimize$1,
				regExp
			},
			loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
			loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
			meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
			messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
			inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
			schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
			addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
			validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
			validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
			unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
			int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
			uriResolver
		};
	}
	var Ajv$2 = class {
		constructor(opts = {}) {
			this.schemas = {};
			this.refs = {};
			this.formats = {};
			this._compilations = /* @__PURE__ */ new Set();
			this._loading = {};
			this._cache = /* @__PURE__ */ new Map();
			opts = this.opts = {
				...opts,
				...requiredOptions(opts)
			};
			const { es5, lines } = this.opts.code;
			this.scope = new codegen_2.ValueScope({
				scope: {},
				prefixes: EXT_SCOPE_NAMES,
				es5,
				lines
			});
			this.logger = getLogger(opts.logger);
			const formatOpt = opts.validateFormats;
			opts.validateFormats = false;
			this.RULES = (0, rules_1.getRules)();
			checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
			checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
			this._metaOpts = getMetaSchemaOptions.call(this);
			if (opts.formats) addInitialFormats.call(this);
			this._addVocabularies();
			this._addDefaultMetaSchema();
			if (opts.keywords) addInitialKeywords.call(this, opts.keywords);
			if (typeof opts.meta == "object") this.addMetaSchema(opts.meta);
			addInitialSchemas.call(this);
			opts.validateFormats = formatOpt;
		}
		_addVocabularies() {
			this.addKeyword("$async");
		}
		_addDefaultMetaSchema() {
			const { $data, meta, schemaId } = this.opts;
			let _dataRefSchema = $dataRefSchema;
			if (schemaId === "id") {
				_dataRefSchema = { ...$dataRefSchema };
				_dataRefSchema.id = _dataRefSchema.$id;
				delete _dataRefSchema.$id;
			}
			if (meta && $data) this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
		}
		defaultMeta() {
			const { meta, schemaId } = this.opts;
			return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : void 0;
		}
		validate(schemaKeyRef, data) {
			let v;
			if (typeof schemaKeyRef == "string") {
				v = this.getSchema(schemaKeyRef);
				if (!v) throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
			} else v = this.compile(schemaKeyRef);
			const valid = v(data);
			if (!("$async" in v)) this.errors = v.errors;
			return valid;
		}
		compile(schema$1, _meta) {
			const sch = this._addSchema(schema$1, _meta);
			return sch.validate || this._compileSchemaEnv(sch);
		}
		compileAsync(schema$1, meta) {
			if (typeof this.opts.loadSchema != "function") throw new Error("options.loadSchema should be a function");
			const { loadSchema } = this.opts;
			return runCompileAsync.call(this, schema$1, meta);
			async function runCompileAsync(_schema, _meta) {
				await loadMetaSchema.call(this, _schema.$schema);
				const sch = this._addSchema(_schema, _meta);
				return sch.validate || _compileAsync.call(this, sch);
			}
			async function loadMetaSchema($ref) {
				if ($ref && !this.getSchema($ref)) await runCompileAsync.call(this, { $ref }, true);
			}
			async function _compileAsync(sch) {
				try {
					return this._compileSchemaEnv(sch);
				} catch (e) {
					if (!(e instanceof ref_error_1$3.default)) throw e;
					checkLoaded.call(this, e);
					await loadMissingSchema.call(this, e.missingSchema);
					return _compileAsync.call(this, sch);
				}
			}
			function checkLoaded({ missingSchema: ref, missingRef }) {
				if (this.refs[ref]) throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
			}
			async function loadMissingSchema(ref) {
				const _schema = await _loadSchema.call(this, ref);
				if (!this.refs[ref]) await loadMetaSchema.call(this, _schema.$schema);
				if (!this.refs[ref]) this.addSchema(_schema, ref, meta);
			}
			async function _loadSchema(ref) {
				const p = this._loading[ref];
				if (p) return p;
				try {
					return await (this._loading[ref] = loadSchema(ref));
				} finally {
					delete this._loading[ref];
				}
			}
		}
		addSchema(schema$1, key, _meta, _validateSchema = this.opts.validateSchema) {
			if (Array.isArray(schema$1)) {
				for (const sch of schema$1) this.addSchema(sch, void 0, _meta, _validateSchema);
				return this;
			}
			let id;
			if (typeof schema$1 === "object") {
				const { schemaId } = this.opts;
				id = schema$1[schemaId];
				if (id !== void 0 && typeof id != "string") throw new Error(`schema ${schemaId} must be string`);
			}
			key = (0, resolve_1.normalizeId)(key || id);
			this._checkUnique(key);
			this.schemas[key] = this._addSchema(schema$1, _meta, key, _validateSchema, true);
			return this;
		}
		addMetaSchema(schema$1, key, _validateSchema = this.opts.validateSchema) {
			this.addSchema(schema$1, key, true, _validateSchema);
			return this;
		}
		validateSchema(schema$1, throwOrLogError) {
			if (typeof schema$1 == "boolean") return true;
			let $schema;
			$schema = schema$1.$schema;
			if ($schema !== void 0 && typeof $schema != "string") throw new Error("$schema must be a string");
			$schema = $schema || this.opts.defaultMeta || this.defaultMeta();
			if (!$schema) {
				this.logger.warn("meta-schema not available");
				this.errors = null;
				return true;
			}
			const valid = this.validate($schema, schema$1);
			if (!valid && throwOrLogError) {
				const message = "schema is invalid: " + this.errorsText();
				if (this.opts.validateSchema === "log") this.logger.error(message);
				else throw new Error(message);
			}
			return valid;
		}
		getSchema(keyRef) {
			let sch;
			while (typeof (sch = getSchEnv.call(this, keyRef)) == "string") keyRef = sch;
			if (sch === void 0) {
				const { schemaId } = this.opts;
				const root = new compile_1$2.SchemaEnv({
					schema: {},
					schemaId
				});
				sch = compile_1$2.resolveSchema.call(this, root, keyRef);
				if (!sch) return;
				this.refs[keyRef] = sch;
			}
			return sch.validate || this._compileSchemaEnv(sch);
		}
		removeSchema(schemaKeyRef) {
			if (schemaKeyRef instanceof RegExp) {
				this._removeAllSchemas(this.schemas, schemaKeyRef);
				this._removeAllSchemas(this.refs, schemaKeyRef);
				return this;
			}
			switch (typeof schemaKeyRef) {
				case "undefined":
					this._removeAllSchemas(this.schemas);
					this._removeAllSchemas(this.refs);
					this._cache.clear();
					return this;
				case "string": {
					const sch = getSchEnv.call(this, schemaKeyRef);
					if (typeof sch == "object") this._cache.delete(sch.schema);
					delete this.schemas[schemaKeyRef];
					delete this.refs[schemaKeyRef];
					return this;
				}
				case "object": {
					const cacheKey = schemaKeyRef;
					this._cache.delete(cacheKey);
					let id = schemaKeyRef[this.opts.schemaId];
					if (id) {
						id = (0, resolve_1.normalizeId)(id);
						delete this.schemas[id];
						delete this.refs[id];
					}
					return this;
				}
				default: throw new Error("ajv.removeSchema: invalid parameter");
			}
		}
		addVocabulary(definitions) {
			for (const def$30 of definitions) this.addKeyword(def$30);
			return this;
		}
		addKeyword(kwdOrDef, def$30) {
			let keyword;
			if (typeof kwdOrDef == "string") {
				keyword = kwdOrDef;
				if (typeof def$30 == "object") {
					this.logger.warn("these parameters are deprecated, see docs for addKeyword");
					def$30.keyword = keyword;
				}
			} else if (typeof kwdOrDef == "object" && def$30 === void 0) {
				def$30 = kwdOrDef;
				keyword = def$30.keyword;
				if (Array.isArray(keyword) && !keyword.length) throw new Error("addKeywords: keyword must be string or non-empty array");
			} else throw new Error("invalid addKeywords parameters");
			checkKeyword.call(this, keyword, def$30);
			if (!def$30) {
				(0, util_1$21.eachItem)(keyword, (kwd) => addRule.call(this, kwd));
				return this;
			}
			keywordMetaschema.call(this, def$30);
			const definition = {
				...def$30,
				type: (0, dataType_1$1.getJSONTypes)(def$30.type),
				schemaType: (0, dataType_1$1.getJSONTypes)(def$30.schemaType)
			};
			(0, util_1$21.eachItem)(keyword, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t$1) => addRule.call(this, k, definition, t$1)));
			return this;
		}
		getKeyword(keyword) {
			const rule = this.RULES.all[keyword];
			return typeof rule == "object" ? rule.definition : !!rule;
		}
		removeKeyword(keyword) {
			const { RULES } = this;
			delete RULES.keywords[keyword];
			delete RULES.all[keyword];
			for (const group of RULES.rules) {
				const i = group.rules.findIndex((rule) => rule.keyword === keyword);
				if (i >= 0) group.rules.splice(i, 1);
			}
			return this;
		}
		addFormat(name, format$1) {
			if (typeof format$1 == "string") format$1 = new RegExp(format$1);
			this.formats[name] = format$1;
			return this;
		}
		errorsText(errors$1 = this.errors, { separator = ", ", dataVar = "data" } = {}) {
			if (!errors$1 || errors$1.length === 0) return "No errors";
			return errors$1.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);
		}
		$dataMetaSchema(metaSchema, keywordsJsonPointers) {
			const rules = this.RULES.all;
			metaSchema = JSON.parse(JSON.stringify(metaSchema));
			for (const jsonPointer of keywordsJsonPointers) {
				const segments = jsonPointer.split("/").slice(1);
				let keywords = metaSchema;
				for (const seg of segments) keywords = keywords[seg];
				for (const key in rules) {
					const rule = rules[key];
					if (typeof rule != "object") continue;
					const { $data } = rule.definition;
					const schema$1 = keywords[key];
					if ($data && schema$1) keywords[key] = schemaOrData(schema$1);
				}
			}
			return metaSchema;
		}
		_removeAllSchemas(schemas$1, regex) {
			for (const keyRef in schemas$1) {
				const sch = schemas$1[keyRef];
				if (!regex || regex.test(keyRef)) {
					if (typeof sch == "string") delete schemas$1[keyRef];
					else if (sch && !sch.meta) {
						this._cache.delete(sch.schema);
						delete schemas$1[keyRef];
					}
				}
			}
		}
		_addSchema(schema$1, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
			let id;
			const { schemaId } = this.opts;
			if (typeof schema$1 == "object") id = schema$1[schemaId];
			else if (this.opts.jtd) throw new Error("schema must be object");
			else if (typeof schema$1 != "boolean") throw new Error("schema must be object or boolean");
			let sch = this._cache.get(schema$1);
			if (sch !== void 0) return sch;
			baseId = (0, resolve_1.normalizeId)(id || baseId);
			const localRefs = resolve_1.getSchemaRefs.call(this, schema$1, baseId);
			sch = new compile_1$2.SchemaEnv({
				schema: schema$1,
				schemaId,
				meta,
				baseId,
				localRefs
			});
			this._cache.set(sch.schema, sch);
			if (addSchema && !baseId.startsWith("#")) {
				if (baseId) this._checkUnique(baseId);
				this.refs[baseId] = sch;
			}
			if (validateSchema) this.validateSchema(schema$1, true);
			return sch;
		}
		_checkUnique(id) {
			if (this.schemas[id] || this.refs[id]) throw new Error(`schema with key or id "${id}" already exists`);
		}
		_compileSchemaEnv(sch) {
			if (sch.meta) this._compileMetaSchema(sch);
			else compile_1$2.compileSchema.call(this, sch);
			/* istanbul ignore if */
			if (!sch.validate) throw new Error("ajv implementation error");
			return sch.validate;
		}
		_compileMetaSchema(sch) {
			const currentOpts = this.opts;
			this.opts = this._metaOpts;
			try {
				compile_1$2.compileSchema.call(this, sch);
			} finally {
				this.opts = currentOpts;
			}
		}
	};
	Ajv$2.ValidationError = validation_error_1$1.default;
	Ajv$2.MissingRefError = ref_error_1$3.default;
	exports.default = Ajv$2;
	function checkOptions(checkOpts, options, msg, log = "error") {
		for (const key in checkOpts) {
			const opt = key;
			if (opt in options) this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
		}
	}
	function getSchEnv(keyRef) {
		keyRef = (0, resolve_1.normalizeId)(keyRef);
		return this.schemas[keyRef] || this.refs[keyRef];
	}
	function addInitialSchemas() {
		const optsSchemas = this.opts.schemas;
		if (!optsSchemas) return;
		if (Array.isArray(optsSchemas)) this.addSchema(optsSchemas);
		else for (const key in optsSchemas) this.addSchema(optsSchemas[key], key);
	}
	function addInitialFormats() {
		for (const name in this.opts.formats) {
			const format$1 = this.opts.formats[name];
			if (format$1) this.addFormat(name, format$1);
		}
	}
	function addInitialKeywords(defs) {
		if (Array.isArray(defs)) {
			this.addVocabulary(defs);
			return;
		}
		this.logger.warn("keywords option as map is deprecated, pass array");
		for (const keyword in defs) {
			const def$30 = defs[keyword];
			if (!def$30.keyword) def$30.keyword = keyword;
			this.addKeyword(def$30);
		}
	}
	function getMetaSchemaOptions() {
		const metaOpts = { ...this.opts };
		for (const opt of META_IGNORE_OPTIONS) delete metaOpts[opt];
		return metaOpts;
	}
	const noLogs = {
		log() {},
		warn() {},
		error() {}
	};
	function getLogger(logger) {
		if (logger === false) return noLogs;
		if (logger === void 0) return console;
		if (logger.log && logger.warn && logger.error) return logger;
		throw new Error("logger must implement log, warn and error methods");
	}
	const KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
	function checkKeyword(keyword, def$30) {
		const { RULES } = this;
		(0, util_1$21.eachItem)(keyword, (kwd) => {
			if (RULES.keywords[kwd]) throw new Error(`Keyword ${kwd} is already defined`);
			if (!KEYWORD_NAME.test(kwd)) throw new Error(`Keyword ${kwd} has invalid name`);
		});
		if (!def$30) return;
		if (def$30.$data && !("code" in def$30 || "validate" in def$30)) throw new Error("$data keyword must have \"code\" or \"validate\" function");
	}
	function addRule(keyword, definition, dataType) {
		var _a$1;
		const post = definition === null || definition === void 0 ? void 0 : definition.post;
		if (dataType && post) throw new Error("keyword with \"post\" flag cannot have \"type\"");
		const { RULES } = this;
		let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t$1 }) => t$1 === dataType);
		if (!ruleGroup) {
			ruleGroup = {
				type: dataType,
				rules: []
			};
			RULES.rules.push(ruleGroup);
		}
		RULES.keywords[keyword] = true;
		if (!definition) return;
		const rule = {
			keyword,
			definition: {
				...definition,
				type: (0, dataType_1$1.getJSONTypes)(definition.type),
				schemaType: (0, dataType_1$1.getJSONTypes)(definition.schemaType)
			}
		};
		if (definition.before) addBeforeRule.call(this, ruleGroup, rule, definition.before);
		else ruleGroup.rules.push(rule);
		RULES.all[keyword] = rule;
		(_a$1 = definition.implements) === null || _a$1 === void 0 || _a$1.forEach((kwd) => this.addKeyword(kwd));
	}
	function addBeforeRule(ruleGroup, rule, before) {
		const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
		if (i >= 0) ruleGroup.rules.splice(i, 0, rule);
		else {
			ruleGroup.rules.push(rule);
			this.logger.warn(`rule ${before} is not defined`);
		}
	}
	function keywordMetaschema(def$30) {
		let { metaSchema } = def$30;
		if (metaSchema === void 0) return;
		if (def$30.$data && this.opts.$data) metaSchema = schemaOrData(metaSchema);
		def$30.validateSchema = this.compile(metaSchema, true);
	}
	const $dataRef = { $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" };
	function schemaOrData(schema$1) {
		return { anyOf: [schema$1, $dataRef] };
	}
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/core/id.js
var require_id = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/core/id.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const def$29 = {
		keyword: "id",
		code() {
			throw new Error("NOT SUPPORTED: keyword \"id\", use \"$id\" for schema ID");
		}
	};
	exports.default = def$29;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/core/ref.js
var require_ref = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/core/ref.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const ref_error_1$2 = require_ref_error();
	const code_1$8 = require_code();
	const codegen_1$23 = require_codegen();
	const names_1$1 = require_names();
	const compile_1$1 = require_compile();
	const util_1$20 = require_util();
	const def$28 = {
		keyword: "$ref",
		schemaType: "string",
		code(cxt) {
			const { gen, schema: $ref, it } = cxt;
			const { baseId, schemaEnv: env, validateName, opts, self } = it;
			const { root } = env;
			if (($ref === "#" || $ref === "#/") && baseId === root.baseId) return callRootRef();
			const schOrEnv = compile_1$1.resolveRef.call(self, root, baseId, $ref);
			if (schOrEnv === void 0) throw new ref_error_1$2.default(it.opts.uriResolver, baseId, $ref);
			if (schOrEnv instanceof compile_1$1.SchemaEnv) return callValidate(schOrEnv);
			return inlineRefSchema(schOrEnv);
			function callRootRef() {
				if (env === root) return callRef(cxt, validateName, env, env.$async);
				const rootName = gen.scopeValue("root", { ref: root });
				return callRef(cxt, (0, codegen_1$23._)`${rootName}.validate`, root, root.$async);
			}
			function callValidate(sch) {
				callRef(cxt, getValidate(cxt, sch), sch, sch.$async);
			}
			function inlineRefSchema(sch) {
				const schName = gen.scopeValue("schema", opts.code.source === true ? {
					ref: sch,
					code: (0, codegen_1$23.stringify)(sch)
				} : { ref: sch });
				const valid = gen.name("valid");
				const schCxt = cxt.subschema({
					schema: sch,
					dataTypes: [],
					schemaPath: codegen_1$23.nil,
					topSchemaRef: schName,
					errSchemaPath: $ref
				}, valid);
				cxt.mergeEvaluated(schCxt);
				cxt.ok(valid);
			}
		}
	};
	function getValidate(cxt, sch) {
		const { gen } = cxt;
		return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1$23._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
	}
	exports.getValidate = getValidate;
	function callRef(cxt, v, sch, $async) {
		const { gen, it } = cxt;
		const { allErrors, schemaEnv: env, opts } = it;
		const passCxt = opts.passContext ? names_1$1.default.this : codegen_1$23.nil;
		if ($async) callAsyncRef();
		else callSyncRef();
		function callAsyncRef() {
			if (!env.$async) throw new Error("async schema referenced by sync schema");
			const valid = gen.let("valid");
			gen.try(() => {
				gen.code((0, codegen_1$23._)`await ${(0, code_1$8.callValidateCode)(cxt, v, passCxt)}`);
				addEvaluatedFrom(v);
				if (!allErrors) gen.assign(valid, true);
			}, (e) => {
				gen.if((0, codegen_1$23._)`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
				addErrorsFrom(e);
				if (!allErrors) gen.assign(valid, false);
			});
			cxt.ok(valid);
		}
		function callSyncRef() {
			cxt.result((0, code_1$8.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
		}
		function addErrorsFrom(source) {
			const errs = (0, codegen_1$23._)`${source}.errors`;
			gen.assign(names_1$1.default.vErrors, (0, codegen_1$23._)`${names_1$1.default.vErrors} === null ? ${errs} : ${names_1$1.default.vErrors}.concat(${errs})`);
			gen.assign(names_1$1.default.errors, (0, codegen_1$23._)`${names_1$1.default.vErrors}.length`);
		}
		function addEvaluatedFrom(source) {
			var _a$1;
			if (!it.opts.unevaluated) return;
			const schEvaluated = (_a$1 = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a$1 === void 0 ? void 0 : _a$1.evaluated;
			if (it.props !== true) if (schEvaluated && !schEvaluated.dynamicProps) {
				if (schEvaluated.props !== void 0) it.props = util_1$20.mergeEvaluated.props(gen, schEvaluated.props, it.props);
			} else {
				const props = gen.var("props", (0, codegen_1$23._)`${source}.evaluated.props`);
				it.props = util_1$20.mergeEvaluated.props(gen, props, it.props, codegen_1$23.Name);
			}
			if (it.items !== true) if (schEvaluated && !schEvaluated.dynamicItems) {
				if (schEvaluated.items !== void 0) it.items = util_1$20.mergeEvaluated.items(gen, schEvaluated.items, it.items);
			} else {
				const items = gen.var("items", (0, codegen_1$23._)`${source}.evaluated.items`);
				it.items = util_1$20.mergeEvaluated.items(gen, items, it.items, codegen_1$23.Name);
			}
		}
	}
	exports.callRef = callRef;
	exports.default = def$28;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/core/index.js
var require_core = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/core/index.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const id_1 = require_id();
	const ref_1 = require_ref();
	const core = [
		"$schema",
		"$id",
		"$defs",
		"$vocabulary",
		{ keyword: "$comment" },
		"definitions",
		id_1.default,
		ref_1.default
	];
	exports.default = core;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/validation/limitNumber.js
var require_limitNumber = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/validation/limitNumber.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$22 = require_codegen();
	const ops = codegen_1$22.operators;
	const KWDs = {
		maximum: {
			okStr: "<=",
			ok: ops.LTE,
			fail: ops.GT
		},
		minimum: {
			okStr: ">=",
			ok: ops.GTE,
			fail: ops.LT
		},
		exclusiveMaximum: {
			okStr: "<",
			ok: ops.LT,
			fail: ops.GTE
		},
		exclusiveMinimum: {
			okStr: ">",
			ok: ops.GT,
			fail: ops.LTE
		}
	};
	const def$27 = {
		keyword: Object.keys(KWDs),
		type: "number",
		schemaType: "number",
		$data: true,
		error: {
			message: ({ keyword, schemaCode }) => (0, codegen_1$22.str)`must be ${KWDs[keyword].okStr} ${schemaCode}`,
			params: ({ keyword, schemaCode }) => (0, codegen_1$22._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
		},
		code(cxt) {
			const { keyword, data, schemaCode } = cxt;
			cxt.fail$data((0, codegen_1$22._)`${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
		}
	};
	exports.default = def$27;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/validation/multipleOf.js
var require_multipleOf = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/validation/multipleOf.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$21 = require_codegen();
	const def$26 = {
		keyword: "multipleOf",
		type: "number",
		schemaType: "number",
		$data: true,
		error: {
			message: ({ schemaCode }) => (0, codegen_1$21.str)`must be multiple of ${schemaCode}`,
			params: ({ schemaCode }) => (0, codegen_1$21._)`{multipleOf: ${schemaCode}}`
		},
		code(cxt) {
			const { gen, data, schemaCode, it } = cxt;
			const prec = it.opts.multipleOfPrecision;
			const res = gen.let("res");
			const invalid = prec ? (0, codegen_1$21._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1$21._)`${res} !== parseInt(${res})`;
			cxt.fail$data((0, codegen_1$21._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
		}
	};
	exports.default = def$26;
}) });

//#endregion
//#region node_modules/ajv/dist/runtime/ucs2length.js
var require_ucs2length = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/runtime/ucs2length.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	function ucs2length(str$1) {
		const len = str$1.length;
		let length = 0;
		let pos = 0;
		let value;
		while (pos < len) {
			length++;
			value = str$1.charCodeAt(pos++);
			if (value >= 55296 && value <= 56319 && pos < len) {
				value = str$1.charCodeAt(pos);
				if ((value & 64512) === 56320) pos++;
			}
		}
		return length;
	}
	exports.default = ucs2length;
	ucs2length.code = "require(\"ajv/dist/runtime/ucs2length\").default";
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/validation/limitLength.js
var require_limitLength = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/validation/limitLength.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$20 = require_codegen();
	const util_1$19 = require_util();
	const ucs2length_1 = require_ucs2length();
	const def$25 = {
		keyword: ["maxLength", "minLength"],
		type: "string",
		schemaType: "number",
		$data: true,
		error: {
			message({ keyword, schemaCode }) {
				const comp = keyword === "maxLength" ? "more" : "fewer";
				return (0, codegen_1$20.str)`must NOT have ${comp} than ${schemaCode} characters`;
			},
			params: ({ schemaCode }) => (0, codegen_1$20._)`{limit: ${schemaCode}}`
		},
		code(cxt) {
			const { keyword, data, schemaCode, it } = cxt;
			const op = keyword === "maxLength" ? codegen_1$20.operators.GT : codegen_1$20.operators.LT;
			const len = it.opts.unicode === false ? (0, codegen_1$20._)`${data}.length` : (0, codegen_1$20._)`${(0, util_1$19.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
			cxt.fail$data((0, codegen_1$20._)`${len} ${op} ${schemaCode}`);
		}
	};
	exports.default = def$25;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/validation/pattern.js
var require_pattern = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/validation/pattern.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const code_1$7 = require_code();
	const codegen_1$19 = require_codegen();
	const def$24 = {
		keyword: "pattern",
		type: "string",
		schemaType: "string",
		$data: true,
		error: {
			message: ({ schemaCode }) => (0, codegen_1$19.str)`must match pattern "${schemaCode}"`,
			params: ({ schemaCode }) => (0, codegen_1$19._)`{pattern: ${schemaCode}}`
		},
		code(cxt) {
			const { data, $data, schema: schema$1, schemaCode, it } = cxt;
			const u = it.opts.unicodeRegExp ? "u" : "";
			const regExp = $data ? (0, codegen_1$19._)`(new RegExp(${schemaCode}, ${u}))` : (0, code_1$7.usePattern)(cxt, schema$1);
			cxt.fail$data((0, codegen_1$19._)`!${regExp}.test(${data})`);
		}
	};
	exports.default = def$24;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/validation/limitProperties.js
var require_limitProperties = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/validation/limitProperties.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$18 = require_codegen();
	const def$23 = {
		keyword: ["maxProperties", "minProperties"],
		type: "object",
		schemaType: "number",
		$data: true,
		error: {
			message({ keyword, schemaCode }) {
				const comp = keyword === "maxProperties" ? "more" : "fewer";
				return (0, codegen_1$18.str)`must NOT have ${comp} than ${schemaCode} properties`;
			},
			params: ({ schemaCode }) => (0, codegen_1$18._)`{limit: ${schemaCode}}`
		},
		code(cxt) {
			const { keyword, data, schemaCode } = cxt;
			const op = keyword === "maxProperties" ? codegen_1$18.operators.GT : codegen_1$18.operators.LT;
			cxt.fail$data((0, codegen_1$18._)`Object.keys(${data}).length ${op} ${schemaCode}`);
		}
	};
	exports.default = def$23;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/validation/required.js
var require_required = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/validation/required.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const code_1$6 = require_code();
	const codegen_1$17 = require_codegen();
	const util_1$18 = require_util();
	const def$22 = {
		keyword: "required",
		type: "object",
		schemaType: "array",
		$data: true,
		error: {
			message: ({ params: { missingProperty } }) => (0, codegen_1$17.str)`must have required property '${missingProperty}'`,
			params: ({ params: { missingProperty } }) => (0, codegen_1$17._)`{missingProperty: ${missingProperty}}`
		},
		code(cxt) {
			const { gen, schema: schema$1, schemaCode, data, $data, it } = cxt;
			const { opts } = it;
			if (!$data && schema$1.length === 0) return;
			const useLoop = schema$1.length >= opts.loopRequired;
			if (it.allErrors) allErrorsMode();
			else exitOnErrorMode();
			if (opts.strictRequired) {
				const props = cxt.parentSchema.properties;
				const { definedProperties } = cxt.it;
				for (const requiredKey of schema$1) if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
					const msg = `required property "${requiredKey}" is not defined at "${it.schemaEnv.baseId + it.errSchemaPath}" (strictRequired)`;
					(0, util_1$18.checkStrictMode)(it, msg, it.opts.strictRequired);
				}
			}
			function allErrorsMode() {
				if (useLoop || $data) cxt.block$data(codegen_1$17.nil, loopAllRequired);
				else for (const prop of schema$1) (0, code_1$6.checkReportMissingProp)(cxt, prop);
			}
			function exitOnErrorMode() {
				const missing = gen.let("missing");
				if (useLoop || $data) {
					const valid = gen.let("valid", true);
					cxt.block$data(valid, () => loopUntilMissing(missing, valid));
					cxt.ok(valid);
				} else {
					gen.if((0, code_1$6.checkMissingProp)(cxt, schema$1, missing));
					(0, code_1$6.reportMissingProp)(cxt, missing);
					gen.else();
				}
			}
			function loopAllRequired() {
				gen.forOf("prop", schemaCode, (prop) => {
					cxt.setParams({ missingProperty: prop });
					gen.if((0, code_1$6.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
				});
			}
			function loopUntilMissing(missing, valid) {
				cxt.setParams({ missingProperty: missing });
				gen.forOf(missing, schemaCode, () => {
					gen.assign(valid, (0, code_1$6.propertyInData)(gen, data, missing, opts.ownProperties));
					gen.if((0, codegen_1$17.not)(valid), () => {
						cxt.error();
						gen.break();
					});
				}, codegen_1$17.nil);
			}
		}
	};
	exports.default = def$22;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/validation/limitItems.js
var require_limitItems = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/validation/limitItems.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$16 = require_codegen();
	const def$21 = {
		keyword: ["maxItems", "minItems"],
		type: "array",
		schemaType: "number",
		$data: true,
		error: {
			message({ keyword, schemaCode }) {
				const comp = keyword === "maxItems" ? "more" : "fewer";
				return (0, codegen_1$16.str)`must NOT have ${comp} than ${schemaCode} items`;
			},
			params: ({ schemaCode }) => (0, codegen_1$16._)`{limit: ${schemaCode}}`
		},
		code(cxt) {
			const { keyword, data, schemaCode } = cxt;
			const op = keyword === "maxItems" ? codegen_1$16.operators.GT : codegen_1$16.operators.LT;
			cxt.fail$data((0, codegen_1$16._)`${data}.length ${op} ${schemaCode}`);
		}
	};
	exports.default = def$21;
}) });

//#endregion
//#region node_modules/ajv/dist/runtime/equal.js
var require_equal = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/runtime/equal.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const equal = require_fast_deep_equal();
	equal.code = "require(\"ajv/dist/runtime/equal\").default";
	exports.default = equal;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/validation/uniqueItems.js
var require_uniqueItems = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/validation/uniqueItems.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const dataType_1 = require_dataType();
	const codegen_1$15 = require_codegen();
	const util_1$17 = require_util();
	const equal_1$2 = require_equal();
	const def$20 = {
		keyword: "uniqueItems",
		type: "array",
		schemaType: "boolean",
		$data: true,
		error: {
			message: ({ params: { i, j } }) => (0, codegen_1$15.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
			params: ({ params: { i, j } }) => (0, codegen_1$15._)`{i: ${i}, j: ${j}}`
		},
		code(cxt) {
			const { gen, data, $data, schema: schema$1, parentSchema, schemaCode, it } = cxt;
			if (!$data && !schema$1) return;
			const valid = gen.let("valid");
			const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
			cxt.block$data(valid, validateUniqueItems, (0, codegen_1$15._)`${schemaCode} === false`);
			cxt.ok(valid);
			function validateUniqueItems() {
				const i = gen.let("i", (0, codegen_1$15._)`${data}.length`);
				const j = gen.let("j");
				cxt.setParams({
					i,
					j
				});
				gen.assign(valid, true);
				gen.if((0, codegen_1$15._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
			}
			function canOptimize() {
				return itemTypes.length > 0 && !itemTypes.some((t$1) => t$1 === "object" || t$1 === "array");
			}
			function loopN(i, j) {
				const item = gen.name("item");
				const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
				const indices = gen.const("indices", (0, codegen_1$15._)`{}`);
				gen.for((0, codegen_1$15._)`;${i}--;`, () => {
					gen.let(item, (0, codegen_1$15._)`${data}[${i}]`);
					gen.if(wrongType, (0, codegen_1$15._)`continue`);
					if (itemTypes.length > 1) gen.if((0, codegen_1$15._)`typeof ${item} == "string"`, (0, codegen_1$15._)`${item} += "_"`);
					gen.if((0, codegen_1$15._)`typeof ${indices}[${item}] == "number"`, () => {
						gen.assign(j, (0, codegen_1$15._)`${indices}[${item}]`);
						cxt.error();
						gen.assign(valid, false).break();
					}).code((0, codegen_1$15._)`${indices}[${item}] = ${i}`);
				});
			}
			function loopN2(i, j) {
				const eql = (0, util_1$17.useFunc)(gen, equal_1$2.default);
				const outer = gen.name("outer");
				gen.label(outer).for((0, codegen_1$15._)`;${i}--;`, () => gen.for((0, codegen_1$15._)`${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1$15._)`${eql}(${data}[${i}], ${data}[${j}])`, () => {
					cxt.error();
					gen.assign(valid, false).break(outer);
				})));
			}
		}
	};
	exports.default = def$20;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/validation/const.js
var require_const = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/validation/const.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$14 = require_codegen();
	const util_1$16 = require_util();
	const equal_1$1 = require_equal();
	const def$19 = {
		keyword: "const",
		$data: true,
		error: {
			message: "must be equal to constant",
			params: ({ schemaCode }) => (0, codegen_1$14._)`{allowedValue: ${schemaCode}}`
		},
		code(cxt) {
			const { gen, data, $data, schemaCode, schema: schema$1 } = cxt;
			if ($data || schema$1 && typeof schema$1 == "object") cxt.fail$data((0, codegen_1$14._)`!${(0, util_1$16.useFunc)(gen, equal_1$1.default)}(${data}, ${schemaCode})`);
			else cxt.fail((0, codegen_1$14._)`${schema$1} !== ${data}`);
		}
	};
	exports.default = def$19;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/validation/enum.js
var require_enum = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/validation/enum.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$13 = require_codegen();
	const util_1$15 = require_util();
	const equal_1 = require_equal();
	const def$18 = {
		keyword: "enum",
		schemaType: "array",
		$data: true,
		error: {
			message: "must be equal to one of the allowed values",
			params: ({ schemaCode }) => (0, codegen_1$13._)`{allowedValues: ${schemaCode}}`
		},
		code(cxt) {
			const { gen, data, $data, schema: schema$1, schemaCode, it } = cxt;
			if (!$data && schema$1.length === 0) throw new Error("enum must have non-empty array");
			const useLoop = schema$1.length >= it.opts.loopEnum;
			let eql;
			const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1$15.useFunc)(gen, equal_1.default);
			let valid;
			if (useLoop || $data) {
				valid = gen.let("valid");
				cxt.block$data(valid, loopEnum);
			} else {
				/* istanbul ignore if */
				if (!Array.isArray(schema$1)) throw new Error("ajv implementation error");
				const vSchema = gen.const("vSchema", schemaCode);
				valid = (0, codegen_1$13.or)(...schema$1.map((_x, i) => equalCode(vSchema, i)));
			}
			cxt.pass(valid);
			function loopEnum() {
				gen.assign(valid, false);
				gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1$13._)`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));
			}
			function equalCode(vSchema, i) {
				const sch = schema$1[i];
				return typeof sch === "object" && sch !== null ? (0, codegen_1$13._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1$13._)`${data} === ${sch}`;
			}
		}
	};
	exports.default = def$18;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/validation/index.js
var require_validation = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/validation/index.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const limitNumber_1 = require_limitNumber();
	const multipleOf_1 = require_multipleOf();
	const limitLength_1 = require_limitLength();
	const pattern_1 = require_pattern();
	const limitProperties_1 = require_limitProperties();
	const required_1 = require_required();
	const limitItems_1 = require_limitItems();
	const uniqueItems_1 = require_uniqueItems();
	const const_1 = require_const();
	const enum_1 = require_enum();
	const validation = [
		limitNumber_1.default,
		multipleOf_1.default,
		limitLength_1.default,
		pattern_1.default,
		limitProperties_1.default,
		required_1.default,
		limitItems_1.default,
		uniqueItems_1.default,
		{
			keyword: "type",
			schemaType: ["string", "array"]
		},
		{
			keyword: "nullable",
			schemaType: "boolean"
		},
		const_1.default,
		enum_1.default
	];
	exports.default = validation;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/applicator/additionalItems.js
var require_additionalItems = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/applicator/additionalItems.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$12 = require_codegen();
	const util_1$14 = require_util();
	const def$17 = {
		keyword: "additionalItems",
		type: "array",
		schemaType: ["boolean", "object"],
		before: "uniqueItems",
		error: {
			message: ({ params: { len } }) => (0, codegen_1$12.str)`must NOT have more than ${len} items`,
			params: ({ params: { len } }) => (0, codegen_1$12._)`{limit: ${len}}`
		},
		code(cxt) {
			const { parentSchema, it } = cxt;
			const { items } = parentSchema;
			if (!Array.isArray(items)) {
				(0, util_1$14.checkStrictMode)(it, "\"additionalItems\" is ignored when \"items\" is not an array of schemas");
				return;
			}
			validateAdditionalItems(cxt, items);
		}
	};
	function validateAdditionalItems(cxt, items) {
		const { gen, schema: schema$1, data, keyword, it } = cxt;
		it.items = true;
		const len = gen.const("len", (0, codegen_1$12._)`${data}.length`);
		if (schema$1 === false) {
			cxt.setParams({ len: items.length });
			cxt.pass((0, codegen_1$12._)`${len} <= ${items.length}`);
		} else if (typeof schema$1 == "object" && !(0, util_1$14.alwaysValidSchema)(it, schema$1)) {
			const valid = gen.var("valid", (0, codegen_1$12._)`${len} <= ${items.length}`);
			gen.if((0, codegen_1$12.not)(valid), () => validateItems(valid));
			cxt.ok(valid);
		}
		function validateItems(valid) {
			gen.forRange("i", items.length, len, (i) => {
				cxt.subschema({
					keyword,
					dataProp: i,
					dataPropType: util_1$14.Type.Num
				}, valid);
				if (!it.allErrors) gen.if((0, codegen_1$12.not)(valid), () => gen.break());
			});
		}
	}
	exports.validateAdditionalItems = validateAdditionalItems;
	exports.default = def$17;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/applicator/items.js
var require_items = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/applicator/items.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$11 = require_codegen();
	const util_1$13 = require_util();
	const code_1$5 = require_code();
	const def$16 = {
		keyword: "items",
		type: "array",
		schemaType: [
			"object",
			"array",
			"boolean"
		],
		before: "uniqueItems",
		code(cxt) {
			const { schema: schema$1, it } = cxt;
			if (Array.isArray(schema$1)) return validateTuple(cxt, "additionalItems", schema$1);
			it.items = true;
			if ((0, util_1$13.alwaysValidSchema)(it, schema$1)) return;
			cxt.ok((0, code_1$5.validateArray)(cxt));
		}
	};
	function validateTuple(cxt, extraItems, schArr = cxt.schema) {
		const { gen, parentSchema, data, keyword, it } = cxt;
		checkStrictTuple(parentSchema);
		if (it.opts.unevaluated && schArr.length && it.items !== true) it.items = util_1$13.mergeEvaluated.items(gen, schArr.length, it.items);
		const valid = gen.name("valid");
		const len = gen.const("len", (0, codegen_1$11._)`${data}.length`);
		schArr.forEach((sch, i) => {
			if ((0, util_1$13.alwaysValidSchema)(it, sch)) return;
			gen.if((0, codegen_1$11._)`${len} > ${i}`, () => cxt.subschema({
				keyword,
				schemaProp: i,
				dataProp: i
			}, valid));
			cxt.ok(valid);
		});
		function checkStrictTuple(sch) {
			const { opts, errSchemaPath } = it;
			const l = schArr.length;
			const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
			if (opts.strictTuples && !fullTuple) {
				const msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
				(0, util_1$13.checkStrictMode)(it, msg, opts.strictTuples);
			}
		}
	}
	exports.validateTuple = validateTuple;
	exports.default = def$16;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/applicator/prefixItems.js
var require_prefixItems = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/applicator/prefixItems.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const items_1$1 = require_items();
	const def$15 = {
		keyword: "prefixItems",
		type: "array",
		schemaType: ["array"],
		before: "uniqueItems",
		code: (cxt) => (0, items_1$1.validateTuple)(cxt, "items")
	};
	exports.default = def$15;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/applicator/items2020.js
var require_items2020 = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/applicator/items2020.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$10 = require_codegen();
	const util_1$12 = require_util();
	const code_1$4 = require_code();
	const additionalItems_1$1 = require_additionalItems();
	const def$14 = {
		keyword: "items",
		type: "array",
		schemaType: ["object", "boolean"],
		before: "uniqueItems",
		error: {
			message: ({ params: { len } }) => (0, codegen_1$10.str)`must NOT have more than ${len} items`,
			params: ({ params: { len } }) => (0, codegen_1$10._)`{limit: ${len}}`
		},
		code(cxt) {
			const { schema: schema$1, parentSchema, it } = cxt;
			const { prefixItems } = parentSchema;
			it.items = true;
			if ((0, util_1$12.alwaysValidSchema)(it, schema$1)) return;
			if (prefixItems) (0, additionalItems_1$1.validateAdditionalItems)(cxt, prefixItems);
			else cxt.ok((0, code_1$4.validateArray)(cxt));
		}
	};
	exports.default = def$14;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/applicator/contains.js
var require_contains = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/applicator/contains.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$9 = require_codegen();
	const util_1$11 = require_util();
	const def$13 = {
		keyword: "contains",
		type: "array",
		schemaType: ["object", "boolean"],
		before: "uniqueItems",
		trackErrors: true,
		error: {
			message: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1$9.str)`must contain at least ${min} valid item(s)` : (0, codegen_1$9.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
			params: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1$9._)`{minContains: ${min}}` : (0, codegen_1$9._)`{minContains: ${min}, maxContains: ${max}}`
		},
		code(cxt) {
			const { gen, schema: schema$1, parentSchema, data, it } = cxt;
			let min;
			let max;
			const { minContains, maxContains } = parentSchema;
			if (it.opts.next) {
				min = minContains === void 0 ? 1 : minContains;
				max = maxContains;
			} else min = 1;
			const len = gen.const("len", (0, codegen_1$9._)`${data}.length`);
			cxt.setParams({
				min,
				max
			});
			if (max === void 0 && min === 0) {
				(0, util_1$11.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
				return;
			}
			if (max !== void 0 && min > max) {
				(0, util_1$11.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
				cxt.fail();
				return;
			}
			if ((0, util_1$11.alwaysValidSchema)(it, schema$1)) {
				let cond = (0, codegen_1$9._)`${len} >= ${min}`;
				if (max !== void 0) cond = (0, codegen_1$9._)`${cond} && ${len} <= ${max}`;
				cxt.pass(cond);
				return;
			}
			it.items = true;
			const valid = gen.name("valid");
			if (max === void 0 && min === 1) validateItems(valid, () => gen.if(valid, () => gen.break()));
			else if (min === 0) {
				gen.let(valid, true);
				if (max !== void 0) gen.if((0, codegen_1$9._)`${data}.length > 0`, validateItemsWithCount);
			} else {
				gen.let(valid, false);
				validateItemsWithCount();
			}
			cxt.result(valid, () => cxt.reset());
			function validateItemsWithCount() {
				const schValid = gen.name("_valid");
				const count = gen.let("count", 0);
				validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
			}
			function validateItems(_valid, block) {
				gen.forRange("i", 0, len, (i) => {
					cxt.subschema({
						keyword: "contains",
						dataProp: i,
						dataPropType: util_1$11.Type.Num,
						compositeRule: true
					}, _valid);
					block();
				});
			}
			function checkLimits(count) {
				gen.code((0, codegen_1$9._)`${count}++`);
				if (max === void 0) gen.if((0, codegen_1$9._)`${count} >= ${min}`, () => gen.assign(valid, true).break());
				else {
					gen.if((0, codegen_1$9._)`${count} > ${max}`, () => gen.assign(valid, false).break());
					if (min === 1) gen.assign(valid, true);
					else gen.if((0, codegen_1$9._)`${count} >= ${min}`, () => gen.assign(valid, true));
				}
			}
		}
	};
	exports.default = def$13;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/applicator/dependencies.js
var require_dependencies = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/applicator/dependencies.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;
	const codegen_1$8 = require_codegen();
	const util_1$10 = require_util();
	const code_1$3 = require_code();
	exports.error = {
		message: ({ params: { property, depsCount, deps } }) => {
			const property_ies = depsCount === 1 ? "property" : "properties";
			return (0, codegen_1$8.str)`must have ${property_ies} ${deps} when property ${property} is present`;
		},
		params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1$8._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
	};
	const def$12 = {
		keyword: "dependencies",
		type: "object",
		schemaType: "object",
		error: exports.error,
		code(cxt) {
			const [propDeps, schDeps] = splitDependencies(cxt);
			validatePropertyDeps(cxt, propDeps);
			validateSchemaDeps(cxt, schDeps);
		}
	};
	function splitDependencies({ schema: schema$1 }) {
		const propertyDeps = {};
		const schemaDeps = {};
		for (const key in schema$1) {
			if (key === "__proto__") continue;
			const deps = Array.isArray(schema$1[key]) ? propertyDeps : schemaDeps;
			deps[key] = schema$1[key];
		}
		return [propertyDeps, schemaDeps];
	}
	function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
		const { gen, data, it } = cxt;
		if (Object.keys(propertyDeps).length === 0) return;
		const missing = gen.let("missing");
		for (const prop in propertyDeps) {
			const deps = propertyDeps[prop];
			if (deps.length === 0) continue;
			const hasProperty = (0, code_1$3.propertyInData)(gen, data, prop, it.opts.ownProperties);
			cxt.setParams({
				property: prop,
				depsCount: deps.length,
				deps: deps.join(", ")
			});
			if (it.allErrors) gen.if(hasProperty, () => {
				for (const depProp of deps) (0, code_1$3.checkReportMissingProp)(cxt, depProp);
			});
			else {
				gen.if((0, codegen_1$8._)`${hasProperty} && (${(0, code_1$3.checkMissingProp)(cxt, deps, missing)})`);
				(0, code_1$3.reportMissingProp)(cxt, missing);
				gen.else();
			}
		}
	}
	exports.validatePropertyDeps = validatePropertyDeps;
	function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
		const { gen, data, keyword, it } = cxt;
		const valid = gen.name("valid");
		for (const prop in schemaDeps) {
			if ((0, util_1$10.alwaysValidSchema)(it, schemaDeps[prop])) continue;
			gen.if((0, code_1$3.propertyInData)(gen, data, prop, it.opts.ownProperties), () => {
				const schCxt = cxt.subschema({
					keyword,
					schemaProp: prop
				}, valid);
				cxt.mergeValidEvaluated(schCxt, valid);
			}, () => gen.var(valid, true));
			cxt.ok(valid);
		}
	}
	exports.validateSchemaDeps = validateSchemaDeps;
	exports.default = def$12;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/applicator/propertyNames.js
var require_propertyNames = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/applicator/propertyNames.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$7 = require_codegen();
	const util_1$9 = require_util();
	const def$11 = {
		keyword: "propertyNames",
		type: "object",
		schemaType: ["object", "boolean"],
		error: {
			message: "property name must be valid",
			params: ({ params }) => (0, codegen_1$7._)`{propertyName: ${params.propertyName}}`
		},
		code(cxt) {
			const { gen, schema: schema$1, data, it } = cxt;
			if ((0, util_1$9.alwaysValidSchema)(it, schema$1)) return;
			const valid = gen.name("valid");
			gen.forIn("key", data, (key) => {
				cxt.setParams({ propertyName: key });
				cxt.subschema({
					keyword: "propertyNames",
					data: key,
					dataTypes: ["string"],
					propertyName: key,
					compositeRule: true
				}, valid);
				gen.if((0, codegen_1$7.not)(valid), () => {
					cxt.error(true);
					if (!it.allErrors) gen.break();
				});
			});
			cxt.ok(valid);
		}
	};
	exports.default = def$11;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js
var require_additionalProperties = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const code_1$2 = require_code();
	const codegen_1$6 = require_codegen();
	const names_1 = require_names();
	const util_1$8 = require_util();
	const def$10 = {
		keyword: "additionalProperties",
		type: ["object"],
		schemaType: ["boolean", "object"],
		allowUndefined: true,
		trackErrors: true,
		error: {
			message: "must NOT have additional properties",
			params: ({ params }) => (0, codegen_1$6._)`{additionalProperty: ${params.additionalProperty}}`
		},
		code(cxt) {
			const { gen, schema: schema$1, parentSchema, data, errsCount, it } = cxt;
			/* istanbul ignore if */
			if (!errsCount) throw new Error("ajv implementation error");
			const { allErrors, opts } = it;
			it.props = true;
			if (opts.removeAdditional !== "all" && (0, util_1$8.alwaysValidSchema)(it, schema$1)) return;
			const props = (0, code_1$2.allSchemaProperties)(parentSchema.properties);
			const patProps = (0, code_1$2.allSchemaProperties)(parentSchema.patternProperties);
			checkAdditionalProperties();
			cxt.ok((0, codegen_1$6._)`${errsCount} === ${names_1.default.errors}`);
			function checkAdditionalProperties() {
				gen.forIn("key", data, (key) => {
					if (!props.length && !patProps.length) additionalPropertyCode(key);
					else gen.if(isAdditional(key), () => additionalPropertyCode(key));
				});
			}
			function isAdditional(key) {
				let definedProp;
				if (props.length > 8) {
					const propsSchema = (0, util_1$8.schemaRefOrVal)(it, parentSchema.properties, "properties");
					definedProp = (0, code_1$2.isOwnProperty)(gen, propsSchema, key);
				} else if (props.length) definedProp = (0, codegen_1$6.or)(...props.map((p) => (0, codegen_1$6._)`${key} === ${p}`));
				else definedProp = codegen_1$6.nil;
				if (patProps.length) definedProp = (0, codegen_1$6.or)(definedProp, ...patProps.map((p) => (0, codegen_1$6._)`${(0, code_1$2.usePattern)(cxt, p)}.test(${key})`));
				return (0, codegen_1$6.not)(definedProp);
			}
			function deleteAdditional(key) {
				gen.code((0, codegen_1$6._)`delete ${data}[${key}]`);
			}
			function additionalPropertyCode(key) {
				if (opts.removeAdditional === "all" || opts.removeAdditional && schema$1 === false) {
					deleteAdditional(key);
					return;
				}
				if (schema$1 === false) {
					cxt.setParams({ additionalProperty: key });
					cxt.error();
					if (!allErrors) gen.break();
					return;
				}
				if (typeof schema$1 == "object" && !(0, util_1$8.alwaysValidSchema)(it, schema$1)) {
					const valid = gen.name("valid");
					if (opts.removeAdditional === "failing") {
						applyAdditionalSchema(key, valid, false);
						gen.if((0, codegen_1$6.not)(valid), () => {
							cxt.reset();
							deleteAdditional(key);
						});
					} else {
						applyAdditionalSchema(key, valid);
						if (!allErrors) gen.if((0, codegen_1$6.not)(valid), () => gen.break());
					}
				}
			}
			function applyAdditionalSchema(key, valid, errors$1) {
				const subschema = {
					keyword: "additionalProperties",
					dataProp: key,
					dataPropType: util_1$8.Type.Str
				};
				if (errors$1 === false) Object.assign(subschema, {
					compositeRule: true,
					createErrors: false,
					allErrors: false
				});
				cxt.subschema(subschema, valid);
			}
		}
	};
	exports.default = def$10;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/applicator/properties.js
var require_properties = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/applicator/properties.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const validate_1$1 = require_validate();
	const code_1$1 = require_code();
	const util_1$7 = require_util();
	const additionalProperties_1$1 = require_additionalProperties();
	const def$9 = {
		keyword: "properties",
		type: "object",
		schemaType: "object",
		code(cxt) {
			const { gen, schema: schema$1, parentSchema, data, it } = cxt;
			if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) additionalProperties_1$1.default.code(new validate_1$1.KeywordCxt(it, additionalProperties_1$1.default, "additionalProperties"));
			const allProps = (0, code_1$1.allSchemaProperties)(schema$1);
			for (const prop of allProps) it.definedProperties.add(prop);
			if (it.opts.unevaluated && allProps.length && it.props !== true) it.props = util_1$7.mergeEvaluated.props(gen, (0, util_1$7.toHash)(allProps), it.props);
			const properties = allProps.filter((p) => !(0, util_1$7.alwaysValidSchema)(it, schema$1[p]));
			if (properties.length === 0) return;
			const valid = gen.name("valid");
			for (const prop of properties) {
				if (hasDefault(prop)) applyPropertySchema(prop);
				else {
					gen.if((0, code_1$1.propertyInData)(gen, data, prop, it.opts.ownProperties));
					applyPropertySchema(prop);
					if (!it.allErrors) gen.else().var(valid, true);
					gen.endIf();
				}
				cxt.it.definedProperties.add(prop);
				cxt.ok(valid);
			}
			function hasDefault(prop) {
				return it.opts.useDefaults && !it.compositeRule && schema$1[prop].default !== void 0;
			}
			function applyPropertySchema(prop) {
				cxt.subschema({
					keyword: "properties",
					schemaProp: prop,
					dataProp: prop
				}, valid);
			}
		}
	};
	exports.default = def$9;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/applicator/patternProperties.js
var require_patternProperties = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/applicator/patternProperties.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const code_1 = require_code();
	const codegen_1$5 = require_codegen();
	const util_1$6 = require_util();
	const util_2 = require_util();
	const def$8 = {
		keyword: "patternProperties",
		type: "object",
		schemaType: "object",
		code(cxt) {
			const { gen, schema: schema$1, data, parentSchema, it } = cxt;
			const { opts } = it;
			const patterns = (0, code_1.allSchemaProperties)(schema$1);
			const alwaysValidPatterns = patterns.filter((p) => (0, util_1$6.alwaysValidSchema)(it, schema$1[p]));
			if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) return;
			const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
			const valid = gen.name("valid");
			if (it.props !== true && !(it.props instanceof codegen_1$5.Name)) it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
			const { props } = it;
			validatePatternProperties();
			function validatePatternProperties() {
				for (const pat of patterns) {
					if (checkProperties) checkMatchingProperties(pat);
					if (it.allErrors) validateProperties(pat);
					else {
						gen.var(valid, true);
						validateProperties(pat);
						gen.if(valid);
					}
				}
			}
			function checkMatchingProperties(pat) {
				for (const prop in checkProperties) if (new RegExp(pat).test(prop)) (0, util_1$6.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
			}
			function validateProperties(pat) {
				gen.forIn("key", data, (key) => {
					gen.if((0, codegen_1$5._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
						const alwaysValid = alwaysValidPatterns.includes(pat);
						if (!alwaysValid) cxt.subschema({
							keyword: "patternProperties",
							schemaProp: pat,
							dataProp: key,
							dataPropType: util_2.Type.Str
						}, valid);
						if (it.opts.unevaluated && props !== true) gen.assign((0, codegen_1$5._)`${props}[${key}]`, true);
						else if (!alwaysValid && !it.allErrors) gen.if((0, codegen_1$5.not)(valid), () => gen.break());
					});
				});
			}
		}
	};
	exports.default = def$8;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/applicator/not.js
var require_not = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/applicator/not.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const util_1$5 = require_util();
	const def$7 = {
		keyword: "not",
		schemaType: ["object", "boolean"],
		trackErrors: true,
		code(cxt) {
			const { gen, schema: schema$1, it } = cxt;
			if ((0, util_1$5.alwaysValidSchema)(it, schema$1)) {
				cxt.fail();
				return;
			}
			const valid = gen.name("valid");
			cxt.subschema({
				keyword: "not",
				compositeRule: true,
				createErrors: false,
				allErrors: false
			}, valid);
			cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
		},
		error: { message: "must NOT be valid" }
	};
	exports.default = def$7;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/applicator/anyOf.js
var require_anyOf = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/applicator/anyOf.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const def$6 = {
		keyword: "anyOf",
		schemaType: "array",
		trackErrors: true,
		code: require_code().validateUnion,
		error: { message: "must match a schema in anyOf" }
	};
	exports.default = def$6;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/applicator/oneOf.js
var require_oneOf = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/applicator/oneOf.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$4 = require_codegen();
	const util_1$4 = require_util();
	const def$5 = {
		keyword: "oneOf",
		schemaType: "array",
		trackErrors: true,
		error: {
			message: "must match exactly one schema in oneOf",
			params: ({ params }) => (0, codegen_1$4._)`{passingSchemas: ${params.passing}}`
		},
		code(cxt) {
			const { gen, schema: schema$1, parentSchema, it } = cxt;
			/* istanbul ignore if */
			if (!Array.isArray(schema$1)) throw new Error("ajv implementation error");
			if (it.opts.discriminator && parentSchema.discriminator) return;
			const schArr = schema$1;
			const valid = gen.let("valid", false);
			const passing = gen.let("passing", null);
			const schValid = gen.name("_valid");
			cxt.setParams({ passing });
			gen.block(validateOneOf);
			cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
			function validateOneOf() {
				schArr.forEach((sch, i) => {
					let schCxt;
					if ((0, util_1$4.alwaysValidSchema)(it, sch)) gen.var(schValid, true);
					else schCxt = cxt.subschema({
						keyword: "oneOf",
						schemaProp: i,
						compositeRule: true
					}, schValid);
					if (i > 0) gen.if((0, codegen_1$4._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1$4._)`[${passing}, ${i}]`).else();
					gen.if(schValid, () => {
						gen.assign(valid, true);
						gen.assign(passing, i);
						if (schCxt) cxt.mergeEvaluated(schCxt, codegen_1$4.Name);
					});
				});
			}
		}
	};
	exports.default = def$5;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/applicator/allOf.js
var require_allOf = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/applicator/allOf.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const util_1$3 = require_util();
	const def$4 = {
		keyword: "allOf",
		schemaType: "array",
		code(cxt) {
			const { gen, schema: schema$1, it } = cxt;
			/* istanbul ignore if */
			if (!Array.isArray(schema$1)) throw new Error("ajv implementation error");
			const valid = gen.name("valid");
			schema$1.forEach((sch, i) => {
				if ((0, util_1$3.alwaysValidSchema)(it, sch)) return;
				const schCxt = cxt.subschema({
					keyword: "allOf",
					schemaProp: i
				}, valid);
				cxt.ok(valid);
				cxt.mergeEvaluated(schCxt);
			});
		}
	};
	exports.default = def$4;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/applicator/if.js
var require_if = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/applicator/if.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$3 = require_codegen();
	const util_1$2 = require_util();
	const def$3 = {
		keyword: "if",
		schemaType: ["object", "boolean"],
		trackErrors: true,
		error: {
			message: ({ params }) => (0, codegen_1$3.str)`must match "${params.ifClause}" schema`,
			params: ({ params }) => (0, codegen_1$3._)`{failingKeyword: ${params.ifClause}}`
		},
		code(cxt) {
			const { gen, parentSchema, it } = cxt;
			if (parentSchema.then === void 0 && parentSchema.else === void 0) (0, util_1$2.checkStrictMode)(it, "\"if\" without \"then\" and \"else\" is ignored");
			const hasThen = hasSchema(it, "then");
			const hasElse = hasSchema(it, "else");
			if (!hasThen && !hasElse) return;
			const valid = gen.let("valid", true);
			const schValid = gen.name("_valid");
			validateIf();
			cxt.reset();
			if (hasThen && hasElse) {
				const ifClause = gen.let("ifClause");
				cxt.setParams({ ifClause });
				gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
			} else if (hasThen) gen.if(schValid, validateClause("then"));
			else gen.if((0, codegen_1$3.not)(schValid), validateClause("else"));
			cxt.pass(valid, () => cxt.error(true));
			function validateIf() {
				const schCxt = cxt.subschema({
					keyword: "if",
					compositeRule: true,
					createErrors: false,
					allErrors: false
				}, schValid);
				cxt.mergeEvaluated(schCxt);
			}
			function validateClause(keyword, ifClause) {
				return () => {
					const schCxt = cxt.subschema({ keyword }, schValid);
					gen.assign(valid, schValid);
					cxt.mergeValidEvaluated(schCxt, valid);
					if (ifClause) gen.assign(ifClause, (0, codegen_1$3._)`${keyword}`);
					else cxt.setParams({ ifClause: keyword });
				};
			}
		}
	};
	function hasSchema(it, keyword) {
		const schema$1 = it.schema[keyword];
		return schema$1 !== void 0 && !(0, util_1$2.alwaysValidSchema)(it, schema$1);
	}
	exports.default = def$3;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/applicator/thenElse.js
var require_thenElse = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/applicator/thenElse.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const util_1$1 = require_util();
	const def$2 = {
		keyword: ["then", "else"],
		schemaType: ["object", "boolean"],
		code({ keyword, parentSchema, it }) {
			if (parentSchema.if === void 0) (0, util_1$1.checkStrictMode)(it, `"${keyword}" without "if" is ignored`);
		}
	};
	exports.default = def$2;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/applicator/index.js
var require_applicator = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/applicator/index.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const additionalItems_1 = require_additionalItems();
	const prefixItems_1 = require_prefixItems();
	const items_1 = require_items();
	const items2020_1 = require_items2020();
	const contains_1 = require_contains();
	const dependencies_1 = require_dependencies();
	const propertyNames_1 = require_propertyNames();
	const additionalProperties_1 = require_additionalProperties();
	const properties_1 = require_properties();
	const patternProperties_1 = require_patternProperties();
	const not_1 = require_not();
	const anyOf_1 = require_anyOf();
	const oneOf_1 = require_oneOf();
	const allOf_1 = require_allOf();
	const if_1 = require_if();
	const thenElse_1 = require_thenElse();
	function getApplicator(draft2020 = false) {
		const applicator = [
			not_1.default,
			anyOf_1.default,
			oneOf_1.default,
			allOf_1.default,
			if_1.default,
			thenElse_1.default,
			propertyNames_1.default,
			additionalProperties_1.default,
			dependencies_1.default,
			properties_1.default,
			patternProperties_1.default
		];
		if (draft2020) applicator.push(prefixItems_1.default, items2020_1.default);
		else applicator.push(additionalItems_1.default, items_1.default);
		applicator.push(contains_1.default);
		return applicator;
	}
	exports.default = getApplicator;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/format/format.js
var require_format$1 = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/format/format.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$2 = require_codegen();
	const def$1 = {
		keyword: "format",
		type: ["number", "string"],
		schemaType: "string",
		$data: true,
		error: {
			message: ({ schemaCode }) => (0, codegen_1$2.str)`must match format "${schemaCode}"`,
			params: ({ schemaCode }) => (0, codegen_1$2._)`{format: ${schemaCode}}`
		},
		code(cxt, ruleType) {
			const { gen, data, $data, schema: schema$1, schemaCode, it } = cxt;
			const { opts, errSchemaPath, schemaEnv, self } = it;
			if (!opts.validateFormats) return;
			if ($data) validate$DataFormat();
			else validateFormat();
			function validate$DataFormat() {
				const fmts = gen.scopeValue("formats", {
					ref: self.formats,
					code: opts.code.formats
				});
				const fDef = gen.const("fDef", (0, codegen_1$2._)`${fmts}[${schemaCode}]`);
				const fType = gen.let("fType");
				const format$1 = gen.let("format");
				gen.if((0, codegen_1$2._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1$2._)`${fDef}.type || "string"`).assign(format$1, (0, codegen_1$2._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1$2._)`"string"`).assign(format$1, fDef));
				cxt.fail$data((0, codegen_1$2.or)(unknownFmt(), invalidFmt()));
				function unknownFmt() {
					if (opts.strictSchema === false) return codegen_1$2.nil;
					return (0, codegen_1$2._)`${schemaCode} && !${format$1}`;
				}
				function invalidFmt() {
					const callFormat = schemaEnv.$async ? (0, codegen_1$2._)`(${fDef}.async ? await ${format$1}(${data}) : ${format$1}(${data}))` : (0, codegen_1$2._)`${format$1}(${data})`;
					const validData = (0, codegen_1$2._)`(typeof ${format$1} == "function" ? ${callFormat} : ${format$1}.test(${data}))`;
					return (0, codegen_1$2._)`${format$1} && ${format$1} !== true && ${fType} === ${ruleType} && !${validData}`;
				}
			}
			function validateFormat() {
				const formatDef = self.formats[schema$1];
				if (!formatDef) {
					unknownFormat();
					return;
				}
				if (formatDef === true) return;
				const [fmtType, format$1, fmtRef] = getFormat(formatDef);
				if (fmtType === ruleType) cxt.pass(validCondition());
				function unknownFormat() {
					if (opts.strictSchema === false) {
						self.logger.warn(unknownMsg());
						return;
					}
					throw new Error(unknownMsg());
					function unknownMsg() {
						return `unknown format "${schema$1}" ignored in schema at path "${errSchemaPath}"`;
					}
				}
				function getFormat(fmtDef) {
					const code = fmtDef instanceof RegExp ? (0, codegen_1$2.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1$2._)`${opts.code.formats}${(0, codegen_1$2.getProperty)(schema$1)}` : void 0;
					const fmt = gen.scopeValue("formats", {
						key: schema$1,
						ref: fmtDef,
						code
					});
					if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) return [
						fmtDef.type || "string",
						fmtDef.validate,
						(0, codegen_1$2._)`${fmt}.validate`
					];
					return [
						"string",
						fmtDef,
						fmt
					];
				}
				function validCondition() {
					if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
						if (!schemaEnv.$async) throw new Error("async format in sync schema");
						return (0, codegen_1$2._)`await ${fmtRef}(${data})`;
					}
					return typeof format$1 == "function" ? (0, codegen_1$2._)`${fmtRef}(${data})` : (0, codegen_1$2._)`${fmtRef}.test(${data})`;
				}
			}
		}
	};
	exports.default = def$1;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/format/index.js
var require_format = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/format/index.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const format = [require_format$1().default];
	exports.default = format;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/metadata.js
var require_metadata = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/metadata.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.metadataVocabulary = [
		"title",
		"description",
		"default",
		"deprecated",
		"readOnly",
		"writeOnly",
		"examples"
	];
	exports.contentVocabulary = [
		"contentMediaType",
		"contentEncoding",
		"contentSchema"
	];
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/draft7.js
var require_draft7 = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/draft7.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const core_1$1 = require_core();
	const validation_1 = require_validation();
	const applicator_1 = require_applicator();
	const format_1 = require_format();
	const metadata_1 = require_metadata();
	const draft7Vocabularies = [
		core_1$1.default,
		validation_1.default,
		(0, applicator_1.default)(),
		format_1.default,
		metadata_1.metadataVocabulary,
		metadata_1.contentVocabulary
	];
	exports.default = draft7Vocabularies;
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/discriminator/types.js
var require_types = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/discriminator/types.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var DiscrError;
	(function(DiscrError$1) {
		DiscrError$1["Tag"] = "tag";
		DiscrError$1["Mapping"] = "mapping";
	})(DiscrError || (exports.DiscrError = DiscrError = {}));
}) });

//#endregion
//#region node_modules/ajv/dist/vocabularies/discriminator/index.js
var require_discriminator = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/vocabularies/discriminator/index.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$1 = require_codegen();
	const types_1 = require_types();
	const compile_1 = require_compile();
	const ref_error_1$1 = require_ref_error();
	const util_1 = require_util();
	const def = {
		keyword: "discriminator",
		type: "object",
		schemaType: "object",
		error: {
			message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
			params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1$1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
		},
		code(cxt) {
			const { gen, data, schema: schema$1, parentSchema, it } = cxt;
			const { oneOf } = parentSchema;
			if (!it.opts.discriminator) throw new Error("discriminator: requires discriminator option");
			const tagName = schema$1.propertyName;
			if (typeof tagName != "string") throw new Error("discriminator: requires propertyName");
			if (schema$1.mapping) throw new Error("discriminator: mapping is not supported");
			if (!oneOf) throw new Error("discriminator: requires oneOf keyword");
			const valid = gen.let("valid", false);
			const tag = gen.const("tag", (0, codegen_1$1._)`${data}${(0, codegen_1$1.getProperty)(tagName)}`);
			gen.if((0, codegen_1$1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, {
				discrError: types_1.DiscrError.Tag,
				tag,
				tagName
			}));
			cxt.ok(valid);
			function validateMapping() {
				const mapping = getMapping();
				gen.if(false);
				for (const tagValue in mapping) {
					gen.elseIf((0, codegen_1$1._)`${tag} === ${tagValue}`);
					gen.assign(valid, applyTagSchema(mapping[tagValue]));
				}
				gen.else();
				cxt.error(false, {
					discrError: types_1.DiscrError.Mapping,
					tag,
					tagName
				});
				gen.endIf();
			}
			function applyTagSchema(schemaProp) {
				const _valid = gen.name("valid");
				const schCxt = cxt.subschema({
					keyword: "oneOf",
					schemaProp
				}, _valid);
				cxt.mergeEvaluated(schCxt, codegen_1$1.Name);
				return _valid;
			}
			function getMapping() {
				var _a$1;
				const oneOfMapping = {};
				const topRequired = hasRequired(parentSchema);
				let tagRequired = true;
				for (let i = 0; i < oneOf.length; i++) {
					let sch = oneOf[i];
					if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
						const ref = sch.$ref;
						sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref);
						if (sch instanceof compile_1.SchemaEnv) sch = sch.schema;
						if (sch === void 0) throw new ref_error_1$1.default(it.opts.uriResolver, it.baseId, ref);
					}
					const propSch = (_a$1 = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a$1 === void 0 ? void 0 : _a$1[tagName];
					if (typeof propSch != "object") throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
					tagRequired = tagRequired && (topRequired || hasRequired(sch));
					addMappings(propSch, i);
				}
				if (!tagRequired) throw new Error(`discriminator: "${tagName}" must be required`);
				return oneOfMapping;
				function hasRequired({ required }) {
					return Array.isArray(required) && required.includes(tagName);
				}
				function addMappings(sch, i) {
					if (sch.const) addMapping(sch.const, i);
					else if (sch.enum) for (const tagValue of sch.enum) addMapping(tagValue, i);
					else throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
				}
				function addMapping(tagValue, i) {
					if (typeof tagValue != "string" || tagValue in oneOfMapping) throw new Error(`discriminator: "${tagName}" values must be unique strings`);
					oneOfMapping[tagValue] = i;
				}
			}
		}
	};
	exports.default = def;
}) });

//#endregion
//#region node_modules/ajv/dist/refs/json-schema-draft-07.json
var require_json_schema_draft_07 = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/refs/json-schema-draft-07.json": ((exports, module) => {
	module.exports = {
		"$schema": "http://json-schema.org/draft-07/schema#",
		"$id": "http://json-schema.org/draft-07/schema#",
		"title": "Core schema meta-schema",
		"definitions": {
			"schemaArray": {
				"type": "array",
				"minItems": 1,
				"items": { "$ref": "#" }
			},
			"nonNegativeInteger": {
				"type": "integer",
				"minimum": 0
			},
			"nonNegativeIntegerDefault0": { "allOf": [{ "$ref": "#/definitions/nonNegativeInteger" }, { "default": 0 }] },
			"simpleTypes": { "enum": [
				"array",
				"boolean",
				"integer",
				"null",
				"number",
				"object",
				"string"
			] },
			"stringArray": {
				"type": "array",
				"items": { "type": "string" },
				"uniqueItems": true,
				"default": []
			}
		},
		"type": ["object", "boolean"],
		"properties": {
			"$id": {
				"type": "string",
				"format": "uri-reference"
			},
			"$schema": {
				"type": "string",
				"format": "uri"
			},
			"$ref": {
				"type": "string",
				"format": "uri-reference"
			},
			"$comment": { "type": "string" },
			"title": { "type": "string" },
			"description": { "type": "string" },
			"default": true,
			"readOnly": {
				"type": "boolean",
				"default": false
			},
			"examples": {
				"type": "array",
				"items": true
			},
			"multipleOf": {
				"type": "number",
				"exclusiveMinimum": 0
			},
			"maximum": { "type": "number" },
			"exclusiveMaximum": { "type": "number" },
			"minimum": { "type": "number" },
			"exclusiveMinimum": { "type": "number" },
			"maxLength": { "$ref": "#/definitions/nonNegativeInteger" },
			"minLength": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },
			"pattern": {
				"type": "string",
				"format": "regex"
			},
			"additionalItems": { "$ref": "#" },
			"items": {
				"anyOf": [{ "$ref": "#" }, { "$ref": "#/definitions/schemaArray" }],
				"default": true
			},
			"maxItems": { "$ref": "#/definitions/nonNegativeInteger" },
			"minItems": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },
			"uniqueItems": {
				"type": "boolean",
				"default": false
			},
			"contains": { "$ref": "#" },
			"maxProperties": { "$ref": "#/definitions/nonNegativeInteger" },
			"minProperties": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },
			"required": { "$ref": "#/definitions/stringArray" },
			"additionalProperties": { "$ref": "#" },
			"definitions": {
				"type": "object",
				"additionalProperties": { "$ref": "#" },
				"default": {}
			},
			"properties": {
				"type": "object",
				"additionalProperties": { "$ref": "#" },
				"default": {}
			},
			"patternProperties": {
				"type": "object",
				"additionalProperties": { "$ref": "#" },
				"propertyNames": { "format": "regex" },
				"default": {}
			},
			"dependencies": {
				"type": "object",
				"additionalProperties": { "anyOf": [{ "$ref": "#" }, { "$ref": "#/definitions/stringArray" }] }
			},
			"propertyNames": { "$ref": "#" },
			"const": true,
			"enum": {
				"type": "array",
				"items": true,
				"minItems": 1,
				"uniqueItems": true
			},
			"type": { "anyOf": [{ "$ref": "#/definitions/simpleTypes" }, {
				"type": "array",
				"items": { "$ref": "#/definitions/simpleTypes" },
				"minItems": 1,
				"uniqueItems": true
			}] },
			"format": { "type": "string" },
			"contentMediaType": { "type": "string" },
			"contentEncoding": { "type": "string" },
			"if": { "$ref": "#" },
			"then": { "$ref": "#" },
			"else": { "$ref": "#" },
			"allOf": { "$ref": "#/definitions/schemaArray" },
			"anyOf": { "$ref": "#/definitions/schemaArray" },
			"oneOf": { "$ref": "#/definitions/schemaArray" },
			"not": { "$ref": "#" }
		},
		"default": true
	};
}) });

//#endregion
//#region node_modules/ajv/dist/ajv.js
var require_ajv = /* @__PURE__ */ __commonJS$2({ "node_modules/ajv/dist/ajv.js": ((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = exports.Ajv = void 0;
	const core_1 = require_core$1();
	const draft7_1 = require_draft7();
	const discriminator_1 = require_discriminator();
	const draft7MetaSchema = require_json_schema_draft_07();
	const META_SUPPORT_DATA = ["/properties"];
	const META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
	var Ajv$1 = class extends core_1.default {
		_addVocabularies() {
			super._addVocabularies();
			draft7_1.default.forEach((v) => this.addVocabulary(v));
			if (this.opts.discriminator) this.addKeyword(discriminator_1.default);
		}
		_addDefaultMetaSchema() {
			super._addDefaultMetaSchema();
			if (!this.opts.meta) return;
			const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
			this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
			this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
		}
		defaultMeta() {
			return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
		}
	};
	exports.Ajv = Ajv$1;
	module.exports = exports = Ajv$1;
	module.exports.Ajv = Ajv$1;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Ajv$1;
	var validate_1 = require_validate();
	Object.defineProperty(exports, "KeywordCxt", {
		enumerable: true,
		get: function() {
			return validate_1.KeywordCxt;
		}
	});
	var codegen_1 = require_codegen();
	Object.defineProperty(exports, "_", {
		enumerable: true,
		get: function() {
			return codegen_1._;
		}
	});
	Object.defineProperty(exports, "str", {
		enumerable: true,
		get: function() {
			return codegen_1.str;
		}
	});
	Object.defineProperty(exports, "stringify", {
		enumerable: true,
		get: function() {
			return codegen_1.stringify;
		}
	});
	Object.defineProperty(exports, "nil", {
		enumerable: true,
		get: function() {
			return codegen_1.nil;
		}
	});
	Object.defineProperty(exports, "Name", {
		enumerable: true,
		get: function() {
			return codegen_1.Name;
		}
	});
	Object.defineProperty(exports, "CodeGen", {
		enumerable: true,
		get: function() {
			return codegen_1.CodeGen;
		}
	});
	var validation_error_1 = require_validation_error();
	Object.defineProperty(exports, "ValidationError", {
		enumerable: true,
		get: function() {
			return validation_error_1.default;
		}
	});
	var ref_error_1 = require_ref_error();
	Object.defineProperty(exports, "MissingRefError", {
		enumerable: true,
		get: function() {
			return ref_error_1.default;
		}
	});
}) });

//#endregion
//#region src/hash.ts
var import_ajv = /* @__PURE__ */ __toESM$2(require_ajv());
const FNV_OFFSET_1 = 14695981039346656037n;
const FNV_OFFSET_2 = 9521211207457086692n;
const FNV_PRIME = 1099511628211n;
const MASK_64 = (1n << 64n) - 1n;
const hash64 = (value, offset) => {
	let hash = offset;
	for (let i = 0; i < value.length; i += 1) {
		hash ^= BigInt(value.charCodeAt(i));
		hash = hash * FNV_PRIME & MASK_64;
	}
	return hash;
};
const toHex64 = (value) => value.toString(16).padStart(16, "0");
const hash128 = (...data) => {
	const input = JSON.stringify(data);
	const high = hash64(input, FNV_OFFSET_1);
	const low = hash64(input, FNV_OFFSET_2);
	return `${toHex64(high)}${toHex64(low)}`;
};

//#endregion
//#region src/schemas.ts
const string = { type: "string" };
const object = (properties, extra = {}) => ({
	type: "object",
	properties,
	required: Object.keys(properties),
	...extra
});
function hashData(data, schemaHash) {
	if (schemaHash === "0" && data != "{}") throw new Error("schema hash is 0 but data is not empty");
	return hash128(String(schemaHash), data);
}
function NoteData(schema$1, data) {
	return {
		schemaHash: hashData(schema$1.data, schema$1.schemaHash),
		data: JSON.stringify(data)
	};
}
const top = {
	schemaHash: "0",
	data: "{}"
};
const script_schema = NoteData(top, object({
	title: string,
	code: string
}, { title: "script_schema" }));
const schemas = [script_schema];

//#endregion
//#region src/index.ts
const JsonNotes = table({
	name: "note",
	public: true
}, {
	id: t.u64().primaryKey(),
	schemaId: t.u64(),
	data: t.string(),
	hash: t.string().unique()
});
const spacetimedb = schema(JsonNotes);
const ajv = new import_ajv.Ajv();
const add_note = spacetimedb.reducer("add_note", {
	schemaId: t.u128(),
	data: t.string()
}, (ctx, { schemaId, data }) => {
	const schemaRow = ctx.db.note.id.find(schemaId);
	if (!schemaRow) throw new SenderError("Schema not found");
	const validate = ajv.compile(JSON.parse(schemaRow.data));
	if (!validate(JSON.parse(data))) throw new SenderError(validate.errors?.map((e) => e.message).join(", ") || "Invalid data");
	let id = ctx.db.note.count();
	const hash = hashData(data, String(schemaRow.hash));
	if (ctx.db.note.hash.find(hash)) return;
	ctx.db.note.insert({
		id,
		schemaId,
		data,
		hash
	});
});
const setup = spacetimedb.reducer("setup", {}, (ctx) => {
	try {
		ctx.db.note.insert({
			id: 0n,
			schemaId: 0n,
			data: "{}",
			hash: hashData("{}", "0")
		});
	} catch {}
	for (const note of schemas) {
		const schemaRow = ctx.db.note.hash.find(note.schemaHash);
		if (!schemaRow) throw new Error("Schema not found");
		add_note(ctx, {
			schemaId: schemaRow.id,
			data: note.data
		});
	}
});
spacetimedb.init(setup);

//#endregion
export { spacetimedb };
//# debugId=3e0de766-590b-4be2-80d7-3e8cb510f164
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVuZGxlLmpzIiwibmFtZXMiOlsiX19jcmVhdGUiLCJfX2RlZlByb3AiLCJfX2dldE93blByb3BEZXNjIiwiX19nZXRPd25Qcm9wTmFtZXMiLCJfX2dldFByb3RvT2YiLCJfX2hhc093blByb3AiLCJfX2NvbW1vbkpTIiwiX19jb3B5UHJvcHMiLCJfX3RvRVNNIiwic3RyIiwicGFyc2UiLCJpbml0IiwiRSIsIl8iLCJleHBvcnRzIiwiI3ZpZXciLCIjb2Zmc2V0IiwiI2Vuc3VyZSIsIiNidWZmZXIiLCIjZXhwYW5kQnVmZmVyIiwic3RyIiwiYW5kIiwiI2Zyb20iLCIjdG8iLCIjYm9keSIsIiNpbm5lciIsInVyaSIsIiNpZGVudGl0eSIsIiNzZW5kZXJBdXRoIiwiI3V1aWRDb3VudGVyIiwiI2ZpbmFsaXphdGlvblJlZ2lzdHJ5IiwiI2lkIiwiI2RldGFjaCIsIl9hIiwibmFtZXMiLCJjb2RlXzEiLCJfYSIsIl9iIiwiZGVmIiwiY29kZV8xIiwibmFtZXMiLCJfYSIsIl9iIiwiY29kZWdlbl8xIiwiY29kZV8xIiwic2NoZW1hIiwic3RyIiwiY29kZWdlbl8xIiwiY29kZWdlbl8xIiwidXRpbF8xIiwibmFtZXNfMSIsImVycm9yc18xIiwiY29kZWdlbl8xIiwibmFtZXNfMSIsInNjaGVtYSIsInNjaGVtYSIsIl9hIiwicnVsZXNfMSIsImFwcGxpY2FiaWxpdHlfMSIsImVycm9yc18xIiwiY29kZWdlbl8xIiwidXRpbF8xIiwic2NoZW1hIiwidCIsImNvZGVnZW5fMSIsInV0aWxfMSIsImNvZGVnZW5fMSIsInV0aWxfMSIsIm5hbWVzXzEiLCJ1dGlsXzIiLCJzY2hlbWEiLCJjb2RlZ2VuXzEiLCJuYW1lc18xIiwiY29kZV8xIiwiZXJyb3JzXzEiLCJkZWYiLCJzY2hlbWEiLCJfYSIsImVycm9ycyIsImNvZGVnZW5fMSIsInV0aWxfMSIsInNjaGVtYSIsImVxdWFsIiwidHJhdmVyc2UiLCJzY2hlbWEiLCJzdHIiLCJ1dGlsXzEiLCJlcXVhbCIsInNjaGVtYSIsIm5vcm1hbGl6ZSIsImRhdGFUeXBlXzEiLCJjb2RlZ2VuXzEiLCJuYW1lc18xIiwicmVzb2x2ZV8xIiwidXRpbF8xIiwic2NoZW1hIiwiVmFsaWRhdGlvbkVycm9yIiwidCIsImRlZiIsImVycm9ycyIsInJlc29sdmVfMSIsImNvZGVnZW5fMSIsInZhbGlkYXRpb25fZXJyb3JfMSIsIm5hbWVzXzEiLCJyZXNvbHZlXzEiLCJ1dGlsXzEiLCJ2YWxpZGF0ZV8xIiwiX2EiLCJzY2hlbWEiLCJyZXNvbHZlIiwiaXNVVUlEIiwiaXNJUHY0Iiwibm9uU2ltcGxlRG9tYWluIiwibm9ybWFsaXplSVB2NiIsInN0ciIsInJlbW92ZURvdFNlZ21lbnRzIiwibm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmciLCJyZWNvbXBvc2VBdXRob3JpdHkiLCJnZXRTY2hlbWVIYW5kbGVyIiwiU0NIRU1FUyIsInVyaSIsImVxdWFsIiwidmFsaWRhdGVfMSIsImNvZGVnZW5fMSIsInZhbGlkYXRpb25fZXJyb3JfMSIsInJlZl9lcnJvcl8xIiwiY29tcGlsZV8xIiwiZGF0YVR5cGVfMSIsInV0aWxfMSIsInN0ciIsIl9hIiwiX2IiLCJfYyIsIm9wdGltaXplIiwiQWp2Iiwic2NoZW1hIiwiZGVmIiwidCIsImZvcm1hdCIsImVycm9ycyIsInNjaGVtYXMiLCJkZWYiLCJyZWZfZXJyb3JfMSIsImNvZGVfMSIsImNvZGVnZW5fMSIsIm5hbWVzXzEiLCJjb21waWxlXzEiLCJ1dGlsXzEiLCJkZWYiLCJfYSIsImNvZGVnZW5fMSIsImRlZiIsImNvZGVnZW5fMSIsImRlZiIsInN0ciIsImNvZGVnZW5fMSIsInV0aWxfMSIsImRlZiIsImNvZGVfMSIsImNvZGVnZW5fMSIsImRlZiIsInNjaGVtYSIsImNvZGVnZW5fMSIsImRlZiIsImNvZGVfMSIsImNvZGVnZW5fMSIsInV0aWxfMSIsImRlZiIsInNjaGVtYSIsImNvZGVnZW5fMSIsImRlZiIsImNvZGVnZW5fMSIsInV0aWxfMSIsImVxdWFsXzEiLCJkZWYiLCJzY2hlbWEiLCJ0IiwiY29kZWdlbl8xIiwidXRpbF8xIiwiZXF1YWxfMSIsImRlZiIsInNjaGVtYSIsImNvZGVnZW5fMSIsInV0aWxfMSIsImRlZiIsInNjaGVtYSIsImNvZGVnZW5fMSIsInV0aWxfMSIsImRlZiIsInNjaGVtYSIsImNvZGVnZW5fMSIsInV0aWxfMSIsImNvZGVfMSIsImRlZiIsInNjaGVtYSIsIml0ZW1zXzEiLCJkZWYiLCJjb2RlZ2VuXzEiLCJ1dGlsXzEiLCJjb2RlXzEiLCJhZGRpdGlvbmFsSXRlbXNfMSIsImRlZiIsInNjaGVtYSIsImNvZGVnZW5fMSIsInV0aWxfMSIsImRlZiIsInNjaGVtYSIsImNvZGVnZW5fMSIsInV0aWxfMSIsImNvZGVfMSIsImRlZiIsInNjaGVtYSIsImNvZGVnZW5fMSIsInV0aWxfMSIsImRlZiIsInNjaGVtYSIsImNvZGVfMSIsImNvZGVnZW5fMSIsInV0aWxfMSIsImRlZiIsInNjaGVtYSIsImVycm9ycyIsInZhbGlkYXRlXzEiLCJjb2RlXzEiLCJ1dGlsXzEiLCJhZGRpdGlvbmFsUHJvcGVydGllc18xIiwiZGVmIiwic2NoZW1hIiwiY29kZWdlbl8xIiwidXRpbF8xIiwiZGVmIiwic2NoZW1hIiwidXRpbF8xIiwiZGVmIiwic2NoZW1hIiwiZGVmIiwiY29kZWdlbl8xIiwidXRpbF8xIiwiZGVmIiwic2NoZW1hIiwidXRpbF8xIiwiZGVmIiwic2NoZW1hIiwiY29kZWdlbl8xIiwidXRpbF8xIiwiZGVmIiwic2NoZW1hIiwidXRpbF8xIiwiZGVmIiwiY29kZWdlbl8xIiwiZGVmIiwiZm9ybWF0Iiwic2NoZW1hIiwiY29yZV8xIiwiY29kZWdlbl8xIiwicmVmX2Vycm9yXzEiLCJzY2hlbWEiLCJfYSIsIkFqdiIsInNjaGVtYSIsInRvcDogTm90ZURhdGEiLCJzY2hlbWFzIDogTm90ZURhdGFbXSIsIkFqdiJdLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9oZWFkZXJzLXBvbHlmaWxsL2xpYi9pbmRleC5tanMiLCJub2RlX21vZHVsZXMvc3BhY2V0aW1lZGIvZGlzdC9zZXJ2ZXIvaW5kZXgubWpzIiwibm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvY29kZWdlbi9jb2RlLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvY29kZWdlbi9zY29wZS5qcyIsIm5vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL2NvZGVnZW4vaW5kZXguanMiLCJub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvbmFtZXMuanMiLCJub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS9lcnJvcnMuanMiLCJub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS92YWxpZGF0ZS9ib29sU2NoZW1hLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvcnVsZXMuanMiLCJub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS92YWxpZGF0ZS9hcHBsaWNhYmlsaXR5LmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvdmFsaWRhdGUvZGF0YVR5cGUuanMiLCJub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS92YWxpZGF0ZS9kZWZhdWx0cy5qcyIsIm5vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3ZhbGlkYXRlL2tleXdvcmQuanMiLCJub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS92YWxpZGF0ZS9zdWJzY2hlbWEuanMiLCJub2RlX21vZHVsZXMvZmFzdC1kZWVwLWVxdWFsL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2pzb24tc2NoZW1hLXRyYXZlcnNlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvcmVzb2x2ZS5qcyIsIm5vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3ZhbGlkYXRlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3J1bnRpbWUvdmFsaWRhdGlvbl9lcnJvci5qcyIsIm5vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3JlZl9lcnJvci5qcyIsIm5vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3JlZnMvZGF0YS5qc29uIiwibm9kZV9tb2R1bGVzL2Zhc3QtdXJpL2xpYi91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9mYXN0LXVyaS9saWIvc2NoZW1lcy5qcyIsIm5vZGVfbW9kdWxlcy9mYXN0LXVyaS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hanYvZGlzdC9ydW50aW1lL3VyaS5qcyIsIm5vZGVfbW9kdWxlcy9hanYvZGlzdC9jb3JlLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9jb3JlL2lkLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9jb3JlL3JlZi5qcyIsIm5vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvY29yZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9saW1pdE51bWJlci5qcyIsIm5vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9tdWx0aXBsZU9mLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3J1bnRpbWUvdWNzMmxlbmd0aC5qcyIsIm5vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9saW1pdExlbmd0aC5qcyIsIm5vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9wYXR0ZXJuLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL2xpbWl0UHJvcGVydGllcy5qcyIsIm5vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9yZXF1aXJlZC5qcyIsIm5vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9saW1pdEl0ZW1zLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3J1bnRpbWUvZXF1YWwuanMiLCJub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vdW5pcXVlSXRlbXMuanMiLCJub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vY29uc3QuanMiLCJub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vZW51bS5qcyIsIm5vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9hZGRpdGlvbmFsSXRlbXMuanMiLCJub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvaXRlbXMuanMiLCJub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvcHJlZml4SXRlbXMuanMiLCJub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvaXRlbXMyMDIwLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2NvbnRhaW5zLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2RlcGVuZGVuY2llcy5qcyIsIm5vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9wcm9wZXJ0eU5hbWVzLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2FkZGl0aW9uYWxQcm9wZXJ0aWVzLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL3Byb3BlcnRpZXMuanMiLCJub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvcGF0dGVyblByb3BlcnRpZXMuanMiLCJub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3Ivbm90LmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2FueU9mLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL29uZU9mLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2FsbE9mLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2lmLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL3RoZW5FbHNlLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9mb3JtYXQvZm9ybWF0LmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9mb3JtYXQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL21ldGFkYXRhLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9kcmFmdDcuanMiLCJub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2Rpc2NyaW1pbmF0b3IvdHlwZXMuanMiLCJub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2Rpc2NyaW1pbmF0b3IvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYWp2L2Rpc3QvcmVmcy9qc29uLXNjaGVtYS1kcmFmdC0wNy5qc29uIiwibm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2Fqdi5qcyIsInNyYy9oYXNoLnRzIiwic3JjL3NjaGVtYXMudHMiLCJzcmMvaW5kZXgudHMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2NvbW1vbkpTID0gKGNiLCBtb2QpID0+IGZ1bmN0aW9uIF9fcmVxdWlyZSgpIHtcbiAgcmV0dXJuIG1vZCB8fCAoMCwgY2JbX19nZXRPd25Qcm9wTmFtZXMoY2IpWzBdXSkoKG1vZCA9IHsgZXhwb3J0czoge30gfSkuZXhwb3J0cywgbW9kKSwgbW9kLmV4cG9ydHM7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9FU00gPSAobW9kLCBpc05vZGVNb2RlLCB0YXJnZXQpID0+ICh0YXJnZXQgPSBtb2QgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2QpKSA6IHt9LCBfX2NvcHlQcm9wcyhcbiAgLy8gSWYgdGhlIGltcG9ydGVyIGlzIGluIG5vZGUgY29tcGF0aWJpbGl0eSBtb2RlIG9yIHRoaXMgaXMgbm90IGFuIEVTTVxuICAvLyBmaWxlIHRoYXQgaGFzIGJlZW4gY29udmVydGVkIHRvIGEgQ29tbW9uSlMgZmlsZSB1c2luZyBhIEJhYmVsLVxuICAvLyBjb21wYXRpYmxlIHRyYW5zZm9ybSAoaS5lLiBcIl9fZXNNb2R1bGVcIiBoYXMgbm90IGJlZW4gc2V0KSwgdGhlbiBzZXRcbiAgLy8gXCJkZWZhdWx0XCIgdG8gdGhlIENvbW1vbkpTIFwibW9kdWxlLmV4cG9ydHNcIiBmb3Igbm9kZSBjb21wYXRpYmlsaXR5LlxuICBpc05vZGVNb2RlIHx8ICFtb2QgfHwgIW1vZC5fX2VzTW9kdWxlID8gX19kZWZQcm9wKHRhcmdldCwgXCJkZWZhdWx0XCIsIHsgdmFsdWU6IG1vZCwgZW51bWVyYWJsZTogdHJ1ZSB9KSA6IHRhcmdldCxcbiAgbW9kXG4pKTtcblxuLy8gbm9kZV9tb2R1bGVzL3NldC1jb29raWUtcGFyc2VyL2xpYi9zZXQtY29va2llLmpzXG52YXIgcmVxdWlyZV9zZXRfY29va2llID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL3NldC1jb29raWUtcGFyc2VyL2xpYi9zZXQtY29va2llLmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGRlZmF1bHRQYXJzZU9wdGlvbnMgPSB7XG4gICAgICBkZWNvZGVWYWx1ZXM6IHRydWUsXG4gICAgICBtYXA6IGZhbHNlLFxuICAgICAgc2lsZW50OiBmYWxzZVxuICAgIH07XG4gICAgZnVuY3Rpb24gaXNOb25FbXB0eVN0cmluZyhzdHIpIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygc3RyID09PSBcInN0cmluZ1wiICYmICEhc3RyLnRyaW0oKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VTdHJpbmcoc2V0Q29va2llVmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBwYXJ0cyA9IHNldENvb2tpZVZhbHVlLnNwbGl0KFwiO1wiKS5maWx0ZXIoaXNOb25FbXB0eVN0cmluZyk7XG4gICAgICB2YXIgbmFtZVZhbHVlUGFpclN0ciA9IHBhcnRzLnNoaWZ0KCk7XG4gICAgICB2YXIgcGFyc2VkID0gcGFyc2VOYW1lVmFsdWVQYWlyKG5hbWVWYWx1ZVBhaXJTdHIpO1xuICAgICAgdmFyIG5hbWUgPSBwYXJzZWQubmFtZTtcbiAgICAgIHZhciB2YWx1ZSA9IHBhcnNlZC52YWx1ZTtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zID8gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFBhcnNlT3B0aW9ucywgb3B0aW9ucykgOiBkZWZhdWx0UGFyc2VPcHRpb25zO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFsdWUgPSBvcHRpb25zLmRlY29kZVZhbHVlcyA/IGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcInNldC1jb29raWUtcGFyc2VyIGVuY291bnRlcmVkIGFuIGVycm9yIHdoaWxlIGRlY29kaW5nIGEgY29va2llIHdpdGggdmFsdWUgJ1wiICsgdmFsdWUgKyBcIicuIFNldCBvcHRpb25zLmRlY29kZVZhbHVlcyB0byBmYWxzZSB0byBkaXNhYmxlIHRoaXMgZmVhdHVyZS5cIixcbiAgICAgICAgICBlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB2YXIgY29va2llID0ge1xuICAgICAgICBuYW1lLFxuICAgICAgICB2YWx1ZVxuICAgICAgfTtcbiAgICAgIHBhcnRzLmZvckVhY2goZnVuY3Rpb24ocGFydCkge1xuICAgICAgICB2YXIgc2lkZXMgPSBwYXJ0LnNwbGl0KFwiPVwiKTtcbiAgICAgICAgdmFyIGtleSA9IHNpZGVzLnNoaWZ0KCkudHJpbUxlZnQoKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB2YXIgdmFsdWUyID0gc2lkZXMuam9pbihcIj1cIik7XG4gICAgICAgIGlmIChrZXkgPT09IFwiZXhwaXJlc1wiKSB7XG4gICAgICAgICAgY29va2llLmV4cGlyZXMgPSBuZXcgRGF0ZSh2YWx1ZTIpO1xuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJtYXgtYWdlXCIpIHtcbiAgICAgICAgICBjb29raWUubWF4QWdlID0gcGFyc2VJbnQodmFsdWUyLCAxMCk7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcInNlY3VyZVwiKSB7XG4gICAgICAgICAgY29va2llLnNlY3VyZSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcImh0dHBvbmx5XCIpIHtcbiAgICAgICAgICBjb29raWUuaHR0cE9ubHkgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJzYW1lc2l0ZVwiKSB7XG4gICAgICAgICAgY29va2llLnNhbWVTaXRlID0gdmFsdWUyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvb2tpZVtrZXldID0gdmFsdWUyO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjb29raWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlTmFtZVZhbHVlUGFpcihuYW1lVmFsdWVQYWlyU3RyKSB7XG4gICAgICB2YXIgbmFtZSA9IFwiXCI7XG4gICAgICB2YXIgdmFsdWUgPSBcIlwiO1xuICAgICAgdmFyIG5hbWVWYWx1ZUFyciA9IG5hbWVWYWx1ZVBhaXJTdHIuc3BsaXQoXCI9XCIpO1xuICAgICAgaWYgKG5hbWVWYWx1ZUFyci5sZW5ndGggPiAxKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lVmFsdWVBcnIuc2hpZnQoKTtcbiAgICAgICAgdmFsdWUgPSBuYW1lVmFsdWVBcnIuam9pbihcIj1cIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IG5hbWVWYWx1ZVBhaXJTdHI7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBuYW1lLCB2YWx1ZSB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZShpbnB1dCwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0UGFyc2VPcHRpb25zLCBvcHRpb25zKSA6IGRlZmF1bHRQYXJzZU9wdGlvbnM7XG4gICAgICBpZiAoIWlucHV0KSB7XG4gICAgICAgIGlmICghb3B0aW9ucy5tYXApIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaW5wdXQuaGVhZGVycykge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0LmhlYWRlcnMuZ2V0U2V0Q29va2llID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBpbnB1dCA9IGlucHV0LmhlYWRlcnMuZ2V0U2V0Q29va2llKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXQuaGVhZGVyc1tcInNldC1jb29raWVcIl0pIHtcbiAgICAgICAgICBpbnB1dCA9IGlucHV0LmhlYWRlcnNbXCJzZXQtY29va2llXCJdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBzY2ggPSBpbnB1dC5oZWFkZXJzW09iamVjdC5rZXlzKGlucHV0LmhlYWRlcnMpLmZpbmQoZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4ga2V5LnRvTG93ZXJDYXNlKCkgPT09IFwic2V0LWNvb2tpZVwiO1xuICAgICAgICAgIH0pXTtcbiAgICAgICAgICBpZiAoIXNjaCAmJiBpbnB1dC5oZWFkZXJzLmNvb2tpZSAmJiAhb3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgXCJXYXJuaW5nOiBzZXQtY29va2llLXBhcnNlciBhcHBlYXJzIHRvIGhhdmUgYmVlbiBjYWxsZWQgb24gYSByZXF1ZXN0IG9iamVjdC4gSXQgaXMgZGVzaWduZWQgdG8gcGFyc2UgU2V0LUNvb2tpZSBoZWFkZXJzIGZyb20gcmVzcG9uc2VzLCBub3QgQ29va2llIGhlYWRlcnMgZnJvbSByZXF1ZXN0cy4gU2V0IHRoZSBvcHRpb24ge3NpbGVudDogdHJ1ZX0gdG8gc3VwcHJlc3MgdGhpcyB3YXJuaW5nLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbnB1dCA9IHNjaDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICBpbnB1dCA9IFtpbnB1dF07XG4gICAgICB9XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyA/IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRQYXJzZU9wdGlvbnMsIG9wdGlvbnMpIDogZGVmYXVsdFBhcnNlT3B0aW9ucztcbiAgICAgIGlmICghb3B0aW9ucy5tYXApIHtcbiAgICAgICAgcmV0dXJuIGlucHV0LmZpbHRlcihpc05vbkVtcHR5U3RyaW5nKS5tYXAoZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlU3RyaW5nKHN0ciwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGNvb2tpZXMgPSB7fTtcbiAgICAgICAgcmV0dXJuIGlucHV0LmZpbHRlcihpc05vbkVtcHR5U3RyaW5nKS5yZWR1Y2UoZnVuY3Rpb24oY29va2llczIsIHN0cikge1xuICAgICAgICAgIHZhciBjb29raWUgPSBwYXJzZVN0cmluZyhzdHIsIG9wdGlvbnMpO1xuICAgICAgICAgIGNvb2tpZXMyW2Nvb2tpZS5uYW1lXSA9IGNvb2tpZTtcbiAgICAgICAgICByZXR1cm4gY29va2llczI7XG4gICAgICAgIH0sIGNvb2tpZXMpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzcGxpdENvb2tpZXNTdHJpbmcyKGNvb2tpZXNTdHJpbmcpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvb2tpZXNTdHJpbmcpKSB7XG4gICAgICAgIHJldHVybiBjb29raWVzU3RyaW5nO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBjb29raWVzU3RyaW5nICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBjb29raWVzU3RyaW5ncyA9IFtdO1xuICAgICAgdmFyIHBvcyA9IDA7XG4gICAgICB2YXIgc3RhcnQ7XG4gICAgICB2YXIgY2g7XG4gICAgICB2YXIgbGFzdENvbW1hO1xuICAgICAgdmFyIG5leHRTdGFydDtcbiAgICAgIHZhciBjb29raWVzU2VwYXJhdG9yRm91bmQ7XG4gICAgICBmdW5jdGlvbiBza2lwV2hpdGVzcGFjZSgpIHtcbiAgICAgICAgd2hpbGUgKHBvcyA8IGNvb2tpZXNTdHJpbmcubGVuZ3RoICYmIC9cXHMvLnRlc3QoY29va2llc1N0cmluZy5jaGFyQXQocG9zKSkpIHtcbiAgICAgICAgICBwb3MgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9zIDwgY29va2llc1N0cmluZy5sZW5ndGg7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBub3RTcGVjaWFsQ2hhcigpIHtcbiAgICAgICAgY2ggPSBjb29raWVzU3RyaW5nLmNoYXJBdChwb3MpO1xuICAgICAgICByZXR1cm4gY2ggIT09IFwiPVwiICYmIGNoICE9PSBcIjtcIiAmJiBjaCAhPT0gXCIsXCI7XG4gICAgICB9XG4gICAgICB3aGlsZSAocG9zIDwgY29va2llc1N0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgc3RhcnQgPSBwb3M7XG4gICAgICAgIGNvb2tpZXNTZXBhcmF0b3JGb3VuZCA9IGZhbHNlO1xuICAgICAgICB3aGlsZSAoc2tpcFdoaXRlc3BhY2UoKSkge1xuICAgICAgICAgIGNoID0gY29va2llc1N0cmluZy5jaGFyQXQocG9zKTtcbiAgICAgICAgICBpZiAoY2ggPT09IFwiLFwiKSB7XG4gICAgICAgICAgICBsYXN0Q29tbWEgPSBwb3M7XG4gICAgICAgICAgICBwb3MgKz0gMTtcbiAgICAgICAgICAgIHNraXBXaGl0ZXNwYWNlKCk7XG4gICAgICAgICAgICBuZXh0U3RhcnQgPSBwb3M7XG4gICAgICAgICAgICB3aGlsZSAocG9zIDwgY29va2llc1N0cmluZy5sZW5ndGggJiYgbm90U3BlY2lhbENoYXIoKSkge1xuICAgICAgICAgICAgICBwb3MgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb3MgPCBjb29raWVzU3RyaW5nLmxlbmd0aCAmJiBjb29raWVzU3RyaW5nLmNoYXJBdChwb3MpID09PSBcIj1cIikge1xuICAgICAgICAgICAgICBjb29raWVzU2VwYXJhdG9yRm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICBwb3MgPSBuZXh0U3RhcnQ7XG4gICAgICAgICAgICAgIGNvb2tpZXNTdHJpbmdzLnB1c2goY29va2llc1N0cmluZy5zdWJzdHJpbmcoc3RhcnQsIGxhc3RDb21tYSkpO1xuICAgICAgICAgICAgICBzdGFydCA9IHBvcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBvcyA9IGxhc3RDb21tYSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvcyArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvb2tpZXNTZXBhcmF0b3JGb3VuZCB8fCBwb3MgPj0gY29va2llc1N0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgICBjb29raWVzU3RyaW5ncy5wdXNoKGNvb2tpZXNTdHJpbmcuc3Vic3RyaW5nKHN0YXJ0LCBjb29raWVzU3RyaW5nLmxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY29va2llc1N0cmluZ3M7XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0gcGFyc2U7XG4gICAgbW9kdWxlLmV4cG9ydHMucGFyc2UgPSBwYXJzZTtcbiAgICBtb2R1bGUuZXhwb3J0cy5wYXJzZVN0cmluZyA9IHBhcnNlU3RyaW5nO1xuICAgIG1vZHVsZS5leHBvcnRzLnNwbGl0Q29va2llc1N0cmluZyA9IHNwbGl0Q29va2llc1N0cmluZzI7XG4gIH1cbn0pO1xuXG4vLyBzcmMvSGVhZGVycy50c1xudmFyIGltcG9ydF9zZXRfY29va2llX3BhcnNlciA9IF9fdG9FU00ocmVxdWlyZV9zZXRfY29va2llKCkpO1xuXG4vLyBzcmMvdXRpbHMvbm9ybWFsaXplSGVhZGVyTmFtZS50c1xudmFyIEhFQURFUlNfSU5WQUxJRF9DSEFSQUNURVJTID0gL1teYS16MC05XFwtIyQlJicqKy5eX2B8fl0vaTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZUhlYWRlck5hbWUobmFtZSkge1xuICBpZiAoSEVBREVSU19JTlZBTElEX0NIQVJBQ1RFUlMudGVzdChuYW1lKSB8fCBuYW1lLnRyaW0oKSA9PT0gXCJcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGNoYXJhY3RlciBpbiBoZWFkZXIgZmllbGQgbmFtZVwiKTtcbiAgfVxuICByZXR1cm4gbmFtZS50cmltKCkudG9Mb3dlckNhc2UoKTtcbn1cblxuLy8gc3JjL3V0aWxzL25vcm1hbGl6ZUhlYWRlclZhbHVlLnRzXG52YXIgY2hhckNvZGVzVG9SZW1vdmUgPSBbXG4gIFN0cmluZy5mcm9tQ2hhckNvZGUoMTApLFxuICBTdHJpbmcuZnJvbUNoYXJDb2RlKDEzKSxcbiAgU3RyaW5nLmZyb21DaGFyQ29kZSg5KSxcbiAgU3RyaW5nLmZyb21DaGFyQ29kZSgzMilcbl07XG52YXIgSEVBREVSX1ZBTFVFX1JFTU9WRV9SRUdFWFAgPSBuZXcgUmVnRXhwKFxuICBgKF5bJHtjaGFyQ29kZXNUb1JlbW92ZS5qb2luKFwiXCIpfV18JFske2NoYXJDb2Rlc1RvUmVtb3ZlLmpvaW4oXCJcIil9XSlgLFxuICBcImdcIlxuKTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZUhlYWRlclZhbHVlKHZhbHVlKSB7XG4gIGNvbnN0IG5leHRWYWx1ZSA9IHZhbHVlLnJlcGxhY2UoSEVBREVSX1ZBTFVFX1JFTU9WRV9SRUdFWFAsIFwiXCIpO1xuICByZXR1cm4gbmV4dFZhbHVlO1xufVxuXG4vLyBzcmMvdXRpbHMvaXNWYWxpZEhlYWRlck5hbWUudHNcbmZ1bmN0aW9uIGlzVmFsaWRIZWFkZXJOYW1lKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hhcmFjdGVyID0gdmFsdWUuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoY2hhcmFjdGVyID4gMTI3IHx8ICFpc1Rva2VuKGNoYXJhY3RlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBpc1Rva2VuKHZhbHVlKSB7XG4gIHJldHVybiAhW1xuICAgIDEyNyxcbiAgICAzMixcbiAgICBcIihcIixcbiAgICBcIilcIixcbiAgICBcIjxcIixcbiAgICBcIj5cIixcbiAgICBcIkBcIixcbiAgICBcIixcIixcbiAgICBcIjtcIixcbiAgICBcIjpcIixcbiAgICBcIlxcXFxcIixcbiAgICAnXCInLFxuICAgIFwiL1wiLFxuICAgIFwiW1wiLFxuICAgIFwiXVwiLFxuICAgIFwiP1wiLFxuICAgIFwiPVwiLFxuICAgIFwie1wiLFxuICAgIFwifVwiXG4gIF0uaW5jbHVkZXModmFsdWUpO1xufVxuXG4vLyBzcmMvdXRpbHMvaXNWYWxpZEhlYWRlclZhbHVlLnRzXG5mdW5jdGlvbiBpc1ZhbGlkSGVhZGVyVmFsdWUodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodmFsdWUudHJpbSgpICE9PSB2YWx1ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hhcmFjdGVyID0gdmFsdWUuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoXG4gICAgICAvLyBOVUwuXG4gICAgICBjaGFyYWN0ZXIgPT09IDAgfHwgLy8gSFRUUCBuZXdsaW5lIGJ5dGVzLlxuICAgICAgY2hhcmFjdGVyID09PSAxMCB8fCBjaGFyYWN0ZXIgPT09IDEzXG4gICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyBzcmMvSGVhZGVycy50c1xudmFyIE5PUk1BTElaRURfSEVBREVSUyA9IFN5bWJvbChcIm5vcm1hbGl6ZWRIZWFkZXJzXCIpO1xudmFyIFJBV19IRUFERVJfTkFNRVMgPSBTeW1ib2woXCJyYXdIZWFkZXJOYW1lc1wiKTtcbnZhciBIRUFERVJfVkFMVUVfREVMSU1JVEVSID0gXCIsIFwiO1xudmFyIF9hLCBfYiwgX2M7XG52YXIgSGVhZGVycyA9IGNsYXNzIF9IZWFkZXJzIHtcbiAgY29uc3RydWN0b3IoaW5pdCkge1xuICAgIC8vIE5vcm1hbGl6ZWQgaGVhZGVyIHtcIm5hbWVcIjpcImEsIGJcIn0gc3RvcmFnZS5cbiAgICB0aGlzW19hXSA9IHt9O1xuICAgIC8vIEtlZXBzIHRoZSBtYXBwaW5nIGJldHdlZW4gdGhlIHJhdyBoZWFkZXIgbmFtZVxuICAgIC8vIGFuZCB0aGUgbm9ybWFsaXplZCBoZWFkZXIgbmFtZSB0byBlYXNlIHRoZSBsb29rdXAuXG4gICAgdGhpc1tfYl0gPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXNbX2NdID0gXCJIZWFkZXJzXCI7XG4gICAgaWYgKFtcIkhlYWRlcnNcIiwgXCJIZWFkZXJzUG9seWZpbGxcIl0uaW5jbHVkZXMoaW5pdD8uY29uc3RydWN0b3IubmFtZSkgfHwgaW5pdCBpbnN0YW5jZW9mIF9IZWFkZXJzIHx8IHR5cGVvZiBnbG9iYWxUaGlzLkhlYWRlcnMgIT09IFwidW5kZWZpbmVkXCIgJiYgaW5pdCBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuSGVhZGVycykge1xuICAgICAgY29uc3QgaW5pdGlhbEhlYWRlcnMgPSBpbml0O1xuICAgICAgaW5pdGlhbEhlYWRlcnMuZm9yRWFjaCgodmFsdWUsIG5hbWUpID0+IHtcbiAgICAgICAgdGhpcy5hcHBlbmQobmFtZSwgdmFsdWUpO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGluaXQpKSB7XG4gICAgICBpbml0LmZvckVhY2goKFtuYW1lLCB2YWx1ZV0pID0+IHtcbiAgICAgICAgdGhpcy5hcHBlbmQoXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLmpvaW4oSEVBREVSX1ZBTFVFX0RFTElNSVRFUikgOiB2YWx1ZVxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChpbml0KSB7XG4gICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhpbml0KS5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gaW5pdFtuYW1lXTtcbiAgICAgICAgdGhpcy5hcHBlbmQoXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLmpvaW4oSEVBREVSX1ZBTFVFX0RFTElNSVRFUikgOiB2YWx1ZVxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIFsoX2EgPSBOT1JNQUxJWkVEX0hFQURFUlMsIF9iID0gUkFXX0hFQURFUl9OQU1FUywgX2MgPSBTeW1ib2wudG9TdHJpbmdUYWcsIFN5bWJvbC5pdGVyYXRvcildKCkge1xuICAgIHJldHVybiB0aGlzLmVudHJpZXMoKTtcbiAgfVxuICAqa2V5cygpIHtcbiAgICBmb3IgKGNvbnN0IFtuYW1lXSBvZiB0aGlzLmVudHJpZXMoKSkge1xuICAgICAgeWllbGQgbmFtZTtcbiAgICB9XG4gIH1cbiAgKnZhbHVlcygpIHtcbiAgICBmb3IgKGNvbnN0IFssIHZhbHVlXSBvZiB0aGlzLmVudHJpZXMoKSkge1xuICAgICAgeWllbGQgdmFsdWU7XG4gICAgfVxuICB9XG4gICplbnRyaWVzKCkge1xuICAgIGxldCBzb3J0ZWRLZXlzID0gT2JqZWN0LmtleXModGhpc1tOT1JNQUxJWkVEX0hFQURFUlNdKS5zb3J0KFxuICAgICAgKGEsIGIpID0+IGEubG9jYWxlQ29tcGFyZShiKVxuICAgICk7XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIHNvcnRlZEtleXMpIHtcbiAgICAgIGlmIChuYW1lID09PSBcInNldC1jb29raWVcIikge1xuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHRoaXMuZ2V0U2V0Q29va2llKCkpIHtcbiAgICAgICAgICB5aWVsZCBbbmFtZSwgdmFsdWVdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5aWVsZCBbbmFtZSwgdGhpcy5nZXQobmFtZSldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIGJvb2xlYW4gc3RhdGluZyB3aGV0aGVyIGEgYEhlYWRlcnNgIG9iamVjdCBjb250YWlucyBhIGNlcnRhaW4gaGVhZGVyLlxuICAgKi9cbiAgaGFzKG5hbWUpIHtcbiAgICBpZiAoIWlzVmFsaWRIZWFkZXJOYW1lKG5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIGhlYWRlciBuYW1lIFwiJHtuYW1lfVwiYCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzW05PUk1BTElaRURfSEVBREVSU10uaGFzT3duUHJvcGVydHkobm9ybWFsaXplSGVhZGVyTmFtZShuYW1lKSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBgQnl0ZVN0cmluZ2Agc2VxdWVuY2Ugb2YgYWxsIHRoZSB2YWx1ZXMgb2YgYSBoZWFkZXIgd2l0aCBhIGdpdmVuIG5hbWUuXG4gICAqL1xuICBnZXQobmFtZSkge1xuICAgIGlmICghaXNWYWxpZEhlYWRlck5hbWUobmFtZSkpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcihgSW52YWxpZCBoZWFkZXIgbmFtZSBcIiR7bmFtZX1cImApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpc1tOT1JNQUxJWkVEX0hFQURFUlNdW25vcm1hbGl6ZUhlYWRlck5hbWUobmFtZSldID8/IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgYSBuZXcgdmFsdWUgZm9yIGFuIGV4aXN0aW5nIGhlYWRlciBpbnNpZGUgYSBgSGVhZGVyc2Agb2JqZWN0LCBvciBhZGRzIHRoZSBoZWFkZXIgaWYgaXQgZG9lcyBub3QgYWxyZWFkeSBleGlzdC5cbiAgICovXG4gIHNldChuYW1lLCB2YWx1ZSkge1xuICAgIGlmICghaXNWYWxpZEhlYWRlck5hbWUobmFtZSkgfHwgIWlzVmFsaWRIZWFkZXJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgbm9ybWFsaXplZE5hbWUgPSBub3JtYWxpemVIZWFkZXJOYW1lKG5hbWUpO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRWYWx1ZSA9IG5vcm1hbGl6ZUhlYWRlclZhbHVlKHZhbHVlKTtcbiAgICB0aGlzW05PUk1BTElaRURfSEVBREVSU11bbm9ybWFsaXplZE5hbWVdID0gbm9ybWFsaXplSGVhZGVyVmFsdWUobm9ybWFsaXplZFZhbHVlKTtcbiAgICB0aGlzW1JBV19IRUFERVJfTkFNRVNdLnNldChub3JtYWxpemVkTmFtZSwgbmFtZSk7XG4gIH1cbiAgLyoqXG4gICAqIEFwcGVuZHMgYSBuZXcgdmFsdWUgb250byBhbiBleGlzdGluZyBoZWFkZXIgaW5zaWRlIGEgYEhlYWRlcnNgIG9iamVjdCwgb3IgYWRkcyB0aGUgaGVhZGVyIGlmIGl0IGRvZXMgbm90IGFscmVhZHkgZXhpc3QuXG4gICAqL1xuICBhcHBlbmQobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoIWlzVmFsaWRIZWFkZXJOYW1lKG5hbWUpIHx8ICFpc1ZhbGlkSGVhZGVyVmFsdWUodmFsdWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5vcm1hbGl6ZWROYW1lID0gbm9ybWFsaXplSGVhZGVyTmFtZShuYW1lKTtcbiAgICBjb25zdCBub3JtYWxpemVkVmFsdWUgPSBub3JtYWxpemVIZWFkZXJWYWx1ZSh2YWx1ZSk7XG4gICAgbGV0IHJlc29sdmVkVmFsdWUgPSB0aGlzLmhhcyhub3JtYWxpemVkTmFtZSkgPyBgJHt0aGlzLmdldChub3JtYWxpemVkTmFtZSl9LCAke25vcm1hbGl6ZWRWYWx1ZX1gIDogbm9ybWFsaXplZFZhbHVlO1xuICAgIHRoaXMuc2V0KG5hbWUsIHJlc29sdmVkVmFsdWUpO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIGEgaGVhZGVyIGZyb20gdGhlIGBIZWFkZXJzYCBvYmplY3QuXG4gICAqL1xuICBkZWxldGUobmFtZSkge1xuICAgIGlmICghaXNWYWxpZEhlYWRlck5hbWUobmFtZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmhhcyhuYW1lKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBub3JtYWxpemVkTmFtZSA9IG5vcm1hbGl6ZUhlYWRlck5hbWUobmFtZSk7XG4gICAgZGVsZXRlIHRoaXNbTk9STUFMSVpFRF9IRUFERVJTXVtub3JtYWxpemVkTmFtZV07XG4gICAgdGhpc1tSQVdfSEVBREVSX05BTUVTXS5kZWxldGUobm9ybWFsaXplZE5hbWUpO1xuICB9XG4gIC8qKlxuICAgKiBUcmF2ZXJzZXMgdGhlIGBIZWFkZXJzYCBvYmplY3QsXG4gICAqIGNhbGxpbmcgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBlYWNoIGhlYWRlci5cbiAgICovXG4gIGZvckVhY2goY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICBmb3IgKGNvbnN0IFtuYW1lLCB2YWx1ZV0gb2YgdGhpcy5lbnRyaWVzKCkpIHtcbiAgICAgIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgdmFsdWUsIG5hbWUsIHRoaXMpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBjb250YWluaW5nIHRoZSB2YWx1ZXNcbiAgICogb2YgYWxsIFNldC1Db29raWUgaGVhZGVycyBhc3NvY2lhdGVkXG4gICAqIHdpdGggYSByZXNwb25zZVxuICAgKi9cbiAgZ2V0U2V0Q29va2llKCkge1xuICAgIGNvbnN0IHNldENvb2tpZUhlYWRlciA9IHRoaXMuZ2V0KFwic2V0LWNvb2tpZVwiKTtcbiAgICBpZiAoc2V0Q29va2llSGVhZGVyID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGlmIChzZXRDb29raWVIZWFkZXIgPT09IFwiXCIpIHtcbiAgICAgIHJldHVybiBbXCJcIl07XG4gICAgfVxuICAgIHJldHVybiAoMCwgaW1wb3J0X3NldF9jb29raWVfcGFyc2VyLnNwbGl0Q29va2llc1N0cmluZykoc2V0Q29va2llSGVhZGVyKTtcbiAgfVxufTtcblxuLy8gc3JjL2dldFJhd0hlYWRlcnMudHNcbmZ1bmN0aW9uIGdldFJhd0hlYWRlcnMoaGVhZGVycykge1xuICBjb25zdCByYXdIZWFkZXJzID0ge307XG4gIGZvciAoY29uc3QgW25hbWUsIHZhbHVlXSBvZiBoZWFkZXJzLmVudHJpZXMoKSkge1xuICAgIHJhd0hlYWRlcnNbaGVhZGVyc1tSQVdfSEVBREVSX05BTUVTXS5nZXQobmFtZSldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHJhd0hlYWRlcnM7XG59XG5cbi8vIHNyYy90cmFuc2Zvcm1lcnMvaGVhZGVyc1RvTGlzdC50c1xuZnVuY3Rpb24gaGVhZGVyc1RvTGlzdChoZWFkZXJzKSB7XG4gIGNvbnN0IGhlYWRlcnNMaXN0ID0gW107XG4gIGhlYWRlcnMuZm9yRWFjaCgodmFsdWUsIG5hbWUpID0+IHtcbiAgICBjb25zdCByZXNvbHZlZFZhbHVlID0gdmFsdWUuaW5jbHVkZXMoXCIsXCIpID8gdmFsdWUuc3BsaXQoXCIsXCIpLm1hcCgodmFsdWUyKSA9PiB2YWx1ZTIudHJpbSgpKSA6IHZhbHVlO1xuICAgIGhlYWRlcnNMaXN0LnB1c2goW25hbWUsIHJlc29sdmVkVmFsdWVdKTtcbiAgfSk7XG4gIHJldHVybiBoZWFkZXJzTGlzdDtcbn1cblxuLy8gc3JjL3RyYW5zZm9ybWVycy9oZWFkZXJzVG9TdHJpbmcudHNcbmZ1bmN0aW9uIGhlYWRlcnNUb1N0cmluZyhoZWFkZXJzKSB7XG4gIGNvbnN0IGxpc3QgPSBoZWFkZXJzVG9MaXN0KGhlYWRlcnMpO1xuICBjb25zdCBsaW5lcyA9IGxpc3QubWFwKChbbmFtZSwgdmFsdWVdKSA9PiB7XG4gICAgY29uc3QgdmFsdWVzID0gW10uY29uY2F0KHZhbHVlKTtcbiAgICByZXR1cm4gYCR7bmFtZX06ICR7dmFsdWVzLmpvaW4oXCIsIFwiKX1gO1xuICB9KTtcbiAgcmV0dXJuIGxpbmVzLmpvaW4oXCJcXHJcXG5cIik7XG59XG5cbi8vIHNyYy90cmFuc2Zvcm1lcnMvaGVhZGVyc1RvT2JqZWN0LnRzXG52YXIgc2luZ2xlVmFsdWVIZWFkZXJzID0gW1widXNlci1hZ2VudFwiXTtcbmZ1bmN0aW9uIGhlYWRlcnNUb09iamVjdChoZWFkZXJzKSB7XG4gIGNvbnN0IGhlYWRlcnNPYmplY3QgPSB7fTtcbiAgaGVhZGVycy5mb3JFYWNoKCh2YWx1ZSwgbmFtZSkgPT4ge1xuICAgIGNvbnN0IGlzTXVsdGlWYWx1ZSA9ICFzaW5nbGVWYWx1ZUhlYWRlcnMuaW5jbHVkZXMobmFtZS50b0xvd2VyQ2FzZSgpKSAmJiB2YWx1ZS5pbmNsdWRlcyhcIixcIik7XG4gICAgaGVhZGVyc09iamVjdFtuYW1lXSA9IGlzTXVsdGlWYWx1ZSA/IHZhbHVlLnNwbGl0KFwiLFwiKS5tYXAoKHMpID0+IHMudHJpbSgpKSA6IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIGhlYWRlcnNPYmplY3Q7XG59XG5cbi8vIHNyYy90cmFuc2Zvcm1lcnMvc3RyaW5nVG9IZWFkZXJzLnRzXG5mdW5jdGlvbiBzdHJpbmdUb0hlYWRlcnMoc3RyKSB7XG4gIGNvbnN0IGxpbmVzID0gc3RyLnRyaW0oKS5zcGxpdCgvW1xcclxcbl0rLyk7XG4gIHJldHVybiBsaW5lcy5yZWR1Y2UoKGhlYWRlcnMsIGxpbmUpID0+IHtcbiAgICBpZiAobGluZS50cmltKCkgPT09IFwiXCIpIHtcbiAgICAgIHJldHVybiBoZWFkZXJzO1xuICAgIH1cbiAgICBjb25zdCBwYXJ0cyA9IGxpbmUuc3BsaXQoXCI6IFwiKTtcbiAgICBjb25zdCBuYW1lID0gcGFydHMuc2hpZnQoKTtcbiAgICBjb25zdCB2YWx1ZSA9IHBhcnRzLmpvaW4oXCI6IFwiKTtcbiAgICBoZWFkZXJzLmFwcGVuZChuYW1lLCB2YWx1ZSk7XG4gICAgcmV0dXJuIGhlYWRlcnM7XG4gIH0sIG5ldyBIZWFkZXJzKCkpO1xufVxuXG4vLyBzcmMvdHJhbnNmb3JtZXJzL2xpc3RUb0hlYWRlcnMudHNcbmZ1bmN0aW9uIGxpc3RUb0hlYWRlcnMobGlzdCkge1xuICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgbGlzdC5mb3JFYWNoKChbbmFtZSwgdmFsdWVdKSA9PiB7XG4gICAgY29uc3QgdmFsdWVzID0gW10uY29uY2F0KHZhbHVlKTtcbiAgICB2YWx1ZXMuZm9yRWFjaCgodmFsdWUyKSA9PiB7XG4gICAgICBoZWFkZXJzLmFwcGVuZChuYW1lLCB2YWx1ZTIpO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIGhlYWRlcnM7XG59XG5cbi8vIHNyYy90cmFuc2Zvcm1lcnMvcmVkdWNlSGVhZGVyc09iamVjdC50c1xuZnVuY3Rpb24gcmVkdWNlSGVhZGVyc09iamVjdChoZWFkZXJzLCByZWR1Y2VyLCBpbml0aWFsU3RhdGUpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGhlYWRlcnMpLnJlZHVjZSgobmV4dEhlYWRlcnMsIG5hbWUpID0+IHtcbiAgICByZXR1cm4gcmVkdWNlcihuZXh0SGVhZGVycywgbmFtZSwgaGVhZGVyc1tuYW1lXSk7XG4gIH0sIGluaXRpYWxTdGF0ZSk7XG59XG5cbi8vIHNyYy90cmFuc2Zvcm1lcnMvb2JqZWN0VG9IZWFkZXJzLnRzXG5mdW5jdGlvbiBvYmplY3RUb0hlYWRlcnMoaGVhZGVyc09iamVjdCkge1xuICByZXR1cm4gcmVkdWNlSGVhZGVyc09iamVjdChcbiAgICBoZWFkZXJzT2JqZWN0LFxuICAgIChoZWFkZXJzLCBuYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgY29uc3QgdmFsdWVzID0gW10uY29uY2F0KHZhbHVlKS5maWx0ZXIoQm9vbGVhbik7XG4gICAgICB2YWx1ZXMuZm9yRWFjaCgodmFsdWUyKSA9PiB7XG4gICAgICAgIGhlYWRlcnMuYXBwZW5kKG5hbWUsIHZhbHVlMik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBoZWFkZXJzO1xuICAgIH0sXG4gICAgbmV3IEhlYWRlcnMoKVxuICApO1xufVxuXG4vLyBzcmMvdHJhbnNmb3JtZXJzL2ZsYXR0ZW5IZWFkZXJzTGlzdC50c1xuZnVuY3Rpb24gZmxhdHRlbkhlYWRlcnNMaXN0KGxpc3QpIHtcbiAgcmV0dXJuIGxpc3QubWFwKChbbmFtZSwgdmFsdWVzXSkgPT4ge1xuICAgIHJldHVybiBbbmFtZSwgW10uY29uY2F0KHZhbHVlcykuam9pbihcIiwgXCIpXTtcbiAgfSk7XG59XG5cbi8vIHNyYy90cmFuc2Zvcm1lcnMvZmxhdHRlbkhlYWRlcnNPYmplY3QudHNcbmZ1bmN0aW9uIGZsYXR0ZW5IZWFkZXJzT2JqZWN0KGhlYWRlcnNPYmplY3QpIHtcbiAgcmV0dXJuIHJlZHVjZUhlYWRlcnNPYmplY3QoXG4gICAgaGVhZGVyc09iamVjdCxcbiAgICAoaGVhZGVycywgbmFtZSwgdmFsdWUpID0+IHtcbiAgICAgIGhlYWRlcnNbbmFtZV0gPSBbXS5jb25jYXQodmFsdWUpLmpvaW4oXCIsIFwiKTtcbiAgICAgIHJldHVybiBoZWFkZXJzO1xuICAgIH0sXG4gICAge31cbiAgKTtcbn1cbmV4cG9ydCB7XG4gIEhlYWRlcnMsXG4gIGZsYXR0ZW5IZWFkZXJzTGlzdCxcbiAgZmxhdHRlbkhlYWRlcnNPYmplY3QsXG4gIGdldFJhd0hlYWRlcnMsXG4gIGhlYWRlcnNUb0xpc3QsXG4gIGhlYWRlcnNUb09iamVjdCxcbiAgaGVhZGVyc1RvU3RyaW5nLFxuICBsaXN0VG9IZWFkZXJzLFxuICBvYmplY3RUb0hlYWRlcnMsXG4gIHJlZHVjZUhlYWRlcnNPYmplY3QsXG4gIHN0cmluZ1RvSGVhZGVyc1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiLCJpbXBvcnQgKiBhcyBfc3lzY2FsbHMxXzAgZnJvbSAnc3BhY2V0aW1lOnN5c0AxLjAnO1xuaW1wb3J0IHsgcmVnaXN0ZXJfaG9va3MgfSBmcm9tICdzcGFjZXRpbWU6c3lzQDEuMCc7XG5pbXBvcnQgeyByZWdpc3Rlcl9ob29rcyBhcyByZWdpc3Rlcl9ob29rcyQxIH0gZnJvbSAnc3BhY2V0aW1lOnN5c0AxLjEnO1xuaW1wb3J0ICogYXMgX3N5c2NhbGxzMV8yIGZyb20gJ3NwYWNldGltZTpzeXNAMS4yJztcbmltcG9ydCB7IHJlZ2lzdGVyX2hvb2tzIGFzIHJlZ2lzdGVyX2hvb2tzJDIgfSBmcm9tICdzcGFjZXRpbWU6c3lzQDEuMic7XG5pbXBvcnQgeyBoZWFkZXJzVG9MaXN0LCBIZWFkZXJzIH0gZnJvbSAnaGVhZGVycy1wb2x5ZmlsbCc7XG5cbnR5cGVvZiBnbG9iYWxUaGlzIT09XCJ1bmRlZmluZWRcIiYmKChnbG9iYWxUaGlzLmdsb2JhbD1nbG9iYWxUaGlzLmdsb2JhbHx8Z2xvYmFsVGhpcyksKGdsb2JhbFRoaXMud2luZG93PWdsb2JhbFRoaXMud2luZG93fHxnbG9iYWxUaGlzKSk7XG52YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fa25vd25TeW1ib2wgPSAobmFtZSwgc3ltYm9sKSA9PiAoc3ltYm9sID0gU3ltYm9sW25hbWVdKSA/IHN5bWJvbCA6IFN5bWJvbC5mb3IoXCJTeW1ib2wuXCIgKyBuYW1lKTtcbnZhciBfX3R5cGVFcnJvciA9IChtc2cpID0+IHtcbiAgdGhyb3cgVHlwZUVycm9yKG1zZyk7XG59O1xudmFyIF9fY29tbW9uSlMgPSAoY2IsIG1vZCkgPT4gZnVuY3Rpb24gX19yZXF1aXJlKCkge1xuICByZXR1cm4gbW9kIHx8ICgwLCBjYltfX2dldE93blByb3BOYW1lcyhjYilbMF1dKSgobW9kID0geyBleHBvcnRzOiB7fSB9KS5leHBvcnRzLCBtb2QpLCBtb2QuZXhwb3J0cztcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0VTTSA9IChtb2QsIGlzTm9kZU1vZGUsIHRhcmdldCkgPT4gKHRhcmdldCA9IG1vZCAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZCkpIDoge30sIF9fY29weVByb3BzKFxuICAvLyBJZiB0aGUgaW1wb3J0ZXIgaXMgaW4gbm9kZSBjb21wYXRpYmlsaXR5IG1vZGUgb3IgdGhpcyBpcyBub3QgYW4gRVNNXG4gIC8vIGZpbGUgdGhhdCBoYXMgYmVlbiBjb252ZXJ0ZWQgdG8gYSBDb21tb25KUyBmaWxlIHVzaW5nIGEgQmFiZWwtXG4gIC8vIGNvbXBhdGlibGUgdHJhbnNmb3JtIChpLmUuIFwiX19lc01vZHVsZVwiIGhhcyBub3QgYmVlbiBzZXQpLCB0aGVuIHNldFxuICAvLyBcImRlZmF1bHRcIiB0byB0aGUgQ29tbW9uSlMgXCJtb2R1bGUuZXhwb3J0c1wiIGZvciBub2RlIGNvbXBhdGliaWxpdHkuXG4gIF9fZGVmUHJvcCh0YXJnZXQsIFwiZGVmYXVsdFwiLCB7IHZhbHVlOiBtb2QsIGVudW1lcmFibGU6IHRydWUgfSkgLFxuICBtb2RcbikpO1xudmFyIF9fdXNpbmcgPSAoc3RhY2ssIHZhbHVlLCBhc3luYykgPT4ge1xuICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIF9fdHlwZUVycm9yKFwiT2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgIHZhciBkaXNwb3NlLCBpbm5lcjtcbiAgICBpZiAoZGlzcG9zZSA9PT0gdm9pZCAwKSB7XG4gICAgICBkaXNwb3NlID0gdmFsdWVbX19rbm93blN5bWJvbChcImRpc3Bvc2VcIildO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGRpc3Bvc2UgIT09IFwiZnVuY3Rpb25cIikgX190eXBlRXJyb3IoXCJPYmplY3Qgbm90IGRpc3Bvc2FibGVcIik7XG4gICAgaWYgKGlubmVyKSBkaXNwb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpbm5lci5jYWxsKHRoaXMpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBzdGFjay5wdXNoKFthc3luYywgZGlzcG9zZSwgdmFsdWVdKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59O1xudmFyIF9fY2FsbERpc3Bvc2UgPSAoc3RhY2ssIGVycm9yLCBoYXNFcnJvcikgPT4ge1xuICB2YXIgRSA9IHR5cGVvZiBTdXBwcmVzc2VkRXJyb3IgPT09IFwiZnVuY3Rpb25cIiA/IFN1cHByZXNzZWRFcnJvciA6IGZ1bmN0aW9uKGUsIHMsIG0sIF8pIHtcbiAgICByZXR1cm4gXyA9IEVycm9yKG0pLCBfLm5hbWUgPSBcIlN1cHByZXNzZWRFcnJvclwiLCBfLmVycm9yID0gZSwgXy5zdXBwcmVzc2VkID0gcywgXztcbiAgfTtcbiAgdmFyIGZhaWwgPSAoZSkgPT4gZXJyb3IgPSBoYXNFcnJvciA/IG5ldyBFKGUsIGVycm9yLCBcIkFuIGVycm9yIHdhcyBzdXBwcmVzc2VkIGR1cmluZyBkaXNwb3NhbFwiKSA6IChoYXNFcnJvciA9IHRydWUsIGUpO1xuICB2YXIgbmV4dCA9IChpdCkgPT4ge1xuICAgIHdoaWxlIChpdCA9IHN0YWNrLnBvcCgpKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gaXRbMV0gJiYgaXRbMV0uY2FsbChpdFsyXSk7XG4gICAgICAgIGlmIChpdFswXSkgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpLnRoZW4obmV4dCwgKGUpID0+IChmYWlsKGUpLCBuZXh0KCkpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZmFpbChlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGhhc0Vycm9yKSB0aHJvdyBlcnJvcjtcbiAgfTtcbiAgcmV0dXJuIG5leHQoKTtcbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9iYXNlNjQtanNAMS41LjEvbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qc1xudmFyIHJlcXVpcmVfYmFzZTY0X2pzID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Jhc2U2NC1qc0AxLjUuMS9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzXCIoZXhwb3J0cykge1xuICAgIGV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGg7XG4gICAgZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5O1xuICAgIGV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXkyO1xuICAgIHZhciBsb29rdXAgPSBbXTtcbiAgICB2YXIgcmV2TG9va3VwID0gW107XG4gICAgdmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSBcInVuZGVmaW5lZFwiID8gVWludDhBcnJheSA6IEFycmF5O1xuICAgIHZhciBjb2RlID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCI7XG4gICAgZm9yIChpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgbG9va3VwW2ldID0gY29kZVtpXTtcbiAgICAgIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaTtcbiAgICB9XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbjtcbiAgICByZXZMb29rdXBbXCItXCIuY2hhckNvZGVBdCgwKV0gPSA2MjtcbiAgICByZXZMb29rdXBbXCJfXCIuY2hhckNvZGVBdCgwKV0gPSA2MztcbiAgICBmdW5jdGlvbiBnZXRMZW5zKGI2NCkge1xuICAgICAgdmFyIGxlbjIgPSBiNjQubGVuZ3RoO1xuICAgICAgaWYgKGxlbjIgJSA0ID4gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0XCIpO1xuICAgICAgfVxuICAgICAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoXCI9XCIpO1xuICAgICAgaWYgKHZhbGlkTGVuID09PSAtMSkgdmFsaWRMZW4gPSBsZW4yO1xuICAgICAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW4yID8gMCA6IDQgLSB2YWxpZExlbiAlIDQ7XG4gICAgICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dO1xuICAgIH1cbiAgICBmdW5jdGlvbiBieXRlTGVuZ3RoKGI2NCkge1xuICAgICAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NCk7XG4gICAgICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdO1xuICAgICAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV07XG4gICAgICByZXR1cm4gKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzTGVuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgICAgIHJldHVybiAodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQgLSBwbGFjZUhvbGRlcnNMZW47XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRvQnl0ZUFycmF5KGI2NCkge1xuICAgICAgdmFyIHRtcDtcbiAgICAgIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpO1xuICAgICAgdmFyIHZhbGlkTGVuID0gbGVuc1swXTtcbiAgICAgIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdO1xuICAgICAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSk7XG4gICAgICB2YXIgY3VyQnl0ZSA9IDA7XG4gICAgICB2YXIgbGVuMiA9IHBsYWNlSG9sZGVyc0xlbiA+IDAgPyB2YWxpZExlbiAtIDQgOiB2YWxpZExlbjtcbiAgICAgIHZhciBpMjtcbiAgICAgIGZvciAoaTIgPSAwOyBpMiA8IGxlbjI7IGkyICs9IDQpIHtcbiAgICAgICAgdG1wID0gcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkyKV0gPDwgMTggfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaTIgKyAxKV0gPDwgMTIgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaTIgKyAyKV0gPDwgNiB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpMiArIDMpXTtcbiAgICAgICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgPj4gMTYgJiAyNTU7XG4gICAgICAgIGFycltjdXJCeXRlKytdID0gdG1wID4+IDggJiAyNTU7XG4gICAgICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMjU1O1xuICAgICAgfVxuICAgICAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMikge1xuICAgICAgICB0bXAgPSByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaTIpXSA8PCAyIHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkyICsgMSldID4+IDQ7XG4gICAgICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMjU1O1xuICAgICAgfVxuICAgICAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgICAgICB0bXAgPSByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaTIpXSA8PCAxMCB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpMiArIDEpXSA8PCA0IHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkyICsgMildID4+IDI7XG4gICAgICAgIGFycltjdXJCeXRlKytdID0gdG1wID4+IDggJiAyNTU7XG4gICAgICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMjU1O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycjtcbiAgICB9XG4gICAgZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0KG51bSkge1xuICAgICAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiA2M10gKyBsb29rdXBbbnVtID4+IDEyICYgNjNdICsgbG9va3VwW251bSA+PiA2ICYgNjNdICsgbG9va3VwW251bSAmIDYzXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5jb2RlQ2h1bmsodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciB0bXA7XG4gICAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgICBmb3IgKHZhciBpMiA9IHN0YXJ0OyBpMiA8IGVuZDsgaTIgKz0gMykge1xuICAgICAgICB0bXAgPSAodWludDhbaTJdIDw8IDE2ICYgMTY3MTE2ODApICsgKHVpbnQ4W2kyICsgMV0gPDwgOCAmIDY1MjgwKSArICh1aW50OFtpMiArIDJdICYgMjU1KTtcbiAgICAgICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dHB1dC5qb2luKFwiXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmcm9tQnl0ZUFycmF5Mih1aW50OCkge1xuICAgICAgdmFyIHRtcDtcbiAgICAgIHZhciBsZW4yID0gdWludDgubGVuZ3RoO1xuICAgICAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4yICUgMztcbiAgICAgIHZhciBwYXJ0cyA9IFtdO1xuICAgICAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODM7XG4gICAgICBmb3IgKHZhciBpMiA9IDAsIGxlbjIyID0gbGVuMiAtIGV4dHJhQnl0ZXM7IGkyIDwgbGVuMjI7IGkyICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsIGkyLCBpMiArIG1heENodW5rTGVuZ3RoID4gbGVuMjIgPyBsZW4yMiA6IGkyICsgbWF4Q2h1bmtMZW5ndGgpKTtcbiAgICAgIH1cbiAgICAgIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgICAgIHRtcCA9IHVpbnQ4W2xlbjIgLSAxXTtcbiAgICAgICAgcGFydHMucHVzaChcbiAgICAgICAgICBsb29rdXBbdG1wID4+IDJdICsgbG9va3VwW3RtcCA8PCA0ICYgNjNdICsgXCI9PVwiXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICAgICAgdG1wID0gKHVpbnQ4W2xlbjIgLSAyXSA8PCA4KSArIHVpbnQ4W2xlbjIgLSAxXTtcbiAgICAgICAgcGFydHMucHVzaChcbiAgICAgICAgICBsb29rdXBbdG1wID4+IDEwXSArIGxvb2t1cFt0bXAgPj4gNCAmIDYzXSArIGxvb2t1cFt0bXAgPDwgMiAmIDYzXSArIFwiPVwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFydHMuam9pbihcIlwiKTtcbiAgICB9XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZmFzdC10ZXh0LWVuY29kaW5nQDEuMC42L25vZGVfbW9kdWxlcy9mYXN0LXRleHQtZW5jb2RpbmcvdGV4dC5taW4uanNcbnZhciByZXF1aXJlX3RleHRfbWluID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Zhc3QtdGV4dC1lbmNvZGluZ0AxLjAuNi9ub2RlX21vZHVsZXMvZmFzdC10ZXh0LWVuY29kaW5nL3RleHQubWluLmpzXCIoZXhwb3J0cykge1xuICAgIChmdW5jdGlvbihzY29wZSkge1xuICAgICAgZnVuY3Rpb24gQihyLCBlKSB7XG4gICAgICAgIHZhciBmO1xuICAgICAgICByZXR1cm4gciBpbnN0YW5jZW9mIEJ1ZmZlciA/IGYgPSByIDogZiA9IEJ1ZmZlci5mcm9tKHIuYnVmZmVyLCByLmJ5dGVPZmZzZXQsIHIuYnl0ZUxlbmd0aCksIGYudG9TdHJpbmcoZSk7XG4gICAgICB9XG4gICAgICB2YXIgdyA9IGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHIpO1xuICAgICAgfTtcbiAgICAgIGZ1bmN0aW9uIGgocikge1xuICAgICAgICBmb3IgKHZhciBlID0gMCwgZiA9IE1hdGgubWluKDI1NiAqIDI1Niwgci5sZW5ndGggKyAxKSwgbiA9IG5ldyBVaW50MTZBcnJheShmKSwgaSA9IFtdLCBvID0gMDsgOyApIHtcbiAgICAgICAgICB2YXIgdDIgPSBlIDwgci5sZW5ndGg7XG4gICAgICAgICAgaWYgKCF0MiB8fCBvID49IGYgLSAxKSB7XG4gICAgICAgICAgICB2YXIgcyA9IG4uc3ViYXJyYXkoMCwgbyksIG0gPSBzO1xuICAgICAgICAgICAgaWYgKGkucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG0pKSwgIXQyKSByZXR1cm4gaS5qb2luKFwiXCIpO1xuICAgICAgICAgICAgciA9IHIuc3ViYXJyYXkoZSksIGUgPSAwLCBvID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGEgPSByW2UrK107XG4gICAgICAgICAgaWYgKChhICYgMTI4KSA9PT0gMCkgbltvKytdID0gYTtcbiAgICAgICAgICBlbHNlIGlmICgoYSAmIDIyNCkgPT09IDE5Mikge1xuICAgICAgICAgICAgdmFyIGQgPSByW2UrK10gJiA2MztcbiAgICAgICAgICAgIG5bbysrXSA9IChhICYgMzEpIDw8IDYgfCBkO1xuICAgICAgICAgIH0gZWxzZSBpZiAoKGEgJiAyNDApID09PSAyMjQpIHtcbiAgICAgICAgICAgIHZhciBkID0gcltlKytdICYgNjMsIGwgPSByW2UrK10gJiA2MztcbiAgICAgICAgICAgIG5bbysrXSA9IChhICYgMzEpIDw8IDEyIHwgZCA8PCA2IHwgbDtcbiAgICAgICAgICB9IGVsc2UgaWYgKChhICYgMjQ4KSA9PT0gMjQwKSB7XG4gICAgICAgICAgICB2YXIgZCA9IHJbZSsrXSAmIDYzLCBsID0gcltlKytdICYgNjMsIFIgPSByW2UrK10gJiA2MywgYyA9IChhICYgNykgPDwgMTggfCBkIDw8IDEyIHwgbCA8PCA2IHwgUjtcbiAgICAgICAgICAgIGMgPiA2NTUzNSAmJiAoYyAtPSA2NTUzNiwgbltvKytdID0gYyA+Pj4gMTAgJiAxMDIzIHwgNTUyOTYsIGMgPSA1NjMyMCB8IGMgJiAxMDIzKSwgbltvKytdID0gYztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIEYocikge1xuICAgICAgICBmb3IgKHZhciBlID0gMCwgZiA9IHIubGVuZ3RoLCBuID0gMCwgaSA9IE1hdGgubWF4KDMyLCBmICsgKGYgPj4+IDEpICsgNyksIG8gPSBuZXcgVWludDhBcnJheShpID4+PiAzIDw8IDMpOyBlIDwgZjsgKSB7XG4gICAgICAgICAgdmFyIHQyID0gci5jaGFyQ29kZUF0KGUrKyk7XG4gICAgICAgICAgaWYgKHQyID49IDU1Mjk2ICYmIHQyIDw9IDU2MzE5KSB7XG4gICAgICAgICAgICBpZiAoZSA8IGYpIHtcbiAgICAgICAgICAgICAgdmFyIHMgPSByLmNoYXJDb2RlQXQoZSk7XG4gICAgICAgICAgICAgIChzICYgNjQ1MTIpID09PSA1NjMyMCAmJiAoKytlLCB0MiA9ICgodDIgJiAxMDIzKSA8PCAxMCkgKyAocyAmIDEwMjMpICsgNjU1MzYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHQyID49IDU1Mjk2ICYmIHQyIDw9IDU2MzE5KSBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG4gKyA0ID4gby5sZW5ndGgpIHtcbiAgICAgICAgICAgIGkgKz0gOCwgaSAqPSAxICsgZSAvIHIubGVuZ3RoICogMiwgaSA9IGkgPj4+IDMgPDwgMztcbiAgICAgICAgICAgIHZhciBtID0gbmV3IFVpbnQ4QXJyYXkoaSk7XG4gICAgICAgICAgICBtLnNldChvKSwgbyA9IG07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgodDIgJiA0Mjk0OTY3MTY4KSA9PT0gMCkge1xuICAgICAgICAgICAgb1tuKytdID0gdDI7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCh0MiAmIDQyOTQ5NjUyNDgpID09PSAwKSBvW24rK10gPSB0MiA+Pj4gNiAmIDMxIHwgMTkyO1xuICAgICAgICAgIGVsc2UgaWYgKCh0MiAmIDQyOTQ5MDE3NjApID09PSAwKSBvW24rK10gPSB0MiA+Pj4gMTIgJiAxNSB8IDIyNCwgb1tuKytdID0gdDIgPj4+IDYgJiA2MyB8IDEyODtcbiAgICAgICAgICBlbHNlIGlmICgodDIgJiA0MjkyODcwMTQ0KSA9PT0gMCkgb1tuKytdID0gdDIgPj4+IDE4ICYgNyB8IDI0MCwgb1tuKytdID0gdDIgPj4+IDEyICYgNjMgfCAxMjgsIG9bbisrXSA9IHQyID4+PiA2ICYgNjMgfCAxMjg7XG4gICAgICAgICAgZWxzZSBjb250aW51ZTtcbiAgICAgICAgICBvW24rK10gPSB0MiAmIDYzIHwgMTI4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvLnNsaWNlID8gby5zbGljZSgwLCBuKSA6IG8uc3ViYXJyYXkoMCwgbik7XG4gICAgICB9XG4gICAgICB2YXIgdSA9IFwiRmFpbGVkIHRvIFwiLCBwID0gZnVuY3Rpb24ociwgZSwgZikge1xuICAgICAgICBpZiAocikgdGhyb3cgbmV3IEVycm9yKFwiXCIuY29uY2F0KHUpLmNvbmNhdChlLCBcIjogdGhlICdcIikuY29uY2F0KGYsIFwiJyBvcHRpb24gaXMgdW5zdXBwb3J0ZWQuXCIpKTtcbiAgICAgIH07XG4gICAgICB2YXIgeCA9IHR5cGVvZiBCdWZmZXIgPT0gXCJmdW5jdGlvblwiICYmIEJ1ZmZlci5mcm9tO1xuICAgICAgdmFyIEEgPSB4ID8gdyA6IEY7XG4gICAgICBmdW5jdGlvbiB2KCkge1xuICAgICAgICB0aGlzLmVuY29kaW5nID0gXCJ1dGYtOFwiO1xuICAgICAgfVxuICAgICAgdi5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24ociwgZSkge1xuICAgICAgICByZXR1cm4gcChlICYmIGUuc3RyZWFtLCBcImVuY29kZVwiLCBcInN0cmVhbVwiKSwgQShyKTtcbiAgICAgIH07XG4gICAgICBmdW5jdGlvbiBVKHIpIHtcbiAgICAgICAgdmFyIGU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGYgPSBuZXcgQmxvYihbcl0sIHsgdHlwZTogXCJ0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLThcIiB9KTtcbiAgICAgICAgICBlID0gVVJMLmNyZWF0ZU9iamVjdFVSTChmKTtcbiAgICAgICAgICB2YXIgbiA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgIHJldHVybiBuLm9wZW4oXCJHRVRcIiwgZSwgZmFsc2UpLCBuLnNlbmQoKSwgbi5yZXNwb25zZVRleHQ7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgZSAmJiBVUkwucmV2b2tlT2JqZWN0VVJMKGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgTyA9ICF4ICYmIHR5cGVvZiBCbG9iID09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgVVJMID09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgVVJMLmNyZWF0ZU9iamVjdFVSTCA9PSBcImZ1bmN0aW9uXCIsIFMgPSBbXCJ1dGYtOFwiLCBcInV0ZjhcIiwgXCJ1bmljb2RlLTEtMS11dGYtOFwiXSwgVCA9IGg7XG4gICAgICB4ID8gVCA9IEIgOiBPICYmIChUID0gZnVuY3Rpb24ocikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBVKHIpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0dXJuIGgocik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdmFyIHkgPSBcImNvbnN0cnVjdCAnVGV4dERlY29kZXInXCIsIEUgPSBcIlwiLmNvbmNhdCh1LCBcIiBcIikuY29uY2F0KHksIFwiOiB0aGUgXCIpO1xuICAgICAgZnVuY3Rpb24gZyhyLCBlKSB7XG4gICAgICAgIHAoZSAmJiBlLmZhdGFsLCB5LCBcImZhdGFsXCIpLCByID0gciB8fCBcInV0Zi04XCI7XG4gICAgICAgIHZhciBmO1xuICAgICAgICBpZiAoeCA/IGYgPSBCdWZmZXIuaXNFbmNvZGluZyhyKSA6IGYgPSBTLmluZGV4T2Yoci50b0xvd2VyQ2FzZSgpKSAhPT0gLTEsICFmKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlwiLmNvbmNhdChFLCBcIiBlbmNvZGluZyBsYWJlbCBwcm92aWRlZCAoJ1wiKS5jb25jYXQociwgXCInKSBpcyBpbnZhbGlkLlwiKSk7XG4gICAgICAgIHRoaXMuZW5jb2RpbmcgPSByLCB0aGlzLmZhdGFsID0gZmFsc2UsIHRoaXMuaWdub3JlQk9NID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBnLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbihyLCBlKSB7XG4gICAgICAgIHAoZSAmJiBlLnN0cmVhbSwgXCJkZWNvZGVcIiwgXCJzdHJlYW1cIik7XG4gICAgICAgIHZhciBmO1xuICAgICAgICByZXR1cm4gciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyBmID0gciA6IHIuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgPyBmID0gbmV3IFVpbnQ4QXJyYXkoci5idWZmZXIpIDogZiA9IG5ldyBVaW50OEFycmF5KHIpLCBUKGYsIHRoaXMuZW5jb2RpbmcpO1xuICAgICAgfTtcbiAgICAgIHNjb3BlLlRleHRFbmNvZGVyID0gc2NvcGUuVGV4dEVuY29kZXIgfHwgdjtcbiAgICAgIHNjb3BlLlRleHREZWNvZGVyID0gc2NvcGUuVGV4dERlY29kZXIgfHwgZztcbiAgICB9KSh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IGV4cG9ydHMpO1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3N0YXR1c2VzQDIuMC4yL25vZGVfbW9kdWxlcy9zdGF0dXNlcy9jb2Rlcy5qc29uXG52YXIgcmVxdWlyZV9jb2RlcyA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9zdGF0dXNlc0AyLjAuMi9ub2RlX21vZHVsZXMvc3RhdHVzZXMvY29kZXMuanNvblwiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgXCIxMDBcIjogXCJDb250aW51ZVwiLFxuICAgICAgXCIxMDFcIjogXCJTd2l0Y2hpbmcgUHJvdG9jb2xzXCIsXG4gICAgICBcIjEwMlwiOiBcIlByb2Nlc3NpbmdcIixcbiAgICAgIFwiMTAzXCI6IFwiRWFybHkgSGludHNcIixcbiAgICAgIFwiMjAwXCI6IFwiT0tcIixcbiAgICAgIFwiMjAxXCI6IFwiQ3JlYXRlZFwiLFxuICAgICAgXCIyMDJcIjogXCJBY2NlcHRlZFwiLFxuICAgICAgXCIyMDNcIjogXCJOb24tQXV0aG9yaXRhdGl2ZSBJbmZvcm1hdGlvblwiLFxuICAgICAgXCIyMDRcIjogXCJObyBDb250ZW50XCIsXG4gICAgICBcIjIwNVwiOiBcIlJlc2V0IENvbnRlbnRcIixcbiAgICAgIFwiMjA2XCI6IFwiUGFydGlhbCBDb250ZW50XCIsXG4gICAgICBcIjIwN1wiOiBcIk11bHRpLVN0YXR1c1wiLFxuICAgICAgXCIyMDhcIjogXCJBbHJlYWR5IFJlcG9ydGVkXCIsXG4gICAgICBcIjIyNlwiOiBcIklNIFVzZWRcIixcbiAgICAgIFwiMzAwXCI6IFwiTXVsdGlwbGUgQ2hvaWNlc1wiLFxuICAgICAgXCIzMDFcIjogXCJNb3ZlZCBQZXJtYW5lbnRseVwiLFxuICAgICAgXCIzMDJcIjogXCJGb3VuZFwiLFxuICAgICAgXCIzMDNcIjogXCJTZWUgT3RoZXJcIixcbiAgICAgIFwiMzA0XCI6IFwiTm90IE1vZGlmaWVkXCIsXG4gICAgICBcIjMwNVwiOiBcIlVzZSBQcm94eVwiLFxuICAgICAgXCIzMDdcIjogXCJUZW1wb3JhcnkgUmVkaXJlY3RcIixcbiAgICAgIFwiMzA4XCI6IFwiUGVybWFuZW50IFJlZGlyZWN0XCIsXG4gICAgICBcIjQwMFwiOiBcIkJhZCBSZXF1ZXN0XCIsXG4gICAgICBcIjQwMVwiOiBcIlVuYXV0aG9yaXplZFwiLFxuICAgICAgXCI0MDJcIjogXCJQYXltZW50IFJlcXVpcmVkXCIsXG4gICAgICBcIjQwM1wiOiBcIkZvcmJpZGRlblwiLFxuICAgICAgXCI0MDRcIjogXCJOb3QgRm91bmRcIixcbiAgICAgIFwiNDA1XCI6IFwiTWV0aG9kIE5vdCBBbGxvd2VkXCIsXG4gICAgICBcIjQwNlwiOiBcIk5vdCBBY2NlcHRhYmxlXCIsXG4gICAgICBcIjQwN1wiOiBcIlByb3h5IEF1dGhlbnRpY2F0aW9uIFJlcXVpcmVkXCIsXG4gICAgICBcIjQwOFwiOiBcIlJlcXVlc3QgVGltZW91dFwiLFxuICAgICAgXCI0MDlcIjogXCJDb25mbGljdFwiLFxuICAgICAgXCI0MTBcIjogXCJHb25lXCIsXG4gICAgICBcIjQxMVwiOiBcIkxlbmd0aCBSZXF1aXJlZFwiLFxuICAgICAgXCI0MTJcIjogXCJQcmVjb25kaXRpb24gRmFpbGVkXCIsXG4gICAgICBcIjQxM1wiOiBcIlBheWxvYWQgVG9vIExhcmdlXCIsXG4gICAgICBcIjQxNFwiOiBcIlVSSSBUb28gTG9uZ1wiLFxuICAgICAgXCI0MTVcIjogXCJVbnN1cHBvcnRlZCBNZWRpYSBUeXBlXCIsXG4gICAgICBcIjQxNlwiOiBcIlJhbmdlIE5vdCBTYXRpc2ZpYWJsZVwiLFxuICAgICAgXCI0MTdcIjogXCJFeHBlY3RhdGlvbiBGYWlsZWRcIixcbiAgICAgIFwiNDE4XCI6IFwiSSdtIGEgVGVhcG90XCIsXG4gICAgICBcIjQyMVwiOiBcIk1pc2RpcmVjdGVkIFJlcXVlc3RcIixcbiAgICAgIFwiNDIyXCI6IFwiVW5wcm9jZXNzYWJsZSBFbnRpdHlcIixcbiAgICAgIFwiNDIzXCI6IFwiTG9ja2VkXCIsXG4gICAgICBcIjQyNFwiOiBcIkZhaWxlZCBEZXBlbmRlbmN5XCIsXG4gICAgICBcIjQyNVwiOiBcIlRvbyBFYXJseVwiLFxuICAgICAgXCI0MjZcIjogXCJVcGdyYWRlIFJlcXVpcmVkXCIsXG4gICAgICBcIjQyOFwiOiBcIlByZWNvbmRpdGlvbiBSZXF1aXJlZFwiLFxuICAgICAgXCI0MjlcIjogXCJUb28gTWFueSBSZXF1ZXN0c1wiLFxuICAgICAgXCI0MzFcIjogXCJSZXF1ZXN0IEhlYWRlciBGaWVsZHMgVG9vIExhcmdlXCIsXG4gICAgICBcIjQ1MVwiOiBcIlVuYXZhaWxhYmxlIEZvciBMZWdhbCBSZWFzb25zXCIsXG4gICAgICBcIjUwMFwiOiBcIkludGVybmFsIFNlcnZlciBFcnJvclwiLFxuICAgICAgXCI1MDFcIjogXCJOb3QgSW1wbGVtZW50ZWRcIixcbiAgICAgIFwiNTAyXCI6IFwiQmFkIEdhdGV3YXlcIixcbiAgICAgIFwiNTAzXCI6IFwiU2VydmljZSBVbmF2YWlsYWJsZVwiLFxuICAgICAgXCI1MDRcIjogXCJHYXRld2F5IFRpbWVvdXRcIixcbiAgICAgIFwiNTA1XCI6IFwiSFRUUCBWZXJzaW9uIE5vdCBTdXBwb3J0ZWRcIixcbiAgICAgIFwiNTA2XCI6IFwiVmFyaWFudCBBbHNvIE5lZ290aWF0ZXNcIixcbiAgICAgIFwiNTA3XCI6IFwiSW5zdWZmaWNpZW50IFN0b3JhZ2VcIixcbiAgICAgIFwiNTA4XCI6IFwiTG9vcCBEZXRlY3RlZFwiLFxuICAgICAgXCI1MDlcIjogXCJCYW5kd2lkdGggTGltaXQgRXhjZWVkZWRcIixcbiAgICAgIFwiNTEwXCI6IFwiTm90IEV4dGVuZGVkXCIsXG4gICAgICBcIjUxMVwiOiBcIk5ldHdvcmsgQXV0aGVudGljYXRpb24gUmVxdWlyZWRcIlxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vc3RhdHVzZXNAMi4wLjIvbm9kZV9tb2R1bGVzL3N0YXR1c2VzL2luZGV4LmpzXG52YXIgcmVxdWlyZV9zdGF0dXNlcyA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9zdGF0dXNlc0AyLjAuMi9ub2RlX21vZHVsZXMvc3RhdHVzZXMvaW5kZXguanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICB2YXIgY29kZXMgPSByZXF1aXJlX2NvZGVzKCk7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBzdGF0dXMyO1xuICAgIHN0YXR1czIubWVzc2FnZSA9IGNvZGVzO1xuICAgIHN0YXR1czIuY29kZSA9IGNyZWF0ZU1lc3NhZ2VUb1N0YXR1c0NvZGVNYXAoY29kZXMpO1xuICAgIHN0YXR1czIuY29kZXMgPSBjcmVhdGVTdGF0dXNDb2RlTGlzdChjb2Rlcyk7XG4gICAgc3RhdHVzMi5yZWRpcmVjdCA9IHtcbiAgICAgIDMwMDogdHJ1ZSxcbiAgICAgIDMwMTogdHJ1ZSxcbiAgICAgIDMwMjogdHJ1ZSxcbiAgICAgIDMwMzogdHJ1ZSxcbiAgICAgIDMwNTogdHJ1ZSxcbiAgICAgIDMwNzogdHJ1ZSxcbiAgICAgIDMwODogdHJ1ZVxuICAgIH07XG4gICAgc3RhdHVzMi5lbXB0eSA9IHtcbiAgICAgIDIwNDogdHJ1ZSxcbiAgICAgIDIwNTogdHJ1ZSxcbiAgICAgIDMwNDogdHJ1ZVxuICAgIH07XG4gICAgc3RhdHVzMi5yZXRyeSA9IHtcbiAgICAgIDUwMjogdHJ1ZSxcbiAgICAgIDUwMzogdHJ1ZSxcbiAgICAgIDUwNDogdHJ1ZVxuICAgIH07XG4gICAgZnVuY3Rpb24gY3JlYXRlTWVzc2FnZVRvU3RhdHVzQ29kZU1hcChjb2RlczIpIHtcbiAgICAgIHZhciBtYXAgPSB7fTtcbiAgICAgIE9iamVjdC5rZXlzKGNvZGVzMikuZm9yRWFjaChmdW5jdGlvbiBmb3JFYWNoQ29kZShjb2RlKSB7XG4gICAgICAgIHZhciBtZXNzYWdlID0gY29kZXMyW2NvZGVdO1xuICAgICAgICB2YXIgc3RhdHVzMyA9IE51bWJlcihjb2RlKTtcbiAgICAgICAgbWFwW21lc3NhZ2UudG9Mb3dlckNhc2UoKV0gPSBzdGF0dXMzO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbWFwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVTdGF0dXNDb2RlTGlzdChjb2RlczIpIHtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyhjb2RlczIpLm1hcChmdW5jdGlvbiBtYXBDb2RlKGNvZGUpIHtcbiAgICAgICAgcmV0dXJuIE51bWJlcihjb2RlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRTdGF0dXNDb2RlKG1lc3NhZ2UpIHtcbiAgICAgIHZhciBtc2cgPSBtZXNzYWdlLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzdGF0dXMyLmNvZGUsIG1zZykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHN0YXR1cyBtZXNzYWdlOiBcIicgKyBtZXNzYWdlICsgJ1wiJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RhdHVzMi5jb2RlW21zZ107XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFN0YXR1c01lc3NhZ2UoY29kZSkge1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc3RhdHVzMi5tZXNzYWdlLCBjb2RlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHN0YXR1cyBjb2RlOiBcIiArIGNvZGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0YXR1czIubWVzc2FnZVtjb2RlXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RhdHVzMihjb2RlKSB7XG4gICAgICBpZiAodHlwZW9mIGNvZGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIGdldFN0YXR1c01lc3NhZ2UoY29kZSk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGNvZGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNvZGUgbXVzdCBiZSBhIG51bWJlciBvciBzdHJpbmdcIik7XG4gICAgICB9XG4gICAgICB2YXIgbiA9IHBhcnNlSW50KGNvZGUsIDEwKTtcbiAgICAgIGlmICghaXNOYU4obikpIHtcbiAgICAgICAgcmV0dXJuIGdldFN0YXR1c01lc3NhZ2Uobik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0U3RhdHVzQ29kZShjb2RlKTtcbiAgICB9XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3RpbWVfZHVyYXRpb24udHNcbnZhciBUaW1lRHVyYXRpb24gPSBjbGFzcyBfVGltZUR1cmF0aW9uIHtcbiAgX190aW1lX2R1cmF0aW9uX21pY3Jvc19fO1xuICBzdGF0aWMgTUlDUk9TX1BFUl9NSUxMSVMgPSAxMDAwbjtcbiAgLyoqXG4gICAqIEdldCB0aGUgYWxnZWJyYWljIHR5cGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIHtAbGluayBUaW1lRHVyYXRpb259IHR5cGUuXG4gICAqIEByZXR1cm5zIFRoZSBhbGdlYnJhaWMgdHlwZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgdHlwZS5cbiAgICovXG4gIHN0YXRpYyBnZXRBbGdlYnJhaWNUeXBlKCkge1xuICAgIHJldHVybiBBbGdlYnJhaWNUeXBlLlByb2R1Y3Qoe1xuICAgICAgZWxlbWVudHM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwiX190aW1lX2R1cmF0aW9uX21pY3Jvc19fXCIsXG4gICAgICAgICAgYWxnZWJyYWljVHlwZTogQWxnZWJyYWljVHlwZS5JNjRcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBpc1RpbWVEdXJhdGlvbihhbGdlYnJhaWNUeXBlKSB7XG4gICAgaWYgKGFsZ2VicmFpY1R5cGUudGFnICE9PSBcIlByb2R1Y3RcIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBlbGVtZW50cyA9IGFsZ2VicmFpY1R5cGUudmFsdWUuZWxlbWVudHM7XG4gICAgaWYgKGVsZW1lbnRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBtaWNyb3NFbGVtZW50ID0gZWxlbWVudHNbMF07XG4gICAgcmV0dXJuIG1pY3Jvc0VsZW1lbnQubmFtZSA9PT0gXCJfX3RpbWVfZHVyYXRpb25fbWljcm9zX19cIiAmJiBtaWNyb3NFbGVtZW50LmFsZ2VicmFpY1R5cGUudGFnID09PSBcIkk2NFwiO1xuICB9XG4gIGdldCBtaWNyb3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuX190aW1lX2R1cmF0aW9uX21pY3Jvc19fO1xuICB9XG4gIGdldCBtaWxsaXMoKSB7XG4gICAgcmV0dXJuIE51bWJlcih0aGlzLm1pY3JvcyAvIF9UaW1lRHVyYXRpb24uTUlDUk9TX1BFUl9NSUxMSVMpO1xuICB9XG4gIGNvbnN0cnVjdG9yKG1pY3Jvcykge1xuICAgIHRoaXMuX190aW1lX2R1cmF0aW9uX21pY3Jvc19fID0gbWljcm9zO1xuICB9XG4gIHN0YXRpYyBmcm9tTWlsbGlzKG1pbGxpcykge1xuICAgIHJldHVybiBuZXcgX1RpbWVEdXJhdGlvbihCaWdJbnQobWlsbGlzKSAqIF9UaW1lRHVyYXRpb24uTUlDUk9TX1BFUl9NSUxMSVMpO1xuICB9XG4gIC8qKiBUaGlzIG91dHB1dHMgdGhlIHNhbWUgc3RyaW5nIGZvcm1hdCB0aGF0IHdlIHVzZSBpbiB0aGUgaG9zdCBhbmQgaW4gUnVzdCBtb2R1bGVzICovXG4gIHRvU3RyaW5nKCkge1xuICAgIGNvbnN0IG1pY3JvcyA9IHRoaXMubWljcm9zO1xuICAgIGNvbnN0IHNpZ24gPSBtaWNyb3MgPCAwID8gXCItXCIgOiBcIitcIjtcbiAgICBjb25zdCBwb3MgPSBtaWNyb3MgPCAwID8gLW1pY3JvcyA6IG1pY3JvcztcbiAgICBjb25zdCBzZWNzID0gcG9zIC8gMTAwMDAwMG47XG4gICAgY29uc3QgbWljcm9zX3JlbWFpbmluZyA9IHBvcyAlIDEwMDAwMDBuO1xuICAgIHJldHVybiBgJHtzaWdufSR7c2Vjc30uJHtTdHJpbmcobWljcm9zX3JlbWFpbmluZykucGFkU3RhcnQoNiwgXCIwXCIpfWA7XG4gIH1cbn07XG5cbi8vIHNyYy9saWIvdGltZXN0YW1wLnRzXG52YXIgVGltZXN0YW1wID0gY2xhc3MgX1RpbWVzdGFtcCB7XG4gIF9fdGltZXN0YW1wX21pY3Jvc19zaW5jZV91bml4X2Vwb2NoX187XG4gIHN0YXRpYyBNSUNST1NfUEVSX01JTExJUyA9IDEwMDBuO1xuICBnZXQgbWljcm9zU2luY2VVbml4RXBvY2goKSB7XG4gICAgcmV0dXJuIHRoaXMuX190aW1lc3RhbXBfbWljcm9zX3NpbmNlX3VuaXhfZXBvY2hfXztcbiAgfVxuICBjb25zdHJ1Y3RvcihtaWNyb3MpIHtcbiAgICB0aGlzLl9fdGltZXN0YW1wX21pY3Jvc19zaW5jZV91bml4X2Vwb2NoX18gPSBtaWNyb3M7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgYWxnZWJyYWljIHR5cGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIHtAbGluayBUaW1lc3RhbXB9IHR5cGUuXG4gICAqIEByZXR1cm5zIFRoZSBhbGdlYnJhaWMgdHlwZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgdHlwZS5cbiAgICovXG4gIHN0YXRpYyBnZXRBbGdlYnJhaWNUeXBlKCkge1xuICAgIHJldHVybiBBbGdlYnJhaWNUeXBlLlByb2R1Y3Qoe1xuICAgICAgZWxlbWVudHM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwiX190aW1lc3RhbXBfbWljcm9zX3NpbmNlX3VuaXhfZXBvY2hfX1wiLFxuICAgICAgICAgIGFsZ2VicmFpY1R5cGU6IEFsZ2VicmFpY1R5cGUuSTY0XG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgaXNUaW1lc3RhbXAoYWxnZWJyYWljVHlwZSkge1xuICAgIGlmIChhbGdlYnJhaWNUeXBlLnRhZyAhPT0gXCJQcm9kdWN0XCIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgZWxlbWVudHMgPSBhbGdlYnJhaWNUeXBlLnZhbHVlLmVsZW1lbnRzO1xuICAgIGlmIChlbGVtZW50cy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgbWljcm9zRWxlbWVudCA9IGVsZW1lbnRzWzBdO1xuICAgIHJldHVybiBtaWNyb3NFbGVtZW50Lm5hbWUgPT09IFwiX190aW1lc3RhbXBfbWljcm9zX3NpbmNlX3VuaXhfZXBvY2hfX1wiICYmIG1pY3Jvc0VsZW1lbnQuYWxnZWJyYWljVHlwZS50YWcgPT09IFwiSTY0XCI7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBVbml4IGVwb2NoLCB0aGUgbWlkbmlnaHQgYXQgdGhlIGJlZ2lubmluZyBvZiBKYW51YXJ5IDEsIDE5NzAsIFVUQy5cbiAgICovXG4gIHN0YXRpYyBVTklYX0VQT0NIID0gbmV3IF9UaW1lc3RhbXAoMG4pO1xuICAvKipcbiAgICogR2V0IGEgYFRpbWVzdGFtcGAgcmVwcmVzZW50aW5nIHRoZSBleGVjdXRpb24gZW52aXJvbm1lbnQncyBiZWxpZWYgb2YgdGhlIGN1cnJlbnQgbW9tZW50IGluIHRpbWUuXG4gICAqL1xuICBzdGF0aWMgbm93KCkge1xuICAgIHJldHVybiBfVGltZXN0YW1wLmZyb21EYXRlKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKTtcbiAgfVxuICAvKiogQ29udmVydCB0byBtaWxsaXNlY29uZHMgc2luY2UgVW5peCBlcG9jaC4gKi9cbiAgdG9NaWxsaXMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWljcm9zU2luY2VVbml4RXBvY2ggLyAxMDAwbjtcbiAgfVxuICAvKipcbiAgICogR2V0IGEgYFRpbWVzdGFtcGAgcmVwcmVzZW50aW5nIHRoZSBzYW1lIHBvaW50IGluIHRpbWUgYXMgYGRhdGVgLlxuICAgKi9cbiAgc3RhdGljIGZyb21EYXRlKGRhdGUpIHtcbiAgICBjb25zdCBtaWxsaXMgPSBkYXRlLmdldFRpbWUoKTtcbiAgICBjb25zdCBtaWNyb3MgPSBCaWdJbnQobWlsbGlzKSAqIF9UaW1lc3RhbXAuTUlDUk9TX1BFUl9NSUxMSVM7XG4gICAgcmV0dXJuIG5ldyBfVGltZXN0YW1wKG1pY3Jvcyk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhIGBEYXRlYCByZXByZXNlbnRpbmcgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBwb2ludCBpbiB0aW1lIGFzIGB0aGlzYC5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgdHJ1bmNhdGVzIHRvIG1pbGxpc2Vjb25kIHByZWNpc2lvbixcbiAgICogYW5kIHRocm93cyBgUmFuZ2VFcnJvcmAgaWYgdGhlIGBUaW1lc3RhbXBgIGlzIG91dHNpZGUgdGhlIHJhbmdlIHJlcHJlc2VudGFibGUgYXMgYSBgRGF0ZWAuXG4gICAqL1xuICB0b0RhdGUoKSB7XG4gICAgY29uc3QgbWljcm9zID0gdGhpcy5fX3RpbWVzdGFtcF9taWNyb3Nfc2luY2VfdW5peF9lcG9jaF9fO1xuICAgIGNvbnN0IG1pbGxpcyA9IG1pY3JvcyAvIF9UaW1lc3RhbXAuTUlDUk9TX1BFUl9NSUxMSVM7XG4gICAgaWYgKG1pbGxpcyA+IEJpZ0ludChOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikgfHwgbWlsbGlzIDwgQmlnSW50KE51bWJlci5NSU5fU0FGRV9JTlRFR0VSKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXG4gICAgICAgIFwiVGltZXN0YW1wIGlzIG91dHNpZGUgb2YgdGhlIHJlcHJlc2VudGFibGUgcmFuZ2Ugb2YgSlMncyBEYXRlXCJcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRGF0ZShOdW1iZXIobWlsbGlzKSk7XG4gIH1cbiAgc2luY2Uob3RoZXIpIHtcbiAgICByZXR1cm4gbmV3IFRpbWVEdXJhdGlvbihcbiAgICAgIHRoaXMuX190aW1lc3RhbXBfbWljcm9zX3NpbmNlX3VuaXhfZXBvY2hfXyAtIG90aGVyLl9fdGltZXN0YW1wX21pY3Jvc19zaW5jZV91bml4X2Vwb2NoX19cbiAgICApO1xuICB9XG59O1xuXG4vLyBzcmMvbGliL3V1aWQudHNcbnZhciBVdWlkID0gY2xhc3MgX1V1aWQge1xuICBfX3V1aWRfXztcbiAgLyoqXG4gICAqIFRoZSBuaWwgVVVJRCAoYWxsIHplcm9zKS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogY29uc3QgdXVpZCA9IFV1aWQuTklMO1xuICAgKiBjb25zb2xlLmFzc2VydChcbiAgICogICB1dWlkLnRvU3RyaW5nKCkgPT09IFwiMDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwXCJcbiAgICogKTtcbiAgICogYGBgXG4gICAqL1xuICBzdGF0aWMgTklMID0gbmV3IF9VdWlkKDBuKTtcbiAgc3RhdGljIE1BWF9VVUlEX0JJR0lOVCA9IDB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZuO1xuICAvKipcbiAgICogVGhlIG1heCBVVUlEIChhbGwgb25lcykuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIGNvbnN0IHV1aWQgPSBVdWlkLk1BWDtcbiAgICogY29uc29sZS5hc3NlcnQoXG4gICAqICAgdXVpZC50b1N0cmluZygpID09PSBcImZmZmZmZmZmLWZmZmYtZmZmZi1mZmZmLWZmZmZmZmZmZmZmZlwiXG4gICAqICk7XG4gICAqIGBgYFxuICAgKi9cbiAgc3RhdGljIE1BWCA9IG5ldyBfVXVpZChfVXVpZC5NQVhfVVVJRF9CSUdJTlQpO1xuICAvKipcbiAgICogQ3JlYXRlIGEgVVVJRCBmcm9tIGEgcmF3IDEyOC1iaXQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB1IC0gVW5zaWduZWQgMTI4LWJpdCBpbnRlZ2VyXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgdmFsdWUgaXMgb3V0c2lkZSB0aGUgdmFsaWQgVVVJRCByYW5nZVxuICAgKi9cbiAgY29uc3RydWN0b3IodSkge1xuICAgIGlmICh1IDwgMG4gfHwgdSA+IF9VdWlkLk1BWF9VVUlEX0JJR0lOVCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBVVUlEOiBtdXN0IGJlIGJldHdlZW4gMCBhbmQgYE1BWF9VVUlEX0JJR0lOVGBcIik7XG4gICAgfVxuICAgIHRoaXMuX191dWlkX18gPSB1O1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBVVUlEIGB2NGAgZnJvbSBleHBsaWNpdCByYW5kb20gYnl0ZXMuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGFzc3VtZXMgdGhlIGJ5dGVzIGFyZSBhbHJlYWR5IHN1ZmZpY2llbnRseSByYW5kb20uXG4gICAqIEl0IG9ubHkgc2V0cyB0aGUgYXBwcm9wcmlhdGUgYml0cyBmb3IgdGhlIFVVSUQgdmVyc2lvbiBhbmQgdmFyaWFudC5cbiAgICpcbiAgICogQHBhcmFtIGJ5dGVzIC0gRXhhY3RseSAxNiByYW5kb20gYnl0ZXNcbiAgICogQHJldHVybnMgQSBVVUlEIGB2NGBcbiAgICogQHRocm93cyB7RXJyb3J9IElmIGBieXRlcy5sZW5ndGggIT09IDE2YFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiBjb25zdCByYW5kb21CeXRlcyA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgICogY29uc3QgdXVpZCA9IFV1aWQuZnJvbVJhbmRvbUJ5dGVzVjQocmFuZG9tQnl0ZXMpO1xuICAgKlxuICAgKiBjb25zb2xlLmFzc2VydChcbiAgICogICB1dWlkLnRvU3RyaW5nKCkgPT09IFwiMDAwMDAwMDAtMDAwMC00MDAwLTgwMDAtMDAwMDAwMDAwMDAwXCJcbiAgICogKTtcbiAgICogYGBgXG4gICAqL1xuICBzdGF0aWMgZnJvbVJhbmRvbUJ5dGVzVjQoYnl0ZXMpIHtcbiAgICBpZiAoYnl0ZXMubGVuZ3RoICE9PSAxNikgdGhyb3cgbmV3IEVycm9yKFwiVVVJRCB2NCByZXF1aXJlcyAxNiBieXRlc1wiKTtcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheShieXRlcyk7XG4gICAgYXJyWzZdID0gYXJyWzZdICYgMTUgfCA2NDtcbiAgICBhcnJbOF0gPSBhcnJbOF0gJiA2MyB8IDEyODtcbiAgICByZXR1cm4gbmV3IF9VdWlkKF9VdWlkLmJ5dGVzVG9CaWdJbnQoYXJyKSk7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgVVVJRCBgdjdgIHVzaW5nIGEgbW9ub3RvbmljIGNvdW50ZXIgZnJvbSBgMGAgdG8gYDJeMzEgLSAxYCxcbiAgICogYSB0aW1lc3RhbXAsIGFuZCA0IHJhbmRvbSBieXRlcy5cbiAgICpcbiAgICogVGhlIGNvdW50ZXIgd3JhcHMgYXJvdW5kIG9uIG92ZXJmbG93LlxuICAgKlxuICAgKiBUaGUgVVVJRCBgdjdgIGlzIHN0cnVjdHVyZWQgYXMgZm9sbG93czpcbiAgICpcbiAgICogYGBgYXNjaWlcbiAgICog4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSs4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQXG4gICAqIHwgQjAgIHwgQjEgIHwgQjIgIHwgQjMgIHwgQjQgIHwgQjUgICAgICAgICAgICAgIHwgICAgICAgICBCNiAgICAgICAgfFxuICAgKiDilJzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKRcbiAgICogfCAgICAgICAgICAgICAgICAgdW5peF90c19tcyAgICAgICAgICAgICAgICAgICAgfCAgICAgIHZlcnNpb24gNyAgICB8XG4gICAqIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUtOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmFxuICAgKiDilIzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKzilIDilIDilIDilIDilIDilIDilIDilIDilIDilKzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJBcbiAgICogfCBCNyAgICAgICAgICAgfCBCOCAgICAgIHwgQjkgIHwgQjEwIHwgQjExICB8IEIxMiB8IEIxMyB8IEIxNCB8IEIxNSB8XG4gICAqIOKUnOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUpFxuICAgKiB8IGNvdW50ZXJfaGlnaCB8IHZhcmlhbnQgfCAgICBjb3VudGVyX2xvdyAgIHwgICAgICAgIHJhbmRvbSAgICAgICAgIHxcbiAgICog4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS04pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS04pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS04pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYXG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gY291bnRlciAtIE11dGFibGUgbW9ub3RvbmljIGNvdW50ZXIgKDMxLWJpdClcbiAgICogQHBhcmFtIG5vdyAtIFRpbWVzdGFtcCBzaW5jZSB0aGUgVW5peCBlcG9jaFxuICAgKiBAcGFyYW0gcmFuZG9tQnl0ZXMgLSBFeGFjdGx5IDQgcmFuZG9tIGJ5dGVzXG4gICAqIEByZXR1cm5zIEEgVVVJRCBgdjdgXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgYGNvdW50ZXJgIGlzIG5lZ2F0aXZlXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgYHRpbWVzdGFtcGAgaXMgYmVmb3JlIHRoZSBVbml4IGVwb2NoXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBgcmFuZG9tQnl0ZXMubGVuZ3RoICE9PSA0YFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiBjb25zdCBub3cgPSBUaW1lc3RhbXAuZnJvbU1pbGxpcygxXzY4Nl8wMDBfMDAwXzAwMG4pO1xuICAgKiBjb25zdCBjb3VudGVyID0geyB2YWx1ZTogMSB9O1xuICAgKiBjb25zdCByYW5kb21CeXRlcyA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgKlxuICAgKiBjb25zdCB1dWlkID0gVXVpZC5mcm9tQ291bnRlclY3KGNvdW50ZXIsIG5vdywgcmFuZG9tQnl0ZXMpO1xuICAgKlxuICAgKiBjb25zb2xlLmFzc2VydChcbiAgICogICB1dWlkLnRvU3RyaW5nKCkgPT09IFwiMDAwMDY0N2UtNTE4MC03MDAwLTgwMDAtMDAwMjAwMDAwMDAwXCJcbiAgICogKTtcbiAgICogYGBgXG4gICAqL1xuICBzdGF0aWMgZnJvbUNvdW50ZXJWNyhjb3VudGVyLCBub3csIHJhbmRvbUJ5dGVzKSB7XG4gICAgaWYgKHJhbmRvbUJ5dGVzLmxlbmd0aCAhPT0gNCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYGZyb21Db3VudGVyVjdgIHJlcXVpcmVzIGByYW5kb21CeXRlcy5sZW5ndGggPT0gNGBcIik7XG4gICAgfVxuICAgIGlmIChjb3VudGVyLnZhbHVlIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYGZyb21Db3VudGVyVjdgIHV1aWQgYGNvdW50ZXJgIG11c3QgYmUgbm9uLW5lZ2F0aXZlXCIpO1xuICAgIH1cbiAgICBpZiAobm93Ll9fdGltZXN0YW1wX21pY3Jvc19zaW5jZV91bml4X2Vwb2NoX18gPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgZnJvbUNvdW50ZXJWN2AgYHRpbWVzdGFtcGAgYmVmb3JlIHVuaXggZXBvY2hcIik7XG4gICAgfVxuICAgIGNvbnN0IGNvdW50ZXJWYWwgPSBjb3VudGVyLnZhbHVlO1xuICAgIGNvdW50ZXIudmFsdWUgPSBjb3VudGVyVmFsICsgMSAmIDIxNDc0ODM2NDc7XG4gICAgY29uc3QgdHNNcyA9IG5vdy50b01pbGxpcygpICYgMHhmZmZmZmZmZmZmZmZuO1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICAgIGJ5dGVzWzBdID0gTnVtYmVyKHRzTXMgPj4gNDBuICYgMHhmZm4pO1xuICAgIGJ5dGVzWzFdID0gTnVtYmVyKHRzTXMgPj4gMzJuICYgMHhmZm4pO1xuICAgIGJ5dGVzWzJdID0gTnVtYmVyKHRzTXMgPj4gMjRuICYgMHhmZm4pO1xuICAgIGJ5dGVzWzNdID0gTnVtYmVyKHRzTXMgPj4gMTZuICYgMHhmZm4pO1xuICAgIGJ5dGVzWzRdID0gTnVtYmVyKHRzTXMgPj4gOG4gJiAweGZmbik7XG4gICAgYnl0ZXNbNV0gPSBOdW1iZXIodHNNcyAmIDB4ZmZuKTtcbiAgICBieXRlc1s3XSA9IGNvdW50ZXJWYWwgPj4+IDIzICYgMjU1O1xuICAgIGJ5dGVzWzldID0gY291bnRlclZhbCA+Pj4gMTUgJiAyNTU7XG4gICAgYnl0ZXNbMTBdID0gY291bnRlclZhbCA+Pj4gNyAmIDI1NTtcbiAgICBieXRlc1sxMV0gPSAoY291bnRlclZhbCAmIDEyNykgPDwgMSAmIDI1NTtcbiAgICBieXRlc1sxMl0gfD0gcmFuZG9tQnl0ZXNbMF0gJiAxMjc7XG4gICAgYnl0ZXNbMTNdID0gcmFuZG9tQnl0ZXNbMV07XG4gICAgYnl0ZXNbMTRdID0gcmFuZG9tQnl0ZXNbMl07XG4gICAgYnl0ZXNbMTVdID0gcmFuZG9tQnl0ZXNbM107XG4gICAgYnl0ZXNbNl0gPSBieXRlc1s2XSAmIDE1IHwgMTEyO1xuICAgIGJ5dGVzWzhdID0gYnl0ZXNbOF0gJiA2MyB8IDEyODtcbiAgICByZXR1cm4gbmV3IF9VdWlkKF9VdWlkLmJ5dGVzVG9CaWdJbnQoYnl0ZXMpKTtcbiAgfVxuICAvKipcbiAgICogUGFyc2UgYSBVVUlEIGZyb20gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSBzIC0gVVVJRCBzdHJpbmdcbiAgICogQHJldHVybnMgUGFyc2VkIFVVSURcbiAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBzdHJpbmcgaXMgbm90IGEgdmFsaWQgVVVJRFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiBjb25zdCBzID0gXCIwMTg4OGQ2ZS01YzAwLTcwMDAtODAwMC0wMDAwMDAwMDAwMDBcIjtcbiAgICogY29uc3QgdXVpZCA9IFV1aWQucGFyc2Uocyk7XG4gICAqXG4gICAqIGNvbnNvbGUuYXNzZXJ0KHV1aWQudG9TdHJpbmcoKSA9PT0gcyk7XG4gICAqIGBgYFxuICAgKi9cbiAgc3RhdGljIHBhcnNlKHMpIHtcbiAgICBjb25zdCBoZXggPSBzLnJlcGxhY2UoLy0vZywgXCJcIik7XG4gICAgaWYgKGhleC5sZW5ndGggIT09IDMyKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGhleCBVVUlEXCIpO1xuICAgIGxldCB2ID0gMG47XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzMjsgaSArPSAyKSB7XG4gICAgICB2ID0gdiA8PCA4biB8IEJpZ0ludChwYXJzZUludChoZXguc2xpY2UoaSwgaSArIDIpLCAxNikpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IF9VdWlkKHYpO1xuICB9XG4gIC8qKiBDb252ZXJ0IHRvIHN0cmluZyAoaHlwaGVuYXRlZCBmb3JtKS4gKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBfVXVpZC5iaWdJbnRUb0J5dGVzKHRoaXMuX191dWlkX18pO1xuICAgIGNvbnN0IGhleCA9IFsuLi5ieXRlc10ubWFwKChiKSA9PiBiLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIikpLmpvaW4oXCJcIik7XG4gICAgcmV0dXJuIGhleC5zbGljZSgwLCA4KSArIFwiLVwiICsgaGV4LnNsaWNlKDgsIDEyKSArIFwiLVwiICsgaGV4LnNsaWNlKDEyLCAxNikgKyBcIi1cIiArIGhleC5zbGljZSgxNiwgMjApICsgXCItXCIgKyBoZXguc2xpY2UoMjApO1xuICB9XG4gIC8qKiBDb252ZXJ0IHRvIGJpZ2ludCAodTEyOCkuICovXG4gIGFzQmlnSW50KCkge1xuICAgIHJldHVybiB0aGlzLl9fdXVpZF9fO1xuICB9XG4gIC8qKiBSZXR1cm4gYSBgVWludDhBcnJheWAgb2YgMTYgYnl0ZXMuICovXG4gIHRvQnl0ZXMoKSB7XG4gICAgcmV0dXJuIF9VdWlkLmJpZ0ludFRvQnl0ZXModGhpcy5fX3V1aWRfXyk7XG4gIH1cbiAgc3RhdGljIGJ5dGVzVG9CaWdJbnQoYnl0ZXMpIHtcbiAgICBsZXQgcmVzdWx0ID0gMG47XG4gICAgZm9yIChjb25zdCBiIG9mIGJ5dGVzKSByZXN1bHQgPSByZXN1bHQgPDwgOG4gfCBCaWdJbnQoYik7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBzdGF0aWMgYmlnSW50VG9CeXRlcyh2YWx1ZSkge1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICAgIGZvciAobGV0IGkgPSAxNTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGJ5dGVzW2ldID0gTnVtYmVyKHZhbHVlICYgMHhmZm4pO1xuICAgICAgdmFsdWUgPj49IDhuO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHZlcnNpb24gb2YgdGhpcyBVVUlELlxuICAgKlxuICAgKiBUaGlzIHJlcHJlc2VudHMgdGhlIGFsZ29yaXRobSB1c2VkIHRvIGdlbmVyYXRlIHRoZSB2YWx1ZS5cbiAgICpcbiAgICogQHJldHVybnMgQSBgVXVpZFZlcnNpb25gXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgdmVyc2lvbiBmaWVsZCBpcyBub3QgcmVjb2duaXplZFxuICAgKi9cbiAgZ2V0VmVyc2lvbigpIHtcbiAgICBjb25zdCB2ZXJzaW9uID0gdGhpcy50b0J5dGVzKClbNl0gPj4gNCAmIDE1O1xuICAgIHN3aXRjaCAodmVyc2lvbikge1xuICAgICAgY2FzZSA0OlxuICAgICAgICByZXR1cm4gXCJWNFwiO1xuICAgICAgY2FzZSA3OlxuICAgICAgICByZXR1cm4gXCJWN1wiO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHRoaXMgPT0gX1V1aWQuTklMKSB7XG4gICAgICAgICAgcmV0dXJuIFwiTmlsXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMgPT0gX1V1aWQuTUFYKSB7XG4gICAgICAgICAgcmV0dXJuIFwiTWF4XCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBVVUlEIHZlcnNpb246ICR7dmVyc2lvbn1gKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEV4dHJhY3QgdGhlIG1vbm90b25pYyBjb3VudGVyIGZyb20gYSBVVUlEdjcuXG4gICAqXG4gICAqIEludGVuZGVkIGZvciB0ZXN0aW5nIGFuZCBkaWFnbm9zdGljcy5cbiAgICogQmVoYXZpb3IgaXMgdW5kZWZpbmVkIGlmIGNhbGxlZCBvbiBhIG5vbi1WNyBVVUlELlxuICAgKlxuICAgKiBAcmV0dXJucyAzMS1iaXQgY291bnRlciB2YWx1ZVxuICAgKi9cbiAgZ2V0Q291bnRlcigpIHtcbiAgICBjb25zdCBieXRlcyA9IHRoaXMudG9CeXRlcygpO1xuICAgIGNvbnN0IGhpZ2ggPSBieXRlc1s3XTtcbiAgICBjb25zdCBtaWQxID0gYnl0ZXNbOV07XG4gICAgY29uc3QgbWlkMiA9IGJ5dGVzWzEwXTtcbiAgICBjb25zdCBsb3cgPSBieXRlc1sxMV0gPj4+IDE7XG4gICAgcmV0dXJuIGhpZ2ggPDwgMjMgfCBtaWQxIDw8IDE1IHwgbWlkMiA8PCA3IHwgbG93IHwgMDtcbiAgfVxuICBjb21wYXJlVG8ob3RoZXIpIHtcbiAgICBpZiAodGhpcy5fX3V1aWRfXyA8IG90aGVyLl9fdXVpZF9fKSByZXR1cm4gLTE7XG4gICAgaWYgKHRoaXMuX191dWlkX18gPiBvdGhlci5fX3V1aWRfXykgcmV0dXJuIDE7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgc3RhdGljIGdldEFsZ2VicmFpY1R5cGUoKSB7XG4gICAgcmV0dXJuIEFsZ2VicmFpY1R5cGUuUHJvZHVjdCh7XG4gICAgICBlbGVtZW50czogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJfX3V1aWRfX1wiLFxuICAgICAgICAgIGFsZ2VicmFpY1R5cGU6IEFsZ2VicmFpY1R5cGUuVTEyOFxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIHNyYy9saWIvYmluYXJ5X3JlYWRlci50c1xudmFyIEJpbmFyeVJlYWRlciA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIFRoZSBEYXRhVmlldyB1c2VkIHRvIHJlYWQgdmFsdWVzIGZyb20gdGhlIGJpbmFyeSBkYXRhLlxuICAgKlxuICAgKiBOb3RlOiBUaGUgRGF0YVZpZXcncyBgYnl0ZU9mZnNldGAgaXMgcmVsYXRpdmUgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGVcbiAgICogdW5kZXJseWluZyBBcnJheUJ1ZmZlciwgbm90IHRoZSBzdGFydCBvZiB0aGUgcHJvdmlkZWQgVWludDhBcnJheSBpbnB1dC5cbiAgICogVGhpcyBgQmluYXJ5UmVhZGVyYCdzIGAjb2Zmc2V0YCBmaWVsZCBpcyB1c2VkIHRvIHRyYWNrIHRoZSBjdXJyZW50IHJlYWQgcG9zaXRpb25cbiAgICogcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoZSBwcm92aWRlZCBVaW50OEFycmF5IGlucHV0LlxuICAgKi9cbiAgI3ZpZXc7XG4gIC8qKlxuICAgKiBSZXByZXNlbnRzIHRoZSBvZmZzZXQgKGluIGJ5dGVzKSByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIERhdGFWaWV3XG4gICAqIGFuZCBwcm92aWRlZCBVaW50OEFycmF5IGlucHV0LlxuICAgKlxuICAgKiBOb3RlOiBUaGlzIGlzICpub3QqIHRoZSBhYnNvbHV0ZSBieXRlIG9mZnNldCB3aXRoaW4gdGhlIHVuZGVybHlpbmcgQXJyYXlCdWZmZXIuXG4gICAqL1xuICAjb2Zmc2V0ID0gMDtcbiAgY29uc3RydWN0b3IoaW5wdXQpIHtcbiAgICB0aGlzLiN2aWV3ID0gbmV3IERhdGFWaWV3KGlucHV0LmJ1ZmZlciwgaW5wdXQuYnl0ZU9mZnNldCwgaW5wdXQuYnl0ZUxlbmd0aCk7XG4gICAgdGhpcy4jb2Zmc2V0ID0gMDtcbiAgfVxuICBnZXQgb2Zmc2V0KCkge1xuICAgIHJldHVybiB0aGlzLiNvZmZzZXQ7XG4gIH1cbiAgZ2V0IHJlbWFpbmluZygpIHtcbiAgICByZXR1cm4gdGhpcy4jdmlldy5ieXRlTGVuZ3RoIC0gdGhpcy4jb2Zmc2V0O1xuICB9XG4gIC8qKiBFbnN1cmUgd2UgaGF2ZSBhdCBsZWFzdCBgbmAgYnl0ZXMgbGVmdCB0byByZWFkICovXG4gICNlbnN1cmUobikge1xuICAgIGlmICh0aGlzLiNvZmZzZXQgKyBuID4gdGhpcy4jdmlldy5ieXRlTGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcbiAgICAgICAgYFRyaWVkIHRvIHJlYWQgJHtufSBieXRlKHMpIGF0IHJlbGF0aXZlIG9mZnNldCAke3RoaXMuI29mZnNldH0sIGJ1dCBvbmx5ICR7dGhpcy5yZW1haW5pbmd9IGJ5dGUocykgcmVtYWluYFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmVhZFVJbnQ4QXJyYXkoKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gdGhpcy5yZWFkVTMyKCk7XG4gICAgdGhpcy4jZW5zdXJlKGxlbmd0aCk7XG4gICAgcmV0dXJuIHRoaXMucmVhZEJ5dGVzKGxlbmd0aCk7XG4gIH1cbiAgcmVhZEJvb2woKSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLiN2aWV3LmdldFVpbnQ4KHRoaXMuI29mZnNldCk7XG4gICAgdGhpcy4jb2Zmc2V0ICs9IDE7XG4gICAgcmV0dXJuIHZhbHVlICE9PSAwO1xuICB9XG4gIHJlYWRCeXRlKCkge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jdmlldy5nZXRVaW50OCh0aGlzLiNvZmZzZXQpO1xuICAgIHRoaXMuI29mZnNldCArPSAxO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZWFkQnl0ZXMobGVuZ3RoKSB7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShcbiAgICAgIHRoaXMuI3ZpZXcuYnVmZmVyLFxuICAgICAgdGhpcy4jdmlldy5ieXRlT2Zmc2V0ICsgdGhpcy4jb2Zmc2V0LFxuICAgICAgbGVuZ3RoXG4gICAgKTtcbiAgICB0aGlzLiNvZmZzZXQgKz0gbGVuZ3RoO1xuICAgIHJldHVybiBhcnJheTtcbiAgfVxuICByZWFkSTgoKSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLiN2aWV3LmdldEludDgodGhpcy4jb2Zmc2V0KTtcbiAgICB0aGlzLiNvZmZzZXQgKz0gMTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmVhZFU4KCkge1xuICAgIHJldHVybiB0aGlzLnJlYWRCeXRlKCk7XG4gIH1cbiAgcmVhZEkxNigpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI3ZpZXcuZ2V0SW50MTYodGhpcy4jb2Zmc2V0LCB0cnVlKTtcbiAgICB0aGlzLiNvZmZzZXQgKz0gMjtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmVhZFUxNigpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI3ZpZXcuZ2V0VWludDE2KHRoaXMuI29mZnNldCwgdHJ1ZSk7XG4gICAgdGhpcy4jb2Zmc2V0ICs9IDI7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJlYWRJMzIoKSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLiN2aWV3LmdldEludDMyKHRoaXMuI29mZnNldCwgdHJ1ZSk7XG4gICAgdGhpcy4jb2Zmc2V0ICs9IDQ7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJlYWRVMzIoKSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLiN2aWV3LmdldFVpbnQzMih0aGlzLiNvZmZzZXQsIHRydWUpO1xuICAgIHRoaXMuI29mZnNldCArPSA0O1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZWFkSTY0KCkge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jdmlldy5nZXRCaWdJbnQ2NCh0aGlzLiNvZmZzZXQsIHRydWUpO1xuICAgIHRoaXMuI29mZnNldCArPSA4O1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZWFkVTY0KCkge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jdmlldy5nZXRCaWdVaW50NjQodGhpcy4jb2Zmc2V0LCB0cnVlKTtcbiAgICB0aGlzLiNvZmZzZXQgKz0gODtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmVhZFUxMjgoKSB7XG4gICAgY29uc3QgbG93ZXJQYXJ0ID0gdGhpcy4jdmlldy5nZXRCaWdVaW50NjQodGhpcy4jb2Zmc2V0LCB0cnVlKTtcbiAgICBjb25zdCB1cHBlclBhcnQgPSB0aGlzLiN2aWV3LmdldEJpZ1VpbnQ2NCh0aGlzLiNvZmZzZXQgKyA4LCB0cnVlKTtcbiAgICB0aGlzLiNvZmZzZXQgKz0gMTY7XG4gICAgcmV0dXJuICh1cHBlclBhcnQgPDwgQmlnSW50KDY0KSkgKyBsb3dlclBhcnQ7XG4gIH1cbiAgcmVhZEkxMjgoKSB7XG4gICAgY29uc3QgbG93ZXJQYXJ0ID0gdGhpcy4jdmlldy5nZXRCaWdVaW50NjQodGhpcy4jb2Zmc2V0LCB0cnVlKTtcbiAgICBjb25zdCB1cHBlclBhcnQgPSB0aGlzLiN2aWV3LmdldEJpZ0ludDY0KHRoaXMuI29mZnNldCArIDgsIHRydWUpO1xuICAgIHRoaXMuI29mZnNldCArPSAxNjtcbiAgICByZXR1cm4gKHVwcGVyUGFydCA8PCBCaWdJbnQoNjQpKSArIGxvd2VyUGFydDtcbiAgfVxuICByZWFkVTI1NigpIHtcbiAgICBjb25zdCBwMCA9IHRoaXMuI3ZpZXcuZ2V0QmlnVWludDY0KHRoaXMuI29mZnNldCwgdHJ1ZSk7XG4gICAgY29uc3QgcDEgPSB0aGlzLiN2aWV3LmdldEJpZ1VpbnQ2NCh0aGlzLiNvZmZzZXQgKyA4LCB0cnVlKTtcbiAgICBjb25zdCBwMiA9IHRoaXMuI3ZpZXcuZ2V0QmlnVWludDY0KHRoaXMuI29mZnNldCArIDE2LCB0cnVlKTtcbiAgICBjb25zdCBwMyA9IHRoaXMuI3ZpZXcuZ2V0QmlnVWludDY0KHRoaXMuI29mZnNldCArIDI0LCB0cnVlKTtcbiAgICB0aGlzLiNvZmZzZXQgKz0gMzI7XG4gICAgcmV0dXJuIChwMyA8PCBCaWdJbnQoMyAqIDY0KSkgKyAocDIgPDwgQmlnSW50KDIgKiA2NCkpICsgKHAxIDw8IEJpZ0ludCgxICogNjQpKSArIHAwO1xuICB9XG4gIHJlYWRJMjU2KCkge1xuICAgIGNvbnN0IHAwID0gdGhpcy4jdmlldy5nZXRCaWdVaW50NjQodGhpcy4jb2Zmc2V0LCB0cnVlKTtcbiAgICBjb25zdCBwMSA9IHRoaXMuI3ZpZXcuZ2V0QmlnVWludDY0KHRoaXMuI29mZnNldCArIDgsIHRydWUpO1xuICAgIGNvbnN0IHAyID0gdGhpcy4jdmlldy5nZXRCaWdVaW50NjQodGhpcy4jb2Zmc2V0ICsgMTYsIHRydWUpO1xuICAgIGNvbnN0IHAzID0gdGhpcy4jdmlldy5nZXRCaWdJbnQ2NCh0aGlzLiNvZmZzZXQgKyAyNCwgdHJ1ZSk7XG4gICAgdGhpcy4jb2Zmc2V0ICs9IDMyO1xuICAgIHJldHVybiAocDMgPDwgQmlnSW50KDMgKiA2NCkpICsgKHAyIDw8IEJpZ0ludCgyICogNjQpKSArIChwMSA8PCBCaWdJbnQoMSAqIDY0KSkgKyBwMDtcbiAgfVxuICByZWFkRjMyKCkge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jdmlldy5nZXRGbG9hdDMyKHRoaXMuI29mZnNldCwgdHJ1ZSk7XG4gICAgdGhpcy4jb2Zmc2V0ICs9IDQ7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJlYWRGNjQoKSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLiN2aWV3LmdldEZsb2F0NjQodGhpcy4jb2Zmc2V0LCB0cnVlKTtcbiAgICB0aGlzLiNvZmZzZXQgKz0gODtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmVhZFN0cmluZygpIHtcbiAgICBjb25zdCB1aW50OEFycmF5ID0gdGhpcy5yZWFkVUludDhBcnJheSgpO1xuICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoXCJ1dGYtOFwiKS5kZWNvZGUodWludDhBcnJheSk7XG4gIH1cbn07XG5cbi8vIHNyYy9saWIvYmluYXJ5X3dyaXRlci50c1xudmFyIGltcG9ydF9iYXNlNjRfanMgPSBfX3RvRVNNKHJlcXVpcmVfYmFzZTY0X2pzKCkpO1xudmFyIEJpbmFyeVdyaXRlciA9IGNsYXNzIHtcbiAgI2J1ZmZlcjtcbiAgI3ZpZXc7XG4gICNvZmZzZXQgPSAwO1xuICBjb25zdHJ1Y3RvcihzaXplKSB7XG4gICAgdGhpcy4jYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gICAgdGhpcy4jdmlldyA9IG5ldyBEYXRhVmlldyh0aGlzLiNidWZmZXIuYnVmZmVyKTtcbiAgfVxuICAjZXhwYW5kQnVmZmVyKGFkZGl0aW9uYWxDYXBhY2l0eSkge1xuICAgIGNvbnN0IG1pbkNhcGFjaXR5ID0gdGhpcy4jb2Zmc2V0ICsgYWRkaXRpb25hbENhcGFjaXR5ICsgMTtcbiAgICBpZiAobWluQ2FwYWNpdHkgPD0gdGhpcy4jYnVmZmVyLmxlbmd0aCkgcmV0dXJuO1xuICAgIGxldCBuZXdDYXBhY2l0eSA9IHRoaXMuI2J1ZmZlci5sZW5ndGggKiAyO1xuICAgIGlmIChuZXdDYXBhY2l0eSA8IG1pbkNhcGFjaXR5KSBuZXdDYXBhY2l0eSA9IG1pbkNhcGFjaXR5O1xuICAgIGNvbnN0IG5ld0J1ZmZlciA9IG5ldyBVaW50OEFycmF5KG5ld0NhcGFjaXR5KTtcbiAgICBuZXdCdWZmZXIuc2V0KHRoaXMuI2J1ZmZlcik7XG4gICAgdGhpcy4jYnVmZmVyID0gbmV3QnVmZmVyO1xuICAgIHRoaXMuI3ZpZXcgPSBuZXcgRGF0YVZpZXcodGhpcy4jYnVmZmVyLmJ1ZmZlcik7XG4gIH1cbiAgdG9CYXNlNjQoKSB7XG4gICAgcmV0dXJuICgwLCBpbXBvcnRfYmFzZTY0X2pzLmZyb21CeXRlQXJyYXkpKHRoaXMuI2J1ZmZlci5zdWJhcnJheSgwLCB0aGlzLiNvZmZzZXQpKTtcbiAgfVxuICBnZXRCdWZmZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2J1ZmZlci5zbGljZSgwLCB0aGlzLiNvZmZzZXQpO1xuICB9XG4gIGdldCBvZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI29mZnNldDtcbiAgfVxuICB3cml0ZVVJbnQ4QXJyYXkodmFsdWUpIHtcbiAgICBjb25zdCBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG4gICAgdGhpcy4jZXhwYW5kQnVmZmVyKDQgKyBsZW5ndGgpO1xuICAgIHRoaXMud3JpdGVVMzIobGVuZ3RoKTtcbiAgICB0aGlzLiNidWZmZXIuc2V0KHZhbHVlLCB0aGlzLiNvZmZzZXQpO1xuICAgIHRoaXMuI29mZnNldCArPSB2YWx1ZS5sZW5ndGg7XG4gIH1cbiAgd3JpdGVCb29sKHZhbHVlKSB7XG4gICAgdGhpcy4jZXhwYW5kQnVmZmVyKDEpO1xuICAgIHRoaXMuI3ZpZXcuc2V0VWludDgodGhpcy4jb2Zmc2V0LCB2YWx1ZSA/IDEgOiAwKTtcbiAgICB0aGlzLiNvZmZzZXQgKz0gMTtcbiAgfVxuICB3cml0ZUJ5dGUodmFsdWUpIHtcbiAgICB0aGlzLiNleHBhbmRCdWZmZXIoMSk7XG4gICAgdGhpcy4jdmlldy5zZXRVaW50OCh0aGlzLiNvZmZzZXQsIHZhbHVlKTtcbiAgICB0aGlzLiNvZmZzZXQgKz0gMTtcbiAgfVxuICB3cml0ZUk4KHZhbHVlKSB7XG4gICAgdGhpcy4jZXhwYW5kQnVmZmVyKDEpO1xuICAgIHRoaXMuI3ZpZXcuc2V0SW50OCh0aGlzLiNvZmZzZXQsIHZhbHVlKTtcbiAgICB0aGlzLiNvZmZzZXQgKz0gMTtcbiAgfVxuICB3cml0ZVU4KHZhbHVlKSB7XG4gICAgdGhpcy4jZXhwYW5kQnVmZmVyKDEpO1xuICAgIHRoaXMuI3ZpZXcuc2V0VWludDgodGhpcy4jb2Zmc2V0LCB2YWx1ZSk7XG4gICAgdGhpcy4jb2Zmc2V0ICs9IDE7XG4gIH1cbiAgd3JpdGVJMTYodmFsdWUpIHtcbiAgICB0aGlzLiNleHBhbmRCdWZmZXIoMik7XG4gICAgdGhpcy4jdmlldy5zZXRJbnQxNih0aGlzLiNvZmZzZXQsIHZhbHVlLCB0cnVlKTtcbiAgICB0aGlzLiNvZmZzZXQgKz0gMjtcbiAgfVxuICB3cml0ZVUxNih2YWx1ZSkge1xuICAgIHRoaXMuI2V4cGFuZEJ1ZmZlcigyKTtcbiAgICB0aGlzLiN2aWV3LnNldFVpbnQxNih0aGlzLiNvZmZzZXQsIHZhbHVlLCB0cnVlKTtcbiAgICB0aGlzLiNvZmZzZXQgKz0gMjtcbiAgfVxuICB3cml0ZUkzMih2YWx1ZSkge1xuICAgIHRoaXMuI2V4cGFuZEJ1ZmZlcig0KTtcbiAgICB0aGlzLiN2aWV3LnNldEludDMyKHRoaXMuI29mZnNldCwgdmFsdWUsIHRydWUpO1xuICAgIHRoaXMuI29mZnNldCArPSA0O1xuICB9XG4gIHdyaXRlVTMyKHZhbHVlKSB7XG4gICAgdGhpcy4jZXhwYW5kQnVmZmVyKDQpO1xuICAgIHRoaXMuI3ZpZXcuc2V0VWludDMyKHRoaXMuI29mZnNldCwgdmFsdWUsIHRydWUpO1xuICAgIHRoaXMuI29mZnNldCArPSA0O1xuICB9XG4gIHdyaXRlSTY0KHZhbHVlKSB7XG4gICAgdGhpcy4jZXhwYW5kQnVmZmVyKDgpO1xuICAgIHRoaXMuI3ZpZXcuc2V0QmlnSW50NjQodGhpcy4jb2Zmc2V0LCB2YWx1ZSwgdHJ1ZSk7XG4gICAgdGhpcy4jb2Zmc2V0ICs9IDg7XG4gIH1cbiAgd3JpdGVVNjQodmFsdWUpIHtcbiAgICB0aGlzLiNleHBhbmRCdWZmZXIoOCk7XG4gICAgdGhpcy4jdmlldy5zZXRCaWdVaW50NjQodGhpcy4jb2Zmc2V0LCB2YWx1ZSwgdHJ1ZSk7XG4gICAgdGhpcy4jb2Zmc2V0ICs9IDg7XG4gIH1cbiAgd3JpdGVVMTI4KHZhbHVlKSB7XG4gICAgdGhpcy4jZXhwYW5kQnVmZmVyKDE2KTtcbiAgICBjb25zdCBsb3dlclBhcnQgPSB2YWx1ZSAmIEJpZ0ludChcIjB4RkZGRkZGRkZGRkZGRkZGRlwiKTtcbiAgICBjb25zdCB1cHBlclBhcnQgPSB2YWx1ZSA+PiBCaWdJbnQoNjQpO1xuICAgIHRoaXMuI3ZpZXcuc2V0QmlnVWludDY0KHRoaXMuI29mZnNldCwgbG93ZXJQYXJ0LCB0cnVlKTtcbiAgICB0aGlzLiN2aWV3LnNldEJpZ1VpbnQ2NCh0aGlzLiNvZmZzZXQgKyA4LCB1cHBlclBhcnQsIHRydWUpO1xuICAgIHRoaXMuI29mZnNldCArPSAxNjtcbiAgfVxuICB3cml0ZUkxMjgodmFsdWUpIHtcbiAgICB0aGlzLiNleHBhbmRCdWZmZXIoMTYpO1xuICAgIGNvbnN0IGxvd2VyUGFydCA9IHZhbHVlICYgQmlnSW50KFwiMHhGRkZGRkZGRkZGRkZGRkZGXCIpO1xuICAgIGNvbnN0IHVwcGVyUGFydCA9IHZhbHVlID4+IEJpZ0ludCg2NCk7XG4gICAgdGhpcy4jdmlldy5zZXRCaWdJbnQ2NCh0aGlzLiNvZmZzZXQsIGxvd2VyUGFydCwgdHJ1ZSk7XG4gICAgdGhpcy4jdmlldy5zZXRCaWdJbnQ2NCh0aGlzLiNvZmZzZXQgKyA4LCB1cHBlclBhcnQsIHRydWUpO1xuICAgIHRoaXMuI29mZnNldCArPSAxNjtcbiAgfVxuICB3cml0ZVUyNTYodmFsdWUpIHtcbiAgICB0aGlzLiNleHBhbmRCdWZmZXIoMzIpO1xuICAgIGNvbnN0IGxvd182NF9tYXNrID0gQmlnSW50KFwiMHhGRkZGRkZGRkZGRkZGRkZGXCIpO1xuICAgIGNvbnN0IHAwID0gdmFsdWUgJiBsb3dfNjRfbWFzaztcbiAgICBjb25zdCBwMSA9IHZhbHVlID4+IEJpZ0ludCg2NCAqIDEpICYgbG93XzY0X21hc2s7XG4gICAgY29uc3QgcDIgPSB2YWx1ZSA+PiBCaWdJbnQoNjQgKiAyKSAmIGxvd182NF9tYXNrO1xuICAgIGNvbnN0IHAzID0gdmFsdWUgPj4gQmlnSW50KDY0ICogMyk7XG4gICAgdGhpcy4jdmlldy5zZXRCaWdVaW50NjQodGhpcy4jb2Zmc2V0ICsgOCAqIDAsIHAwLCB0cnVlKTtcbiAgICB0aGlzLiN2aWV3LnNldEJpZ1VpbnQ2NCh0aGlzLiNvZmZzZXQgKyA4ICogMSwgcDEsIHRydWUpO1xuICAgIHRoaXMuI3ZpZXcuc2V0QmlnVWludDY0KHRoaXMuI29mZnNldCArIDggKiAyLCBwMiwgdHJ1ZSk7XG4gICAgdGhpcy4jdmlldy5zZXRCaWdVaW50NjQodGhpcy4jb2Zmc2V0ICsgOCAqIDMsIHAzLCB0cnVlKTtcbiAgICB0aGlzLiNvZmZzZXQgKz0gMzI7XG4gIH1cbiAgd3JpdGVJMjU2KHZhbHVlKSB7XG4gICAgdGhpcy4jZXhwYW5kQnVmZmVyKDMyKTtcbiAgICBjb25zdCBsb3dfNjRfbWFzayA9IEJpZ0ludChcIjB4RkZGRkZGRkZGRkZGRkZGRlwiKTtcbiAgICBjb25zdCBwMCA9IHZhbHVlICYgbG93XzY0X21hc2s7XG4gICAgY29uc3QgcDEgPSB2YWx1ZSA+PiBCaWdJbnQoNjQgKiAxKSAmIGxvd182NF9tYXNrO1xuICAgIGNvbnN0IHAyID0gdmFsdWUgPj4gQmlnSW50KDY0ICogMikgJiBsb3dfNjRfbWFzaztcbiAgICBjb25zdCBwMyA9IHZhbHVlID4+IEJpZ0ludCg2NCAqIDMpO1xuICAgIHRoaXMuI3ZpZXcuc2V0QmlnVWludDY0KHRoaXMuI29mZnNldCArIDggKiAwLCBwMCwgdHJ1ZSk7XG4gICAgdGhpcy4jdmlldy5zZXRCaWdVaW50NjQodGhpcy4jb2Zmc2V0ICsgOCAqIDEsIHAxLCB0cnVlKTtcbiAgICB0aGlzLiN2aWV3LnNldEJpZ1VpbnQ2NCh0aGlzLiNvZmZzZXQgKyA4ICogMiwgcDIsIHRydWUpO1xuICAgIHRoaXMuI3ZpZXcuc2V0QmlnSW50NjQodGhpcy4jb2Zmc2V0ICsgOCAqIDMsIHAzLCB0cnVlKTtcbiAgICB0aGlzLiNvZmZzZXQgKz0gMzI7XG4gIH1cbiAgd3JpdGVGMzIodmFsdWUpIHtcbiAgICB0aGlzLiNleHBhbmRCdWZmZXIoNCk7XG4gICAgdGhpcy4jdmlldy5zZXRGbG9hdDMyKHRoaXMuI29mZnNldCwgdmFsdWUsIHRydWUpO1xuICAgIHRoaXMuI29mZnNldCArPSA0O1xuICB9XG4gIHdyaXRlRjY0KHZhbHVlKSB7XG4gICAgdGhpcy4jZXhwYW5kQnVmZmVyKDgpO1xuICAgIHRoaXMuI3ZpZXcuc2V0RmxvYXQ2NCh0aGlzLiNvZmZzZXQsIHZhbHVlLCB0cnVlKTtcbiAgICB0aGlzLiNvZmZzZXQgKz0gODtcbiAgfVxuICB3cml0ZVN0cmluZyh2YWx1ZSkge1xuICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICBjb25zdCBlbmNvZGVkU3RyaW5nID0gZW5jb2Rlci5lbmNvZGUodmFsdWUpO1xuICAgIHRoaXMud3JpdGVVMzIoZW5jb2RlZFN0cmluZy5sZW5ndGgpO1xuICAgIHRoaXMuI2V4cGFuZEJ1ZmZlcihlbmNvZGVkU3RyaW5nLmxlbmd0aCk7XG4gICAgdGhpcy4jYnVmZmVyLnNldChlbmNvZGVkU3RyaW5nLCB0aGlzLiNvZmZzZXQpO1xuICAgIHRoaXMuI29mZnNldCArPSBlbmNvZGVkU3RyaW5nLmxlbmd0aDtcbiAgfVxufTtcblxuLy8gc3JjL2xpYi91dGlsLnRzXG5mdW5jdGlvbiB0b1Bhc2NhbENhc2Uocykge1xuICBjb25zdCBzdHIgPSBzLnJlcGxhY2UoLyhbLV9dW2Etel0pL2dpLCAoJDEpID0+IHtcbiAgICByZXR1cm4gJDEudG9VcHBlckNhc2UoKS5yZXBsYWNlKFwiLVwiLCBcIlwiKS5yZXBsYWNlKFwiX1wiLCBcIlwiKTtcbiAgfSk7XG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XG59XG5mdW5jdGlvbiB1aW50OEFycmF5VG9IZXhTdHJpbmcoYXJyYXkpIHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbChhcnJheS5yZXZlcnNlKCksICh4KSA9PiAoXCIwMFwiICsgeC50b1N0cmluZygxNikpLnNsaWNlKC0yKSkuam9pbihcIlwiKTtcbn1cbmZ1bmN0aW9uIHVpbnQ4QXJyYXlUb1UxMjgoYXJyYXkpIHtcbiAgaWYgKGFycmF5Lmxlbmd0aCAhPSAxNikge1xuICAgIHRocm93IG5ldyBFcnJvcihgVWludDhBcnJheSBpcyBub3QgMTYgYnl0ZXMgbG9uZzogJHthcnJheX1gKTtcbiAgfVxuICByZXR1cm4gbmV3IEJpbmFyeVJlYWRlcihhcnJheSkucmVhZFUxMjgoKTtcbn1cbmZ1bmN0aW9uIHVpbnQ4QXJyYXlUb1UyNTYoYXJyYXkpIHtcbiAgaWYgKGFycmF5Lmxlbmd0aCAhPSAzMikge1xuICAgIHRocm93IG5ldyBFcnJvcihgVWludDhBcnJheSBpcyBub3QgMzIgYnl0ZXMgbG9uZzogWyR7YXJyYXl9XWApO1xuICB9XG4gIHJldHVybiBuZXcgQmluYXJ5UmVhZGVyKGFycmF5KS5yZWFkVTI1NigpO1xufVxuZnVuY3Rpb24gaGV4U3RyaW5nVG9VaW50OEFycmF5KHN0cikge1xuICBpZiAoc3RyLnN0YXJ0c1dpdGgoXCIweFwiKSkge1xuICAgIHN0ciA9IHN0ci5zbGljZSgyKTtcbiAgfVxuICBjb25zdCBtYXRjaGVzID0gc3RyLm1hdGNoKC8uezEsMn0vZykgfHwgW107XG4gIGNvbnN0IGRhdGEgPSBVaW50OEFycmF5LmZyb20oXG4gICAgbWF0Y2hlcy5tYXAoKGJ5dGUpID0+IHBhcnNlSW50KGJ5dGUsIDE2KSlcbiAgKTtcbiAgcmV0dXJuIGRhdGEucmV2ZXJzZSgpO1xufVxuZnVuY3Rpb24gaGV4U3RyaW5nVG9VMTI4KHN0cikge1xuICByZXR1cm4gdWludDhBcnJheVRvVTEyOChoZXhTdHJpbmdUb1VpbnQ4QXJyYXkoc3RyKSk7XG59XG5mdW5jdGlvbiBoZXhTdHJpbmdUb1UyNTYoc3RyKSB7XG4gIHJldHVybiB1aW50OEFycmF5VG9VMjU2KGhleFN0cmluZ1RvVWludDhBcnJheShzdHIpKTtcbn1cbmZ1bmN0aW9uIHUxMjhUb1VpbnQ4QXJyYXkoZGF0YSkge1xuICBjb25zdCB3cml0ZXIgPSBuZXcgQmluYXJ5V3JpdGVyKDE2KTtcbiAgd3JpdGVyLndyaXRlVTEyOChkYXRhKTtcbiAgcmV0dXJuIHdyaXRlci5nZXRCdWZmZXIoKTtcbn1cbmZ1bmN0aW9uIHUxMjhUb0hleFN0cmluZyhkYXRhKSB7XG4gIHJldHVybiB1aW50OEFycmF5VG9IZXhTdHJpbmcodTEyOFRvVWludDhBcnJheShkYXRhKSk7XG59XG5mdW5jdGlvbiB1MjU2VG9VaW50OEFycmF5KGRhdGEpIHtcbiAgY29uc3Qgd3JpdGVyID0gbmV3IEJpbmFyeVdyaXRlcigzMik7XG4gIHdyaXRlci53cml0ZVUyNTYoZGF0YSk7XG4gIHJldHVybiB3cml0ZXIuZ2V0QnVmZmVyKCk7XG59XG5mdW5jdGlvbiB1MjU2VG9IZXhTdHJpbmcoZGF0YSkge1xuICByZXR1cm4gdWludDhBcnJheVRvSGV4U3RyaW5nKHUyNTZUb1VpbnQ4QXJyYXkoZGF0YSkpO1xufVxuZnVuY3Rpb24gdG9DYW1lbENhc2Uoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvWy1fXSsvZywgXCJfXCIpLnJlcGxhY2UoL18oW2EtekEtWjAtOV0pL2csIChfLCBjKSA9PiBjLnRvVXBwZXJDYXNlKCkpO1xufVxuZnVuY3Rpb24gYnNhdG5CYXNlU2l6ZSh0eXBlc3BhY2UsIHR5KSB7XG4gIGNvbnN0IGFzc3VtZWRBcnJheUxlbmd0aCA9IDQ7XG4gIHdoaWxlICh0eS50YWcgPT09IFwiUmVmXCIpIHR5ID0gdHlwZXNwYWNlLnR5cGVzW3R5LnZhbHVlXTtcbiAgaWYgKHR5LnRhZyA9PT0gXCJQcm9kdWN0XCIpIHtcbiAgICBsZXQgc3VtID0gMDtcbiAgICBmb3IgKGNvbnN0IHsgYWxnZWJyYWljVHlwZTogZWxlbSB9IG9mIHR5LnZhbHVlLmVsZW1lbnRzKSB7XG4gICAgICBzdW0gKz0gYnNhdG5CYXNlU2l6ZSh0eXBlc3BhY2UsIGVsZW0pO1xuICAgIH1cbiAgICByZXR1cm4gc3VtO1xuICB9IGVsc2UgaWYgKHR5LnRhZyA9PT0gXCJTdW1cIikge1xuICAgIGxldCBtaW4gPSBJbmZpbml0eTtcbiAgICBmb3IgKGNvbnN0IHsgYWxnZWJyYWljVHlwZTogdmFyaSB9IG9mIHR5LnZhbHVlLnZhcmlhbnRzKSB7XG4gICAgICBjb25zdCB2U2l6ZSA9IGJzYXRuQmFzZVNpemUodHlwZXNwYWNlLCB2YXJpKTtcbiAgICAgIGlmICh2U2l6ZSA8IG1pbikgbWluID0gdlNpemU7XG4gICAgfVxuICAgIGlmIChtaW4gPT09IEluZmluaXR5KSBtaW4gPSAwO1xuICAgIHJldHVybiA0ICsgbWluO1xuICB9IGVsc2UgaWYgKHR5LnRhZyA9PSBcIkFycmF5XCIpIHtcbiAgICByZXR1cm4gNCArIGFzc3VtZWRBcnJheUxlbmd0aCAqIGJzYXRuQmFzZVNpemUodHlwZXNwYWNlLCB0eS52YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBTdHJpbmc6IDQgKyBhc3N1bWVkQXJyYXlMZW5ndGgsXG4gICAgU3VtOiAxLFxuICAgIEJvb2w6IDEsXG4gICAgSTg6IDEsXG4gICAgVTg6IDEsXG4gICAgSTE2OiAyLFxuICAgIFUxNjogMixcbiAgICBJMzI6IDQsXG4gICAgVTMyOiA0LFxuICAgIEYzMjogNCxcbiAgICBJNjQ6IDgsXG4gICAgVTY0OiA4LFxuICAgIEY2NDogOCxcbiAgICBJMTI4OiAxNixcbiAgICBVMTI4OiAxNixcbiAgICBJMjU2OiAzMixcbiAgICBVMjU2OiAzMlxuICB9W3R5LnRhZ107XG59XG5cbi8vIHNyYy9saWIvY29ubmVjdGlvbl9pZC50c1xudmFyIENvbm5lY3Rpb25JZCA9IGNsYXNzIF9Db25uZWN0aW9uSWQge1xuICBfX2Nvbm5lY3Rpb25faWRfXztcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYENvbm5lY3Rpb25JZGAuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgdGhpcy5fX2Nvbm5lY3Rpb25faWRfXyA9IGRhdGE7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgYWxnZWJyYWljIHR5cGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIHtAbGluayBDb25uZWN0aW9uSWR9IHR5cGUuXG4gICAqIEByZXR1cm5zIFRoZSBhbGdlYnJhaWMgdHlwZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgdHlwZS5cbiAgICovXG4gIHN0YXRpYyBnZXRBbGdlYnJhaWNUeXBlKCkge1xuICAgIHJldHVybiBBbGdlYnJhaWNUeXBlLlByb2R1Y3Qoe1xuICAgICAgZWxlbWVudHM6IFtcbiAgICAgICAgeyBuYW1lOiBcIl9fY29ubmVjdGlvbl9pZF9fXCIsIGFsZ2VicmFpY1R5cGU6IEFsZ2VicmFpY1R5cGUuVTEyOCB9XG4gICAgICBdXG4gICAgfSk7XG4gIH1cbiAgaXNaZXJvKCkge1xuICAgIHJldHVybiB0aGlzLl9fY29ubmVjdGlvbl9pZF9fID09PSBCaWdJbnQoMCk7XG4gIH1cbiAgc3RhdGljIG51bGxJZlplcm8oYWRkcikge1xuICAgIGlmIChhZGRyLmlzWmVybygpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFkZHI7XG4gICAgfVxuICB9XG4gIHN0YXRpYyByYW5kb20oKSB7XG4gICAgZnVuY3Rpb24gcmFuZG9tVTgoKSB7XG4gICAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjU1KTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdCA9IEJpZ0ludCgwKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdCA8PCBCaWdJbnQoOCkgfCBCaWdJbnQocmFuZG9tVTgoKSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgX0Nvbm5lY3Rpb25JZChyZXN1bHQpO1xuICB9XG4gIC8qKlxuICAgKiBDb21wYXJlIHR3byBjb25uZWN0aW9uIElEcyBmb3IgZXF1YWxpdHkuXG4gICAqL1xuICBpc0VxdWFsKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX19jb25uZWN0aW9uX2lkX18gPT0gb3RoZXIuX19jb25uZWN0aW9uX2lkX187XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIHR3byBjb25uZWN0aW9uIElEcyBhcmUgZXF1YWwuXG4gICAqL1xuICBlcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5pc0VxdWFsKG90aGVyKTtcbiAgfVxuICAvKipcbiAgICogUHJpbnQgdGhlIGNvbm5lY3Rpb24gSUQgYXMgYSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gICAqL1xuICB0b0hleFN0cmluZygpIHtcbiAgICByZXR1cm4gdTEyOFRvSGV4U3RyaW5nKHRoaXMuX19jb25uZWN0aW9uX2lkX18pO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0IHRoZSBjb25uZWN0aW9uIElEIHRvIGEgVWludDhBcnJheS5cbiAgICovXG4gIHRvVWludDhBcnJheSgpIHtcbiAgICByZXR1cm4gdTEyOFRvVWludDhBcnJheSh0aGlzLl9fY29ubmVjdGlvbl9pZF9fKTtcbiAgfVxuICAvKipcbiAgICogUGFyc2UgYSBjb25uZWN0aW9uIElEIGZyb20gYSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gICAqL1xuICBzdGF0aWMgZnJvbVN0cmluZyhzdHIpIHtcbiAgICByZXR1cm4gbmV3IF9Db25uZWN0aW9uSWQoaGV4U3RyaW5nVG9VMTI4KHN0cikpO1xuICB9XG4gIHN0YXRpYyBmcm9tU3RyaW5nT3JOdWxsKHN0cikge1xuICAgIGNvbnN0IGFkZHIgPSBfQ29ubmVjdGlvbklkLmZyb21TdHJpbmcoc3RyKTtcbiAgICBpZiAoYWRkci5pc1plcm8oKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhZGRyO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2xpYi9pZGVudGl0eS50c1xudmFyIElkZW50aXR5ID0gY2xhc3MgX0lkZW50aXR5IHtcbiAgX19pZGVudGl0eV9fO1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBgSWRlbnRpdHlgLlxuICAgKlxuICAgKiBgZGF0YWAgY2FuIGJlIGEgaGV4YWRlY2ltYWwgc3RyaW5nIG9yIGEgYGJpZ2ludGAuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgdGhpcy5fX2lkZW50aXR5X18gPSB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiA/IGhleFN0cmluZ1RvVTI1NihkYXRhKSA6IGRhdGE7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgYWxnZWJyYWljIHR5cGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIHtAbGluayBJZGVudGl0eX0gdHlwZS5cbiAgICogQHJldHVybnMgVGhlIGFsZ2VicmFpYyB0eXBlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0eXBlLlxuICAgKi9cbiAgc3RhdGljIGdldEFsZ2VicmFpY1R5cGUoKSB7XG4gICAgcmV0dXJuIEFsZ2VicmFpY1R5cGUuUHJvZHVjdCh7XG4gICAgICBlbGVtZW50czogW3sgbmFtZTogXCJfX2lkZW50aXR5X19cIiwgYWxnZWJyYWljVHlwZTogQWxnZWJyYWljVHlwZS5VMjU2IH1dXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIHR3byBpZGVudGl0aWVzIGFyZSBlcXVhbC5cbiAgICovXG4gIGlzRXF1YWwob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy50b0hleFN0cmluZygpID09PSBvdGhlci50b0hleFN0cmluZygpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiB0d28gaWRlbnRpdGllcyBhcmUgZXF1YWwuXG4gICAqL1xuICBlcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5pc0VxdWFsKG90aGVyKTtcbiAgfVxuICAvKipcbiAgICogUHJpbnQgdGhlIGlkZW50aXR5IGFzIGEgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICAgKi9cbiAgdG9IZXhTdHJpbmcoKSB7XG4gICAgcmV0dXJuIHUyNTZUb0hleFN0cmluZyh0aGlzLl9faWRlbnRpdHlfXyk7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnQgdGhlIGFkZHJlc3MgdG8gYSBVaW50OEFycmF5LlxuICAgKi9cbiAgdG9VaW50OEFycmF5KCkge1xuICAgIHJldHVybiB1MjU2VG9VaW50OEFycmF5KHRoaXMuX19pZGVudGl0eV9fKTtcbiAgfVxuICAvKipcbiAgICogUGFyc2UgYW4gSWRlbnRpdHkgZnJvbSBhIGhleGFkZWNpbWFsIHN0cmluZy5cbiAgICovXG4gIHN0YXRpYyBmcm9tU3RyaW5nKHN0cikge1xuICAgIHJldHVybiBuZXcgX0lkZW50aXR5KHN0cik7XG4gIH1cbiAgLyoqXG4gICAqIFplcm8gaWRlbnRpdHkgKDB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMClcbiAgICovXG4gIHN0YXRpYyB6ZXJvKCkge1xuICAgIHJldHVybiBuZXcgX0lkZW50aXR5KDBuKTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy50b0hleFN0cmluZygpO1xuICB9XG59O1xuXG4vLyBzcmMvbGliL2FsZ2VicmFpY190eXBlLnRzXG52YXIgQWxnZWJyYWljVHlwZSA9IHtcbiAgUmVmOiAodmFsdWUpID0+ICh7IHRhZzogXCJSZWZcIiwgdmFsdWUgfSksXG4gIFN1bTogKHZhbHVlKSA9PiAoe1xuICAgIHRhZzogXCJTdW1cIixcbiAgICB2YWx1ZVxuICB9KSxcbiAgUHJvZHVjdDogKHZhbHVlKSA9PiAoe1xuICAgIHRhZzogXCJQcm9kdWN0XCIsXG4gICAgdmFsdWVcbiAgfSksXG4gIEFycmF5OiAodmFsdWUpID0+ICh7XG4gICAgdGFnOiBcIkFycmF5XCIsXG4gICAgdmFsdWVcbiAgfSksXG4gIFN0cmluZzogeyB0YWc6IFwiU3RyaW5nXCIgfSxcbiAgQm9vbDogeyB0YWc6IFwiQm9vbFwiIH0sXG4gIEk4OiB7IHRhZzogXCJJOFwiIH0sXG4gIFU4OiB7IHRhZzogXCJVOFwiIH0sXG4gIEkxNjogeyB0YWc6IFwiSTE2XCIgfSxcbiAgVTE2OiB7IHRhZzogXCJVMTZcIiB9LFxuICBJMzI6IHsgdGFnOiBcIkkzMlwiIH0sXG4gIFUzMjogeyB0YWc6IFwiVTMyXCIgfSxcbiAgSTY0OiB7IHRhZzogXCJJNjRcIiB9LFxuICBVNjQ6IHsgdGFnOiBcIlU2NFwiIH0sXG4gIEkxMjg6IHsgdGFnOiBcIkkxMjhcIiB9LFxuICBVMTI4OiB7IHRhZzogXCJVMTI4XCIgfSxcbiAgSTI1NjogeyB0YWc6IFwiSTI1NlwiIH0sXG4gIFUyNTY6IHsgdGFnOiBcIlUyNTZcIiB9LFxuICBGMzI6IHsgdGFnOiBcIkYzMlwiIH0sXG4gIEY2NDogeyB0YWc6IFwiRjY0XCIgfSxcbiAgc2VyaWFsaXplVmFsdWUod3JpdGVyLCB0eSwgdmFsdWUsIHR5cGVzcGFjZSkge1xuICAgIGlmICh0eS50YWcgPT09IFwiUmVmXCIpIHtcbiAgICAgIGlmICghdHlwZXNwYWNlKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3Qgc2VyaWFsaXplIHJlZnMgd2l0aG91dCBhIHR5cGVzcGFjZVwiKTtcbiAgICAgIHdoaWxlICh0eS50YWcgPT09IFwiUmVmXCIpIHR5ID0gdHlwZXNwYWNlLnR5cGVzW3R5LnZhbHVlXTtcbiAgICB9XG4gICAgc3dpdGNoICh0eS50YWcpIHtcbiAgICAgIGNhc2UgXCJQcm9kdWN0XCI6XG4gICAgICAgIFByb2R1Y3RUeXBlLnNlcmlhbGl6ZVZhbHVlKHdyaXRlciwgdHkudmFsdWUsIHZhbHVlLCB0eXBlc3BhY2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJTdW1cIjpcbiAgICAgICAgU3VtVHlwZS5zZXJpYWxpemVWYWx1ZSh3cml0ZXIsIHR5LnZhbHVlLCB2YWx1ZSwgdHlwZXNwYWNlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiQXJyYXlcIjpcbiAgICAgICAgaWYgKHR5LnZhbHVlLnRhZyA9PT0gXCJVOFwiKSB7XG4gICAgICAgICAgd3JpdGVyLndyaXRlVUludDhBcnJheSh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgZWxlbVR5cGUgPSB0eS52YWx1ZTtcbiAgICAgICAgICB3cml0ZXIud3JpdGVVMzIodmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGVsZW0gb2YgdmFsdWUpIHtcbiAgICAgICAgICAgIEFsZ2VicmFpY1R5cGUuc2VyaWFsaXplVmFsdWUod3JpdGVyLCBlbGVtVHlwZSwgZWxlbSwgdHlwZXNwYWNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiQm9vbFwiOlxuICAgICAgICB3cml0ZXIud3JpdGVCb29sKHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiSThcIjpcbiAgICAgICAgd3JpdGVyLndyaXRlSTgodmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJVOFwiOlxuICAgICAgICB3cml0ZXIud3JpdGVVOCh2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkkxNlwiOlxuICAgICAgICB3cml0ZXIud3JpdGVJMTYodmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJVMTZcIjpcbiAgICAgICAgd3JpdGVyLndyaXRlVTE2KHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiSTMyXCI6XG4gICAgICAgIHdyaXRlci53cml0ZUkzMih2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIlUzMlwiOlxuICAgICAgICB3cml0ZXIud3JpdGVVMzIodmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJJNjRcIjpcbiAgICAgICAgd3JpdGVyLndyaXRlSTY0KHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiVTY0XCI6XG4gICAgICAgIHdyaXRlci53cml0ZVU2NCh2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkkxMjhcIjpcbiAgICAgICAgd3JpdGVyLndyaXRlSTEyOCh2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIlUxMjhcIjpcbiAgICAgICAgd3JpdGVyLndyaXRlVTEyOCh2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkkyNTZcIjpcbiAgICAgICAgd3JpdGVyLndyaXRlSTI1Nih2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIlUyNTZcIjpcbiAgICAgICAgd3JpdGVyLndyaXRlVTI1Nih2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkYzMlwiOlxuICAgICAgICB3cml0ZXIud3JpdGVGMzIodmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJGNjRcIjpcbiAgICAgICAgd3JpdGVyLndyaXRlRjY0KHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiU3RyaW5nXCI6XG4gICAgICAgIHdyaXRlci53cml0ZVN0cmluZyh2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSxcbiAgZGVzZXJpYWxpemVWYWx1ZTogZnVuY3Rpb24ocmVhZGVyLCB0eSwgdHlwZXNwYWNlKSB7XG4gICAgaWYgKHR5LnRhZyA9PT0gXCJSZWZcIikge1xuICAgICAgaWYgKCF0eXBlc3BhY2UpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBkZXNlcmlhbGl6ZSByZWZzIHdpdGhvdXQgYSB0eXBlc3BhY2VcIik7XG4gICAgICB3aGlsZSAodHkudGFnID09PSBcIlJlZlwiKSB0eSA9IHR5cGVzcGFjZS50eXBlc1t0eS52YWx1ZV07XG4gICAgfVxuICAgIHN3aXRjaCAodHkudGFnKSB7XG4gICAgICBjYXNlIFwiUHJvZHVjdFwiOlxuICAgICAgICByZXR1cm4gUHJvZHVjdFR5cGUuZGVzZXJpYWxpemVWYWx1ZShyZWFkZXIsIHR5LnZhbHVlLCB0eXBlc3BhY2UpO1xuICAgICAgY2FzZSBcIlN1bVwiOlxuICAgICAgICByZXR1cm4gU3VtVHlwZS5kZXNlcmlhbGl6ZVZhbHVlKHJlYWRlciwgdHkudmFsdWUsIHR5cGVzcGFjZSk7XG4gICAgICBjYXNlIFwiQXJyYXlcIjpcbiAgICAgICAgaWYgKHR5LnZhbHVlLnRhZyA9PT0gXCJVOFwiKSB7XG4gICAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkVUludDhBcnJheSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGVsZW1UeXBlID0gdHkudmFsdWU7XG4gICAgICAgICAgY29uc3QgbGVuZ3RoID0gcmVhZGVyLnJlYWRVMzIoKTtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICAgICAgQWxnZWJyYWljVHlwZS5kZXNlcmlhbGl6ZVZhbHVlKHJlYWRlciwgZWxlbVR5cGUsIHR5cGVzcGFjZSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgXCJCb29sXCI6XG4gICAgICAgIHJldHVybiByZWFkZXIucmVhZEJvb2woKTtcbiAgICAgIGNhc2UgXCJJOFwiOlxuICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWRJOCgpO1xuICAgICAgY2FzZSBcIlU4XCI6XG4gICAgICAgIHJldHVybiByZWFkZXIucmVhZFU4KCk7XG4gICAgICBjYXNlIFwiSTE2XCI6XG4gICAgICAgIHJldHVybiByZWFkZXIucmVhZEkxNigpO1xuICAgICAgY2FzZSBcIlUxNlwiOlxuICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWRVMTYoKTtcbiAgICAgIGNhc2UgXCJJMzJcIjpcbiAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkSTMyKCk7XG4gICAgICBjYXNlIFwiVTMyXCI6XG4gICAgICAgIHJldHVybiByZWFkZXIucmVhZFUzMigpO1xuICAgICAgY2FzZSBcIkk2NFwiOlxuICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWRJNjQoKTtcbiAgICAgIGNhc2UgXCJVNjRcIjpcbiAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkVTY0KCk7XG4gICAgICBjYXNlIFwiSTEyOFwiOlxuICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWRJMTI4KCk7XG4gICAgICBjYXNlIFwiVTEyOFwiOlxuICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWRVMTI4KCk7XG4gICAgICBjYXNlIFwiSTI1NlwiOlxuICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWRJMjU2KCk7XG4gICAgICBjYXNlIFwiVTI1NlwiOlxuICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWRVMjU2KCk7XG4gICAgICBjYXNlIFwiRjMyXCI6XG4gICAgICAgIHJldHVybiByZWFkZXIucmVhZEYzMigpO1xuICAgICAgY2FzZSBcIkY2NFwiOlxuICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWRGNjQoKTtcbiAgICAgIGNhc2UgXCJTdHJpbmdcIjpcbiAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkU3RyaW5nKCk7XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogQ29udmVydCBhIHZhbHVlIG9mIHRoZSBhbGdlYnJhaWMgdHlwZSBpbnRvIHNvbWV0aGluZyB0aGF0IGNhbiBiZSB1c2VkIGFzIGEga2V5IGluIGEgbWFwLlxuICAgKiBUaGVyZSBhcmUgbm8gZ3VhcmFudGVlcyBhYm91dCBiZWluZyBhYmxlIHRvIG9yZGVyIGl0LlxuICAgKiBUaGlzIGlzIG9ubHkgZ3VhcmFudGVlZCB0byBiZSBjb21wYXJhYmxlIHRvIG90aGVyIHZhbHVlcyBvZiB0aGUgc2FtZSB0eXBlLlxuICAgKiBAcGFyYW0gdmFsdWUgQSB2YWx1ZSBvZiB0aGUgYWxnZWJyYWljIHR5cGVcbiAgICogQHJldHVybnMgU29tZXRoaW5nIHRoYXQgY2FuIGJlIHVzZWQgYXMgYSBrZXkgaW4gYSBtYXAuXG4gICAqL1xuICBpbnRvTWFwS2V5OiBmdW5jdGlvbih0eSwgdmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5LnRhZykge1xuICAgICAgY2FzZSBcIlU4XCI6XG4gICAgICBjYXNlIFwiVTE2XCI6XG4gICAgICBjYXNlIFwiVTMyXCI6XG4gICAgICBjYXNlIFwiVTY0XCI6XG4gICAgICBjYXNlIFwiVTEyOFwiOlxuICAgICAgY2FzZSBcIlUyNTZcIjpcbiAgICAgIGNhc2UgXCJJOFwiOlxuICAgICAgY2FzZSBcIkkxNlwiOlxuICAgICAgY2FzZSBcIkkzMlwiOlxuICAgICAgY2FzZSBcIkk2NFwiOlxuICAgICAgY2FzZSBcIkkxMjhcIjpcbiAgICAgIGNhc2UgXCJJMjU2XCI6XG4gICAgICBjYXNlIFwiRjMyXCI6XG4gICAgICBjYXNlIFwiRjY0XCI6XG4gICAgICBjYXNlIFwiU3RyaW5nXCI6XG4gICAgICBjYXNlIFwiQm9vbFwiOlxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICBjYXNlIFwiUHJvZHVjdFwiOlxuICAgICAgICByZXR1cm4gUHJvZHVjdFR5cGUuaW50b01hcEtleSh0eS52YWx1ZSwgdmFsdWUpO1xuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBjb25zdCB3cml0ZXIgPSBuZXcgQmluYXJ5V3JpdGVyKDEwKTtcbiAgICAgICAgQWxnZWJyYWljVHlwZS5zZXJpYWxpemVWYWx1ZSh3cml0ZXIsIHR5LCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiB3cml0ZXIudG9CYXNlNjQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG52YXIgUHJvZHVjdFR5cGUgPSB7XG4gIHNlcmlhbGl6ZVZhbHVlKHdyaXRlciwgdHksIHZhbHVlLCB0eXBlc3BhY2UpIHtcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdHkuZWxlbWVudHMpIHtcbiAgICAgIEFsZ2VicmFpY1R5cGUuc2VyaWFsaXplVmFsdWUoXG4gICAgICAgIHdyaXRlcixcbiAgICAgICAgZWxlbWVudC5hbGdlYnJhaWNUeXBlLFxuICAgICAgICB2YWx1ZVtlbGVtZW50Lm5hbWVdLFxuICAgICAgICB0eXBlc3BhY2VcbiAgICAgICk7XG4gICAgfVxuICB9LFxuICBkZXNlcmlhbGl6ZVZhbHVlKHJlYWRlciwgdHksIHR5cGVzcGFjZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGlmICh0eS5lbGVtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGlmICh0eS5lbGVtZW50c1swXS5uYW1lID09PSBcIl9fdGltZV9kdXJhdGlvbl9taWNyb3NfX1wiKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGltZUR1cmF0aW9uKHJlYWRlci5yZWFkSTY0KCkpO1xuICAgICAgfVxuICAgICAgaWYgKHR5LmVsZW1lbnRzWzBdLm5hbWUgPT09IFwiX190aW1lc3RhbXBfbWljcm9zX3NpbmNlX3VuaXhfZXBvY2hfX1wiKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGltZXN0YW1wKHJlYWRlci5yZWFkSTY0KCkpO1xuICAgICAgfVxuICAgICAgaWYgKHR5LmVsZW1lbnRzWzBdLm5hbWUgPT09IFwiX19pZGVudGl0eV9fXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJZGVudGl0eShyZWFkZXIucmVhZFUyNTYoKSk7XG4gICAgICB9XG4gICAgICBpZiAodHkuZWxlbWVudHNbMF0ubmFtZSA9PT0gXCJfX2Nvbm5lY3Rpb25faWRfX1wiKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29ubmVjdGlvbklkKHJlYWRlci5yZWFkVTEyOCgpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eS5lbGVtZW50c1swXS5uYW1lID09PSBcIl9fdXVpZF9fXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVdWlkKHJlYWRlci5yZWFkVTEyOCgpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHR5LmVsZW1lbnRzKSB7XG4gICAgICByZXN1bHRbZWxlbWVudC5uYW1lXSA9IEFsZ2VicmFpY1R5cGUuZGVzZXJpYWxpemVWYWx1ZShcbiAgICAgICAgcmVhZGVyLFxuICAgICAgICBlbGVtZW50LmFsZ2VicmFpY1R5cGUsXG4gICAgICAgIHR5cGVzcGFjZVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcbiAgaW50b01hcEtleSh0eSwgdmFsdWUpIHtcbiAgICBpZiAodHkuZWxlbWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAodHkuZWxlbWVudHNbMF0ubmFtZSA9PT0gXCJfX3RpbWVfZHVyYXRpb25fbWljcm9zX19cIikge1xuICAgICAgICByZXR1cm4gdmFsdWUuX190aW1lX2R1cmF0aW9uX21pY3Jvc19fO1xuICAgICAgfVxuICAgICAgaWYgKHR5LmVsZW1lbnRzWzBdLm5hbWUgPT09IFwiX190aW1lc3RhbXBfbWljcm9zX3NpbmNlX3VuaXhfZXBvY2hfX1wiKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5fX3RpbWVzdGFtcF9taWNyb3Nfc2luY2VfdW5peF9lcG9jaF9fO1xuICAgICAgfVxuICAgICAgaWYgKHR5LmVsZW1lbnRzWzBdLm5hbWUgPT09IFwiX19pZGVudGl0eV9fXCIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLl9faWRlbnRpdHlfXztcbiAgICAgIH1cbiAgICAgIGlmICh0eS5lbGVtZW50c1swXS5uYW1lID09PSBcIl9fY29ubmVjdGlvbl9pZF9fXCIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLl9fY29ubmVjdGlvbl9pZF9fO1xuICAgICAgfVxuICAgICAgaWYgKHR5LmVsZW1lbnRzWzBdLm5hbWUgPT09IFwiX191dWlkX19cIikge1xuICAgICAgICByZXR1cm4gdmFsdWUuX191dWlkX187XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHdyaXRlciA9IG5ldyBCaW5hcnlXcml0ZXIoMTApO1xuICAgIEFsZ2VicmFpY1R5cGUuc2VyaWFsaXplVmFsdWUod3JpdGVyLCBBbGdlYnJhaWNUeXBlLlByb2R1Y3QodHkpLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHdyaXRlci50b0Jhc2U2NCgpO1xuICB9XG59O1xudmFyIFN1bVR5cGUgPSB7XG4gIHNlcmlhbGl6ZVZhbHVlOiBmdW5jdGlvbih3cml0ZXIsIHR5LCB2YWx1ZSwgdHlwZXNwYWNlKSB7XG4gICAgaWYgKHR5LnZhcmlhbnRzLmxlbmd0aCA9PSAyICYmIHR5LnZhcmlhbnRzWzBdLm5hbWUgPT09IFwic29tZVwiICYmIHR5LnZhcmlhbnRzWzFdLm5hbWUgPT09IFwibm9uZVwiKSB7XG4gICAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICB3cml0ZXIud3JpdGVCeXRlKDApO1xuICAgICAgICBBbGdlYnJhaWNUeXBlLnNlcmlhbGl6ZVZhbHVlKFxuICAgICAgICAgIHdyaXRlcixcbiAgICAgICAgICB0eS52YXJpYW50c1swXS5hbGdlYnJhaWNUeXBlLFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIHR5cGVzcGFjZVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JpdGVyLndyaXRlQnl0ZSgxKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5LnZhcmlhbnRzLmxlbmd0aCA9PSAyICYmIHR5LnZhcmlhbnRzWzBdLm5hbWUgPT09IFwib2tcIiAmJiB0eS52YXJpYW50c1sxXS5uYW1lID09PSBcImVyclwiKSB7XG4gICAgICBsZXQgdmFyaWFudE5hbWU7XG4gICAgICBsZXQgaW5uZXJWYWx1ZTtcbiAgICAgIGxldCBpbmRleDtcbiAgICAgIGlmIChcIm9rXCIgaW4gdmFsdWUpIHtcbiAgICAgICAgdmFyaWFudE5hbWUgPSBcIm9rXCI7XG4gICAgICAgIGlubmVyVmFsdWUgPSB2YWx1ZS5vaztcbiAgICAgICAgaW5kZXggPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyaWFudE5hbWUgPSBcImVyclwiO1xuICAgICAgICBpbm5lclZhbHVlID0gdmFsdWUuZXJyO1xuICAgICAgICBpbmRleCA9IDE7XG4gICAgICB9XG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIHRocm93IGBSZXN1bHQgc2VyaWFsaXphdGlvbiBlcnJvcjogdmFyaWFudCAnJHt2YXJpYW50TmFtZX0nIG5vdCBmb3VuZCBpbiAke0pTT04uc3RyaW5naWZ5KHR5KX1gO1xuICAgICAgfVxuICAgICAgd3JpdGVyLndyaXRlVTgoaW5kZXgpO1xuICAgICAgQWxnZWJyYWljVHlwZS5zZXJpYWxpemVWYWx1ZShcbiAgICAgICAgd3JpdGVyLFxuICAgICAgICB0eS52YXJpYW50c1tpbmRleF0uYWxnZWJyYWljVHlwZSxcbiAgICAgICAgaW5uZXJWYWx1ZSxcbiAgICAgICAgdHlwZXNwYWNlXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB2YXJpYW50ID0gdmFsdWVbXCJ0YWdcIl07XG4gICAgICBjb25zdCBpbmRleCA9IHR5LnZhcmlhbnRzLmZpbmRJbmRleCgodikgPT4gdi5uYW1lID09PSB2YXJpYW50KTtcbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgdGhyb3cgYENhbid0IHNlcmlhbGl6ZSBhIHN1bSB0eXBlLCBjb3VsZG4ndCBmaW5kICR7dmFsdWUudGFnfSB0YWcgJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9IGluIHZhcmlhbnRzICR7SlNPTi5zdHJpbmdpZnkodHkpfWA7XG4gICAgICB9XG4gICAgICB3cml0ZXIud3JpdGVVOChpbmRleCk7XG4gICAgICBBbGdlYnJhaWNUeXBlLnNlcmlhbGl6ZVZhbHVlKFxuICAgICAgICB3cml0ZXIsXG4gICAgICAgIHR5LnZhcmlhbnRzW2luZGV4XS5hbGdlYnJhaWNUeXBlLFxuICAgICAgICB2YWx1ZVtcInZhbHVlXCJdLFxuICAgICAgICB0eXBlc3BhY2VcbiAgICAgICk7XG4gICAgfVxuICB9LFxuICBkZXNlcmlhbGl6ZVZhbHVlOiBmdW5jdGlvbihyZWFkZXIsIHR5LCB0eXBlc3BhY2UpIHtcbiAgICBjb25zdCB0YWcgPSByZWFkZXIucmVhZFU4KCk7XG4gICAgaWYgKHR5LnZhcmlhbnRzLmxlbmd0aCA9PSAyICYmIHR5LnZhcmlhbnRzWzBdLm5hbWUgPT09IFwic29tZVwiICYmIHR5LnZhcmlhbnRzWzFdLm5hbWUgPT09IFwibm9uZVwiKSB7XG4gICAgICBpZiAodGFnID09PSAwKSB7XG4gICAgICAgIHJldHVybiBBbGdlYnJhaWNUeXBlLmRlc2VyaWFsaXplVmFsdWUoXG4gICAgICAgICAgcmVhZGVyLFxuICAgICAgICAgIHR5LnZhcmlhbnRzWzBdLmFsZ2VicmFpY1R5cGUsXG4gICAgICAgICAgdHlwZXNwYWNlXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKHRhZyA9PT0gMSkge1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgYENhbid0IGRlc2VyaWFsaXplIGFuIG9wdGlvbiB0eXBlLCBjb3VsZG4ndCBmaW5kICR7dGFnfSB0YWdgO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHkudmFyaWFudHMubGVuZ3RoID09IDIgJiYgdHkudmFyaWFudHNbMF0ubmFtZSA9PT0gXCJva1wiICYmIHR5LnZhcmlhbnRzWzFdLm5hbWUgPT09IFwiZXJyXCIpIHtcbiAgICAgIGlmICh0YWcgPT09IDApIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBBbGdlYnJhaWNUeXBlLmRlc2VyaWFsaXplVmFsdWUoXG4gICAgICAgICAgcmVhZGVyLFxuICAgICAgICAgIHR5LnZhcmlhbnRzWzBdLmFsZ2VicmFpY1R5cGUsXG4gICAgICAgICAgdHlwZXNwYWNlXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB7IG9rOiB2YWx1ZSB9O1xuICAgICAgfSBlbHNlIGlmICh0YWcgPT09IDEpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBBbGdlYnJhaWNUeXBlLmRlc2VyaWFsaXplVmFsdWUoXG4gICAgICAgICAgcmVhZGVyLFxuICAgICAgICAgIHR5LnZhcmlhbnRzWzFdLmFsZ2VicmFpY1R5cGUsXG4gICAgICAgICAgdHlwZXNwYWNlXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB7IGVycjogdmFsdWUgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGBDYW4ndCBkZXNlcmlhbGl6ZSBhIHJlc3VsdCB0eXBlLCBjb3VsZG4ndCBmaW5kICR7dGFnfSB0YWdgO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB2YXJpYW50ID0gdHkudmFyaWFudHNbdGFnXTtcbiAgICAgIGNvbnN0IHZhbHVlID0gQWxnZWJyYWljVHlwZS5kZXNlcmlhbGl6ZVZhbHVlKFxuICAgICAgICByZWFkZXIsXG4gICAgICAgIHZhcmlhbnQuYWxnZWJyYWljVHlwZSxcbiAgICAgICAgdHlwZXNwYWNlXG4gICAgICApO1xuICAgICAgcmV0dXJuIHsgdGFnOiB2YXJpYW50Lm5hbWUsIHZhbHVlIH07XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvbGliL29wdGlvbi50c1xudmFyIE9wdGlvbiA9IHtcbiAgZ2V0QWxnZWJyYWljVHlwZShpbm5lclR5cGUpIHtcbiAgICByZXR1cm4gQWxnZWJyYWljVHlwZS5TdW0oe1xuICAgICAgdmFyaWFudHM6IFtcbiAgICAgICAgeyBuYW1lOiBcInNvbWVcIiwgYWxnZWJyYWljVHlwZTogaW5uZXJUeXBlIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcIm5vbmVcIixcbiAgICAgICAgICBhbGdlYnJhaWNUeXBlOiBBbGdlYnJhaWNUeXBlLlByb2R1Y3QoeyBlbGVtZW50czogW10gfSlcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvbGliL3Jlc3VsdC50c1xudmFyIFJlc3VsdCA9IHtcbiAgZ2V0QWxnZWJyYWljVHlwZShva1R5cGUsIGVyclR5cGUpIHtcbiAgICByZXR1cm4gQWxnZWJyYWljVHlwZS5TdW0oe1xuICAgICAgdmFyaWFudHM6IFtcbiAgICAgICAgeyBuYW1lOiBcIm9rXCIsIGFsZ2VicmFpY1R5cGU6IG9rVHlwZSB9LFxuICAgICAgICB7IG5hbWU6IFwiZXJyXCIsIGFsZ2VicmFpY1R5cGU6IGVyclR5cGUgfVxuICAgICAgXVxuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvbGliL3NjaGVkdWxlX2F0LnRzXG52YXIgU2NoZWR1bGVBdCA9IHtcbiAgaW50ZXJ2YWwodmFsdWUpIHtcbiAgICByZXR1cm4gSW50ZXJ2YWwodmFsdWUpO1xuICB9LFxuICB0aW1lKHZhbHVlKSB7XG4gICAgcmV0dXJuIFRpbWUodmFsdWUpO1xuICB9LFxuICBnZXRBbGdlYnJhaWNUeXBlKCkge1xuICAgIHJldHVybiBBbGdlYnJhaWNUeXBlLlN1bSh7XG4gICAgICB2YXJpYW50czogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJJbnRlcnZhbFwiLFxuICAgICAgICAgIGFsZ2VicmFpY1R5cGU6IFRpbWVEdXJhdGlvbi5nZXRBbGdlYnJhaWNUeXBlKClcbiAgICAgICAgfSxcbiAgICAgICAgeyBuYW1lOiBcIlRpbWVcIiwgYWxnZWJyYWljVHlwZTogVGltZXN0YW1wLmdldEFsZ2VicmFpY1R5cGUoKSB9XG4gICAgICBdXG4gICAgfSk7XG4gIH0sXG4gIGlzU2NoZWR1bGVBdChhbGdlYnJhaWNUeXBlKSB7XG4gICAgaWYgKGFsZ2VicmFpY1R5cGUudGFnICE9PSBcIlN1bVwiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHZhcmlhbnRzID0gYWxnZWJyYWljVHlwZS52YWx1ZS52YXJpYW50cztcbiAgICBpZiAodmFyaWFudHMubGVuZ3RoICE9PSAyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGludGVydmFsVmFyaWFudCA9IHZhcmlhbnRzLmZpbmQoKHYpID0+IHYubmFtZSA9PT0gXCJJbnRlcnZhbFwiKTtcbiAgICBjb25zdCB0aW1lVmFyaWFudCA9IHZhcmlhbnRzLmZpbmQoKHYpID0+IHYubmFtZSA9PT0gXCJUaW1lXCIpO1xuICAgIGlmICghaW50ZXJ2YWxWYXJpYW50IHx8ICF0aW1lVmFyaWFudCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gVGltZUR1cmF0aW9uLmlzVGltZUR1cmF0aW9uKGludGVydmFsVmFyaWFudC5hbGdlYnJhaWNUeXBlKSAmJiBUaW1lc3RhbXAuaXNUaW1lc3RhbXAodGltZVZhcmlhbnQuYWxnZWJyYWljVHlwZSk7XG4gIH1cbn07XG52YXIgSW50ZXJ2YWwgPSAobWljcm9zKSA9PiAoe1xuICB0YWc6IFwiSW50ZXJ2YWxcIixcbiAgdmFsdWU6IG5ldyBUaW1lRHVyYXRpb24obWljcm9zKVxufSk7XG52YXIgVGltZSA9IChtaWNyb3NTaW5jZVVuaXhFcG9jaCkgPT4gKHtcbiAgdGFnOiBcIlRpbWVcIixcbiAgdmFsdWU6IG5ldyBUaW1lc3RhbXAobWljcm9zU2luY2VVbml4RXBvY2gpXG59KTtcbnZhciBzY2hlZHVsZV9hdF9kZWZhdWx0ID0gU2NoZWR1bGVBdDtcblxuLy8gc3JjL2xpYi90eXBlX3V0aWwudHNcbmZ1bmN0aW9uIHNldCh4LCB0Mikge1xuICByZXR1cm4geyAuLi54LCAuLi50MiB9O1xufVxuXG4vLyBzcmMvbGliL3R5cGVfYnVpbGRlcnMudHNcbnZhciBUeXBlQnVpbGRlciA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIFRoZSBUeXBlU2NyaXB0IHBoYW50b20gdHlwZS4gVGhpcyBpcyBub3Qgc3RvcmVkIGF0IHJ1bnRpbWUsXG4gICAqIGJ1dCBpcyB2aXNpYmxlIHRvIHRoZSBjb21waWxlclxuICAgKi9cbiAgdHlwZTtcbiAgLyoqXG4gICAqIFRoZSBTcGFjZXRpbWVEQiBhbGdlYnJhaWMgdHlwZSAocnVu4oCRdGltZSB2YWx1ZSkuIEluIGFkZGl0aW9uIHRvIHN0b3JpbmdcbiAgICogdGhlIHJ1bnRpbWUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGBBbGdlYnJhaWNUeXBlYCwgaXQgYWxzbyBjYXB0dXJlc1xuICAgKiB0aGUgVHlwZVNjcmlwdCB0eXBlIGluZm9ybWF0aW9uIG9mIHRoZSBgQWxnZWJyYWljVHlwZWAuIFRoYXQgaXMgdG8gc2F5XG4gICAqIHRoZSB2YWx1ZSBpcyBub3QgbWVyZWx5IGFuIGBBbGdlYnJhaWNUeXBlYCwgYnV0IGlzIGNvbnN0cnVjdGVkIHRvIGJlXG4gICAqIHRoZSBjb3JyZXNwb25kaW5nIGNvbmNyZXRlIGBBbGdlYnJhaWNUeXBlYCBmb3IgdGhlIFR5cGVTY3JpcHQgdHlwZSBgVHlwZWAuXG4gICAqXG4gICAqIGUuZy4gYHN0cmluZ2AgY29ycmVzcG9uZHMgdG8gYEFsZ2VicmFpY1R5cGUuU3RyaW5nYFxuICAgKi9cbiAgYWxnZWJyYWljVHlwZTtcbiAgY29uc3RydWN0b3IoYWxnZWJyYWljVHlwZSkge1xuICAgIHRoaXMuYWxnZWJyYWljVHlwZSA9IGFsZ2VicmFpY1R5cGU7XG4gIH1cbiAgb3B0aW9uYWwoKSB7XG4gICAgcmV0dXJuIG5ldyBPcHRpb25CdWlsZGVyKHRoaXMpO1xuICB9XG4gIHNlcmlhbGl6ZSh3cml0ZXIsIHZhbHVlKSB7XG4gICAgQWxnZWJyYWljVHlwZS5zZXJpYWxpemVWYWx1ZSh3cml0ZXIsIHRoaXMuYWxnZWJyYWljVHlwZSwgdmFsdWUpO1xuICB9XG4gIGRlc2VyaWFsaXplKHJlYWRlcikge1xuICAgIHJldHVybiBBbGdlYnJhaWNUeXBlLmRlc2VyaWFsaXplVmFsdWUocmVhZGVyLCB0aGlzLmFsZ2VicmFpY1R5cGUpO1xuICB9XG59O1xudmFyIFU4QnVpbGRlciA9IGNsYXNzIGV4dGVuZHMgVHlwZUJ1aWxkZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihBbGdlYnJhaWNUeXBlLlU4KTtcbiAgfVxuICBpbmRleChhbGdvcml0aG0gPSBcImJ0cmVlXCIpIHtcbiAgICByZXR1cm4gbmV3IFU4Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGluZGV4VHlwZTogYWxnb3JpdGhtIH0pXG4gICAgKTtcbiAgfVxuICB1bmlxdWUoKSB7XG4gICAgcmV0dXJuIG5ldyBVOENvbHVtbkJ1aWxkZXIodGhpcywgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc1VuaXF1ZTogdHJ1ZSB9KSk7XG4gIH1cbiAgcHJpbWFyeUtleSgpIHtcbiAgICByZXR1cm4gbmV3IFU4Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzUHJpbWFyeUtleTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgYXV0b0luYygpIHtcbiAgICByZXR1cm4gbmV3IFU4Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzQXV0b0luY3JlbWVudDogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgVThDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgZGVmYXVsdFZhbHVlOiB2YWx1ZSB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBVOENvbHVtbkJ1aWxkZXIodGhpcywgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBuYW1lIH0pKTtcbiAgfVxufTtcbnZhciBVMTZCdWlsZGVyID0gY2xhc3MgZXh0ZW5kcyBUeXBlQnVpbGRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKEFsZ2VicmFpY1R5cGUuVTE2KTtcbiAgfVxuICBpbmRleChhbGdvcml0aG0gPSBcImJ0cmVlXCIpIHtcbiAgICByZXR1cm4gbmV3IFUxNkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpbmRleFR5cGU6IGFsZ29yaXRobSB9KVxuICAgICk7XG4gIH1cbiAgdW5pcXVlKCkge1xuICAgIHJldHVybiBuZXcgVTE2Q29sdW1uQnVpbGRlcih0aGlzLCBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzVW5pcXVlOiB0cnVlIH0pKTtcbiAgfVxuICBwcmltYXJ5S2V5KCkge1xuICAgIHJldHVybiBuZXcgVTE2Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzUHJpbWFyeUtleTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgYXV0b0luYygpIHtcbiAgICByZXR1cm4gbmV3IFUxNkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc0F1dG9JbmNyZW1lbnQ6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IFUxNkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBkZWZhdWx0VmFsdWU6IHZhbHVlIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IFUxNkNvbHVtbkJ1aWxkZXIodGhpcywgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBuYW1lIH0pKTtcbiAgfVxufTtcbnZhciBVMzJCdWlsZGVyID0gY2xhc3MgZXh0ZW5kcyBUeXBlQnVpbGRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKEFsZ2VicmFpY1R5cGUuVTMyKTtcbiAgfVxuICBpbmRleChhbGdvcml0aG0gPSBcImJ0cmVlXCIpIHtcbiAgICByZXR1cm4gbmV3IFUzMkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpbmRleFR5cGU6IGFsZ29yaXRobSB9KVxuICAgICk7XG4gIH1cbiAgdW5pcXVlKCkge1xuICAgIHJldHVybiBuZXcgVTMyQ29sdW1uQnVpbGRlcih0aGlzLCBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzVW5pcXVlOiB0cnVlIH0pKTtcbiAgfVxuICBwcmltYXJ5S2V5KCkge1xuICAgIHJldHVybiBuZXcgVTMyQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzUHJpbWFyeUtleTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgYXV0b0luYygpIHtcbiAgICByZXR1cm4gbmV3IFUzMkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc0F1dG9JbmNyZW1lbnQ6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IFUzMkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBkZWZhdWx0VmFsdWU6IHZhbHVlIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IFUzMkNvbHVtbkJ1aWxkZXIodGhpcywgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBuYW1lIH0pKTtcbiAgfVxufTtcbnZhciBVNjRCdWlsZGVyID0gY2xhc3MgZXh0ZW5kcyBUeXBlQnVpbGRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKEFsZ2VicmFpY1R5cGUuVTY0KTtcbiAgfVxuICBpbmRleChhbGdvcml0aG0gPSBcImJ0cmVlXCIpIHtcbiAgICByZXR1cm4gbmV3IFU2NENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpbmRleFR5cGU6IGFsZ29yaXRobSB9KVxuICAgICk7XG4gIH1cbiAgdW5pcXVlKCkge1xuICAgIHJldHVybiBuZXcgVTY0Q29sdW1uQnVpbGRlcih0aGlzLCBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzVW5pcXVlOiB0cnVlIH0pKTtcbiAgfVxuICBwcmltYXJ5S2V5KCkge1xuICAgIHJldHVybiBuZXcgVTY0Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzUHJpbWFyeUtleTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgYXV0b0luYygpIHtcbiAgICByZXR1cm4gbmV3IFU2NENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc0F1dG9JbmNyZW1lbnQ6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IFU2NENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBkZWZhdWx0VmFsdWU6IHZhbHVlIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IFU2NENvbHVtbkJ1aWxkZXIodGhpcywgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBuYW1lIH0pKTtcbiAgfVxufTtcbnZhciBVMTI4QnVpbGRlciA9IGNsYXNzIGV4dGVuZHMgVHlwZUJ1aWxkZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihBbGdlYnJhaWNUeXBlLlUxMjgpO1xuICB9XG4gIGluZGV4KGFsZ29yaXRobSA9IFwiYnRyZWVcIikge1xuICAgIHJldHVybiBuZXcgVTEyOENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpbmRleFR5cGU6IGFsZ29yaXRobSB9KVxuICAgICk7XG4gIH1cbiAgdW5pcXVlKCkge1xuICAgIHJldHVybiBuZXcgVTEyOENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc1VuaXF1ZTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgcHJpbWFyeUtleSgpIHtcbiAgICByZXR1cm4gbmV3IFUxMjhDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNQcmltYXJ5S2V5OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBhdXRvSW5jKCkge1xuICAgIHJldHVybiBuZXcgVTEyOENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc0F1dG9JbmNyZW1lbnQ6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IFUxMjhDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgZGVmYXVsdFZhbHVlOiB2YWx1ZSB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBVMTI4Q29sdW1uQnVpbGRlcih0aGlzLCBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IG5hbWUgfSkpO1xuICB9XG59O1xudmFyIFUyNTZCdWlsZGVyID0gY2xhc3MgZXh0ZW5kcyBUeXBlQnVpbGRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKEFsZ2VicmFpY1R5cGUuVTI1Nik7XG4gIH1cbiAgaW5kZXgoYWxnb3JpdGhtID0gXCJidHJlZVwiKSB7XG4gICAgcmV0dXJuIG5ldyBVMjU2Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGluZGV4VHlwZTogYWxnb3JpdGhtIH0pXG4gICAgKTtcbiAgfVxuICB1bmlxdWUoKSB7XG4gICAgcmV0dXJuIG5ldyBVMjU2Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzVW5pcXVlOiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBwcmltYXJ5S2V5KCkge1xuICAgIHJldHVybiBuZXcgVTI1NkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc1ByaW1hcnlLZXk6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGF1dG9JbmMoKSB7XG4gICAgcmV0dXJuIG5ldyBVMjU2Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzQXV0b0luY3JlbWVudDogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgVTI1NkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBkZWZhdWx0VmFsdWU6IHZhbHVlIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IFUyNTZDb2x1bW5CdWlsZGVyKHRoaXMsIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgbmFtZSB9KSk7XG4gIH1cbn07XG52YXIgSThCdWlsZGVyID0gY2xhc3MgZXh0ZW5kcyBUeXBlQnVpbGRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKEFsZ2VicmFpY1R5cGUuSTgpO1xuICB9XG4gIGluZGV4KGFsZ29yaXRobSA9IFwiYnRyZWVcIikge1xuICAgIHJldHVybiBuZXcgSThDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaW5kZXhUeXBlOiBhbGdvcml0aG0gfSlcbiAgICApO1xuICB9XG4gIHVuaXF1ZSgpIHtcbiAgICByZXR1cm4gbmV3IEk4Q29sdW1uQnVpbGRlcih0aGlzLCBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzVW5pcXVlOiB0cnVlIH0pKTtcbiAgfVxuICBwcmltYXJ5S2V5KCkge1xuICAgIHJldHVybiBuZXcgSThDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNQcmltYXJ5S2V5OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBhdXRvSW5jKCkge1xuICAgIHJldHVybiBuZXcgSThDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNBdXRvSW5jcmVtZW50OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBJOENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBkZWZhdWx0VmFsdWU6IHZhbHVlIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IEk4Q29sdW1uQnVpbGRlcih0aGlzLCBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IG5hbWUgfSkpO1xuICB9XG59O1xudmFyIEkxNkJ1aWxkZXIgPSBjbGFzcyBleHRlbmRzIFR5cGVCdWlsZGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoQWxnZWJyYWljVHlwZS5JMTYpO1xuICB9XG4gIGluZGV4KGFsZ29yaXRobSA9IFwiYnRyZWVcIikge1xuICAgIHJldHVybiBuZXcgSTE2Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGluZGV4VHlwZTogYWxnb3JpdGhtIH0pXG4gICAgKTtcbiAgfVxuICB1bmlxdWUoKSB7XG4gICAgcmV0dXJuIG5ldyBJMTZDb2x1bW5CdWlsZGVyKHRoaXMsIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNVbmlxdWU6IHRydWUgfSkpO1xuICB9XG4gIHByaW1hcnlLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBJMTZDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNQcmltYXJ5S2V5OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBhdXRvSW5jKCkge1xuICAgIHJldHVybiBuZXcgSTE2Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzQXV0b0luY3JlbWVudDogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgSTE2Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGRlZmF1bHRWYWx1ZTogdmFsdWUgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgSTE2Q29sdW1uQnVpbGRlcih0aGlzLCBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IG5hbWUgfSkpO1xuICB9XG59O1xudmFyIEkzMkJ1aWxkZXIgPSBjbGFzcyBleHRlbmRzIFR5cGVCdWlsZGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoQWxnZWJyYWljVHlwZS5JMzIpO1xuICB9XG4gIGluZGV4KGFsZ29yaXRobSA9IFwiYnRyZWVcIikge1xuICAgIHJldHVybiBuZXcgSTMyQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGluZGV4VHlwZTogYWxnb3JpdGhtIH0pXG4gICAgKTtcbiAgfVxuICB1bmlxdWUoKSB7XG4gICAgcmV0dXJuIG5ldyBJMzJDb2x1bW5CdWlsZGVyKHRoaXMsIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNVbmlxdWU6IHRydWUgfSkpO1xuICB9XG4gIHByaW1hcnlLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBJMzJDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNQcmltYXJ5S2V5OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBhdXRvSW5jKCkge1xuICAgIHJldHVybiBuZXcgSTMyQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzQXV0b0luY3JlbWVudDogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgSTMyQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGRlZmF1bHRWYWx1ZTogdmFsdWUgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgSTMyQ29sdW1uQnVpbGRlcih0aGlzLCBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IG5hbWUgfSkpO1xuICB9XG59O1xudmFyIEk2NEJ1aWxkZXIgPSBjbGFzcyBleHRlbmRzIFR5cGVCdWlsZGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoQWxnZWJyYWljVHlwZS5JNjQpO1xuICB9XG4gIGluZGV4KGFsZ29yaXRobSA9IFwiYnRyZWVcIikge1xuICAgIHJldHVybiBuZXcgSTY0Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGluZGV4VHlwZTogYWxnb3JpdGhtIH0pXG4gICAgKTtcbiAgfVxuICB1bmlxdWUoKSB7XG4gICAgcmV0dXJuIG5ldyBJNjRDb2x1bW5CdWlsZGVyKHRoaXMsIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNVbmlxdWU6IHRydWUgfSkpO1xuICB9XG4gIHByaW1hcnlLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBJNjRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNQcmltYXJ5S2V5OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBhdXRvSW5jKCkge1xuICAgIHJldHVybiBuZXcgSTY0Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzQXV0b0luY3JlbWVudDogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgSTY0Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGRlZmF1bHRWYWx1ZTogdmFsdWUgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgSTY0Q29sdW1uQnVpbGRlcih0aGlzLCBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IG5hbWUgfSkpO1xuICB9XG59O1xudmFyIEkxMjhCdWlsZGVyID0gY2xhc3MgZXh0ZW5kcyBUeXBlQnVpbGRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKEFsZ2VicmFpY1R5cGUuSTEyOCk7XG4gIH1cbiAgaW5kZXgoYWxnb3JpdGhtID0gXCJidHJlZVwiKSB7XG4gICAgcmV0dXJuIG5ldyBJMTI4Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGluZGV4VHlwZTogYWxnb3JpdGhtIH0pXG4gICAgKTtcbiAgfVxuICB1bmlxdWUoKSB7XG4gICAgcmV0dXJuIG5ldyBJMTI4Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzVW5pcXVlOiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBwcmltYXJ5S2V5KCkge1xuICAgIHJldHVybiBuZXcgSTEyOENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc1ByaW1hcnlLZXk6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGF1dG9JbmMoKSB7XG4gICAgcmV0dXJuIG5ldyBJMTI4Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzQXV0b0luY3JlbWVudDogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgSTEyOENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBkZWZhdWx0VmFsdWU6IHZhbHVlIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IEkxMjhDb2x1bW5CdWlsZGVyKHRoaXMsIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgbmFtZSB9KSk7XG4gIH1cbn07XG52YXIgSTI1NkJ1aWxkZXIgPSBjbGFzcyBleHRlbmRzIFR5cGVCdWlsZGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoQWxnZWJyYWljVHlwZS5JMjU2KTtcbiAgfVxuICBpbmRleChhbGdvcml0aG0gPSBcImJ0cmVlXCIpIHtcbiAgICByZXR1cm4gbmV3IEkyNTZDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaW5kZXhUeXBlOiBhbGdvcml0aG0gfSlcbiAgICApO1xuICB9XG4gIHVuaXF1ZSgpIHtcbiAgICByZXR1cm4gbmV3IEkyNTZDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNVbmlxdWU6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIHByaW1hcnlLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBJMjU2Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzUHJpbWFyeUtleTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgYXV0b0luYygpIHtcbiAgICByZXR1cm4gbmV3IEkyNTZDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNBdXRvSW5jcmVtZW50OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBJMjU2Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGRlZmF1bHRWYWx1ZTogdmFsdWUgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgSTI1NkNvbHVtbkJ1aWxkZXIodGhpcywgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBuYW1lIH0pKTtcbiAgfVxufTtcbnZhciBGMzJCdWlsZGVyID0gY2xhc3MgZXh0ZW5kcyBUeXBlQnVpbGRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKEFsZ2VicmFpY1R5cGUuRjMyKTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBGMzJDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgZGVmYXVsdFZhbHVlOiB2YWx1ZSB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBGMzJDb2x1bW5CdWlsZGVyKHRoaXMsIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgbmFtZSB9KSk7XG4gIH1cbn07XG52YXIgRjY0QnVpbGRlciA9IGNsYXNzIGV4dGVuZHMgVHlwZUJ1aWxkZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihBbGdlYnJhaWNUeXBlLkY2NCk7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgRjY0Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGRlZmF1bHRWYWx1ZTogdmFsdWUgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgRjY0Q29sdW1uQnVpbGRlcih0aGlzLCBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IG5hbWUgfSkpO1xuICB9XG59O1xudmFyIEJvb2xCdWlsZGVyID0gY2xhc3MgZXh0ZW5kcyBUeXBlQnVpbGRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKEFsZ2VicmFpY1R5cGUuQm9vbCk7XG4gIH1cbiAgaW5kZXgoYWxnb3JpdGhtID0gXCJidHJlZVwiKSB7XG4gICAgcmV0dXJuIG5ldyBCb29sQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGluZGV4VHlwZTogYWxnb3JpdGhtIH0pXG4gICAgKTtcbiAgfVxuICB1bmlxdWUoKSB7XG4gICAgcmV0dXJuIG5ldyBCb29sQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzVW5pcXVlOiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBwcmltYXJ5S2V5KCkge1xuICAgIHJldHVybiBuZXcgQm9vbENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc1ByaW1hcnlLZXk6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IEJvb2xDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgZGVmYXVsdFZhbHVlOiB2YWx1ZSB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBCb29sQ29sdW1uQnVpbGRlcih0aGlzLCBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IG5hbWUgfSkpO1xuICB9XG59O1xudmFyIFN0cmluZ0J1aWxkZXIgPSBjbGFzcyBleHRlbmRzIFR5cGVCdWlsZGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoQWxnZWJyYWljVHlwZS5TdHJpbmcpO1xuICB9XG4gIGluZGV4KGFsZ29yaXRobSA9IFwiYnRyZWVcIikge1xuICAgIHJldHVybiBuZXcgU3RyaW5nQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGluZGV4VHlwZTogYWxnb3JpdGhtIH0pXG4gICAgKTtcbiAgfVxuICB1bmlxdWUoKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJpbmdDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNVbmlxdWU6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIHByaW1hcnlLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJpbmdDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNQcmltYXJ5S2V5OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJpbmdDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgZGVmYXVsdFZhbHVlOiB2YWx1ZSB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJpbmdDb2x1bW5CdWlsZGVyKHRoaXMsIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgbmFtZSB9KSk7XG4gIH1cbn07XG52YXIgQXJyYXlCdWlsZGVyID0gY2xhc3MgZXh0ZW5kcyBUeXBlQnVpbGRlciB7XG4gIGVsZW1lbnQ7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQpIHtcbiAgICBzdXBlcihBbGdlYnJhaWNUeXBlLkFycmF5KGVsZW1lbnQuYWxnZWJyYWljVHlwZSkpO1xuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgQXJyYXlDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy5lbGVtZW50LFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBkZWZhdWx0VmFsdWU6IHZhbHVlIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IEFycmF5Q29sdW1uQnVpbGRlcih0aGlzLmVsZW1lbnQsIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgbmFtZSB9KSk7XG4gIH1cbn07XG52YXIgQnl0ZUFycmF5QnVpbGRlciA9IGNsYXNzIGV4dGVuZHMgVHlwZUJ1aWxkZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihBbGdlYnJhaWNUeXBlLkFycmF5KEFsZ2VicmFpY1R5cGUuVTgpKTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBCeXRlQXJyYXlDb2x1bW5CdWlsZGVyKFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBkZWZhdWx0VmFsdWU6IHZhbHVlIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IEJ5dGVBcnJheUNvbHVtbkJ1aWxkZXIoc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBuYW1lIH0pKTtcbiAgfVxufTtcbnZhciBPcHRpb25CdWlsZGVyID0gY2xhc3MgZXh0ZW5kcyBUeXBlQnVpbGRlciB7XG4gIHZhbHVlO1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgIHN1cGVyKE9wdGlvbi5nZXRBbGdlYnJhaWNUeXBlKHZhbHVlLmFsZ2VicmFpY1R5cGUpKTtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgT3B0aW9uQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGRlZmF1bHRWYWx1ZTogdmFsdWUgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgT3B0aW9uQ29sdW1uQnVpbGRlcih0aGlzLCBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IG5hbWUgfSkpO1xuICB9XG59O1xudmFyIFByb2R1Y3RCdWlsZGVyID0gY2xhc3MgZXh0ZW5kcyBUeXBlQnVpbGRlciB7XG4gIHR5cGVOYW1lO1xuICBlbGVtZW50cztcbiAgY29uc3RydWN0b3IoZWxlbWVudHMsIG5hbWUpIHtcbiAgICBmdW5jdGlvbiBlbGVtZW50c0FycmF5RnJvbUVsZW1lbnRzT2JqKG9iaikge1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubWFwKChrZXkpID0+ICh7XG4gICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgLy8gTGF6aWx5IHJlc29sdmUgdGhlIHVuZGVybHlpbmcgb2JqZWN0J3MgYWxnZWJyYWljVHlwZS5cbiAgICAgICAgLy8gVGhpcyB3aWxsIGNhbGwgb2JqW2tleV0uYWxnZWJyYWljVHlwZSBvbmx5IHdoZW4gc29tZW9uZVxuICAgICAgICAvLyBhY3R1YWxseSByZWFkcyB0aGlzIHByb3BlcnR5LlxuICAgICAgICBnZXQgYWxnZWJyYWljVHlwZSgpIHtcbiAgICAgICAgICByZXR1cm4gb2JqW2tleV0uYWxnZWJyYWljVHlwZTtcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgIH1cbiAgICBzdXBlcihcbiAgICAgIEFsZ2VicmFpY1R5cGUuUHJvZHVjdCh7XG4gICAgICAgIGVsZW1lbnRzOiBlbGVtZW50c0FycmF5RnJvbUVsZW1lbnRzT2JqKGVsZW1lbnRzKVxuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMudHlwZU5hbWUgPSBuYW1lO1xuICAgIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50cztcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9kdWN0Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGRlZmF1bHRWYWx1ZTogdmFsdWUgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgUHJvZHVjdENvbHVtbkJ1aWxkZXIodGhpcywgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBuYW1lIH0pKTtcbiAgfVxufTtcbnZhciBSZXN1bHRCdWlsZGVyID0gY2xhc3MgZXh0ZW5kcyBUeXBlQnVpbGRlciB7XG4gIG9rO1xuICBlcnI7XG4gIGNvbnN0cnVjdG9yKG9rLCBlcnIpIHtcbiAgICBzdXBlcihSZXN1bHQuZ2V0QWxnZWJyYWljVHlwZShvay5hbGdlYnJhaWNUeXBlLCBlcnIuYWxnZWJyYWljVHlwZSkpO1xuICAgIHRoaXMub2sgPSBvaztcbiAgICB0aGlzLmVyciA9IGVycjtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBSZXN1bHRDb2x1bW5CdWlsZGVyKHRoaXMsIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgZGVmYXVsdFZhbHVlOiB2YWx1ZSB9KSk7XG4gIH1cbn07XG52YXIgVW5pdEJ1aWxkZXIgPSBjbGFzcyBleHRlbmRzIFR5cGVCdWlsZGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoeyB0YWc6IFwiUHJvZHVjdFwiLCB2YWx1ZTogeyBlbGVtZW50czogW10gfSB9KTtcbiAgfVxufTtcbnZhciBSb3dCdWlsZGVyID0gY2xhc3MgZXh0ZW5kcyBUeXBlQnVpbGRlciB7XG4gIHJvdztcbiAgdHlwZU5hbWU7XG4gIGNvbnN0cnVjdG9yKHJvdywgbmFtZSkge1xuICAgIGNvbnN0IG1hcHBlZFJvdyA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgIE9iamVjdC5lbnRyaWVzKHJvdykubWFwKChbY29sTmFtZSwgYnVpbGRlcl0pID0+IFtcbiAgICAgICAgY29sTmFtZSxcbiAgICAgICAgYnVpbGRlciBpbnN0YW5jZW9mIENvbHVtbkJ1aWxkZXIgPyBidWlsZGVyIDogbmV3IENvbHVtbkJ1aWxkZXIoYnVpbGRlciwge30pXG4gICAgICBdKVxuICAgICk7XG4gICAgY29uc3QgZWxlbWVudHMgPSBPYmplY3Qua2V5cyhtYXBwZWRSb3cpLm1hcCgobmFtZTIpID0+ICh7XG4gICAgICBuYW1lOiBuYW1lMixcbiAgICAgIGdldCBhbGdlYnJhaWNUeXBlKCkge1xuICAgICAgICByZXR1cm4gbWFwcGVkUm93W25hbWUyXS50eXBlQnVpbGRlci5hbGdlYnJhaWNUeXBlO1xuICAgICAgfVxuICAgIH0pKTtcbiAgICBzdXBlcihBbGdlYnJhaWNUeXBlLlByb2R1Y3QoeyBlbGVtZW50cyB9KSk7XG4gICAgdGhpcy5yb3cgPSBtYXBwZWRSb3c7XG4gICAgdGhpcy50eXBlTmFtZSA9IG5hbWU7XG4gIH1cbn07XG52YXIgU3VtQnVpbGRlckltcGwgPSBjbGFzcyBleHRlbmRzIFR5cGVCdWlsZGVyIHtcbiAgdmFyaWFudHM7XG4gIHR5cGVOYW1lO1xuICBjb25zdHJ1Y3Rvcih2YXJpYW50cywgbmFtZSkge1xuICAgIGZ1bmN0aW9uIHZhcmlhbnRzQXJyYXlGcm9tVmFyaWFudHNPYmoodmFyaWFudHMyKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXModmFyaWFudHMyKS5tYXAoKGtleSkgPT4gKHtcbiAgICAgICAgbmFtZToga2V5LFxuICAgICAgICAvLyBMYXppbHkgcmVzb2x2ZSB0aGUgdW5kZXJseWluZyBvYmplY3QncyBhbGdlYnJhaWNUeXBlLlxuICAgICAgICAvLyBUaGlzIHdpbGwgY2FsbCBvYmpba2V5XS5hbGdlYnJhaWNUeXBlIG9ubHkgd2hlbiBzb21lb25lXG4gICAgICAgIC8vIGFjdHVhbGx5IHJlYWRzIHRoaXMgcHJvcGVydHkuXG4gICAgICAgIGdldCBhbGdlYnJhaWNUeXBlKCkge1xuICAgICAgICAgIHJldHVybiB2YXJpYW50czJba2V5XS5hbGdlYnJhaWNUeXBlO1xuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgfVxuICAgIHN1cGVyKFxuICAgICAgQWxnZWJyYWljVHlwZS5TdW0oe1xuICAgICAgICB2YXJpYW50czogdmFyaWFudHNBcnJheUZyb21WYXJpYW50c09iaih2YXJpYW50cylcbiAgICAgIH0pXG4gICAgKTtcbiAgICB0aGlzLnZhcmlhbnRzID0gdmFyaWFudHM7XG4gICAgdGhpcy50eXBlTmFtZSA9IG5hbWU7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModmFyaWFudHMpKSB7XG4gICAgICBjb25zdCBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YXJpYW50cywga2V5KTtcbiAgICAgIGNvbnN0IGlzQWNjZXNzb3IgPSAhIWRlc2MgJiYgKHR5cGVvZiBkZXNjLmdldCA9PT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiBkZXNjLnNldCA9PT0gXCJmdW5jdGlvblwiKTtcbiAgICAgIGxldCBpc1VuaXQyID0gZmFsc2U7XG4gICAgICBpZiAoIWlzQWNjZXNzb3IpIHtcbiAgICAgICAgY29uc3QgdmFyaWFudCA9IHZhcmlhbnRzW2tleV07XG4gICAgICAgIGlzVW5pdDIgPSB2YXJpYW50IGluc3RhbmNlb2YgVW5pdEJ1aWxkZXI7XG4gICAgICB9XG4gICAgICBpZiAoaXNVbml0Mikge1xuICAgICAgICBjb25zdCBjb25zdGFudCA9IHRoaXMuY3JlYXRlKGtleSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBrZXksIHtcbiAgICAgICAgICB2YWx1ZTogY29uc3RhbnQsXG4gICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGZuID0gKCh2YWx1ZSkgPT4gdGhpcy5jcmVhdGUoa2V5LCB2YWx1ZSkpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywga2V5LCB7XG4gICAgICAgICAgdmFsdWU6IGZuLFxuICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNyZWF0ZSh0YWcsIHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB2b2lkIDAgPyB7IHRhZyB9IDogeyB0YWcsIHZhbHVlIH07XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgU3VtQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGRlZmF1bHRWYWx1ZTogdmFsdWUgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgU3VtQ29sdW1uQnVpbGRlcih0aGlzLCBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IG5hbWUgfSkpO1xuICB9XG59O1xudmFyIFN1bUJ1aWxkZXIgPSBTdW1CdWlsZGVySW1wbDtcbnZhciBTaW1wbGVTdW1CdWlsZGVySW1wbCA9IGNsYXNzIGV4dGVuZHMgU3VtQnVpbGRlckltcGwge1xuICBpbmRleChhbGdvcml0aG0gPSBcImJ0cmVlXCIpIHtcbiAgICByZXR1cm4gbmV3IFNpbXBsZVN1bUNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpbmRleFR5cGU6IGFsZ29yaXRobSB9KVxuICAgICk7XG4gIH1cbiAgcHJpbWFyeUtleSgpIHtcbiAgICByZXR1cm4gbmV3IFNpbXBsZVN1bUNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc1ByaW1hcnlLZXk6IHRydWUgfSlcbiAgICApO1xuICB9XG59O1xudmFyIFNpbXBsZVN1bUJ1aWxkZXIgPSBTaW1wbGVTdW1CdWlsZGVySW1wbDtcbnZhciBTY2hlZHVsZUF0QnVpbGRlciA9IGNsYXNzIGV4dGVuZHMgVHlwZUJ1aWxkZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihzY2hlZHVsZV9hdF9kZWZhdWx0LmdldEFsZ2VicmFpY1R5cGUoKSk7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgU2NoZWR1bGVBdENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBkZWZhdWx0VmFsdWU6IHZhbHVlIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IFNjaGVkdWxlQXRDb2x1bW5CdWlsZGVyKHRoaXMsIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgbmFtZSB9KSk7XG4gIH1cbn07XG52YXIgSWRlbnRpdHlCdWlsZGVyID0gY2xhc3MgZXh0ZW5kcyBUeXBlQnVpbGRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKElkZW50aXR5LmdldEFsZ2VicmFpY1R5cGUoKSk7XG4gIH1cbiAgaW5kZXgoYWxnb3JpdGhtID0gXCJidHJlZVwiKSB7XG4gICAgcmV0dXJuIG5ldyBJZGVudGl0eUNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpbmRleFR5cGU6IGFsZ29yaXRobSB9KVxuICAgICk7XG4gIH1cbiAgdW5pcXVlKCkge1xuICAgIHJldHVybiBuZXcgSWRlbnRpdHlDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNVbmlxdWU6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIHByaW1hcnlLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBJZGVudGl0eUNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc1ByaW1hcnlLZXk6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGF1dG9JbmMoKSB7XG4gICAgcmV0dXJuIG5ldyBJZGVudGl0eUNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc0F1dG9JbmNyZW1lbnQ6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IElkZW50aXR5Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGRlZmF1bHRWYWx1ZTogdmFsdWUgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgSWRlbnRpdHlDb2x1bW5CdWlsZGVyKHRoaXMsIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgbmFtZSB9KSk7XG4gIH1cbn07XG52YXIgQ29ubmVjdGlvbklkQnVpbGRlciA9IGNsYXNzIGV4dGVuZHMgVHlwZUJ1aWxkZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihDb25uZWN0aW9uSWQuZ2V0QWxnZWJyYWljVHlwZSgpKTtcbiAgfVxuICBpbmRleChhbGdvcml0aG0gPSBcImJ0cmVlXCIpIHtcbiAgICByZXR1cm4gbmV3IENvbm5lY3Rpb25JZENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpbmRleFR5cGU6IGFsZ29yaXRobSB9KVxuICAgICk7XG4gIH1cbiAgdW5pcXVlKCkge1xuICAgIHJldHVybiBuZXcgQ29ubmVjdGlvbklkQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzVW5pcXVlOiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBwcmltYXJ5S2V5KCkge1xuICAgIHJldHVybiBuZXcgQ29ubmVjdGlvbklkQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzUHJpbWFyeUtleTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgYXV0b0luYygpIHtcbiAgICByZXR1cm4gbmV3IENvbm5lY3Rpb25JZENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc0F1dG9JbmNyZW1lbnQ6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IENvbm5lY3Rpb25JZENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBkZWZhdWx0VmFsdWU6IHZhbHVlIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IENvbm5lY3Rpb25JZENvbHVtbkJ1aWxkZXIodGhpcywgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBuYW1lIH0pKTtcbiAgfVxufTtcbnZhciBUaW1lc3RhbXBCdWlsZGVyID0gY2xhc3MgZXh0ZW5kcyBUeXBlQnVpbGRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFRpbWVzdGFtcC5nZXRBbGdlYnJhaWNUeXBlKCkpO1xuICB9XG4gIGluZGV4KGFsZ29yaXRobSA9IFwiYnRyZWVcIikge1xuICAgIHJldHVybiBuZXcgVGltZXN0YW1wQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGluZGV4VHlwZTogYWxnb3JpdGhtIH0pXG4gICAgKTtcbiAgfVxuICB1bmlxdWUoKSB7XG4gICAgcmV0dXJuIG5ldyBUaW1lc3RhbXBDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNVbmlxdWU6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIHByaW1hcnlLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBUaW1lc3RhbXBDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNQcmltYXJ5S2V5OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBhdXRvSW5jKCkge1xuICAgIHJldHVybiBuZXcgVGltZXN0YW1wQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzQXV0b0luY3JlbWVudDogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgVGltZXN0YW1wQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGRlZmF1bHRWYWx1ZTogdmFsdWUgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgVGltZXN0YW1wQ29sdW1uQnVpbGRlcih0aGlzLCBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IG5hbWUgfSkpO1xuICB9XG59O1xudmFyIFRpbWVEdXJhdGlvbkJ1aWxkZXIgPSBjbGFzcyBleHRlbmRzIFR5cGVCdWlsZGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoVGltZUR1cmF0aW9uLmdldEFsZ2VicmFpY1R5cGUoKSk7XG4gIH1cbiAgaW5kZXgoYWxnb3JpdGhtID0gXCJidHJlZVwiKSB7XG4gICAgcmV0dXJuIG5ldyBUaW1lRHVyYXRpb25Db2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaW5kZXhUeXBlOiBhbGdvcml0aG0gfSlcbiAgICApO1xuICB9XG4gIHVuaXF1ZSgpIHtcbiAgICByZXR1cm4gbmV3IFRpbWVEdXJhdGlvbkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc1VuaXF1ZTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgcHJpbWFyeUtleSgpIHtcbiAgICByZXR1cm4gbmV3IFRpbWVEdXJhdGlvbkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc1ByaW1hcnlLZXk6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGF1dG9JbmMoKSB7XG4gICAgcmV0dXJuIG5ldyBUaW1lRHVyYXRpb25Db2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNBdXRvSW5jcmVtZW50OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBUaW1lRHVyYXRpb25Db2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgZGVmYXVsdFZhbHVlOiB2YWx1ZSB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBUaW1lRHVyYXRpb25Db2x1bW5CdWlsZGVyKHRoaXMsIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgbmFtZSB9KSk7XG4gIH1cbn07XG52YXIgVXVpZEJ1aWxkZXIgPSBjbGFzcyBleHRlbmRzIFR5cGVCdWlsZGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoVXVpZC5nZXRBbGdlYnJhaWNUeXBlKCkpO1xuICB9XG4gIGluZGV4KGFsZ29yaXRobSA9IFwiYnRyZWVcIikge1xuICAgIHJldHVybiBuZXcgVXVpZENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpbmRleFR5cGU6IGFsZ29yaXRobSB9KVxuICAgICk7XG4gIH1cbiAgdW5pcXVlKCkge1xuICAgIHJldHVybiBuZXcgVXVpZENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc1VuaXF1ZTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgcHJpbWFyeUtleSgpIHtcbiAgICByZXR1cm4gbmV3IFV1aWRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNQcmltYXJ5S2V5OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBhdXRvSW5jKCkge1xuICAgIHJldHVybiBuZXcgVXVpZENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc0F1dG9JbmNyZW1lbnQ6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IFV1aWRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgZGVmYXVsdFZhbHVlOiB2YWx1ZSB9KVxuICAgICk7XG4gIH1cbn07XG52YXIgZGVmYXVsdE1ldGFkYXRhID0ge307XG52YXIgQ29sdW1uQnVpbGRlciA9IGNsYXNzIHtcbiAgdHlwZUJ1aWxkZXI7XG4gIGNvbHVtbk1ldGFkYXRhO1xuICBjb25zdHJ1Y3Rvcih0eXBlQnVpbGRlciwgbWV0YWRhdGEpIHtcbiAgICB0aGlzLnR5cGVCdWlsZGVyID0gdHlwZUJ1aWxkZXI7XG4gICAgdGhpcy5jb2x1bW5NZXRhZGF0YSA9IG1ldGFkYXRhO1xuICB9XG4gIHNlcmlhbGl6ZSh3cml0ZXIsIHZhbHVlKSB7XG4gICAgQWxnZWJyYWljVHlwZS5zZXJpYWxpemVWYWx1ZSh3cml0ZXIsIHRoaXMudHlwZUJ1aWxkZXIuYWxnZWJyYWljVHlwZSwgdmFsdWUpO1xuICB9XG4gIGRlc2VyaWFsaXplKHJlYWRlcikge1xuICAgIHJldHVybiBBbGdlYnJhaWNUeXBlLmRlc2VyaWFsaXplVmFsdWUoXG4gICAgICByZWFkZXIsXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLmFsZ2VicmFpY1R5cGVcbiAgICApO1xuICB9XG59O1xudmFyIFU4Q29sdW1uQnVpbGRlciA9IGNsYXNzIF9VOENvbHVtbkJ1aWxkZXIgZXh0ZW5kcyBDb2x1bW5CdWlsZGVyIHtcbiAgaW5kZXgoYWxnb3JpdGhtID0gXCJidHJlZVwiKSB7XG4gICAgcmV0dXJuIG5ldyBfVThDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGluZGV4VHlwZTogYWxnb3JpdGhtIH0pXG4gICAgKTtcbiAgfVxuICB1bmlxdWUoKSB7XG4gICAgcmV0dXJuIG5ldyBfVThDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzVW5pcXVlOiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBwcmltYXJ5S2V5KCkge1xuICAgIHJldHVybiBuZXcgX1U4Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc1ByaW1hcnlLZXk6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGF1dG9JbmMoKSB7XG4gICAgcmV0dXJuIG5ldyBfVThDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzQXV0b0luY3JlbWVudDogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgX1U4Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwge1xuICAgICAgICBkZWZhdWx0VmFsdWU6IHZhbHVlXG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBfVThDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IG5hbWUgfSlcbiAgICApO1xuICB9XG59O1xudmFyIFUxNkNvbHVtbkJ1aWxkZXIgPSBjbGFzcyBfVTE2Q29sdW1uQnVpbGRlciBleHRlbmRzIENvbHVtbkJ1aWxkZXIge1xuICBpbmRleChhbGdvcml0aG0gPSBcImJ0cmVlXCIpIHtcbiAgICByZXR1cm4gbmV3IF9VMTZDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGluZGV4VHlwZTogYWxnb3JpdGhtIH0pXG4gICAgKTtcbiAgfVxuICB1bmlxdWUoKSB7XG4gICAgcmV0dXJuIG5ldyBfVTE2Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc1VuaXF1ZTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgcHJpbWFyeUtleSgpIHtcbiAgICByZXR1cm4gbmV3IF9VMTZDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzUHJpbWFyeUtleTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgYXV0b0luYygpIHtcbiAgICByZXR1cm4gbmV3IF9VMTZDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzQXV0b0luY3JlbWVudDogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgX1UxNkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHtcbiAgICAgICAgZGVmYXVsdFZhbHVlOiB2YWx1ZVxuICAgICAgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgX1UxNkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgbmFtZSB9KVxuICAgICk7XG4gIH1cbn07XG52YXIgVTMyQ29sdW1uQnVpbGRlciA9IGNsYXNzIF9VMzJDb2x1bW5CdWlsZGVyIGV4dGVuZHMgQ29sdW1uQnVpbGRlciB7XG4gIGluZGV4KGFsZ29yaXRobSA9IFwiYnRyZWVcIikge1xuICAgIHJldHVybiBuZXcgX1UzMkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaW5kZXhUeXBlOiBhbGdvcml0aG0gfSlcbiAgICApO1xuICB9XG4gIHVuaXF1ZSgpIHtcbiAgICByZXR1cm4gbmV3IF9VMzJDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzVW5pcXVlOiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBwcmltYXJ5S2V5KCkge1xuICAgIHJldHVybiBuZXcgX1UzMkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNQcmltYXJ5S2V5OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBhdXRvSW5jKCkge1xuICAgIHJldHVybiBuZXcgX1UzMkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNBdXRvSW5jcmVtZW50OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBfVTMyQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwge1xuICAgICAgICBkZWZhdWx0VmFsdWU6IHZhbHVlXG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBfVTMyQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBuYW1lIH0pXG4gICAgKTtcbiAgfVxufTtcbnZhciBVNjRDb2x1bW5CdWlsZGVyID0gY2xhc3MgX1U2NENvbHVtbkJ1aWxkZXIgZXh0ZW5kcyBDb2x1bW5CdWlsZGVyIHtcbiAgaW5kZXgoYWxnb3JpdGhtID0gXCJidHJlZVwiKSB7XG4gICAgcmV0dXJuIG5ldyBfVTY0Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpbmRleFR5cGU6IGFsZ29yaXRobSB9KVxuICAgICk7XG4gIH1cbiAgdW5pcXVlKCkge1xuICAgIHJldHVybiBuZXcgX1U2NENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNVbmlxdWU6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIHByaW1hcnlLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBfVTY0Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc1ByaW1hcnlLZXk6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGF1dG9JbmMoKSB7XG4gICAgcmV0dXJuIG5ldyBfVTY0Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc0F1dG9JbmNyZW1lbnQ6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IF9VNjRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7XG4gICAgICAgIGRlZmF1bHRWYWx1ZTogdmFsdWVcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IF9VNjRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IG5hbWUgfSlcbiAgICApO1xuICB9XG59O1xudmFyIFUxMjhDb2x1bW5CdWlsZGVyID0gY2xhc3MgX1UxMjhDb2x1bW5CdWlsZGVyIGV4dGVuZHMgQ29sdW1uQnVpbGRlciB7XG4gIGluZGV4KGFsZ29yaXRobSA9IFwiYnRyZWVcIikge1xuICAgIHJldHVybiBuZXcgX1UxMjhDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGluZGV4VHlwZTogYWxnb3JpdGhtIH0pXG4gICAgKTtcbiAgfVxuICB1bmlxdWUoKSB7XG4gICAgcmV0dXJuIG5ldyBfVTEyOENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNVbmlxdWU6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIHByaW1hcnlLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBfVTEyOENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNQcmltYXJ5S2V5OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBhdXRvSW5jKCkge1xuICAgIHJldHVybiBuZXcgX1UxMjhDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzQXV0b0luY3JlbWVudDogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgX1UxMjhDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7XG4gICAgICAgIGRlZmF1bHRWYWx1ZTogdmFsdWVcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IF9VMTI4Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBuYW1lIH0pXG4gICAgKTtcbiAgfVxufTtcbnZhciBVMjU2Q29sdW1uQnVpbGRlciA9IGNsYXNzIF9VMjU2Q29sdW1uQnVpbGRlciBleHRlbmRzIENvbHVtbkJ1aWxkZXIge1xuICBpbmRleChhbGdvcml0aG0gPSBcImJ0cmVlXCIpIHtcbiAgICByZXR1cm4gbmV3IF9VMjU2Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpbmRleFR5cGU6IGFsZ29yaXRobSB9KVxuICAgICk7XG4gIH1cbiAgdW5pcXVlKCkge1xuICAgIHJldHVybiBuZXcgX1UyNTZDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzVW5pcXVlOiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBwcmltYXJ5S2V5KCkge1xuICAgIHJldHVybiBuZXcgX1UyNTZDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzUHJpbWFyeUtleTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgYXV0b0luYygpIHtcbiAgICByZXR1cm4gbmV3IF9VMjU2Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc0F1dG9JbmNyZW1lbnQ6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IF9VMjU2Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwge1xuICAgICAgICBkZWZhdWx0VmFsdWU6IHZhbHVlXG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBfVTI1NkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgbmFtZSB9KVxuICAgICk7XG4gIH1cbn07XG52YXIgSThDb2x1bW5CdWlsZGVyID0gY2xhc3MgX0k4Q29sdW1uQnVpbGRlciBleHRlbmRzIENvbHVtbkJ1aWxkZXIge1xuICBpbmRleChhbGdvcml0aG0gPSBcImJ0cmVlXCIpIHtcbiAgICByZXR1cm4gbmV3IF9JOENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaW5kZXhUeXBlOiBhbGdvcml0aG0gfSlcbiAgICApO1xuICB9XG4gIHVuaXF1ZSgpIHtcbiAgICByZXR1cm4gbmV3IF9JOENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNVbmlxdWU6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIHByaW1hcnlLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBfSThDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzUHJpbWFyeUtleTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgYXV0b0luYygpIHtcbiAgICByZXR1cm4gbmV3IF9JOENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNBdXRvSW5jcmVtZW50OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBfSThDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7XG4gICAgICAgIGRlZmF1bHRWYWx1ZTogdmFsdWVcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IF9JOENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgbmFtZSB9KVxuICAgICk7XG4gIH1cbn07XG52YXIgSTE2Q29sdW1uQnVpbGRlciA9IGNsYXNzIF9JMTZDb2x1bW5CdWlsZGVyIGV4dGVuZHMgQ29sdW1uQnVpbGRlciB7XG4gIGluZGV4KGFsZ29yaXRobSA9IFwiYnRyZWVcIikge1xuICAgIHJldHVybiBuZXcgX0kxNkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaW5kZXhUeXBlOiBhbGdvcml0aG0gfSlcbiAgICApO1xuICB9XG4gIHVuaXF1ZSgpIHtcbiAgICByZXR1cm4gbmV3IF9JMTZDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzVW5pcXVlOiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBwcmltYXJ5S2V5KCkge1xuICAgIHJldHVybiBuZXcgX0kxNkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNQcmltYXJ5S2V5OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBhdXRvSW5jKCkge1xuICAgIHJldHVybiBuZXcgX0kxNkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNBdXRvSW5jcmVtZW50OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBfSTE2Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwge1xuICAgICAgICBkZWZhdWx0VmFsdWU6IHZhbHVlXG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBfSTE2Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBuYW1lIH0pXG4gICAgKTtcbiAgfVxufTtcbnZhciBJMzJDb2x1bW5CdWlsZGVyID0gY2xhc3MgX0kzMkNvbHVtbkJ1aWxkZXIgZXh0ZW5kcyBDb2x1bW5CdWlsZGVyIHtcbiAgaW5kZXgoYWxnb3JpdGhtID0gXCJidHJlZVwiKSB7XG4gICAgcmV0dXJuIG5ldyBfSTMyQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpbmRleFR5cGU6IGFsZ29yaXRobSB9KVxuICAgICk7XG4gIH1cbiAgdW5pcXVlKCkge1xuICAgIHJldHVybiBuZXcgX0kzMkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNVbmlxdWU6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIHByaW1hcnlLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBfSTMyQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc1ByaW1hcnlLZXk6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGF1dG9JbmMoKSB7XG4gICAgcmV0dXJuIG5ldyBfSTMyQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc0F1dG9JbmNyZW1lbnQ6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IF9JMzJDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7XG4gICAgICAgIGRlZmF1bHRWYWx1ZTogdmFsdWVcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IF9JMzJDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IG5hbWUgfSlcbiAgICApO1xuICB9XG59O1xudmFyIEk2NENvbHVtbkJ1aWxkZXIgPSBjbGFzcyBfSTY0Q29sdW1uQnVpbGRlciBleHRlbmRzIENvbHVtbkJ1aWxkZXIge1xuICBpbmRleChhbGdvcml0aG0gPSBcImJ0cmVlXCIpIHtcbiAgICByZXR1cm4gbmV3IF9JNjRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGluZGV4VHlwZTogYWxnb3JpdGhtIH0pXG4gICAgKTtcbiAgfVxuICB1bmlxdWUoKSB7XG4gICAgcmV0dXJuIG5ldyBfSTY0Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc1VuaXF1ZTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgcHJpbWFyeUtleSgpIHtcbiAgICByZXR1cm4gbmV3IF9JNjRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzUHJpbWFyeUtleTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgYXV0b0luYygpIHtcbiAgICByZXR1cm4gbmV3IF9JNjRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzQXV0b0luY3JlbWVudDogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgX0k2NENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHtcbiAgICAgICAgZGVmYXVsdFZhbHVlOiB2YWx1ZVxuICAgICAgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgX0k2NENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgbmFtZSB9KVxuICAgICk7XG4gIH1cbn07XG52YXIgSTEyOENvbHVtbkJ1aWxkZXIgPSBjbGFzcyBfSTEyOENvbHVtbkJ1aWxkZXIgZXh0ZW5kcyBDb2x1bW5CdWlsZGVyIHtcbiAgaW5kZXgoYWxnb3JpdGhtID0gXCJidHJlZVwiKSB7XG4gICAgcmV0dXJuIG5ldyBfSTEyOENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaW5kZXhUeXBlOiBhbGdvcml0aG0gfSlcbiAgICApO1xuICB9XG4gIHVuaXF1ZSgpIHtcbiAgICByZXR1cm4gbmV3IF9JMTI4Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc1VuaXF1ZTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgcHJpbWFyeUtleSgpIHtcbiAgICByZXR1cm4gbmV3IF9JMTI4Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc1ByaW1hcnlLZXk6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGF1dG9JbmMoKSB7XG4gICAgcmV0dXJuIG5ldyBfSTEyOENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNBdXRvSW5jcmVtZW50OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBfSTEyOENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHtcbiAgICAgICAgZGVmYXVsdFZhbHVlOiB2YWx1ZVxuICAgICAgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgX0kxMjhDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IG5hbWUgfSlcbiAgICApO1xuICB9XG59O1xudmFyIEkyNTZDb2x1bW5CdWlsZGVyID0gY2xhc3MgX0kyNTZDb2x1bW5CdWlsZGVyIGV4dGVuZHMgQ29sdW1uQnVpbGRlciB7XG4gIGluZGV4KGFsZ29yaXRobSA9IFwiYnRyZWVcIikge1xuICAgIHJldHVybiBuZXcgX0kyNTZDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGluZGV4VHlwZTogYWxnb3JpdGhtIH0pXG4gICAgKTtcbiAgfVxuICB1bmlxdWUoKSB7XG4gICAgcmV0dXJuIG5ldyBfSTI1NkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNVbmlxdWU6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIHByaW1hcnlLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBfSTI1NkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNQcmltYXJ5S2V5OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBhdXRvSW5jKCkge1xuICAgIHJldHVybiBuZXcgX0kyNTZDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzQXV0b0luY3JlbWVudDogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgX0kyNTZDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7XG4gICAgICAgIGRlZmF1bHRWYWx1ZTogdmFsdWVcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IF9JMjU2Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBuYW1lIH0pXG4gICAgKTtcbiAgfVxufTtcbnZhciBGMzJDb2x1bW5CdWlsZGVyID0gY2xhc3MgX0YzMkNvbHVtbkJ1aWxkZXIgZXh0ZW5kcyBDb2x1bW5CdWlsZGVyIHtcbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgX0YzMkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHtcbiAgICAgICAgZGVmYXVsdFZhbHVlOiB2YWx1ZVxuICAgICAgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgX0YzMkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgbmFtZSB9KVxuICAgICk7XG4gIH1cbn07XG52YXIgRjY0Q29sdW1uQnVpbGRlciA9IGNsYXNzIF9GNjRDb2x1bW5CdWlsZGVyIGV4dGVuZHMgQ29sdW1uQnVpbGRlciB7XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IF9GNjRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7XG4gICAgICAgIGRlZmF1bHRWYWx1ZTogdmFsdWVcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IF9GNjRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IG5hbWUgfSlcbiAgICApO1xuICB9XG59O1xudmFyIEJvb2xDb2x1bW5CdWlsZGVyID0gY2xhc3MgX0Jvb2xDb2x1bW5CdWlsZGVyIGV4dGVuZHMgQ29sdW1uQnVpbGRlciB7XG4gIGluZGV4KGFsZ29yaXRobSA9IFwiYnRyZWVcIikge1xuICAgIHJldHVybiBuZXcgX0Jvb2xDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGluZGV4VHlwZTogYWxnb3JpdGhtIH0pXG4gICAgKTtcbiAgfVxuICB1bmlxdWUoKSB7XG4gICAgcmV0dXJuIG5ldyBfQm9vbENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNVbmlxdWU6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIHByaW1hcnlLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBfQm9vbENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNQcmltYXJ5S2V5OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBfQm9vbENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHtcbiAgICAgICAgZGVmYXVsdFZhbHVlOiB2YWx1ZVxuICAgICAgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgX0Jvb2xDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IG5hbWUgfSlcbiAgICApO1xuICB9XG59O1xudmFyIFN0cmluZ0NvbHVtbkJ1aWxkZXIgPSBjbGFzcyBfU3RyaW5nQ29sdW1uQnVpbGRlciBleHRlbmRzIENvbHVtbkJ1aWxkZXIge1xuICBpbmRleChhbGdvcml0aG0gPSBcImJ0cmVlXCIpIHtcbiAgICByZXR1cm4gbmV3IF9TdHJpbmdDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGluZGV4VHlwZTogYWxnb3JpdGhtIH0pXG4gICAgKTtcbiAgfVxuICB1bmlxdWUoKSB7XG4gICAgcmV0dXJuIG5ldyBfU3RyaW5nQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc1VuaXF1ZTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgcHJpbWFyeUtleSgpIHtcbiAgICByZXR1cm4gbmV3IF9TdHJpbmdDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzUHJpbWFyeUtleTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgX1N0cmluZ0NvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHtcbiAgICAgICAgZGVmYXVsdFZhbHVlOiB2YWx1ZVxuICAgICAgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgX1N0cmluZ0NvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgbmFtZSB9KVxuICAgICk7XG4gIH1cbn07XG52YXIgQXJyYXlDb2x1bW5CdWlsZGVyID0gY2xhc3MgX0FycmF5Q29sdW1uQnVpbGRlciBleHRlbmRzIENvbHVtbkJ1aWxkZXIge1xuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBfQXJyYXlDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7XG4gICAgICAgIGRlZmF1bHRWYWx1ZTogdmFsdWVcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IF9BcnJheUNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgbmFtZSB9KVxuICAgICk7XG4gIH1cbn07XG52YXIgQnl0ZUFycmF5Q29sdW1uQnVpbGRlciA9IGNsYXNzIF9CeXRlQXJyYXlDb2x1bW5CdWlsZGVyIGV4dGVuZHMgQ29sdW1uQnVpbGRlciB7XG4gIGNvbnN0cnVjdG9yKG1ldGFkYXRhKSB7XG4gICAgc3VwZXIobmV3IFR5cGVCdWlsZGVyKEFsZ2VicmFpY1R5cGUuQXJyYXkoQWxnZWJyYWljVHlwZS5VOCkpLCBtZXRhZGF0YSk7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgX0J5dGVBcnJheUNvbHVtbkJ1aWxkZXIoXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBkZWZhdWx0VmFsdWU6IHZhbHVlIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IF9CeXRlQXJyYXlDb2x1bW5CdWlsZGVyKHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IG5hbWUgfSkpO1xuICB9XG59O1xudmFyIE9wdGlvbkNvbHVtbkJ1aWxkZXIgPSBjbGFzcyBfT3B0aW9uQ29sdW1uQnVpbGRlciBleHRlbmRzIENvbHVtbkJ1aWxkZXIge1xuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBfT3B0aW9uQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwge1xuICAgICAgICBkZWZhdWx0VmFsdWU6IHZhbHVlXG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBfT3B0aW9uQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBuYW1lIH0pXG4gICAgKTtcbiAgfVxufTtcbnZhciBSZXN1bHRDb2x1bW5CdWlsZGVyID0gY2xhc3MgX1Jlc3VsdENvbHVtbkJ1aWxkZXIgZXh0ZW5kcyBDb2x1bW5CdWlsZGVyIHtcbiAgY29uc3RydWN0b3IodHlwZUJ1aWxkZXIsIG1ldGFkYXRhKSB7XG4gICAgc3VwZXIodHlwZUJ1aWxkZXIsIG1ldGFkYXRhKTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBfUmVzdWx0Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwge1xuICAgICAgICBkZWZhdWx0VmFsdWU6IHZhbHVlXG4gICAgICB9KVxuICAgICk7XG4gIH1cbn07XG52YXIgUHJvZHVjdENvbHVtbkJ1aWxkZXIgPSBjbGFzcyBfUHJvZHVjdENvbHVtbkJ1aWxkZXIgZXh0ZW5kcyBDb2x1bW5CdWlsZGVyIHtcbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgX1Byb2R1Y3RDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGRlZmF1bHRWYWx1ZTogdmFsdWUgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgX1Byb2R1Y3RDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IG5hbWUgfSlcbiAgICApO1xuICB9XG59O1xudmFyIFN1bUNvbHVtbkJ1aWxkZXIgPSBjbGFzcyBfU3VtQ29sdW1uQnVpbGRlciBleHRlbmRzIENvbHVtbkJ1aWxkZXIge1xuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBfU3VtQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBkZWZhdWx0VmFsdWU6IHZhbHVlIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IF9TdW1Db2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IG5hbWUgfSlcbiAgICApO1xuICB9XG59O1xudmFyIFNpbXBsZVN1bUNvbHVtbkJ1aWxkZXIgPSBjbGFzcyBfU2ltcGxlU3VtQ29sdW1uQnVpbGRlciBleHRlbmRzIFN1bUNvbHVtbkJ1aWxkZXIge1xuICBpbmRleChhbGdvcml0aG0gPSBcImJ0cmVlXCIpIHtcbiAgICByZXR1cm4gbmV3IF9TaW1wbGVTdW1Db2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGluZGV4VHlwZTogYWxnb3JpdGhtIH0pXG4gICAgKTtcbiAgfVxuICBwcmltYXJ5S2V5KCkge1xuICAgIHJldHVybiBuZXcgX1NpbXBsZVN1bUNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNQcmltYXJ5S2V5OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxufTtcbnZhciBTY2hlZHVsZUF0Q29sdW1uQnVpbGRlciA9IGNsYXNzIF9TY2hlZHVsZUF0Q29sdW1uQnVpbGRlciBleHRlbmRzIENvbHVtbkJ1aWxkZXIge1xuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBfU2NoZWR1bGVBdENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgZGVmYXVsdFZhbHVlOiB2YWx1ZSB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBfU2NoZWR1bGVBdENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgbmFtZSB9KVxuICAgICk7XG4gIH1cbn07XG52YXIgSWRlbnRpdHlDb2x1bW5CdWlsZGVyID0gY2xhc3MgX0lkZW50aXR5Q29sdW1uQnVpbGRlciBleHRlbmRzIENvbHVtbkJ1aWxkZXIge1xuICBpbmRleChhbGdvcml0aG0gPSBcImJ0cmVlXCIpIHtcbiAgICByZXR1cm4gbmV3IF9JZGVudGl0eUNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaW5kZXhUeXBlOiBhbGdvcml0aG0gfSlcbiAgICApO1xuICB9XG4gIHVuaXF1ZSgpIHtcbiAgICByZXR1cm4gbmV3IF9JZGVudGl0eUNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNVbmlxdWU6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIHByaW1hcnlLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBfSWRlbnRpdHlDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzUHJpbWFyeUtleTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgX0lkZW50aXR5Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBkZWZhdWx0VmFsdWU6IHZhbHVlIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IF9JZGVudGl0eUNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgbmFtZSB9KVxuICAgICk7XG4gIH1cbn07XG52YXIgQ29ubmVjdGlvbklkQ29sdW1uQnVpbGRlciA9IGNsYXNzIF9Db25uZWN0aW9uSWRDb2x1bW5CdWlsZGVyIGV4dGVuZHMgQ29sdW1uQnVpbGRlciB7XG4gIGluZGV4KGFsZ29yaXRobSA9IFwiYnRyZWVcIikge1xuICAgIHJldHVybiBuZXcgX0Nvbm5lY3Rpb25JZENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaW5kZXhUeXBlOiBhbGdvcml0aG0gfSlcbiAgICApO1xuICB9XG4gIHVuaXF1ZSgpIHtcbiAgICByZXR1cm4gbmV3IF9Db25uZWN0aW9uSWRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzVW5pcXVlOiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBwcmltYXJ5S2V5KCkge1xuICAgIHJldHVybiBuZXcgX0Nvbm5lY3Rpb25JZENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNQcmltYXJ5S2V5OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBfQ29ubmVjdGlvbklkQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBkZWZhdWx0VmFsdWU6IHZhbHVlIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IF9Db25uZWN0aW9uSWRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IG5hbWUgfSlcbiAgICApO1xuICB9XG59O1xudmFyIFRpbWVzdGFtcENvbHVtbkJ1aWxkZXIgPSBjbGFzcyBfVGltZXN0YW1wQ29sdW1uQnVpbGRlciBleHRlbmRzIENvbHVtbkJ1aWxkZXIge1xuICBpbmRleChhbGdvcml0aG0gPSBcImJ0cmVlXCIpIHtcbiAgICByZXR1cm4gbmV3IF9UaW1lc3RhbXBDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGluZGV4VHlwZTogYWxnb3JpdGhtIH0pXG4gICAgKTtcbiAgfVxuICB1bmlxdWUoKSB7XG4gICAgcmV0dXJuIG5ldyBfVGltZXN0YW1wQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc1VuaXF1ZTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgcHJpbWFyeUtleSgpIHtcbiAgICByZXR1cm4gbmV3IF9UaW1lc3RhbXBDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzUHJpbWFyeUtleTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgX1RpbWVzdGFtcENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgZGVmYXVsdFZhbHVlOiB2YWx1ZSB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBfVGltZXN0YW1wQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBuYW1lIH0pXG4gICAgKTtcbiAgfVxufTtcbnZhciBUaW1lRHVyYXRpb25Db2x1bW5CdWlsZGVyID0gY2xhc3MgX1RpbWVEdXJhdGlvbkNvbHVtbkJ1aWxkZXIgZXh0ZW5kcyBDb2x1bW5CdWlsZGVyIHtcbiAgaW5kZXgoYWxnb3JpdGhtID0gXCJidHJlZVwiKSB7XG4gICAgcmV0dXJuIG5ldyBfVGltZUR1cmF0aW9uQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpbmRleFR5cGU6IGFsZ29yaXRobSB9KVxuICAgICk7XG4gIH1cbiAgdW5pcXVlKCkge1xuICAgIHJldHVybiBuZXcgX1RpbWVEdXJhdGlvbkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNVbmlxdWU6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIHByaW1hcnlLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBfVGltZUR1cmF0aW9uQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc1ByaW1hcnlLZXk6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IF9UaW1lRHVyYXRpb25Db2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGRlZmF1bHRWYWx1ZTogdmFsdWUgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgX1RpbWVEdXJhdGlvbkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgbmFtZSB9KVxuICAgICk7XG4gIH1cbn07XG52YXIgVXVpZENvbHVtbkJ1aWxkZXIgPSBjbGFzcyBfVXVpZENvbHVtbkJ1aWxkZXIgZXh0ZW5kcyBDb2x1bW5CdWlsZGVyIHtcbiAgaW5kZXgoYWxnb3JpdGhtID0gXCJidHJlZVwiKSB7XG4gICAgcmV0dXJuIG5ldyBfVXVpZENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaW5kZXhUeXBlOiBhbGdvcml0aG0gfSlcbiAgICApO1xuICB9XG4gIHVuaXF1ZSgpIHtcbiAgICByZXR1cm4gbmV3IF9VdWlkQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc1VuaXF1ZTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgcHJpbWFyeUtleSgpIHtcbiAgICByZXR1cm4gbmV3IF9VdWlkQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc1ByaW1hcnlLZXk6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IF9VdWlkQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBkZWZhdWx0VmFsdWU6IHZhbHVlIH0pXG4gICAgKTtcbiAgfVxufTtcbnZhciBSZWZCdWlsZGVyID0gY2xhc3MgZXh0ZW5kcyBUeXBlQnVpbGRlciB7XG4gIHJlZjtcbiAgLyoqIFRoZSBwaGFudG9tIHR5cGUgb2YgdGhlIHBvaW50ZWUgb2YgdGhpcyByZWYuICovXG4gIF9fc3BhY2V0aW1lVHlwZTtcbiAgY29uc3RydWN0b3IocmVmKSB7XG4gICAgc3VwZXIoQWxnZWJyYWljVHlwZS5SZWYocmVmKSk7XG4gICAgdGhpcy5yZWYgPSByZWY7XG4gIH1cbn07XG52YXIgZW51bUltcGwgPSAoKG5hbWVPck9iaiwgbWF5YmVPYmopID0+IHtcbiAgbGV0IG9iaiA9IG5hbWVPck9iajtcbiAgbGV0IG5hbWUgPSB2b2lkIDA7XG4gIGlmICh0eXBlb2YgbmFtZU9yT2JqID09PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKCFtYXliZU9iaikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgXCJXaGVuIHByb3ZpZGluZyBhIG5hbWUsIHlvdSBtdXN0IGFsc28gcHJvdmlkZSB0aGUgdmFyaWFudHMgb2JqZWN0IG9yIGFycmF5LlwiXG4gICAgICApO1xuICAgIH1cbiAgICBvYmogPSBtYXliZU9iajtcbiAgICBuYW1lID0gbmFtZU9yT2JqO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICBjb25zdCBzaW1wbGVWYXJpYW50c09iaiA9IHt9O1xuICAgIGZvciAoY29uc3QgdmFyaWFudCBvZiBvYmopIHtcbiAgICAgIHNpbXBsZVZhcmlhbnRzT2JqW3ZhcmlhbnRdID0gbmV3IFVuaXRCdWlsZGVyKCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgU2ltcGxlU3VtQnVpbGRlckltcGwoc2ltcGxlVmFyaWFudHNPYmosIG5hbWUpO1xuICB9XG4gIHJldHVybiBuZXcgU3VtQnVpbGRlcihvYmosIG5hbWUpO1xufSk7XG52YXIgdCA9IHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYEJvb2xgIHtAbGluayBBbGdlYnJhaWNUeXBlfSB0byBiZSB1c2VkIGluIHRhYmxlIGRlZmluaXRpb25zXG4gICAqIFJlcHJlc2VudGVkIGFzIGBib29sZWFuYCBpbiBUeXBlU2NyaXB0LlxuICAgKiBAcmV0dXJucyBBIG5ldyB7QGxpbmsgQm9vbEJ1aWxkZXJ9IGluc3RhbmNlXG4gICAqL1xuICBib29sOiAoKSA9PiBuZXcgQm9vbEJ1aWxkZXIoKSxcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYFN0cmluZ2Age0BsaW5rIEFsZ2VicmFpY1R5cGV9IHRvIGJlIHVzZWQgaW4gdGFibGUgZGVmaW5pdGlvbnNcbiAgICogUmVwcmVzZW50ZWQgYXMgYHN0cmluZ2AgaW4gVHlwZVNjcmlwdC5cbiAgICogQHJldHVybnMgQSBuZXcge0BsaW5rIFN0cmluZ0J1aWxkZXJ9IGluc3RhbmNlXG4gICAqL1xuICBzdHJpbmc6ICgpID0+IG5ldyBTdHJpbmdCdWlsZGVyKCksXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGBGNjRgIHtAbGluayBBbGdlYnJhaWNUeXBlfSB0byBiZSB1c2VkIGluIHRhYmxlIGRlZmluaXRpb25zXG4gICAqIFJlcHJlc2VudGVkIGFzIGBudW1iZXJgIGluIFR5cGVTY3JpcHQuXG4gICAqIEByZXR1cm5zIEEgbmV3IHtAbGluayBGNjRCdWlsZGVyfSBpbnN0YW5jZVxuICAgKi9cbiAgbnVtYmVyOiAoKSA9PiBuZXcgRjY0QnVpbGRlcigpLFxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBgSThgIHtAbGluayBBbGdlYnJhaWNUeXBlfSB0byBiZSB1c2VkIGluIHRhYmxlIGRlZmluaXRpb25zXG4gICAqIFJlcHJlc2VudGVkIGFzIGBudW1iZXJgIGluIFR5cGVTY3JpcHQuXG4gICAqIEByZXR1cm5zIEEgbmV3IHtAbGluayBJOEJ1aWxkZXJ9IGluc3RhbmNlXG4gICAqL1xuICBpODogKCkgPT4gbmV3IEk4QnVpbGRlcigpLFxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBgVThgIHtAbGluayBBbGdlYnJhaWNUeXBlfSB0byBiZSB1c2VkIGluIHRhYmxlIGRlZmluaXRpb25zXG4gICAqIFJlcHJlc2VudGVkIGFzIGBudW1iZXJgIGluIFR5cGVTY3JpcHQuXG4gICAqIEByZXR1cm5zIEEgbmV3IHtAbGluayBVOEJ1aWxkZXJ9IGluc3RhbmNlXG4gICAqL1xuICB1ODogKCkgPT4gbmV3IFU4QnVpbGRlcigpLFxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBgSTE2YCB7QGxpbmsgQWxnZWJyYWljVHlwZX0gdG8gYmUgdXNlZCBpbiB0YWJsZSBkZWZpbml0aW9uc1xuICAgKiBSZXByZXNlbnRlZCBhcyBgbnVtYmVyYCBpbiBUeXBlU2NyaXB0LlxuICAgKiBAcmV0dXJucyBBIG5ldyB7QGxpbmsgSTE2QnVpbGRlcn0gaW5zdGFuY2VcbiAgICovXG4gIGkxNjogKCkgPT4gbmV3IEkxNkJ1aWxkZXIoKSxcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYFUxNmAge0BsaW5rIEFsZ2VicmFpY1R5cGV9IHRvIGJlIHVzZWQgaW4gdGFibGUgZGVmaW5pdGlvbnNcbiAgICogUmVwcmVzZW50ZWQgYXMgYG51bWJlcmAgaW4gVHlwZVNjcmlwdC5cbiAgICogQHJldHVybnMgQSBuZXcge0BsaW5rIFUxNkJ1aWxkZXJ9IGluc3RhbmNlXG4gICAqL1xuICB1MTY6ICgpID0+IG5ldyBVMTZCdWlsZGVyKCksXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGBJMzJgIHtAbGluayBBbGdlYnJhaWNUeXBlfSB0byBiZSB1c2VkIGluIHRhYmxlIGRlZmluaXRpb25zXG4gICAqIFJlcHJlc2VudGVkIGFzIGBudW1iZXJgIGluIFR5cGVTY3JpcHQuXG4gICAqIEByZXR1cm5zIEEgbmV3IHtAbGluayBJMzJCdWlsZGVyfSBpbnN0YW5jZVxuICAgKi9cbiAgaTMyOiAoKSA9PiBuZXcgSTMyQnVpbGRlcigpLFxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBgVTMyYCB7QGxpbmsgQWxnZWJyYWljVHlwZX0gdG8gYmUgdXNlZCBpbiB0YWJsZSBkZWZpbml0aW9uc1xuICAgKiBSZXByZXNlbnRlZCBhcyBgbnVtYmVyYCBpbiBUeXBlU2NyaXB0LlxuICAgKiBAcmV0dXJucyBBIG5ldyB7QGxpbmsgVTMyQnVpbGRlcn0gaW5zdGFuY2VcbiAgICovXG4gIHUzMjogKCkgPT4gbmV3IFUzMkJ1aWxkZXIoKSxcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYEk2NGAge0BsaW5rIEFsZ2VicmFpY1R5cGV9IHRvIGJlIHVzZWQgaW4gdGFibGUgZGVmaW5pdGlvbnNcbiAgICogUmVwcmVzZW50ZWQgYXMgYGJpZ2ludGAgaW4gVHlwZVNjcmlwdC5cbiAgICogQHJldHVybnMgQSBuZXcge0BsaW5rIEk2NEJ1aWxkZXJ9IGluc3RhbmNlXG4gICAqL1xuICBpNjQ6ICgpID0+IG5ldyBJNjRCdWlsZGVyKCksXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGBVNjRgIHtAbGluayBBbGdlYnJhaWNUeXBlfSB0byBiZSB1c2VkIGluIHRhYmxlIGRlZmluaXRpb25zXG4gICAqIFJlcHJlc2VudGVkIGFzIGBiaWdpbnRgIGluIFR5cGVTY3JpcHQuXG4gICAqIEByZXR1cm5zIEEgbmV3IHtAbGluayBVNjRCdWlsZGVyfSBpbnN0YW5jZVxuICAgKi9cbiAgdTY0OiAoKSA9PiBuZXcgVTY0QnVpbGRlcigpLFxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBgSTEyOGAge0BsaW5rIEFsZ2VicmFpY1R5cGV9IHRvIGJlIHVzZWQgaW4gdGFibGUgZGVmaW5pdGlvbnNcbiAgICogUmVwcmVzZW50ZWQgYXMgYGJpZ2ludGAgaW4gVHlwZVNjcmlwdC5cbiAgICogQHJldHVybnMgQSBuZXcge0BsaW5rIEkxMjhCdWlsZGVyfSBpbnN0YW5jZVxuICAgKi9cbiAgaTEyODogKCkgPT4gbmV3IEkxMjhCdWlsZGVyKCksXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGBVMTI4YCB7QGxpbmsgQWxnZWJyYWljVHlwZX0gdG8gYmUgdXNlZCBpbiB0YWJsZSBkZWZpbml0aW9uc1xuICAgKiBSZXByZXNlbnRlZCBhcyBgYmlnaW50YCBpbiBUeXBlU2NyaXB0LlxuICAgKiBAcmV0dXJucyBBIG5ldyB7QGxpbmsgVTEyOEJ1aWxkZXJ9IGluc3RhbmNlXG4gICAqL1xuICB1MTI4OiAoKSA9PiBuZXcgVTEyOEJ1aWxkZXIoKSxcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYEkyNTZgIHtAbGluayBBbGdlYnJhaWNUeXBlfSB0byBiZSB1c2VkIGluIHRhYmxlIGRlZmluaXRpb25zXG4gICAqIFJlcHJlc2VudGVkIGFzIGBiaWdpbnRgIGluIFR5cGVTY3JpcHQuXG4gICAqIEByZXR1cm5zIEEgbmV3IHtAbGluayBJMjU2QnVpbGRlcn0gaW5zdGFuY2VcbiAgICovXG4gIGkyNTY6ICgpID0+IG5ldyBJMjU2QnVpbGRlcigpLFxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBgVTI1NmAge0BsaW5rIEFsZ2VicmFpY1R5cGV9IHRvIGJlIHVzZWQgaW4gdGFibGUgZGVmaW5pdGlvbnNcbiAgICogUmVwcmVzZW50ZWQgYXMgYGJpZ2ludGAgaW4gVHlwZVNjcmlwdC5cbiAgICogQHJldHVybnMgQSBuZXcge0BsaW5rIFUyNTZCdWlsZGVyfSBpbnN0YW5jZVxuICAgKi9cbiAgdTI1NjogKCkgPT4gbmV3IFUyNTZCdWlsZGVyKCksXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGBGMzJgIHtAbGluayBBbGdlYnJhaWNUeXBlfSB0byBiZSB1c2VkIGluIHRhYmxlIGRlZmluaXRpb25zXG4gICAqIFJlcHJlc2VudGVkIGFzIGBudW1iZXJgIGluIFR5cGVTY3JpcHQuXG4gICAqIEByZXR1cm5zIEEgbmV3IHtAbGluayBGMzJCdWlsZGVyfSBpbnN0YW5jZVxuICAgKi9cbiAgZjMyOiAoKSA9PiBuZXcgRjMyQnVpbGRlcigpLFxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBgRjY0YCB7QGxpbmsgQWxnZWJyYWljVHlwZX0gdG8gYmUgdXNlZCBpbiB0YWJsZSBkZWZpbml0aW9uc1xuICAgKiBSZXByZXNlbnRlZCBhcyBgbnVtYmVyYCBpbiBUeXBlU2NyaXB0LlxuICAgKiBAcmV0dXJucyBBIG5ldyB7QGxpbmsgRjY0QnVpbGRlcn0gaW5zdGFuY2VcbiAgICovXG4gIGY2NDogKCkgPT4gbmV3IEY2NEJ1aWxkZXIoKSxcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYFByb2R1Y3RgIHtAbGluayBBbGdlYnJhaWNUeXBlfSB0byBiZSB1c2VkIGluIHRhYmxlIGRlZmluaXRpb25zLiBQcm9kdWN0IHR5cGVzIGluIFNwYWNldGltZURCXG4gICAqIGFyZSBlc3NlbnRpYWxseSB0aGUgc2FtZSBhcyBvYmplY3RzIGluIEphdmFTY3JpcHQvVHlwZVNjcmlwdC5cbiAgICogUHJvcGVydGllcyBvZiB0aGUgb2JqZWN0IG11c3QgYWxzbyBiZSB7QGxpbmsgVHlwZUJ1aWxkZXJ9cy5cbiAgICogUmVwcmVzZW50ZWQgYXMgYW4gb2JqZWN0IHdpdGggc3BlY2lmaWMgcHJvcGVydGllcyBpbiBUeXBlU2NyaXB0LlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSAob3B0aW9uYWwpIEEgZGlzcGxheSBuYW1lIGZvciB0aGUgcHJvZHVjdCB0eXBlLiBJZiBvbWl0dGVkLCBhbiBhbm9ueW1vdXMgcHJvZHVjdCB0eXBlIGlzIGNyZWF0ZWQuXG4gICAqIEBwYXJhbSBvYmogVGhlIG9iamVjdCBkZWZpbmluZyB0aGUgcHJvcGVydGllcyBvZiB0aGUgdHlwZSwgd2hvc2UgcHJvcGVydHlcbiAgICogdmFsdWVzIG11c3QgYmUge0BsaW5rIFR5cGVCdWlsZGVyfXMuXG4gICAqIEByZXR1cm5zIEEgbmV3IHtAbGluayBQcm9kdWN0QnVpbGRlcn0gaW5zdGFuY2UuXG4gICAqL1xuICBvYmplY3Q6ICgobmFtZU9yT2JqLCBtYXliZU9iaikgPT4ge1xuICAgIGlmICh0eXBlb2YgbmFtZU9yT2JqID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBpZiAoIW1heWJlT2JqKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgXCJXaGVuIHByb3ZpZGluZyBhIG5hbWUsIHlvdSBtdXN0IGFsc28gcHJvdmlkZSB0aGUgb2JqZWN0LlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFByb2R1Y3RCdWlsZGVyKG1heWJlT2JqLCBuYW1lT3JPYmopO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb2R1Y3RCdWlsZGVyKG5hbWVPck9iaiwgdm9pZCAwKTtcbiAgfSksXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGBSb3dgIHtAbGluayBBbGdlYnJhaWNUeXBlfSB0byBiZSB1c2VkIGluIHRhYmxlIGRlZmluaXRpb25zLiBSb3cgdHlwZXMgaW4gU3BhY2V0aW1lREJcbiAgICogYXJlIHNpbWlsYXIgdG8gYFByb2R1Y3RgIHR5cGVzLCBidXQgYXJlIHNwZWNpZmljYWxseSB1c2VkIHRvIGRlZmluZSB0aGUgc2NoZW1hIG9mIGEgdGFibGUgcm93LlxuICAgKiBQcm9wZXJ0aWVzIG9mIHRoZSBvYmplY3QgbXVzdCBhbHNvIGJlIHtAbGluayBUeXBlQnVpbGRlcn0gb3Ige0BsaW5rIENvbHVtbkJ1aWxkZXJ9cy5cbiAgICpcbiAgICogWW91IGNhbiByZXByZXNlbnQgYSBgUm93YCBhcyBlaXRoZXIgYSB7QGxpbmsgUm93T2JqfSBvciBhbiB7QGxpbmsgUm93QnVpbGRlcn0gdHlwZSB3aGVuXG4gICAqIGRlZmluaW5nIGEgdGFibGUgc2NoZW1hLlxuICAgKlxuICAgKiBUaGUge0BsaW5rIFJvd0J1aWxkZXJ9IHR5cGUgaXMgdXNlZnVsIHdoZW4geW91IHdhbnQgdG8gY3JlYXRlIGEgdHlwZSB3aGljaCBjYW4gYmUgdXNlZCBhbnl3aGVyZVxuICAgKiBhIHtAbGluayBUeXBlQnVpbGRlcn0gaXMgYWNjZXB0ZWQsIHN1Y2ggYXMgaW4gbmVzdGVkIG9iamVjdHMgb3IgYXJyYXlzLCBvciBhcyB0aGUgYXJndW1lbnRcbiAgICogdG8gYSBzY2hlZHVsZWQgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSBvYmogVGhlIG9iamVjdCBkZWZpbmluZyB0aGUgcHJvcGVydGllcyBvZiB0aGUgcm93LCB3aG9zZSBwcm9wZXJ0eVxuICAgKiB2YWx1ZXMgbXVzdCBiZSB7QGxpbmsgVHlwZUJ1aWxkZXJ9cyBvciB7QGxpbmsgQ29sdW1uQnVpbGRlcn1zLlxuICAgKiBAcmV0dXJucyBBIG5ldyB7QGxpbmsgUm93QnVpbGRlcn0gaW5zdGFuY2VcbiAgICovXG4gIHJvdzogKChuYW1lT3JPYmosIG1heWJlT2JqKSA9PiB7XG4gICAgY29uc3QgW29iaiwgbmFtZV0gPSB0eXBlb2YgbmFtZU9yT2JqID09PSBcInN0cmluZ1wiID8gW21heWJlT2JqLCBuYW1lT3JPYmpdIDogW25hbWVPck9iaiwgdm9pZCAwXTtcbiAgICByZXR1cm4gbmV3IFJvd0J1aWxkZXIob2JqLCBuYW1lKTtcbiAgfSksXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGBBcnJheWAge0BsaW5rIEFsZ2VicmFpY1R5cGV9IHRvIGJlIHVzZWQgaW4gdGFibGUgZGVmaW5pdGlvbnMuXG4gICAqIFJlcHJlc2VudGVkIGFzIGFuIGFycmF5IGluIFR5cGVTY3JpcHQuXG4gICAqIEBwYXJhbSBlbGVtZW50IFRoZSBlbGVtZW50IHR5cGUgb2YgdGhlIGFycmF5LCB3aGljaCBtdXN0IGJlIGEgYFR5cGVCdWlsZGVyYC5cbiAgICogQHJldHVybnMgQSBuZXcge0BsaW5rIEFycmF5QnVpbGRlcn0gaW5zdGFuY2VcbiAgICovXG4gIGFycmF5KGUpIHtcbiAgICByZXR1cm4gbmV3IEFycmF5QnVpbGRlcihlKTtcbiAgfSxcbiAgZW51bTogZW51bUltcGwsXG4gIC8qKlxuICAgKiBUaGlzIGlzIGEgc3BlY2lhbCBoZWxwZXIgZnVuY3Rpb24gZm9yIGNvbnZlbmllbnRseSBjcmVhdGluZyB7QGxpbmsgUHJvZHVjdH0gdHlwZSBjb2x1bW5zIHdpdGggbm8gZmllbGRzLlxuICAgKlxuICAgKiBAcmV0dXJucyBBIG5ldyB7QGxpbmsgUHJvZHVjdEJ1aWxkZXJ9IGluc3RhbmNlIHdpdGggbm8gZmllbGRzLlxuICAgKi9cbiAgdW5pdCgpIHtcbiAgICByZXR1cm4gbmV3IFVuaXRCdWlsZGVyKCk7XG4gIH0sXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbGF6aWx5LWV2YWx1YXRlZCB7QGxpbmsgVHlwZUJ1aWxkZXJ9LiBUaGlzIGlzIHVzZWZ1bCBmb3IgY3JlYXRpbmdcbiAgICogcmVjdXJzaXZlIHR5cGVzLCBzdWNoIGFzIGEgdHJlZSBvciBsaW5rZWQgbGlzdC5cbiAgICogQHBhcmFtIHRodW5rIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEge0BsaW5rIFR5cGVCdWlsZGVyfS5cbiAgICogQHJldHVybnMgQSBwcm94eSB7QGxpbmsgVHlwZUJ1aWxkZXJ9IHRoYXQgZXZhbHVhdGVzIHRoZSB0aHVuayBvbiBmaXJzdCBhY2Nlc3MuXG4gICAqL1xuICBsYXp5KHRodW5rKSB7XG4gICAgbGV0IGNhY2hlZCA9IG51bGw7XG4gICAgY29uc3QgZ2V0ID0gKCkgPT4gY2FjaGVkID8/PSB0aHVuaygpO1xuICAgIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KHt9LCB7XG4gICAgICBnZXQoX3QsIHByb3AsIHJlY3YpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZ2V0KCk7XG4gICAgICAgIGNvbnN0IHZhbCA9IFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjdik7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsID09PSBcImZ1bmN0aW9uXCIgPyB2YWwuYmluZCh0YXJnZXQpIDogdmFsO1xuICAgICAgfSxcbiAgICAgIHNldChfdCwgcHJvcCwgdmFsdWUsIHJlY3YpIHtcbiAgICAgICAgcmV0dXJuIFJlZmxlY3Quc2V0KGdldCgpLCBwcm9wLCB2YWx1ZSwgcmVjdik7XG4gICAgICB9LFxuICAgICAgaGFzKF90LCBwcm9wKSB7XG4gICAgICAgIHJldHVybiBwcm9wIGluIGdldCgpO1xuICAgICAgfSxcbiAgICAgIG93bktleXMoKSB7XG4gICAgICAgIHJldHVybiBSZWZsZWN0Lm93bktleXMoZ2V0KCkpO1xuICAgICAgfSxcbiAgICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihfdCwgcHJvcCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihnZXQoKSwgcHJvcCk7XG4gICAgICB9LFxuICAgICAgZ2V0UHJvdG90eXBlT2YoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZ2V0KCkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBwcm94eTtcbiAgfSxcbiAgLyoqXG4gICAqIFRoaXMgaXMgYSBzcGVjaWFsIGhlbHBlciBmdW5jdGlvbiBmb3IgY29udmVuaWVudGx5IGNyZWF0aW5nIHtAbGluayBTY2hlZHVsZUF0fSB0eXBlIGNvbHVtbnMuXG4gICAqIEByZXR1cm5zIEEgbmV3IENvbHVtbkJ1aWxkZXIgaW5zdGFuY2Ugd2l0aCB0aGUge0BsaW5rIFNjaGVkdWxlQXR9IHR5cGUuXG4gICAqL1xuICBzY2hlZHVsZUF0OiAoKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBTY2hlZHVsZUF0QnVpbGRlcigpO1xuICB9LFxuICAvKipcbiAgICogVGhpcyBpcyBhIGNvbnZlbmllbmNlIG1ldGhvZCBmb3IgY3JlYXRpbmcgYSBjb2x1bW4gd2l0aCB0aGUge0BsaW5rIE9wdGlvbn0gdHlwZS5cbiAgICogWW91IGNhbiBjcmVhdGUgYSBjb2x1bW4gb2YgdGhlIHNhbWUgdHlwZSBieSBjb25zdHJ1Y3RpbmcgYW4gZW51bSB3aXRoIGEgYHNvbWVgIGFuZCBgbm9uZWAgdmFyaWFudC5cbiAgICogQHBhcmFtIHZhbHVlIFRoZSB0eXBlIG9mIHRoZSB2YWx1ZSBjb250YWluZWQgaW4gdGhlIGBzb21lYCB2YXJpYW50IG9mIHRoZSBgT3B0aW9uYC5cbiAgICogQHJldHVybnMgQSBuZXcge0BsaW5rIE9wdGlvbkJ1aWxkZXJ9IGluc3RhbmNlIHdpdGggdGhlIHtAbGluayBPcHRpb259IHR5cGUuXG4gICAqL1xuICBvcHRpb24odmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IE9wdGlvbkJ1aWxkZXIodmFsdWUpO1xuICB9LFxuICAvKipcbiAgICogVGhpcyBpcyBhIGNvbnZlbmllbmNlIG1ldGhvZCBmb3IgY3JlYXRpbmcgYSBjb2x1bW4gd2l0aCB0aGUge0BsaW5rIFJlc3VsdH0gdHlwZS5cbiAgICogWW91IGNhbiBjcmVhdGUgYSBjb2x1bW4gb2YgdGhlIHNhbWUgdHlwZSBieSBjb25zdHJ1Y3RpbmcgYW4gZW51bSB3aXRoIGFuIGBva2AgYW5kIGBlcnJgIHZhcmlhbnQuXG4gICAqIEBwYXJhbSBvayBUaGUgdHlwZSBvZiB0aGUgdmFsdWUgY29udGFpbmVkIGluIHRoZSBgb2tgIHZhcmlhbnQgb2YgdGhlIGBSZXN1bHRgLlxuICAgKiBAcGFyYW0gZXJyIFRoZSB0eXBlIG9mIHRoZSB2YWx1ZSBjb250YWluZWQgaW4gdGhlIGBlcnJgIHZhcmlhbnQgb2YgdGhlIGBSZXN1bHRgLlxuICAgKiBAcmV0dXJucyBBIG5ldyB7QGxpbmsgUmVzdWx0QnVpbGRlcn0gaW5zdGFuY2Ugd2l0aCB0aGUge0BsaW5rIFJlc3VsdH0gdHlwZS5cbiAgICovXG4gIHJlc3VsdChvaywgZXJyKSB7XG4gICAgcmV0dXJuIG5ldyBSZXN1bHRCdWlsZGVyKG9rLCBlcnIpO1xuICB9LFxuICAvKipcbiAgICogVGhpcyBpcyBhIGNvbnZlbmllbmNlIG1ldGhvZCBmb3IgY3JlYXRpbmcgYSBjb2x1bW4gd2l0aCB0aGUge0BsaW5rIElkZW50aXR5fSB0eXBlLlxuICAgKiBZb3UgY2FuIGNyZWF0ZSBhIGNvbHVtbiBvZiB0aGUgc2FtZSB0eXBlIGJ5IGNvbnN0cnVjdGluZyBhbiBgb2JqZWN0YCB3aXRoIGEgc2luZ2xlIGBfX2lkZW50aXR5X19gIGVsZW1lbnQuXG4gICAqIEByZXR1cm5zIEEgbmV3IHtAbGluayBUeXBlQnVpbGRlcn0gaW5zdGFuY2Ugd2l0aCB0aGUge0BsaW5rIElkZW50aXR5fSB0eXBlLlxuICAgKi9cbiAgaWRlbnRpdHk6ICgpID0+IHtcbiAgICByZXR1cm4gbmV3IElkZW50aXR5QnVpbGRlcigpO1xuICB9LFxuICAvKipcbiAgICogVGhpcyBpcyBhIGNvbnZlbmllbmNlIG1ldGhvZCBmb3IgY3JlYXRpbmcgYSBjb2x1bW4gd2l0aCB0aGUge0BsaW5rIENvbm5lY3Rpb25JZH0gdHlwZS5cbiAgICogWW91IGNhbiBjcmVhdGUgYSBjb2x1bW4gb2YgdGhlIHNhbWUgdHlwZSBieSBjb25zdHJ1Y3RpbmcgYW4gYG9iamVjdGAgd2l0aCBhIHNpbmdsZSBgX19jb25uZWN0aW9uX2lkX19gIGVsZW1lbnQuXG4gICAqIEByZXR1cm5zIEEgbmV3IHtAbGluayBUeXBlQnVpbGRlcn0gaW5zdGFuY2Ugd2l0aCB0aGUge0BsaW5rIENvbm5lY3Rpb25JZH0gdHlwZS5cbiAgICovXG4gIGNvbm5lY3Rpb25JZDogKCkgPT4ge1xuICAgIHJldHVybiBuZXcgQ29ubmVjdGlvbklkQnVpbGRlcigpO1xuICB9LFxuICAvKipcbiAgICogVGhpcyBpcyBhIGNvbnZlbmllbmNlIG1ldGhvZCBmb3IgY3JlYXRpbmcgYSBjb2x1bW4gd2l0aCB0aGUge0BsaW5rIFRpbWVzdGFtcH0gdHlwZS5cbiAgICogWW91IGNhbiBjcmVhdGUgYSBjb2x1bW4gb2YgdGhlIHNhbWUgdHlwZSBieSBjb25zdHJ1Y3RpbmcgYW4gYG9iamVjdGAgd2l0aCBhIHNpbmdsZSBgX190aW1lc3RhbXBfbWljcm9zX3NpbmNlX3VuaXhfZXBvY2hfX2AgZWxlbWVudC5cbiAgICogQHJldHVybnMgQSBuZXcge0BsaW5rIFR5cGVCdWlsZGVyfSBpbnN0YW5jZSB3aXRoIHRoZSB7QGxpbmsgVGltZXN0YW1wfSB0eXBlLlxuICAgKi9cbiAgdGltZXN0YW1wOiAoKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBUaW1lc3RhbXBCdWlsZGVyKCk7XG4gIH0sXG4gIC8qKlxuICAgKiBUaGlzIGlzIGEgY29udmVuaWVuY2UgbWV0aG9kIGZvciBjcmVhdGluZyBhIGNvbHVtbiB3aXRoIHRoZSB7QGxpbmsgVGltZUR1cmF0aW9ufSB0eXBlLlxuICAgKiBZb3UgY2FuIGNyZWF0ZSBhIGNvbHVtbiBvZiB0aGUgc2FtZSB0eXBlIGJ5IGNvbnN0cnVjdGluZyBhbiBgb2JqZWN0YCB3aXRoIGEgc2luZ2xlIGBfX3RpbWVfZHVyYXRpb25fbWljcm9zX19gIGVsZW1lbnQuXG4gICAqIEByZXR1cm5zIEEgbmV3IHtAbGluayBUeXBlQnVpbGRlcn0gaW5zdGFuY2Ugd2l0aCB0aGUge0BsaW5rIFRpbWVEdXJhdGlvbn0gdHlwZS5cbiAgICovXG4gIHRpbWVEdXJhdGlvbjogKCkgPT4ge1xuICAgIHJldHVybiBuZXcgVGltZUR1cmF0aW9uQnVpbGRlcigpO1xuICB9LFxuICAvKipcbiAgICogVGhpcyBpcyBhIGNvbnZlbmllbmNlIG1ldGhvZCBmb3IgY3JlYXRpbmcgYSBjb2x1bW4gd2l0aCB0aGUge0BsaW5rIFV1aWR9IHR5cGUuXG4gICAqIFlvdSBjYW4gY3JlYXRlIGEgY29sdW1uIG9mIHRoZSBzYW1lIHR5cGUgYnkgY29uc3RydWN0aW5nIGFuIGBvYmplY3RgIHdpdGggYSBzaW5nbGUgYF9fdXVpZF9fYCBlbGVtZW50LlxuICAgKiBAcmV0dXJucyBBIG5ldyB7QGxpbmsgVHlwZUJ1aWxkZXJ9IGluc3RhbmNlIHdpdGggdGhlIHtAbGluayBVdWlkfSB0eXBlLlxuICAgKi9cbiAgdXVpZDogKCkgPT4ge1xuICAgIHJldHVybiBuZXcgVXVpZEJ1aWxkZXIoKTtcbiAgfSxcbiAgLyoqXG4gICAqIFRoaXMgaXMgYSBjb252ZW5pZW5jZSBtZXRob2QgZm9yIGNyZWF0aW5nIGEgY29sdW1uIHdpdGggdGhlIHtAbGluayBCeXRlQXJyYXl9IHR5cGUuXG4gICAqIFlvdSBjYW4gY3JlYXRlIGEgY29sdW1uIG9mIHRoZSBzYW1lIHR5cGUgYnkgY29uc3RydWN0aW5nIGFuIGBhcnJheWAgb2YgYHU4YC5cbiAgICogVGhlIFR5cGVTY3JpcHQgcmVwcmVzZW50YXRpb24gaXMge0BsaW5rIFVpbnQ4QXJyYXl9LlxuICAgKiBAcmV0dXJucyBBIG5ldyB7QGxpbmsgQnl0ZUFycmF5QnVpbGRlcn0gaW5zdGFuY2Ugd2l0aCB0aGUge0BsaW5rIEJ5dGVBcnJheX0gdHlwZS5cbiAgICovXG4gIGJ5dGVBcnJheTogKCkgPT4ge1xuICAgIHJldHVybiBuZXcgQnl0ZUFycmF5QnVpbGRlcigpO1xuICB9XG59O1xuXG4vLyBzcmMvbGliL2F1dG9nZW4vbGlmZWN5Y2xlX3R5cGUudHNcbnZhciBMaWZlY3ljbGUgPSB0LmVudW0oXCJMaWZlY3ljbGVcIiwge1xuICBJbml0OiB0LnVuaXQoKSxcbiAgT25Db25uZWN0OiB0LnVuaXQoKSxcbiAgT25EaXNjb25uZWN0OiB0LnVuaXQoKVxufSk7XG52YXIgbGlmZWN5Y2xlX3R5cGVfZGVmYXVsdCA9IExpZmVjeWNsZTtcblxuLy8gc3JjL2xpYi9yZWR1Y2Vycy50c1xuZnVuY3Rpb24gcHVzaFJlZHVjZXIobmFtZSwgcGFyYW1zLCBmbiwgbGlmZWN5Y2xlKSB7XG4gIGlmIChleGlzdGluZ1JlZHVjZXJzLmhhcyhuYW1lKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZXJlIGlzIGFscmVhZHkgYSByZWR1Y2VyIHdpdGggdGhlIG5hbWUgJyR7bmFtZX0nYCk7XG4gIH1cbiAgZXhpc3RpbmdSZWR1Y2Vycy5hZGQobmFtZSk7XG4gIGlmICghKHBhcmFtcyBpbnN0YW5jZW9mIFJvd0J1aWxkZXIpKSB7XG4gICAgcGFyYW1zID0gbmV3IFJvd0J1aWxkZXIocGFyYW1zKTtcbiAgfVxuICBpZiAocGFyYW1zLnR5cGVOYW1lID09PSB2b2lkIDApIHtcbiAgICBwYXJhbXMudHlwZU5hbWUgPSB0b1Bhc2NhbENhc2UobmFtZSk7XG4gIH1cbiAgY29uc3QgcmVmID0gcmVnaXN0ZXJUeXBlc1JlY3Vyc2l2ZWx5KHBhcmFtcyk7XG4gIGNvbnN0IHBhcmFtc1R5cGUgPSByZXNvbHZlVHlwZShNT0RVTEVfREVGLnR5cGVzcGFjZSwgcmVmKS52YWx1ZTtcbiAgTU9EVUxFX0RFRi5yZWR1Y2Vycy5wdXNoKHtcbiAgICBuYW1lLFxuICAgIHBhcmFtczogcGFyYW1zVHlwZSxcbiAgICBsaWZlY3ljbGVcbiAgICAvLyA8LSBsaWZlY3ljbGUgZmxhZyBsYW5kcyBoZXJlXG4gIH0pO1xuICBpZiAoIWZuLm5hbWUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sIFwibmFtZVwiLCB7IHZhbHVlOiBuYW1lLCB3cml0YWJsZTogZmFsc2UgfSk7XG4gIH1cbiAgUkVEVUNFUlMucHVzaChmbik7XG59XG52YXIgZXhpc3RpbmdSZWR1Y2VycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG52YXIgUkVEVUNFUlMgPSBbXTtcbmZ1bmN0aW9uIHJlZHVjZXIobmFtZSwgcGFyYW1zLCBmbikge1xuICBwdXNoUmVkdWNlcihuYW1lLCBwYXJhbXMsIGZuKTtcbn1cbmZ1bmN0aW9uIGluaXQobmFtZSwgcGFyYW1zLCBmbikge1xuICBwdXNoUmVkdWNlcihuYW1lLCBwYXJhbXMsIGZuLCBsaWZlY3ljbGVfdHlwZV9kZWZhdWx0LkluaXQpO1xufVxuZnVuY3Rpb24gY2xpZW50Q29ubmVjdGVkKG5hbWUsIHBhcmFtcywgZm4pIHtcbiAgcHVzaFJlZHVjZXIobmFtZSwgcGFyYW1zLCBmbiwgbGlmZWN5Y2xlX3R5cGVfZGVmYXVsdC5PbkNvbm5lY3QpO1xufVxuZnVuY3Rpb24gY2xpZW50RGlzY29ubmVjdGVkKG5hbWUsIHBhcmFtcywgZm4pIHtcbiAgcHVzaFJlZHVjZXIobmFtZSwgcGFyYW1zLCBmbiwgbGlmZWN5Y2xlX3R5cGVfZGVmYXVsdC5PbkRpc2Nvbm5lY3QpO1xufVxudmFyIFJlZHVjZXJzID0gY2xhc3Mge1xuICByZWR1Y2Vyc1R5cGU7XG4gIGNvbnN0cnVjdG9yKGhhbmRsZXMpIHtcbiAgICB0aGlzLnJlZHVjZXJzVHlwZSA9IHJlZHVjZXJzVG9TY2hlbWEoaGFuZGxlcyk7XG4gIH1cbn07XG5mdW5jdGlvbiByZWR1Y2Vyc1RvU2NoZW1hKHJlZHVjZXJzMikge1xuICBjb25zdCBtYXBwZWQgPSByZWR1Y2VyczIubWFwKChyKSA9PiB7XG4gICAgY29uc3QgcGFyYW1zUm93ID0gci5wYXJhbXMucm93O1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiByLnJlZHVjZXJOYW1lLFxuICAgICAgLy8gUHJlZmVyIHRoZSBzY2hlbWEncyBvd24gYWNjZXNzb3JOYW1lIGlmIHByZXNlbnQgYXQgcnVudGltZTsgb3RoZXJ3aXNlIGRlcml2ZSBpdC5cbiAgICAgIGFjY2Vzc29yTmFtZTogci5hY2Nlc3Nvck5hbWUsXG4gICAgICBwYXJhbXM6IHBhcmFtc1JvdyxcbiAgICAgIHBhcmFtc1R5cGU6IHIucGFyYW1zU3BhY2V0aW1lVHlwZVxuICAgIH07XG4gIH0pO1xuICBjb25zdCByZXN1bHQgPSB7IHJlZHVjZXJzOiBtYXBwZWQgfTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHJlZHVjZXJzKC4uLmFyZ3MpIHtcbiAgY29uc3QgaGFuZGxlcyA9IGFyZ3MubGVuZ3RoID09PSAxICYmIEFycmF5LmlzQXJyYXkoYXJnc1swXSkgPyBhcmdzWzBdIDogYXJncztcbiAgcmV0dXJuIG5ldyBSZWR1Y2VycyhoYW5kbGVzKTtcbn1cblxuLy8gc3JjL3NlcnZlci9xdWVyeS50c1xudmFyIFF1ZXJ5QnJhbmQgPSBTeW1ib2woXCJRdWVyeUJyYW5kXCIpO1xudmFyIGlzUm93VHlwZWRRdWVyeSA9ICh2YWwpID0+ICEhdmFsICYmIHR5cGVvZiB2YWwgPT09IFwib2JqZWN0XCIgJiYgUXVlcnlCcmFuZCBpbiB2YWw7XG5mdW5jdGlvbiB0b1NxbChxKSB7XG4gIHJldHVybiBxLnRvU3FsKCk7XG59XG52YXIgU2VtaWpvaW5JbXBsID0gY2xhc3MgX1NlbWlqb2luSW1wbCB7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZVF1ZXJ5LCBmaWx0ZXJRdWVyeSwgam9pbkNvbmRpdGlvbikge1xuICAgIHRoaXMuc291cmNlUXVlcnkgPSBzb3VyY2VRdWVyeTtcbiAgICB0aGlzLmZpbHRlclF1ZXJ5ID0gZmlsdGVyUXVlcnk7XG4gICAgdGhpcy5qb2luQ29uZGl0aW9uID0gam9pbkNvbmRpdGlvbjtcbiAgICBpZiAoc291cmNlUXVlcnkudGFibGUubmFtZSA9PT0gZmlsdGVyUXVlcnkudGFibGUubmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNlbWlqb2luIGEgdGFibGUgdG8gaXRzZWxmXCIpO1xuICAgIH1cbiAgfVxuICBbUXVlcnlCcmFuZF0gPSB0cnVlO1xuICB0eXBlID0gXCJzZW1pam9pblwiO1xuICBidWlsZCgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB3aGVyZShwcmVkaWNhdGUpIHtcbiAgICBjb25zdCBuZXh0U291cmNlUXVlcnkgPSB0aGlzLnNvdXJjZVF1ZXJ5LndoZXJlKHByZWRpY2F0ZSk7XG4gICAgcmV0dXJuIG5ldyBfU2VtaWpvaW5JbXBsKFxuICAgICAgbmV4dFNvdXJjZVF1ZXJ5LFxuICAgICAgdGhpcy5maWx0ZXJRdWVyeSxcbiAgICAgIHRoaXMuam9pbkNvbmRpdGlvblxuICAgICk7XG4gIH1cbiAgdG9TcWwoKSB7XG4gICAgY29uc3QgbGVmdCA9IHRoaXMuZmlsdGVyUXVlcnk7XG4gICAgY29uc3QgcmlnaHQgPSB0aGlzLnNvdXJjZVF1ZXJ5O1xuICAgIGNvbnN0IGxlZnRUYWJsZSA9IHF1b3RlSWRlbnRpZmllcihsZWZ0LnRhYmxlLm5hbWUpO1xuICAgIGNvbnN0IHJpZ2h0VGFibGUgPSBxdW90ZUlkZW50aWZpZXIocmlnaHQudGFibGUubmFtZSk7XG4gICAgbGV0IHNxbCA9IGBTRUxFQ1QgJHtyaWdodFRhYmxlfS4qIEZST00gJHtsZWZ0VGFibGV9IEpPSU4gJHtyaWdodFRhYmxlfSBPTiAke2Jvb2xlYW5FeHByVG9TcWwodGhpcy5qb2luQ29uZGl0aW9uKX1gO1xuICAgIGNvbnN0IGNsYXVzZXMgPSBbXTtcbiAgICBpZiAobGVmdC53aGVyZUNsYXVzZSkge1xuICAgICAgY2xhdXNlcy5wdXNoKGJvb2xlYW5FeHByVG9TcWwobGVmdC53aGVyZUNsYXVzZSkpO1xuICAgIH1cbiAgICBpZiAocmlnaHQud2hlcmVDbGF1c2UpIHtcbiAgICAgIGNsYXVzZXMucHVzaChib29sZWFuRXhwclRvU3FsKHJpZ2h0LndoZXJlQ2xhdXNlKSk7XG4gICAgfVxuICAgIGlmIChjbGF1c2VzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHdoZXJlU3FsID0gY2xhdXNlcy5sZW5ndGggPT09IDEgPyBjbGF1c2VzWzBdIDogY2xhdXNlcy5tYXAod3JhcEluUGFyZW5zKS5qb2luKFwiIEFORCBcIik7XG4gICAgICBzcWwgKz0gYCBXSEVSRSAke3doZXJlU3FsfWA7XG4gICAgfVxuICAgIHJldHVybiBzcWw7XG4gIH1cbn07XG52YXIgRnJvbUJ1aWxkZXIgPSBjbGFzcyBfRnJvbUJ1aWxkZXIge1xuICBjb25zdHJ1Y3Rvcih0YWJsZTIsIHdoZXJlQ2xhdXNlKSB7XG4gICAgdGhpcy50YWJsZSA9IHRhYmxlMjtcbiAgICB0aGlzLndoZXJlQ2xhdXNlID0gd2hlcmVDbGF1c2U7XG4gIH1cbiAgW1F1ZXJ5QnJhbmRdID0gdHJ1ZTtcbiAgd2hlcmUocHJlZGljYXRlKSB7XG4gICAgY29uc3QgbmV3Q29uZGl0aW9uID0gcHJlZGljYXRlKHRoaXMudGFibGUuY29scyk7XG4gICAgY29uc3QgbmV4dFdoZXJlID0gdGhpcy53aGVyZUNsYXVzZSA/IGFuZCh0aGlzLndoZXJlQ2xhdXNlLCBuZXdDb25kaXRpb24pIDogbmV3Q29uZGl0aW9uO1xuICAgIHJldHVybiBuZXcgX0Zyb21CdWlsZGVyKHRoaXMudGFibGUsIG5leHRXaGVyZSk7XG4gIH1cbiAgcmlnaHRTZW1pam9pbihyaWdodCwgb24pIHtcbiAgICBjb25zdCBzb3VyY2VRdWVyeSA9IG5ldyBfRnJvbUJ1aWxkZXIocmlnaHQpO1xuICAgIGNvbnN0IGpvaW5Db25kaXRpb24gPSBvbihcbiAgICAgIHRoaXMudGFibGUuaW5kZXhlZENvbHMsXG4gICAgICByaWdodC5pbmRleGVkQ29sc1xuICAgICk7XG4gICAgcmV0dXJuIG5ldyBTZW1pam9pbkltcGwoc291cmNlUXVlcnksIHRoaXMsIGpvaW5Db25kaXRpb24pO1xuICB9XG4gIGxlZnRTZW1pam9pbihyaWdodCwgb24pIHtcbiAgICBjb25zdCBmaWx0ZXJRdWVyeSA9IG5ldyBfRnJvbUJ1aWxkZXIocmlnaHQpO1xuICAgIGNvbnN0IGpvaW5Db25kaXRpb24gPSBvbihcbiAgICAgIHRoaXMudGFibGUuaW5kZXhlZENvbHMsXG4gICAgICByaWdodC5pbmRleGVkQ29sc1xuICAgICk7XG4gICAgcmV0dXJuIG5ldyBTZW1pam9pbkltcGwodGhpcywgZmlsdGVyUXVlcnksIGpvaW5Db25kaXRpb24pO1xuICB9XG4gIHRvU3FsKCkge1xuICAgIHJldHVybiByZW5kZXJTZWxlY3RTcWxXaXRoSm9pbnModGhpcy50YWJsZSwgdGhpcy53aGVyZUNsYXVzZSk7XG4gIH1cbiAgYnVpbGQoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG52YXIgVGFibGVSZWZJbXBsID0gY2xhc3Mge1xuICB0eXBlID0gXCJ0YWJsZVwiO1xuICBuYW1lO1xuICBjb2xzO1xuICBpbmRleGVkQ29scztcbiAgdGFibGVEZWY7XG4gIGNvbnN0cnVjdG9yKHRhYmxlRGVmKSB7XG4gICAgdGhpcy5uYW1lID0gdGFibGVEZWYubmFtZTtcbiAgICB0aGlzLmNvbHMgPSBjcmVhdGVSb3dFeHByKHRhYmxlRGVmKTtcbiAgICB0aGlzLmluZGV4ZWRDb2xzID0gdGhpcy5jb2xzO1xuICAgIHRoaXMudGFibGVEZWYgPSB0YWJsZURlZjtcbiAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICB9XG4gIGFzRnJvbSgpIHtcbiAgICByZXR1cm4gbmV3IEZyb21CdWlsZGVyKHRoaXMpO1xuICB9XG4gIHJpZ2h0U2VtaWpvaW4ob3RoZXIsIG9uKSB7XG4gICAgcmV0dXJuIHRoaXMuYXNGcm9tKCkucmlnaHRTZW1pam9pbihvdGhlciwgb24pO1xuICB9XG4gIGxlZnRTZW1pam9pbihvdGhlciwgb24pIHtcbiAgICByZXR1cm4gdGhpcy5hc0Zyb20oKS5sZWZ0U2VtaWpvaW4ob3RoZXIsIG9uKTtcbiAgfVxuICBidWlsZCgpIHtcbiAgICByZXR1cm4gdGhpcy5hc0Zyb20oKS5idWlsZCgpO1xuICB9XG4gIHRvU3FsKCkge1xuICAgIHJldHVybiB0aGlzLmFzRnJvbSgpLnRvU3FsKCk7XG4gIH1cbiAgd2hlcmUocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIHRoaXMuYXNGcm9tKCkud2hlcmUocHJlZGljYXRlKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGNyZWF0ZVRhYmxlUmVmRnJvbURlZih0YWJsZURlZikge1xuICByZXR1cm4gbmV3IFRhYmxlUmVmSW1wbCh0YWJsZURlZik7XG59XG5mdW5jdGlvbiBtYWtlUXVlcnlCdWlsZGVyKHNjaGVtYTIpIHtcbiAgY29uc3QgcWIgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZm9yIChjb25zdCB0YWJsZTIgb2Ygc2NoZW1hMi50YWJsZXMpIHtcbiAgICBjb25zdCByZWYgPSBjcmVhdGVUYWJsZVJlZkZyb21EZWYoXG4gICAgICB0YWJsZTJcbiAgICApO1xuICAgIHFiW3RhYmxlMi5uYW1lXSA9IHJlZjtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShxYik7XG59XG5mdW5jdGlvbiBjcmVhdGVSb3dFeHByKHRhYmxlRGVmKSB7XG4gIGNvbnN0IHJvdyA9IHt9O1xuICBmb3IgKGNvbnN0IGNvbHVtbk5hbWUgb2YgT2JqZWN0LmtleXModGFibGVEZWYuY29sdW1ucykpIHtcbiAgICBjb25zdCBjb2x1bW5CdWlsZGVyID0gdGFibGVEZWYuY29sdW1uc1tjb2x1bW5OYW1lXTtcbiAgICBjb25zdCBjb2x1bW4gPSBuZXcgQ29sdW1uRXhwcmVzc2lvbihcbiAgICAgIHRhYmxlRGVmLm5hbWUsXG4gICAgICBjb2x1bW5OYW1lLFxuICAgICAgY29sdW1uQnVpbGRlci50eXBlQnVpbGRlci5hbGdlYnJhaWNUeXBlXG4gICAgKTtcbiAgICByb3dbY29sdW1uTmFtZV0gPSBPYmplY3QuZnJlZXplKGNvbHVtbik7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5mcmVlemUocm93KTtcbn1cbmZ1bmN0aW9uIHJlbmRlclNlbGVjdFNxbFdpdGhKb2lucyh0YWJsZTIsIHdoZXJlLCBleHRyYUNsYXVzZXMgPSBbXSkge1xuICBjb25zdCBxdW90ZWRUYWJsZSA9IHF1b3RlSWRlbnRpZmllcih0YWJsZTIubmFtZSk7XG4gIGNvbnN0IHNxbCA9IGBTRUxFQ1QgKiBGUk9NICR7cXVvdGVkVGFibGV9YDtcbiAgY29uc3QgY2xhdXNlcyA9IFtdO1xuICBpZiAod2hlcmUpIGNsYXVzZXMucHVzaChib29sZWFuRXhwclRvU3FsKHdoZXJlKSk7XG4gIGNsYXVzZXMucHVzaCguLi5leHRyYUNsYXVzZXMpO1xuICBpZiAoY2xhdXNlcy5sZW5ndGggPT09IDApIHJldHVybiBzcWw7XG4gIGNvbnN0IHdoZXJlU3FsID0gY2xhdXNlcy5sZW5ndGggPT09IDEgPyBjbGF1c2VzWzBdIDogY2xhdXNlcy5tYXAod3JhcEluUGFyZW5zKS5qb2luKFwiIEFORCBcIik7XG4gIHJldHVybiBgJHtzcWx9IFdIRVJFICR7d2hlcmVTcWx9YDtcbn1cbnZhciBDb2x1bW5FeHByZXNzaW9uID0gY2xhc3Mge1xuICB0eXBlID0gXCJjb2x1bW5cIjtcbiAgY29sdW1uO1xuICB0YWJsZTtcbiAgLy8gcGhhbnRvbTogYWN0dWFsIHJ1bnRpbWUgdmFsdWUgaXMgdW5kZWZpbmVkXG4gIHRzVmFsdWVUeXBlO1xuICBzcGFjZXRpbWVUeXBlO1xuICBjb25zdHJ1Y3Rvcih0YWJsZTIsIGNvbHVtbiwgc3BhY2V0aW1lVHlwZSkge1xuICAgIHRoaXMudGFibGUgPSB0YWJsZTI7XG4gICAgdGhpcy5jb2x1bW4gPSBjb2x1bW47XG4gICAgdGhpcy5zcGFjZXRpbWVUeXBlID0gc3BhY2V0aW1lVHlwZTtcbiAgfVxuICAvLyBUaGVzZSB0eXBlcyBjb3VsZCBiZSB0aWdodGVkLCBidXQgc2luY2Ugd2UgZGVjbGFyZSB0aGUgb3ZlcmxvYWRzIGFib3ZlLCBpdCBkb2Vzbid0IHdlYWtlbiB0aGUgQVBJIHN1cmZhY2UuXG4gIGVxKHgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJlcVwiLFxuICAgICAgbGVmdDogdGhpcyxcbiAgICAgIHJpZ2h0OiBub3JtYWxpemVWYWx1ZSh4KVxuICAgIH07XG4gIH1cbiAgLy8gVGhlc2UgdHlwZXMgY291bGQgYmUgdGlnaHRlZCwgYnV0IHNpbmNlIHdlIGRlY2xhcmUgdGhlIG92ZXJsb2FkcyBhYm92ZSwgaXQgZG9lc24ndCB3ZWFrZW4gdGhlIEFQSSBzdXJmYWNlLlxuICBsdCh4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwibHRcIixcbiAgICAgIGxlZnQ6IHRoaXMsXG4gICAgICByaWdodDogbm9ybWFsaXplVmFsdWUoeClcbiAgICB9O1xuICB9XG4gIC8vIFRoZXNlIHR5cGVzIGNvdWxkIGJlIHRpZ2h0ZWQsIGJ1dCBzaW5jZSB3ZSBkZWNsYXJlIHRoZSBvdmVybG9hZHMgYWJvdmUsIGl0IGRvZXNuJ3Qgd2Vha2VuIHRoZSBBUEkgc3VyZmFjZS5cbiAgbHRlKHgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJsdGVcIixcbiAgICAgIGxlZnQ6IHRoaXMsXG4gICAgICByaWdodDogbm9ybWFsaXplVmFsdWUoeClcbiAgICB9O1xuICB9XG4gIC8vIFRoZXNlIHR5cGVzIGNvdWxkIGJlIHRpZ2h0ZWQsIGJ1dCBzaW5jZSB3ZSBkZWNsYXJlIHRoZSBvdmVybG9hZHMgYWJvdmUsIGl0IGRvZXNuJ3Qgd2Vha2VuIHRoZSBBUEkgc3VyZmFjZS5cbiAgZ3QoeCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImd0XCIsXG4gICAgICBsZWZ0OiB0aGlzLFxuICAgICAgcmlnaHQ6IG5vcm1hbGl6ZVZhbHVlKHgpXG4gICAgfTtcbiAgfVxuICAvLyBUaGVzZSB0eXBlcyBjb3VsZCBiZSB0aWdodGVkLCBidXQgc2luY2Ugd2UgZGVjbGFyZSB0aGUgb3ZlcmxvYWRzIGFib3ZlLCBpdCBkb2Vzbid0IHdlYWtlbiB0aGUgQVBJIHN1cmZhY2UuXG4gIGd0ZSh4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZ3RlXCIsXG4gICAgICBsZWZ0OiB0aGlzLFxuICAgICAgcmlnaHQ6IG5vcm1hbGl6ZVZhbHVlKHgpXG4gICAgfTtcbiAgfVxufTtcbmZ1bmN0aW9uIGxpdGVyYWwodmFsdWUpIHtcbiAgcmV0dXJuIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlIH07XG59XG5mdW5jdGlvbiBub3JtYWxpemVWYWx1ZSh2YWwpIHtcbiAgaWYgKHZhbC50eXBlID09PSBcImxpdGVyYWxcIilcbiAgICByZXR1cm4gdmFsO1xuICBpZiAodHlwZW9mIHZhbCA9PT0gXCJvYmplY3RcIiAmJiB2YWwgIT0gbnVsbCAmJiBcInR5cGVcIiBpbiB2YWwgJiYgdmFsLnR5cGUgPT09IFwiY29sdW1uXCIpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIHJldHVybiBsaXRlcmFsKHZhbCk7XG59XG5mdW5jdGlvbiBub3QoY2xhdXNlKSB7XG4gIHJldHVybiB7IHR5cGU6IFwibm90XCIsIGNsYXVzZSB9O1xufVxuZnVuY3Rpb24gYW5kKC4uLmNsYXVzZXMpIHtcbiAgcmV0dXJuIHsgdHlwZTogXCJhbmRcIiwgY2xhdXNlcyB9O1xufVxuZnVuY3Rpb24gb3IoLi4uY2xhdXNlcykge1xuICByZXR1cm4geyB0eXBlOiBcIm9yXCIsIGNsYXVzZXMgfTtcbn1cbmZ1bmN0aW9uIGJvb2xlYW5FeHByVG9TcWwoZXhwciwgdGFibGVBbGlhcykge1xuICBzd2l0Y2ggKGV4cHIudHlwZSkge1xuICAgIGNhc2UgXCJlcVwiOlxuICAgICAgcmV0dXJuIGAke3ZhbHVlRXhwclRvU3FsKGV4cHIubGVmdCl9ID0gJHt2YWx1ZUV4cHJUb1NxbChleHByLnJpZ2h0KX1gO1xuICAgIGNhc2UgXCJuZVwiOlxuICAgICAgcmV0dXJuIGAke3ZhbHVlRXhwclRvU3FsKGV4cHIubGVmdCl9IDw+ICR7dmFsdWVFeHByVG9TcWwoZXhwci5yaWdodCl9YDtcbiAgICBjYXNlIFwiZ3RcIjpcbiAgICAgIHJldHVybiBgJHt2YWx1ZUV4cHJUb1NxbChleHByLmxlZnQpfSA+ICR7dmFsdWVFeHByVG9TcWwoZXhwci5yaWdodCl9YDtcbiAgICBjYXNlIFwiZ3RlXCI6XG4gICAgICByZXR1cm4gYCR7dmFsdWVFeHByVG9TcWwoZXhwci5sZWZ0KX0gPj0gJHt2YWx1ZUV4cHJUb1NxbChleHByLnJpZ2h0KX1gO1xuICAgIGNhc2UgXCJsdFwiOlxuICAgICAgcmV0dXJuIGAke3ZhbHVlRXhwclRvU3FsKGV4cHIubGVmdCl9IDwgJHt2YWx1ZUV4cHJUb1NxbChleHByLnJpZ2h0KX1gO1xuICAgIGNhc2UgXCJsdGVcIjpcbiAgICAgIHJldHVybiBgJHt2YWx1ZUV4cHJUb1NxbChleHByLmxlZnQpfSA8PSAke3ZhbHVlRXhwclRvU3FsKGV4cHIucmlnaHQpfWA7XG4gICAgY2FzZSBcImFuZFwiOlxuICAgICAgcmV0dXJuIGV4cHIuY2xhdXNlcy5tYXAoKGMpID0+IGJvb2xlYW5FeHByVG9TcWwoYykpLm1hcCh3cmFwSW5QYXJlbnMpLmpvaW4oXCIgQU5EIFwiKTtcbiAgICBjYXNlIFwib3JcIjpcbiAgICAgIHJldHVybiBleHByLmNsYXVzZXMubWFwKChjKSA9PiBib29sZWFuRXhwclRvU3FsKGMpKS5tYXAod3JhcEluUGFyZW5zKS5qb2luKFwiIE9SIFwiKTtcbiAgICBjYXNlIFwibm90XCI6XG4gICAgICByZXR1cm4gYE5PVCAke3dyYXBJblBhcmVucyhib29sZWFuRXhwclRvU3FsKGV4cHIuY2xhdXNlKSl9YDtcbiAgfVxufVxuZnVuY3Rpb24gd3JhcEluUGFyZW5zKHNxbCkge1xuICByZXR1cm4gYCgke3NxbH0pYDtcbn1cbmZ1bmN0aW9uIHZhbHVlRXhwclRvU3FsKGV4cHIsIHRhYmxlQWxpYXMpIHtcbiAgaWYgKGlzTGl0ZXJhbEV4cHIoZXhwcikpIHtcbiAgICByZXR1cm4gbGl0ZXJhbFZhbHVlVG9TcWwoZXhwci52YWx1ZSk7XG4gIH1cbiAgY29uc3QgdGFibGUyID0gZXhwci50YWJsZTtcbiAgcmV0dXJuIGAke3F1b3RlSWRlbnRpZmllcih0YWJsZTIpfS4ke3F1b3RlSWRlbnRpZmllcihleHByLmNvbHVtbil9YDtcbn1cbmZ1bmN0aW9uIGxpdGVyYWxWYWx1ZVRvU3FsKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIFwiTlVMTFwiO1xuICB9XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIElkZW50aXR5IHx8IHZhbHVlIGluc3RhbmNlb2YgQ29ubmVjdGlvbklkKSB7XG4gICAgcmV0dXJuIGAweCR7dmFsdWUudG9IZXhTdHJpbmcoKX1gO1xuICB9XG4gIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICByZXR1cm4gdmFsdWUgPyBcIlRSVUVcIiA6IFwiRkFMU0VcIjtcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICByZXR1cm4gYCcke3ZhbHVlLnJlcGxhY2UoLycvZywgXCInJ1wiKX0nYDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGAnJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvJy9nLCBcIicnXCIpfSdgO1xuICB9XG59XG5mdW5jdGlvbiBxdW90ZUlkZW50aWZpZXIobmFtZSkge1xuICByZXR1cm4gYFwiJHtuYW1lLnJlcGxhY2UoL1wiL2csICdcIlwiJyl9XCJgO1xufVxuZnVuY3Rpb24gaXNMaXRlcmFsRXhwcihleHByKSB7XG4gIHJldHVybiBleHByLnR5cGUgPT09IFwibGl0ZXJhbFwiO1xufVxuXG4vLyBzcmMvbGliL3ZpZXdzLnRzXG5mdW5jdGlvbiBkZWZpbmVWaWV3KG9wdHMsIGFub24sIHBhcmFtcywgcmV0LCBmbikge1xuICBjb25zdCBwYXJhbXNCdWlsZGVyID0gbmV3IFJvd0J1aWxkZXIocGFyYW1zLCB0b1Bhc2NhbENhc2Uob3B0cy5uYW1lKSk7XG4gIGxldCByZXR1cm5UeXBlID0gcmVnaXN0ZXJUeXBlc1JlY3Vyc2l2ZWx5KHJldCkuYWxnZWJyYWljVHlwZTtcbiAgY29uc3QgeyB2YWx1ZTogcGFyYW1UeXBlIH0gPSByZXNvbHZlVHlwZShcbiAgICBNT0RVTEVfREVGLnR5cGVzcGFjZSxcbiAgICByZWdpc3RlclR5cGVzUmVjdXJzaXZlbHkocGFyYW1zQnVpbGRlcilcbiAgKTtcbiAgTU9EVUxFX0RFRi5taXNjRXhwb3J0cy5wdXNoKHtcbiAgICB0YWc6IFwiVmlld1wiLFxuICAgIHZhbHVlOiB7XG4gICAgICBuYW1lOiBvcHRzLm5hbWUsXG4gICAgICBpbmRleDogKGFub24gPyBBTk9OX1ZJRVdTIDogVklFV1MpLmxlbmd0aCxcbiAgICAgIGlzUHVibGljOiBvcHRzLnB1YmxpYyxcbiAgICAgIGlzQW5vbnltb3VzOiBhbm9uLFxuICAgICAgcGFyYW1zOiBwYXJhbVR5cGUsXG4gICAgICByZXR1cm5UeXBlXG4gICAgfVxuICB9KTtcbiAgaWYgKHJldHVyblR5cGUudGFnID09IFwiU3VtXCIpIHtcbiAgICBjb25zdCBvcmlnaW5hbEZuID0gZm47XG4gICAgZm4gPSAoKGN0eCwgYXJncykgPT4ge1xuICAgICAgY29uc3QgcmV0MiA9IG9yaWdpbmFsRm4oY3R4LCBhcmdzKTtcbiAgICAgIHJldHVybiByZXQyID09IG51bGwgPyBbXSA6IFtyZXQyXTtcbiAgICB9KTtcbiAgICByZXR1cm5UeXBlID0gQWxnZWJyYWljVHlwZS5BcnJheShcbiAgICAgIHJldHVyblR5cGUudmFsdWUudmFyaWFudHNbMF0uYWxnZWJyYWljVHlwZVxuICAgICk7XG4gIH1cbiAgKGFub24gPyBBTk9OX1ZJRVdTIDogVklFV1MpLnB1c2goe1xuICAgIGZuLFxuICAgIHBhcmFtczogcGFyYW1UeXBlLFxuICAgIHJldHVyblR5cGUsXG4gICAgcmV0dXJuVHlwZUJhc2VTaXplOiBic2F0bkJhc2VTaXplKE1PRFVMRV9ERUYudHlwZXNwYWNlLCByZXR1cm5UeXBlKVxuICB9KTtcbn1cbnZhciBWSUVXUyA9IFtdO1xudmFyIEFOT05fVklFV1MgPSBbXTtcblxuLy8gc3JjL2xpYi9wcm9jZWR1cmVzLnRzXG5mdW5jdGlvbiBwcm9jZWR1cmUobmFtZSwgcGFyYW1zLCByZXQsIGZuKSB7XG4gIGNvbnN0IHBhcmFtc1R5cGUgPSB7XG4gICAgZWxlbWVudHM6IE9iamVjdC5lbnRyaWVzKHBhcmFtcykubWFwKChbbiwgY10pID0+ICh7XG4gICAgICBuYW1lOiBuLFxuICAgICAgYWxnZWJyYWljVHlwZTogcmVnaXN0ZXJUeXBlc1JlY3Vyc2l2ZWx5KFxuICAgICAgICBcInR5cGVCdWlsZGVyXCIgaW4gYyA/IGMudHlwZUJ1aWxkZXIgOiBjXG4gICAgICApLmFsZ2VicmFpY1R5cGVcbiAgICB9KSlcbiAgfTtcbiAgY29uc3QgcmV0dXJuVHlwZSA9IHJlZ2lzdGVyVHlwZXNSZWN1cnNpdmVseShyZXQpLmFsZ2VicmFpY1R5cGU7XG4gIE1PRFVMRV9ERUYubWlzY0V4cG9ydHMucHVzaCh7XG4gICAgdGFnOiBcIlByb2NlZHVyZVwiLFxuICAgIHZhbHVlOiB7XG4gICAgICBuYW1lLFxuICAgICAgcGFyYW1zOiBwYXJhbXNUeXBlLFxuICAgICAgcmV0dXJuVHlwZVxuICAgIH1cbiAgfSk7XG4gIFBST0NFRFVSRVMucHVzaCh7XG4gICAgZm4sXG4gICAgcGFyYW1zVHlwZSxcbiAgICByZXR1cm5UeXBlLFxuICAgIHJldHVyblR5cGVCYXNlU2l6ZTogYnNhdG5CYXNlU2l6ZShNT0RVTEVfREVGLnR5cGVzcGFjZSwgcmV0dXJuVHlwZSlcbiAgfSk7XG59XG52YXIgUFJPQ0VEVVJFUyA9IFtdO1xuXG4vLyBzcmMvbGliL3NjaGVtYS50c1xudmFyIFJFR0lTVEVSRURfU0NIRU1BID0gbnVsbDtcbmZ1bmN0aW9uIGdldFJlZ2lzdGVyZWRTY2hlbWEoKSB7XG4gIGlmIChSRUdJU1RFUkVEX1NDSEVNQSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU2NoZW1hIGhhcyBub3QgYmVlbiByZWdpc3RlcmVkIHlldC4gQ2FsbCBzY2hlbWEoKSBmaXJzdC5cIik7XG4gIH1cbiAgcmV0dXJuIFJFR0lTVEVSRURfU0NIRU1BO1xufVxuZnVuY3Rpb24gdGFibGVzVG9TY2hlbWEodGFibGVzKSB7XG4gIHJldHVybiB7IHRhYmxlczogdGFibGVzLm1hcCh0YWJsZVRvU2NoZW1hKSB9O1xufVxuZnVuY3Rpb24gdGFibGVUb1NjaGVtYShzY2hlbWEyKSB7XG4gIGNvbnN0IGdldENvbE5hbWUgPSAoaSkgPT4gc2NoZW1hMi5yb3dUeXBlLmFsZ2VicmFpY1R5cGUudmFsdWUuZWxlbWVudHNbaV0ubmFtZTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBzY2hlbWEyLnRhYmxlTmFtZSxcbiAgICBhY2Nlc3Nvck5hbWU6IHRvQ2FtZWxDYXNlKHNjaGVtYTIudGFibGVOYW1lKSxcbiAgICBjb2x1bW5zOiBzY2hlbWEyLnJvd1R5cGUucm93LFxuICAgIC8vIHR5cGVkIGFzIFRbaV1bJ3Jvd1R5cGUnXVsncm93J10gdW5kZXIgVGFibGVzVG9TY2hlbWE8VD5cbiAgICByb3dUeXBlOiBzY2hlbWEyLnJvd1NwYWNldGltZVR5cGUsXG4gICAgY29uc3RyYWludHM6IHNjaGVtYTIudGFibGVEZWYuY29uc3RyYWludHMubWFwKChjKSA9PiAoe1xuICAgICAgbmFtZTogYy5uYW1lLFxuICAgICAgY29uc3RyYWludDogXCJ1bmlxdWVcIixcbiAgICAgIGNvbHVtbnM6IGMuZGF0YS52YWx1ZS5jb2x1bW5zLm1hcChnZXRDb2xOYW1lKVxuICAgIH0pKSxcbiAgICAvLyBUT0RPOiBob3JyaWJsZSBob3JyaWJsZSBob3JyaWJsZS4gd2Ugc211Z2dsZSB0aGlzIGBBcnJheTxVbnR5cGVkSW5kZXg+YFxuICAgIC8vIGJ5IGNhc3RpbmcgaXQgdG8gYW4gYEFycmF5PEluZGV4T3B0cz5gIGFzIGBUYWJsZVRvU2NoZW1hYCBleHBlY3RzLlxuICAgIC8vIFRoaXMgaXMgdGhlbiB1c2VkIGluIGBUYWJsZUNhY2hlSW1wbC5jb25zdHJ1Y3RvcmAgYW5kIHdobyBrbm93cyB3aGVyZSBlbHNlLlxuICAgIC8vIFdlIHNob3VsZCBzdG9wIGx5aW5nIGFib3V0IG91ciB0eXBlcy5cbiAgICBpbmRleGVzOiBzY2hlbWEyLnRhYmxlRGVmLmluZGV4ZXMubWFwKChpZHgpID0+IHtcbiAgICAgIGNvbnN0IGNvbHVtbklkcyA9IGlkeC5hbGdvcml0aG0udGFnID09PSBcIkRpcmVjdFwiID8gW2lkeC5hbGdvcml0aG0udmFsdWVdIDogaWR4LmFsZ29yaXRobS52YWx1ZTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IGlkeC5hY2Nlc3Nvck5hbWUsXG4gICAgICAgIHVuaXF1ZTogc2NoZW1hMi50YWJsZURlZi5jb25zdHJhaW50cy5zb21lKFxuICAgICAgICAgIChjKSA9PiBjLmRhdGEudmFsdWUuY29sdW1ucy5ldmVyeSgoY29sKSA9PiBjb2x1bW5JZHMuaW5jbHVkZXMoY29sKSlcbiAgICAgICAgKSxcbiAgICAgICAgYWxnb3JpdGhtOiBpZHguYWxnb3JpdGhtLnRhZy50b0xvd2VyQ2FzZSgpLFxuICAgICAgICBjb2x1bW5zOiBjb2x1bW5JZHMubWFwKGdldENvbE5hbWUpXG4gICAgICB9O1xuICAgIH0pXG4gIH07XG59XG52YXIgTU9EVUxFX0RFRiA9IHtcbiAgdHlwZXNwYWNlOiB7IHR5cGVzOiBbXSB9LFxuICB0YWJsZXM6IFtdLFxuICByZWR1Y2VyczogW10sXG4gIHR5cGVzOiBbXSxcbiAgbWlzY0V4cG9ydHM6IFtdLFxuICByb3dMZXZlbFNlY3VyaXR5OiBbXVxufTtcbnZhciBDT01QT1VORF9UWVBFUyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG5mdW5jdGlvbiByZXNvbHZlVHlwZSh0eXBlc3BhY2UsIHR5cGVCdWlsZGVyKSB7XG4gIGxldCB0eSA9IHR5cGVCdWlsZGVyLmFsZ2VicmFpY1R5cGU7XG4gIHdoaWxlICh0eS50YWcgPT09IFwiUmVmXCIpIHtcbiAgICB0eSA9IHR5cGVzcGFjZS50eXBlc1t0eS52YWx1ZV07XG4gIH1cbiAgcmV0dXJuIHR5O1xufVxuZnVuY3Rpb24gcmVnaXN0ZXJUeXBlc1JlY3Vyc2l2ZWx5KHR5cGVCdWlsZGVyKSB7XG4gIGlmICh0eXBlQnVpbGRlciBpbnN0YW5jZW9mIFByb2R1Y3RCdWlsZGVyICYmICFpc1VuaXQodHlwZUJ1aWxkZXIpIHx8IHR5cGVCdWlsZGVyIGluc3RhbmNlb2YgU3VtQnVpbGRlciB8fCB0eXBlQnVpbGRlciBpbnN0YW5jZW9mIFJvd0J1aWxkZXIpIHtcbiAgICByZXR1cm4gcmVnaXN0ZXJDb21wb3VuZFR5cGVSZWN1cnNpdmVseSh0eXBlQnVpbGRlcik7XG4gIH0gZWxzZSBpZiAodHlwZUJ1aWxkZXIgaW5zdGFuY2VvZiBPcHRpb25CdWlsZGVyKSB7XG4gICAgcmV0dXJuIG5ldyBPcHRpb25CdWlsZGVyKFxuICAgICAgcmVnaXN0ZXJUeXBlc1JlY3Vyc2l2ZWx5KHR5cGVCdWlsZGVyLnZhbHVlKVxuICAgICk7XG4gIH0gZWxzZSBpZiAodHlwZUJ1aWxkZXIgaW5zdGFuY2VvZiBSZXN1bHRCdWlsZGVyKSB7XG4gICAgcmV0dXJuIG5ldyBSZXN1bHRCdWlsZGVyKFxuICAgICAgcmVnaXN0ZXJUeXBlc1JlY3Vyc2l2ZWx5KHR5cGVCdWlsZGVyLm9rKSxcbiAgICAgIHJlZ2lzdGVyVHlwZXNSZWN1cnNpdmVseSh0eXBlQnVpbGRlci5lcnIpXG4gICAgKTtcbiAgfSBlbHNlIGlmICh0eXBlQnVpbGRlciBpbnN0YW5jZW9mIEFycmF5QnVpbGRlcikge1xuICAgIHJldHVybiBuZXcgQXJyYXlCdWlsZGVyKFxuICAgICAgcmVnaXN0ZXJUeXBlc1JlY3Vyc2l2ZWx5KHR5cGVCdWlsZGVyLmVsZW1lbnQpXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdHlwZUJ1aWxkZXI7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyQ29tcG91bmRUeXBlUmVjdXJzaXZlbHkodHlwZUJ1aWxkZXIpIHtcbiAgY29uc3QgdHkgPSB0eXBlQnVpbGRlci5hbGdlYnJhaWNUeXBlO1xuICBjb25zdCBuYW1lID0gdHlwZUJ1aWxkZXIudHlwZU5hbWU7XG4gIGlmIChuYW1lID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgTWlzc2luZyB0eXBlIG5hbWUgZm9yICR7dHlwZUJ1aWxkZXIuY29uc3RydWN0b3IubmFtZSA/PyBcIlR5cGVCdWlsZGVyXCJ9ICR7SlNPTi5zdHJpbmdpZnkodHlwZUJ1aWxkZXIpfWBcbiAgICApO1xuICB9XG4gIGxldCByID0gQ09NUE9VTkRfVFlQRVMuZ2V0KHR5KTtcbiAgaWYgKHIgIT0gbnVsbCkge1xuICAgIHJldHVybiByO1xuICB9XG4gIGNvbnN0IG5ld1R5ID0gdHlwZUJ1aWxkZXIgaW5zdGFuY2VvZiBSb3dCdWlsZGVyIHx8IHR5cGVCdWlsZGVyIGluc3RhbmNlb2YgUHJvZHVjdEJ1aWxkZXIgPyB7XG4gICAgdGFnOiBcIlByb2R1Y3RcIixcbiAgICB2YWx1ZTogeyBlbGVtZW50czogW10gfVxuICB9IDogeyB0YWc6IFwiU3VtXCIsIHZhbHVlOiB7IHZhcmlhbnRzOiBbXSB9IH07XG4gIHIgPSBuZXcgUmVmQnVpbGRlcihNT0RVTEVfREVGLnR5cGVzcGFjZS50eXBlcy5sZW5ndGgpO1xuICBNT0RVTEVfREVGLnR5cGVzcGFjZS50eXBlcy5wdXNoKG5ld1R5KTtcbiAgQ09NUE9VTkRfVFlQRVMuc2V0KHR5LCByKTtcbiAgaWYgKHR5cGVCdWlsZGVyIGluc3RhbmNlb2YgUm93QnVpbGRlcikge1xuICAgIGZvciAoY29uc3QgW25hbWUyLCBlbGVtXSBvZiBPYmplY3QuZW50cmllcyh0eXBlQnVpbGRlci5yb3cpKSB7XG4gICAgICBuZXdUeS52YWx1ZS5lbGVtZW50cy5wdXNoKHtcbiAgICAgICAgbmFtZTogbmFtZTIsXG4gICAgICAgIGFsZ2VicmFpY1R5cGU6IHJlZ2lzdGVyVHlwZXNSZWN1cnNpdmVseShlbGVtLnR5cGVCdWlsZGVyKS5hbGdlYnJhaWNUeXBlXG4gICAgICB9KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZUJ1aWxkZXIgaW5zdGFuY2VvZiBQcm9kdWN0QnVpbGRlcikge1xuICAgIGZvciAoY29uc3QgW25hbWUyLCBlbGVtXSBvZiBPYmplY3QuZW50cmllcyh0eXBlQnVpbGRlci5lbGVtZW50cykpIHtcbiAgICAgIG5ld1R5LnZhbHVlLmVsZW1lbnRzLnB1c2goe1xuICAgICAgICBuYW1lOiBuYW1lMixcbiAgICAgICAgYWxnZWJyYWljVHlwZTogcmVnaXN0ZXJUeXBlc1JlY3Vyc2l2ZWx5KGVsZW0pLmFsZ2VicmFpY1R5cGVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlQnVpbGRlciBpbnN0YW5jZW9mIFN1bUJ1aWxkZXIpIHtcbiAgICBmb3IgKGNvbnN0IFtuYW1lMiwgdmFyaWFudF0gb2YgT2JqZWN0LmVudHJpZXModHlwZUJ1aWxkZXIudmFyaWFudHMpKSB7XG4gICAgICBuZXdUeS52YWx1ZS52YXJpYW50cy5wdXNoKHtcbiAgICAgICAgbmFtZTogbmFtZTIsXG4gICAgICAgIGFsZ2VicmFpY1R5cGU6IHJlZ2lzdGVyVHlwZXNSZWN1cnNpdmVseSh2YXJpYW50KS5hbGdlYnJhaWNUeXBlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgTU9EVUxFX0RFRi50eXBlcy5wdXNoKHtcbiAgICBuYW1lOiBzcGxpdE5hbWUobmFtZSksXG4gICAgdHk6IHIucmVmLFxuICAgIGN1c3RvbU9yZGVyaW5nOiB0cnVlXG4gIH0pO1xuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIGlzVW5pdCh0eXBlQnVpbGRlcikge1xuICByZXR1cm4gdHlwZUJ1aWxkZXIudHlwZU5hbWUgPT0gbnVsbCAmJiB0eXBlQnVpbGRlci5hbGdlYnJhaWNUeXBlLnZhbHVlLmVsZW1lbnRzLmxlbmd0aCA9PT0gMDtcbn1cbmZ1bmN0aW9uIHNwbGl0TmFtZShuYW1lKSB7XG4gIGNvbnN0IHNjb3BlID0gbmFtZS5zcGxpdChcIi5cIik7XG4gIHJldHVybiB7IG5hbWU6IHNjb3BlLnBvcCgpLCBzY29wZSB9O1xufVxudmFyIFNjaGVtYSA9IGNsYXNzIHtcbiAgdGFibGVzRGVmO1xuICB0eXBlc3BhY2U7XG4gIHNjaGVtYVR5cGU7XG4gIGNvbnN0cnVjdG9yKHRhYmxlcywgdHlwZXNwYWNlLCBoYW5kbGVzKSB7XG4gICAgdGhpcy50YWJsZXNEZWYgPSB7IHRhYmxlcyB9O1xuICAgIHRoaXMudHlwZXNwYWNlID0gdHlwZXNwYWNlO1xuICAgIHRoaXMuc2NoZW1hVHlwZSA9IHRhYmxlc1RvU2NoZW1hKGhhbmRsZXMpO1xuICB9XG4gIHJlZHVjZXIobmFtZSwgcGFyYW1zT3JGbiwgZm4pIHtcbiAgICBpZiAodHlwZW9mIHBhcmFtc09yRm4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmVkdWNlcihuYW1lLCB7fSwgcGFyYW1zT3JGbik7XG4gICAgICByZXR1cm4gcGFyYW1zT3JGbjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVkdWNlcihuYW1lLCBwYXJhbXNPckZuLCBmbik7XG4gICAgICByZXR1cm4gZm47XG4gICAgfVxuICB9XG4gIGluaXQobmFtZU9yRm4sIG1heWJlRm4pIHtcbiAgICBjb25zdCBbbmFtZSwgZm5dID0gdHlwZW9mIG5hbWVPckZuID09PSBcInN0cmluZ1wiID8gW25hbWVPckZuLCBtYXliZUZuXSA6IFtcImluaXRcIiwgbmFtZU9yRm5dO1xuICAgIGluaXQobmFtZSwge30sIGZuKTtcbiAgfVxuICBjbGllbnRDb25uZWN0ZWQobmFtZU9yRm4sIG1heWJlRm4pIHtcbiAgICBjb25zdCBbbmFtZSwgZm5dID0gdHlwZW9mIG5hbWVPckZuID09PSBcInN0cmluZ1wiID8gW25hbWVPckZuLCBtYXliZUZuXSA6IFtcIm9uX2Nvbm5lY3RcIiwgbmFtZU9yRm5dO1xuICAgIGNsaWVudENvbm5lY3RlZChuYW1lLCB7fSwgZm4pO1xuICB9XG4gIGNsaWVudERpc2Nvbm5lY3RlZChuYW1lT3JGbiwgbWF5YmVGbikge1xuICAgIGNvbnN0IFtuYW1lLCBmbl0gPSB0eXBlb2YgbmFtZU9yRm4gPT09IFwic3RyaW5nXCIgPyBbbmFtZU9yRm4sIG1heWJlRm5dIDogW1wib25fZGlzY29ubmVjdFwiLCBuYW1lT3JGbl07XG4gICAgY2xpZW50RGlzY29ubmVjdGVkKG5hbWUsIHt9LCBmbik7XG4gIH1cbiAgdmlldyhvcHRzLCByZXQsIGZuKSB7XG4gICAgZGVmaW5lVmlldyhvcHRzLCBmYWxzZSwge30sIHJldCwgZm4pO1xuICB9XG4gIC8vIFRPRE86IHJlLWVuYWJsZSBvbmNlIHBhcmFtZXRlcml6ZWQgdmlld3MgYXJlIHN1cHBvcnRlZCBpbiBTUUxcbiAgLy8gdmlldzxSZXQgZXh0ZW5kcyBWaWV3UmV0dXJuVHlwZUJ1aWxkZXI+KFxuICAvLyAgIG9wdHM6IFZpZXdPcHRzLFxuICAvLyAgIHJldDogUmV0LFxuICAvLyAgIGZuOiBWaWV3Rm48Uywge30sIFJldD5cbiAgLy8gKTogdm9pZDtcbiAgLy8gdmlldzxQYXJhbXMgZXh0ZW5kcyBQYXJhbXNPYmosIFJldCBleHRlbmRzIFZpZXdSZXR1cm5UeXBlQnVpbGRlcj4oXG4gIC8vICAgb3B0czogVmlld09wdHMsXG4gIC8vICAgcGFyYW1zOiBQYXJhbXMsXG4gIC8vICAgcmV0OiBSZXQsXG4gIC8vICAgZm46IFZpZXdGbjxTLCB7fSwgUmV0PlxuICAvLyApOiB2b2lkO1xuICAvLyB2aWV3PFBhcmFtcyBleHRlbmRzIFBhcmFtc09iaiwgUmV0IGV4dGVuZHMgVmlld1JldHVyblR5cGVCdWlsZGVyPihcbiAgLy8gICBvcHRzOiBWaWV3T3B0cyxcbiAgLy8gICBwYXJhbXNPclJldDogUmV0IHwgUGFyYW1zLFxuICAvLyAgIHJldE9yRm46IFZpZXdGbjxTLCB7fSwgUmV0PiB8IFJldCxcbiAgLy8gICBtYXliZUZuPzogVmlld0ZuPFMsIFBhcmFtcywgUmV0PlxuICAvLyApOiB2b2lkIHtcbiAgLy8gICBpZiAodHlwZW9mIHJldE9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gICAgIGRlZmluZVZpZXcobmFtZSwgZmFsc2UsIHt9LCBwYXJhbXNPclJldCBhcyBSZXQsIHJldE9yRm4pO1xuICAvLyAgIH0gZWxzZSB7XG4gIC8vICAgICBkZWZpbmVWaWV3KG5hbWUsIGZhbHNlLCBwYXJhbXNPclJldCBhcyBQYXJhbXMsIHJldE9yRm4sIG1heWJlRm4hKTtcbiAgLy8gICB9XG4gIC8vIH1cbiAgYW5vbnltb3VzVmlldyhvcHRzLCByZXQsIGZuKSB7XG4gICAgZGVmaW5lVmlldyhvcHRzLCB0cnVlLCB7fSwgcmV0LCBmbik7XG4gIH1cbiAgcHJvY2VkdXJlKG5hbWUsIHBhcmFtc09yUmV0LCByZXRPckZuLCBtYXliZUZuKSB7XG4gICAgaWYgKHR5cGVvZiByZXRPckZuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHByb2NlZHVyZShuYW1lLCB7fSwgcGFyYW1zT3JSZXQsIHJldE9yRm4pO1xuICAgICAgcmV0dXJuIHJldE9yRm47XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2NlZHVyZShuYW1lLCBwYXJhbXNPclJldCwgcmV0T3JGbiwgbWF5YmVGbik7XG4gICAgICByZXR1cm4gbWF5YmVGbjtcbiAgICB9XG4gIH1cbiAgY2xpZW50VmlzaWJpbGl0eUZpbHRlciA9IHtcbiAgICBzcWwoZmlsdGVyKSB7XG4gICAgICBNT0RVTEVfREVGLnJvd0xldmVsU2VjdXJpdHkucHVzaCh7IHNxbDogZmlsdGVyIH0pO1xuICAgIH1cbiAgfTtcbn07XG5mdW5jdGlvbiBzY2hlbWEoLi4uYXJncykge1xuICBjb25zdCBoYW5kbGVzID0gYXJncy5sZW5ndGggPT09IDEgJiYgQXJyYXkuaXNBcnJheShhcmdzWzBdKSA/IGFyZ3NbMF0gOiBhcmdzO1xuICBjb25zdCB0YWJsZURlZnMgPSBoYW5kbGVzLm1hcCgoaCkgPT4gaC50YWJsZURlZik7XG4gIE1PRFVMRV9ERUYudGFibGVzLnB1c2goLi4udGFibGVEZWZzKTtcbiAgUkVHSVNURVJFRF9TQ0hFTUEgPSB7XG4gICAgdGFibGVzOiBoYW5kbGVzLm1hcCgoaGFuZGxlKSA9PiAoe1xuICAgICAgbmFtZTogaGFuZGxlLnRhYmxlTmFtZSxcbiAgICAgIGFjY2Vzc29yTmFtZTogaGFuZGxlLnRhYmxlTmFtZSxcbiAgICAgIGNvbHVtbnM6IGhhbmRsZS5yb3dUeXBlLnJvdyxcbiAgICAgIHJvd1R5cGU6IGhhbmRsZS5yb3dTcGFjZXRpbWVUeXBlLFxuICAgICAgaW5kZXhlczogaGFuZGxlLmlkeHMsXG4gICAgICBjb25zdHJhaW50czogaGFuZGxlLmNvbnN0cmFpbnRzXG4gICAgfSkpXG4gIH07XG4gIHJldHVybiBuZXcgU2NoZW1hKHRhYmxlRGVmcywgTU9EVUxFX0RFRi50eXBlc3BhY2UsIGhhbmRsZXMpO1xufVxuXG4vLyBzcmMvbGliL2F1dG9nZW4vcmF3X2luZGV4X2FsZ29yaXRobV90eXBlLnRzXG52YXIgUmF3SW5kZXhBbGdvcml0aG0gPSB0LmVudW0oXCJSYXdJbmRleEFsZ29yaXRobVwiLCB7XG4gIEJUcmVlOiB0LmFycmF5KHQudTE2KCkpLFxuICBIYXNoOiB0LmFycmF5KHQudTE2KCkpLFxuICBEaXJlY3Q6IHQudTE2KClcbn0pO1xudmFyIHJhd19pbmRleF9hbGdvcml0aG1fdHlwZV9kZWZhdWx0ID0gUmF3SW5kZXhBbGdvcml0aG07XG5cbi8vIHNyYy9saWIvdGFibGUudHNcbmZ1bmN0aW9uIHRhYmxlKG9wdHMsIHJvdykge1xuICBjb25zdCB7XG4gICAgbmFtZSxcbiAgICBwdWJsaWM6IGlzUHVibGljID0gZmFsc2UsXG4gICAgaW5kZXhlczogdXNlckluZGV4ZXMgPSBbXSxcbiAgICBzY2hlZHVsZWRcbiAgfSA9IG9wdHM7XG4gIGNvbnN0IGNvbElkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IGNvbE5hbWVMaXN0ID0gW107XG4gIGlmICghKHJvdyBpbnN0YW5jZW9mIFJvd0J1aWxkZXIpKSB7XG4gICAgcm93ID0gbmV3IFJvd0J1aWxkZXIocm93KTtcbiAgfVxuICBpZiAocm93LnR5cGVOYW1lID09PSB2b2lkIDApIHtcbiAgICByb3cudHlwZU5hbWUgPSB0b1Bhc2NhbENhc2UobmFtZSk7XG4gIH1cbiAgY29uc3Qgcm93VHlwZVJlZiA9IHJlZ2lzdGVyVHlwZXNSZWN1cnNpdmVseShyb3cpO1xuICByb3cuYWxnZWJyYWljVHlwZS52YWx1ZS5lbGVtZW50cy5mb3JFYWNoKChlbGVtLCBpKSA9PiB7XG4gICAgY29sSWRzLnNldChlbGVtLm5hbWUsIGkpO1xuICAgIGNvbE5hbWVMaXN0LnB1c2goZWxlbS5uYW1lKTtcbiAgfSk7XG4gIGNvbnN0IHBrID0gW107XG4gIGNvbnN0IGluZGV4ZXMgPSBbXTtcbiAgY29uc3QgY29uc3RyYWludHMgPSBbXTtcbiAgY29uc3Qgc2VxdWVuY2VzID0gW107XG4gIGxldCBzY2hlZHVsZUF0Q29sO1xuICBmb3IgKGNvbnN0IFtuYW1lMiwgYnVpbGRlcl0gb2YgT2JqZWN0LmVudHJpZXMocm93LnJvdykpIHtcbiAgICBjb25zdCBtZXRhID0gYnVpbGRlci5jb2x1bW5NZXRhZGF0YTtcbiAgICBpZiAobWV0YS5pc1ByaW1hcnlLZXkpIHtcbiAgICAgIHBrLnB1c2goY29sSWRzLmdldChuYW1lMikpO1xuICAgIH1cbiAgICBjb25zdCBpc1VuaXF1ZSA9IG1ldGEuaXNVbmlxdWUgfHwgbWV0YS5pc1ByaW1hcnlLZXk7XG4gICAgaWYgKG1ldGEuaW5kZXhUeXBlIHx8IGlzVW5pcXVlKSB7XG4gICAgICBjb25zdCBhbGdvID0gbWV0YS5pbmRleFR5cGUgPz8gXCJidHJlZVwiO1xuICAgICAgY29uc3QgaWQgPSBjb2xJZHMuZ2V0KG5hbWUyKTtcbiAgICAgIGxldCBhbGdvcml0aG07XG4gICAgICBzd2l0Y2ggKGFsZ28pIHtcbiAgICAgICAgY2FzZSBcImJ0cmVlXCI6XG4gICAgICAgICAgYWxnb3JpdGhtID0gcmF3X2luZGV4X2FsZ29yaXRobV90eXBlX2RlZmF1bHQuQlRyZWUoW2lkXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJkaXJlY3RcIjpcbiAgICAgICAgICBhbGdvcml0aG0gPSByYXdfaW5kZXhfYWxnb3JpdGhtX3R5cGVfZGVmYXVsdC5EaXJlY3QoaWQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaW5kZXhlcy5wdXNoKHtcbiAgICAgICAgbmFtZTogdm9pZCAwLFxuICAgICAgICAvLyBVbm5hbWVkIGluZGV4ZXMgd2lsbCBiZSBhc3NpZ25lZCBhIGdsb2JhbGx5IHVuaXF1ZSBuYW1lXG4gICAgICAgIGFjY2Vzc29yTmFtZTogbmFtZTIsXG4gICAgICAgIC8vIFRoZSBuYW1lIG9mIHRoaXMgY29sdW1uIHdpbGwgYmUgdXNlZCBhcyB0aGUgYWNjZXNzb3IgbmFtZVxuICAgICAgICBhbGdvcml0aG1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoaXNVbmlxdWUpIHtcbiAgICAgIGNvbnN0cmFpbnRzLnB1c2goe1xuICAgICAgICBuYW1lOiB2b2lkIDAsXG4gICAgICAgIGRhdGE6IHsgdGFnOiBcIlVuaXF1ZVwiLCB2YWx1ZTogeyBjb2x1bW5zOiBbY29sSWRzLmdldChuYW1lMildIH0gfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChtZXRhLmlzQXV0b0luY3JlbWVudCkge1xuICAgICAgc2VxdWVuY2VzLnB1c2goe1xuICAgICAgICBuYW1lOiB2b2lkIDAsXG4gICAgICAgIHN0YXJ0OiB2b2lkIDAsXG4gICAgICAgIG1pblZhbHVlOiB2b2lkIDAsXG4gICAgICAgIG1heFZhbHVlOiB2b2lkIDAsXG4gICAgICAgIGNvbHVtbjogY29sSWRzLmdldChuYW1lMiksXG4gICAgICAgIGluY3JlbWVudDogMW5cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc2NoZWR1bGVkKSB7XG4gICAgICBjb25zdCBhbGdlYnJhaWNUeXBlID0gYnVpbGRlci50eXBlQnVpbGRlci5hbGdlYnJhaWNUeXBlO1xuICAgICAgaWYgKHNjaGVkdWxlX2F0X2RlZmF1bHQuaXNTY2hlZHVsZUF0KGFsZ2VicmFpY1R5cGUpKSB7XG4gICAgICAgIHNjaGVkdWxlQXRDb2wgPSBjb2xJZHMuZ2V0KG5hbWUyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBpbmRleE9wdHMgb2YgdXNlckluZGV4ZXMgPz8gW10pIHtcbiAgICBsZXQgYWxnb3JpdGhtO1xuICAgIHN3aXRjaCAoaW5kZXhPcHRzLmFsZ29yaXRobSkge1xuICAgICAgY2FzZSBcImJ0cmVlXCI6XG4gICAgICAgIGFsZ29yaXRobSA9IHtcbiAgICAgICAgICB0YWc6IFwiQlRyZWVcIixcbiAgICAgICAgICB2YWx1ZTogaW5kZXhPcHRzLmNvbHVtbnMubWFwKChjKSA9PiBjb2xJZHMuZ2V0KGMpKVxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJkaXJlY3RcIjpcbiAgICAgICAgYWxnb3JpdGhtID0geyB0YWc6IFwiRGlyZWN0XCIsIHZhbHVlOiBjb2xJZHMuZ2V0KGluZGV4T3B0cy5jb2x1bW4pIH07XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpbmRleGVzLnB1c2goeyBuYW1lOiB2b2lkIDAsIGFjY2Vzc29yTmFtZTogaW5kZXhPcHRzLm5hbWUsIGFsZ29yaXRobSB9KTtcbiAgfVxuICBmb3IgKGNvbnN0IGNvbnN0cmFpbnRPcHRzIG9mIG9wdHMuY29uc3RyYWludHMgPz8gW10pIHtcbiAgICBpZiAoY29uc3RyYWludE9wdHMuY29uc3RyYWludCA9PT0gXCJ1bmlxdWVcIikge1xuICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgdGFnOiBcIlVuaXF1ZVwiLFxuICAgICAgICB2YWx1ZTogeyBjb2x1bW5zOiBjb25zdHJhaW50T3B0cy5jb2x1bW5zLm1hcCgoYykgPT4gY29sSWRzLmdldChjKSkgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0cmFpbnRzLnB1c2goeyBuYW1lOiBjb25zdHJhaW50T3B0cy5uYW1lLCBkYXRhIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3QgaW5kZXggb2YgaW5kZXhlcykge1xuICAgIGNvbnN0IGNvbHMgPSBpbmRleC5hbGdvcml0aG0udGFnID09PSBcIkRpcmVjdFwiID8gW2luZGV4LmFsZ29yaXRobS52YWx1ZV0gOiBpbmRleC5hbGdvcml0aG0udmFsdWU7XG4gICAgY29uc3QgY29sUyA9IGNvbHMubWFwKChpKSA9PiBjb2xOYW1lTGlzdFtpXSkuam9pbihcIl9cIik7XG4gICAgaW5kZXgubmFtZSA9IGAke25hbWV9XyR7Y29sU31faWR4XyR7aW5kZXguYWxnb3JpdGhtLnRhZy50b0xvd2VyQ2FzZSgpfWA7XG4gIH1cbiAgY29uc3QgdGFibGVEZWYgPSB7XG4gICAgbmFtZSxcbiAgICBwcm9kdWN0VHlwZVJlZjogcm93VHlwZVJlZi5yZWYsXG4gICAgcHJpbWFyeUtleTogcGssXG4gICAgaW5kZXhlcyxcbiAgICBjb25zdHJhaW50cyxcbiAgICBzZXF1ZW5jZXMsXG4gICAgc2NoZWR1bGU6IHNjaGVkdWxlZCAmJiBzY2hlZHVsZUF0Q29sICE9PSB2b2lkIDAgPyB7XG4gICAgICBuYW1lOiB2b2lkIDAsXG4gICAgICByZWR1Y2VyTmFtZTogc2NoZWR1bGVkLFxuICAgICAgc2NoZWR1bGVkQXRDb2x1bW46IHNjaGVkdWxlQXRDb2xcbiAgICB9IDogdm9pZCAwLFxuICAgIHRhYmxlVHlwZTogeyB0YWc6IFwiVXNlclwiIH0sXG4gICAgdGFibGVBY2Nlc3M6IHsgdGFnOiBpc1B1YmxpYyA/IFwiUHVibGljXCIgOiBcIlByaXZhdGVcIiB9XG4gIH07XG4gIGNvbnN0IHByb2R1Y3RUeXBlID0gcm93LmFsZ2VicmFpY1R5cGUudmFsdWU7XG4gIHJldHVybiB7XG4gICAgcm93VHlwZTogcm93LFxuICAgIHRhYmxlTmFtZTogbmFtZSxcbiAgICByb3dTcGFjZXRpbWVUeXBlOiBwcm9kdWN0VHlwZSxcbiAgICB0YWJsZURlZixcbiAgICBpZHhzOiB7fSxcbiAgICBjb25zdHJhaW50c1xuICB9O1xufVxuXG4vLyBzcmMvc2VydmVyL2Vycm9ycy50c1xudmFyIFNwYWNldGltZUhvc3RFcnJvciA9IGNsYXNzIF9TcGFjZXRpbWVIb3N0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvZGU7XG4gIG1lc3NhZ2U7XG4gIGNvbnN0cnVjdG9yKGNvZGUsIG1lc3NhZ2UpIHtcbiAgICBzdXBlcigpO1xuICAgIGNvbnN0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpO1xuICAgIGxldCBjbHM7XG4gICAgaWYgKGVycm9yUHJvdG95cGVzLmhhcyhwcm90bykpIHtcbiAgICAgIGNscyA9IHByb3RvLmNvbnN0cnVjdG9yO1xuICAgICAgaWYgKGNvZGUgIT09IGNscy5DT0RFKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBpbnZhbGlkIGVycm9yIGNvZGUgZm9yICR7Y2xzLm5hbWV9YCk7XG4gICAgfSBlbHNlIGlmIChwcm90byA9PT0gX1NwYWNldGltZUhvc3RFcnJvci5wcm90b3R5cGUpIHtcbiAgICAgIGNscyA9IGVycm5vVG9DbGFzcy5nZXQoY29kZSk7XG4gICAgICBpZiAoIWNscykgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYHVua25vd24gZXJyb3IgY29kZSAke2NvZGV9YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYW5ub3Qgc3ViY2xhc3MgU3BhY2V0aW1lRXJyb3JcIik7XG4gICAgfVxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBjbHMucHJvdG90eXBlKTtcbiAgICB0aGlzLmNvZGUgPSBjbHMuQ09ERTtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlID8/IGNscy5NRVNTQUdFO1xuICB9XG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiBlcnJub1RvQ2xhc3MuZ2V0KHRoaXMuY29kZSk/Lm5hbWUgPz8gXCJTcGFjZXRpbWVIb3N0RXJyb3JcIjtcbiAgfVxufTtcbnZhciBTZW5kZXJFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gIH1cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIFwiU2VuZGVyRXJyb3JcIjtcbiAgfVxufTtcbnZhciBlcnJvckRhdGEgPSB7XG4gIC8qKlxuICAgKiBBIGdlbmVyaWMgZXJyb3IgY2xhc3MgZm9yIHVua25vd24gZXJyb3IgY29kZXMuXG4gICAqL1xuICBIb3N0Q2FsbEZhaWx1cmU6IFsxLCBcIkFCSSBjYWxsZWQgYnkgaG9zdCByZXR1cm5lZCBhbiBlcnJvclwiXSxcbiAgLyoqXG4gICAqIEVycm9yIGluZGljYXRpbmcgdGhhdCBhbiBBQkkgY2FsbCB3YXMgbWFkZSBvdXRzaWRlIG9mIGEgdHJhbnNhY3Rpb24uXG4gICAqL1xuICBOb3RJblRyYW5zYWN0aW9uOiBbMiwgXCJBQkkgY2FsbCBjYW4gb25seSBiZSBtYWRlIHdoaWxlIGluIGEgdHJhbnNhY3Rpb25cIl0sXG4gIC8qKlxuICAgKiBFcnJvciBpbmRpY2F0aW5nIHRoYXQgQlNBVE4gZGVjb2RpbmcgZmFpbGVkLlxuICAgKiBUaGlzIHR5cGljYWxseSBtZWFucyB0aGF0IHRoZSBkYXRhIGNvdWxkIG5vdCBiZSBkZWNvZGVkIHRvIHRoZSBleHBlY3RlZCB0eXBlLlxuICAgKi9cbiAgQnNhdG5EZWNvZGVFcnJvcjogWzMsIFwiQ291bGRuJ3QgZGVjb2RlIHRoZSBCU0FUTiB0byB0aGUgZXhwZWN0ZWQgdHlwZVwiXSxcbiAgLyoqXG4gICAqIEVycm9yIGluZGljYXRpbmcgdGhhdCBhIHNwZWNpZmllZCB0YWJsZSBkb2VzIG5vdCBleGlzdC5cbiAgICovXG4gIE5vU3VjaFRhYmxlOiBbNCwgXCJObyBzdWNoIHRhYmxlXCJdLFxuICAvKipcbiAgICogRXJyb3IgaW5kaWNhdGluZyB0aGF0IGEgc3BlY2lmaWVkIGluZGV4IGRvZXMgbm90IGV4aXN0LlxuICAgKi9cbiAgTm9TdWNoSW5kZXg6IFs1LCBcIk5vIHN1Y2ggaW5kZXhcIl0sXG4gIC8qKlxuICAgKiBFcnJvciBpbmRpY2F0aW5nIHRoYXQgYSBzcGVjaWZpZWQgcm93IGl0ZXJhdG9yIGlzIG5vdCB2YWxpZC5cbiAgICovXG4gIE5vU3VjaEl0ZXI6IFs2LCBcIlRoZSBwcm92aWRlZCByb3cgaXRlcmF0b3IgaXMgbm90IHZhbGlkXCJdLFxuICAvKipcbiAgICogRXJyb3IgaW5kaWNhdGluZyB0aGF0IGEgc3BlY2lmaWVkIGNvbnNvbGUgdGltZXIgZG9lcyBub3QgZXhpc3QuXG4gICAqL1xuICBOb1N1Y2hDb25zb2xlVGltZXI6IFs3LCBcIlRoZSBwcm92aWRlZCBjb25zb2xlIHRpbWVyIGRvZXMgbm90IGV4aXN0XCJdLFxuICAvKipcbiAgICogRXJyb3IgaW5kaWNhdGluZyB0aGF0IGEgc3BlY2lmaWVkIGJ5dGVzIHNvdXJjZSBvciBzaW5rIGlzIG5vdCB2YWxpZC5cbiAgICovXG4gIE5vU3VjaEJ5dGVzOiBbOCwgXCJUaGUgcHJvdmlkZWQgYnl0ZXMgc291cmNlIG9yIHNpbmsgaXMgbm90IHZhbGlkXCJdLFxuICAvKipcbiAgICogRXJyb3IgaW5kaWNhdGluZyB0aGF0IGEgcHJvdmlkZWQgc2luayBoYXMgbm8gbW9yZSBzcGFjZSBsZWZ0LlxuICAgKi9cbiAgTm9TcGFjZTogWzksIFwiVGhlIHByb3ZpZGVkIHNpbmsgaGFzIG5vIG1vcmUgc3BhY2UgbGVmdFwiXSxcbiAgLyoqXG4gICAqIEVycm9yIGluZGljYXRpbmcgdGhhdCB0aGVyZSBpcyBubyBtb3JlIHNwYWNlIGluIHRoZSBkYXRhYmFzZS5cbiAgICovXG4gIEJ1ZmZlclRvb1NtYWxsOiBbXG4gICAgMTEsXG4gICAgXCJUaGUgcHJvdmlkZWQgYnVmZmVyIGlzIG5vdCBsYXJnZSBlbm91Z2ggdG8gc3RvcmUgdGhlIGRhdGFcIlxuICBdLFxuICAvKipcbiAgICogRXJyb3IgaW5kaWNhdGluZyB0aGF0IGEgdmFsdWUgd2l0aCBhIGdpdmVuIHVuaXF1ZSBpZGVudGlmaWVyIGFscmVhZHkgZXhpc3RzLlxuICAgKi9cbiAgVW5pcXVlQWxyZWFkeUV4aXN0czogW1xuICAgIDEyLFxuICAgIFwiVmFsdWUgd2l0aCBnaXZlbiB1bmlxdWUgaWRlbnRpZmllciBhbHJlYWR5IGV4aXN0c1wiXG4gIF0sXG4gIC8qKlxuICAgKiBFcnJvciBpbmRpY2F0aW5nIHRoYXQgdGhlIHNwZWNpZmllZCBkZWxheSBpbiBzY2hlZHVsaW5nIGEgcm93IHdhcyB0b28gbG9uZy5cbiAgICovXG4gIFNjaGVkdWxlQXREZWxheVRvb0xvbmc6IFtcbiAgICAxMyxcbiAgICBcIlNwZWNpZmllZCBkZWxheSBpbiBzY2hlZHVsaW5nIHJvdyB3YXMgdG9vIGxvbmdcIlxuICBdLFxuICAvKipcbiAgICogRXJyb3IgaW5kaWNhdGluZyB0aGF0IGFuIGluZGV4IHdhcyBub3QgdW5pcXVlIHdoZW4gaXQgd2FzIGV4cGVjdGVkIHRvIGJlLlxuICAgKi9cbiAgSW5kZXhOb3RVbmlxdWU6IFsxNCwgXCJUaGUgaW5kZXggd2FzIG5vdCB1bmlxdWVcIl0sXG4gIC8qKlxuICAgKiBFcnJvciBpbmRpY2F0aW5nIHRoYXQgYW4gaW5kZXggd2FzIG5vdCB1bmlxdWUgd2hlbiBpdCB3YXMgZXhwZWN0ZWQgdG8gYmUuXG4gICAqL1xuICBOb1N1Y2hSb3c6IFsxNSwgXCJUaGUgcm93IHdhcyBub3QgZm91bmQsIGUuZy4sIGluIGFuIHVwZGF0ZSBjYWxsXCJdLFxuICAvKipcbiAgICogRXJyb3IgaW5kaWNhdGluZyB0aGF0IGFuIGF1dG8taW5jcmVtZW50IHNlcXVlbmNlIGhhcyBvdmVyZmxvd2VkLlxuICAgKi9cbiAgQXV0b0luY092ZXJmbG93OiBbMTYsIFwiVGhlIGF1dG8taW5jcmVtZW50IHNlcXVlbmNlIG92ZXJmbG93ZWRcIl0sXG4gIFdvdWxkQmxvY2tUcmFuc2FjdGlvbjogW1xuICAgIDE3LFxuICAgIFwiQXR0ZW1wdGVkIGFzeW5jIG9yIGJsb2NraW5nIG9wIHdoaWxlIGhvbGRpbmcgb3BlbiBhIHRyYW5zYWN0aW9uXCJcbiAgXSxcbiAgVHJhbnNhY3Rpb25Ob3RBbm9ueW1vdXM6IFtcbiAgICAxOCxcbiAgICBcIk5vdCBpbiBhbiBhbm9ueW1vdXMgdHJhbnNhY3Rpb24uIENhbGxlZCBieSBhIHJlZHVjZXI/XCJcbiAgXSxcbiAgVHJhbnNhY3Rpb25Jc1JlYWRPbmx5OiBbXG4gICAgMTksXG4gICAgXCJBQkkgY2FsbCBjYW4gb25seSBiZSBtYWRlIHdoaWxlIHdpdGhpbiBhIG11dGFibGUgdHJhbnNhY3Rpb25cIlxuICBdLFxuICBUcmFuc2FjdGlvbklzTXV0OiBbXG4gICAgMjAsXG4gICAgXCJBQkkgY2FsbCBjYW4gb25seSBiZSBtYWRlIHdoaWxlIHdpdGhpbiBhIHJlYWQtb25seSB0cmFuc2FjdGlvblwiXG4gIF0sXG4gIEh0dHBFcnJvcjogWzIxLCBcIlRoZSBIVFRQIHJlcXVlc3QgZmFpbGVkXCJdXG59O1xuZnVuY3Rpb24gbWFwRW50cmllcyh4LCBmKSB7XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgT2JqZWN0LmVudHJpZXMoeCkubWFwKChbaywgdl0pID0+IFtrLCBmKGssIHYpXSlcbiAgKTtcbn1cbnZhciBlcnJvcnMgPSBPYmplY3QuZnJlZXplKFxuICBtYXBFbnRyaWVzKFxuICAgIGVycm9yRGF0YSxcbiAgICAobmFtZSwgW2NvZGUsIG1lc3NhZ2VdKSA9PiBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICBjbGFzcyBleHRlbmRzIFNwYWNldGltZUhvc3RFcnJvciB7XG4gICAgICAgIHN0YXRpYyBDT0RFID0gY29kZTtcbiAgICAgICAgc3RhdGljIE1FU1NBR0UgPSBtZXNzYWdlO1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICBzdXBlcihjb2RlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwibmFtZVwiLFxuICAgICAgeyB2YWx1ZTogbmFtZSwgd3JpdGFibGU6IGZhbHNlIH1cbiAgICApXG4gIClcbik7XG52YXIgZXJyb3JQcm90b3lwZXMgPSBuZXcgU2V0KE9iamVjdC52YWx1ZXMoZXJyb3JzKS5tYXAoKGNscykgPT4gY2xzLnByb3RvdHlwZSkpO1xudmFyIGVycm5vVG9DbGFzcyA9IG5ldyBNYXAoXG4gIE9iamVjdC52YWx1ZXMoZXJyb3JzKS5tYXAoKGNscykgPT4gW2Nscy5DT0RFLCBjbHNdKVxuKTtcblxuLy8gc3JjL3NlcnZlci9wb2x5ZmlsbHMudHNcbl9fdG9FU00ocmVxdWlyZV90ZXh0X21pbigpKTtcblxuLy8gc3JjL2xpYi9hdXRvZ2VuL3N1bV90eXBlX3ZhcmlhbnRfdHlwZS50c1xudmFyIHN1bV90eXBlX3ZhcmlhbnRfdHlwZV9kZWZhdWx0ID0gdC5vYmplY3QoXCJTdW1UeXBlVmFyaWFudFwiLCB7XG4gIG5hbWU6IHQub3B0aW9uKHQuc3RyaW5nKCkpLFxuICBnZXQgYWxnZWJyYWljVHlwZSgpIHtcbiAgICByZXR1cm4gYWxnZWJyYWljX3R5cGVfdHlwZV9kZWZhdWx0O1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9hdXRvZ2VuL3N1bV90eXBlX3R5cGUudHNcbnZhciBzdW1fdHlwZV90eXBlX2RlZmF1bHQgPSB0Lm9iamVjdChcIlN1bVR5cGVcIiwge1xuICBnZXQgdmFyaWFudHMoKSB7XG4gICAgcmV0dXJuIHQuYXJyYXkoc3VtX3R5cGVfdmFyaWFudF90eXBlX2RlZmF1bHQpO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9hdXRvZ2VuL3Byb2R1Y3RfdHlwZV9lbGVtZW50X3R5cGUudHNcbnZhciBwcm9kdWN0X3R5cGVfZWxlbWVudF90eXBlX2RlZmF1bHQgPSB0Lm9iamVjdChcIlByb2R1Y3RUeXBlRWxlbWVudFwiLCB7XG4gIG5hbWU6IHQub3B0aW9uKHQuc3RyaW5nKCkpLFxuICBnZXQgYWxnZWJyYWljVHlwZSgpIHtcbiAgICByZXR1cm4gYWxnZWJyYWljX3R5cGVfdHlwZV9kZWZhdWx0O1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9hdXRvZ2VuL3Byb2R1Y3RfdHlwZV90eXBlLnRzXG52YXIgcHJvZHVjdF90eXBlX3R5cGVfZGVmYXVsdCA9IHQub2JqZWN0KFwiUHJvZHVjdFR5cGVcIiwge1xuICBnZXQgZWxlbWVudHMoKSB7XG4gICAgcmV0dXJuIHQuYXJyYXkocHJvZHVjdF90eXBlX2VsZW1lbnRfdHlwZV9kZWZhdWx0KTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvYXV0b2dlbi9hbGdlYnJhaWNfdHlwZV90eXBlLnRzXG52YXIgQWxnZWJyYWljVHlwZTIgPSB0LmVudW0oXCJBbGdlYnJhaWNUeXBlXCIsIHtcbiAgUmVmOiB0LnUzMigpLFxuICBnZXQgU3VtKCkge1xuICAgIHJldHVybiBzdW1fdHlwZV90eXBlX2RlZmF1bHQ7XG4gIH0sXG4gIGdldCBQcm9kdWN0KCkge1xuICAgIHJldHVybiBwcm9kdWN0X3R5cGVfdHlwZV9kZWZhdWx0O1xuICB9LFxuICBnZXQgQXJyYXkoKSB7XG4gICAgcmV0dXJuIEFsZ2VicmFpY1R5cGUyO1xuICB9LFxuICBTdHJpbmc6IHQudW5pdCgpLFxuICBCb29sOiB0LnVuaXQoKSxcbiAgSTg6IHQudW5pdCgpLFxuICBVODogdC51bml0KCksXG4gIEkxNjogdC51bml0KCksXG4gIFUxNjogdC51bml0KCksXG4gIEkzMjogdC51bml0KCksXG4gIFUzMjogdC51bml0KCksXG4gIEk2NDogdC51bml0KCksXG4gIFU2NDogdC51bml0KCksXG4gIEkxMjg6IHQudW5pdCgpLFxuICBVMTI4OiB0LnVuaXQoKSxcbiAgSTI1NjogdC51bml0KCksXG4gIFUyNTY6IHQudW5pdCgpLFxuICBGMzI6IHQudW5pdCgpLFxuICBGNjQ6IHQudW5pdCgpXG59KTtcbnZhciBhbGdlYnJhaWNfdHlwZV90eXBlX2RlZmF1bHQgPSBBbGdlYnJhaWNUeXBlMjtcblxuLy8gc3JjL2xpYi9hdXRvZ2VuL3R5cGVzcGFjZV90eXBlLnRzXG52YXIgdHlwZXNwYWNlX3R5cGVfZGVmYXVsdCA9IHQub2JqZWN0KFwiVHlwZXNwYWNlXCIsIHtcbiAgZ2V0IHR5cGVzKCkge1xuICAgIHJldHVybiB0LmFycmF5KGFsZ2VicmFpY190eXBlX3R5cGVfZGVmYXVsdCk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL2F1dG9nZW4vcmF3X2NvbHVtbl9kZWZfdl84X3R5cGUudHNcbnZhciByYXdfY29sdW1uX2RlZl92XzhfdHlwZV9kZWZhdWx0ID0gdC5vYmplY3QoXCJSYXdDb2x1bW5EZWZWOFwiLCB7XG4gIGNvbE5hbWU6IHQuc3RyaW5nKCksXG4gIGdldCBjb2xUeXBlKCkge1xuICAgIHJldHVybiBhbGdlYnJhaWNfdHlwZV90eXBlX2RlZmF1bHQ7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL2F1dG9nZW4vaW5kZXhfdHlwZV90eXBlLnRzXG52YXIgSW5kZXhUeXBlID0gdC5lbnVtKFwiSW5kZXhUeXBlXCIsIHtcbiAgQlRyZWU6IHQudW5pdCgpLFxuICBIYXNoOiB0LnVuaXQoKVxufSk7XG52YXIgaW5kZXhfdHlwZV90eXBlX2RlZmF1bHQgPSBJbmRleFR5cGU7XG5cbi8vIHNyYy9saWIvYXV0b2dlbi9yYXdfaW5kZXhfZGVmX3ZfOF90eXBlLnRzXG52YXIgcmF3X2luZGV4X2RlZl92XzhfdHlwZV9kZWZhdWx0ID0gdC5vYmplY3QoXCJSYXdJbmRleERlZlY4XCIsIHtcbiAgaW5kZXhOYW1lOiB0LnN0cmluZygpLFxuICBpc1VuaXF1ZTogdC5ib29sKCksXG4gIGdldCBpbmRleFR5cGUoKSB7XG4gICAgcmV0dXJuIGluZGV4X3R5cGVfdHlwZV9kZWZhdWx0O1xuICB9LFxuICBjb2x1bW5zOiB0LmFycmF5KHQudTE2KCkpXG59KTtcblxuLy8gc3JjL2xpYi9hdXRvZ2VuL3Jhd19jb25zdHJhaW50X2RlZl92XzhfdHlwZS50c1xudmFyIHJhd19jb25zdHJhaW50X2RlZl92XzhfdHlwZV9kZWZhdWx0ID0gdC5vYmplY3QoXCJSYXdDb25zdHJhaW50RGVmVjhcIiwge1xuICBjb25zdHJhaW50TmFtZTogdC5zdHJpbmcoKSxcbiAgY29uc3RyYWludHM6IHQudTgoKSxcbiAgY29sdW1uczogdC5hcnJheSh0LnUxNigpKVxufSk7XG5cbi8vIHNyYy9saWIvYXV0b2dlbi9yYXdfc2VxdWVuY2VfZGVmX3ZfOF90eXBlLnRzXG52YXIgcmF3X3NlcXVlbmNlX2RlZl92XzhfdHlwZV9kZWZhdWx0ID0gdC5vYmplY3QoXCJSYXdTZXF1ZW5jZURlZlY4XCIsIHtcbiAgc2VxdWVuY2VOYW1lOiB0LnN0cmluZygpLFxuICBjb2xQb3M6IHQudTE2KCksXG4gIGluY3JlbWVudDogdC5pMTI4KCksXG4gIHN0YXJ0OiB0Lm9wdGlvbih0LmkxMjgoKSksXG4gIG1pblZhbHVlOiB0Lm9wdGlvbih0LmkxMjgoKSksXG4gIG1heFZhbHVlOiB0Lm9wdGlvbih0LmkxMjgoKSksXG4gIGFsbG9jYXRlZDogdC5pMTI4KClcbn0pO1xuXG4vLyBzcmMvbGliL2F1dG9nZW4vcmF3X3RhYmxlX2RlZl92XzhfdHlwZS50c1xudmFyIHJhd190YWJsZV9kZWZfdl84X3R5cGVfZGVmYXVsdCA9IHQub2JqZWN0KFwiUmF3VGFibGVEZWZWOFwiLCB7XG4gIHRhYmxlTmFtZTogdC5zdHJpbmcoKSxcbiAgZ2V0IGNvbHVtbnMoKSB7XG4gICAgcmV0dXJuIHQuYXJyYXkocmF3X2NvbHVtbl9kZWZfdl84X3R5cGVfZGVmYXVsdCk7XG4gIH0sXG4gIGdldCBpbmRleGVzKCkge1xuICAgIHJldHVybiB0LmFycmF5KHJhd19pbmRleF9kZWZfdl84X3R5cGVfZGVmYXVsdCk7XG4gIH0sXG4gIGdldCBjb25zdHJhaW50cygpIHtcbiAgICByZXR1cm4gdC5hcnJheShyYXdfY29uc3RyYWludF9kZWZfdl84X3R5cGVfZGVmYXVsdCk7XG4gIH0sXG4gIGdldCBzZXF1ZW5jZXMoKSB7XG4gICAgcmV0dXJuIHQuYXJyYXkocmF3X3NlcXVlbmNlX2RlZl92XzhfdHlwZV9kZWZhdWx0KTtcbiAgfSxcbiAgdGFibGVUeXBlOiB0LnN0cmluZygpLFxuICB0YWJsZUFjY2VzczogdC5zdHJpbmcoKSxcbiAgc2NoZWR1bGVkOiB0Lm9wdGlvbih0LnN0cmluZygpKVxufSk7XG5cbi8vIHNyYy9saWIvYXV0b2dlbi90YWJsZV9kZXNjX3R5cGUudHNcbnZhciB0YWJsZV9kZXNjX3R5cGVfZGVmYXVsdCA9IHQub2JqZWN0KFwiVGFibGVEZXNjXCIsIHtcbiAgZ2V0IHNjaGVtYSgpIHtcbiAgICByZXR1cm4gcmF3X3RhYmxlX2RlZl92XzhfdHlwZV9kZWZhdWx0O1xuICB9LFxuICBkYXRhOiB0LnUzMigpXG59KTtcblxuLy8gc3JjL2xpYi9hdXRvZ2VuL3JlZHVjZXJfZGVmX3R5cGUudHNcbnZhciByZWR1Y2VyX2RlZl90eXBlX2RlZmF1bHQgPSB0Lm9iamVjdChcIlJlZHVjZXJEZWZcIiwge1xuICBuYW1lOiB0LnN0cmluZygpLFxuICBnZXQgYXJncygpIHtcbiAgICByZXR1cm4gdC5hcnJheShwcm9kdWN0X3R5cGVfZWxlbWVudF90eXBlX2RlZmF1bHQpO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9hdXRvZ2VuL3R5cGVfYWxpYXNfdHlwZS50c1xudmFyIHR5cGVfYWxpYXNfdHlwZV9kZWZhdWx0ID0gdC5vYmplY3QoXCJUeXBlQWxpYXNcIiwge1xuICBuYW1lOiB0LnN0cmluZygpLFxuICB0eTogdC51MzIoKVxufSk7XG5cbi8vIHNyYy9saWIvYXV0b2dlbi9taXNjX21vZHVsZV9leHBvcnRfdHlwZS50c1xudmFyIE1pc2NNb2R1bGVFeHBvcnQgPSB0LmVudW0oXCJNaXNjTW9kdWxlRXhwb3J0XCIsIHtcbiAgZ2V0IFR5cGVBbGlhcygpIHtcbiAgICByZXR1cm4gdHlwZV9hbGlhc190eXBlX2RlZmF1bHQ7XG4gIH1cbn0pO1xudmFyIG1pc2NfbW9kdWxlX2V4cG9ydF90eXBlX2RlZmF1bHQgPSBNaXNjTW9kdWxlRXhwb3J0O1xuXG4vLyBzcmMvbGliL2F1dG9nZW4vcmF3X21vZHVsZV9kZWZfdl84X3R5cGUudHNcbnZhciByYXdfbW9kdWxlX2RlZl92XzhfdHlwZV9kZWZhdWx0ID0gdC5vYmplY3QoXCJSYXdNb2R1bGVEZWZWOFwiLCB7XG4gIGdldCB0eXBlc3BhY2UoKSB7XG4gICAgcmV0dXJuIHR5cGVzcGFjZV90eXBlX2RlZmF1bHQ7XG4gIH0sXG4gIGdldCB0YWJsZXMoKSB7XG4gICAgcmV0dXJuIHQuYXJyYXkodGFibGVfZGVzY190eXBlX2RlZmF1bHQpO1xuICB9LFxuICBnZXQgcmVkdWNlcnMoKSB7XG4gICAgcmV0dXJuIHQuYXJyYXkocmVkdWNlcl9kZWZfdHlwZV9kZWZhdWx0KTtcbiAgfSxcbiAgZ2V0IG1pc2NFeHBvcnRzKCkge1xuICAgIHJldHVybiB0LmFycmF5KG1pc2NfbW9kdWxlX2V4cG9ydF90eXBlX2RlZmF1bHQpO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9hdXRvZ2VuL3Jhd19pbmRleF9kZWZfdl85X3R5cGUudHNcbnZhciByYXdfaW5kZXhfZGVmX3ZfOV90eXBlX2RlZmF1bHQgPSB0Lm9iamVjdChcIlJhd0luZGV4RGVmVjlcIiwge1xuICBuYW1lOiB0Lm9wdGlvbih0LnN0cmluZygpKSxcbiAgYWNjZXNzb3JOYW1lOiB0Lm9wdGlvbih0LnN0cmluZygpKSxcbiAgZ2V0IGFsZ29yaXRobSgpIHtcbiAgICByZXR1cm4gcmF3X2luZGV4X2FsZ29yaXRobV90eXBlX2RlZmF1bHQ7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL2F1dG9nZW4vcmF3X3VuaXF1ZV9jb25zdHJhaW50X2RhdGFfdl85X3R5cGUudHNcbnZhciByYXdfdW5pcXVlX2NvbnN0cmFpbnRfZGF0YV92XzlfdHlwZV9kZWZhdWx0ID0gdC5vYmplY3QoXCJSYXdVbmlxdWVDb25zdHJhaW50RGF0YVY5XCIsIHtcbiAgY29sdW1uczogdC5hcnJheSh0LnUxNigpKVxufSk7XG5cbi8vIHNyYy9saWIvYXV0b2dlbi9yYXdfY29uc3RyYWludF9kYXRhX3ZfOV90eXBlLnRzXG52YXIgUmF3Q29uc3RyYWludERhdGFWOSA9IHQuZW51bShcIlJhd0NvbnN0cmFpbnREYXRhVjlcIiwge1xuICBnZXQgVW5pcXVlKCkge1xuICAgIHJldHVybiByYXdfdW5pcXVlX2NvbnN0cmFpbnRfZGF0YV92XzlfdHlwZV9kZWZhdWx0O1xuICB9XG59KTtcbnZhciByYXdfY29uc3RyYWludF9kYXRhX3ZfOV90eXBlX2RlZmF1bHQgPSBSYXdDb25zdHJhaW50RGF0YVY5O1xuXG4vLyBzcmMvbGliL2F1dG9nZW4vcmF3X2NvbnN0cmFpbnRfZGVmX3ZfOV90eXBlLnRzXG52YXIgcmF3X2NvbnN0cmFpbnRfZGVmX3ZfOV90eXBlX2RlZmF1bHQgPSB0Lm9iamVjdChcIlJhd0NvbnN0cmFpbnREZWZWOVwiLCB7XG4gIG5hbWU6IHQub3B0aW9uKHQuc3RyaW5nKCkpLFxuICBnZXQgZGF0YSgpIHtcbiAgICByZXR1cm4gcmF3X2NvbnN0cmFpbnRfZGF0YV92XzlfdHlwZV9kZWZhdWx0O1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9hdXRvZ2VuL3Jhd19zZXF1ZW5jZV9kZWZfdl85X3R5cGUudHNcbnZhciByYXdfc2VxdWVuY2VfZGVmX3ZfOV90eXBlX2RlZmF1bHQgPSB0Lm9iamVjdChcIlJhd1NlcXVlbmNlRGVmVjlcIiwge1xuICBuYW1lOiB0Lm9wdGlvbih0LnN0cmluZygpKSxcbiAgY29sdW1uOiB0LnUxNigpLFxuICBzdGFydDogdC5vcHRpb24odC5pMTI4KCkpLFxuICBtaW5WYWx1ZTogdC5vcHRpb24odC5pMTI4KCkpLFxuICBtYXhWYWx1ZTogdC5vcHRpb24odC5pMTI4KCkpLFxuICBpbmNyZW1lbnQ6IHQuaTEyOCgpXG59KTtcblxuLy8gc3JjL2xpYi9hdXRvZ2VuL3Jhd19zY2hlZHVsZV9kZWZfdl85X3R5cGUudHNcbnZhciByYXdfc2NoZWR1bGVfZGVmX3ZfOV90eXBlX2RlZmF1bHQgPSB0Lm9iamVjdChcIlJhd1NjaGVkdWxlRGVmVjlcIiwge1xuICBuYW1lOiB0Lm9wdGlvbih0LnN0cmluZygpKSxcbiAgcmVkdWNlck5hbWU6IHQuc3RyaW5nKCksXG4gIHNjaGVkdWxlZEF0Q29sdW1uOiB0LnUxNigpXG59KTtcblxuLy8gc3JjL2xpYi9hdXRvZ2VuL3RhYmxlX3R5cGVfdHlwZS50c1xudmFyIFRhYmxlVHlwZSA9IHQuZW51bShcIlRhYmxlVHlwZVwiLCB7XG4gIFN5c3RlbTogdC51bml0KCksXG4gIFVzZXI6IHQudW5pdCgpXG59KTtcbnZhciB0YWJsZV90eXBlX3R5cGVfZGVmYXVsdCA9IFRhYmxlVHlwZTtcblxuLy8gc3JjL2xpYi9hdXRvZ2VuL3RhYmxlX2FjY2Vzc190eXBlLnRzXG52YXIgVGFibGVBY2Nlc3MgPSB0LmVudW0oXCJUYWJsZUFjY2Vzc1wiLCB7XG4gIFB1YmxpYzogdC51bml0KCksXG4gIFByaXZhdGU6IHQudW5pdCgpXG59KTtcbnZhciB0YWJsZV9hY2Nlc3NfdHlwZV9kZWZhdWx0ID0gVGFibGVBY2Nlc3M7XG5cbi8vIHNyYy9saWIvYXV0b2dlbi9yYXdfdGFibGVfZGVmX3ZfOV90eXBlLnRzXG52YXIgcmF3X3RhYmxlX2RlZl92XzlfdHlwZV9kZWZhdWx0ID0gdC5vYmplY3QoXCJSYXdUYWJsZURlZlY5XCIsIHtcbiAgbmFtZTogdC5zdHJpbmcoKSxcbiAgcHJvZHVjdFR5cGVSZWY6IHQudTMyKCksXG4gIHByaW1hcnlLZXk6IHQuYXJyYXkodC51MTYoKSksXG4gIGdldCBpbmRleGVzKCkge1xuICAgIHJldHVybiB0LmFycmF5KHJhd19pbmRleF9kZWZfdl85X3R5cGVfZGVmYXVsdCk7XG4gIH0sXG4gIGdldCBjb25zdHJhaW50cygpIHtcbiAgICByZXR1cm4gdC5hcnJheShyYXdfY29uc3RyYWludF9kZWZfdl85X3R5cGVfZGVmYXVsdCk7XG4gIH0sXG4gIGdldCBzZXF1ZW5jZXMoKSB7XG4gICAgcmV0dXJuIHQuYXJyYXkocmF3X3NlcXVlbmNlX2RlZl92XzlfdHlwZV9kZWZhdWx0KTtcbiAgfSxcbiAgZ2V0IHNjaGVkdWxlKCkge1xuICAgIHJldHVybiB0Lm9wdGlvbihyYXdfc2NoZWR1bGVfZGVmX3ZfOV90eXBlX2RlZmF1bHQpO1xuICB9LFxuICBnZXQgdGFibGVUeXBlKCkge1xuICAgIHJldHVybiB0YWJsZV90eXBlX3R5cGVfZGVmYXVsdDtcbiAgfSxcbiAgZ2V0IHRhYmxlQWNjZXNzKCkge1xuICAgIHJldHVybiB0YWJsZV9hY2Nlc3NfdHlwZV9kZWZhdWx0O1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9hdXRvZ2VuL3Jhd19yZWR1Y2VyX2RlZl92XzlfdHlwZS50c1xudmFyIHJhd19yZWR1Y2VyX2RlZl92XzlfdHlwZV9kZWZhdWx0ID0gdC5vYmplY3QoXCJSYXdSZWR1Y2VyRGVmVjlcIiwge1xuICBuYW1lOiB0LnN0cmluZygpLFxuICBnZXQgcGFyYW1zKCkge1xuICAgIHJldHVybiBwcm9kdWN0X3R5cGVfdHlwZV9kZWZhdWx0O1xuICB9LFxuICBnZXQgbGlmZWN5Y2xlKCkge1xuICAgIHJldHVybiB0Lm9wdGlvbihsaWZlY3ljbGVfdHlwZV9kZWZhdWx0KTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvYXV0b2dlbi9yYXdfc2NvcGVkX3R5cGVfbmFtZV92XzlfdHlwZS50c1xudmFyIHJhd19zY29wZWRfdHlwZV9uYW1lX3ZfOV90eXBlX2RlZmF1bHQgPSB0Lm9iamVjdChcIlJhd1Njb3BlZFR5cGVOYW1lVjlcIiwge1xuICBzY29wZTogdC5hcnJheSh0LnN0cmluZygpKSxcbiAgbmFtZTogdC5zdHJpbmcoKVxufSk7XG5cbi8vIHNyYy9saWIvYXV0b2dlbi9yYXdfdHlwZV9kZWZfdl85X3R5cGUudHNcbnZhciByYXdfdHlwZV9kZWZfdl85X3R5cGVfZGVmYXVsdCA9IHQub2JqZWN0KFwiUmF3VHlwZURlZlY5XCIsIHtcbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIHJhd19zY29wZWRfdHlwZV9uYW1lX3ZfOV90eXBlX2RlZmF1bHQ7XG4gIH0sXG4gIHR5OiB0LnUzMigpLFxuICBjdXN0b21PcmRlcmluZzogdC5ib29sKClcbn0pO1xuXG4vLyBzcmMvbGliL2F1dG9nZW4vcmF3X2NvbHVtbl9kZWZhdWx0X3ZhbHVlX3ZfOV90eXBlLnRzXG52YXIgcmF3X2NvbHVtbl9kZWZhdWx0X3ZhbHVlX3ZfOV90eXBlX2RlZmF1bHQgPSB0Lm9iamVjdChcIlJhd0NvbHVtbkRlZmF1bHRWYWx1ZVY5XCIsIHtcbiAgdGFibGU6IHQuc3RyaW5nKCksXG4gIGNvbElkOiB0LnUxNigpLFxuICB2YWx1ZTogdC5ieXRlQXJyYXkoKVxufSk7XG5cbi8vIHNyYy9saWIvYXV0b2dlbi9yYXdfcHJvY2VkdXJlX2RlZl92XzlfdHlwZS50c1xudmFyIHJhd19wcm9jZWR1cmVfZGVmX3ZfOV90eXBlX2RlZmF1bHQgPSB0Lm9iamVjdChcIlJhd1Byb2NlZHVyZURlZlY5XCIsIHtcbiAgbmFtZTogdC5zdHJpbmcoKSxcbiAgZ2V0IHBhcmFtcygpIHtcbiAgICByZXR1cm4gcHJvZHVjdF90eXBlX3R5cGVfZGVmYXVsdDtcbiAgfSxcbiAgZ2V0IHJldHVyblR5cGUoKSB7XG4gICAgcmV0dXJuIGFsZ2VicmFpY190eXBlX3R5cGVfZGVmYXVsdDtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvYXV0b2dlbi9yYXdfdmlld19kZWZfdl85X3R5cGUudHNcbnZhciByYXdfdmlld19kZWZfdl85X3R5cGVfZGVmYXVsdCA9IHQub2JqZWN0KFwiUmF3Vmlld0RlZlY5XCIsIHtcbiAgbmFtZTogdC5zdHJpbmcoKSxcbiAgaW5kZXg6IHQudTMyKCksXG4gIGlzUHVibGljOiB0LmJvb2woKSxcbiAgaXNBbm9ueW1vdXM6IHQuYm9vbCgpLFxuICBnZXQgcGFyYW1zKCkge1xuICAgIHJldHVybiBwcm9kdWN0X3R5cGVfdHlwZV9kZWZhdWx0O1xuICB9LFxuICBnZXQgcmV0dXJuVHlwZSgpIHtcbiAgICByZXR1cm4gYWxnZWJyYWljX3R5cGVfdHlwZV9kZWZhdWx0O1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9hdXRvZ2VuL3Jhd19taXNjX21vZHVsZV9leHBvcnRfdl85X3R5cGUudHNcbnZhciBSYXdNaXNjTW9kdWxlRXhwb3J0VjkgPSB0LmVudW0oXCJSYXdNaXNjTW9kdWxlRXhwb3J0VjlcIiwge1xuICBnZXQgQ29sdW1uRGVmYXVsdFZhbHVlKCkge1xuICAgIHJldHVybiByYXdfY29sdW1uX2RlZmF1bHRfdmFsdWVfdl85X3R5cGVfZGVmYXVsdDtcbiAgfSxcbiAgZ2V0IFByb2NlZHVyZSgpIHtcbiAgICByZXR1cm4gcmF3X3Byb2NlZHVyZV9kZWZfdl85X3R5cGVfZGVmYXVsdDtcbiAgfSxcbiAgZ2V0IFZpZXcoKSB7XG4gICAgcmV0dXJuIHJhd192aWV3X2RlZl92XzlfdHlwZV9kZWZhdWx0O1xuICB9XG59KTtcbnZhciByYXdfbWlzY19tb2R1bGVfZXhwb3J0X3ZfOV90eXBlX2RlZmF1bHQgPSBSYXdNaXNjTW9kdWxlRXhwb3J0Vjk7XG5cbi8vIHNyYy9saWIvYXV0b2dlbi9yYXdfcm93X2xldmVsX3NlY3VyaXR5X2RlZl92XzlfdHlwZS50c1xudmFyIHJhd19yb3dfbGV2ZWxfc2VjdXJpdHlfZGVmX3ZfOV90eXBlX2RlZmF1bHQgPSB0Lm9iamVjdChcIlJhd1Jvd0xldmVsU2VjdXJpdHlEZWZWOVwiLCB7XG4gIHNxbDogdC5zdHJpbmcoKVxufSk7XG5cbi8vIHNyYy9saWIvYXV0b2dlbi9yYXdfbW9kdWxlX2RlZl92XzlfdHlwZS50c1xudmFyIHJhd19tb2R1bGVfZGVmX3ZfOV90eXBlX2RlZmF1bHQgPSB0Lm9iamVjdChcIlJhd01vZHVsZURlZlY5XCIsIHtcbiAgZ2V0IHR5cGVzcGFjZSgpIHtcbiAgICByZXR1cm4gdHlwZXNwYWNlX3R5cGVfZGVmYXVsdDtcbiAgfSxcbiAgZ2V0IHRhYmxlcygpIHtcbiAgICByZXR1cm4gdC5hcnJheShyYXdfdGFibGVfZGVmX3ZfOV90eXBlX2RlZmF1bHQpO1xuICB9LFxuICBnZXQgcmVkdWNlcnMoKSB7XG4gICAgcmV0dXJuIHQuYXJyYXkocmF3X3JlZHVjZXJfZGVmX3ZfOV90eXBlX2RlZmF1bHQpO1xuICB9LFxuICBnZXQgdHlwZXMoKSB7XG4gICAgcmV0dXJuIHQuYXJyYXkocmF3X3R5cGVfZGVmX3ZfOV90eXBlX2RlZmF1bHQpO1xuICB9LFxuICBnZXQgbWlzY0V4cG9ydHMoKSB7XG4gICAgcmV0dXJuIHQuYXJyYXkocmF3X21pc2NfbW9kdWxlX2V4cG9ydF92XzlfdHlwZV9kZWZhdWx0KTtcbiAgfSxcbiAgZ2V0IHJvd0xldmVsU2VjdXJpdHkoKSB7XG4gICAgcmV0dXJuIHQuYXJyYXkocmF3X3Jvd19sZXZlbF9zZWN1cml0eV9kZWZfdl85X3R5cGVfZGVmYXVsdCk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL2F1dG9nZW4vcmF3X21vZHVsZV9kZWZfdHlwZS50c1xudmFyIFJhd01vZHVsZURlZiA9IHQuZW51bShcIlJhd01vZHVsZURlZlwiLCB7XG4gIGdldCBWOEJhY2tDb21wYXQoKSB7XG4gICAgcmV0dXJuIHJhd19tb2R1bGVfZGVmX3ZfOF90eXBlX2RlZmF1bHQ7XG4gIH0sXG4gIGdldCBWOSgpIHtcbiAgICByZXR1cm4gcmF3X21vZHVsZV9kZWZfdl85X3R5cGVfZGVmYXVsdDtcbiAgfVxufSk7XG52YXIgcmF3X21vZHVsZV9kZWZfdHlwZV9kZWZhdWx0ID0gUmF3TW9kdWxlRGVmO1xuXG4vLyBzcmMvc2VydmVyL3JhbmdlLnRzXG52YXIgUmFuZ2UgPSBjbGFzcyB7XG4gICNmcm9tO1xuICAjdG87XG4gIGNvbnN0cnVjdG9yKGZyb20sIHRvKSB7XG4gICAgdGhpcy4jZnJvbSA9IGZyb20gPz8geyB0YWc6IFwidW5ib3VuZGVkXCIgfTtcbiAgICB0aGlzLiN0byA9IHRvID8/IHsgdGFnOiBcInVuYm91bmRlZFwiIH07XG4gIH1cbiAgZ2V0IGZyb20oKSB7XG4gICAgcmV0dXJuIHRoaXMuI2Zyb207XG4gIH1cbiAgZ2V0IHRvKCkge1xuICAgIHJldHVybiB0aGlzLiN0bztcbiAgfVxufTtcblxuLy8gc3JjL3NlcnZlci9odHRwX2ludGVybmFsLnRzXG52YXIgaW1wb3J0X3N0YXR1c2VzID0gX190b0VTTShyZXF1aXJlX3N0YXR1c2VzKCkpO1xuXG4vLyBzcmMvbGliL2F1dG9nZW4vaHR0cF9oZWFkZXJfcGFpcl90eXBlLnRzXG52YXIgaHR0cF9oZWFkZXJfcGFpcl90eXBlX2RlZmF1bHQgPSB0Lm9iamVjdChcIkh0dHBIZWFkZXJQYWlyXCIsIHtcbiAgbmFtZTogdC5zdHJpbmcoKSxcbiAgdmFsdWU6IHQuYnl0ZUFycmF5KClcbn0pO1xuXG4vLyBzcmMvbGliL2F1dG9nZW4vaHR0cF9oZWFkZXJzX3R5cGUudHNcbnZhciBodHRwX2hlYWRlcnNfdHlwZV9kZWZhdWx0ID0gdC5vYmplY3QoXCJIdHRwSGVhZGVyc1wiLCB7XG4gIGdldCBlbnRyaWVzKCkge1xuICAgIHJldHVybiB0LmFycmF5KGh0dHBfaGVhZGVyX3BhaXJfdHlwZV9kZWZhdWx0KTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvYXV0b2dlbi9odHRwX21ldGhvZF90eXBlLnRzXG52YXIgSHR0cE1ldGhvZCA9IHQuZW51bShcIkh0dHBNZXRob2RcIiwge1xuICBHZXQ6IHQudW5pdCgpLFxuICBIZWFkOiB0LnVuaXQoKSxcbiAgUG9zdDogdC51bml0KCksXG4gIFB1dDogdC51bml0KCksXG4gIERlbGV0ZTogdC51bml0KCksXG4gIENvbm5lY3Q6IHQudW5pdCgpLFxuICBPcHRpb25zOiB0LnVuaXQoKSxcbiAgVHJhY2U6IHQudW5pdCgpLFxuICBQYXRjaDogdC51bml0KCksXG4gIEV4dGVuc2lvbjogdC5zdHJpbmcoKVxufSk7XG52YXIgaHR0cF9tZXRob2RfdHlwZV9kZWZhdWx0ID0gSHR0cE1ldGhvZDtcblxuLy8gc3JjL2xpYi9hdXRvZ2VuL2h0dHBfdmVyc2lvbl90eXBlLnRzXG52YXIgSHR0cFZlcnNpb24gPSB0LmVudW0oXCJIdHRwVmVyc2lvblwiLCB7XG4gIEh0dHAwOTogdC51bml0KCksXG4gIEh0dHAxMDogdC51bml0KCksXG4gIEh0dHAxMTogdC51bml0KCksXG4gIEh0dHAyOiB0LnVuaXQoKSxcbiAgSHR0cDM6IHQudW5pdCgpXG59KTtcbnZhciBodHRwX3ZlcnNpb25fdHlwZV9kZWZhdWx0ID0gSHR0cFZlcnNpb247XG5cbi8vIHNyYy9saWIvYXV0b2dlbi9odHRwX3JlcXVlc3RfdHlwZS50c1xudmFyIGh0dHBfcmVxdWVzdF90eXBlX2RlZmF1bHQgPSB0Lm9iamVjdChcIkh0dHBSZXF1ZXN0XCIsIHtcbiAgZ2V0IG1ldGhvZCgpIHtcbiAgICByZXR1cm4gaHR0cF9tZXRob2RfdHlwZV9kZWZhdWx0O1xuICB9LFxuICBnZXQgaGVhZGVycygpIHtcbiAgICByZXR1cm4gaHR0cF9oZWFkZXJzX3R5cGVfZGVmYXVsdDtcbiAgfSxcbiAgdGltZW91dDogdC5vcHRpb24odC50aW1lRHVyYXRpb24oKSksXG4gIHVyaTogdC5zdHJpbmcoKSxcbiAgZ2V0IHZlcnNpb24oKSB7XG4gICAgcmV0dXJuIGh0dHBfdmVyc2lvbl90eXBlX2RlZmF1bHQ7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL2F1dG9nZW4vaHR0cF9yZXNwb25zZV90eXBlLnRzXG52YXIgaHR0cF9yZXNwb25zZV90eXBlX2RlZmF1bHQgPSB0Lm9iamVjdChcIkh0dHBSZXNwb25zZVwiLCB7XG4gIGdldCBoZWFkZXJzKCkge1xuICAgIHJldHVybiBodHRwX2hlYWRlcnNfdHlwZV9kZWZhdWx0O1xuICB9LFxuICBnZXQgdmVyc2lvbigpIHtcbiAgICByZXR1cm4gaHR0cF92ZXJzaW9uX3R5cGVfZGVmYXVsdDtcbiAgfSxcbiAgY29kZTogdC51MTYoKVxufSk7XG5cbi8vIHNyYy9zZXJ2ZXIvaHR0cF9pbnRlcm5hbC50c1xudmFyIHsgZnJlZXplIH0gPSBPYmplY3Q7XG52YXIgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbnZhciB0ZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcihcbiAgXCJ1dGYtOFwiXG4gIC8qIHsgZmF0YWw6IHRydWUgfSAqL1xuKTtcbnZhciBtYWtlUmVzcG9uc2UgPSBTeW1ib2woXCJtYWtlUmVzcG9uc2VcIik7XG52YXIgU3luY1Jlc3BvbnNlID0gY2xhc3MgX1N5bmNSZXNwb25zZSB7XG4gICNib2R5O1xuICAjaW5uZXI7XG4gIGNvbnN0cnVjdG9yKGJvZHksIGluaXQyKSB7XG4gICAgaWYgKGJvZHkgPT0gbnVsbCkge1xuICAgICAgdGhpcy4jYm9keSA9IG51bGw7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYm9keSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhpcy4jYm9keSA9IGJvZHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI2JvZHkgPSBuZXcgVWludDhBcnJheShib2R5KS5idWZmZXI7XG4gICAgfVxuICAgIHRoaXMuI2lubmVyID0ge1xuICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnMoaW5pdDI/LmhlYWRlcnMpLFxuICAgICAgc3RhdHVzOiBpbml0Mj8uc3RhdHVzID8/IDIwMCxcbiAgICAgIHN0YXR1c1RleHQ6IGluaXQyPy5zdGF0dXNUZXh0ID8/IFwiXCIsXG4gICAgICB0eXBlOiBcImRlZmF1bHRcIixcbiAgICAgIHVybDogbnVsbCxcbiAgICAgIGFib3J0ZWQ6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgW21ha2VSZXNwb25zZV0oYm9keSwgaW5uZXIpIHtcbiAgICBjb25zdCBtZSA9IG5ldyBfU3luY1Jlc3BvbnNlKGJvZHkpO1xuICAgIG1lLiNpbm5lciA9IGlubmVyO1xuICAgIHJldHVybiBtZTtcbiAgfVxuICBnZXQgaGVhZGVycygpIHtcbiAgICByZXR1cm4gdGhpcy4jaW5uZXIuaGVhZGVycztcbiAgfVxuICBnZXQgc3RhdHVzKCkge1xuICAgIHJldHVybiB0aGlzLiNpbm5lci5zdGF0dXM7XG4gIH1cbiAgZ2V0IHN0YXR1c1RleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2lubmVyLnN0YXR1c1RleHQ7XG4gIH1cbiAgZ2V0IG9rKCkge1xuICAgIHJldHVybiAyMDAgPD0gdGhpcy4jaW5uZXIuc3RhdHVzICYmIHRoaXMuI2lubmVyLnN0YXR1cyA8PSAyOTk7XG4gIH1cbiAgZ2V0IHVybCgpIHtcbiAgICByZXR1cm4gdGhpcy4jaW5uZXIudXJsID8/IFwiXCI7XG4gIH1cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2lubmVyLnR5cGU7XG4gIH1cbiAgYXJyYXlCdWZmZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuYnl0ZXMoKS5idWZmZXI7XG4gIH1cbiAgYnl0ZXMoKSB7XG4gICAgaWYgKHRoaXMuI2JvZHkgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy4jYm9keSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIHRleHRFbmNvZGVyLmVuY29kZSh0aGlzLiNib2R5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHRoaXMuI2JvZHkpO1xuICAgIH1cbiAgfVxuICBqc29uKCkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKHRoaXMudGV4dCgpKTtcbiAgfVxuICB0ZXh0KCkge1xuICAgIGlmICh0aGlzLiNib2R5ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuI2JvZHkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiB0aGlzLiNib2R5O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGV4dERlY29kZXIuZGVjb2RlKHRoaXMuI2JvZHkpO1xuICAgIH1cbiAgfVxufTtcbnZhciByZXF1ZXN0QmFzZVNpemUgPSBic2F0bkJhc2VTaXplKHsgdHlwZXM6IFtdIH0sIGh0dHBfcmVxdWVzdF90eXBlX2RlZmF1bHQuYWxnZWJyYWljVHlwZSk7XG52YXIgbWV0aG9kcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgW1wiR0VUXCIsIHsgdGFnOiBcIkdldFwiIH1dLFxuICBbXCJIRUFEXCIsIHsgdGFnOiBcIkhlYWRcIiB9XSxcbiAgW1wiUE9TVFwiLCB7IHRhZzogXCJQb3N0XCIgfV0sXG4gIFtcIlBVVFwiLCB7IHRhZzogXCJQdXRcIiB9XSxcbiAgW1wiREVMRVRFXCIsIHsgdGFnOiBcIkRlbGV0ZVwiIH1dLFxuICBbXCJDT05ORUNUXCIsIHsgdGFnOiBcIkNvbm5lY3RcIiB9XSxcbiAgW1wiT1BUSU9OU1wiLCB7IHRhZzogXCJPcHRpb25zXCIgfV0sXG4gIFtcIlRSQUNFXCIsIHsgdGFnOiBcIlRyYWNlXCIgfV0sXG4gIFtcIlBBVENIXCIsIHsgdGFnOiBcIlBhdGNoXCIgfV1cbl0pO1xuZnVuY3Rpb24gZmV0Y2godXJsLCBpbml0MiA9IHt9KSB7XG4gIGNvbnN0IG1ldGhvZCA9IG1ldGhvZHMuZ2V0KGluaXQyLm1ldGhvZD8udG9VcHBlckNhc2UoKSA/PyBcIkdFVFwiKSA/PyB7XG4gICAgdGFnOiBcIkV4dGVuc2lvblwiLFxuICAgIHZhbHVlOiBpbml0Mi5tZXRob2RcbiAgfTtcbiAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAvLyBhbnlzIGJlY2F1c2UgdGhlIHR5cGluZ3MgYXJlIHdvbmt5IC0gc2VlIGNvbW1lbnQgaW4gU3luY1Jlc3BvbnNlLmNvbnN0cnVjdG9yXG4gICAgZW50cmllczogaGVhZGVyc1RvTGlzdChuZXcgSGVhZGVycyhpbml0Mi5oZWFkZXJzKSkuZmxhdE1hcCgoW2ssIHZdKSA9PiBBcnJheS5pc0FycmF5KHYpID8gdi5tYXAoKHYyKSA9PiBbaywgdjJdKSA6IFtbaywgdl1dKS5tYXAoKFtuYW1lLCB2YWx1ZV0pID0+ICh7IG5hbWUsIHZhbHVlOiB0ZXh0RW5jb2Rlci5lbmNvZGUodmFsdWUpIH0pKVxuICB9O1xuICBjb25zdCB1cmkgPSBcIlwiICsgdXJsO1xuICBjb25zdCByZXF1ZXN0ID0gZnJlZXplKHtcbiAgICBtZXRob2QsXG4gICAgaGVhZGVycyxcbiAgICB0aW1lb3V0OiBpbml0Mi50aW1lb3V0LFxuICAgIHVyaSxcbiAgICB2ZXJzaW9uOiB7IHRhZzogXCJIdHRwMTFcIiB9XG4gIH0pO1xuICBjb25zdCByZXF1ZXN0QnVmID0gbmV3IEJpbmFyeVdyaXRlcihyZXF1ZXN0QmFzZVNpemUpO1xuICBodHRwX3JlcXVlc3RfdHlwZV9kZWZhdWx0LnNlcmlhbGl6ZShyZXF1ZXN0QnVmLCByZXF1ZXN0KTtcbiAgY29uc3QgYm9keSA9IGluaXQyLmJvZHkgPT0gbnVsbCA/IG5ldyBVaW50OEFycmF5KCkgOiB0eXBlb2YgaW5pdDIuYm9keSA9PT0gXCJzdHJpbmdcIiA/IGluaXQyLmJvZHkgOiBuZXcgVWludDhBcnJheShpbml0Mi5ib2R5KTtcbiAgY29uc3QgW3Jlc3BvbnNlQnVmLCByZXNwb25zZUJvZHldID0gc3lzLnByb2NlZHVyZV9odHRwX3JlcXVlc3QoXG4gICAgcmVxdWVzdEJ1Zi5nZXRCdWZmZXIoKSxcbiAgICBib2R5XG4gICk7XG4gIGNvbnN0IHJlc3BvbnNlID0gaHR0cF9yZXNwb25zZV90eXBlX2RlZmF1bHQuZGVzZXJpYWxpemUobmV3IEJpbmFyeVJlYWRlcihyZXNwb25zZUJ1ZikpO1xuICByZXR1cm4gU3luY1Jlc3BvbnNlW21ha2VSZXNwb25zZV0ocmVzcG9uc2VCb2R5LCB7XG4gICAgdHlwZTogXCJiYXNpY1wiLFxuICAgIHVybDogdXJpLFxuICAgIHN0YXR1czogcmVzcG9uc2UuY29kZSxcbiAgICBzdGF0dXNUZXh0OiAoMCwgaW1wb3J0X3N0YXR1c2VzLmRlZmF1bHQpKHJlc3BvbnNlLmNvZGUpLFxuICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKCksXG4gICAgYWJvcnRlZDogZmFsc2VcbiAgfSk7XG59XG5mcmVlemUoZmV0Y2gpO1xudmFyIGh0dHBDbGllbnQgPSBmcmVlemUoeyBmZXRjaCB9KTtcblxuLy8gc3JjL3NlcnZlci9wcm9jZWR1cmVzLnRzXG52YXIgeyBmcmVlemU6IGZyZWV6ZTIgfSA9IE9iamVjdDtcbmZ1bmN0aW9uIGNhbGxQcm9jZWR1cmUoaWQsIHNlbmRlciwgY29ubmVjdGlvbklkLCB0aW1lc3RhbXAsIGFyZ3NCdWYpIHtcbiAgY29uc3QgeyBmbiwgcGFyYW1zVHlwZSwgcmV0dXJuVHlwZSwgcmV0dXJuVHlwZUJhc2VTaXplIH0gPSBQUk9DRURVUkVTW2lkXTtcbiAgY29uc3QgYXJncyA9IFByb2R1Y3RUeXBlLmRlc2VyaWFsaXplVmFsdWUoXG4gICAgbmV3IEJpbmFyeVJlYWRlcihhcmdzQnVmKSxcbiAgICBwYXJhbXNUeXBlLFxuICAgIE1PRFVMRV9ERUYudHlwZXNwYWNlXG4gICk7XG4gIGNvbnN0IGN0eCA9IHtcbiAgICBzZW5kZXIsXG4gICAgdGltZXN0YW1wLFxuICAgIGNvbm5lY3Rpb25JZCxcbiAgICBodHRwOiBodHRwQ2xpZW50LFxuICAgIC8vICoqTm90ZToqKiBtdXN0IGJlIDAuLj11MzI6Ok1BWFxuICAgIGNvdW50ZXJfdXVpZDogeyB2YWx1ZTogTnVtYmVyKDApIH0sXG4gICAgZ2V0IGlkZW50aXR5KCkge1xuICAgICAgcmV0dXJuIG5ldyBJZGVudGl0eShzeXMuaWRlbnRpdHkoKS5fX2lkZW50aXR5X18pO1xuICAgIH0sXG4gICAgd2l0aFR4KGJvZHkpIHtcbiAgICAgIGNvbnN0IHJ1biA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgdGltZXN0YW1wMiA9IHN5cy5wcm9jZWR1cmVfc3RhcnRfbXV0X3R4KCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgY3R4MiA9IG5ldyBSZWR1Y2VyQ3R4SW1wbChcbiAgICAgICAgICAgIHNlbmRlcixcbiAgICAgICAgICAgIG5ldyBUaW1lc3RhbXAodGltZXN0YW1wMiksXG4gICAgICAgICAgICBjb25uZWN0aW9uSWRcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBib2R5KGN0eDIpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgc3lzLnByb2NlZHVyZV9hYm9ydF9tdXRfdHgoKTtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgbGV0IHJlcyA9IHJ1bigpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3lzLnByb2NlZHVyZV9jb21taXRfbXV0X3R4KCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgIH1cbiAgICAgIGNvbnNvbGUud2FybihcImNvbW1pdHRpbmcgYW5vbnltb3VzIHRyYW5zYWN0aW9uIGZhaWxlZFwiKTtcbiAgICAgIHJlcyA9IHJ1bigpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3lzLnByb2NlZHVyZV9jb21taXRfbXV0X3R4KCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyYW5zYWN0aW9uIHJldHJ5IGZhaWxlZCBhZ2FpblwiLCB7IGNhdXNlOiBlIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHJhbmRvbSB7QGxpbmsgVXVpZH0gYHY0YCB1c2luZyB0aGUge0BsaW5rIGNyeXB0b30gUk5HLlxuICAgICAqXG4gICAgICogV0FSTjogVW50aWwgd2UgdXNlIGEgc3BhY2V0aW1lIFJORyB0aGlzIG1ha2UgY2FsbHMgbm9uLWRldGVybWluaXN0aWMuXG4gICAgICovXG4gICAgbmV3VXVpZFY0KCkge1xuICAgICAgY29uc3QgYnl0ZXMgPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KDE2KSk7XG4gICAgICByZXR1cm4gVXVpZC5mcm9tUmFuZG9tQnl0ZXNWNChieXRlcyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgc29ydGFibGUge0BsaW5rIFV1aWR9IGB2N2AgdXNpbmcgdGhlIHtAbGluayBjcnlwdG99IFJORywgY291bnRlcixcbiAgICAgKiBhbmQgdGhlIHRpbWVzdGFtcC5cbiAgICAgKlxuICAgICAqIFdBUk46IFVudGlsIHdlIHVzZSBhIHNwYWNldGltZSBSTkcgdGhpcyBtYWtlIGNhbGxzIG5vbi1kZXRlcm1pbmlzdGljLlxuICAgICAqL1xuICAgIG5ld1V1aWRWNygpIHtcbiAgICAgIGNvbnN0IGJ5dGVzID0gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheSgxMCkpO1xuICAgICAgcmV0dXJuIFV1aWQuZnJvbUNvdW50ZXJWNyh0aGlzLmNvdW50ZXJfdXVpZCwgdGhpcy50aW1lc3RhbXAsIGJ5dGVzKTtcbiAgICB9XG4gIH07XG4gIGZyZWV6ZTIoY3R4KTtcbiAgY29uc3QgcmV0ID0gY2FsbFVzZXJGdW5jdGlvbihmbiwgY3R4LCBhcmdzKTtcbiAgY29uc3QgcmV0QnVmID0gbmV3IEJpbmFyeVdyaXRlcihyZXR1cm5UeXBlQmFzZVNpemUpO1xuICBBbGdlYnJhaWNUeXBlLnNlcmlhbGl6ZVZhbHVlKHJldEJ1ZiwgcmV0dXJuVHlwZSwgcmV0LCBNT0RVTEVfREVGLnR5cGVzcGFjZSk7XG4gIHJldHVybiByZXRCdWYuZ2V0QnVmZmVyKCk7XG59XG5cbi8vIHNyYy9saWIvYXV0b2dlbi92aWV3X3Jlc3VsdF9oZWFkZXJfdHlwZS50c1xudmFyIFZpZXdSZXN1bHRIZWFkZXIgPSB0LmVudW0oXCJWaWV3UmVzdWx0SGVhZGVyXCIsIHtcbiAgUm93RGF0YTogdC51bml0KCksXG4gIFJhd1NxbDogdC5zdHJpbmcoKVxufSk7XG52YXIgdmlld19yZXN1bHRfaGVhZGVyX3R5cGVfZGVmYXVsdCA9IFZpZXdSZXN1bHRIZWFkZXI7XG5cbi8vIHNyYy9zZXJ2ZXIvcnVudGltZS50c1xudmFyIHsgZnJlZXplOiBmcmVlemUzIH0gPSBPYmplY3Q7XG52YXIgc3lzID0gZnJlZXplMyh3cmFwU3lzY2FsbHMoX3N5c2NhbGxzMV8wLCBfc3lzY2FsbHMxXzIpKTtcbmZ1bmN0aW9uIHBhcnNlSnNvbk9iamVjdChqc29uKSB7XG4gIGxldCB2YWx1ZTtcbiAgdHJ5IHtcbiAgICB2YWx1ZSA9IEpTT04ucGFyc2UoanNvbik7XG4gIH0gY2F0Y2gge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgSlNPTjogZmFpbGVkIHRvIHBhcnNlIHN0cmluZ1wiKTtcbiAgfVxuICBpZiAodmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgYSBKU09OIG9iamVjdCBhdCB0aGUgdG9wIGxldmVsXCIpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbnZhciBKd3RDbGFpbXNJbXBsID0gY2xhc3Mge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBKd3RDbGFpbXMgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSByYXdQYXlsb2FkIFRoZSBKV1QgcGF5bG9hZCBhcyBhIHJhdyBKU09OIHN0cmluZy5cbiAgICogQHBhcmFtIGlkZW50aXR5IFRoZSBpZGVudGl0eSBmb3IgdGhpcyBKV1QuIFdlIGFyZSBvbmx5IHRha2luZyB0aGlzIGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSBhIGJsYWtlMyBpbXBsZW1lbnRhdGlvbiAod2hpY2ggd2UgbmVlZCB0byBjb21wdXRlIGl0KS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHJhd1BheWxvYWQsIGlkZW50aXR5KSB7XG4gICAgdGhpcy5yYXdQYXlsb2FkID0gcmF3UGF5bG9hZDtcbiAgICB0aGlzLmZ1bGxQYXlsb2FkID0gcGFyc2VKc29uT2JqZWN0KHJhd1BheWxvYWQpO1xuICAgIHRoaXMuX2lkZW50aXR5ID0gaWRlbnRpdHk7XG4gIH1cbiAgZnVsbFBheWxvYWQ7XG4gIF9pZGVudGl0eTtcbiAgZ2V0IGlkZW50aXR5KCkge1xuICAgIHJldHVybiB0aGlzLl9pZGVudGl0eTtcbiAgfVxuICBnZXQgc3ViamVjdCgpIHtcbiAgICByZXR1cm4gdGhpcy5mdWxsUGF5bG9hZFtcInN1YlwiXTtcbiAgfVxuICBnZXQgaXNzdWVyKCkge1xuICAgIHJldHVybiB0aGlzLmZ1bGxQYXlsb2FkW1wiaXNzXCJdO1xuICB9XG4gIGdldCBhdWRpZW5jZSgpIHtcbiAgICBjb25zdCBhdWQgPSB0aGlzLmZ1bGxQYXlsb2FkW1wiYXVkXCJdO1xuICAgIGlmIChhdWQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZW9mIGF1ZCA9PT0gXCJzdHJpbmdcIiA/IFthdWRdIDogYXVkO1xuICB9XG59O1xudmFyIEF1dGhDdHhJbXBsID0gY2xhc3MgX0F1dGhDdHhJbXBsIHtcbiAgaXNJbnRlcm5hbDtcbiAgLy8gU291cmNlIG9mIHRoZSBKV1QgcGF5bG9hZCBzdHJpbmcsIGlmIHRoZXJlIGlzIG9uZS5cbiAgX2p3dFNvdXJjZTtcbiAgLy8gV2hldGhlciB3ZSBoYXZlIGluaXRpYWxpemVkIHRoZSBKV1QgY2xhaW1zLlxuICBfaW5pdGlhbGl6ZWRKV1QgPSBmYWxzZTtcbiAgX2p3dENsYWltcztcbiAgX3NlbmRlcklkZW50aXR5O1xuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgdGhpcy5pc0ludGVybmFsID0gb3B0cy5pc0ludGVybmFsO1xuICAgIHRoaXMuX2p3dFNvdXJjZSA9IG9wdHMuand0U291cmNlO1xuICAgIHRoaXMuX3NlbmRlcklkZW50aXR5ID0gb3B0cy5zZW5kZXJJZGVudGl0eTtcbiAgfVxuICBfaW5pdGlhbGl6ZUpXVCgpIHtcbiAgICBpZiAodGhpcy5faW5pdGlhbGl6ZWRKV1QpIHJldHVybjtcbiAgICB0aGlzLl9pbml0aWFsaXplZEpXVCA9IHRydWU7XG4gICAgY29uc3QgdG9rZW4gPSB0aGlzLl9qd3RTb3VyY2UoKTtcbiAgICBpZiAoIXRva2VuKSB7XG4gICAgICB0aGlzLl9qd3RDbGFpbXMgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9qd3RDbGFpbXMgPSBuZXcgSnd0Q2xhaW1zSW1wbCh0b2tlbiwgdGhpcy5fc2VuZGVySWRlbnRpdHkpO1xuICAgIH1cbiAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICB9XG4gIC8qKiBMYXppbHkgY29tcHV0ZSB3aGV0aGVyIGEgSldUIGV4aXN0cyBhbmQgaXMgcGFyc2VhYmxlLiAqL1xuICBnZXQgaGFzSldUKCkge1xuICAgIHRoaXMuX2luaXRpYWxpemVKV1QoKTtcbiAgICByZXR1cm4gdGhpcy5fand0Q2xhaW1zICE9PSBudWxsO1xuICB9XG4gIC8qKiBMYXppbHkgcGFyc2UgdGhlIEp3dENsYWltcyBvbmx5IHdoZW4gYWNjZXNzZWQuICovXG4gIGdldCBqd3QoKSB7XG4gICAgdGhpcy5faW5pdGlhbGl6ZUpXVCgpO1xuICAgIHJldHVybiB0aGlzLl9qd3RDbGFpbXM7XG4gIH1cbiAgLyoqIENyZWF0ZSBhIGNvbnRleHQgcmVwcmVzZW50aW5nIGludGVybmFsIChub24tdXNlcikgcmVxdWVzdHMuICovXG4gIHN0YXRpYyBpbnRlcm5hbCgpIHtcbiAgICByZXR1cm4gbmV3IF9BdXRoQ3R4SW1wbCh7XG4gICAgICBpc0ludGVybmFsOiB0cnVlLFxuICAgICAgand0U291cmNlOiAoKSA9PiBudWxsLFxuICAgICAgc2VuZGVySWRlbnRpdHk6IElkZW50aXR5Lnplcm8oKVxuICAgIH0pO1xuICB9XG4gIC8qKiBJZiB0aGVyZSBpcyBhIGNvbm5lY3Rpb24gaWQsIGxvb2sgdXAgdGhlIEpXVCBwYXlsb2FkIGZyb20gdGhlIHN5c3RlbSB0YWJsZXMuICovXG4gIHN0YXRpYyBmcm9tU3lzdGVtVGFibGVzKGNvbm5lY3Rpb25JZCwgc2VuZGVyKSB7XG4gICAgaWYgKGNvbm5lY3Rpb25JZCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG5ldyBfQXV0aEN0eEltcGwoe1xuICAgICAgICBpc0ludGVybmFsOiBmYWxzZSxcbiAgICAgICAgand0U291cmNlOiAoKSA9PiBudWxsLFxuICAgICAgICBzZW5kZXJJZGVudGl0eTogc2VuZGVyXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBfQXV0aEN0eEltcGwoe1xuICAgICAgaXNJbnRlcm5hbDogZmFsc2UsXG4gICAgICBqd3RTb3VyY2U6ICgpID0+IHtcbiAgICAgICAgY29uc3QgcGF5bG9hZEJ1ZiA9IHN5cy5nZXRfand0X3BheWxvYWQoY29ubmVjdGlvbklkLl9fY29ubmVjdGlvbl9pZF9fKTtcbiAgICAgICAgaWYgKHBheWxvYWRCdWYubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcbiAgICAgICAgY29uc3QgcGF5bG9hZFN0ciA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShwYXlsb2FkQnVmKTtcbiAgICAgICAgcmV0dXJuIHBheWxvYWRTdHI7XG4gICAgICB9LFxuICAgICAgc2VuZGVySWRlbnRpdHk6IHNlbmRlclxuICAgIH0pO1xuICB9XG59O1xudmFyIFJlZHVjZXJDdHhJbXBsID0gY2xhc3MgUmVkdWNlckN0eCB7XG4gICNpZGVudGl0eTtcbiAgI3NlbmRlckF1dGg7XG4gICN1dWlkQ291bnRlcjtcbiAgc2VuZGVyO1xuICB0aW1lc3RhbXA7XG4gIGNvbm5lY3Rpb25JZDtcbiAgZGI7XG4gIGNvbnN0cnVjdG9yKHNlbmRlciwgdGltZXN0YW1wLCBjb25uZWN0aW9uSWQpIHtcbiAgICBPYmplY3Quc2VhbCh0aGlzKTtcbiAgICB0aGlzLnNlbmRlciA9IHNlbmRlcjtcbiAgICB0aGlzLnRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcbiAgICB0aGlzLmNvbm5lY3Rpb25JZCA9IGNvbm5lY3Rpb25JZDtcbiAgICB0aGlzLmRiID0gZ2V0RGJWaWV3KCk7XG4gIH1cbiAgZ2V0IGlkZW50aXR5KCkge1xuICAgIHJldHVybiB0aGlzLiNpZGVudGl0eSA/Pz0gbmV3IElkZW50aXR5KHN5cy5pZGVudGl0eSgpLl9faWRlbnRpdHlfXyk7XG4gIH1cbiAgZ2V0IHNlbmRlckF1dGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3NlbmRlckF1dGggPz89IEF1dGhDdHhJbXBsLmZyb21TeXN0ZW1UYWJsZXMoXG4gICAgICB0aGlzLmNvbm5lY3Rpb25JZCxcbiAgICAgIHRoaXMuc2VuZGVyXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHJhbmRvbSB7QGxpbmsgVXVpZH0gYHY0YCB1c2luZyB0aGUge0BsaW5rIGNyeXB0b30gUk5HLlxuICAgKlxuICAgKiBXQVJOOiBVbnRpbCB3ZSB1c2UgYSBzcGFjZXRpbWUgUk5HIHRoaXMgbWFrZSBjYWxscyBub24tZGV0ZXJtaW5pc3RpYy5cbiAgICovXG4gIG5ld1V1aWRWNCgpIHtcbiAgICBjb25zdCBieXRlcyA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoMTYpKTtcbiAgICByZXR1cm4gVXVpZC5mcm9tUmFuZG9tQnl0ZXNWNChieXRlcyk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBzb3J0YWJsZSB7QGxpbmsgVXVpZH0gYHY3YCB1c2luZyB0aGUge0BsaW5rIGNyeXB0b30gUk5HLCBjb3VudGVyLFxuICAgKiBhbmQgdGhlIHRpbWVzdGFtcC5cbiAgICpcbiAgICogV0FSTjogVW50aWwgd2UgdXNlIGEgc3BhY2V0aW1lIFJORyB0aGlzIG1ha2UgY2FsbHMgbm9uLWRldGVybWluaXN0aWMuXG4gICAqL1xuICBuZXdVdWlkVjcoKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KDQpKTtcbiAgICBjb25zdCBjb3VudGVyID0gdGhpcy4jdXVpZENvdW50ZXIgPz89IHsgdmFsdWU6IDAgfTtcbiAgICByZXR1cm4gVXVpZC5mcm9tQ291bnRlclY3KGNvdW50ZXIsIHRoaXMudGltZXN0YW1wLCBieXRlcyk7XG4gIH1cbn07XG52YXIgY2FsbFVzZXJGdW5jdGlvbiA9IGZ1bmN0aW9uIF9fc3BhY2V0aW1lZGJfZW5kX3Nob3J0X2JhY2t0cmFjZShmbiwgLi4uYXJncykge1xuICByZXR1cm4gZm4oLi4uYXJncyk7XG59O1xudmFyIGhvb2tzID0ge1xuICBfX2Rlc2NyaWJlX21vZHVsZV9fKCkge1xuICAgIGNvbnN0IHdyaXRlciA9IG5ldyBCaW5hcnlXcml0ZXIoMTI4KTtcbiAgICBBbGdlYnJhaWNUeXBlLnNlcmlhbGl6ZVZhbHVlKFxuICAgICAgd3JpdGVyLFxuICAgICAgcmF3X21vZHVsZV9kZWZfdHlwZV9kZWZhdWx0LmFsZ2VicmFpY1R5cGUsXG4gICAgICByYXdfbW9kdWxlX2RlZl90eXBlX2RlZmF1bHQuVjkoTU9EVUxFX0RFRilcbiAgICApO1xuICAgIHJldHVybiB3cml0ZXIuZ2V0QnVmZmVyKCk7XG4gIH0sXG4gIF9fY2FsbF9yZWR1Y2VyX18ocmVkdWNlcklkLCBzZW5kZXIsIGNvbm5JZCwgdGltZXN0YW1wLCBhcmdzQnVmKSB7XG4gICAgY29uc3QgYXJnc1R5cGUgPSBBbGdlYnJhaWNUeXBlLlByb2R1Y3QoXG4gICAgICBNT0RVTEVfREVGLnJlZHVjZXJzW3JlZHVjZXJJZF0ucGFyYW1zXG4gICAgKTtcbiAgICBjb25zdCBhcmdzID0gQWxnZWJyYWljVHlwZS5kZXNlcmlhbGl6ZVZhbHVlKFxuICAgICAgbmV3IEJpbmFyeVJlYWRlcihhcmdzQnVmKSxcbiAgICAgIGFyZ3NUeXBlLFxuICAgICAgTU9EVUxFX0RFRi50eXBlc3BhY2VcbiAgICApO1xuICAgIGNvbnN0IHNlbmRlcklkZW50aXR5ID0gbmV3IElkZW50aXR5KHNlbmRlcik7XG4gICAgY29uc3QgY3R4ID0gbmV3IFJlZHVjZXJDdHhJbXBsKFxuICAgICAgc2VuZGVySWRlbnRpdHksXG4gICAgICBuZXcgVGltZXN0YW1wKHRpbWVzdGFtcCksXG4gICAgICBDb25uZWN0aW9uSWQubnVsbElmWmVybyhuZXcgQ29ubmVjdGlvbklkKGNvbm5JZCkpXG4gICAgKTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNhbGxVc2VyRnVuY3Rpb24oUkVEVUNFUlNbcmVkdWNlcklkXSwgY3R4LCBhcmdzKSA/PyB7IHRhZzogXCJva1wiIH07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUgaW5zdGFuY2VvZiBTZW5kZXJFcnJvcikge1xuICAgICAgICByZXR1cm4geyB0YWc6IFwiZXJyXCIsIHZhbHVlOiBlLm1lc3NhZ2UgfTtcbiAgICAgIH1cbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG59O1xudmFyIGhvb2tzX3YxXzEgPSB7XG4gIF9fY2FsbF92aWV3X18oaWQsIHNlbmRlciwgYXJnc0J1Zikge1xuICAgIGNvbnN0IHsgZm4sIHBhcmFtcywgcmV0dXJuVHlwZSwgcmV0dXJuVHlwZUJhc2VTaXplIH0gPSBWSUVXU1tpZF07XG4gICAgY29uc3QgY3R4ID0gZnJlZXplMyh7XG4gICAgICBzZW5kZXI6IG5ldyBJZGVudGl0eShzZW5kZXIpLFxuICAgICAgLy8gdGhpcyBpcyB0aGUgbm9uLXJlYWRvbmx5IERiVmlldywgYnV0IHRoZSB0eXBpbmcgZm9yIHRoZSB1c2VyIHdpbGwgYmVcbiAgICAgIC8vIHRoZSByZWFkb25seSBvbmUsIGFuZCBpZiB0aGV5IGRvIGNhbGwgbXV0YXRpbmcgZnVuY3Rpb25zIGl0IHdpbGwgZmFpbFxuICAgICAgLy8gYXQgcnVudGltZVxuICAgICAgZGI6IGdldERiVmlldygpLFxuICAgICAgZnJvbTogbWFrZVF1ZXJ5QnVpbGRlcihnZXRSZWdpc3RlcmVkU2NoZW1hKCkpXG4gICAgfSk7XG4gICAgY29uc3QgYXJncyA9IFByb2R1Y3RUeXBlLmRlc2VyaWFsaXplVmFsdWUoXG4gICAgICBuZXcgQmluYXJ5UmVhZGVyKGFyZ3NCdWYpLFxuICAgICAgcGFyYW1zLFxuICAgICAgTU9EVUxFX0RFRi50eXBlc3BhY2VcbiAgICApO1xuICAgIGNvbnN0IHJldCA9IGNhbGxVc2VyRnVuY3Rpb24oZm4sIGN0eCwgYXJncyk7XG4gICAgY29uc3QgcmV0QnVmID0gbmV3IEJpbmFyeVdyaXRlcihyZXR1cm5UeXBlQmFzZVNpemUpO1xuICAgIGlmIChpc1Jvd1R5cGVkUXVlcnkocmV0KSkge1xuICAgICAgY29uc3QgcXVlcnkgPSB0b1NxbChyZXQpO1xuICAgICAgY29uc3QgdiA9IHZpZXdfcmVzdWx0X2hlYWRlcl90eXBlX2RlZmF1bHQuUmF3U3FsKHF1ZXJ5KTtcbiAgICAgIEFsZ2VicmFpY1R5cGUuc2VyaWFsaXplVmFsdWUoXG4gICAgICAgIHJldEJ1ZixcbiAgICAgICAgdmlld19yZXN1bHRfaGVhZGVyX3R5cGVfZGVmYXVsdC5hbGdlYnJhaWNUeXBlLFxuICAgICAgICB2LFxuICAgICAgICBNT0RVTEVfREVGLnR5cGVzcGFjZVxuICAgICAgKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IHJldEJ1Zi5nZXRCdWZmZXIoKVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgQWxnZWJyYWljVHlwZS5zZXJpYWxpemVWYWx1ZShcbiAgICAgICAgcmV0QnVmLFxuICAgICAgICB2aWV3X3Jlc3VsdF9oZWFkZXJfdHlwZV9kZWZhdWx0LmFsZ2VicmFpY1R5cGUsXG4gICAgICAgIHZpZXdfcmVzdWx0X2hlYWRlcl90eXBlX2RlZmF1bHQuUm93RGF0YSxcbiAgICAgICAgTU9EVUxFX0RFRi50eXBlc3BhY2VcbiAgICAgICk7XG4gICAgICBBbGdlYnJhaWNUeXBlLnNlcmlhbGl6ZVZhbHVlKFxuICAgICAgICByZXRCdWYsXG4gICAgICAgIHJldHVyblR5cGUsXG4gICAgICAgIHJldCxcbiAgICAgICAgTU9EVUxFX0RFRi50eXBlc3BhY2VcbiAgICAgICk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiByZXRCdWYuZ2V0QnVmZmVyKClcbiAgICAgIH07XG4gICAgfVxuICB9LFxuICBfX2NhbGxfdmlld19hbm9uX18oaWQsIGFyZ3NCdWYpIHtcbiAgICBjb25zdCB7IGZuLCBwYXJhbXMsIHJldHVyblR5cGUsIHJldHVyblR5cGVCYXNlU2l6ZSB9ID0gQU5PTl9WSUVXU1tpZF07XG4gICAgY29uc3QgY3R4ID0gZnJlZXplMyh7XG4gICAgICAvLyB0aGlzIGlzIHRoZSBub24tcmVhZG9ubHkgRGJWaWV3LCBidXQgdGhlIHR5cGluZyBmb3IgdGhlIHVzZXIgd2lsbCBiZVxuICAgICAgLy8gdGhlIHJlYWRvbmx5IG9uZSwgYW5kIGlmIHRoZXkgZG8gY2FsbCBtdXRhdGluZyBmdW5jdGlvbnMgaXQgd2lsbCBmYWlsXG4gICAgICAvLyBhdCBydW50aW1lXG4gICAgICBkYjogZ2V0RGJWaWV3KCksXG4gICAgICBmcm9tOiBtYWtlUXVlcnlCdWlsZGVyKGdldFJlZ2lzdGVyZWRTY2hlbWEoKSlcbiAgICB9KTtcbiAgICBjb25zdCBhcmdzID0gUHJvZHVjdFR5cGUuZGVzZXJpYWxpemVWYWx1ZShcbiAgICAgIG5ldyBCaW5hcnlSZWFkZXIoYXJnc0J1ZiksXG4gICAgICBwYXJhbXMsXG4gICAgICBNT0RVTEVfREVGLnR5cGVzcGFjZVxuICAgICk7XG4gICAgY29uc3QgcmV0ID0gY2FsbFVzZXJGdW5jdGlvbihmbiwgY3R4LCBhcmdzKTtcbiAgICBjb25zdCByZXRCdWYgPSBuZXcgQmluYXJ5V3JpdGVyKHJldHVyblR5cGVCYXNlU2l6ZSk7XG4gICAgaWYgKGlzUm93VHlwZWRRdWVyeShyZXQpKSB7XG4gICAgICBjb25zdCBxdWVyeSA9IHRvU3FsKHJldCk7XG4gICAgICBjb25zdCB2ID0gdmlld19yZXN1bHRfaGVhZGVyX3R5cGVfZGVmYXVsdC5SYXdTcWwocXVlcnkpO1xuICAgICAgQWxnZWJyYWljVHlwZS5zZXJpYWxpemVWYWx1ZShcbiAgICAgICAgcmV0QnVmLFxuICAgICAgICB2aWV3X3Jlc3VsdF9oZWFkZXJfdHlwZV9kZWZhdWx0LmFsZ2VicmFpY1R5cGUsXG4gICAgICAgIHYsXG4gICAgICAgIE1PRFVMRV9ERUYudHlwZXNwYWNlXG4gICAgICApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YTogcmV0QnVmLmdldEJ1ZmZlcigpXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBBbGdlYnJhaWNUeXBlLnNlcmlhbGl6ZVZhbHVlKFxuICAgICAgICByZXRCdWYsXG4gICAgICAgIHZpZXdfcmVzdWx0X2hlYWRlcl90eXBlX2RlZmF1bHQuYWxnZWJyYWljVHlwZSxcbiAgICAgICAgdmlld19yZXN1bHRfaGVhZGVyX3R5cGVfZGVmYXVsdC5Sb3dEYXRhLFxuICAgICAgICBNT0RVTEVfREVGLnR5cGVzcGFjZVxuICAgICAgKTtcbiAgICAgIEFsZ2VicmFpY1R5cGUuc2VyaWFsaXplVmFsdWUoXG4gICAgICAgIHJldEJ1ZixcbiAgICAgICAgcmV0dXJuVHlwZSxcbiAgICAgICAgcmV0LFxuICAgICAgICBNT0RVTEVfREVGLnR5cGVzcGFjZVxuICAgICAgKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IHJldEJ1Zi5nZXRCdWZmZXIoKVxuICAgICAgfTtcbiAgICB9XG4gIH1cbn07XG52YXIgaG9va3NfdjFfMiA9IHtcbiAgX19jYWxsX3Byb2NlZHVyZV9fKGlkLCBzZW5kZXIsIGNvbm5lY3Rpb25faWQsIHRpbWVzdGFtcCwgYXJncykge1xuICAgIHJldHVybiBjYWxsUHJvY2VkdXJlKFxuICAgICAgaWQsXG4gICAgICBuZXcgSWRlbnRpdHkoc2VuZGVyKSxcbiAgICAgIENvbm5lY3Rpb25JZC5udWxsSWZaZXJvKG5ldyBDb25uZWN0aW9uSWQoY29ubmVjdGlvbl9pZCkpLFxuICAgICAgbmV3IFRpbWVzdGFtcCh0aW1lc3RhbXApLFxuICAgICAgYXJnc1xuICAgICk7XG4gIH1cbn07XG52YXIgREJfVklFVyA9IG51bGw7XG5mdW5jdGlvbiBnZXREYlZpZXcoKSB7XG4gIERCX1ZJRVcgPz89IG1ha2VEYlZpZXcoTU9EVUxFX0RFRik7XG4gIHJldHVybiBEQl9WSUVXO1xufVxuZnVuY3Rpb24gbWFrZURiVmlldyhtb2R1bGVEZWYpIHtcbiAgcmV0dXJuIGZyZWV6ZTMoXG4gICAgT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgbW9kdWxlRGVmLnRhYmxlcy5tYXAoKHRhYmxlMikgPT4gW1xuICAgICAgICB0b0NhbWVsQ2FzZSh0YWJsZTIubmFtZSksXG4gICAgICAgIG1ha2VUYWJsZVZpZXcobW9kdWxlRGVmLnR5cGVzcGFjZSwgdGFibGUyKVxuICAgICAgXSlcbiAgICApXG4gICk7XG59XG5mdW5jdGlvbiBtYWtlVGFibGVWaWV3KHR5cGVzcGFjZSwgdGFibGUyKSB7XG4gIGNvbnN0IHRhYmxlX2lkID0gc3lzLnRhYmxlX2lkX2Zyb21fbmFtZSh0YWJsZTIubmFtZSk7XG4gIGNvbnN0IHJvd1R5cGUgPSB0eXBlc3BhY2UudHlwZXNbdGFibGUyLnByb2R1Y3RUeXBlUmVmXTtcbiAgaWYgKHJvd1R5cGUudGFnICE9PSBcIlByb2R1Y3RcIikge1xuICAgIHRocm93IFwiaW1wb3NzaWJsZVwiO1xuICB9XG4gIGNvbnN0IGJhc2VTaXplID0gYnNhdG5CYXNlU2l6ZSh0eXBlc3BhY2UsIHJvd1R5cGUpO1xuICBjb25zdCBzZXF1ZW5jZXMgPSB0YWJsZTIuc2VxdWVuY2VzLm1hcCgoc2VxKSA9PiB7XG4gICAgY29uc3QgY29sID0gcm93VHlwZS52YWx1ZS5lbGVtZW50c1tzZXEuY29sdW1uXTtcbiAgICBjb25zdCBjb2xUeXBlID0gY29sLmFsZ2VicmFpY1R5cGU7XG4gICAgbGV0IHNlcXVlbmNlVHJpZ2dlcjtcbiAgICBzd2l0Y2ggKGNvbFR5cGUudGFnKSB7XG4gICAgICBjYXNlIFwiVThcIjpcbiAgICAgIGNhc2UgXCJJOFwiOlxuICAgICAgY2FzZSBcIlUxNlwiOlxuICAgICAgY2FzZSBcIkkxNlwiOlxuICAgICAgY2FzZSBcIlUzMlwiOlxuICAgICAgY2FzZSBcIkkzMlwiOlxuICAgICAgICBzZXF1ZW5jZVRyaWdnZXIgPSAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJVNjRcIjpcbiAgICAgIGNhc2UgXCJJNjRcIjpcbiAgICAgIGNhc2UgXCJVMTI4XCI6XG4gICAgICBjYXNlIFwiSTEyOFwiOlxuICAgICAgY2FzZSBcIlUyNTZcIjpcbiAgICAgIGNhc2UgXCJJMjU2XCI6XG4gICAgICAgIHNlcXVlbmNlVHJpZ2dlciA9IDBuO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHNlcXVlbmNlIHR5cGVcIik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBjb2xOYW1lOiBjb2wubmFtZSxcbiAgICAgIHNlcXVlbmNlVHJpZ2dlcixcbiAgICAgIHJlYWQ6IChyZWFkZXIpID0+IEFsZ2VicmFpY1R5cGUuZGVzZXJpYWxpemVWYWx1ZShyZWFkZXIsIGNvbFR5cGUsIHR5cGVzcGFjZSlcbiAgICB9O1xuICB9KTtcbiAgY29uc3QgaGFzQXV0b0luY3JlbWVudCA9IHNlcXVlbmNlcy5sZW5ndGggPiAwO1xuICBjb25zdCBpdGVyID0gKCkgPT4gdGFibGVJdGVyYXRvcihzeXMuZGF0YXN0b3JlX3RhYmxlX3NjYW5fYnNhdG4odGFibGVfaWQpLCByb3dUeXBlKTtcbiAgY29uc3QgaW50ZWdyYXRlR2VuZXJhdGVkQ29sdW1ucyA9IGhhc0F1dG9JbmNyZW1lbnQgPyAocm93LCByZXRfYnVmKSA9PiB7XG4gICAgY29uc3QgcmVhZGVyID0gbmV3IEJpbmFyeVJlYWRlcihyZXRfYnVmKTtcbiAgICBmb3IgKGNvbnN0IHsgY29sTmFtZSwgcmVhZCwgc2VxdWVuY2VUcmlnZ2VyIH0gb2Ygc2VxdWVuY2VzKSB7XG4gICAgICBpZiAocm93W2NvbE5hbWVdID09PSBzZXF1ZW5jZVRyaWdnZXIpIHtcbiAgICAgICAgcm93W2NvbE5hbWVdID0gcmVhZChyZWFkZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfSA6IG51bGw7XG4gIGNvbnN0IHRhYmxlTWV0aG9kcyA9IHtcbiAgICBjb3VudDogKCkgPT4gc3lzLmRhdGFzdG9yZV90YWJsZV9yb3dfY291bnQodGFibGVfaWQpLFxuICAgIGl0ZXIsXG4gICAgW1N5bWJvbC5pdGVyYXRvcl06ICgpID0+IGl0ZXIoKSxcbiAgICBpbnNlcnQ6IChyb3cpID0+IHtcbiAgICAgIGNvbnN0IHdyaXRlciA9IG5ldyBCaW5hcnlXcml0ZXIoYmFzZVNpemUpO1xuICAgICAgQWxnZWJyYWljVHlwZS5zZXJpYWxpemVWYWx1ZSh3cml0ZXIsIHJvd1R5cGUsIHJvdywgdHlwZXNwYWNlKTtcbiAgICAgIGNvbnN0IHJldF9idWYgPSBzeXMuZGF0YXN0b3JlX2luc2VydF9ic2F0bih0YWJsZV9pZCwgd3JpdGVyLmdldEJ1ZmZlcigpKTtcbiAgICAgIGNvbnN0IHJldCA9IHsgLi4ucm93IH07XG4gICAgICBpbnRlZ3JhdGVHZW5lcmF0ZWRDb2x1bW5zPy4ocmV0LCByZXRfYnVmKTtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSxcbiAgICBkZWxldGU6IChyb3cpID0+IHtcbiAgICAgIGNvbnN0IHdyaXRlciA9IG5ldyBCaW5hcnlXcml0ZXIoNCArIGJhc2VTaXplKTtcbiAgICAgIHdyaXRlci53cml0ZVUzMigxKTtcbiAgICAgIEFsZ2VicmFpY1R5cGUuc2VyaWFsaXplVmFsdWUod3JpdGVyLCByb3dUeXBlLCByb3csIHR5cGVzcGFjZSk7XG4gICAgICBjb25zdCBjb3VudCA9IHN5cy5kYXRhc3RvcmVfZGVsZXRlX2FsbF9ieV9lcV9ic2F0bihcbiAgICAgICAgdGFibGVfaWQsXG4gICAgICAgIHdyaXRlci5nZXRCdWZmZXIoKVxuICAgICAgKTtcbiAgICAgIHJldHVybiBjb3VudCA+IDA7XG4gICAgfVxuICB9O1xuICBjb25zdCB0YWJsZVZpZXcgPSBPYmplY3QuYXNzaWduKFxuICAgIC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgIHRhYmxlTWV0aG9kc1xuICApO1xuICBmb3IgKGNvbnN0IGluZGV4RGVmIG9mIHRhYmxlMi5pbmRleGVzKSB7XG4gICAgY29uc3QgaW5kZXhfaWQgPSBzeXMuaW5kZXhfaWRfZnJvbV9uYW1lKGluZGV4RGVmLm5hbWUpO1xuICAgIGxldCBjb2x1bW5faWRzO1xuICAgIHN3aXRjaCAoaW5kZXhEZWYuYWxnb3JpdGhtLnRhZykge1xuICAgICAgY2FzZSBcIkJUcmVlXCI6XG4gICAgICAgIGNvbHVtbl9pZHMgPSBpbmRleERlZi5hbGdvcml0aG0udmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkhhc2hcIjpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW1wb3NzaWJsZVwiKTtcbiAgICAgIGNhc2UgXCJEaXJlY3RcIjpcbiAgICAgICAgY29sdW1uX2lkcyA9IFtpbmRleERlZi5hbGdvcml0aG0udmFsdWVdO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgY29uc3QgbnVtQ29sdW1ucyA9IGNvbHVtbl9pZHMubGVuZ3RoO1xuICAgIGNvbnN0IGNvbHVtblNldCA9IG5ldyBTZXQoY29sdW1uX2lkcyk7XG4gICAgY29uc3QgaXNVbmlxdWUgPSB0YWJsZTIuY29uc3RyYWludHMuZmlsdGVyKCh4KSA9PiB4LmRhdGEudGFnID09PSBcIlVuaXF1ZVwiKS5zb21lKCh4KSA9PiBjb2x1bW5TZXQuaXNTdWJzZXRPZihuZXcgU2V0KHguZGF0YS52YWx1ZS5jb2x1bW5zKSkpO1xuICAgIGNvbnN0IGluZGV4VHlwZSA9IEFsZ2VicmFpY1R5cGUuUHJvZHVjdCh7XG4gICAgICBlbGVtZW50czogY29sdW1uX2lkcy5tYXAoKGlkKSA9PiByb3dUeXBlLnZhbHVlLmVsZW1lbnRzW2lkXSlcbiAgICB9KTtcbiAgICBjb25zdCBiYXNlU2l6ZTIgPSBic2F0bkJhc2VTaXplKHR5cGVzcGFjZSwgaW5kZXhUeXBlKTtcbiAgICBjb25zdCBzZXJpYWxpemVQcmVmaXggPSAod3JpdGVyLCBwcmVmaXgsIHByZWZpeF9lbGVtcykgPT4ge1xuICAgICAgaWYgKHByZWZpeF9lbGVtcyA+IG51bUNvbHVtbnMgLSAxKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwidG9vIG1hbnkgZWxlbWVudHMgaW4gcHJlZml4XCIpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVmaXhfZWxlbXM7IGkrKykge1xuICAgICAgICBjb25zdCBlbGVtVHlwZSA9IGluZGV4VHlwZS52YWx1ZS5lbGVtZW50c1tpXS5hbGdlYnJhaWNUeXBlO1xuICAgICAgICBBbGdlYnJhaWNUeXBlLnNlcmlhbGl6ZVZhbHVlKHdyaXRlciwgZWxlbVR5cGUsIHByZWZpeFtpXSwgdHlwZXNwYWNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfTtcbiAgICBsZXQgaW5kZXg7XG4gICAgaWYgKGlzVW5pcXVlKSB7XG4gICAgICBjb25zdCBzZXJpYWxpemVCb3VuZCA9IChjb2xWYWwpID0+IHtcbiAgICAgICAgaWYgKGNvbFZhbC5sZW5ndGggIT09IG51bUNvbHVtbnMpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIndyb25nIG51bWJlciBvZiBlbGVtZW50c1wiKTtcbiAgICAgICAgY29uc3Qgd3JpdGVyID0gbmV3IEJpbmFyeVdyaXRlcihiYXNlU2l6ZTIgKyAxKTtcbiAgICAgICAgY29uc3QgcHJlZml4X2VsZW1zID0gbnVtQ29sdW1ucyAtIDE7XG4gICAgICAgIHNlcmlhbGl6ZVByZWZpeCh3cml0ZXIsIGNvbFZhbCwgcHJlZml4X2VsZW1zKTtcbiAgICAgICAgY29uc3QgcnN0YXJ0T2Zmc2V0ID0gd3JpdGVyLm9mZnNldDtcbiAgICAgICAgd3JpdGVyLndyaXRlVTgoMCk7XG4gICAgICAgIEFsZ2VicmFpY1R5cGUuc2VyaWFsaXplVmFsdWUoXG4gICAgICAgICAgd3JpdGVyLFxuICAgICAgICAgIGluZGV4VHlwZS52YWx1ZS5lbGVtZW50c1tudW1Db2x1bW5zIC0gMV0uYWxnZWJyYWljVHlwZSxcbiAgICAgICAgICBjb2xWYWxbbnVtQ29sdW1ucyAtIDFdLFxuICAgICAgICAgIHR5cGVzcGFjZVxuICAgICAgICApO1xuICAgICAgICBjb25zdCBidWZmZXIgPSB3cml0ZXIuZ2V0QnVmZmVyKCk7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IGJ1ZmZlci5zbGljZSgwLCByc3RhcnRPZmZzZXQpO1xuICAgICAgICBjb25zdCByc3RhcnQgPSBidWZmZXIuc2xpY2UocnN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIFtwcmVmaXgsIHByZWZpeF9lbGVtcywgcnN0YXJ0LCByc3RhcnRdO1xuICAgICAgfTtcbiAgICAgIGluZGV4ID0ge1xuICAgICAgICBmaW5kOiAoY29sVmFsKSA9PiB7XG4gICAgICAgICAgaWYgKG51bUNvbHVtbnMgPT09IDEpIGNvbFZhbCA9IFtjb2xWYWxdO1xuICAgICAgICAgIGNvbnN0IGFyZ3MgPSBzZXJpYWxpemVCb3VuZChjb2xWYWwpO1xuICAgICAgICAgIGNvbnN0IGl0ZXIyID0gdGFibGVJdGVyYXRvcihcbiAgICAgICAgICAgIHN5cy5kYXRhc3RvcmVfaW5kZXhfc2Nhbl9yYW5nZV9ic2F0bihpbmRleF9pZCwgLi4uYXJncyksXG4gICAgICAgICAgICByb3dUeXBlXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBpdGVyMi5uZXh0KCk7XG4gICAgICAgICAgaWYgKGRvbmUpIHJldHVybiBudWxsO1xuICAgICAgICAgIGlmICghaXRlcjIubmV4dCgpLmRvbmUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIFwiYGRhdGFzdG9yZV9pbmRleF9zY2FuX3JhbmdlX2JzYXRuYCBvbiB1bmlxdWUgZmllbGQgY2Fubm90IHJldHVybiA+MSByb3dzXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBkZWxldGU6IChjb2xWYWwpID0+IHtcbiAgICAgICAgICBpZiAobnVtQ29sdW1ucyA9PT0gMSkgY29sVmFsID0gW2NvbFZhbF07XG4gICAgICAgICAgY29uc3QgYXJncyA9IHNlcmlhbGl6ZUJvdW5kKGNvbFZhbCk7XG4gICAgICAgICAgY29uc3QgbnVtID0gc3lzLmRhdGFzdG9yZV9kZWxldGVfYnlfaW5kZXhfc2Nhbl9yYW5nZV9ic2F0bihcbiAgICAgICAgICAgIGluZGV4X2lkLFxuICAgICAgICAgICAgLi4uYXJnc1xuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIG51bSA+IDA7XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZTogKHJvdykgPT4ge1xuICAgICAgICAgIGNvbnN0IHdyaXRlciA9IG5ldyBCaW5hcnlXcml0ZXIoYmFzZVNpemUyKTtcbiAgICAgICAgICBBbGdlYnJhaWNUeXBlLnNlcmlhbGl6ZVZhbHVlKHdyaXRlciwgcm93VHlwZSwgcm93LCB0eXBlc3BhY2UpO1xuICAgICAgICAgIGNvbnN0IHJldF9idWYgPSBzeXMuZGF0YXN0b3JlX3VwZGF0ZV9ic2F0bihcbiAgICAgICAgICAgIHRhYmxlX2lkLFxuICAgICAgICAgICAgaW5kZXhfaWQsXG4gICAgICAgICAgICB3cml0ZXIuZ2V0QnVmZmVyKClcbiAgICAgICAgICApO1xuICAgICAgICAgIGludGVncmF0ZUdlbmVyYXRlZENvbHVtbnM/Lihyb3csIHJldF9idWYpO1xuICAgICAgICAgIHJldHVybiByb3c7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZVJhbmdlID0gKHJhbmdlKSA9PiB7XG4gICAgICAgIGlmIChyYW5nZS5sZW5ndGggPiBudW1Db2x1bW5zKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwidG9vIG1hbnkgZWxlbWVudHNcIik7XG4gICAgICAgIGNvbnN0IHdyaXRlciA9IG5ldyBCaW5hcnlXcml0ZXIoYmFzZVNpemUyICsgMSk7XG4gICAgICAgIGNvbnN0IHByZWZpeF9lbGVtcyA9IHJhbmdlLmxlbmd0aCAtIDE7XG4gICAgICAgIHNlcmlhbGl6ZVByZWZpeCh3cml0ZXIsIHJhbmdlLCBwcmVmaXhfZWxlbXMpO1xuICAgICAgICBjb25zdCByc3RhcnRPZmZzZXQgPSB3cml0ZXIub2Zmc2V0O1xuICAgICAgICBjb25zdCB0ZXJtID0gcmFuZ2VbcmFuZ2UubGVuZ3RoIC0gMV07XG4gICAgICAgIGNvbnN0IHRlcm1UeXBlID0gaW5kZXhUeXBlLnZhbHVlLmVsZW1lbnRzW3JhbmdlLmxlbmd0aCAtIDFdLmFsZ2VicmFpY1R5cGU7XG4gICAgICAgIGxldCByc3RhcnQsIHJlbmQ7XG4gICAgICAgIGlmICh0ZXJtIGluc3RhbmNlb2YgUmFuZ2UpIHtcbiAgICAgICAgICBjb25zdCB3cml0ZUJvdW5kID0gKGJvdW5kKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0YWdzID0geyBpbmNsdWRlZDogMCwgZXhjbHVkZWQ6IDEsIHVuYm91bmRlZDogMiB9O1xuICAgICAgICAgICAgd3JpdGVyLndyaXRlVTgodGFnc1tib3VuZC50YWddKTtcbiAgICAgICAgICAgIGlmIChib3VuZC50YWcgIT09IFwidW5ib3VuZGVkXCIpXG4gICAgICAgICAgICAgIEFsZ2VicmFpY1R5cGUuc2VyaWFsaXplVmFsdWUoXG4gICAgICAgICAgICAgICAgd3JpdGVyLFxuICAgICAgICAgICAgICAgIHRlcm1UeXBlLFxuICAgICAgICAgICAgICAgIGJvdW5kLnZhbHVlLFxuICAgICAgICAgICAgICAgIHR5cGVzcGFjZVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgIH07XG4gICAgICAgICAgd3JpdGVCb3VuZCh0ZXJtLmZyb20pO1xuICAgICAgICAgIGNvbnN0IHJlbmRPZmZzZXQgPSB3cml0ZXIub2Zmc2V0O1xuICAgICAgICAgIHdyaXRlQm91bmQodGVybS50byk7XG4gICAgICAgICAgcnN0YXJ0ID0gd3JpdGVyLmdldEJ1ZmZlcigpLnNsaWNlKHJzdGFydE9mZnNldCwgcmVuZE9mZnNldCk7XG4gICAgICAgICAgcmVuZCA9IHdyaXRlci5nZXRCdWZmZXIoKS5zbGljZShyZW5kT2Zmc2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3cml0ZXIud3JpdGVVOCgwKTtcbiAgICAgICAgICBBbGdlYnJhaWNUeXBlLnNlcmlhbGl6ZVZhbHVlKHdyaXRlciwgdGVybVR5cGUsIHRlcm0sIHR5cGVzcGFjZSk7XG4gICAgICAgICAgcnN0YXJ0ID0gcmVuZCA9IHdyaXRlci5nZXRCdWZmZXIoKS5zbGljZShyc3RhcnRPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHdyaXRlci5nZXRCdWZmZXIoKTtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gYnVmZmVyLnNsaWNlKDAsIHJzdGFydE9mZnNldCk7XG4gICAgICAgIHJldHVybiBbcHJlZml4LCBwcmVmaXhfZWxlbXMsIHJzdGFydCwgcmVuZF07XG4gICAgICB9O1xuICAgICAgaW5kZXggPSB7XG4gICAgICAgIGZpbHRlcjogKHJhbmdlKSA9PiB7XG4gICAgICAgICAgaWYgKG51bUNvbHVtbnMgPT09IDEpIHJhbmdlID0gW3JhbmdlXTtcbiAgICAgICAgICBjb25zdCBhcmdzID0gc2VyaWFsaXplUmFuZ2UocmFuZ2UpO1xuICAgICAgICAgIHJldHVybiB0YWJsZUl0ZXJhdG9yKFxuICAgICAgICAgICAgc3lzLmRhdGFzdG9yZV9pbmRleF9zY2FuX3JhbmdlX2JzYXRuKGluZGV4X2lkLCAuLi5hcmdzKSxcbiAgICAgICAgICAgIHJvd1R5cGVcbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICBkZWxldGU6IChyYW5nZSkgPT4ge1xuICAgICAgICAgIGlmIChudW1Db2x1bW5zID09PSAxKSByYW5nZSA9IFtyYW5nZV07XG4gICAgICAgICAgY29uc3QgYXJncyA9IHNlcmlhbGl6ZVJhbmdlKHJhbmdlKTtcbiAgICAgICAgICByZXR1cm4gc3lzLmRhdGFzdG9yZV9kZWxldGVfYnlfaW5kZXhfc2Nhbl9yYW5nZV9ic2F0bihcbiAgICAgICAgICAgIGluZGV4X2lkLFxuICAgICAgICAgICAgLi4uYXJnc1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChPYmplY3QuaGFzT3duKHRhYmxlVmlldywgaW5kZXhEZWYuYWNjZXNzb3JOYW1lKSkge1xuICAgICAgZnJlZXplMyhPYmplY3QuYXNzaWduKHRhYmxlVmlld1tpbmRleERlZi5hY2Nlc3Nvck5hbWVdLCBpbmRleCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YWJsZVZpZXdbaW5kZXhEZWYuYWNjZXNzb3JOYW1lXSA9IGZyZWV6ZTMoaW5kZXgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZnJlZXplMyh0YWJsZVZpZXcpO1xufVxuZnVuY3Rpb24gaGFzT3duKG8sIGspIHtcbiAgcmV0dXJuIE9iamVjdC5oYXNPd24obywgayk7XG59XG5mdW5jdGlvbiogdGFibGVJdGVyYXRvcihpZCwgdHkpIHtcbiAgdmFyIF9zdGFjayA9IFtdO1xuICB0cnkge1xuICAgIGNvbnN0IGl0ZXIgPSBfX3VzaW5nKF9zdGFjaywgbmV3IEl0ZXJhdG9ySGFuZGxlKGlkKSk7XG4gICAgY29uc3QgeyB0eXBlc3BhY2UgfSA9IE1PRFVMRV9ERUY7XG4gICAgbGV0IGJ1ZjtcbiAgICB3aGlsZSAoKGJ1ZiA9IGFkdmFuY2VJdGVyKGl0ZXIpKSAhPSBudWxsKSB7XG4gICAgICBjb25zdCByZWFkZXIgPSBuZXcgQmluYXJ5UmVhZGVyKGJ1Zik7XG4gICAgICB3aGlsZSAocmVhZGVyLnJlbWFpbmluZyA+IDApIHtcbiAgICAgICAgeWllbGQgQWxnZWJyYWljVHlwZS5kZXNlcmlhbGl6ZVZhbHVlKHJlYWRlciwgdHksIHR5cGVzcGFjZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChfKSB7XG4gICAgdmFyIF9lcnJvciA9IF8sIF9oYXNFcnJvciA9IHRydWU7XG4gIH0gZmluYWxseSB7XG4gICAgX19jYWxsRGlzcG9zZShfc3RhY2ssIF9lcnJvciwgX2hhc0Vycm9yKTtcbiAgfVxufVxuZnVuY3Rpb24gYWR2YW5jZUl0ZXIoaXRlcikge1xuICBsZXQgYnVmX21heF9sZW4gPSA2NTUzNjtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGl0ZXIuYWR2YW5jZShidWZfbWF4X2xlbik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUgJiYgdHlwZW9mIGUgPT09IFwib2JqZWN0XCIgJiYgaGFzT3duKGUsIFwiX19idWZmZXJfdG9vX3NtYWxsX19cIikpIHtcbiAgICAgICAgYnVmX21heF9sZW4gPSBlLl9fYnVmZmVyX3Rvb19zbWFsbF9fO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG59XG52YXIgSXRlcmF0b3JIYW5kbGUgPSBjbGFzcyBfSXRlcmF0b3JIYW5kbGUge1xuICAjaWQ7XG4gIHN0YXRpYyAjZmluYWxpemF0aW9uUmVnaXN0cnkgPSBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkoXG4gICAgc3lzLnJvd19pdGVyX2JzYXRuX2Nsb3NlXG4gICk7XG4gIGNvbnN0cnVjdG9yKGlkKSB7XG4gICAgdGhpcy4jaWQgPSBpZDtcbiAgICBfSXRlcmF0b3JIYW5kbGUuI2ZpbmFsaXphdGlvblJlZ2lzdHJ5LnJlZ2lzdGVyKHRoaXMsIGlkLCB0aGlzKTtcbiAgfVxuICAvKiogVW5yZWdpc3RlciB0aGlzIG9iamVjdCB3aXRoIHRoZSBmaW5hbGl6YXRpb24gcmVnaXN0cnkgYW5kIHJldHVybiB0aGUgaWQgKi9cbiAgI2RldGFjaCgpIHtcbiAgICBjb25zdCBpZCA9IHRoaXMuI2lkO1xuICAgIHRoaXMuI2lkID0gLTE7XG4gICAgX0l0ZXJhdG9ySGFuZGxlLiNmaW5hbGl6YXRpb25SZWdpc3RyeS51bnJlZ2lzdGVyKHRoaXMpO1xuICAgIHJldHVybiBpZDtcbiAgfVxuICAvKiogQ2FsbCBgcm93X2l0ZXJfYnNhdG5fYWR2YW5jZWAsIHJldHVybmluZyBudWxsIGlmIHRoaXMgaXRlcmF0b3Igd2FzIGFscmVhZHkgZXhoYXVzdGVkLiAqL1xuICBhZHZhbmNlKGJ1Zl9tYXhfbGVuKSB7XG4gICAgaWYgKHRoaXMuI2lkID09PSAtMSkgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgeyAwOiBkb25lLCAxOiBidWYgfSA9IHN5cy5yb3dfaXRlcl9ic2F0bl9hZHZhbmNlKFxuICAgICAgdGhpcy4jaWQsXG4gICAgICBidWZfbWF4X2xlblxuICAgICk7XG4gICAgaWYgKGRvbmUpIHRoaXMuI2RldGFjaCgpO1xuICAgIHJldHVybiBidWY7XG4gIH1cbiAgW1N5bWJvbC5kaXNwb3NlXSgpIHtcbiAgICBpZiAodGhpcy4jaWQgPj0gMCkge1xuICAgICAgY29uc3QgaWQgPSB0aGlzLiNkZXRhY2goKTtcbiAgICAgIHN5cy5yb3dfaXRlcl9ic2F0bl9jbG9zZShpZCk7XG4gICAgfVxuICB9XG59O1xuZnVuY3Rpb24gd3JhcFN5c2NhbGxzKC4uLm1vZHVsZXMpIHtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBtb2R1bGVzLmZsYXRNYXAoT2JqZWN0LmVudHJpZXMpLm1hcCgoW2ssIHZdKSA9PiBbaywgd3JhcFN5c2NhbGwodildKVxuICApO1xufVxuZnVuY3Rpb24gd3JhcFN5c2NhbGwoZnVuYykge1xuICBjb25zdCBuYW1lID0gZnVuYy5uYW1lO1xuICByZXR1cm4ge1xuICAgIFtuYW1lXSguLi5hcmdzKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZnVuYyguLi5hcmdzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUgIT09IG51bGwgJiYgdHlwZW9mIGUgPT09IFwib2JqZWN0XCIgJiYgaGFzT3duKGUsIFwiX19jb2RlX2Vycm9yX19cIikgJiYgdHlwZW9mIGUuX19jb2RlX2Vycm9yX18gPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBoYXNPd24oZSwgXCJfX2Vycm9yX21lc3NhZ2VfX1wiKSAmJiB0eXBlb2YgZS5fX2Vycm9yX21lc3NhZ2VfXyA9PT0gXCJzdHJpbmdcIiA/IGUuX19lcnJvcl9tZXNzYWdlX18gOiB2b2lkIDA7XG4gICAgICAgICAgdGhyb3cgbmV3IFNwYWNldGltZUhvc3RFcnJvcihlLl9fY29kZV9lcnJvcl9fLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cbiAgfVtuYW1lXTtcbn1cbmZ1bmN0aW9uIGZtdExvZyguLi5kYXRhKSB7XG4gIHJldHVybiBkYXRhLmpvaW4oXCIgXCIpO1xufVxudmFyIGNvbnNvbGVfbGV2ZWxfZXJyb3IgPSAwO1xudmFyIGNvbnNvbGVfbGV2ZWxfd2FybiA9IDE7XG52YXIgY29uc29sZV9sZXZlbF9pbmZvID0gMjtcbnZhciBjb25zb2xlX2xldmVsX2RlYnVnID0gMztcbnZhciBjb25zb2xlX2xldmVsX3RyYWNlID0gNDtcbnZhciB0aW1lck1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG52YXIgY29uc29sZTIgPSB7XG4gIC8vIEB0cy1leHBlY3QtZXJyb3Igd2Ugd2FudCBhIGJsYW5rIHByb3RvdHlwZSwgYnV0IHR5cGVzY3JpcHQgY29tcGxhaW5zXG4gIF9fcHJvdG9fXzoge30sXG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiBcImNvbnNvbGVcIixcbiAgYXNzZXJ0OiAoY29uZGl0aW9uID0gZmFsc2UsIC4uLmRhdGEpID0+IHtcbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgc3lzLmNvbnNvbGVfbG9nKGNvbnNvbGVfbGV2ZWxfZXJyb3IsIGZtdExvZyguLi5kYXRhKSk7XG4gICAgfVxuICB9LFxuICBjbGVhcjogKCkgPT4ge1xuICB9LFxuICBkZWJ1ZzogKC4uLmRhdGEpID0+IHtcbiAgICBzeXMuY29uc29sZV9sb2coY29uc29sZV9sZXZlbF9kZWJ1ZywgZm10TG9nKC4uLmRhdGEpKTtcbiAgfSxcbiAgZXJyb3I6ICguLi5kYXRhKSA9PiB7XG4gICAgc3lzLmNvbnNvbGVfbG9nKGNvbnNvbGVfbGV2ZWxfZXJyb3IsIGZtdExvZyguLi5kYXRhKSk7XG4gIH0sXG4gIGluZm86ICguLi5kYXRhKSA9PiB7XG4gICAgc3lzLmNvbnNvbGVfbG9nKGNvbnNvbGVfbGV2ZWxfaW5mbywgZm10TG9nKC4uLmRhdGEpKTtcbiAgfSxcbiAgbG9nOiAoLi4uZGF0YSkgPT4ge1xuICAgIHN5cy5jb25zb2xlX2xvZyhjb25zb2xlX2xldmVsX2luZm8sIGZtdExvZyguLi5kYXRhKSk7XG4gIH0sXG4gIHRhYmxlOiAodGFidWxhckRhdGEsIF9wcm9wZXJ0aWVzKSA9PiB7XG4gICAgc3lzLmNvbnNvbGVfbG9nKGNvbnNvbGVfbGV2ZWxfaW5mbywgZm10TG9nKHRhYnVsYXJEYXRhKSk7XG4gIH0sXG4gIHRyYWNlOiAoLi4uZGF0YSkgPT4ge1xuICAgIHN5cy5jb25zb2xlX2xvZyhjb25zb2xlX2xldmVsX3RyYWNlLCBmbXRMb2coLi4uZGF0YSkpO1xuICB9LFxuICB3YXJuOiAoLi4uZGF0YSkgPT4ge1xuICAgIHN5cy5jb25zb2xlX2xvZyhjb25zb2xlX2xldmVsX3dhcm4sIGZtdExvZyguLi5kYXRhKSk7XG4gIH0sXG4gIGRpcjogKF9pdGVtLCBfb3B0aW9ucykgPT4ge1xuICB9LFxuICBkaXJ4bWw6ICguLi5fZGF0YSkgPT4ge1xuICB9LFxuICAvLyBDb3VudGluZ1xuICBjb3VudDogKF9sYWJlbCA9IFwiZGVmYXVsdFwiKSA9PiB7XG4gIH0sXG4gIGNvdW50UmVzZXQ6IChfbGFiZWwgPSBcImRlZmF1bHRcIikgPT4ge1xuICB9LFxuICAvLyBHcm91cGluZ1xuICBncm91cDogKC4uLl9kYXRhKSA9PiB7XG4gIH0sXG4gIGdyb3VwQ29sbGFwc2VkOiAoLi4uX2RhdGEpID0+IHtcbiAgfSxcbiAgZ3JvdXBFbmQ6ICgpID0+IHtcbiAgfSxcbiAgLy8gVGltaW5nXG4gIHRpbWU6IChsYWJlbCA9IFwiZGVmYXVsdFwiKSA9PiB7XG4gICAgaWYgKHRpbWVyTWFwLmhhcyhsYWJlbCkpIHtcbiAgICAgIHN5cy5jb25zb2xlX2xvZyhjb25zb2xlX2xldmVsX3dhcm4sIGBUaW1lciAnJHtsYWJlbH0nIGFscmVhZHkgZXhpc3RzLmApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aW1lck1hcC5zZXQobGFiZWwsIHN5cy5jb25zb2xlX3RpbWVyX3N0YXJ0KGxhYmVsKSk7XG4gIH0sXG4gIHRpbWVMb2c6IChsYWJlbCA9IFwiZGVmYXVsdFwiLCAuLi5kYXRhKSA9PiB7XG4gICAgc3lzLmNvbnNvbGVfbG9nKGNvbnNvbGVfbGV2ZWxfaW5mbywgZm10TG9nKGxhYmVsLCAuLi5kYXRhKSk7XG4gIH0sXG4gIHRpbWVFbmQ6IChsYWJlbCA9IFwiZGVmYXVsdFwiKSA9PiB7XG4gICAgY29uc3Qgc3BhbklkID0gdGltZXJNYXAuZ2V0KGxhYmVsKTtcbiAgICBpZiAoc3BhbklkID09PSB2b2lkIDApIHtcbiAgICAgIHN5cy5jb25zb2xlX2xvZyhjb25zb2xlX2xldmVsX3dhcm4sIGBUaW1lciAnJHtsYWJlbH0nIGRvZXMgbm90IGV4aXN0LmApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzeXMuY29uc29sZV90aW1lcl9lbmQoc3BhbklkKTtcbiAgICB0aW1lck1hcC5kZWxldGUobGFiZWwpO1xuICB9LFxuICAvLyBBZGRpdGlvbmFsIGNvbnNvbGUgbWV0aG9kcyB0byBzYXRpc2Z5IHRoZSBDb25zb2xlIGludGVyZmFjZVxuICB0aW1lU3RhbXA6ICgpID0+IHtcbiAgfSxcbiAgcHJvZmlsZTogKCkgPT4ge1xuICB9LFxuICBwcm9maWxlRW5kOiAoKSA9PiB7XG4gIH1cbn07XG5jb25zb2xlMi5Db25zb2xlID0gY29uc29sZTI7XG5nbG9iYWxUaGlzLmNvbnNvbGUgPSBjb25zb2xlMjtcblxuLy8gc3JjL3NlcnZlci9yZWdpc3Rlcl9ob29rcy50c1xucmVnaXN0ZXJfaG9va3MoaG9va3MpO1xucmVnaXN0ZXJfaG9va3MkMShob29rc192MV8xKTtcbnJlZ2lzdGVyX2hvb2tzJDIoaG9va3NfdjFfMik7XG4vKiEgQnVuZGxlZCBsaWNlbnNlIGluZm9ybWF0aW9uOlxuXG5zdGF0dXNlcy9pbmRleC5qczpcbiAgKCohXG4gICAqIHN0YXR1c2VzXG4gICAqIENvcHlyaWdodChjKSAyMDE0IEpvbmF0aGFuIE9uZ1xuICAgKiBDb3B5cmlnaHQoYykgMjAxNiBEb3VnbGFzIENocmlzdG9waGVyIFdpbHNvblxuICAgKiBNSVQgTGljZW5zZWRcbiAgICopXG4qL1xuXG5leHBvcnQgeyBBcnJheUJ1aWxkZXIsIEFycmF5Q29sdW1uQnVpbGRlciwgQm9vbEJ1aWxkZXIsIEJvb2xDb2x1bW5CdWlsZGVyLCBCeXRlQXJyYXlCdWlsZGVyLCBCeXRlQXJyYXlDb2x1bW5CdWlsZGVyLCBDb2x1bW5CdWlsZGVyLCBDb25uZWN0aW9uSWRCdWlsZGVyLCBDb25uZWN0aW9uSWRDb2x1bW5CdWlsZGVyLCBGMzJCdWlsZGVyLCBGMzJDb2x1bW5CdWlsZGVyLCBGNjRCdWlsZGVyLCBGNjRDb2x1bW5CdWlsZGVyLCBJMTI4QnVpbGRlciwgSTEyOENvbHVtbkJ1aWxkZXIsIEkxNkJ1aWxkZXIsIEkxNkNvbHVtbkJ1aWxkZXIsIEkyNTZCdWlsZGVyLCBJMjU2Q29sdW1uQnVpbGRlciwgSTMyQnVpbGRlciwgSTMyQ29sdW1uQnVpbGRlciwgSTY0QnVpbGRlciwgSTY0Q29sdW1uQnVpbGRlciwgSThCdWlsZGVyLCBJOENvbHVtbkJ1aWxkZXIsIElkZW50aXR5QnVpbGRlciwgSWRlbnRpdHlDb2x1bW5CdWlsZGVyLCBPcHRpb25CdWlsZGVyLCBPcHRpb25Db2x1bW5CdWlsZGVyLCBQcm9kdWN0QnVpbGRlciwgUHJvZHVjdENvbHVtbkJ1aWxkZXIsIFJlZkJ1aWxkZXIsIFJlc3VsdEJ1aWxkZXIsIFJlc3VsdENvbHVtbkJ1aWxkZXIsIFJvd0J1aWxkZXIsIFNjaGVkdWxlQXRCdWlsZGVyLCBTY2hlZHVsZUF0Q29sdW1uQnVpbGRlciwgU2VuZGVyRXJyb3IsIFNpbXBsZVN1bUJ1aWxkZXIsIFNpbXBsZVN1bUNvbHVtbkJ1aWxkZXIsIFNwYWNldGltZUhvc3RFcnJvciwgU3RyaW5nQnVpbGRlciwgU3RyaW5nQ29sdW1uQnVpbGRlciwgU3VtQnVpbGRlciwgU3VtQ29sdW1uQnVpbGRlciwgVGltZUR1cmF0aW9uQnVpbGRlciwgVGltZUR1cmF0aW9uQ29sdW1uQnVpbGRlciwgVGltZXN0YW1wQnVpbGRlciwgVGltZXN0YW1wQ29sdW1uQnVpbGRlciwgVHlwZUJ1aWxkZXIsIFUxMjhCdWlsZGVyLCBVMTI4Q29sdW1uQnVpbGRlciwgVTE2QnVpbGRlciwgVTE2Q29sdW1uQnVpbGRlciwgVTI1NkJ1aWxkZXIsIFUyNTZDb2x1bW5CdWlsZGVyLCBVMzJCdWlsZGVyLCBVMzJDb2x1bW5CdWlsZGVyLCBVNjRCdWlsZGVyLCBVNjRDb2x1bW5CdWlsZGVyLCBVOEJ1aWxkZXIsIFU4Q29sdW1uQnVpbGRlciwgVXVpZEJ1aWxkZXIsIFV1aWRDb2x1bW5CdWlsZGVyLCBhbmQsIGVycm9ycywgbm90LCBvciwgcmVkdWNlcnMsIHNjaGVtYSwgdCwgdGFibGUsIHRvQ2FtZWxDYXNlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJlZ2V4cENvZGUgPSBleHBvcnRzLmdldEVzbUV4cG9ydE5hbWUgPSBleHBvcnRzLmdldFByb3BlcnR5ID0gZXhwb3J0cy5zYWZlU3RyaW5naWZ5ID0gZXhwb3J0cy5zdHJpbmdpZnkgPSBleHBvcnRzLnN0ckNvbmNhdCA9IGV4cG9ydHMuYWRkQ29kZUFyZyA9IGV4cG9ydHMuc3RyID0gZXhwb3J0cy5fID0gZXhwb3J0cy5uaWwgPSBleHBvcnRzLl9Db2RlID0gZXhwb3J0cy5OYW1lID0gZXhwb3J0cy5JREVOVElGSUVSID0gZXhwb3J0cy5fQ29kZU9yTmFtZSA9IHZvaWQgMDtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXh0cmFuZW91cy1jbGFzc1xuY2xhc3MgX0NvZGVPck5hbWUge1xufVxuZXhwb3J0cy5fQ29kZU9yTmFtZSA9IF9Db2RlT3JOYW1lO1xuZXhwb3J0cy5JREVOVElGSUVSID0gL15bYS16JF9dW2EteiRfMC05XSokL2k7XG5jbGFzcyBOYW1lIGV4dGVuZHMgX0NvZGVPck5hbWUge1xuICAgIGNvbnN0cnVjdG9yKHMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgaWYgKCFleHBvcnRzLklERU5USUZJRVIudGVzdChzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvZGVHZW46IG5hbWUgbXVzdCBiZSBhIHZhbGlkIGlkZW50aWZpZXJcIik7XG4gICAgICAgIHRoaXMuc3RyID0gcztcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cjtcbiAgICB9XG4gICAgZW1wdHlTdHIoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICByZXR1cm4geyBbdGhpcy5zdHJdOiAxIH07XG4gICAgfVxufVxuZXhwb3J0cy5OYW1lID0gTmFtZTtcbmNsYXNzIF9Db2RlIGV4dGVuZHMgX0NvZGVPck5hbWUge1xuICAgIGNvbnN0cnVjdG9yKGNvZGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5faXRlbXMgPSB0eXBlb2YgY29kZSA9PT0gXCJzdHJpbmdcIiA/IFtjb2RlXSA6IGNvZGU7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHI7XG4gICAgfVxuICAgIGVtcHR5U3RyKCkge1xuICAgICAgICBpZiAodGhpcy5faXRlbXMubGVuZ3RoID4gMSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuX2l0ZW1zWzBdO1xuICAgICAgICByZXR1cm4gaXRlbSA9PT0gXCJcIiB8fCBpdGVtID09PSAnXCJcIic7XG4gICAgfVxuICAgIGdldCBzdHIoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSB0aGlzLl9zdHIpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICh0aGlzLl9zdHIgPSB0aGlzLl9pdGVtcy5yZWR1Y2UoKHMsIGMpID0+IGAke3N9JHtjfWAsIFwiXCIpKSk7XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IHRoaXMuX25hbWVzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAodGhpcy5fbmFtZXMgPSB0aGlzLl9pdGVtcy5yZWR1Y2UoKG5hbWVzLCBjKSA9PiB7XG4gICAgICAgICAgICBpZiAoYyBpbnN0YW5jZW9mIE5hbWUpXG4gICAgICAgICAgICAgICAgbmFtZXNbYy5zdHJdID0gKG5hbWVzW2Muc3RyXSB8fCAwKSArIDE7XG4gICAgICAgICAgICByZXR1cm4gbmFtZXM7XG4gICAgICAgIH0sIHt9KSkpO1xuICAgIH1cbn1cbmV4cG9ydHMuX0NvZGUgPSBfQ29kZTtcbmV4cG9ydHMubmlsID0gbmV3IF9Db2RlKFwiXCIpO1xuZnVuY3Rpb24gXyhzdHJzLCAuLi5hcmdzKSB7XG4gICAgY29uc3QgY29kZSA9IFtzdHJzWzBdXTtcbiAgICBsZXQgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBhcmdzLmxlbmd0aCkge1xuICAgICAgICBhZGRDb2RlQXJnKGNvZGUsIGFyZ3NbaV0pO1xuICAgICAgICBjb2RlLnB1c2goc3Ryc1srK2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBfQ29kZShjb2RlKTtcbn1cbmV4cG9ydHMuXyA9IF87XG5jb25zdCBwbHVzID0gbmV3IF9Db2RlKFwiK1wiKTtcbmZ1bmN0aW9uIHN0cihzdHJzLCAuLi5hcmdzKSB7XG4gICAgY29uc3QgZXhwciA9IFtzYWZlU3RyaW5naWZ5KHN0cnNbMF0pXTtcbiAgICBsZXQgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBhcmdzLmxlbmd0aCkge1xuICAgICAgICBleHByLnB1c2gocGx1cyk7XG4gICAgICAgIGFkZENvZGVBcmcoZXhwciwgYXJnc1tpXSk7XG4gICAgICAgIGV4cHIucHVzaChwbHVzLCBzYWZlU3RyaW5naWZ5KHN0cnNbKytpXSkpO1xuICAgIH1cbiAgICBvcHRpbWl6ZShleHByKTtcbiAgICByZXR1cm4gbmV3IF9Db2RlKGV4cHIpO1xufVxuZXhwb3J0cy5zdHIgPSBzdHI7XG5mdW5jdGlvbiBhZGRDb2RlQXJnKGNvZGUsIGFyZykge1xuICAgIGlmIChhcmcgaW5zdGFuY2VvZiBfQ29kZSlcbiAgICAgICAgY29kZS5wdXNoKC4uLmFyZy5faXRlbXMpO1xuICAgIGVsc2UgaWYgKGFyZyBpbnN0YW5jZW9mIE5hbWUpXG4gICAgICAgIGNvZGUucHVzaChhcmcpO1xuICAgIGVsc2VcbiAgICAgICAgY29kZS5wdXNoKGludGVycG9sYXRlKGFyZykpO1xufVxuZXhwb3J0cy5hZGRDb2RlQXJnID0gYWRkQ29kZUFyZztcbmZ1bmN0aW9uIG9wdGltaXplKGV4cHIpIHtcbiAgICBsZXQgaSA9IDE7XG4gICAgd2hpbGUgKGkgPCBleHByLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgaWYgKGV4cHJbaV0gPT09IHBsdXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IG1lcmdlRXhwckl0ZW1zKGV4cHJbaSAtIDFdLCBleHByW2kgKyAxXSk7XG4gICAgICAgICAgICBpZiAocmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBleHByLnNwbGljZShpIC0gMSwgMywgcmVzKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4cHJbaSsrXSA9IFwiK1wiO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICB9XG59XG5mdW5jdGlvbiBtZXJnZUV4cHJJdGVtcyhhLCBiKSB7XG4gICAgaWYgKGIgPT09ICdcIlwiJylcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgaWYgKGEgPT09ICdcIlwiJylcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgaWYgKHR5cGVvZiBhID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKGIgaW5zdGFuY2VvZiBOYW1lIHx8IGFbYS5sZW5ndGggLSAxXSAhPT0gJ1wiJylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9IFwic3RyaW5nXCIpXG4gICAgICAgICAgICByZXR1cm4gYCR7YS5zbGljZSgwLCAtMSl9JHtifVwiYDtcbiAgICAgICAgaWYgKGJbMF0gPT09ICdcIicpXG4gICAgICAgICAgICByZXR1cm4gYS5zbGljZSgwLCAtMSkgKyBiLnNsaWNlKDEpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYiA9PSBcInN0cmluZ1wiICYmIGJbMF0gPT09ICdcIicgJiYgIShhIGluc3RhbmNlb2YgTmFtZSkpXG4gICAgICAgIHJldHVybiBgXCIke2F9JHtiLnNsaWNlKDEpfWA7XG4gICAgcmV0dXJuO1xufVxuZnVuY3Rpb24gc3RyQ29uY2F0KGMxLCBjMikge1xuICAgIHJldHVybiBjMi5lbXB0eVN0cigpID8gYzEgOiBjMS5lbXB0eVN0cigpID8gYzIgOiBzdHIgYCR7YzF9JHtjMn1gO1xufVxuZXhwb3J0cy5zdHJDb25jYXQgPSBzdHJDb25jYXQ7XG4vLyBUT0RPIGRvIG5vdCBhbGxvdyBhcnJheXMgaGVyZVxuZnVuY3Rpb24gaW50ZXJwb2xhdGUoeCkge1xuICAgIHJldHVybiB0eXBlb2YgeCA9PSBcIm51bWJlclwiIHx8IHR5cGVvZiB4ID09IFwiYm9vbGVhblwiIHx8IHggPT09IG51bGxcbiAgICAgICAgPyB4XG4gICAgICAgIDogc2FmZVN0cmluZ2lmeShBcnJheS5pc0FycmF5KHgpID8geC5qb2luKFwiLFwiKSA6IHgpO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5KHgpIHtcbiAgICByZXR1cm4gbmV3IF9Db2RlKHNhZmVTdHJpbmdpZnkoeCkpO1xufVxuZXhwb3J0cy5zdHJpbmdpZnkgPSBzdHJpbmdpZnk7XG5mdW5jdGlvbiBzYWZlU3RyaW5naWZ5KHgpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoeClcbiAgICAgICAgLnJlcGxhY2UoL1xcdTIwMjgvZywgXCJcXFxcdTIwMjhcIilcbiAgICAgICAgLnJlcGxhY2UoL1xcdTIwMjkvZywgXCJcXFxcdTIwMjlcIik7XG59XG5leHBvcnRzLnNhZmVTdHJpbmdpZnkgPSBzYWZlU3RyaW5naWZ5O1xuZnVuY3Rpb24gZ2V0UHJvcGVydHkoa2V5KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBrZXkgPT0gXCJzdHJpbmdcIiAmJiBleHBvcnRzLklERU5USUZJRVIudGVzdChrZXkpID8gbmV3IF9Db2RlKGAuJHtrZXl9YCkgOiBfIGBbJHtrZXl9XWA7XG59XG5leHBvcnRzLmdldFByb3BlcnR5ID0gZ2V0UHJvcGVydHk7XG4vL0RvZXMgYmVzdCBlZmZvcnQgdG8gZm9ybWF0IHRoZSBuYW1lIHByb3Blcmx5XG5mdW5jdGlvbiBnZXRFc21FeHBvcnROYW1lKGtleSkge1xuICAgIGlmICh0eXBlb2Yga2V5ID09IFwic3RyaW5nXCIgJiYgZXhwb3J0cy5JREVOVElGSUVSLnRlc3Qoa2V5KSkge1xuICAgICAgICByZXR1cm4gbmV3IF9Db2RlKGAke2tleX1gKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb2RlR2VuOiBpbnZhbGlkIGV4cG9ydCBuYW1lOiAke2tleX0sIHVzZSBleHBsaWNpdCAkaWQgbmFtZSBtYXBwaW5nYCk7XG59XG5leHBvcnRzLmdldEVzbUV4cG9ydE5hbWUgPSBnZXRFc21FeHBvcnROYW1lO1xuZnVuY3Rpb24gcmVnZXhwQ29kZShyeCkge1xuICAgIHJldHVybiBuZXcgX0NvZGUocngudG9TdHJpbmcoKSk7XG59XG5leHBvcnRzLnJlZ2V4cENvZGUgPSByZWdleHBDb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29kZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVmFsdWVTY29wZSA9IGV4cG9ydHMuVmFsdWVTY29wZU5hbWUgPSBleHBvcnRzLlNjb3BlID0gZXhwb3J0cy52YXJLaW5kcyA9IGV4cG9ydHMuVXNlZFZhbHVlU3RhdGUgPSB2b2lkIDA7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi9jb2RlXCIpO1xuY2xhc3MgVmFsdWVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgICAgIHN1cGVyKGBDb2RlR2VuOiBcImNvZGVcIiBmb3IgJHtuYW1lfSBub3QgZGVmaW5lZGApO1xuICAgICAgICB0aGlzLnZhbHVlID0gbmFtZS52YWx1ZTtcbiAgICB9XG59XG52YXIgVXNlZFZhbHVlU3RhdGU7XG4oZnVuY3Rpb24gKFVzZWRWYWx1ZVN0YXRlKSB7XG4gICAgVXNlZFZhbHVlU3RhdGVbVXNlZFZhbHVlU3RhdGVbXCJTdGFydGVkXCJdID0gMF0gPSBcIlN0YXJ0ZWRcIjtcbiAgICBVc2VkVmFsdWVTdGF0ZVtVc2VkVmFsdWVTdGF0ZVtcIkNvbXBsZXRlZFwiXSA9IDFdID0gXCJDb21wbGV0ZWRcIjtcbn0pKFVzZWRWYWx1ZVN0YXRlIHx8IChleHBvcnRzLlVzZWRWYWx1ZVN0YXRlID0gVXNlZFZhbHVlU3RhdGUgPSB7fSkpO1xuZXhwb3J0cy52YXJLaW5kcyA9IHtcbiAgICBjb25zdDogbmV3IGNvZGVfMS5OYW1lKFwiY29uc3RcIiksXG4gICAgbGV0OiBuZXcgY29kZV8xLk5hbWUoXCJsZXRcIiksXG4gICAgdmFyOiBuZXcgY29kZV8xLk5hbWUoXCJ2YXJcIiksXG59O1xuY2xhc3MgU2NvcGUge1xuICAgIGNvbnN0cnVjdG9yKHsgcHJlZml4ZXMsIHBhcmVudCB9ID0ge30pIHtcbiAgICAgICAgdGhpcy5fbmFtZXMgPSB7fTtcbiAgICAgICAgdGhpcy5fcHJlZml4ZXMgPSBwcmVmaXhlcztcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICAgIH1cbiAgICB0b05hbWUobmFtZU9yUHJlZml4KSB7XG4gICAgICAgIHJldHVybiBuYW1lT3JQcmVmaXggaW5zdGFuY2VvZiBjb2RlXzEuTmFtZSA/IG5hbWVPclByZWZpeCA6IHRoaXMubmFtZShuYW1lT3JQcmVmaXgpO1xuICAgIH1cbiAgICBuYW1lKHByZWZpeCkge1xuICAgICAgICByZXR1cm4gbmV3IGNvZGVfMS5OYW1lKHRoaXMuX25ld05hbWUocHJlZml4KSk7XG4gICAgfVxuICAgIF9uZXdOYW1lKHByZWZpeCkge1xuICAgICAgICBjb25zdCBuZyA9IHRoaXMuX25hbWVzW3ByZWZpeF0gfHwgdGhpcy5fbmFtZUdyb3VwKHByZWZpeCk7XG4gICAgICAgIHJldHVybiBgJHtwcmVmaXh9JHtuZy5pbmRleCsrfWA7XG4gICAgfVxuICAgIF9uYW1lR3JvdXAocHJlZml4KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICgoKF9iID0gKF9hID0gdGhpcy5fcGFyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuX3ByZWZpeGVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaGFzKHByZWZpeCkpIHx8ICh0aGlzLl9wcmVmaXhlcyAmJiAhdGhpcy5fcHJlZml4ZXMuaGFzKHByZWZpeCkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvZGVHZW46IHByZWZpeCBcIiR7cHJlZml4fVwiIGlzIG5vdCBhbGxvd2VkIGluIHRoaXMgc2NvcGVgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHRoaXMuX25hbWVzW3ByZWZpeF0gPSB7IHByZWZpeCwgaW5kZXg6IDAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5TY29wZSA9IFNjb3BlO1xuY2xhc3MgVmFsdWVTY29wZU5hbWUgZXh0ZW5kcyBjb2RlXzEuTmFtZSB7XG4gICAgY29uc3RydWN0b3IocHJlZml4LCBuYW1lU3RyKSB7XG4gICAgICAgIHN1cGVyKG5hbWVTdHIpO1xuICAgICAgICB0aGlzLnByZWZpeCA9IHByZWZpeDtcbiAgICB9XG4gICAgc2V0VmFsdWUodmFsdWUsIHsgcHJvcGVydHksIGl0ZW1JbmRleCB9KSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zY29wZVBhdGggPSAoMCwgY29kZV8xLl8pIGAuJHtuZXcgY29kZV8xLk5hbWUocHJvcGVydHkpfVske2l0ZW1JbmRleH1dYDtcbiAgICB9XG59XG5leHBvcnRzLlZhbHVlU2NvcGVOYW1lID0gVmFsdWVTY29wZU5hbWU7XG5jb25zdCBsaW5lID0gKDAsIGNvZGVfMS5fKSBgXFxuYDtcbmNsYXNzIFZhbHVlU2NvcGUgZXh0ZW5kcyBTY29wZSB7XG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBzdXBlcihvcHRzKTtcbiAgICAgICAgdGhpcy5fdmFsdWVzID0ge307XG4gICAgICAgIHRoaXMuX3Njb3BlID0gb3B0cy5zY29wZTtcbiAgICAgICAgdGhpcy5vcHRzID0geyAuLi5vcHRzLCBfbjogb3B0cy5saW5lcyA/IGxpbmUgOiBjb2RlXzEubmlsIH07XG4gICAgfVxuICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Njb3BlO1xuICAgIH1cbiAgICBuYW1lKHByZWZpeCkge1xuICAgICAgICByZXR1cm4gbmV3IFZhbHVlU2NvcGVOYW1lKHByZWZpeCwgdGhpcy5fbmV3TmFtZShwcmVmaXgpKTtcbiAgICB9XG4gICAgdmFsdWUobmFtZU9yUHJlZml4LCB2YWx1ZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh2YWx1ZS5yZWYgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvZGVHZW46IHJlZiBtdXN0IGJlIHBhc3NlZCBpbiB2YWx1ZVwiKTtcbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMudG9OYW1lKG5hbWVPclByZWZpeCk7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4IH0gPSBuYW1lO1xuICAgICAgICBjb25zdCB2YWx1ZUtleSA9IChfYSA9IHZhbHVlLmtleSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdmFsdWUucmVmO1xuICAgICAgICBsZXQgdnMgPSB0aGlzLl92YWx1ZXNbcHJlZml4XTtcbiAgICAgICAgaWYgKHZzKSB7XG4gICAgICAgICAgICBjb25zdCBfbmFtZSA9IHZzLmdldCh2YWx1ZUtleSk7XG4gICAgICAgICAgICBpZiAoX25hbWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9uYW1lO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdnMgPSB0aGlzLl92YWx1ZXNbcHJlZml4XSA9IG5ldyBNYXAoKTtcbiAgICAgICAgfVxuICAgICAgICB2cy5zZXQodmFsdWVLZXksIG5hbWUpO1xuICAgICAgICBjb25zdCBzID0gdGhpcy5fc2NvcGVbcHJlZml4XSB8fCAodGhpcy5fc2NvcGVbcHJlZml4XSA9IFtdKTtcbiAgICAgICAgY29uc3QgaXRlbUluZGV4ID0gcy5sZW5ndGg7XG4gICAgICAgIHNbaXRlbUluZGV4XSA9IHZhbHVlLnJlZjtcbiAgICAgICAgbmFtZS5zZXRWYWx1ZSh2YWx1ZSwgeyBwcm9wZXJ0eTogcHJlZml4LCBpdGVtSW5kZXggfSk7XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbiAgICBnZXRWYWx1ZShwcmVmaXgsIGtleU9yUmVmKSB7XG4gICAgICAgIGNvbnN0IHZzID0gdGhpcy5fdmFsdWVzW3ByZWZpeF07XG4gICAgICAgIGlmICghdnMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHJldHVybiB2cy5nZXQoa2V5T3JSZWYpO1xuICAgIH1cbiAgICBzY29wZVJlZnMoc2NvcGVOYW1lLCB2YWx1ZXMgPSB0aGlzLl92YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZHVjZVZhbHVlcyh2YWx1ZXMsIChuYW1lKSA9PiB7XG4gICAgICAgICAgICBpZiAobmFtZS5zY29wZVBhdGggPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvZGVHZW46IG5hbWUgXCIke25hbWV9XCIgaGFzIG5vIHZhbHVlYCk7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGNvZGVfMS5fKSBgJHtzY29wZU5hbWV9JHtuYW1lLnNjb3BlUGF0aH1gO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2NvcGVDb2RlKHZhbHVlcyA9IHRoaXMuX3ZhbHVlcywgdXNlZFZhbHVlcywgZ2V0Q29kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVkdWNlVmFsdWVzKHZhbHVlcywgKG5hbWUpID0+IHtcbiAgICAgICAgICAgIGlmIChuYW1lLnZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb2RlR2VuOiBuYW1lIFwiJHtuYW1lfVwiIGhhcyBubyB2YWx1ZWApO1xuICAgICAgICAgICAgcmV0dXJuIG5hbWUudmFsdWUuY29kZTtcbiAgICAgICAgfSwgdXNlZFZhbHVlcywgZ2V0Q29kZSk7XG4gICAgfVxuICAgIF9yZWR1Y2VWYWx1ZXModmFsdWVzLCB2YWx1ZUNvZGUsIHVzZWRWYWx1ZXMgPSB7fSwgZ2V0Q29kZSkge1xuICAgICAgICBsZXQgY29kZSA9IGNvZGVfMS5uaWw7XG4gICAgICAgIGZvciAoY29uc3QgcHJlZml4IGluIHZhbHVlcykge1xuICAgICAgICAgICAgY29uc3QgdnMgPSB2YWx1ZXNbcHJlZml4XTtcbiAgICAgICAgICAgIGlmICghdnMpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCBuYW1lU2V0ID0gKHVzZWRWYWx1ZXNbcHJlZml4XSA9IHVzZWRWYWx1ZXNbcHJlZml4XSB8fCBuZXcgTWFwKCkpO1xuICAgICAgICAgICAgdnMuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChuYW1lU2V0LmhhcyhuYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIG5hbWVTZXQuc2V0KG5hbWUsIFVzZWRWYWx1ZVN0YXRlLlN0YXJ0ZWQpO1xuICAgICAgICAgICAgICAgIGxldCBjID0gdmFsdWVDb2RlKG5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChjKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlZiA9IHRoaXMub3B0cy5lczUgPyBleHBvcnRzLnZhcktpbmRzLnZhciA6IGV4cG9ydHMudmFyS2luZHMuY29uc3Q7XG4gICAgICAgICAgICAgICAgICAgIGNvZGUgPSAoMCwgY29kZV8xLl8pIGAke2NvZGV9JHtkZWZ9ICR7bmFtZX0gPSAke2N9OyR7dGhpcy5vcHRzLl9ufWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChjID0gZ2V0Q29kZSA9PT0gbnVsbCB8fCBnZXRDb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBnZXRDb2RlKG5hbWUpKSkge1xuICAgICAgICAgICAgICAgICAgICBjb2RlID0gKDAsIGNvZGVfMS5fKSBgJHtjb2RlfSR7Y30ke3RoaXMub3B0cy5fbn1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IobmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5hbWVTZXQuc2V0KG5hbWUsIFVzZWRWYWx1ZVN0YXRlLkNvbXBsZXRlZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29kZTtcbiAgICB9XG59XG5leHBvcnRzLlZhbHVlU2NvcGUgPSBWYWx1ZVNjb3BlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2NvcGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm9yID0gZXhwb3J0cy5hbmQgPSBleHBvcnRzLm5vdCA9IGV4cG9ydHMuQ29kZUdlbiA9IGV4cG9ydHMub3BlcmF0b3JzID0gZXhwb3J0cy52YXJLaW5kcyA9IGV4cG9ydHMuVmFsdWVTY29wZU5hbWUgPSBleHBvcnRzLlZhbHVlU2NvcGUgPSBleHBvcnRzLlNjb3BlID0gZXhwb3J0cy5OYW1lID0gZXhwb3J0cy5yZWdleHBDb2RlID0gZXhwb3J0cy5zdHJpbmdpZnkgPSBleHBvcnRzLmdldFByb3BlcnR5ID0gZXhwb3J0cy5uaWwgPSBleHBvcnRzLnN0ckNvbmNhdCA9IGV4cG9ydHMuc3RyID0gZXhwb3J0cy5fID0gdm9pZCAwO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4vY29kZVwiKTtcbmNvbnN0IHNjb3BlXzEgPSByZXF1aXJlKFwiLi9zY29wZVwiKTtcbnZhciBjb2RlXzIgPSByZXF1aXJlKFwiLi9jb2RlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZV8yLl87IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdHJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVfMi5zdHI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdHJDb25jYXRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVfMi5zdHJDb25jYXQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJuaWxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVfMi5uaWw7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRQcm9wZXJ0eVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZV8yLmdldFByb3BlcnR5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyaW5naWZ5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlXzIuc3RyaW5naWZ5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVnZXhwQ29kZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZV8yLnJlZ2V4cENvZGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOYW1lXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlXzIuTmFtZTsgfSB9KTtcbnZhciBzY29wZV8yID0gcmVxdWlyZShcIi4vc2NvcGVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTY29wZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2NvcGVfMi5TY29wZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlZhbHVlU2NvcGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNjb3BlXzIuVmFsdWVTY29wZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlZhbHVlU2NvcGVOYW1lXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzY29wZV8yLlZhbHVlU2NvcGVOYW1lOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidmFyS2luZHNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNjb3BlXzIudmFyS2luZHM7IH0gfSk7XG5leHBvcnRzLm9wZXJhdG9ycyA9IHtcbiAgICBHVDogbmV3IGNvZGVfMS5fQ29kZShcIj5cIiksXG4gICAgR1RFOiBuZXcgY29kZV8xLl9Db2RlKFwiPj1cIiksXG4gICAgTFQ6IG5ldyBjb2RlXzEuX0NvZGUoXCI8XCIpLFxuICAgIExURTogbmV3IGNvZGVfMS5fQ29kZShcIjw9XCIpLFxuICAgIEVROiBuZXcgY29kZV8xLl9Db2RlKFwiPT09XCIpLFxuICAgIE5FUTogbmV3IGNvZGVfMS5fQ29kZShcIiE9PVwiKSxcbiAgICBOT1Q6IG5ldyBjb2RlXzEuX0NvZGUoXCIhXCIpLFxuICAgIE9SOiBuZXcgY29kZV8xLl9Db2RlKFwifHxcIiksXG4gICAgQU5EOiBuZXcgY29kZV8xLl9Db2RlKFwiJiZcIiksXG4gICAgQUREOiBuZXcgY29kZV8xLl9Db2RlKFwiK1wiKSxcbn07XG5jbGFzcyBOb2RlIHtcbiAgICBvcHRpbWl6ZU5vZGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgb3B0aW1pemVOYW1lcyhfbmFtZXMsIF9jb25zdGFudHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuY2xhc3MgRGVmIGV4dGVuZHMgTm9kZSB7XG4gICAgY29uc3RydWN0b3IodmFyS2luZCwgbmFtZSwgcmhzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudmFyS2luZCA9IHZhcktpbmQ7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMucmhzID0gcmhzO1xuICAgIH1cbiAgICByZW5kZXIoeyBlczUsIF9uIH0pIHtcbiAgICAgICAgY29uc3QgdmFyS2luZCA9IGVzNSA/IHNjb3BlXzEudmFyS2luZHMudmFyIDogdGhpcy52YXJLaW5kO1xuICAgICAgICBjb25zdCByaHMgPSB0aGlzLnJocyA9PT0gdW5kZWZpbmVkID8gXCJcIiA6IGAgPSAke3RoaXMucmhzfWA7XG4gICAgICAgIHJldHVybiBgJHt2YXJLaW5kfSAke3RoaXMubmFtZX0ke3Joc307YCArIF9uO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpIHtcbiAgICAgICAgaWYgKCFuYW1lc1t0aGlzLm5hbWUuc3RyXSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMucmhzKVxuICAgICAgICAgICAgdGhpcy5yaHMgPSBvcHRpbWl6ZUV4cHIodGhpcy5yaHMsIG5hbWVzLCBjb25zdGFudHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yaHMgaW5zdGFuY2VvZiBjb2RlXzEuX0NvZGVPck5hbWUgPyB0aGlzLnJocy5uYW1lcyA6IHt9O1xuICAgIH1cbn1cbmNsYXNzIEFzc2lnbiBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKGxocywgcmhzLCBzaWRlRWZmZWN0cykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmxocyA9IGxocztcbiAgICAgICAgdGhpcy5yaHMgPSByaHM7XG4gICAgICAgIHRoaXMuc2lkZUVmZmVjdHMgPSBzaWRlRWZmZWN0cztcbiAgICB9XG4gICAgcmVuZGVyKHsgX24gfSkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5saHN9ID0gJHt0aGlzLnJoc307YCArIF9uO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpIHtcbiAgICAgICAgaWYgKHRoaXMubGhzIGluc3RhbmNlb2YgY29kZV8xLk5hbWUgJiYgIW5hbWVzW3RoaXMubGhzLnN0cl0gJiYgIXRoaXMuc2lkZUVmZmVjdHMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMucmhzID0gb3B0aW1pemVFeHByKHRoaXMucmhzLCBuYW1lcywgY29uc3RhbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgY29uc3QgbmFtZXMgPSB0aGlzLmxocyBpbnN0YW5jZW9mIGNvZGVfMS5OYW1lID8ge30gOiB7IC4uLnRoaXMubGhzLm5hbWVzIH07XG4gICAgICAgIHJldHVybiBhZGRFeHByTmFtZXMobmFtZXMsIHRoaXMucmhzKTtcbiAgICB9XG59XG5jbGFzcyBBc3NpZ25PcCBleHRlbmRzIEFzc2lnbiB7XG4gICAgY29uc3RydWN0b3IobGhzLCBvcCwgcmhzLCBzaWRlRWZmZWN0cykge1xuICAgICAgICBzdXBlcihsaHMsIHJocywgc2lkZUVmZmVjdHMpO1xuICAgICAgICB0aGlzLm9wID0gb3A7XG4gICAgfVxuICAgIHJlbmRlcih7IF9uIH0pIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMubGhzfSAke3RoaXMub3B9PSAke3RoaXMucmhzfTtgICsgX247XG4gICAgfVxufVxuY2xhc3MgTGFiZWwgZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihsYWJlbCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmxhYmVsID0gbGFiZWw7XG4gICAgICAgIHRoaXMubmFtZXMgPSB7fTtcbiAgICB9XG4gICAgcmVuZGVyKHsgX24gfSkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5sYWJlbH06YCArIF9uO1xuICAgIH1cbn1cbmNsYXNzIEJyZWFrIGV4dGVuZHMgTm9kZSB7XG4gICAgY29uc3RydWN0b3IobGFiZWwpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xuICAgICAgICB0aGlzLm5hbWVzID0ge307XG4gICAgfVxuICAgIHJlbmRlcih7IF9uIH0pIHtcbiAgICAgICAgY29uc3QgbGFiZWwgPSB0aGlzLmxhYmVsID8gYCAke3RoaXMubGFiZWx9YCA6IFwiXCI7XG4gICAgICAgIHJldHVybiBgYnJlYWske2xhYmVsfTtgICsgX247XG4gICAgfVxufVxuY2xhc3MgVGhyb3cgZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihlcnJvcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgfVxuICAgIHJlbmRlcih7IF9uIH0pIHtcbiAgICAgICAgcmV0dXJuIGB0aHJvdyAke3RoaXMuZXJyb3J9O2AgKyBfbjtcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lcnJvci5uYW1lcztcbiAgICB9XG59XG5jbGFzcyBBbnlDb2RlIGV4dGVuZHMgTm9kZSB7XG4gICAgY29uc3RydWN0b3IoY29kZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIH1cbiAgICByZW5kZXIoeyBfbiB9KSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmNvZGV9O2AgKyBfbjtcbiAgICB9XG4gICAgb3B0aW1pemVOb2RlcygpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuY29kZX1gID8gdGhpcyA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgb3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSB7XG4gICAgICAgIHRoaXMuY29kZSA9IG9wdGltaXplRXhwcih0aGlzLmNvZGUsIG5hbWVzLCBjb25zdGFudHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2RlIGluc3RhbmNlb2YgY29kZV8xLl9Db2RlT3JOYW1lID8gdGhpcy5jb2RlLm5hbWVzIDoge307XG4gICAgfVxufVxuY2xhc3MgUGFyZW50Tm9kZSBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKG5vZGVzID0gW10pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5ub2RlcyA9IG5vZGVzO1xuICAgIH1cbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2Rlcy5yZWR1Y2UoKGNvZGUsIG4pID0+IGNvZGUgKyBuLnJlbmRlcihvcHRzKSwgXCJcIik7XG4gICAgfVxuICAgIG9wdGltaXplTm9kZXMoKSB7XG4gICAgICAgIGNvbnN0IHsgbm9kZXMgfSA9IHRoaXM7XG4gICAgICAgIGxldCBpID0gbm9kZXMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICBjb25zdCBuID0gbm9kZXNbaV0ub3B0aW1pemVOb2RlcygpO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobikpXG4gICAgICAgICAgICAgICAgbm9kZXMuc3BsaWNlKGksIDEsIC4uLm4pO1xuICAgICAgICAgICAgZWxzZSBpZiAobilcbiAgICAgICAgICAgICAgICBub2Rlc1tpXSA9IG47XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbm9kZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2Rlcy5sZW5ndGggPiAwID8gdGhpcyA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgb3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSB7XG4gICAgICAgIGNvbnN0IHsgbm9kZXMgfSA9IHRoaXM7XG4gICAgICAgIGxldCBpID0gbm9kZXMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAvLyBpdGVyYXRpbmcgYmFja3dhcmRzIGltcHJvdmVzIDEtcGFzcyBvcHRpbWl6YXRpb25cbiAgICAgICAgICAgIGNvbnN0IG4gPSBub2Rlc1tpXTtcbiAgICAgICAgICAgIGlmIChuLm9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBzdWJ0cmFjdE5hbWVzKG5hbWVzLCBuLm5hbWVzKTtcbiAgICAgICAgICAgIG5vZGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZXMubGVuZ3RoID4gMCA/IHRoaXMgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZXMucmVkdWNlKChuYW1lcywgbikgPT4gYWRkTmFtZXMobmFtZXMsIG4ubmFtZXMpLCB7fSk7XG4gICAgfVxufVxuY2xhc3MgQmxvY2tOb2RlIGV4dGVuZHMgUGFyZW50Tm9kZSB7XG4gICAgcmVuZGVyKG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIFwie1wiICsgb3B0cy5fbiArIHN1cGVyLnJlbmRlcihvcHRzKSArIFwifVwiICsgb3B0cy5fbjtcbiAgICB9XG59XG5jbGFzcyBSb290IGV4dGVuZHMgUGFyZW50Tm9kZSB7XG59XG5jbGFzcyBFbHNlIGV4dGVuZHMgQmxvY2tOb2RlIHtcbn1cbkVsc2Uua2luZCA9IFwiZWxzZVwiO1xuY2xhc3MgSWYgZXh0ZW5kcyBCbG9ja05vZGUge1xuICAgIGNvbnN0cnVjdG9yKGNvbmRpdGlvbiwgbm9kZXMpIHtcbiAgICAgICAgc3VwZXIobm9kZXMpO1xuICAgICAgICB0aGlzLmNvbmRpdGlvbiA9IGNvbmRpdGlvbjtcbiAgICB9XG4gICAgcmVuZGVyKG9wdHMpIHtcbiAgICAgICAgbGV0IGNvZGUgPSBgaWYoJHt0aGlzLmNvbmRpdGlvbn0pYCArIHN1cGVyLnJlbmRlcihvcHRzKTtcbiAgICAgICAgaWYgKHRoaXMuZWxzZSlcbiAgICAgICAgICAgIGNvZGUgKz0gXCJlbHNlIFwiICsgdGhpcy5lbHNlLnJlbmRlcihvcHRzKTtcbiAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgfVxuICAgIG9wdGltaXplTm9kZXMoKSB7XG4gICAgICAgIHN1cGVyLm9wdGltaXplTm9kZXMoKTtcbiAgICAgICAgY29uc3QgY29uZCA9IHRoaXMuY29uZGl0aW9uO1xuICAgICAgICBpZiAoY29uZCA9PT0gdHJ1ZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vZGVzOyAvLyBlbHNlIGlzIGlnbm9yZWQgaGVyZVxuICAgICAgICBsZXQgZSA9IHRoaXMuZWxzZTtcbiAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgIGNvbnN0IG5zID0gZS5vcHRpbWl6ZU5vZGVzKCk7XG4gICAgICAgICAgICBlID0gdGhpcy5lbHNlID0gQXJyYXkuaXNBcnJheShucykgPyBuZXcgRWxzZShucykgOiBucztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgaWYgKGNvbmQgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgIHJldHVybiBlIGluc3RhbmNlb2YgSWYgPyBlIDogZS5ub2RlcztcbiAgICAgICAgICAgIGlmICh0aGlzLm5vZGVzLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBuZXcgSWYobm90KGNvbmQpLCBlIGluc3RhbmNlb2YgSWYgPyBbZV0gOiBlLm5vZGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZCA9PT0gZmFsc2UgfHwgIXRoaXMubm9kZXMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuZWxzZSA9IChfYSA9IHRoaXMuZWxzZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cyk7XG4gICAgICAgIGlmICghKHN1cGVyLm9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykgfHwgdGhpcy5lbHNlKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5jb25kaXRpb24gPSBvcHRpbWl6ZUV4cHIodGhpcy5jb25kaXRpb24sIG5hbWVzLCBjb25zdGFudHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICBjb25zdCBuYW1lcyA9IHN1cGVyLm5hbWVzO1xuICAgICAgICBhZGRFeHByTmFtZXMobmFtZXMsIHRoaXMuY29uZGl0aW9uKTtcbiAgICAgICAgaWYgKHRoaXMuZWxzZSlcbiAgICAgICAgICAgIGFkZE5hbWVzKG5hbWVzLCB0aGlzLmVsc2UubmFtZXMpO1xuICAgICAgICByZXR1cm4gbmFtZXM7XG4gICAgfVxufVxuSWYua2luZCA9IFwiaWZcIjtcbmNsYXNzIEZvciBleHRlbmRzIEJsb2NrTm9kZSB7XG59XG5Gb3Iua2luZCA9IFwiZm9yXCI7XG5jbGFzcyBGb3JMb29wIGV4dGVuZHMgRm9yIHtcbiAgICBjb25zdHJ1Y3RvcihpdGVyYXRpb24pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5pdGVyYXRpb24gPSBpdGVyYXRpb247XG4gICAgfVxuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIHJldHVybiBgZm9yKCR7dGhpcy5pdGVyYXRpb259KWAgKyBzdXBlci5yZW5kZXIob3B0cyk7XG4gICAgfVxuICAgIG9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykge1xuICAgICAgICBpZiAoIXN1cGVyLm9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuaXRlcmF0aW9uID0gb3B0aW1pemVFeHByKHRoaXMuaXRlcmF0aW9uLCBuYW1lcywgY29uc3RhbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIGFkZE5hbWVzKHN1cGVyLm5hbWVzLCB0aGlzLml0ZXJhdGlvbi5uYW1lcyk7XG4gICAgfVxufVxuY2xhc3MgRm9yUmFuZ2UgZXh0ZW5kcyBGb3Ige1xuICAgIGNvbnN0cnVjdG9yKHZhcktpbmQsIG5hbWUsIGZyb20sIHRvKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudmFyS2luZCA9IHZhcktpbmQ7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICB9XG4gICAgcmVuZGVyKG9wdHMpIHtcbiAgICAgICAgY29uc3QgdmFyS2luZCA9IG9wdHMuZXM1ID8gc2NvcGVfMS52YXJLaW5kcy52YXIgOiB0aGlzLnZhcktpbmQ7XG4gICAgICAgIGNvbnN0IHsgbmFtZSwgZnJvbSwgdG8gfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBgZm9yKCR7dmFyS2luZH0gJHtuYW1lfT0ke2Zyb219OyAke25hbWV9PCR7dG99OyAke25hbWV9KyspYCArIHN1cGVyLnJlbmRlcihvcHRzKTtcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICBjb25zdCBuYW1lcyA9IGFkZEV4cHJOYW1lcyhzdXBlci5uYW1lcywgdGhpcy5mcm9tKTtcbiAgICAgICAgcmV0dXJuIGFkZEV4cHJOYW1lcyhuYW1lcywgdGhpcy50byk7XG4gICAgfVxufVxuY2xhc3MgRm9ySXRlciBleHRlbmRzIEZvciB7XG4gICAgY29uc3RydWN0b3IobG9vcCwgdmFyS2luZCwgbmFtZSwgaXRlcmFibGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5sb29wID0gbG9vcDtcbiAgICAgICAgdGhpcy52YXJLaW5kID0gdmFyS2luZDtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5pdGVyYWJsZSA9IGl0ZXJhYmxlO1xuICAgIH1cbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICByZXR1cm4gYGZvcigke3RoaXMudmFyS2luZH0gJHt0aGlzLm5hbWV9ICR7dGhpcy5sb29wfSAke3RoaXMuaXRlcmFibGV9KWAgKyBzdXBlci5yZW5kZXIob3B0cyk7XG4gICAgfVxuICAgIG9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykge1xuICAgICAgICBpZiAoIXN1cGVyLm9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuaXRlcmFibGUgPSBvcHRpbWl6ZUV4cHIodGhpcy5pdGVyYWJsZSwgbmFtZXMsIGNvbnN0YW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIHJldHVybiBhZGROYW1lcyhzdXBlci5uYW1lcywgdGhpcy5pdGVyYWJsZS5uYW1lcyk7XG4gICAgfVxufVxuY2xhc3MgRnVuYyBleHRlbmRzIEJsb2NrTm9kZSB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgYXJncywgYXN5bmMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5hcmdzID0gYXJncztcbiAgICAgICAgdGhpcy5hc3luYyA9IGFzeW5jO1xuICAgIH1cbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICBjb25zdCBfYXN5bmMgPSB0aGlzLmFzeW5jID8gXCJhc3luYyBcIiA6IFwiXCI7XG4gICAgICAgIHJldHVybiBgJHtfYXN5bmN9ZnVuY3Rpb24gJHt0aGlzLm5hbWV9KCR7dGhpcy5hcmdzfSlgICsgc3VwZXIucmVuZGVyKG9wdHMpO1xuICAgIH1cbn1cbkZ1bmMua2luZCA9IFwiZnVuY1wiO1xuY2xhc3MgUmV0dXJuIGV4dGVuZHMgUGFyZW50Tm9kZSB7XG4gICAgcmVuZGVyKG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIFwicmV0dXJuIFwiICsgc3VwZXIucmVuZGVyKG9wdHMpO1xuICAgIH1cbn1cblJldHVybi5raW5kID0gXCJyZXR1cm5cIjtcbmNsYXNzIFRyeSBleHRlbmRzIEJsb2NrTm9kZSB7XG4gICAgcmVuZGVyKG9wdHMpIHtcbiAgICAgICAgbGV0IGNvZGUgPSBcInRyeVwiICsgc3VwZXIucmVuZGVyKG9wdHMpO1xuICAgICAgICBpZiAodGhpcy5jYXRjaClcbiAgICAgICAgICAgIGNvZGUgKz0gdGhpcy5jYXRjaC5yZW5kZXIob3B0cyk7XG4gICAgICAgIGlmICh0aGlzLmZpbmFsbHkpXG4gICAgICAgICAgICBjb2RlICs9IHRoaXMuZmluYWxseS5yZW5kZXIob3B0cyk7XG4gICAgICAgIHJldHVybiBjb2RlO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5vZGVzKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBzdXBlci5vcHRpbWl6ZU5vZGVzKCk7XG4gICAgICAgIChfYSA9IHRoaXMuY2F0Y2gpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcHRpbWl6ZU5vZGVzKCk7XG4gICAgICAgIChfYiA9IHRoaXMuZmluYWxseSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm9wdGltaXplTm9kZXMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBzdXBlci5vcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpO1xuICAgICAgICAoX2EgPSB0aGlzLmNhdGNoKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKTtcbiAgICAgICAgKF9iID0gdGhpcy5maW5hbGx5KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgY29uc3QgbmFtZXMgPSBzdXBlci5uYW1lcztcbiAgICAgICAgaWYgKHRoaXMuY2F0Y2gpXG4gICAgICAgICAgICBhZGROYW1lcyhuYW1lcywgdGhpcy5jYXRjaC5uYW1lcyk7XG4gICAgICAgIGlmICh0aGlzLmZpbmFsbHkpXG4gICAgICAgICAgICBhZGROYW1lcyhuYW1lcywgdGhpcy5maW5hbGx5Lm5hbWVzKTtcbiAgICAgICAgcmV0dXJuIG5hbWVzO1xuICAgIH1cbn1cbmNsYXNzIENhdGNoIGV4dGVuZHMgQmxvY2tOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihlcnJvcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgfVxuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIHJldHVybiBgY2F0Y2goJHt0aGlzLmVycm9yfSlgICsgc3VwZXIucmVuZGVyKG9wdHMpO1xuICAgIH1cbn1cbkNhdGNoLmtpbmQgPSBcImNhdGNoXCI7XG5jbGFzcyBGaW5hbGx5IGV4dGVuZHMgQmxvY2tOb2RlIHtcbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICByZXR1cm4gXCJmaW5hbGx5XCIgKyBzdXBlci5yZW5kZXIob3B0cyk7XG4gICAgfVxufVxuRmluYWxseS5raW5kID0gXCJmaW5hbGx5XCI7XG5jbGFzcyBDb2RlR2VuIHtcbiAgICBjb25zdHJ1Y3RvcihleHRTY29wZSwgb3B0cyA9IHt9KSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlcyA9IHt9O1xuICAgICAgICB0aGlzLl9ibG9ja1N0YXJ0cyA9IFtdO1xuICAgICAgICB0aGlzLl9jb25zdGFudHMgPSB7fTtcbiAgICAgICAgdGhpcy5vcHRzID0geyAuLi5vcHRzLCBfbjogb3B0cy5saW5lcyA/IFwiXFxuXCIgOiBcIlwiIH07XG4gICAgICAgIHRoaXMuX2V4dFNjb3BlID0gZXh0U2NvcGU7XG4gICAgICAgIHRoaXMuX3Njb3BlID0gbmV3IHNjb3BlXzEuU2NvcGUoeyBwYXJlbnQ6IGV4dFNjb3BlIH0pO1xuICAgICAgICB0aGlzLl9ub2RlcyA9IFtuZXcgUm9vdCgpXTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yb290LnJlbmRlcih0aGlzLm9wdHMpO1xuICAgIH1cbiAgICAvLyByZXR1cm5zIHVuaXF1ZSBuYW1lIGluIHRoZSBpbnRlcm5hbCBzY29wZVxuICAgIG5hbWUocHJlZml4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zY29wZS5uYW1lKHByZWZpeCk7XG4gICAgfVxuICAgIC8vIHJlc2VydmVzIHVuaXF1ZSBuYW1lIGluIHRoZSBleHRlcm5hbCBzY29wZVxuICAgIHNjb3BlTmFtZShwcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4dFNjb3BlLm5hbWUocHJlZml4KTtcbiAgICB9XG4gICAgLy8gcmVzZXJ2ZXMgdW5pcXVlIG5hbWUgaW4gdGhlIGV4dGVybmFsIHNjb3BlIGFuZCBhc3NpZ25zIHZhbHVlIHRvIGl0XG4gICAgc2NvcGVWYWx1ZShwcmVmaXhPck5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLl9leHRTY29wZS52YWx1ZShwcmVmaXhPck5hbWUsIHZhbHVlKTtcbiAgICAgICAgY29uc3QgdnMgPSB0aGlzLl92YWx1ZXNbbmFtZS5wcmVmaXhdIHx8ICh0aGlzLl92YWx1ZXNbbmFtZS5wcmVmaXhdID0gbmV3IFNldCgpKTtcbiAgICAgICAgdnMuYWRkKG5hbWUpO1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gICAgZ2V0U2NvcGVWYWx1ZShwcmVmaXgsIGtleU9yUmVmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9leHRTY29wZS5nZXRWYWx1ZShwcmVmaXgsIGtleU9yUmVmKTtcbiAgICB9XG4gICAgLy8gcmV0dXJuIGNvZGUgdGhhdCBhc3NpZ25zIHZhbHVlcyBpbiB0aGUgZXh0ZXJuYWwgc2NvcGUgdG8gdGhlIG5hbWVzIHRoYXQgYXJlIHVzZWQgaW50ZXJuYWxseVxuICAgIC8vIChzYW1lIG5hbWVzIHRoYXQgd2VyZSByZXR1cm5lZCBieSBnZW4uc2NvcGVOYW1lIG9yIGdlbi5zY29wZVZhbHVlKVxuICAgIHNjb3BlUmVmcyhzY29wZU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4dFNjb3BlLnNjb3BlUmVmcyhzY29wZU5hbWUsIHRoaXMuX3ZhbHVlcyk7XG4gICAgfVxuICAgIHNjb3BlQ29kZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4dFNjb3BlLnNjb3BlQ29kZSh0aGlzLl92YWx1ZXMpO1xuICAgIH1cbiAgICBfZGVmKHZhcktpbmQsIG5hbWVPclByZWZpeCwgcmhzLCBjb25zdGFudCkge1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5fc2NvcGUudG9OYW1lKG5hbWVPclByZWZpeCk7XG4gICAgICAgIGlmIChyaHMgIT09IHVuZGVmaW5lZCAmJiBjb25zdGFudClcbiAgICAgICAgICAgIHRoaXMuX2NvbnN0YW50c1tuYW1lLnN0cl0gPSByaHM7XG4gICAgICAgIHRoaXMuX2xlYWZOb2RlKG5ldyBEZWYodmFyS2luZCwgbmFtZSwgcmhzKSk7XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbiAgICAvLyBgY29uc3RgIGRlY2xhcmF0aW9uIChgdmFyYCBpbiBlczUgbW9kZSlcbiAgICBjb25zdChuYW1lT3JQcmVmaXgsIHJocywgX2NvbnN0YW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYoc2NvcGVfMS52YXJLaW5kcy5jb25zdCwgbmFtZU9yUHJlZml4LCByaHMsIF9jb25zdGFudCk7XG4gICAgfVxuICAgIC8vIGBsZXRgIGRlY2xhcmF0aW9uIHdpdGggb3B0aW9uYWwgYXNzaWdubWVudCAoYHZhcmAgaW4gZXM1IG1vZGUpXG4gICAgbGV0KG5hbWVPclByZWZpeCwgcmhzLCBfY29uc3RhbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZihzY29wZV8xLnZhcktpbmRzLmxldCwgbmFtZU9yUHJlZml4LCByaHMsIF9jb25zdGFudCk7XG4gICAgfVxuICAgIC8vIGB2YXJgIGRlY2xhcmF0aW9uIHdpdGggb3B0aW9uYWwgYXNzaWdubWVudFxuICAgIHZhcihuYW1lT3JQcmVmaXgsIHJocywgX2NvbnN0YW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYoc2NvcGVfMS52YXJLaW5kcy52YXIsIG5hbWVPclByZWZpeCwgcmhzLCBfY29uc3RhbnQpO1xuICAgIH1cbiAgICAvLyBhc3NpZ25tZW50IGNvZGVcbiAgICBhc3NpZ24obGhzLCByaHMsIHNpZGVFZmZlY3RzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sZWFmTm9kZShuZXcgQXNzaWduKGxocywgcmhzLCBzaWRlRWZmZWN0cykpO1xuICAgIH1cbiAgICAvLyBgKz1gIGNvZGVcbiAgICBhZGQobGhzLCByaHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlYWZOb2RlKG5ldyBBc3NpZ25PcChsaHMsIGV4cG9ydHMub3BlcmF0b3JzLkFERCwgcmhzKSk7XG4gICAgfVxuICAgIC8vIGFwcGVuZHMgcGFzc2VkIFNhZmVFeHByIHRvIGNvZGUgb3IgZXhlY3V0ZXMgQmxvY2tcbiAgICBjb2RlKGMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIGMoKTtcbiAgICAgICAgZWxzZSBpZiAoYyAhPT0gY29kZV8xLm5pbClcbiAgICAgICAgICAgIHRoaXMuX2xlYWZOb2RlKG5ldyBBbnlDb2RlKGMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIHJldHVybnMgY29kZSBmb3Igb2JqZWN0IGxpdGVyYWwgZm9yIHRoZSBwYXNzZWQgYXJndW1lbnQgbGlzdCBvZiBrZXktdmFsdWUgcGFpcnNcbiAgICBvYmplY3QoLi4ua2V5VmFsdWVzKSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBbXCJ7XCJdO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBrZXlWYWx1ZXMpIHtcbiAgICAgICAgICAgIGlmIChjb2RlLmxlbmd0aCA+IDEpXG4gICAgICAgICAgICAgICAgY29kZS5wdXNoKFwiLFwiKTtcbiAgICAgICAgICAgIGNvZGUucHVzaChrZXkpO1xuICAgICAgICAgICAgaWYgKGtleSAhPT0gdmFsdWUgfHwgdGhpcy5vcHRzLmVzNSkge1xuICAgICAgICAgICAgICAgIGNvZGUucHVzaChcIjpcIik7XG4gICAgICAgICAgICAgICAgKDAsIGNvZGVfMS5hZGRDb2RlQXJnKShjb2RlLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29kZS5wdXNoKFwifVwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBjb2RlXzEuX0NvZGUoY29kZSk7XG4gICAgfVxuICAgIC8vIGBpZmAgY2xhdXNlIChvciBzdGF0ZW1lbnQgaWYgYHRoZW5Cb2R5YCBhbmQsIG9wdGlvbmFsbHksIGBlbHNlQm9keWAgYXJlIHBhc3NlZClcbiAgICBpZihjb25kaXRpb24sIHRoZW5Cb2R5LCBlbHNlQm9keSkge1xuICAgICAgICB0aGlzLl9ibG9ja05vZGUobmV3IElmKGNvbmRpdGlvbikpO1xuICAgICAgICBpZiAodGhlbkJvZHkgJiYgZWxzZUJvZHkpIHtcbiAgICAgICAgICAgIHRoaXMuY29kZSh0aGVuQm9keSkuZWxzZSgpLmNvZGUoZWxzZUJvZHkpLmVuZElmKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhlbkJvZHkpIHtcbiAgICAgICAgICAgIHRoaXMuY29kZSh0aGVuQm9keSkuZW5kSWYoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbHNlQm9keSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb2RlR2VuOiBcImVsc2VcIiBib2R5IHdpdGhvdXQgXCJ0aGVuXCIgYm9keScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBgZWxzZSBpZmAgY2xhdXNlIC0gaW52YWxpZCB3aXRob3V0IGBpZmAgb3IgYWZ0ZXIgYGVsc2VgIGNsYXVzZXNcbiAgICBlbHNlSWYoY29uZGl0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbHNlTm9kZShuZXcgSWYoY29uZGl0aW9uKSk7XG4gICAgfVxuICAgIC8vIGBlbHNlYCBjbGF1c2UgLSBvbmx5IHZhbGlkIGFmdGVyIGBpZmAgb3IgYGVsc2UgaWZgIGNsYXVzZXNcbiAgICBlbHNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZWxzZU5vZGUobmV3IEVsc2UoKSk7XG4gICAgfVxuICAgIC8vIGVuZCBgaWZgIHN0YXRlbWVudCAobmVlZGVkIGlmIGdlbi5pZiB3YXMgdXNlZCBvbmx5IHdpdGggY29uZGl0aW9uKVxuICAgIGVuZElmKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5kQmxvY2tOb2RlKElmLCBFbHNlKTtcbiAgICB9XG4gICAgX2Zvcihub2RlLCBmb3JCb2R5KSB7XG4gICAgICAgIHRoaXMuX2Jsb2NrTm9kZShub2RlKTtcbiAgICAgICAgaWYgKGZvckJvZHkpXG4gICAgICAgICAgICB0aGlzLmNvZGUoZm9yQm9keSkuZW5kRm9yKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBhIGdlbmVyaWMgYGZvcmAgY2xhdXNlIChvciBzdGF0ZW1lbnQgaWYgYGZvckJvZHlgIGlzIHBhc3NlZClcbiAgICBmb3IoaXRlcmF0aW9uLCBmb3JCb2R5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mb3IobmV3IEZvckxvb3AoaXRlcmF0aW9uKSwgZm9yQm9keSk7XG4gICAgfVxuICAgIC8vIGBmb3JgIHN0YXRlbWVudCBmb3IgYSByYW5nZSBvZiB2YWx1ZXNcbiAgICBmb3JSYW5nZShuYW1lT3JQcmVmaXgsIGZyb20sIHRvLCBmb3JCb2R5LCB2YXJLaW5kID0gdGhpcy5vcHRzLmVzNSA/IHNjb3BlXzEudmFyS2luZHMudmFyIDogc2NvcGVfMS52YXJLaW5kcy5sZXQpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuX3Njb3BlLnRvTmFtZShuYW1lT3JQcmVmaXgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZm9yKG5ldyBGb3JSYW5nZSh2YXJLaW5kLCBuYW1lLCBmcm9tLCB0byksICgpID0+IGZvckJvZHkobmFtZSkpO1xuICAgIH1cbiAgICAvLyBgZm9yLW9mYCBzdGF0ZW1lbnQgKGluIGVzNSBtb2RlIHJlcGxhY2Ugd2l0aCBhIG5vcm1hbCBmb3IgbG9vcClcbiAgICBmb3JPZihuYW1lT3JQcmVmaXgsIGl0ZXJhYmxlLCBmb3JCb2R5LCB2YXJLaW5kID0gc2NvcGVfMS52YXJLaW5kcy5jb25zdCkge1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5fc2NvcGUudG9OYW1lKG5hbWVPclByZWZpeCk7XG4gICAgICAgIGlmICh0aGlzLm9wdHMuZXM1KSB7XG4gICAgICAgICAgICBjb25zdCBhcnIgPSBpdGVyYWJsZSBpbnN0YW5jZW9mIGNvZGVfMS5OYW1lID8gaXRlcmFibGUgOiB0aGlzLnZhcihcIl9hcnJcIiwgaXRlcmFibGUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9yUmFuZ2UoXCJfaVwiLCAwLCAoMCwgY29kZV8xLl8pIGAke2Fycn0ubGVuZ3RoYCwgKGkpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhcihuYW1lLCAoMCwgY29kZV8xLl8pIGAke2Fycn1bJHtpfV1gKTtcbiAgICAgICAgICAgICAgICBmb3JCb2R5KG5hbWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZvcihuZXcgRm9ySXRlcihcIm9mXCIsIHZhcktpbmQsIG5hbWUsIGl0ZXJhYmxlKSwgKCkgPT4gZm9yQm9keShuYW1lKSk7XG4gICAgfVxuICAgIC8vIGBmb3ItaW5gIHN0YXRlbWVudC5cbiAgICAvLyBXaXRoIG9wdGlvbiBgb3duUHJvcGVydGllc2AgcmVwbGFjZWQgd2l0aCBhIGBmb3Itb2ZgIGxvb3AgZm9yIG9iamVjdCBrZXlzXG4gICAgZm9ySW4obmFtZU9yUHJlZml4LCBvYmosIGZvckJvZHksIHZhcktpbmQgPSB0aGlzLm9wdHMuZXM1ID8gc2NvcGVfMS52YXJLaW5kcy52YXIgOiBzY29wZV8xLnZhcktpbmRzLmNvbnN0KSB7XG4gICAgICAgIGlmICh0aGlzLm9wdHMub3duUHJvcGVydGllcykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9yT2YobmFtZU9yUHJlZml4LCAoMCwgY29kZV8xLl8pIGBPYmplY3Qua2V5cygke29ian0pYCwgZm9yQm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuX3Njb3BlLnRvTmFtZShuYW1lT3JQcmVmaXgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZm9yKG5ldyBGb3JJdGVyKFwiaW5cIiwgdmFyS2luZCwgbmFtZSwgb2JqKSwgKCkgPT4gZm9yQm9keShuYW1lKSk7XG4gICAgfVxuICAgIC8vIGVuZCBgZm9yYCBsb29wXG4gICAgZW5kRm9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5kQmxvY2tOb2RlKEZvcik7XG4gICAgfVxuICAgIC8vIGBsYWJlbGAgc3RhdGVtZW50XG4gICAgbGFiZWwobGFiZWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlYWZOb2RlKG5ldyBMYWJlbChsYWJlbCkpO1xuICAgIH1cbiAgICAvLyBgYnJlYWtgIHN0YXRlbWVudFxuICAgIGJyZWFrKGxhYmVsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sZWFmTm9kZShuZXcgQnJlYWsobGFiZWwpKTtcbiAgICB9XG4gICAgLy8gYHJldHVybmAgc3RhdGVtZW50XG4gICAgcmV0dXJuKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBuZXcgUmV0dXJuKCk7XG4gICAgICAgIHRoaXMuX2Jsb2NrTm9kZShub2RlKTtcbiAgICAgICAgdGhpcy5jb2RlKHZhbHVlKTtcbiAgICAgICAgaWYgKG5vZGUubm9kZXMubGVuZ3RoICE9PSAxKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb2RlR2VuOiBcInJldHVyblwiIHNob3VsZCBoYXZlIG9uZSBub2RlJyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmRCbG9ja05vZGUoUmV0dXJuKTtcbiAgICB9XG4gICAgLy8gYHRyeWAgc3RhdGVtZW50XG4gICAgdHJ5KHRyeUJvZHksIGNhdGNoQ29kZSwgZmluYWxseUNvZGUpIHtcbiAgICAgICAgaWYgKCFjYXRjaENvZGUgJiYgIWZpbmFsbHlDb2RlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb2RlR2VuOiBcInRyeVwiIHdpdGhvdXQgXCJjYXRjaFwiIGFuZCBcImZpbmFsbHlcIicpO1xuICAgICAgICBjb25zdCBub2RlID0gbmV3IFRyeSgpO1xuICAgICAgICB0aGlzLl9ibG9ja05vZGUobm9kZSk7XG4gICAgICAgIHRoaXMuY29kZSh0cnlCb2R5KTtcbiAgICAgICAgaWYgKGNhdGNoQ29kZSkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLm5hbWUoXCJlXCIpO1xuICAgICAgICAgICAgdGhpcy5fY3Vyck5vZGUgPSBub2RlLmNhdGNoID0gbmV3IENhdGNoKGVycm9yKTtcbiAgICAgICAgICAgIGNhdGNoQ29kZShlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbmFsbHlDb2RlKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyTm9kZSA9IG5vZGUuZmluYWxseSA9IG5ldyBGaW5hbGx5KCk7XG4gICAgICAgICAgICB0aGlzLmNvZGUoZmluYWxseUNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmRCbG9ja05vZGUoQ2F0Y2gsIEZpbmFsbHkpO1xuICAgIH1cbiAgICAvLyBgdGhyb3dgIHN0YXRlbWVudFxuICAgIHRocm93KGVycm9yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sZWFmTm9kZShuZXcgVGhyb3coZXJyb3IpKTtcbiAgICB9XG4gICAgLy8gc3RhcnQgc2VsZi1iYWxhbmNpbmcgYmxvY2tcbiAgICBibG9jayhib2R5LCBub2RlQ291bnQpIHtcbiAgICAgICAgdGhpcy5fYmxvY2tTdGFydHMucHVzaCh0aGlzLl9ub2Rlcy5sZW5ndGgpO1xuICAgICAgICBpZiAoYm9keSlcbiAgICAgICAgICAgIHRoaXMuY29kZShib2R5KS5lbmRCbG9jayhub2RlQ291bnQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gZW5kIHRoZSBjdXJyZW50IHNlbGYtYmFsYW5jaW5nIGJsb2NrXG4gICAgZW5kQmxvY2sobm9kZUNvdW50KSB7XG4gICAgICAgIGNvbnN0IGxlbiA9IHRoaXMuX2Jsb2NrU3RhcnRzLnBvcCgpO1xuICAgICAgICBpZiAobGVuID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb2RlR2VuOiBub3QgaW4gc2VsZi1iYWxhbmNpbmcgYmxvY2tcIik7XG4gICAgICAgIGNvbnN0IHRvQ2xvc2UgPSB0aGlzLl9ub2Rlcy5sZW5ndGggLSBsZW47XG4gICAgICAgIGlmICh0b0Nsb3NlIDwgMCB8fCAobm9kZUNvdW50ICE9PSB1bmRlZmluZWQgJiYgdG9DbG9zZSAhPT0gbm9kZUNvdW50KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb2RlR2VuOiB3cm9uZyBudW1iZXIgb2Ygbm9kZXM6ICR7dG9DbG9zZX0gdnMgJHtub2RlQ291bnR9IGV4cGVjdGVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbm9kZXMubGVuZ3RoID0gbGVuO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gYGZ1bmN0aW9uYCBoZWFkaW5nIChvciBkZWZpbml0aW9uIGlmIGZ1bmNCb2R5IGlzIHBhc3NlZClcbiAgICBmdW5jKG5hbWUsIGFyZ3MgPSBjb2RlXzEubmlsLCBhc3luYywgZnVuY0JvZHkpIHtcbiAgICAgICAgdGhpcy5fYmxvY2tOb2RlKG5ldyBGdW5jKG5hbWUsIGFyZ3MsIGFzeW5jKSk7XG4gICAgICAgIGlmIChmdW5jQm9keSlcbiAgICAgICAgICAgIHRoaXMuY29kZShmdW5jQm9keSkuZW5kRnVuYygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gZW5kIGZ1bmN0aW9uIGRlZmluaXRpb25cbiAgICBlbmRGdW5jKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5kQmxvY2tOb2RlKEZ1bmMpO1xuICAgIH1cbiAgICBvcHRpbWl6ZShuID0gMSkge1xuICAgICAgICB3aGlsZSAobi0tID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fcm9vdC5vcHRpbWl6ZU5vZGVzKCk7XG4gICAgICAgICAgICB0aGlzLl9yb290Lm9wdGltaXplTmFtZXModGhpcy5fcm9vdC5uYW1lcywgdGhpcy5fY29uc3RhbnRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfbGVhZk5vZGUobm9kZSkge1xuICAgICAgICB0aGlzLl9jdXJyTm9kZS5ub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgX2Jsb2NrTm9kZShub2RlKSB7XG4gICAgICAgIHRoaXMuX2N1cnJOb2RlLm5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIHRoaXMuX25vZGVzLnB1c2gobm9kZSk7XG4gICAgfVxuICAgIF9lbmRCbG9ja05vZGUoTjEsIE4yKSB7XG4gICAgICAgIGNvbnN0IG4gPSB0aGlzLl9jdXJyTm9kZTtcbiAgICAgICAgaWYgKG4gaW5zdGFuY2VvZiBOMSB8fCAoTjIgJiYgbiBpbnN0YW5jZW9mIE4yKSkge1xuICAgICAgICAgICAgdGhpcy5fbm9kZXMucG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvZGVHZW46IG5vdCBpbiBibG9jayBcIiR7TjIgPyBgJHtOMS5raW5kfS8ke04yLmtpbmR9YCA6IE4xLmtpbmR9XCJgKTtcbiAgICB9XG4gICAgX2Vsc2VOb2RlKG5vZGUpIHtcbiAgICAgICAgY29uc3QgbiA9IHRoaXMuX2N1cnJOb2RlO1xuICAgICAgICBpZiAoIShuIGluc3RhbmNlb2YgSWYpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvZGVHZW46IFwiZWxzZVwiIHdpdGhvdXQgXCJpZlwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY3Vyck5vZGUgPSBuLmVsc2UgPSBub2RlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0IF9yb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbm9kZXNbMF07XG4gICAgfVxuICAgIGdldCBfY3Vyck5vZGUoKSB7XG4gICAgICAgIGNvbnN0IG5zID0gdGhpcy5fbm9kZXM7XG4gICAgICAgIHJldHVybiBuc1tucy5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgc2V0IF9jdXJyTm9kZShub2RlKSB7XG4gICAgICAgIGNvbnN0IG5zID0gdGhpcy5fbm9kZXM7XG4gICAgICAgIG5zW25zLmxlbmd0aCAtIDFdID0gbm9kZTtcbiAgICB9XG59XG5leHBvcnRzLkNvZGVHZW4gPSBDb2RlR2VuO1xuZnVuY3Rpb24gYWRkTmFtZXMobmFtZXMsIGZyb20pIHtcbiAgICBmb3IgKGNvbnN0IG4gaW4gZnJvbSlcbiAgICAgICAgbmFtZXNbbl0gPSAobmFtZXNbbl0gfHwgMCkgKyAoZnJvbVtuXSB8fCAwKTtcbiAgICByZXR1cm4gbmFtZXM7XG59XG5mdW5jdGlvbiBhZGRFeHByTmFtZXMobmFtZXMsIGZyb20pIHtcbiAgICByZXR1cm4gZnJvbSBpbnN0YW5jZW9mIGNvZGVfMS5fQ29kZU9yTmFtZSA/IGFkZE5hbWVzKG5hbWVzLCBmcm9tLm5hbWVzKSA6IG5hbWVzO1xufVxuZnVuY3Rpb24gb3B0aW1pemVFeHByKGV4cHIsIG5hbWVzLCBjb25zdGFudHMpIHtcbiAgICBpZiAoZXhwciBpbnN0YW5jZW9mIGNvZGVfMS5OYW1lKVxuICAgICAgICByZXR1cm4gcmVwbGFjZU5hbWUoZXhwcik7XG4gICAgaWYgKCFjYW5PcHRpbWl6ZShleHByKSlcbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgcmV0dXJuIG5ldyBjb2RlXzEuX0NvZGUoZXhwci5faXRlbXMucmVkdWNlKChpdGVtcywgYykgPT4ge1xuICAgICAgICBpZiAoYyBpbnN0YW5jZW9mIGNvZGVfMS5OYW1lKVxuICAgICAgICAgICAgYyA9IHJlcGxhY2VOYW1lKGMpO1xuICAgICAgICBpZiAoYyBpbnN0YW5jZW9mIGNvZGVfMS5fQ29kZSlcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goLi4uYy5faXRlbXMpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBpdGVtcy5wdXNoKGMpO1xuICAgICAgICByZXR1cm4gaXRlbXM7XG4gICAgfSwgW10pKTtcbiAgICBmdW5jdGlvbiByZXBsYWNlTmFtZShuKSB7XG4gICAgICAgIGNvbnN0IGMgPSBjb25zdGFudHNbbi5zdHJdO1xuICAgICAgICBpZiAoYyA9PT0gdW5kZWZpbmVkIHx8IG5hbWVzW24uc3RyXSAhPT0gMSlcbiAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICBkZWxldGUgbmFtZXNbbi5zdHJdO1xuICAgICAgICByZXR1cm4gYztcbiAgICB9XG4gICAgZnVuY3Rpb24gY2FuT3B0aW1pemUoZSkge1xuICAgICAgICByZXR1cm4gKGUgaW5zdGFuY2VvZiBjb2RlXzEuX0NvZGUgJiZcbiAgICAgICAgICAgIGUuX2l0ZW1zLnNvbWUoKGMpID0+IGMgaW5zdGFuY2VvZiBjb2RlXzEuTmFtZSAmJiBuYW1lc1tjLnN0cl0gPT09IDEgJiYgY29uc3RhbnRzW2Muc3RyXSAhPT0gdW5kZWZpbmVkKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gc3VidHJhY3ROYW1lcyhuYW1lcywgZnJvbSkge1xuICAgIGZvciAoY29uc3QgbiBpbiBmcm9tKVxuICAgICAgICBuYW1lc1tuXSA9IChuYW1lc1tuXSB8fCAwKSAtIChmcm9tW25dIHx8IDApO1xufVxuZnVuY3Rpb24gbm90KHgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHggPT0gXCJib29sZWFuXCIgfHwgdHlwZW9mIHggPT0gXCJudW1iZXJcIiB8fCB4ID09PSBudWxsID8gIXggOiAoMCwgY29kZV8xLl8pIGAhJHtwYXIoeCl9YDtcbn1cbmV4cG9ydHMubm90ID0gbm90O1xuY29uc3QgYW5kQ29kZSA9IG1hcHBlbmQoZXhwb3J0cy5vcGVyYXRvcnMuQU5EKTtcbi8vIGJvb2xlYW4gQU5EICgmJikgZXhwcmVzc2lvbiB3aXRoIHRoZSBwYXNzZWQgYXJndW1lbnRzXG5mdW5jdGlvbiBhbmQoLi4uYXJncykge1xuICAgIHJldHVybiBhcmdzLnJlZHVjZShhbmRDb2RlKTtcbn1cbmV4cG9ydHMuYW5kID0gYW5kO1xuY29uc3Qgb3JDb2RlID0gbWFwcGVuZChleHBvcnRzLm9wZXJhdG9ycy5PUik7XG4vLyBib29sZWFuIE9SICh8fCkgZXhwcmVzc2lvbiB3aXRoIHRoZSBwYXNzZWQgYXJndW1lbnRzXG5mdW5jdGlvbiBvciguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGFyZ3MucmVkdWNlKG9yQ29kZSk7XG59XG5leHBvcnRzLm9yID0gb3I7XG5mdW5jdGlvbiBtYXBwZW5kKG9wKSB7XG4gICAgcmV0dXJuICh4LCB5KSA9PiAoeCA9PT0gY29kZV8xLm5pbCA/IHkgOiB5ID09PSBjb2RlXzEubmlsID8geCA6ICgwLCBjb2RlXzEuXykgYCR7cGFyKHgpfSAke29wfSAke3Bhcih5KX1gKTtcbn1cbmZ1bmN0aW9uIHBhcih4KSB7XG4gICAgcmV0dXJuIHggaW5zdGFuY2VvZiBjb2RlXzEuTmFtZSA/IHggOiAoMCwgY29kZV8xLl8pIGAoJHt4fSlgO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNoZWNrU3RyaWN0TW9kZSA9IGV4cG9ydHMuZ2V0RXJyb3JQYXRoID0gZXhwb3J0cy5UeXBlID0gZXhwb3J0cy51c2VGdW5jID0gZXhwb3J0cy5zZXRFdmFsdWF0ZWQgPSBleHBvcnRzLmV2YWx1YXRlZFByb3BzVG9OYW1lID0gZXhwb3J0cy5tZXJnZUV2YWx1YXRlZCA9IGV4cG9ydHMuZWFjaEl0ZW0gPSBleHBvcnRzLnVuZXNjYXBlSnNvblBvaW50ZXIgPSBleHBvcnRzLmVzY2FwZUpzb25Qb2ludGVyID0gZXhwb3J0cy5lc2NhcGVGcmFnbWVudCA9IGV4cG9ydHMudW5lc2NhcGVGcmFnbWVudCA9IGV4cG9ydHMuc2NoZW1hUmVmT3JWYWwgPSBleHBvcnRzLnNjaGVtYUhhc1J1bGVzQnV0UmVmID0gZXhwb3J0cy5zY2hlbWFIYXNSdWxlcyA9IGV4cG9ydHMuY2hlY2tVbmtub3duUnVsZXMgPSBleHBvcnRzLmFsd2F5c1ZhbGlkU2NoZW1hID0gZXhwb3J0cy50b0hhc2ggPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi9jb2RlZ2VuXCIpO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4vY29kZWdlbi9jb2RlXCIpO1xuLy8gVE9ETyByZWZhY3RvciB0byB1c2UgU2V0XG5mdW5jdGlvbiB0b0hhc2goYXJyKSB7XG4gICAgY29uc3QgaGFzaCA9IHt9O1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBhcnIpXG4gICAgICAgIGhhc2hbaXRlbV0gPSB0cnVlO1xuICAgIHJldHVybiBoYXNoO1xufVxuZXhwb3J0cy50b0hhc2ggPSB0b0hhc2g7XG5mdW5jdGlvbiBhbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoZW1hKSB7XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpXG4gICAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgaWYgKE9iamVjdC5rZXlzKHNjaGVtYSkubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjaGVja1Vua25vd25SdWxlcyhpdCwgc2NoZW1hKTtcbiAgICByZXR1cm4gIXNjaGVtYUhhc1J1bGVzKHNjaGVtYSwgaXQuc2VsZi5SVUxFUy5hbGwpO1xufVxuZXhwb3J0cy5hbHdheXNWYWxpZFNjaGVtYSA9IGFsd2F5c1ZhbGlkU2NoZW1hO1xuZnVuY3Rpb24gY2hlY2tVbmtub3duUnVsZXMoaXQsIHNjaGVtYSA9IGl0LnNjaGVtYSkge1xuICAgIGNvbnN0IHsgb3B0cywgc2VsZiB9ID0gaXQ7XG4gICAgaWYgKCFvcHRzLnN0cmljdFNjaGVtYSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICh0eXBlb2Ygc2NoZW1hID09PSBcImJvb2xlYW5cIilcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHJ1bGVzID0gc2VsZi5SVUxFUy5rZXl3b3JkcztcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIHtcbiAgICAgICAgaWYgKCFydWxlc1trZXldKVxuICAgICAgICAgICAgY2hlY2tTdHJpY3RNb2RlKGl0LCBgdW5rbm93biBrZXl3b3JkOiBcIiR7a2V5fVwiYCk7XG4gICAgfVxufVxuZXhwb3J0cy5jaGVja1Vua25vd25SdWxlcyA9IGNoZWNrVW5rbm93blJ1bGVzO1xuZnVuY3Rpb24gc2NoZW1hSGFzUnVsZXMoc2NoZW1hLCBydWxlcykge1xuICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKVxuICAgICAgICByZXR1cm4gIXNjaGVtYTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpXG4gICAgICAgIGlmIChydWxlc1trZXldKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5zY2hlbWFIYXNSdWxlcyA9IHNjaGVtYUhhc1J1bGVzO1xuZnVuY3Rpb24gc2NoZW1hSGFzUnVsZXNCdXRSZWYoc2NoZW1hLCBSVUxFUykge1xuICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKVxuICAgICAgICByZXR1cm4gIXNjaGVtYTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpXG4gICAgICAgIGlmIChrZXkgIT09IFwiJHJlZlwiICYmIFJVTEVTLmFsbFtrZXldKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5zY2hlbWFIYXNSdWxlc0J1dFJlZiA9IHNjaGVtYUhhc1J1bGVzQnV0UmVmO1xuZnVuY3Rpb24gc2NoZW1hUmVmT3JWYWwoeyB0b3BTY2hlbWFSZWYsIHNjaGVtYVBhdGggfSwgc2NoZW1hLCBrZXl3b3JkLCAkZGF0YSkge1xuICAgIGlmICghJGRhdGEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJudW1iZXJcIiB8fCB0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKVxuICAgICAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLl8pIGAke3NjaGVtYX1gO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIGNvZGVnZW5fMS5fKSBgJHt0b3BTY2hlbWFSZWZ9JHtzY2hlbWFQYXRofSR7KDAsIGNvZGVnZW5fMS5nZXRQcm9wZXJ0eSkoa2V5d29yZCl9YDtcbn1cbmV4cG9ydHMuc2NoZW1hUmVmT3JWYWwgPSBzY2hlbWFSZWZPclZhbDtcbmZ1bmN0aW9uIHVuZXNjYXBlRnJhZ21lbnQoc3RyKSB7XG4gICAgcmV0dXJuIHVuZXNjYXBlSnNvblBvaW50ZXIoZGVjb2RlVVJJQ29tcG9uZW50KHN0cikpO1xufVxuZXhwb3J0cy51bmVzY2FwZUZyYWdtZW50ID0gdW5lc2NhcGVGcmFnbWVudDtcbmZ1bmN0aW9uIGVzY2FwZUZyYWdtZW50KHN0cikge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoZXNjYXBlSnNvblBvaW50ZXIoc3RyKSk7XG59XG5leHBvcnRzLmVzY2FwZUZyYWdtZW50ID0gZXNjYXBlRnJhZ21lbnQ7XG5mdW5jdGlvbiBlc2NhcGVKc29uUG9pbnRlcihzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciA9PSBcIm51bWJlclwiKVxuICAgICAgICByZXR1cm4gYCR7c3RyfWA7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9+L2csIFwifjBcIikucmVwbGFjZSgvXFwvL2csIFwifjFcIik7XG59XG5leHBvcnRzLmVzY2FwZUpzb25Qb2ludGVyID0gZXNjYXBlSnNvblBvaW50ZXI7XG5mdW5jdGlvbiB1bmVzY2FwZUpzb25Qb2ludGVyKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvfjEvZywgXCIvXCIpLnJlcGxhY2UoL34wL2csIFwiflwiKTtcbn1cbmV4cG9ydHMudW5lc2NhcGVKc29uUG9pbnRlciA9IHVuZXNjYXBlSnNvblBvaW50ZXI7XG5mdW5jdGlvbiBlYWNoSXRlbSh4cywgZikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHhzKSkge1xuICAgICAgICBmb3IgKGNvbnN0IHggb2YgeHMpXG4gICAgICAgICAgICBmKHgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZih4cyk7XG4gICAgfVxufVxuZXhwb3J0cy5lYWNoSXRlbSA9IGVhY2hJdGVtO1xuZnVuY3Rpb24gbWFrZU1lcmdlRXZhbHVhdGVkKHsgbWVyZ2VOYW1lcywgbWVyZ2VUb05hbWUsIG1lcmdlVmFsdWVzLCByZXN1bHRUb05hbWUsIH0pIHtcbiAgICByZXR1cm4gKGdlbiwgZnJvbSwgdG8sIHRvTmFtZSkgPT4ge1xuICAgICAgICBjb25zdCByZXMgPSB0byA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGZyb21cbiAgICAgICAgICAgIDogdG8gaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZVxuICAgICAgICAgICAgICAgID8gKGZyb20gaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSA/IG1lcmdlTmFtZXMoZ2VuLCBmcm9tLCB0bykgOiBtZXJnZVRvTmFtZShnZW4sIGZyb20sIHRvKSwgdG8pXG4gICAgICAgICAgICAgICAgOiBmcm9tIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWVcbiAgICAgICAgICAgICAgICAgICAgPyAobWVyZ2VUb05hbWUoZ2VuLCB0bywgZnJvbSksIGZyb20pXG4gICAgICAgICAgICAgICAgICAgIDogbWVyZ2VWYWx1ZXMoZnJvbSwgdG8pO1xuICAgICAgICByZXR1cm4gdG9OYW1lID09PSBjb2RlZ2VuXzEuTmFtZSAmJiAhKHJlcyBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lKSA/IHJlc3VsdFRvTmFtZShnZW4sIHJlcykgOiByZXM7XG4gICAgfTtcbn1cbmV4cG9ydHMubWVyZ2VFdmFsdWF0ZWQgPSB7XG4gICAgcHJvcHM6IG1ha2VNZXJnZUV2YWx1YXRlZCh7XG4gICAgICAgIG1lcmdlTmFtZXM6IChnZW4sIGZyb20sIHRvKSA9PiBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHt0b30gIT09IHRydWUgJiYgJHtmcm9tfSAhPT0gdW5kZWZpbmVkYCwgKCkgPT4ge1xuICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZnJvbX0gPT09IHRydWVgLCAoKSA9PiBnZW4uYXNzaWduKHRvLCB0cnVlKSwgKCkgPT4gZ2VuLmFzc2lnbih0bywgKDAsIGNvZGVnZW5fMS5fKSBgJHt0b30gfHwge31gKS5jb2RlKCgwLCBjb2RlZ2VuXzEuXykgYE9iamVjdC5hc3NpZ24oJHt0b30sICR7ZnJvbX0pYCkpO1xuICAgICAgICB9KSxcbiAgICAgICAgbWVyZ2VUb05hbWU6IChnZW4sIGZyb20sIHRvKSA9PiBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHt0b30gIT09IHRydWVgLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoZnJvbSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odG8sIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih0bywgKDAsIGNvZGVnZW5fMS5fKSBgJHt0b30gfHwge31gKTtcbiAgICAgICAgICAgICAgICBzZXRFdmFsdWF0ZWQoZ2VuLCB0bywgZnJvbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICBtZXJnZVZhbHVlczogKGZyb20sIHRvKSA9PiAoZnJvbSA9PT0gdHJ1ZSA/IHRydWUgOiB7IC4uLmZyb20sIC4uLnRvIH0pLFxuICAgICAgICByZXN1bHRUb05hbWU6IGV2YWx1YXRlZFByb3BzVG9OYW1lLFxuICAgIH0pLFxuICAgIGl0ZW1zOiBtYWtlTWVyZ2VFdmFsdWF0ZWQoe1xuICAgICAgICBtZXJnZU5hbWVzOiAoZ2VuLCBmcm9tLCB0bykgPT4gZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7dG99ICE9PSB0cnVlICYmICR7ZnJvbX0gIT09IHVuZGVmaW5lZGAsICgpID0+IGdlbi5hc3NpZ24odG8sICgwLCBjb2RlZ2VuXzEuXykgYCR7ZnJvbX0gPT09IHRydWUgPyB0cnVlIDogJHt0b30gPiAke2Zyb219ID8gJHt0b30gOiAke2Zyb219YCkpLFxuICAgICAgICBtZXJnZVRvTmFtZTogKGdlbiwgZnJvbSwgdG8pID0+IGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke3RvfSAhPT0gdHJ1ZWAsICgpID0+IGdlbi5hc3NpZ24odG8sIGZyb20gPT09IHRydWUgPyB0cnVlIDogKDAsIGNvZGVnZW5fMS5fKSBgJHt0b30gPiAke2Zyb219ID8gJHt0b30gOiAke2Zyb219YCkpLFxuICAgICAgICBtZXJnZVZhbHVlczogKGZyb20sIHRvKSA9PiAoZnJvbSA9PT0gdHJ1ZSA/IHRydWUgOiBNYXRoLm1heChmcm9tLCB0bykpLFxuICAgICAgICByZXN1bHRUb05hbWU6IChnZW4sIGl0ZW1zKSA9PiBnZW4udmFyKFwiaXRlbXNcIiwgaXRlbXMpLFxuICAgIH0pLFxufTtcbmZ1bmN0aW9uIGV2YWx1YXRlZFByb3BzVG9OYW1lKGdlbiwgcHMpIHtcbiAgICBpZiAocHMgPT09IHRydWUpXG4gICAgICAgIHJldHVybiBnZW4udmFyKFwicHJvcHNcIiwgdHJ1ZSk7XG4gICAgY29uc3QgcHJvcHMgPSBnZW4udmFyKFwicHJvcHNcIiwgKDAsIGNvZGVnZW5fMS5fKSBge31gKTtcbiAgICBpZiAocHMgIT09IHVuZGVmaW5lZClcbiAgICAgICAgc2V0RXZhbHVhdGVkKGdlbiwgcHJvcHMsIHBzKTtcbiAgICByZXR1cm4gcHJvcHM7XG59XG5leHBvcnRzLmV2YWx1YXRlZFByb3BzVG9OYW1lID0gZXZhbHVhdGVkUHJvcHNUb05hbWU7XG5mdW5jdGlvbiBzZXRFdmFsdWF0ZWQoZ2VuLCBwcm9wcywgcHMpIHtcbiAgICBPYmplY3Qua2V5cyhwcykuZm9yRWFjaCgocCkgPT4gZ2VuLmFzc2lnbigoMCwgY29kZWdlbl8xLl8pIGAke3Byb3BzfSR7KDAsIGNvZGVnZW5fMS5nZXRQcm9wZXJ0eSkocCl9YCwgdHJ1ZSkpO1xufVxuZXhwb3J0cy5zZXRFdmFsdWF0ZWQgPSBzZXRFdmFsdWF0ZWQ7XG5jb25zdCBzbmlwcGV0cyA9IHt9O1xuZnVuY3Rpb24gdXNlRnVuYyhnZW4sIGYpIHtcbiAgICByZXR1cm4gZ2VuLnNjb3BlVmFsdWUoXCJmdW5jXCIsIHtcbiAgICAgICAgcmVmOiBmLFxuICAgICAgICBjb2RlOiBzbmlwcGV0c1tmLmNvZGVdIHx8IChzbmlwcGV0c1tmLmNvZGVdID0gbmV3IGNvZGVfMS5fQ29kZShmLmNvZGUpKSxcbiAgICB9KTtcbn1cbmV4cG9ydHMudXNlRnVuYyA9IHVzZUZ1bmM7XG52YXIgVHlwZTtcbihmdW5jdGlvbiAoVHlwZSkge1xuICAgIFR5cGVbVHlwZVtcIk51bVwiXSA9IDBdID0gXCJOdW1cIjtcbiAgICBUeXBlW1R5cGVbXCJTdHJcIl0gPSAxXSA9IFwiU3RyXCI7XG59KShUeXBlIHx8IChleHBvcnRzLlR5cGUgPSBUeXBlID0ge30pKTtcbmZ1bmN0aW9uIGdldEVycm9yUGF0aChkYXRhUHJvcCwgZGF0YVByb3BUeXBlLCBqc1Byb3BlcnR5U3ludGF4KSB7XG4gICAgLy8gbGV0IHBhdGhcbiAgICBpZiAoZGF0YVByb3AgaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSkge1xuICAgICAgICBjb25zdCBpc051bWJlciA9IGRhdGFQcm9wVHlwZSA9PT0gVHlwZS5OdW07XG4gICAgICAgIHJldHVybiBqc1Byb3BlcnR5U3ludGF4XG4gICAgICAgICAgICA/IGlzTnVtYmVyXG4gICAgICAgICAgICAgICAgPyAoMCwgY29kZWdlbl8xLl8pIGBcIltcIiArICR7ZGF0YVByb3B9ICsgXCJdXCJgXG4gICAgICAgICAgICAgICAgOiAoMCwgY29kZWdlbl8xLl8pIGBcIlsnXCIgKyAke2RhdGFQcm9wfSArIFwiJ11cImBcbiAgICAgICAgICAgIDogaXNOdW1iZXJcbiAgICAgICAgICAgICAgICA/ICgwLCBjb2RlZ2VuXzEuXykgYFwiL1wiICsgJHtkYXRhUHJvcH1gXG4gICAgICAgICAgICAgICAgOiAoMCwgY29kZWdlbl8xLl8pIGBcIi9cIiArICR7ZGF0YVByb3B9LnJlcGxhY2UoL34vZywgXCJ+MFwiKS5yZXBsYWNlKC9cXFxcLy9nLCBcIn4xXCIpYDsgLy8gVE9ETyBtYXliZSB1c2UgZ2xvYmFsIGVzY2FwZVBvaW50ZXJcbiAgICB9XG4gICAgcmV0dXJuIGpzUHJvcGVydHlTeW50YXggPyAoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KShkYXRhUHJvcCkudG9TdHJpbmcoKSA6IFwiL1wiICsgZXNjYXBlSnNvblBvaW50ZXIoZGF0YVByb3ApO1xufVxuZXhwb3J0cy5nZXRFcnJvclBhdGggPSBnZXRFcnJvclBhdGg7XG5mdW5jdGlvbiBjaGVja1N0cmljdE1vZGUoaXQsIG1zZywgbW9kZSA9IGl0Lm9wdHMuc3RyaWN0U2NoZW1hKSB7XG4gICAgaWYgKCFtb2RlKVxuICAgICAgICByZXR1cm47XG4gICAgbXNnID0gYHN0cmljdCBtb2RlOiAke21zZ31gO1xuICAgIGlmIChtb2RlID09PSB0cnVlKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICBpdC5zZWxmLmxvZ2dlci53YXJuKG1zZyk7XG59XG5leHBvcnRzLmNoZWNrU3RyaWN0TW9kZSA9IGNoZWNrU3RyaWN0TW9kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi9jb2RlZ2VuXCIpO1xuY29uc3QgbmFtZXMgPSB7XG4gICAgLy8gdmFsaWRhdGlvbiBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICBkYXRhOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJkYXRhXCIpLCAvLyBkYXRhIHBhc3NlZCB0byB2YWxpZGF0aW9uIGZ1bmN0aW9uXG4gICAgLy8gYXJncyBwYXNzZWQgZnJvbSByZWZlcmVuY2luZyBzY2hlbWFcbiAgICB2YWxDeHQ6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInZhbEN4dFwiKSwgLy8gdmFsaWRhdGlvbi9kYXRhIGNvbnRleHQgLSBzaG91bGQgbm90IGJlIHVzZWQgZGlyZWN0bHksIGl0IGlzIGRlc3RydWN0dXJlZCB0byB0aGUgbmFtZXMgYmVsb3dcbiAgICBpbnN0YW5jZVBhdGg6IG5ldyBjb2RlZ2VuXzEuTmFtZShcImluc3RhbmNlUGF0aFwiKSxcbiAgICBwYXJlbnREYXRhOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJwYXJlbnREYXRhXCIpLFxuICAgIHBhcmVudERhdGFQcm9wZXJ0eTogbmV3IGNvZGVnZW5fMS5OYW1lKFwicGFyZW50RGF0YVByb3BlcnR5XCIpLFxuICAgIHJvb3REYXRhOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJyb290RGF0YVwiKSwgLy8gcm9vdCBkYXRhIC0gc2FtZSBhcyB0aGUgZGF0YSBwYXNzZWQgdG8gdGhlIGZpcnN0L3RvcCB2YWxpZGF0aW9uIGZ1bmN0aW9uXG4gICAgZHluYW1pY0FuY2hvcnM6IG5ldyBjb2RlZ2VuXzEuTmFtZShcImR5bmFtaWNBbmNob3JzXCIpLCAvLyB1c2VkIHRvIHN1cHBvcnQgcmVjdXJzaXZlUmVmIGFuZCBkeW5hbWljUmVmXG4gICAgLy8gZnVuY3Rpb24gc2NvcGVkIHZhcmlhYmxlc1xuICAgIHZFcnJvcnM6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInZFcnJvcnNcIiksIC8vIG51bGwgb3IgYXJyYXkgb2YgdmFsaWRhdGlvbiBlcnJvcnNcbiAgICBlcnJvcnM6IG5ldyBjb2RlZ2VuXzEuTmFtZShcImVycm9yc1wiKSwgLy8gY291bnRlciBvZiB2YWxpZGF0aW9uIGVycm9yc1xuICAgIHRoaXM6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInRoaXNcIiksXG4gICAgLy8gXCJnbG9iYWxzXCJcbiAgICBzZWxmOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJzZWxmXCIpLFxuICAgIHNjb3BlOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJzY29wZVwiKSxcbiAgICAvLyBKVEQgc2VyaWFsaXplL3BhcnNlIG5hbWUgZm9yIEpTT04gc3RyaW5nIGFuZCBwb3NpdGlvblxuICAgIGpzb246IG5ldyBjb2RlZ2VuXzEuTmFtZShcImpzb25cIiksXG4gICAganNvblBvczogbmV3IGNvZGVnZW5fMS5OYW1lKFwianNvblBvc1wiKSxcbiAgICBqc29uTGVuOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJqc29uTGVuXCIpLFxuICAgIGpzb25QYXJ0OiBuZXcgY29kZWdlbl8xLk5hbWUoXCJqc29uUGFydFwiKSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBuYW1lcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5hbWVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5leHRlbmRFcnJvcnMgPSBleHBvcnRzLnJlc2V0RXJyb3JzQ291bnQgPSBleHBvcnRzLnJlcG9ydEV4dHJhRXJyb3IgPSBleHBvcnRzLnJlcG9ydEVycm9yID0gZXhwb3J0cy5rZXl3b3JkJERhdGFFcnJvciA9IGV4cG9ydHMua2V5d29yZEVycm9yID0gdm9pZCAwO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4vY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5jb25zdCBuYW1lc18xID0gcmVxdWlyZShcIi4vbmFtZXNcIik7XG5leHBvcnRzLmtleXdvcmRFcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBrZXl3b3JkIH0pID0+ICgwLCBjb2RlZ2VuXzEuc3RyKSBgbXVzdCBwYXNzIFwiJHtrZXl3b3JkfVwiIGtleXdvcmQgdmFsaWRhdGlvbmAsXG59O1xuZXhwb3J0cy5rZXl3b3JkJERhdGFFcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBrZXl3b3JkLCBzY2hlbWFUeXBlIH0pID0+IHNjaGVtYVR5cGVcbiAgICAgICAgPyAoMCwgY29kZWdlbl8xLnN0cikgYFwiJHtrZXl3b3JkfVwiIGtleXdvcmQgbXVzdCBiZSAke3NjaGVtYVR5cGV9ICgkZGF0YSlgXG4gICAgICAgIDogKDAsIGNvZGVnZW5fMS5zdHIpIGBcIiR7a2V5d29yZH1cIiBrZXl3b3JkIGlzIGludmFsaWQgKCRkYXRhKWAsXG59O1xuZnVuY3Rpb24gcmVwb3J0RXJyb3IoY3h0LCBlcnJvciA9IGV4cG9ydHMua2V5d29yZEVycm9yLCBlcnJvclBhdGhzLCBvdmVycmlkZUFsbEVycm9ycykge1xuICAgIGNvbnN0IHsgaXQgfSA9IGN4dDtcbiAgICBjb25zdCB7IGdlbiwgY29tcG9zaXRlUnVsZSwgYWxsRXJyb3JzIH0gPSBpdDtcbiAgICBjb25zdCBlcnJPYmogPSBlcnJvck9iamVjdENvZGUoY3h0LCBlcnJvciwgZXJyb3JQYXRocyk7XG4gICAgaWYgKG92ZXJyaWRlQWxsRXJyb3JzICE9PSBudWxsICYmIG92ZXJyaWRlQWxsRXJyb3JzICE9PSB2b2lkIDAgPyBvdmVycmlkZUFsbEVycm9ycyA6IChjb21wb3NpdGVSdWxlIHx8IGFsbEVycm9ycykpIHtcbiAgICAgICAgYWRkRXJyb3IoZ2VuLCBlcnJPYmopO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuRXJyb3JzKGl0LCAoMCwgY29kZWdlbl8xLl8pIGBbJHtlcnJPYmp9XWApO1xuICAgIH1cbn1cbmV4cG9ydHMucmVwb3J0RXJyb3IgPSByZXBvcnRFcnJvcjtcbmZ1bmN0aW9uIHJlcG9ydEV4dHJhRXJyb3IoY3h0LCBlcnJvciA9IGV4cG9ydHMua2V5d29yZEVycm9yLCBlcnJvclBhdGhzKSB7XG4gICAgY29uc3QgeyBpdCB9ID0gY3h0O1xuICAgIGNvbnN0IHsgZ2VuLCBjb21wb3NpdGVSdWxlLCBhbGxFcnJvcnMgfSA9IGl0O1xuICAgIGNvbnN0IGVyck9iaiA9IGVycm9yT2JqZWN0Q29kZShjeHQsIGVycm9yLCBlcnJvclBhdGhzKTtcbiAgICBhZGRFcnJvcihnZW4sIGVyck9iaik7XG4gICAgaWYgKCEoY29tcG9zaXRlUnVsZSB8fCBhbGxFcnJvcnMpKSB7XG4gICAgICAgIHJldHVybkVycm9ycyhpdCwgbmFtZXNfMS5kZWZhdWx0LnZFcnJvcnMpO1xuICAgIH1cbn1cbmV4cG9ydHMucmVwb3J0RXh0cmFFcnJvciA9IHJlcG9ydEV4dHJhRXJyb3I7XG5mdW5jdGlvbiByZXNldEVycm9yc0NvdW50KGdlbiwgZXJyc0NvdW50KSB7XG4gICAgZ2VuLmFzc2lnbihuYW1lc18xLmRlZmF1bHQuZXJyb3JzLCBlcnJzQ291bnQpO1xuICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfSAhPT0gbnVsbGAsICgpID0+IGdlbi5pZihlcnJzQ291bnQsICgpID0+IGdlbi5hc3NpZ24oKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30ubGVuZ3RoYCwgZXJyc0NvdW50KSwgKCkgPT4gZ2VuLmFzc2lnbihuYW1lc18xLmRlZmF1bHQudkVycm9ycywgbnVsbCkpKTtcbn1cbmV4cG9ydHMucmVzZXRFcnJvcnNDb3VudCA9IHJlc2V0RXJyb3JzQ291bnQ7XG5mdW5jdGlvbiBleHRlbmRFcnJvcnMoeyBnZW4sIGtleXdvcmQsIHNjaGVtYVZhbHVlLCBkYXRhLCBlcnJzQ291bnQsIGl0LCB9KSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGVycnNDb3VudCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIik7XG4gICAgY29uc3QgZXJyID0gZ2VuLm5hbWUoXCJlcnJcIik7XG4gICAgZ2VuLmZvclJhbmdlKFwiaVwiLCBlcnJzQ291bnQsIG5hbWVzXzEuZGVmYXVsdC5lcnJvcnMsIChpKSA9PiB7XG4gICAgICAgIGdlbi5jb25zdChlcnIsICgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9WyR7aX1dYCk7XG4gICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke2Vycn0uaW5zdGFuY2VQYXRoID09PSB1bmRlZmluZWRgLCAoKSA9PiBnZW4uYXNzaWduKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZXJyfS5pbnN0YW5jZVBhdGhgLCAoMCwgY29kZWdlbl8xLnN0ckNvbmNhdCkobmFtZXNfMS5kZWZhdWx0Lmluc3RhbmNlUGF0aCwgaXQuZXJyb3JQYXRoKSkpO1xuICAgICAgICBnZW4uYXNzaWduKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZXJyfS5zY2hlbWFQYXRoYCwgKDAsIGNvZGVnZW5fMS5zdHIpIGAke2l0LmVyclNjaGVtYVBhdGh9LyR7a2V5d29yZH1gKTtcbiAgICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgICAgICAgZ2VuLmFzc2lnbigoMCwgY29kZWdlbl8xLl8pIGAke2Vycn0uc2NoZW1hYCwgc2NoZW1hVmFsdWUpO1xuICAgICAgICAgICAgZ2VuLmFzc2lnbigoMCwgY29kZWdlbl8xLl8pIGAke2Vycn0uZGF0YWAsIGRhdGEpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLmV4dGVuZEVycm9ycyA9IGV4dGVuZEVycm9ycztcbmZ1bmN0aW9uIGFkZEVycm9yKGdlbiwgZXJyT2JqKSB7XG4gICAgY29uc3QgZXJyID0gZ2VuLmNvbnN0KFwiZXJyXCIsIGVyck9iaik7XG4gICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9ID09PSBudWxsYCwgKCkgPT4gZ2VuLmFzc2lnbihuYW1lc18xLmRlZmF1bHQudkVycm9ycywgKDAsIGNvZGVnZW5fMS5fKSBgWyR7ZXJyfV1gKSwgKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30ucHVzaCgke2Vycn0pYCk7XG4gICAgZ2VuLmNvZGUoKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQuZXJyb3JzfSsrYCk7XG59XG5mdW5jdGlvbiByZXR1cm5FcnJvcnMoaXQsIGVycnMpIHtcbiAgICBjb25zdCB7IGdlbiwgdmFsaWRhdGVOYW1lLCBzY2hlbWFFbnYgfSA9IGl0O1xuICAgIGlmIChzY2hlbWFFbnYuJGFzeW5jKSB7XG4gICAgICAgIGdlbi50aHJvdygoMCwgY29kZWdlbl8xLl8pIGBuZXcgJHtpdC5WYWxpZGF0aW9uRXJyb3J9KCR7ZXJyc30pYCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnZW4uYXNzaWduKCgwLCBjb2RlZ2VuXzEuXykgYCR7dmFsaWRhdGVOYW1lfS5lcnJvcnNgLCBlcnJzKTtcbiAgICAgICAgZ2VuLnJldHVybihmYWxzZSk7XG4gICAgfVxufVxuY29uc3QgRSA9IHtcbiAgICBrZXl3b3JkOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJrZXl3b3JkXCIpLFxuICAgIHNjaGVtYVBhdGg6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInNjaGVtYVBhdGhcIiksIC8vIGFsc28gdXNlZCBpbiBKVEQgZXJyb3JzXG4gICAgcGFyYW1zOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJwYXJhbXNcIiksXG4gICAgcHJvcGVydHlOYW1lOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJwcm9wZXJ0eU5hbWVcIiksXG4gICAgbWVzc2FnZTogbmV3IGNvZGVnZW5fMS5OYW1lKFwibWVzc2FnZVwiKSxcbiAgICBzY2hlbWE6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInNjaGVtYVwiKSxcbiAgICBwYXJlbnRTY2hlbWE6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInBhcmVudFNjaGVtYVwiKSxcbn07XG5mdW5jdGlvbiBlcnJvck9iamVjdENvZGUoY3h0LCBlcnJvciwgZXJyb3JQYXRocykge1xuICAgIGNvbnN0IHsgY3JlYXRlRXJyb3JzIH0gPSBjeHQuaXQ7XG4gICAgaWYgKGNyZWF0ZUVycm9ycyA9PT0gZmFsc2UpXG4gICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLl8pIGB7fWA7XG4gICAgcmV0dXJuIGVycm9yT2JqZWN0KGN4dCwgZXJyb3IsIGVycm9yUGF0aHMpO1xufVxuZnVuY3Rpb24gZXJyb3JPYmplY3QoY3h0LCBlcnJvciwgZXJyb3JQYXRocyA9IHt9KSB7XG4gICAgY29uc3QgeyBnZW4sIGl0IH0gPSBjeHQ7XG4gICAgY29uc3Qga2V5VmFsdWVzID0gW1xuICAgICAgICBlcnJvckluc3RhbmNlUGF0aChpdCwgZXJyb3JQYXRocyksXG4gICAgICAgIGVycm9yU2NoZW1hUGF0aChjeHQsIGVycm9yUGF0aHMpLFxuICAgIF07XG4gICAgZXh0cmFFcnJvclByb3BzKGN4dCwgZXJyb3IsIGtleVZhbHVlcyk7XG4gICAgcmV0dXJuIGdlbi5vYmplY3QoLi4ua2V5VmFsdWVzKTtcbn1cbmZ1bmN0aW9uIGVycm9ySW5zdGFuY2VQYXRoKHsgZXJyb3JQYXRoIH0sIHsgaW5zdGFuY2VQYXRoIH0pIHtcbiAgICBjb25zdCBpbnN0UGF0aCA9IGluc3RhbmNlUGF0aFxuICAgICAgICA/ICgwLCBjb2RlZ2VuXzEuc3RyKSBgJHtlcnJvclBhdGh9JHsoMCwgdXRpbF8xLmdldEVycm9yUGF0aCkoaW5zdGFuY2VQYXRoLCB1dGlsXzEuVHlwZS5TdHIpfWBcbiAgICAgICAgOiBlcnJvclBhdGg7XG4gICAgcmV0dXJuIFtuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRoLCAoMCwgY29kZWdlbl8xLnN0ckNvbmNhdCkobmFtZXNfMS5kZWZhdWx0Lmluc3RhbmNlUGF0aCwgaW5zdFBhdGgpXTtcbn1cbmZ1bmN0aW9uIGVycm9yU2NoZW1hUGF0aCh7IGtleXdvcmQsIGl0OiB7IGVyclNjaGVtYVBhdGggfSB9LCB7IHNjaGVtYVBhdGgsIHBhcmVudFNjaGVtYSB9KSB7XG4gICAgbGV0IHNjaFBhdGggPSBwYXJlbnRTY2hlbWEgPyBlcnJTY2hlbWFQYXRoIDogKDAsIGNvZGVnZW5fMS5zdHIpIGAke2VyclNjaGVtYVBhdGh9LyR7a2V5d29yZH1gO1xuICAgIGlmIChzY2hlbWFQYXRoKSB7XG4gICAgICAgIHNjaFBhdGggPSAoMCwgY29kZWdlbl8xLnN0cikgYCR7c2NoUGF0aH0keygwLCB1dGlsXzEuZ2V0RXJyb3JQYXRoKShzY2hlbWFQYXRoLCB1dGlsXzEuVHlwZS5TdHIpfWA7XG4gICAgfVxuICAgIHJldHVybiBbRS5zY2hlbWFQYXRoLCBzY2hQYXRoXTtcbn1cbmZ1bmN0aW9uIGV4dHJhRXJyb3JQcm9wcyhjeHQsIHsgcGFyYW1zLCBtZXNzYWdlIH0sIGtleVZhbHVlcykge1xuICAgIGNvbnN0IHsga2V5d29yZCwgZGF0YSwgc2NoZW1hVmFsdWUsIGl0IH0gPSBjeHQ7XG4gICAgY29uc3QgeyBvcHRzLCBwcm9wZXJ0eU5hbWUsIHRvcFNjaGVtYVJlZiwgc2NoZW1hUGF0aCB9ID0gaXQ7XG4gICAga2V5VmFsdWVzLnB1c2goW0Uua2V5d29yZCwga2V5d29yZF0sIFtFLnBhcmFtcywgdHlwZW9mIHBhcmFtcyA9PSBcImZ1bmN0aW9uXCIgPyBwYXJhbXMoY3h0KSA6IHBhcmFtcyB8fCAoMCwgY29kZWdlbl8xLl8pIGB7fWBdKTtcbiAgICBpZiAob3B0cy5tZXNzYWdlcykge1xuICAgICAgICBrZXlWYWx1ZXMucHVzaChbRS5tZXNzYWdlLCB0eXBlb2YgbWVzc2FnZSA9PSBcImZ1bmN0aW9uXCIgPyBtZXNzYWdlKGN4dCkgOiBtZXNzYWdlXSk7XG4gICAgfVxuICAgIGlmIChvcHRzLnZlcmJvc2UpIHtcbiAgICAgICAga2V5VmFsdWVzLnB1c2goW0Uuc2NoZW1hLCBzY2hlbWFWYWx1ZV0sIFtFLnBhcmVudFNjaGVtYSwgKDAsIGNvZGVnZW5fMS5fKSBgJHt0b3BTY2hlbWFSZWZ9JHtzY2hlbWFQYXRofWBdLCBbbmFtZXNfMS5kZWZhdWx0LmRhdGEsIGRhdGFdKTtcbiAgICB9XG4gICAgaWYgKHByb3BlcnR5TmFtZSlcbiAgICAgICAga2V5VmFsdWVzLnB1c2goW0UucHJvcGVydHlOYW1lLCBwcm9wZXJ0eU5hbWVdKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9ycy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYm9vbE9yRW1wdHlTY2hlbWEgPSBleHBvcnRzLnRvcEJvb2xPckVtcHR5U2NoZW1hID0gdm9pZCAwO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uL2NvZGVnZW5cIik7XG5jb25zdCBuYW1lc18xID0gcmVxdWlyZShcIi4uL25hbWVzXCIpO1xuY29uc3QgYm9vbEVycm9yID0ge1xuICAgIG1lc3NhZ2U6IFwiYm9vbGVhbiBzY2hlbWEgaXMgZmFsc2VcIixcbn07XG5mdW5jdGlvbiB0b3BCb29sT3JFbXB0eVNjaGVtYShpdCkge1xuICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIHZhbGlkYXRlTmFtZSB9ID0gaXQ7XG4gICAgaWYgKHNjaGVtYSA9PT0gZmFsc2UpIHtcbiAgICAgICAgZmFsc2VTY2hlbWFFcnJvcihpdCwgZmFsc2UpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Ygc2NoZW1hID09IFwib2JqZWN0XCIgJiYgc2NoZW1hLiRhc3luYyA9PT0gdHJ1ZSkge1xuICAgICAgICBnZW4ucmV0dXJuKG5hbWVzXzEuZGVmYXVsdC5kYXRhKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdlbi5hc3NpZ24oKDAsIGNvZGVnZW5fMS5fKSBgJHt2YWxpZGF0ZU5hbWV9LmVycm9yc2AsIG51bGwpO1xuICAgICAgICBnZW4ucmV0dXJuKHRydWUpO1xuICAgIH1cbn1cbmV4cG9ydHMudG9wQm9vbE9yRW1wdHlTY2hlbWEgPSB0b3BCb29sT3JFbXB0eVNjaGVtYTtcbmZ1bmN0aW9uIGJvb2xPckVtcHR5U2NoZW1hKGl0LCB2YWxpZCkge1xuICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEgfSA9IGl0O1xuICAgIGlmIChzY2hlbWEgPT09IGZhbHNlKSB7XG4gICAgICAgIGdlbi52YXIodmFsaWQsIGZhbHNlKTsgLy8gVE9ETyB2YXJcbiAgICAgICAgZmFsc2VTY2hlbWFFcnJvcihpdCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnZW4udmFyKHZhbGlkLCB0cnVlKTsgLy8gVE9ETyB2YXJcbiAgICB9XG59XG5leHBvcnRzLmJvb2xPckVtcHR5U2NoZW1hID0gYm9vbE9yRW1wdHlTY2hlbWE7XG5mdW5jdGlvbiBmYWxzZVNjaGVtYUVycm9yKGl0LCBvdmVycmlkZUFsbEVycm9ycykge1xuICAgIGNvbnN0IHsgZ2VuLCBkYXRhIH0gPSBpdDtcbiAgICAvLyBUT0RPIG1heWJlIHNvbWUgb3RoZXIgaW50ZXJmYWNlIHNob3VsZCBiZSB1c2VkIGZvciBub24ta2V5d29yZCB2YWxpZGF0aW9uIGVycm9ycy4uLlxuICAgIGNvbnN0IGN4dCA9IHtcbiAgICAgICAgZ2VuLFxuICAgICAgICBrZXl3b3JkOiBcImZhbHNlIHNjaGVtYVwiLFxuICAgICAgICBkYXRhLFxuICAgICAgICBzY2hlbWE6IGZhbHNlLFxuICAgICAgICBzY2hlbWFDb2RlOiBmYWxzZSxcbiAgICAgICAgc2NoZW1hVmFsdWU6IGZhbHNlLFxuICAgICAgICBwYXJhbXM6IHt9LFxuICAgICAgICBpdCxcbiAgICB9O1xuICAgICgwLCBlcnJvcnNfMS5yZXBvcnRFcnJvcikoY3h0LCBib29sRXJyb3IsIHVuZGVmaW5lZCwgb3ZlcnJpZGVBbGxFcnJvcnMpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ym9vbFNjaGVtYS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0UnVsZXMgPSBleHBvcnRzLmlzSlNPTlR5cGUgPSB2b2lkIDA7XG5jb25zdCBfanNvblR5cGVzID0gW1wic3RyaW5nXCIsIFwibnVtYmVyXCIsIFwiaW50ZWdlclwiLCBcImJvb2xlYW5cIiwgXCJudWxsXCIsIFwib2JqZWN0XCIsIFwiYXJyYXlcIl07XG5jb25zdCBqc29uVHlwZXMgPSBuZXcgU2V0KF9qc29uVHlwZXMpO1xuZnVuY3Rpb24gaXNKU09OVHlwZSh4KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB4ID09IFwic3RyaW5nXCIgJiYganNvblR5cGVzLmhhcyh4KTtcbn1cbmV4cG9ydHMuaXNKU09OVHlwZSA9IGlzSlNPTlR5cGU7XG5mdW5jdGlvbiBnZXRSdWxlcygpIHtcbiAgICBjb25zdCBncm91cHMgPSB7XG4gICAgICAgIG51bWJlcjogeyB0eXBlOiBcIm51bWJlclwiLCBydWxlczogW10gfSxcbiAgICAgICAgc3RyaW5nOiB7IHR5cGU6IFwic3RyaW5nXCIsIHJ1bGVzOiBbXSB9LFxuICAgICAgICBhcnJheTogeyB0eXBlOiBcImFycmF5XCIsIHJ1bGVzOiBbXSB9LFxuICAgICAgICBvYmplY3Q6IHsgdHlwZTogXCJvYmplY3RcIiwgcnVsZXM6IFtdIH0sXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlczogeyAuLi5ncm91cHMsIGludGVnZXI6IHRydWUsIGJvb2xlYW46IHRydWUsIG51bGw6IHRydWUgfSxcbiAgICAgICAgcnVsZXM6IFt7IHJ1bGVzOiBbXSB9LCBncm91cHMubnVtYmVyLCBncm91cHMuc3RyaW5nLCBncm91cHMuYXJyYXksIGdyb3Vwcy5vYmplY3RdLFxuICAgICAgICBwb3N0OiB7IHJ1bGVzOiBbXSB9LFxuICAgICAgICBhbGw6IHt9LFxuICAgICAgICBrZXl3b3Jkczoge30sXG4gICAgfTtcbn1cbmV4cG9ydHMuZ2V0UnVsZXMgPSBnZXRSdWxlcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJ1bGVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zaG91bGRVc2VSdWxlID0gZXhwb3J0cy5zaG91bGRVc2VHcm91cCA9IGV4cG9ydHMuc2NoZW1hSGFzUnVsZXNGb3JUeXBlID0gdm9pZCAwO1xuZnVuY3Rpb24gc2NoZW1hSGFzUnVsZXNGb3JUeXBlKHsgc2NoZW1hLCBzZWxmIH0sIHR5cGUpIHtcbiAgICBjb25zdCBncm91cCA9IHNlbGYuUlVMRVMudHlwZXNbdHlwZV07XG4gICAgcmV0dXJuIGdyb3VwICYmIGdyb3VwICE9PSB0cnVlICYmIHNob3VsZFVzZUdyb3VwKHNjaGVtYSwgZ3JvdXApO1xufVxuZXhwb3J0cy5zY2hlbWFIYXNSdWxlc0ZvclR5cGUgPSBzY2hlbWFIYXNSdWxlc0ZvclR5cGU7XG5mdW5jdGlvbiBzaG91bGRVc2VHcm91cChzY2hlbWEsIGdyb3VwKSB7XG4gICAgcmV0dXJuIGdyb3VwLnJ1bGVzLnNvbWUoKHJ1bGUpID0+IHNob3VsZFVzZVJ1bGUoc2NoZW1hLCBydWxlKSk7XG59XG5leHBvcnRzLnNob3VsZFVzZUdyb3VwID0gc2hvdWxkVXNlR3JvdXA7XG5mdW5jdGlvbiBzaG91bGRVc2VSdWxlKHNjaGVtYSwgcnVsZSkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKHNjaGVtYVtydWxlLmtleXdvcmRdICE9PSB1bmRlZmluZWQgfHxcbiAgICAgICAgKChfYSA9IHJ1bGUuZGVmaW5pdGlvbi5pbXBsZW1lbnRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc29tZSgoa3dkKSA9PiBzY2hlbWFba3dkXSAhPT0gdW5kZWZpbmVkKSkpO1xufVxuZXhwb3J0cy5zaG91bGRVc2VSdWxlID0gc2hvdWxkVXNlUnVsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwcGxpY2FiaWxpdHkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJlcG9ydFR5cGVFcnJvciA9IGV4cG9ydHMuY2hlY2tEYXRhVHlwZXMgPSBleHBvcnRzLmNoZWNrRGF0YVR5cGUgPSBleHBvcnRzLmNvZXJjZUFuZENoZWNrRGF0YVR5cGUgPSBleHBvcnRzLmdldEpTT05UeXBlcyA9IGV4cG9ydHMuZ2V0U2NoZW1hVHlwZXMgPSBleHBvcnRzLkRhdGFUeXBlID0gdm9pZCAwO1xuY29uc3QgcnVsZXNfMSA9IHJlcXVpcmUoXCIuLi9ydWxlc1wiKTtcbmNvbnN0IGFwcGxpY2FiaWxpdHlfMSA9IHJlcXVpcmUoXCIuL2FwcGxpY2FiaWxpdHlcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuLi9lcnJvcnNcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIERhdGFUeXBlO1xuKGZ1bmN0aW9uIChEYXRhVHlwZSkge1xuICAgIERhdGFUeXBlW0RhdGFUeXBlW1wiQ29ycmVjdFwiXSA9IDBdID0gXCJDb3JyZWN0XCI7XG4gICAgRGF0YVR5cGVbRGF0YVR5cGVbXCJXcm9uZ1wiXSA9IDFdID0gXCJXcm9uZ1wiO1xufSkoRGF0YVR5cGUgfHwgKGV4cG9ydHMuRGF0YVR5cGUgPSBEYXRhVHlwZSA9IHt9KSk7XG5mdW5jdGlvbiBnZXRTY2hlbWFUeXBlcyhzY2hlbWEpIHtcbiAgICBjb25zdCB0eXBlcyA9IGdldEpTT05UeXBlcyhzY2hlbWEudHlwZSk7XG4gICAgY29uc3QgaGFzTnVsbCA9IHR5cGVzLmluY2x1ZGVzKFwibnVsbFwiKTtcbiAgICBpZiAoaGFzTnVsbCkge1xuICAgICAgICBpZiAoc2NoZW1hLm51bGxhYmxlID09PSBmYWxzZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInR5cGU6IG51bGwgY29udHJhZGljdHMgbnVsbGFibGU6IGZhbHNlXCIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKCF0eXBlcy5sZW5ndGggJiYgc2NoZW1hLm51bGxhYmxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignXCJudWxsYWJsZVwiIGNhbm5vdCBiZSB1c2VkIHdpdGhvdXQgXCJ0eXBlXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1hLm51bGxhYmxlID09PSB0cnVlKVxuICAgICAgICAgICAgdHlwZXMucHVzaChcIm51bGxcIik7XG4gICAgfVxuICAgIHJldHVybiB0eXBlcztcbn1cbmV4cG9ydHMuZ2V0U2NoZW1hVHlwZXMgPSBnZXRTY2hlbWFUeXBlcztcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVkdW5kYW50LXR5cGUtY29uc3RpdHVlbnRzXG5mdW5jdGlvbiBnZXRKU09OVHlwZXModHMpIHtcbiAgICBjb25zdCB0eXBlcyA9IEFycmF5LmlzQXJyYXkodHMpID8gdHMgOiB0cyA/IFt0c10gOiBbXTtcbiAgICBpZiAodHlwZXMuZXZlcnkocnVsZXNfMS5pc0pTT05UeXBlKSlcbiAgICAgICAgcmV0dXJuIHR5cGVzO1xuICAgIHRocm93IG5ldyBFcnJvcihcInR5cGUgbXVzdCBiZSBKU09OVHlwZSBvciBKU09OVHlwZVtdOiBcIiArIHR5cGVzLmpvaW4oXCIsXCIpKTtcbn1cbmV4cG9ydHMuZ2V0SlNPTlR5cGVzID0gZ2V0SlNPTlR5cGVzO1xuZnVuY3Rpb24gY29lcmNlQW5kQ2hlY2tEYXRhVHlwZShpdCwgdHlwZXMpIHtcbiAgICBjb25zdCB7IGdlbiwgZGF0YSwgb3B0cyB9ID0gaXQ7XG4gICAgY29uc3QgY29lcmNlVG8gPSBjb2VyY2VUb1R5cGVzKHR5cGVzLCBvcHRzLmNvZXJjZVR5cGVzKTtcbiAgICBjb25zdCBjaGVja1R5cGVzID0gdHlwZXMubGVuZ3RoID4gMCAmJlxuICAgICAgICAhKGNvZXJjZVRvLmxlbmd0aCA9PT0gMCAmJiB0eXBlcy5sZW5ndGggPT09IDEgJiYgKDAsIGFwcGxpY2FiaWxpdHlfMS5zY2hlbWFIYXNSdWxlc0ZvclR5cGUpKGl0LCB0eXBlc1swXSkpO1xuICAgIGlmIChjaGVja1R5cGVzKSB7XG4gICAgICAgIGNvbnN0IHdyb25nVHlwZSA9IGNoZWNrRGF0YVR5cGVzKHR5cGVzLCBkYXRhLCBvcHRzLnN0cmljdE51bWJlcnMsIERhdGFUeXBlLldyb25nKTtcbiAgICAgICAgZ2VuLmlmKHdyb25nVHlwZSwgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNvZXJjZVRvLmxlbmd0aClcbiAgICAgICAgICAgICAgICBjb2VyY2VEYXRhKGl0LCB0eXBlcywgY29lcmNlVG8pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJlcG9ydFR5cGVFcnJvcihpdCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gY2hlY2tUeXBlcztcbn1cbmV4cG9ydHMuY29lcmNlQW5kQ2hlY2tEYXRhVHlwZSA9IGNvZXJjZUFuZENoZWNrRGF0YVR5cGU7XG5jb25zdCBDT0VSQ0lCTEUgPSBuZXcgU2V0KFtcInN0cmluZ1wiLCBcIm51bWJlclwiLCBcImludGVnZXJcIiwgXCJib29sZWFuXCIsIFwibnVsbFwiXSk7XG5mdW5jdGlvbiBjb2VyY2VUb1R5cGVzKHR5cGVzLCBjb2VyY2VUeXBlcykge1xuICAgIHJldHVybiBjb2VyY2VUeXBlc1xuICAgICAgICA/IHR5cGVzLmZpbHRlcigodCkgPT4gQ09FUkNJQkxFLmhhcyh0KSB8fCAoY29lcmNlVHlwZXMgPT09IFwiYXJyYXlcIiAmJiB0ID09PSBcImFycmF5XCIpKVxuICAgICAgICA6IFtdO1xufVxuZnVuY3Rpb24gY29lcmNlRGF0YShpdCwgdHlwZXMsIGNvZXJjZVRvKSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEsIG9wdHMgfSA9IGl0O1xuICAgIGNvbnN0IGRhdGFUeXBlID0gZ2VuLmxldChcImRhdGFUeXBlXCIsICgwLCBjb2RlZ2VuXzEuXykgYHR5cGVvZiAke2RhdGF9YCk7XG4gICAgY29uc3QgY29lcmNlZCA9IGdlbi5sZXQoXCJjb2VyY2VkXCIsICgwLCBjb2RlZ2VuXzEuXykgYHVuZGVmaW5lZGApO1xuICAgIGlmIChvcHRzLmNvZXJjZVR5cGVzID09PSBcImFycmF5XCIpIHtcbiAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YVR5cGV9ID09ICdvYmplY3QnICYmIEFycmF5LmlzQXJyYXkoJHtkYXRhfSkgJiYgJHtkYXRhfS5sZW5ndGggPT0gMWAsICgpID0+IGdlblxuICAgICAgICAgICAgLmFzc2lnbihkYXRhLCAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9WzBdYClcbiAgICAgICAgICAgIC5hc3NpZ24oZGF0YVR5cGUsICgwLCBjb2RlZ2VuXzEuXykgYHR5cGVvZiAke2RhdGF9YClcbiAgICAgICAgICAgIC5pZihjaGVja0RhdGFUeXBlcyh0eXBlcywgZGF0YSwgb3B0cy5zdHJpY3ROdW1iZXJzKSwgKCkgPT4gZ2VuLmFzc2lnbihjb2VyY2VkLCBkYXRhKSkpO1xuICAgIH1cbiAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtjb2VyY2VkfSAhPT0gdW5kZWZpbmVkYCk7XG4gICAgZm9yIChjb25zdCB0IG9mIGNvZXJjZVRvKSB7XG4gICAgICAgIGlmIChDT0VSQ0lCTEUuaGFzKHQpIHx8ICh0ID09PSBcImFycmF5XCIgJiYgb3B0cy5jb2VyY2VUeXBlcyA9PT0gXCJhcnJheVwiKSkge1xuICAgICAgICAgICAgY29lcmNlU3BlY2lmaWNUeXBlKHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdlbi5lbHNlKCk7XG4gICAgcmVwb3J0VHlwZUVycm9yKGl0KTtcbiAgICBnZW4uZW5kSWYoKTtcbiAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtjb2VyY2VkfSAhPT0gdW5kZWZpbmVkYCwgKCkgPT4ge1xuICAgICAgICBnZW4uYXNzaWduKGRhdGEsIGNvZXJjZWQpO1xuICAgICAgICBhc3NpZ25QYXJlbnREYXRhKGl0LCBjb2VyY2VkKTtcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBjb2VyY2VTcGVjaWZpY1R5cGUodCkge1xuICAgICAgICBzd2l0Y2ggKHQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgICAgICBnZW5cbiAgICAgICAgICAgICAgICAgICAgLmVsc2VJZigoMCwgY29kZWdlbl8xLl8pIGAke2RhdGFUeXBlfSA9PSBcIm51bWJlclwiIHx8ICR7ZGF0YVR5cGV9ID09IFwiYm9vbGVhblwiYClcbiAgICAgICAgICAgICAgICAgICAgLmFzc2lnbihjb2VyY2VkLCAoMCwgY29kZWdlbl8xLl8pIGBcIlwiICsgJHtkYXRhfWApXG4gICAgICAgICAgICAgICAgICAgIC5lbHNlSWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfSA9PT0gbnVsbGApXG4gICAgICAgICAgICAgICAgICAgIC5hc3NpZ24oY29lcmNlZCwgKDAsIGNvZGVnZW5fMS5fKSBgXCJcImApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgICAgICBnZW5cbiAgICAgICAgICAgICAgICAgICAgLmVsc2VJZigoMCwgY29kZWdlbl8xLl8pIGAke2RhdGFUeXBlfSA9PSBcImJvb2xlYW5cIiB8fCAke2RhdGF9ID09PSBudWxsXG4gICAgICAgICAgICAgIHx8ICgke2RhdGFUeXBlfSA9PSBcInN0cmluZ1wiICYmICR7ZGF0YX0gJiYgJHtkYXRhfSA9PSArJHtkYXRhfSlgKVxuICAgICAgICAgICAgICAgICAgICAuYXNzaWduKGNvZXJjZWQsICgwLCBjb2RlZ2VuXzEuXykgYCske2RhdGF9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBcImludGVnZXJcIjpcbiAgICAgICAgICAgICAgICBnZW5cbiAgICAgICAgICAgICAgICAgICAgLmVsc2VJZigoMCwgY29kZWdlbl8xLl8pIGAke2RhdGFUeXBlfSA9PT0gXCJib29sZWFuXCIgfHwgJHtkYXRhfSA9PT0gbnVsbFxuICAgICAgICAgICAgICB8fCAoJHtkYXRhVHlwZX0gPT09IFwic3RyaW5nXCIgJiYgJHtkYXRhfSAmJiAke2RhdGF9ID09ICske2RhdGF9ICYmICEoJHtkYXRhfSAlIDEpKWApXG4gICAgICAgICAgICAgICAgICAgIC5hc3NpZ24oY29lcmNlZCwgKDAsIGNvZGVnZW5fMS5fKSBgKyR7ZGF0YX1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgICAgICAgICAuZWxzZUlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0gPT09IFwiZmFsc2VcIiB8fCAke2RhdGF9ID09PSAwIHx8ICR7ZGF0YX0gPT09IG51bGxgKVxuICAgICAgICAgICAgICAgICAgICAuYXNzaWduKGNvZXJjZWQsIGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAuZWxzZUlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0gPT09IFwidHJ1ZVwiIHx8ICR7ZGF0YX0gPT09IDFgKVxuICAgICAgICAgICAgICAgICAgICAuYXNzaWduKGNvZXJjZWQsIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgXCJudWxsXCI6XG4gICAgICAgICAgICAgICAgZ2VuLmVsc2VJZigoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9ID09PSBcIlwiIHx8ICR7ZGF0YX0gPT09IDAgfHwgJHtkYXRhfSA9PT0gZmFsc2VgKTtcbiAgICAgICAgICAgICAgICBnZW4uYXNzaWduKGNvZXJjZWQsIG51bGwpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgICAgICAgICAuZWxzZUlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YVR5cGV9ID09PSBcInN0cmluZ1wiIHx8ICR7ZGF0YVR5cGV9ID09PSBcIm51bWJlclwiXG4gICAgICAgICAgICAgIHx8ICR7ZGF0YVR5cGV9ID09PSBcImJvb2xlYW5cIiB8fCAke2RhdGF9ID09PSBudWxsYClcbiAgICAgICAgICAgICAgICAgICAgLmFzc2lnbihjb2VyY2VkLCAoMCwgY29kZWdlbl8xLl8pIGBbJHtkYXRhfV1gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGFzc2lnblBhcmVudERhdGEoeyBnZW4sIHBhcmVudERhdGEsIHBhcmVudERhdGFQcm9wZXJ0eSB9LCBleHByKSB7XG4gICAgLy8gVE9ETyB1c2UgZ2VuLnByb3BlcnR5XG4gICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7cGFyZW50RGF0YX0gIT09IHVuZGVmaW5lZGAsICgpID0+IGdlbi5hc3NpZ24oKDAsIGNvZGVnZW5fMS5fKSBgJHtwYXJlbnREYXRhfVske3BhcmVudERhdGFQcm9wZXJ0eX1dYCwgZXhwcikpO1xufVxuZnVuY3Rpb24gY2hlY2tEYXRhVHlwZShkYXRhVHlwZSwgZGF0YSwgc3RyaWN0TnVtcywgY29ycmVjdCA9IERhdGFUeXBlLkNvcnJlY3QpIHtcbiAgICBjb25zdCBFUSA9IGNvcnJlY3QgPT09IERhdGFUeXBlLkNvcnJlY3QgPyBjb2RlZ2VuXzEub3BlcmF0b3JzLkVRIDogY29kZWdlbl8xLm9wZXJhdG9ycy5ORVE7XG4gICAgbGV0IGNvbmQ7XG4gICAgc3dpdGNoIChkYXRhVHlwZSkge1xuICAgICAgICBjYXNlIFwibnVsbFwiOlxuICAgICAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0gJHtFUX0gbnVsbGA7XG4gICAgICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgICAgICAgY29uZCA9ICgwLCBjb2RlZ2VuXzEuXykgYEFycmF5LmlzQXJyYXkoJHtkYXRhfSlgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICAgIGNvbmQgPSAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9ICYmIHR5cGVvZiAke2RhdGF9ID09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkoJHtkYXRhfSlgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJpbnRlZ2VyXCI6XG4gICAgICAgICAgICBjb25kID0gbnVtQ29uZCgoMCwgY29kZWdlbl8xLl8pIGAhKCR7ZGF0YX0gJSAxKSAmJiAhaXNOYU4oJHtkYXRhfSlgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICBjb25kID0gbnVtQ29uZCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gKDAsIGNvZGVnZW5fMS5fKSBgdHlwZW9mICR7ZGF0YX0gJHtFUX0gJHtkYXRhVHlwZX1gO1xuICAgIH1cbiAgICByZXR1cm4gY29ycmVjdCA9PT0gRGF0YVR5cGUuQ29ycmVjdCA/IGNvbmQgOiAoMCwgY29kZWdlbl8xLm5vdCkoY29uZCk7XG4gICAgZnVuY3Rpb24gbnVtQ29uZChfY29uZCA9IGNvZGVnZW5fMS5uaWwpIHtcbiAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuYW5kKSgoMCwgY29kZWdlbl8xLl8pIGB0eXBlb2YgJHtkYXRhfSA9PSBcIm51bWJlclwiYCwgX2NvbmQsIHN0cmljdE51bXMgPyAoMCwgY29kZWdlbl8xLl8pIGBpc0Zpbml0ZSgke2RhdGF9KWAgOiBjb2RlZ2VuXzEubmlsKTtcbiAgICB9XG59XG5leHBvcnRzLmNoZWNrRGF0YVR5cGUgPSBjaGVja0RhdGFUeXBlO1xuZnVuY3Rpb24gY2hlY2tEYXRhVHlwZXMoZGF0YVR5cGVzLCBkYXRhLCBzdHJpY3ROdW1zLCBjb3JyZWN0KSB7XG4gICAgaWYgKGRhdGFUeXBlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGNoZWNrRGF0YVR5cGUoZGF0YVR5cGVzWzBdLCBkYXRhLCBzdHJpY3ROdW1zLCBjb3JyZWN0KTtcbiAgICB9XG4gICAgbGV0IGNvbmQ7XG4gICAgY29uc3QgdHlwZXMgPSAoMCwgdXRpbF8xLnRvSGFzaCkoZGF0YVR5cGVzKTtcbiAgICBpZiAodHlwZXMuYXJyYXkgJiYgdHlwZXMub2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG5vdE9iaiA9ICgwLCBjb2RlZ2VuXzEuXykgYHR5cGVvZiAke2RhdGF9ICE9IFwib2JqZWN0XCJgO1xuICAgICAgICBjb25kID0gdHlwZXMubnVsbCA/IG5vdE9iaiA6ICgwLCBjb2RlZ2VuXzEuXykgYCEke2RhdGF9IHx8ICR7bm90T2JqfWA7XG4gICAgICAgIGRlbGV0ZSB0eXBlcy5udWxsO1xuICAgICAgICBkZWxldGUgdHlwZXMuYXJyYXk7XG4gICAgICAgIGRlbGV0ZSB0eXBlcy5vYmplY3Q7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25kID0gY29kZWdlbl8xLm5pbDtcbiAgICB9XG4gICAgaWYgKHR5cGVzLm51bWJlcilcbiAgICAgICAgZGVsZXRlIHR5cGVzLmludGVnZXI7XG4gICAgZm9yIChjb25zdCB0IGluIHR5cGVzKVxuICAgICAgICBjb25kID0gKDAsIGNvZGVnZW5fMS5hbmQpKGNvbmQsIGNoZWNrRGF0YVR5cGUodCwgZGF0YSwgc3RyaWN0TnVtcywgY29ycmVjdCkpO1xuICAgIHJldHVybiBjb25kO1xufVxuZXhwb3J0cy5jaGVja0RhdGFUeXBlcyA9IGNoZWNrRGF0YVR5cGVzO1xuY29uc3QgdHlwZUVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHNjaGVtYSB9KSA9PiBgbXVzdCBiZSAke3NjaGVtYX1gLFxuICAgIHBhcmFtczogKHsgc2NoZW1hLCBzY2hlbWFWYWx1ZSB9KSA9PiB0eXBlb2Ygc2NoZW1hID09IFwic3RyaW5nXCIgPyAoMCwgY29kZWdlbl8xLl8pIGB7dHlwZTogJHtzY2hlbWF9fWAgOiAoMCwgY29kZWdlbl8xLl8pIGB7dHlwZTogJHtzY2hlbWFWYWx1ZX19YCxcbn07XG5mdW5jdGlvbiByZXBvcnRUeXBlRXJyb3IoaXQpIHtcbiAgICBjb25zdCBjeHQgPSBnZXRUeXBlRXJyb3JDb250ZXh0KGl0KTtcbiAgICAoMCwgZXJyb3JzXzEucmVwb3J0RXJyb3IpKGN4dCwgdHlwZUVycm9yKTtcbn1cbmV4cG9ydHMucmVwb3J0VHlwZUVycm9yID0gcmVwb3J0VHlwZUVycm9yO1xuZnVuY3Rpb24gZ2V0VHlwZUVycm9yQ29udGV4dChpdCkge1xuICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBzY2hlbWEgfSA9IGl0O1xuICAgIGNvbnN0IHNjaGVtYUNvZGUgPSAoMCwgdXRpbF8xLnNjaGVtYVJlZk9yVmFsKShpdCwgc2NoZW1hLCBcInR5cGVcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2VuLFxuICAgICAgICBrZXl3b3JkOiBcInR5cGVcIixcbiAgICAgICAgZGF0YSxcbiAgICAgICAgc2NoZW1hOiBzY2hlbWEudHlwZSxcbiAgICAgICAgc2NoZW1hQ29kZSxcbiAgICAgICAgc2NoZW1hVmFsdWU6IHNjaGVtYUNvZGUsXG4gICAgICAgIHBhcmVudFNjaGVtYTogc2NoZW1hLFxuICAgICAgICBwYXJhbXM6IHt9LFxuICAgICAgICBpdCxcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YVR5cGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFzc2lnbkRlZmF1bHRzID0gdm9pZCAwO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmZ1bmN0aW9uIGFzc2lnbkRlZmF1bHRzKGl0LCB0eSkge1xuICAgIGNvbnN0IHsgcHJvcGVydGllcywgaXRlbXMgfSA9IGl0LnNjaGVtYTtcbiAgICBpZiAodHkgPT09IFwib2JqZWN0XCIgJiYgcHJvcGVydGllcykge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBhc3NpZ25EZWZhdWx0KGl0LCBrZXksIHByb3BlcnRpZXNba2V5XS5kZWZhdWx0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0eSA9PT0gXCJhcnJheVwiICYmIEFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XG4gICAgICAgIGl0ZW1zLmZvckVhY2goKHNjaCwgaSkgPT4gYXNzaWduRGVmYXVsdChpdCwgaSwgc2NoLmRlZmF1bHQpKTtcbiAgICB9XG59XG5leHBvcnRzLmFzc2lnbkRlZmF1bHRzID0gYXNzaWduRGVmYXVsdHM7XG5mdW5jdGlvbiBhc3NpZ25EZWZhdWx0KGl0LCBwcm9wLCBkZWZhdWx0VmFsdWUpIHtcbiAgICBjb25zdCB7IGdlbiwgY29tcG9zaXRlUnVsZSwgZGF0YSwgb3B0cyB9ID0gaXQ7XG4gICAgaWYgKGRlZmF1bHRWYWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgY2hpbGREYXRhID0gKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfSR7KDAsIGNvZGVnZW5fMS5nZXRQcm9wZXJ0eSkocHJvcCl9YDtcbiAgICBpZiAoY29tcG9zaXRlUnVsZSkge1xuICAgICAgICAoMCwgdXRpbF8xLmNoZWNrU3RyaWN0TW9kZSkoaXQsIGBkZWZhdWx0IGlzIGlnbm9yZWQgZm9yOiAke2NoaWxkRGF0YX1gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgY29uZGl0aW9uID0gKDAsIGNvZGVnZW5fMS5fKSBgJHtjaGlsZERhdGF9ID09PSB1bmRlZmluZWRgO1xuICAgIGlmIChvcHRzLnVzZURlZmF1bHRzID09PSBcImVtcHR5XCIpIHtcbiAgICAgICAgY29uZGl0aW9uID0gKDAsIGNvZGVnZW5fMS5fKSBgJHtjb25kaXRpb259IHx8ICR7Y2hpbGREYXRhfSA9PT0gbnVsbCB8fCAke2NoaWxkRGF0YX0gPT09IFwiXCJgO1xuICAgIH1cbiAgICAvLyBgJHtjaGlsZERhdGF9ID09PSB1bmRlZmluZWRgICtcbiAgICAvLyAob3B0cy51c2VEZWZhdWx0cyA9PT0gXCJlbXB0eVwiID8gYCB8fCAke2NoaWxkRGF0YX0gPT09IG51bGwgfHwgJHtjaGlsZERhdGF9ID09PSBcIlwiYCA6IFwiXCIpXG4gICAgZ2VuLmlmKGNvbmRpdGlvbiwgKDAsIGNvZGVnZW5fMS5fKSBgJHtjaGlsZERhdGF9ID0gJHsoMCwgY29kZWdlbl8xLnN0cmluZ2lmeSkoZGVmYXVsdFZhbHVlKX1gKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZmF1bHRzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52YWxpZGF0ZVVuaW9uID0gZXhwb3J0cy52YWxpZGF0ZUFycmF5ID0gZXhwb3J0cy51c2VQYXR0ZXJuID0gZXhwb3J0cy5jYWxsVmFsaWRhdGVDb2RlID0gZXhwb3J0cy5zY2hlbWFQcm9wZXJ0aWVzID0gZXhwb3J0cy5hbGxTY2hlbWFQcm9wZXJ0aWVzID0gZXhwb3J0cy5ub1Byb3BlcnR5SW5EYXRhID0gZXhwb3J0cy5wcm9wZXJ0eUluRGF0YSA9IGV4cG9ydHMuaXNPd25Qcm9wZXJ0eSA9IGV4cG9ydHMuaGFzUHJvcEZ1bmMgPSBleHBvcnRzLnJlcG9ydE1pc3NpbmdQcm9wID0gZXhwb3J0cy5jaGVja01pc3NpbmdQcm9wID0gZXhwb3J0cy5jaGVja1JlcG9ydE1pc3NpbmdQcm9wID0gdm9pZCAwO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBuYW1lc18xID0gcmVxdWlyZShcIi4uL2NvbXBpbGUvbmFtZXNcIik7XG5jb25zdCB1dGlsXzIgPSByZXF1aXJlKFwiLi4vY29tcGlsZS91dGlsXCIpO1xuZnVuY3Rpb24gY2hlY2tSZXBvcnRNaXNzaW5nUHJvcChjeHQsIHByb3ApIHtcbiAgICBjb25zdCB7IGdlbiwgZGF0YSwgaXQgfSA9IGN4dDtcbiAgICBnZW4uaWYobm9Qcm9wZXJ0eUluRGF0YShnZW4sIGRhdGEsIHByb3AsIGl0Lm9wdHMub3duUHJvcGVydGllcyksICgpID0+IHtcbiAgICAgICAgY3h0LnNldFBhcmFtcyh7IG1pc3NpbmdQcm9wZXJ0eTogKDAsIGNvZGVnZW5fMS5fKSBgJHtwcm9wfWAgfSwgdHJ1ZSk7XG4gICAgICAgIGN4dC5lcnJvcigpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5jaGVja1JlcG9ydE1pc3NpbmdQcm9wID0gY2hlY2tSZXBvcnRNaXNzaW5nUHJvcDtcbmZ1bmN0aW9uIGNoZWNrTWlzc2luZ1Byb3AoeyBnZW4sIGRhdGEsIGl0OiB7IG9wdHMgfSB9LCBwcm9wZXJ0aWVzLCBtaXNzaW5nKSB7XG4gICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEub3IpKC4uLnByb3BlcnRpZXMubWFwKChwcm9wKSA9PiAoMCwgY29kZWdlbl8xLmFuZCkobm9Qcm9wZXJ0eUluRGF0YShnZW4sIGRhdGEsIHByb3AsIG9wdHMub3duUHJvcGVydGllcyksICgwLCBjb2RlZ2VuXzEuXykgYCR7bWlzc2luZ30gPSAke3Byb3B9YCkpKTtcbn1cbmV4cG9ydHMuY2hlY2tNaXNzaW5nUHJvcCA9IGNoZWNrTWlzc2luZ1Byb3A7XG5mdW5jdGlvbiByZXBvcnRNaXNzaW5nUHJvcChjeHQsIG1pc3NpbmcpIHtcbiAgICBjeHQuc2V0UGFyYW1zKHsgbWlzc2luZ1Byb3BlcnR5OiBtaXNzaW5nIH0sIHRydWUpO1xuICAgIGN4dC5lcnJvcigpO1xufVxuZXhwb3J0cy5yZXBvcnRNaXNzaW5nUHJvcCA9IHJlcG9ydE1pc3NpbmdQcm9wO1xuZnVuY3Rpb24gaGFzUHJvcEZ1bmMoZ2VuKSB7XG4gICAgcmV0dXJuIGdlbi5zY29wZVZhbHVlKFwiZnVuY1wiLCB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5ib3VuZC1tZXRob2RcbiAgICAgICAgcmVmOiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LFxuICAgICAgICBjb2RlOiAoMCwgY29kZWdlbl8xLl8pIGBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5YCxcbiAgICB9KTtcbn1cbmV4cG9ydHMuaGFzUHJvcEZ1bmMgPSBoYXNQcm9wRnVuYztcbmZ1bmN0aW9uIGlzT3duUHJvcGVydHkoZ2VuLCBkYXRhLCBwcm9wZXJ0eSkge1xuICAgIHJldHVybiAoMCwgY29kZWdlbl8xLl8pIGAke2hhc1Byb3BGdW5jKGdlbil9LmNhbGwoJHtkYXRhfSwgJHtwcm9wZXJ0eX0pYDtcbn1cbmV4cG9ydHMuaXNPd25Qcm9wZXJ0eSA9IGlzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBwcm9wZXJ0eUluRGF0YShnZW4sIGRhdGEsIHByb3BlcnR5LCBvd25Qcm9wZXJ0aWVzKSB7XG4gICAgY29uc3QgY29uZCA9ICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0keygwLCBjb2RlZ2VuXzEuZ2V0UHJvcGVydHkpKHByb3BlcnR5KX0gIT09IHVuZGVmaW5lZGA7XG4gICAgcmV0dXJuIG93blByb3BlcnRpZXMgPyAoMCwgY29kZWdlbl8xLl8pIGAke2NvbmR9ICYmICR7aXNPd25Qcm9wZXJ0eShnZW4sIGRhdGEsIHByb3BlcnR5KX1gIDogY29uZDtcbn1cbmV4cG9ydHMucHJvcGVydHlJbkRhdGEgPSBwcm9wZXJ0eUluRGF0YTtcbmZ1bmN0aW9uIG5vUHJvcGVydHlJbkRhdGEoZ2VuLCBkYXRhLCBwcm9wZXJ0eSwgb3duUHJvcGVydGllcykge1xuICAgIGNvbnN0IGNvbmQgPSAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9JHsoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KShwcm9wZXJ0eSl9ID09PSB1bmRlZmluZWRgO1xuICAgIHJldHVybiBvd25Qcm9wZXJ0aWVzID8gKDAsIGNvZGVnZW5fMS5vcikoY29uZCwgKDAsIGNvZGVnZW5fMS5ub3QpKGlzT3duUHJvcGVydHkoZ2VuLCBkYXRhLCBwcm9wZXJ0eSkpKSA6IGNvbmQ7XG59XG5leHBvcnRzLm5vUHJvcGVydHlJbkRhdGEgPSBub1Byb3BlcnR5SW5EYXRhO1xuZnVuY3Rpb24gYWxsU2NoZW1hUHJvcGVydGllcyhzY2hlbWFNYXApIHtcbiAgICByZXR1cm4gc2NoZW1hTWFwID8gT2JqZWN0LmtleXMoc2NoZW1hTWFwKS5maWx0ZXIoKHApID0+IHAgIT09IFwiX19wcm90b19fXCIpIDogW107XG59XG5leHBvcnRzLmFsbFNjaGVtYVByb3BlcnRpZXMgPSBhbGxTY2hlbWFQcm9wZXJ0aWVzO1xuZnVuY3Rpb24gc2NoZW1hUHJvcGVydGllcyhpdCwgc2NoZW1hTWFwKSB7XG4gICAgcmV0dXJuIGFsbFNjaGVtYVByb3BlcnRpZXMoc2NoZW1hTWFwKS5maWx0ZXIoKHApID0+ICEoMCwgdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKShpdCwgc2NoZW1hTWFwW3BdKSk7XG59XG5leHBvcnRzLnNjaGVtYVByb3BlcnRpZXMgPSBzY2hlbWFQcm9wZXJ0aWVzO1xuZnVuY3Rpb24gY2FsbFZhbGlkYXRlQ29kZSh7IHNjaGVtYUNvZGUsIGRhdGEsIGl0OiB7IGdlbiwgdG9wU2NoZW1hUmVmLCBzY2hlbWFQYXRoLCBlcnJvclBhdGggfSwgaXQgfSwgZnVuYywgY29udGV4dCwgcGFzc1NjaGVtYSkge1xuICAgIGNvbnN0IGRhdGFBbmRTY2hlbWEgPSBwYXNzU2NoZW1hID8gKDAsIGNvZGVnZW5fMS5fKSBgJHtzY2hlbWFDb2RlfSwgJHtkYXRhfSwgJHt0b3BTY2hlbWFSZWZ9JHtzY2hlbWFQYXRofWAgOiBkYXRhO1xuICAgIGNvbnN0IHZhbEN4dCA9IFtcbiAgICAgICAgW25hbWVzXzEuZGVmYXVsdC5pbnN0YW5jZVBhdGgsICgwLCBjb2RlZ2VuXzEuc3RyQ29uY2F0KShuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRoLCBlcnJvclBhdGgpXSxcbiAgICAgICAgW25hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhLCBpdC5wYXJlbnREYXRhXSxcbiAgICAgICAgW25hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhUHJvcGVydHksIGl0LnBhcmVudERhdGFQcm9wZXJ0eV0sXG4gICAgICAgIFtuYW1lc18xLmRlZmF1bHQucm9vdERhdGEsIG5hbWVzXzEuZGVmYXVsdC5yb290RGF0YV0sXG4gICAgXTtcbiAgICBpZiAoaXQub3B0cy5keW5hbWljUmVmKVxuICAgICAgICB2YWxDeHQucHVzaChbbmFtZXNfMS5kZWZhdWx0LmR5bmFtaWNBbmNob3JzLCBuYW1lc18xLmRlZmF1bHQuZHluYW1pY0FuY2hvcnNdKTtcbiAgICBjb25zdCBhcmdzID0gKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhQW5kU2NoZW1hfSwgJHtnZW4ub2JqZWN0KC4uLnZhbEN4dCl9YDtcbiAgICByZXR1cm4gY29udGV4dCAhPT0gY29kZWdlbl8xLm5pbCA/ICgwLCBjb2RlZ2VuXzEuXykgYCR7ZnVuY30uY2FsbCgke2NvbnRleHR9LCAke2FyZ3N9KWAgOiAoMCwgY29kZWdlbl8xLl8pIGAke2Z1bmN9KCR7YXJnc30pYDtcbn1cbmV4cG9ydHMuY2FsbFZhbGlkYXRlQ29kZSA9IGNhbGxWYWxpZGF0ZUNvZGU7XG5jb25zdCBuZXdSZWdFeHAgPSAoMCwgY29kZWdlbl8xLl8pIGBuZXcgUmVnRXhwYDtcbmZ1bmN0aW9uIHVzZVBhdHRlcm4oeyBnZW4sIGl0OiB7IG9wdHMgfSB9LCBwYXR0ZXJuKSB7XG4gICAgY29uc3QgdSA9IG9wdHMudW5pY29kZVJlZ0V4cCA/IFwidVwiIDogXCJcIjtcbiAgICBjb25zdCB7IHJlZ0V4cCB9ID0gb3B0cy5jb2RlO1xuICAgIGNvbnN0IHJ4ID0gcmVnRXhwKHBhdHRlcm4sIHUpO1xuICAgIHJldHVybiBnZW4uc2NvcGVWYWx1ZShcInBhdHRlcm5cIiwge1xuICAgICAgICBrZXk6IHJ4LnRvU3RyaW5nKCksXG4gICAgICAgIHJlZjogcngsXG4gICAgICAgIGNvZGU6ICgwLCBjb2RlZ2VuXzEuXykgYCR7cmVnRXhwLmNvZGUgPT09IFwibmV3IFJlZ0V4cFwiID8gbmV3UmVnRXhwIDogKDAsIHV0aWxfMi51c2VGdW5jKShnZW4sIHJlZ0V4cCl9KCR7cGF0dGVybn0sICR7dX0pYCxcbiAgICB9KTtcbn1cbmV4cG9ydHMudXNlUGF0dGVybiA9IHVzZVBhdHRlcm47XG5mdW5jdGlvbiB2YWxpZGF0ZUFycmF5KGN4dCkge1xuICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBrZXl3b3JkLCBpdCB9ID0gY3h0O1xuICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICBpZiAoaXQuYWxsRXJyb3JzKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkQXJyID0gZ2VuLmxldChcInZhbGlkXCIsIHRydWUpO1xuICAgICAgICB2YWxpZGF0ZUl0ZW1zKCgpID0+IGdlbi5hc3NpZ24odmFsaWRBcnIsIGZhbHNlKSk7XG4gICAgICAgIHJldHVybiB2YWxpZEFycjtcbiAgICB9XG4gICAgZ2VuLnZhcih2YWxpZCwgdHJ1ZSk7XG4gICAgdmFsaWRhdGVJdGVtcygoKSA9PiBnZW4uYnJlYWsoKSk7XG4gICAgcmV0dXJuIHZhbGlkO1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlSXRlbXMobm90VmFsaWQpIHtcbiAgICAgICAgY29uc3QgbGVuID0gZ2VuLmNvbnN0KFwibGVuXCIsICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0ubGVuZ3RoYCk7XG4gICAgICAgIGdlbi5mb3JSYW5nZShcImlcIiwgMCwgbGVuLCAoaSkgPT4ge1xuICAgICAgICAgICAgY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICAgICAga2V5d29yZCxcbiAgICAgICAgICAgICAgICBkYXRhUHJvcDogaSxcbiAgICAgICAgICAgICAgICBkYXRhUHJvcFR5cGU6IHV0aWxfMS5UeXBlLk51bSxcbiAgICAgICAgICAgIH0sIHZhbGlkKTtcbiAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLm5vdCkodmFsaWQpLCBub3RWYWxpZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVBcnJheSA9IHZhbGlkYXRlQXJyYXk7XG5mdW5jdGlvbiB2YWxpZGF0ZVVuaW9uKGN4dCkge1xuICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIGtleXdvcmQsIGl0IH0gPSBjeHQ7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHNjaGVtYSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImFqdiBpbXBsZW1lbnRhdGlvbiBlcnJvclwiKTtcbiAgICBjb25zdCBhbHdheXNWYWxpZCA9IHNjaGVtYS5zb21lKChzY2gpID0+ICgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2gpKTtcbiAgICBpZiAoYWx3YXlzVmFsaWQgJiYgIWl0Lm9wdHMudW5ldmFsdWF0ZWQpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiLCBmYWxzZSk7XG4gICAgY29uc3Qgc2NoVmFsaWQgPSBnZW4ubmFtZShcIl92YWxpZFwiKTtcbiAgICBnZW4uYmxvY2soKCkgPT4gc2NoZW1hLmZvckVhY2goKF9zY2gsIGkpID0+IHtcbiAgICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICBrZXl3b3JkLFxuICAgICAgICAgICAgc2NoZW1hUHJvcDogaSxcbiAgICAgICAgICAgIGNvbXBvc2l0ZVJ1bGU6IHRydWUsXG4gICAgICAgIH0sIHNjaFZhbGlkKTtcbiAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgKDAsIGNvZGVnZW5fMS5fKSBgJHt2YWxpZH0gfHwgJHtzY2hWYWxpZH1gKTtcbiAgICAgICAgY29uc3QgbWVyZ2VkID0gY3h0Lm1lcmdlVmFsaWRFdmFsdWF0ZWQoc2NoQ3h0LCBzY2hWYWxpZCk7XG4gICAgICAgIC8vIGNhbiBzaG9ydC1jaXJjdWl0IGlmIGB1bmV2YWx1YXRlZFByb3BlcnRpZXMvSXRlbXNgIG5vdCBzdXBwb3J0ZWQgKG9wdHMudW5ldmFsdWF0ZWQgIT09IHRydWUpXG4gICAgICAgIC8vIG9yIGlmIGFsbCBwcm9wZXJ0aWVzIGFuZCBpdGVtcyB3ZXJlIGV2YWx1YXRlZCAoaXQucHJvcHMgPT09IHRydWUgJiYgaXQuaXRlbXMgPT09IHRydWUpXG4gICAgICAgIGlmICghbWVyZ2VkKVxuICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEubm90KSh2YWxpZCkpO1xuICAgIH0pKTtcbiAgICBjeHQucmVzdWx0KHZhbGlkLCAoKSA9PiBjeHQucmVzZXQoKSwgKCkgPT4gY3h0LmVycm9yKHRydWUpKTtcbn1cbmV4cG9ydHMudmFsaWRhdGVVbmlvbiA9IHZhbGlkYXRlVW5pb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2RlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52YWxpZGF0ZUtleXdvcmRVc2FnZSA9IGV4cG9ydHMudmFsaWRTY2hlbWFUeXBlID0gZXhwb3J0cy5mdW5jS2V5d29yZENvZGUgPSBleHBvcnRzLm1hY3JvS2V5d29yZENvZGUgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vY29kZWdlblwiKTtcbmNvbnN0IG5hbWVzXzEgPSByZXF1aXJlKFwiLi4vbmFtZXNcIik7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi4vLi4vdm9jYWJ1bGFyaWVzL2NvZGVcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuLi9lcnJvcnNcIik7XG5mdW5jdGlvbiBtYWNyb0tleXdvcmRDb2RlKGN4dCwgZGVmKSB7XG4gICAgY29uc3QgeyBnZW4sIGtleXdvcmQsIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBpdCB9ID0gY3h0O1xuICAgIGNvbnN0IG1hY3JvU2NoZW1hID0gZGVmLm1hY3JvLmNhbGwoaXQuc2VsZiwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGl0KTtcbiAgICBjb25zdCBzY2hlbWFSZWYgPSB1c2VLZXl3b3JkKGdlbiwga2V5d29yZCwgbWFjcm9TY2hlbWEpO1xuICAgIGlmIChpdC5vcHRzLnZhbGlkYXRlU2NoZW1hICE9PSBmYWxzZSlcbiAgICAgICAgaXQuc2VsZi52YWxpZGF0ZVNjaGVtYShtYWNyb1NjaGVtYSwgdHJ1ZSk7XG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgIGN4dC5zdWJzY2hlbWEoe1xuICAgICAgICBzY2hlbWE6IG1hY3JvU2NoZW1hLFxuICAgICAgICBzY2hlbWFQYXRoOiBjb2RlZ2VuXzEubmlsLFxuICAgICAgICBlcnJTY2hlbWFQYXRoOiBgJHtpdC5lcnJTY2hlbWFQYXRofS8ke2tleXdvcmR9YCxcbiAgICAgICAgdG9wU2NoZW1hUmVmOiBzY2hlbWFSZWYsXG4gICAgICAgIGNvbXBvc2l0ZVJ1bGU6IHRydWUsXG4gICAgfSwgdmFsaWQpO1xuICAgIGN4dC5wYXNzKHZhbGlkLCAoKSA9PiBjeHQuZXJyb3IodHJ1ZSkpO1xufVxuZXhwb3J0cy5tYWNyb0tleXdvcmRDb2RlID0gbWFjcm9LZXl3b3JkQ29kZTtcbmZ1bmN0aW9uIGZ1bmNLZXl3b3JkQ29kZShjeHQsIGRlZikge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB7IGdlbiwga2V5d29yZCwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsICRkYXRhLCBpdCB9ID0gY3h0O1xuICAgIGNoZWNrQXN5bmNLZXl3b3JkKGl0LCBkZWYpO1xuICAgIGNvbnN0IHZhbGlkYXRlID0gISRkYXRhICYmIGRlZi5jb21waWxlID8gZGVmLmNvbXBpbGUuY2FsbChpdC5zZWxmLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgaXQpIDogZGVmLnZhbGlkYXRlO1xuICAgIGNvbnN0IHZhbGlkYXRlUmVmID0gdXNlS2V5d29yZChnZW4sIGtleXdvcmQsIHZhbGlkYXRlKTtcbiAgICBjb25zdCB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiKTtcbiAgICBjeHQuYmxvY2skZGF0YSh2YWxpZCwgdmFsaWRhdGVLZXl3b3JkKTtcbiAgICBjeHQub2soKF9hID0gZGVmLnZhbGlkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB2YWxpZCk7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVLZXl3b3JkKCkge1xuICAgICAgICBpZiAoZGVmLmVycm9ycyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGFzc2lnblZhbGlkKCk7XG4gICAgICAgICAgICBpZiAoZGVmLm1vZGlmeWluZylcbiAgICAgICAgICAgICAgICBtb2RpZnlEYXRhKGN4dCk7XG4gICAgICAgICAgICByZXBvcnRFcnJzKCgpID0+IGN4dC5lcnJvcigpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHJ1bGVFcnJzID0gZGVmLmFzeW5jID8gdmFsaWRhdGVBc3luYygpIDogdmFsaWRhdGVTeW5jKCk7XG4gICAgICAgICAgICBpZiAoZGVmLm1vZGlmeWluZylcbiAgICAgICAgICAgICAgICBtb2RpZnlEYXRhKGN4dCk7XG4gICAgICAgICAgICByZXBvcnRFcnJzKCgpID0+IGFkZEVycnMoY3h0LCBydWxlRXJycykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlQXN5bmMoKSB7XG4gICAgICAgIGNvbnN0IHJ1bGVFcnJzID0gZ2VuLmxldChcInJ1bGVFcnJzXCIsIG51bGwpO1xuICAgICAgICBnZW4udHJ5KCgpID0+IGFzc2lnblZhbGlkKCgwLCBjb2RlZ2VuXzEuXykgYGF3YWl0IGApLCAoZSkgPT4gZ2VuLmFzc2lnbih2YWxpZCwgZmFsc2UpLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZX0gaW5zdGFuY2VvZiAke2l0LlZhbGlkYXRpb25FcnJvcn1gLCAoKSA9PiBnZW4uYXNzaWduKHJ1bGVFcnJzLCAoMCwgY29kZWdlbl8xLl8pIGAke2V9LmVycm9yc2ApLCAoKSA9PiBnZW4udGhyb3coZSkpKTtcbiAgICAgICAgcmV0dXJuIHJ1bGVFcnJzO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZVN5bmMoKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRlRXJycyA9ICgwLCBjb2RlZ2VuXzEuXykgYCR7dmFsaWRhdGVSZWZ9LmVycm9yc2A7XG4gICAgICAgIGdlbi5hc3NpZ24odmFsaWRhdGVFcnJzLCBudWxsKTtcbiAgICAgICAgYXNzaWduVmFsaWQoY29kZWdlbl8xLm5pbCk7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZUVycnM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFzc2lnblZhbGlkKF9hd2FpdCA9IGRlZi5hc3luYyA/ICgwLCBjb2RlZ2VuXzEuXykgYGF3YWl0IGAgOiBjb2RlZ2VuXzEubmlsKSB7XG4gICAgICAgIGNvbnN0IHBhc3NDeHQgPSBpdC5vcHRzLnBhc3NDb250ZXh0ID8gbmFtZXNfMS5kZWZhdWx0LnRoaXMgOiBuYW1lc18xLmRlZmF1bHQuc2VsZjtcbiAgICAgICAgY29uc3QgcGFzc1NjaGVtYSA9ICEoKFwiY29tcGlsZVwiIGluIGRlZiAmJiAhJGRhdGEpIHx8IGRlZi5zY2hlbWEgPT09IGZhbHNlKTtcbiAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgKDAsIGNvZGVnZW5fMS5fKSBgJHtfYXdhaXR9JHsoMCwgY29kZV8xLmNhbGxWYWxpZGF0ZUNvZGUpKGN4dCwgdmFsaWRhdGVSZWYsIHBhc3NDeHQsIHBhc3NTY2hlbWEpfWAsIGRlZi5tb2RpZnlpbmcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXBvcnRFcnJzKGVycm9ycykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLm5vdCkoKF9hID0gZGVmLnZhbGlkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB2YWxpZCksIGVycm9ycyk7XG4gICAgfVxufVxuZXhwb3J0cy5mdW5jS2V5d29yZENvZGUgPSBmdW5jS2V5d29yZENvZGU7XG5mdW5jdGlvbiBtb2RpZnlEYXRhKGN4dCkge1xuICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBpdCB9ID0gY3h0O1xuICAgIGdlbi5pZihpdC5wYXJlbnREYXRhLCAoKSA9PiBnZW4uYXNzaWduKGRhdGEsICgwLCBjb2RlZ2VuXzEuXykgYCR7aXQucGFyZW50RGF0YX1bJHtpdC5wYXJlbnREYXRhUHJvcGVydHl9XWApKTtcbn1cbmZ1bmN0aW9uIGFkZEVycnMoY3h0LCBlcnJzKSB7XG4gICAgY29uc3QgeyBnZW4gfSA9IGN4dDtcbiAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgQXJyYXkuaXNBcnJheSgke2VycnN9KWAsICgpID0+IHtcbiAgICAgICAgZ2VuXG4gICAgICAgICAgICAuYXNzaWduKG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzLCAoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfSA9PT0gbnVsbCA/ICR7ZXJyc30gOiAke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfS5jb25jYXQoJHtlcnJzfSlgKVxuICAgICAgICAgICAgLmFzc2lnbihuYW1lc18xLmRlZmF1bHQuZXJyb3JzLCAoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfS5sZW5ndGhgKTtcbiAgICAgICAgKDAsIGVycm9yc18xLmV4dGVuZEVycm9ycykoY3h0KTtcbiAgICB9LCAoKSA9PiBjeHQuZXJyb3IoKSk7XG59XG5mdW5jdGlvbiBjaGVja0FzeW5jS2V5d29yZCh7IHNjaGVtYUVudiB9LCBkZWYpIHtcbiAgICBpZiAoZGVmLmFzeW5jICYmICFzY2hlbWFFbnYuJGFzeW5jKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhc3luYyBrZXl3b3JkIGluIHN5bmMgc2NoZW1hXCIpO1xufVxuZnVuY3Rpb24gdXNlS2V5d29yZChnZW4sIGtleXdvcmQsIHJlc3VsdCkge1xuICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBrZXl3b3JkIFwiJHtrZXl3b3JkfVwiIGZhaWxlZCB0byBjb21waWxlYCk7XG4gICAgcmV0dXJuIGdlbi5zY29wZVZhbHVlKFwia2V5d29yZFwiLCB0eXBlb2YgcmVzdWx0ID09IFwiZnVuY3Rpb25cIiA/IHsgcmVmOiByZXN1bHQgfSA6IHsgcmVmOiByZXN1bHQsIGNvZGU6ICgwLCBjb2RlZ2VuXzEuc3RyaW5naWZ5KShyZXN1bHQpIH0pO1xufVxuZnVuY3Rpb24gdmFsaWRTY2hlbWFUeXBlKHNjaGVtYSwgc2NoZW1hVHlwZSwgYWxsb3dVbmRlZmluZWQgPSBmYWxzZSkge1xuICAgIC8vIFRPRE8gYWRkIHRlc3RzXG4gICAgcmV0dXJuICghc2NoZW1hVHlwZS5sZW5ndGggfHxcbiAgICAgICAgc2NoZW1hVHlwZS5zb21lKChzdCkgPT4gc3QgPT09IFwiYXJyYXlcIlxuICAgICAgICAgICAgPyBBcnJheS5pc0FycmF5KHNjaGVtYSlcbiAgICAgICAgICAgIDogc3QgPT09IFwib2JqZWN0XCJcbiAgICAgICAgICAgICAgICA/IHNjaGVtYSAmJiB0eXBlb2Ygc2NoZW1hID09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkoc2NoZW1hKVxuICAgICAgICAgICAgICAgIDogdHlwZW9mIHNjaGVtYSA9PSBzdCB8fCAoYWxsb3dVbmRlZmluZWQgJiYgdHlwZW9mIHNjaGVtYSA9PSBcInVuZGVmaW5lZFwiKSkpO1xufVxuZXhwb3J0cy52YWxpZFNjaGVtYVR5cGUgPSB2YWxpZFNjaGVtYVR5cGU7XG5mdW5jdGlvbiB2YWxpZGF0ZUtleXdvcmRVc2FnZSh7IHNjaGVtYSwgb3B0cywgc2VsZiwgZXJyU2NoZW1hUGF0aCB9LCBkZWYsIGtleXdvcmQpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoQXJyYXkuaXNBcnJheShkZWYua2V5d29yZCkgPyAhZGVmLmtleXdvcmQuaW5jbHVkZXMoa2V5d29yZCkgOiBkZWYua2V5d29yZCAhPT0ga2V5d29yZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIik7XG4gICAgfVxuICAgIGNvbnN0IGRlcHMgPSBkZWYuZGVwZW5kZW5jaWVzO1xuICAgIGlmIChkZXBzID09PSBudWxsIHx8IGRlcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRlcHMuc29tZSgoa3dkKSA9PiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNjaGVtYSwga3dkKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwYXJlbnQgc2NoZW1hIG11c3QgaGF2ZSBkZXBlbmRlbmNpZXMgb2YgJHtrZXl3b3JkfTogJHtkZXBzLmpvaW4oXCIsXCIpfWApO1xuICAgIH1cbiAgICBpZiAoZGVmLnZhbGlkYXRlU2NoZW1hKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZGVmLnZhbGlkYXRlU2NoZW1hKHNjaGVtYVtrZXl3b3JkXSk7XG4gICAgICAgIGlmICghdmFsaWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IGBrZXl3b3JkIFwiJHtrZXl3b3JkfVwiIHZhbHVlIGlzIGludmFsaWQgYXQgcGF0aCBcIiR7ZXJyU2NoZW1hUGF0aH1cIjogYCArXG4gICAgICAgICAgICAgICAgc2VsZi5lcnJvcnNUZXh0KGRlZi52YWxpZGF0ZVNjaGVtYS5lcnJvcnMpO1xuICAgICAgICAgICAgaWYgKG9wdHMudmFsaWRhdGVTY2hlbWEgPT09IFwibG9nXCIpXG4gICAgICAgICAgICAgICAgc2VsZi5sb2dnZXIuZXJyb3IobXNnKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVLZXl3b3JkVXNhZ2UgPSB2YWxpZGF0ZUtleXdvcmRVc2FnZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWtleXdvcmQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmV4dGVuZFN1YnNjaGVtYU1vZGUgPSBleHBvcnRzLmV4dGVuZFN1YnNjaGVtYURhdGEgPSBleHBvcnRzLmdldFN1YnNjaGVtYSA9IHZvaWQgMDtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5mdW5jdGlvbiBnZXRTdWJzY2hlbWEoaXQsIHsga2V5d29yZCwgc2NoZW1hUHJvcCwgc2NoZW1hLCBzY2hlbWFQYXRoLCBlcnJTY2hlbWFQYXRoLCB0b3BTY2hlbWFSZWYgfSkge1xuICAgIGlmIChrZXl3b3JkICE9PSB1bmRlZmluZWQgJiYgc2NoZW1hICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdib3RoIFwia2V5d29yZFwiIGFuZCBcInNjaGVtYVwiIHBhc3NlZCwgb25seSBvbmUgYWxsb3dlZCcpO1xuICAgIH1cbiAgICBpZiAoa2V5d29yZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHNjaCA9IGl0LnNjaGVtYVtrZXl3b3JkXTtcbiAgICAgICAgcmV0dXJuIHNjaGVtYVByb3AgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgc2NoZW1hOiBzY2gsXG4gICAgICAgICAgICAgICAgc2NoZW1hUGF0aDogKDAsIGNvZGVnZW5fMS5fKSBgJHtpdC5zY2hlbWFQYXRofSR7KDAsIGNvZGVnZW5fMS5nZXRQcm9wZXJ0eSkoa2V5d29yZCl9YCxcbiAgICAgICAgICAgICAgICBlcnJTY2hlbWFQYXRoOiBgJHtpdC5lcnJTY2hlbWFQYXRofS8ke2tleXdvcmR9YCxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgIHNjaGVtYTogc2NoW3NjaGVtYVByb3BdLFxuICAgICAgICAgICAgICAgIHNjaGVtYVBhdGg6ICgwLCBjb2RlZ2VuXzEuXykgYCR7aXQuc2NoZW1hUGF0aH0keygwLCBjb2RlZ2VuXzEuZ2V0UHJvcGVydHkpKGtleXdvcmQpfSR7KDAsIGNvZGVnZW5fMS5nZXRQcm9wZXJ0eSkoc2NoZW1hUHJvcCl9YCxcbiAgICAgICAgICAgICAgICBlcnJTY2hlbWFQYXRoOiBgJHtpdC5lcnJTY2hlbWFQYXRofS8ke2tleXdvcmR9LyR7KDAsIHV0aWxfMS5lc2NhcGVGcmFnbWVudCkoc2NoZW1hUHJvcCl9YCxcbiAgICAgICAgICAgIH07XG4gICAgfVxuICAgIGlmIChzY2hlbWEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoc2NoZW1hUGF0aCA9PT0gdW5kZWZpbmVkIHx8IGVyclNjaGVtYVBhdGggPT09IHVuZGVmaW5lZCB8fCB0b3BTY2hlbWFSZWYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcInNjaGVtYVBhdGhcIiwgXCJlcnJTY2hlbWFQYXRoXCIgYW5kIFwidG9wU2NoZW1hUmVmXCIgYXJlIHJlcXVpcmVkIHdpdGggXCJzY2hlbWFcIicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzY2hlbWEsXG4gICAgICAgICAgICBzY2hlbWFQYXRoLFxuICAgICAgICAgICAgdG9wU2NoZW1hUmVmLFxuICAgICAgICAgICAgZXJyU2NoZW1hUGF0aCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdlaXRoZXIgXCJrZXl3b3JkXCIgb3IgXCJzY2hlbWFcIiBtdXN0IGJlIHBhc3NlZCcpO1xufVxuZXhwb3J0cy5nZXRTdWJzY2hlbWEgPSBnZXRTdWJzY2hlbWE7XG5mdW5jdGlvbiBleHRlbmRTdWJzY2hlbWFEYXRhKHN1YnNjaGVtYSwgaXQsIHsgZGF0YVByb3AsIGRhdGFQcm9wVHlwZTogZHBUeXBlLCBkYXRhLCBkYXRhVHlwZXMsIHByb3BlcnR5TmFtZSB9KSB7XG4gICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCAmJiBkYXRhUHJvcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYm90aCBcImRhdGFcIiBhbmQgXCJkYXRhUHJvcFwiIHBhc3NlZCwgb25seSBvbmUgYWxsb3dlZCcpO1xuICAgIH1cbiAgICBjb25zdCB7IGdlbiB9ID0gaXQ7XG4gICAgaWYgKGRhdGFQcm9wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgeyBlcnJvclBhdGgsIGRhdGFQYXRoQXJyLCBvcHRzIH0gPSBpdDtcbiAgICAgICAgY29uc3QgbmV4dERhdGEgPSBnZW4ubGV0KFwiZGF0YVwiLCAoMCwgY29kZWdlbl8xLl8pIGAke2l0LmRhdGF9JHsoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KShkYXRhUHJvcCl9YCwgdHJ1ZSk7XG4gICAgICAgIGRhdGFDb250ZXh0UHJvcHMobmV4dERhdGEpO1xuICAgICAgICBzdWJzY2hlbWEuZXJyb3JQYXRoID0gKDAsIGNvZGVnZW5fMS5zdHIpIGAke2Vycm9yUGF0aH0keygwLCB1dGlsXzEuZ2V0RXJyb3JQYXRoKShkYXRhUHJvcCwgZHBUeXBlLCBvcHRzLmpzUHJvcGVydHlTeW50YXgpfWA7XG4gICAgICAgIHN1YnNjaGVtYS5wYXJlbnREYXRhUHJvcGVydHkgPSAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGFQcm9wfWA7XG4gICAgICAgIHN1YnNjaGVtYS5kYXRhUGF0aEFyciA9IFsuLi5kYXRhUGF0aEFyciwgc3Vic2NoZW1hLnBhcmVudERhdGFQcm9wZXJ0eV07XG4gICAgfVxuICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgbmV4dERhdGEgPSBkYXRhIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUgPyBkYXRhIDogZ2VuLmxldChcImRhdGFcIiwgZGF0YSwgdHJ1ZSk7IC8vIHJlcGxhY2VhYmxlIGlmIHVzZWQgb25jZT9cbiAgICAgICAgZGF0YUNvbnRleHRQcm9wcyhuZXh0RGF0YSk7XG4gICAgICAgIGlmIChwcm9wZXJ0eU5hbWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHN1YnNjaGVtYS5wcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eU5hbWU7XG4gICAgICAgIC8vIFRPRE8gc29tZXRoaW5nIGlzIHBvc3NpYmx5IHdyb25nIGhlcmUgd2l0aCBub3QgY2hhbmdpbmcgcGFyZW50RGF0YVByb3BlcnR5IGFuZCBub3QgYXBwZW5kaW5nIGRhdGFQYXRoQXJyXG4gICAgfVxuICAgIGlmIChkYXRhVHlwZXMpXG4gICAgICAgIHN1YnNjaGVtYS5kYXRhVHlwZXMgPSBkYXRhVHlwZXM7XG4gICAgZnVuY3Rpb24gZGF0YUNvbnRleHRQcm9wcyhfbmV4dERhdGEpIHtcbiAgICAgICAgc3Vic2NoZW1hLmRhdGEgPSBfbmV4dERhdGE7XG4gICAgICAgIHN1YnNjaGVtYS5kYXRhTGV2ZWwgPSBpdC5kYXRhTGV2ZWwgKyAxO1xuICAgICAgICBzdWJzY2hlbWEuZGF0YVR5cGVzID0gW107XG4gICAgICAgIGl0LmRlZmluZWRQcm9wZXJ0aWVzID0gbmV3IFNldCgpO1xuICAgICAgICBzdWJzY2hlbWEucGFyZW50RGF0YSA9IGl0LmRhdGE7XG4gICAgICAgIHN1YnNjaGVtYS5kYXRhTmFtZXMgPSBbLi4uaXQuZGF0YU5hbWVzLCBfbmV4dERhdGFdO1xuICAgIH1cbn1cbmV4cG9ydHMuZXh0ZW5kU3Vic2NoZW1hRGF0YSA9IGV4dGVuZFN1YnNjaGVtYURhdGE7XG5mdW5jdGlvbiBleHRlbmRTdWJzY2hlbWFNb2RlKHN1YnNjaGVtYSwgeyBqdGREaXNjcmltaW5hdG9yLCBqdGRNZXRhZGF0YSwgY29tcG9zaXRlUnVsZSwgY3JlYXRlRXJyb3JzLCBhbGxFcnJvcnMgfSkge1xuICAgIGlmIChjb21wb3NpdGVSdWxlICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHN1YnNjaGVtYS5jb21wb3NpdGVSdWxlID0gY29tcG9zaXRlUnVsZTtcbiAgICBpZiAoY3JlYXRlRXJyb3JzICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHN1YnNjaGVtYS5jcmVhdGVFcnJvcnMgPSBjcmVhdGVFcnJvcnM7XG4gICAgaWYgKGFsbEVycm9ycyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICBzdWJzY2hlbWEuYWxsRXJyb3JzID0gYWxsRXJyb3JzO1xuICAgIHN1YnNjaGVtYS5qdGREaXNjcmltaW5hdG9yID0ganRkRGlzY3JpbWluYXRvcjsgLy8gbm90IGluaGVyaXRlZFxuICAgIHN1YnNjaGVtYS5qdGRNZXRhZGF0YSA9IGp0ZE1ldGFkYXRhOyAvLyBub3QgaW5oZXJpdGVkXG59XG5leHBvcnRzLmV4dGVuZFN1YnNjaGVtYU1vZGUgPSBleHRlbmRTdWJzY2hlbWFNb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3Vic2NoZW1hLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuLy8gZG8gbm90IGVkaXQgLmpzIGZpbGVzIGRpcmVjdGx5IC0gZWRpdCBzcmMvaW5kZXguanN0XG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlO1xuXG4gIGlmIChhICYmIGIgJiYgdHlwZW9mIGEgPT0gJ29iamVjdCcgJiYgdHlwZW9mIGIgPT0gJ29iamVjdCcpIHtcbiAgICBpZiAoYS5jb25zdHJ1Y3RvciAhPT0gYi5jb25zdHJ1Y3RvcikgcmV0dXJuIGZhbHNlO1xuXG4gICAgdmFyIGxlbmd0aCwgaSwga2V5cztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoICE9IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspXG4gICAgICAgIGlmICghZXF1YWwoYVtpXSwgYltpXSkpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuXG5cbiAgICBpZiAoYS5jb25zdHJ1Y3RvciA9PT0gUmVnRXhwKSByZXR1cm4gYS5zb3VyY2UgPT09IGIuc291cmNlICYmIGEuZmxhZ3MgPT09IGIuZmxhZ3M7XG4gICAgaWYgKGEudmFsdWVPZiAhPT0gT2JqZWN0LnByb3RvdHlwZS52YWx1ZU9mKSByZXR1cm4gYS52YWx1ZU9mKCkgPT09IGIudmFsdWVPZigpO1xuICAgIGlmIChhLnRvU3RyaW5nICE9PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKSByZXR1cm4gYS50b1N0cmluZygpID09PSBiLnRvU3RyaW5nKCk7XG5cbiAgICBrZXlzID0gT2JqZWN0LmtleXMoYSk7XG4gICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCAhPT0gT2JqZWN0LmtleXMoYikubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspXG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBrZXlzW2ldKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKCFlcXVhbChhW2tleV0sIGJba2V5XSkpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIHRydWUgaWYgYm90aCBOYU4sIGZhbHNlIG90aGVyd2lzZVxuICByZXR1cm4gYSE9PWEgJiYgYiE9PWI7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdHJhdmVyc2UgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzY2hlbWEsIG9wdHMsIGNiKSB7XG4gIC8vIExlZ2FjeSBzdXBwb3J0IGZvciB2MC4zLjEgYW5kIGVhcmxpZXIuXG4gIGlmICh0eXBlb2Ygb3B0cyA9PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBvcHRzO1xuICAgIG9wdHMgPSB7fTtcbiAgfVxuXG4gIGNiID0gb3B0cy5jYiB8fCBjYjtcbiAgdmFyIHByZSA9ICh0eXBlb2YgY2IgPT0gJ2Z1bmN0aW9uJykgPyBjYiA6IGNiLnByZSB8fCBmdW5jdGlvbigpIHt9O1xuICB2YXIgcG9zdCA9IGNiLnBvc3QgfHwgZnVuY3Rpb24oKSB7fTtcblxuICBfdHJhdmVyc2Uob3B0cywgcHJlLCBwb3N0LCBzY2hlbWEsICcnLCBzY2hlbWEpO1xufTtcblxuXG50cmF2ZXJzZS5rZXl3b3JkcyA9IHtcbiAgYWRkaXRpb25hbEl0ZW1zOiB0cnVlLFxuICBpdGVtczogdHJ1ZSxcbiAgY29udGFpbnM6IHRydWUsXG4gIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiB0cnVlLFxuICBwcm9wZXJ0eU5hbWVzOiB0cnVlLFxuICBub3Q6IHRydWUsXG4gIGlmOiB0cnVlLFxuICB0aGVuOiB0cnVlLFxuICBlbHNlOiB0cnVlXG59O1xuXG50cmF2ZXJzZS5hcnJheUtleXdvcmRzID0ge1xuICBpdGVtczogdHJ1ZSxcbiAgYWxsT2Y6IHRydWUsXG4gIGFueU9mOiB0cnVlLFxuICBvbmVPZjogdHJ1ZVxufTtcblxudHJhdmVyc2UucHJvcHNLZXl3b3JkcyA9IHtcbiAgJGRlZnM6IHRydWUsXG4gIGRlZmluaXRpb25zOiB0cnVlLFxuICBwcm9wZXJ0aWVzOiB0cnVlLFxuICBwYXR0ZXJuUHJvcGVydGllczogdHJ1ZSxcbiAgZGVwZW5kZW5jaWVzOiB0cnVlXG59O1xuXG50cmF2ZXJzZS5za2lwS2V5d29yZHMgPSB7XG4gIGRlZmF1bHQ6IHRydWUsXG4gIGVudW06IHRydWUsXG4gIGNvbnN0OiB0cnVlLFxuICByZXF1aXJlZDogdHJ1ZSxcbiAgbWF4aW11bTogdHJ1ZSxcbiAgbWluaW11bTogdHJ1ZSxcbiAgZXhjbHVzaXZlTWF4aW11bTogdHJ1ZSxcbiAgZXhjbHVzaXZlTWluaW11bTogdHJ1ZSxcbiAgbXVsdGlwbGVPZjogdHJ1ZSxcbiAgbWF4TGVuZ3RoOiB0cnVlLFxuICBtaW5MZW5ndGg6IHRydWUsXG4gIHBhdHRlcm46IHRydWUsXG4gIGZvcm1hdDogdHJ1ZSxcbiAgbWF4SXRlbXM6IHRydWUsXG4gIG1pbkl0ZW1zOiB0cnVlLFxuICB1bmlxdWVJdGVtczogdHJ1ZSxcbiAgbWF4UHJvcGVydGllczogdHJ1ZSxcbiAgbWluUHJvcGVydGllczogdHJ1ZVxufTtcblxuXG5mdW5jdGlvbiBfdHJhdmVyc2Uob3B0cywgcHJlLCBwb3N0LCBzY2hlbWEsIGpzb25QdHIsIHJvb3RTY2hlbWEsIHBhcmVudEpzb25QdHIsIHBhcmVudEtleXdvcmQsIHBhcmVudFNjaGVtYSwga2V5SW5kZXgpIHtcbiAgaWYgKHNjaGVtYSAmJiB0eXBlb2Ygc2NoZW1hID09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHNjaGVtYSkpIHtcbiAgICBwcmUoc2NoZW1hLCBqc29uUHRyLCByb290U2NoZW1hLCBwYXJlbnRKc29uUHRyLCBwYXJlbnRLZXl3b3JkLCBwYXJlbnRTY2hlbWEsIGtleUluZGV4KTtcbiAgICBmb3IgKHZhciBrZXkgaW4gc2NoZW1hKSB7XG4gICAgICB2YXIgc2NoID0gc2NoZW1hW2tleV07XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2gpKSB7XG4gICAgICAgIGlmIChrZXkgaW4gdHJhdmVyc2UuYXJyYXlLZXl3b3Jkcykge1xuICAgICAgICAgIGZvciAodmFyIGk9MDsgaTxzY2gubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBfdHJhdmVyc2Uob3B0cywgcHJlLCBwb3N0LCBzY2hbaV0sIGpzb25QdHIgKyAnLycgKyBrZXkgKyAnLycgKyBpLCByb290U2NoZW1hLCBqc29uUHRyLCBrZXksIHNjaGVtYSwgaSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoa2V5IGluIHRyYXZlcnNlLnByb3BzS2V5d29yZHMpIHtcbiAgICAgICAgaWYgKHNjaCAmJiB0eXBlb2Ygc2NoID09ICdvYmplY3QnKSB7XG4gICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBzY2gpXG4gICAgICAgICAgICBfdHJhdmVyc2Uob3B0cywgcHJlLCBwb3N0LCBzY2hbcHJvcF0sIGpzb25QdHIgKyAnLycgKyBrZXkgKyAnLycgKyBlc2NhcGVKc29uUHRyKHByb3ApLCByb290U2NoZW1hLCBqc29uUHRyLCBrZXksIHNjaGVtYSwgcHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoa2V5IGluIHRyYXZlcnNlLmtleXdvcmRzIHx8IChvcHRzLmFsbEtleXMgJiYgIShrZXkgaW4gdHJhdmVyc2Uuc2tpcEtleXdvcmRzKSkpIHtcbiAgICAgICAgX3RyYXZlcnNlKG9wdHMsIHByZSwgcG9zdCwgc2NoLCBqc29uUHRyICsgJy8nICsga2V5LCByb290U2NoZW1hLCBqc29uUHRyLCBrZXksIHNjaGVtYSk7XG4gICAgICB9XG4gICAgfVxuICAgIHBvc3Qoc2NoZW1hLCBqc29uUHRyLCByb290U2NoZW1hLCBwYXJlbnRKc29uUHRyLCBwYXJlbnRLZXl3b3JkLCBwYXJlbnRTY2hlbWEsIGtleUluZGV4KTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGVzY2FwZUpzb25QdHIoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvfi9nLCAnfjAnKS5yZXBsYWNlKC9cXC8vZywgJ34xJyk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0U2NoZW1hUmVmcyA9IGV4cG9ydHMucmVzb2x2ZVVybCA9IGV4cG9ydHMubm9ybWFsaXplSWQgPSBleHBvcnRzLl9nZXRGdWxsUGF0aCA9IGV4cG9ydHMuZ2V0RnVsbFBhdGggPSBleHBvcnRzLmlubGluZVJlZiA9IHZvaWQgMDtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5jb25zdCBlcXVhbCA9IHJlcXVpcmUoXCJmYXN0LWRlZXAtZXF1YWxcIik7XG5jb25zdCB0cmF2ZXJzZSA9IHJlcXVpcmUoXCJqc29uLXNjaGVtYS10cmF2ZXJzZVwiKTtcbi8vIFRPRE8gcmVmYWN0b3IgdG8gdXNlIGtleXdvcmQgZGVmaW5pdGlvbnNcbmNvbnN0IFNJTVBMRV9JTkxJTkVEID0gbmV3IFNldChbXG4gICAgXCJ0eXBlXCIsXG4gICAgXCJmb3JtYXRcIixcbiAgICBcInBhdHRlcm5cIixcbiAgICBcIm1heExlbmd0aFwiLFxuICAgIFwibWluTGVuZ3RoXCIsXG4gICAgXCJtYXhQcm9wZXJ0aWVzXCIsXG4gICAgXCJtaW5Qcm9wZXJ0aWVzXCIsXG4gICAgXCJtYXhJdGVtc1wiLFxuICAgIFwibWluSXRlbXNcIixcbiAgICBcIm1heGltdW1cIixcbiAgICBcIm1pbmltdW1cIixcbiAgICBcInVuaXF1ZUl0ZW1zXCIsXG4gICAgXCJtdWx0aXBsZU9mXCIsXG4gICAgXCJyZXF1aXJlZFwiLFxuICAgIFwiZW51bVwiLFxuICAgIFwiY29uc3RcIixcbl0pO1xuZnVuY3Rpb24gaW5saW5lUmVmKHNjaGVtYSwgbGltaXQgPSB0cnVlKSB7XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmIChsaW1pdCA9PT0gdHJ1ZSlcbiAgICAgICAgcmV0dXJuICFoYXNSZWYoc2NoZW1hKTtcbiAgICBpZiAoIWxpbWl0KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIGNvdW50S2V5cyhzY2hlbWEpIDw9IGxpbWl0O1xufVxuZXhwb3J0cy5pbmxpbmVSZWYgPSBpbmxpbmVSZWY7XG5jb25zdCBSRUZfS0VZV09SRFMgPSBuZXcgU2V0KFtcbiAgICBcIiRyZWZcIixcbiAgICBcIiRyZWN1cnNpdmVSZWZcIixcbiAgICBcIiRyZWN1cnNpdmVBbmNob3JcIixcbiAgICBcIiRkeW5hbWljUmVmXCIsXG4gICAgXCIkZHluYW1pY0FuY2hvclwiLFxuXSk7XG5mdW5jdGlvbiBoYXNSZWYoc2NoZW1hKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSB7XG4gICAgICAgIGlmIChSRUZfS0VZV09SRFMuaGFzKGtleSkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY29uc3Qgc2NoID0gc2NoZW1hW2tleV07XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaCkgJiYgc2NoLnNvbWUoaGFzUmVmKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAodHlwZW9mIHNjaCA9PSBcIm9iamVjdFwiICYmIGhhc1JlZihzY2gpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNvdW50S2V5cyhzY2hlbWEpIHtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSkge1xuICAgICAgICBpZiAoa2V5ID09PSBcIiRyZWZcIilcbiAgICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICAgICAgY291bnQrKztcbiAgICAgICAgaWYgKFNJTVBMRV9JTkxJTkVELmhhcyhrZXkpKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hW2tleV0gPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgKDAsIHV0aWxfMS5lYWNoSXRlbSkoc2NoZW1hW2tleV0sIChzY2gpID0+IChjb3VudCArPSBjb3VudEtleXMoc2NoKSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb3VudCA9PT0gSW5maW5pdHkpXG4gICAgICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgfVxuICAgIHJldHVybiBjb3VudDtcbn1cbmZ1bmN0aW9uIGdldEZ1bGxQYXRoKHJlc29sdmVyLCBpZCA9IFwiXCIsIG5vcm1hbGl6ZSkge1xuICAgIGlmIChub3JtYWxpemUgIT09IGZhbHNlKVxuICAgICAgICBpZCA9IG5vcm1hbGl6ZUlkKGlkKTtcbiAgICBjb25zdCBwID0gcmVzb2x2ZXIucGFyc2UoaWQpO1xuICAgIHJldHVybiBfZ2V0RnVsbFBhdGgocmVzb2x2ZXIsIHApO1xufVxuZXhwb3J0cy5nZXRGdWxsUGF0aCA9IGdldEZ1bGxQYXRoO1xuZnVuY3Rpb24gX2dldEZ1bGxQYXRoKHJlc29sdmVyLCBwKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IHJlc29sdmVyLnNlcmlhbGl6ZShwKTtcbiAgICByZXR1cm4gc2VyaWFsaXplZC5zcGxpdChcIiNcIilbMF0gKyBcIiNcIjtcbn1cbmV4cG9ydHMuX2dldEZ1bGxQYXRoID0gX2dldEZ1bGxQYXRoO1xuY29uc3QgVFJBSUxJTkdfU0xBU0hfSEFTSCA9IC8jXFwvPyQvO1xuZnVuY3Rpb24gbm9ybWFsaXplSWQoaWQpIHtcbiAgICByZXR1cm4gaWQgPyBpZC5yZXBsYWNlKFRSQUlMSU5HX1NMQVNIX0hBU0gsIFwiXCIpIDogXCJcIjtcbn1cbmV4cG9ydHMubm9ybWFsaXplSWQgPSBub3JtYWxpemVJZDtcbmZ1bmN0aW9uIHJlc29sdmVVcmwocmVzb2x2ZXIsIGJhc2VJZCwgaWQpIHtcbiAgICBpZCA9IG5vcm1hbGl6ZUlkKGlkKTtcbiAgICByZXR1cm4gcmVzb2x2ZXIucmVzb2x2ZShiYXNlSWQsIGlkKTtcbn1cbmV4cG9ydHMucmVzb2x2ZVVybCA9IHJlc29sdmVVcmw7XG5jb25zdCBBTkNIT1IgPSAvXlthLXpfXVstYS16MC05Ll9dKiQvaTtcbmZ1bmN0aW9uIGdldFNjaGVtYVJlZnMoc2NoZW1hLCBiYXNlSWQpIHtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIilcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIGNvbnN0IHsgc2NoZW1hSWQsIHVyaVJlc29sdmVyIH0gPSB0aGlzLm9wdHM7XG4gICAgY29uc3Qgc2NoSWQgPSBub3JtYWxpemVJZChzY2hlbWFbc2NoZW1hSWRdIHx8IGJhc2VJZCk7XG4gICAgY29uc3QgYmFzZUlkcyA9IHsgXCJcIjogc2NoSWQgfTtcbiAgICBjb25zdCBwYXRoUHJlZml4ID0gZ2V0RnVsbFBhdGgodXJpUmVzb2x2ZXIsIHNjaElkLCBmYWxzZSk7XG4gICAgY29uc3QgbG9jYWxSZWZzID0ge307XG4gICAgY29uc3Qgc2NoZW1hUmVmcyA9IG5ldyBTZXQoKTtcbiAgICB0cmF2ZXJzZShzY2hlbWEsIHsgYWxsS2V5czogdHJ1ZSB9LCAoc2NoLCBqc29uUHRyLCBfLCBwYXJlbnRKc29uUHRyKSA9PiB7XG4gICAgICAgIGlmIChwYXJlbnRKc29uUHRyID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGZ1bGxQYXRoID0gcGF0aFByZWZpeCArIGpzb25QdHI7XG4gICAgICAgIGxldCBpbm5lckJhc2VJZCA9IGJhc2VJZHNbcGFyZW50SnNvblB0cl07XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoW3NjaGVtYUlkXSA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgaW5uZXJCYXNlSWQgPSBhZGRSZWYuY2FsbCh0aGlzLCBzY2hbc2NoZW1hSWRdKTtcbiAgICAgICAgYWRkQW5jaG9yLmNhbGwodGhpcywgc2NoLiRhbmNob3IpO1xuICAgICAgICBhZGRBbmNob3IuY2FsbCh0aGlzLCBzY2guJGR5bmFtaWNBbmNob3IpO1xuICAgICAgICBiYXNlSWRzW2pzb25QdHJdID0gaW5uZXJCYXNlSWQ7XG4gICAgICAgIGZ1bmN0aW9uIGFkZFJlZihyZWYpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5ib3VuZC1tZXRob2RcbiAgICAgICAgICAgIGNvbnN0IF9yZXNvbHZlID0gdGhpcy5vcHRzLnVyaVJlc29sdmVyLnJlc29sdmU7XG4gICAgICAgICAgICByZWYgPSBub3JtYWxpemVJZChpbm5lckJhc2VJZCA/IF9yZXNvbHZlKGlubmVyQmFzZUlkLCByZWYpIDogcmVmKTtcbiAgICAgICAgICAgIGlmIChzY2hlbWFSZWZzLmhhcyhyZWYpKVxuICAgICAgICAgICAgICAgIHRocm93IGFtYmlndW9zKHJlZik7XG4gICAgICAgICAgICBzY2hlbWFSZWZzLmFkZChyZWYpO1xuICAgICAgICAgICAgbGV0IHNjaE9yUmVmID0gdGhpcy5yZWZzW3JlZl07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNjaE9yUmVmID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgc2NoT3JSZWYgPSB0aGlzLnJlZnNbc2NoT3JSZWZdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzY2hPclJlZiA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgY2hlY2tBbWJpZ3Vvc1JlZihzY2gsIHNjaE9yUmVmLnNjaGVtYSwgcmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlZiAhPT0gbm9ybWFsaXplSWQoZnVsbFBhdGgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlZlswXSA9PT0gXCIjXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tBbWJpZ3Vvc1JlZihzY2gsIGxvY2FsUmVmc1tyZWZdLCByZWYpO1xuICAgICAgICAgICAgICAgICAgICBsb2NhbFJlZnNbcmVmXSA9IHNjaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVmc1tyZWZdID0gZnVsbFBhdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlZjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhZGRBbmNob3IoYW5jaG9yKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGFuY2hvciA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBTkNIT1IudGVzdChhbmNob3IpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgYW5jaG9yIFwiJHthbmNob3J9XCJgKTtcbiAgICAgICAgICAgICAgICBhZGRSZWYuY2FsbCh0aGlzLCBgIyR7YW5jaG9yfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGxvY2FsUmVmcztcbiAgICBmdW5jdGlvbiBjaGVja0FtYmlndW9zUmVmKHNjaDEsIHNjaDIsIHJlZikge1xuICAgICAgICBpZiAoc2NoMiAhPT0gdW5kZWZpbmVkICYmICFlcXVhbChzY2gxLCBzY2gyKSlcbiAgICAgICAgICAgIHRocm93IGFtYmlndW9zKHJlZik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFtYmlndW9zKHJlZikge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKGByZWZlcmVuY2UgXCIke3JlZn1cIiByZXNvbHZlcyB0byBtb3JlIHRoYW4gb25lIHNjaGVtYWApO1xuICAgIH1cbn1cbmV4cG9ydHMuZ2V0U2NoZW1hUmVmcyA9IGdldFNjaGVtYVJlZnM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvbHZlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXREYXRhID0gZXhwb3J0cy5LZXl3b3JkQ3h0ID0gZXhwb3J0cy52YWxpZGF0ZUZ1bmN0aW9uQ29kZSA9IHZvaWQgMDtcbmNvbnN0IGJvb2xTY2hlbWFfMSA9IHJlcXVpcmUoXCIuL2Jvb2xTY2hlbWFcIik7XG5jb25zdCBkYXRhVHlwZV8xID0gcmVxdWlyZShcIi4vZGF0YVR5cGVcIik7XG5jb25zdCBhcHBsaWNhYmlsaXR5XzEgPSByZXF1aXJlKFwiLi9hcHBsaWNhYmlsaXR5XCIpO1xuY29uc3QgZGF0YVR5cGVfMiA9IHJlcXVpcmUoXCIuL2RhdGFUeXBlXCIpO1xuY29uc3QgZGVmYXVsdHNfMSA9IHJlcXVpcmUoXCIuL2RlZmF1bHRzXCIpO1xuY29uc3Qga2V5d29yZF8xID0gcmVxdWlyZShcIi4va2V5d29yZFwiKTtcbmNvbnN0IHN1YnNjaGVtYV8xID0gcmVxdWlyZShcIi4vc3Vic2NoZW1hXCIpO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uL2NvZGVnZW5cIik7XG5jb25zdCBuYW1lc18xID0gcmVxdWlyZShcIi4uL25hbWVzXCIpO1xuY29uc3QgcmVzb2x2ZV8xID0gcmVxdWlyZShcIi4uL3Jlc29sdmVcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbi8vIHNjaGVtYSBjb21waWxhdGlvbiAtIGdlbmVyYXRlcyB2YWxpZGF0aW9uIGZ1bmN0aW9uLCBzdWJzY2hlbWFDb2RlIChiZWxvdykgaXMgdXNlZCBmb3Igc3Vic2NoZW1hc1xuZnVuY3Rpb24gdmFsaWRhdGVGdW5jdGlvbkNvZGUoaXQpIHtcbiAgICBpZiAoaXNTY2hlbWFPYmooaXQpKSB7XG4gICAgICAgIGNoZWNrS2V5d29yZHMoaXQpO1xuICAgICAgICBpZiAoc2NoZW1hQ3h0SGFzUnVsZXMoaXQpKSB7XG4gICAgICAgICAgICB0b3BTY2hlbWFPYmpDb2RlKGl0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YWxpZGF0ZUZ1bmN0aW9uKGl0LCAoKSA9PiAoMCwgYm9vbFNjaGVtYV8xLnRvcEJvb2xPckVtcHR5U2NoZW1hKShpdCkpO1xufVxuZXhwb3J0cy52YWxpZGF0ZUZ1bmN0aW9uQ29kZSA9IHZhbGlkYXRlRnVuY3Rpb25Db2RlO1xuZnVuY3Rpb24gdmFsaWRhdGVGdW5jdGlvbih7IGdlbiwgdmFsaWRhdGVOYW1lLCBzY2hlbWEsIHNjaGVtYUVudiwgb3B0cyB9LCBib2R5KSB7XG4gICAgaWYgKG9wdHMuY29kZS5lczUpIHtcbiAgICAgICAgZ2VuLmZ1bmModmFsaWRhdGVOYW1lLCAoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC5kYXRhfSwgJHtuYW1lc18xLmRlZmF1bHQudmFsQ3h0fWAsIHNjaGVtYUVudi4kYXN5bmMsICgpID0+IHtcbiAgICAgICAgICAgIGdlbi5jb2RlKCgwLCBjb2RlZ2VuXzEuXykgYFwidXNlIHN0cmljdFwiOyAke2Z1bmNTb3VyY2VVcmwoc2NoZW1hLCBvcHRzKX1gKTtcbiAgICAgICAgICAgIGRlc3RydWN0dXJlVmFsQ3h0RVM1KGdlbiwgb3B0cyk7XG4gICAgICAgICAgICBnZW4uY29kZShib2R5KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnZW4uZnVuYyh2YWxpZGF0ZU5hbWUsICgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LmRhdGF9LCAke2Rlc3RydWN0dXJlVmFsQ3h0KG9wdHMpfWAsIHNjaGVtYUVudi4kYXN5bmMsICgpID0+IGdlbi5jb2RlKGZ1bmNTb3VyY2VVcmwoc2NoZW1hLCBvcHRzKSkuY29kZShib2R5KSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZGVzdHJ1Y3R1cmVWYWxDeHQob3B0cykge1xuICAgIHJldHVybiAoMCwgY29kZWdlbl8xLl8pIGB7JHtuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRofT1cIlwiLCAke25hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhfSwgJHtuYW1lc18xLmRlZmF1bHQucGFyZW50RGF0YVByb3BlcnR5fSwgJHtuYW1lc18xLmRlZmF1bHQucm9vdERhdGF9PSR7bmFtZXNfMS5kZWZhdWx0LmRhdGF9JHtvcHRzLmR5bmFtaWNSZWYgPyAoMCwgY29kZWdlbl8xLl8pIGAsICR7bmFtZXNfMS5kZWZhdWx0LmR5bmFtaWNBbmNob3JzfT17fWAgOiBjb2RlZ2VuXzEubmlsfX09e31gO1xufVxuZnVuY3Rpb24gZGVzdHJ1Y3R1cmVWYWxDeHRFUzUoZ2VuLCBvcHRzKSB7XG4gICAgZ2VuLmlmKG5hbWVzXzEuZGVmYXVsdC52YWxDeHQsICgpID0+IHtcbiAgICAgICAgZ2VuLnZhcihuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRoLCAoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC52YWxDeHR9LiR7bmFtZXNfMS5kZWZhdWx0Lmluc3RhbmNlUGF0aH1gKTtcbiAgICAgICAgZ2VuLnZhcihuYW1lc18xLmRlZmF1bHQucGFyZW50RGF0YSwgKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQudmFsQ3h0fS4ke25hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhfWApO1xuICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhUHJvcGVydHksICgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LnZhbEN4dH0uJHtuYW1lc18xLmRlZmF1bHQucGFyZW50RGF0YVByb3BlcnR5fWApO1xuICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5yb290RGF0YSwgKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQudmFsQ3h0fS4ke25hbWVzXzEuZGVmYXVsdC5yb290RGF0YX1gKTtcbiAgICAgICAgaWYgKG9wdHMuZHluYW1pY1JlZilcbiAgICAgICAgICAgIGdlbi52YXIobmFtZXNfMS5kZWZhdWx0LmR5bmFtaWNBbmNob3JzLCAoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC52YWxDeHR9LiR7bmFtZXNfMS5kZWZhdWx0LmR5bmFtaWNBbmNob3JzfWApO1xuICAgIH0sICgpID0+IHtcbiAgICAgICAgZ2VuLnZhcihuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRoLCAoMCwgY29kZWdlbl8xLl8pIGBcIlwiYCk7XG4gICAgICAgIGdlbi52YXIobmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGEsICgwLCBjb2RlZ2VuXzEuXykgYHVuZGVmaW5lZGApO1xuICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhUHJvcGVydHksICgwLCBjb2RlZ2VuXzEuXykgYHVuZGVmaW5lZGApO1xuICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5yb290RGF0YSwgbmFtZXNfMS5kZWZhdWx0LmRhdGEpO1xuICAgICAgICBpZiAob3B0cy5keW5hbWljUmVmKVxuICAgICAgICAgICAgZ2VuLnZhcihuYW1lc18xLmRlZmF1bHQuZHluYW1pY0FuY2hvcnMsICgwLCBjb2RlZ2VuXzEuXykgYHt9YCk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiB0b3BTY2hlbWFPYmpDb2RlKGl0KSB7XG4gICAgY29uc3QgeyBzY2hlbWEsIG9wdHMsIGdlbiB9ID0gaXQ7XG4gICAgdmFsaWRhdGVGdW5jdGlvbihpdCwgKCkgPT4ge1xuICAgICAgICBpZiAob3B0cy4kY29tbWVudCAmJiBzY2hlbWEuJGNvbW1lbnQpXG4gICAgICAgICAgICBjb21tZW50S2V5d29yZChpdCk7XG4gICAgICAgIGNoZWNrTm9EZWZhdWx0KGl0KTtcbiAgICAgICAgZ2VuLmxldChuYW1lc18xLmRlZmF1bHQudkVycm9ycywgbnVsbCk7XG4gICAgICAgIGdlbi5sZXQobmFtZXNfMS5kZWZhdWx0LmVycm9ycywgMCk7XG4gICAgICAgIGlmIChvcHRzLnVuZXZhbHVhdGVkKVxuICAgICAgICAgICAgcmVzZXRFdmFsdWF0ZWQoaXQpO1xuICAgICAgICB0eXBlQW5kS2V5d29yZHMoaXQpO1xuICAgICAgICByZXR1cm5SZXN1bHRzKGl0KTtcbiAgICB9KTtcbiAgICByZXR1cm47XG59XG5mdW5jdGlvbiByZXNldEV2YWx1YXRlZChpdCkge1xuICAgIC8vIFRPRE8gbWF5YmUgc29tZSBob29rIHRvIGV4ZWN1dGUgaXQgaW4gdGhlIGVuZCB0byBjaGVjayB3aGV0aGVyIHByb3BzL2l0ZW1zIGFyZSBOYW1lLCBhcyBpbiBhc3NpZ25FdmFsdWF0ZWRcbiAgICBjb25zdCB7IGdlbiwgdmFsaWRhdGVOYW1lIH0gPSBpdDtcbiAgICBpdC5ldmFsdWF0ZWQgPSBnZW4uY29uc3QoXCJldmFsdWF0ZWRcIiwgKDAsIGNvZGVnZW5fMS5fKSBgJHt2YWxpZGF0ZU5hbWV9LmV2YWx1YXRlZGApO1xuICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke2l0LmV2YWx1YXRlZH0uZHluYW1pY1Byb3BzYCwgKCkgPT4gZ2VuLmFzc2lnbigoMCwgY29kZWdlbl8xLl8pIGAke2l0LmV2YWx1YXRlZH0ucHJvcHNgLCAoMCwgY29kZWdlbl8xLl8pIGB1bmRlZmluZWRgKSk7XG4gICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7aXQuZXZhbHVhdGVkfS5keW5hbWljSXRlbXNgLCAoKSA9PiBnZW4uYXNzaWduKCgwLCBjb2RlZ2VuXzEuXykgYCR7aXQuZXZhbHVhdGVkfS5pdGVtc2AsICgwLCBjb2RlZ2VuXzEuXykgYHVuZGVmaW5lZGApKTtcbn1cbmZ1bmN0aW9uIGZ1bmNTb3VyY2VVcmwoc2NoZW1hLCBvcHRzKSB7XG4gICAgY29uc3Qgc2NoSWQgPSB0eXBlb2Ygc2NoZW1hID09IFwib2JqZWN0XCIgJiYgc2NoZW1hW29wdHMuc2NoZW1hSWRdO1xuICAgIHJldHVybiBzY2hJZCAmJiAob3B0cy5jb2RlLnNvdXJjZSB8fCBvcHRzLmNvZGUucHJvY2VzcykgPyAoMCwgY29kZWdlbl8xLl8pIGAvKiMgc291cmNlVVJMPSR7c2NoSWR9ICovYCA6IGNvZGVnZW5fMS5uaWw7XG59XG4vLyBzY2hlbWEgY29tcGlsYXRpb24gLSB0aGlzIGZ1bmN0aW9uIGlzIHVzZWQgcmVjdXJzaXZlbHkgdG8gZ2VuZXJhdGUgY29kZSBmb3Igc3ViLXNjaGVtYXNcbmZ1bmN0aW9uIHN1YnNjaGVtYUNvZGUoaXQsIHZhbGlkKSB7XG4gICAgaWYgKGlzU2NoZW1hT2JqKGl0KSkge1xuICAgICAgICBjaGVja0tleXdvcmRzKGl0KTtcbiAgICAgICAgaWYgKHNjaGVtYUN4dEhhc1J1bGVzKGl0KSkge1xuICAgICAgICAgICAgc3ViU2NoZW1hT2JqQ29kZShpdCwgdmFsaWQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgICgwLCBib29sU2NoZW1hXzEuYm9vbE9yRW1wdHlTY2hlbWEpKGl0LCB2YWxpZCk7XG59XG5mdW5jdGlvbiBzY2hlbWFDeHRIYXNSdWxlcyh7IHNjaGVtYSwgc2VsZiB9KSB7XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpXG4gICAgICAgIHJldHVybiAhc2NoZW1hO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSlcbiAgICAgICAgaWYgKHNlbGYuUlVMRVMuYWxsW2tleV0pXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc1NjaGVtYU9iaihpdCkge1xuICAgIHJldHVybiB0eXBlb2YgaXQuc2NoZW1hICE9IFwiYm9vbGVhblwiO1xufVxuZnVuY3Rpb24gc3ViU2NoZW1hT2JqQ29kZShpdCwgdmFsaWQpIHtcbiAgICBjb25zdCB7IHNjaGVtYSwgZ2VuLCBvcHRzIH0gPSBpdDtcbiAgICBpZiAob3B0cy4kY29tbWVudCAmJiBzY2hlbWEuJGNvbW1lbnQpXG4gICAgICAgIGNvbW1lbnRLZXl3b3JkKGl0KTtcbiAgICB1cGRhdGVDb250ZXh0KGl0KTtcbiAgICBjaGVja0FzeW5jU2NoZW1hKGl0KTtcbiAgICBjb25zdCBlcnJzQ291bnQgPSBnZW4uY29uc3QoXCJfZXJyc1wiLCBuYW1lc18xLmRlZmF1bHQuZXJyb3JzKTtcbiAgICB0eXBlQW5kS2V5d29yZHMoaXQsIGVycnNDb3VudCk7XG4gICAgLy8gVE9ETyB2YXJcbiAgICBnZW4udmFyKHZhbGlkLCAoMCwgY29kZWdlbl8xLl8pIGAke2VycnNDb3VudH0gPT09ICR7bmFtZXNfMS5kZWZhdWx0LmVycm9yc31gKTtcbn1cbmZ1bmN0aW9uIGNoZWNrS2V5d29yZHMoaXQpIHtcbiAgICAoMCwgdXRpbF8xLmNoZWNrVW5rbm93blJ1bGVzKShpdCk7XG4gICAgY2hlY2tSZWZzQW5kS2V5d29yZHMoaXQpO1xufVxuZnVuY3Rpb24gdHlwZUFuZEtleXdvcmRzKGl0LCBlcnJzQ291bnQpIHtcbiAgICBpZiAoaXQub3B0cy5qdGQpXG4gICAgICAgIHJldHVybiBzY2hlbWFLZXl3b3JkcyhpdCwgW10sIGZhbHNlLCBlcnJzQ291bnQpO1xuICAgIGNvbnN0IHR5cGVzID0gKDAsIGRhdGFUeXBlXzEuZ2V0U2NoZW1hVHlwZXMpKGl0LnNjaGVtYSk7XG4gICAgY29uc3QgY2hlY2tlZFR5cGVzID0gKDAsIGRhdGFUeXBlXzEuY29lcmNlQW5kQ2hlY2tEYXRhVHlwZSkoaXQsIHR5cGVzKTtcbiAgICBzY2hlbWFLZXl3b3JkcyhpdCwgdHlwZXMsICFjaGVja2VkVHlwZXMsIGVycnNDb3VudCk7XG59XG5mdW5jdGlvbiBjaGVja1JlZnNBbmRLZXl3b3JkcyhpdCkge1xuICAgIGNvbnN0IHsgc2NoZW1hLCBlcnJTY2hlbWFQYXRoLCBvcHRzLCBzZWxmIH0gPSBpdDtcbiAgICBpZiAoc2NoZW1hLiRyZWYgJiYgb3B0cy5pZ25vcmVLZXl3b3Jkc1dpdGhSZWYgJiYgKDAsIHV0aWxfMS5zY2hlbWFIYXNSdWxlc0J1dFJlZikoc2NoZW1hLCBzZWxmLlJVTEVTKSkge1xuICAgICAgICBzZWxmLmxvZ2dlci53YXJuKGAkcmVmOiBrZXl3b3JkcyBpZ25vcmVkIGluIHNjaGVtYSBhdCBwYXRoIFwiJHtlcnJTY2hlbWFQYXRofVwiYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tOb0RlZmF1bHQoaXQpIHtcbiAgICBjb25zdCB7IHNjaGVtYSwgb3B0cyB9ID0gaXQ7XG4gICAgaWYgKHNjaGVtYS5kZWZhdWx0ICE9PSB1bmRlZmluZWQgJiYgb3B0cy51c2VEZWZhdWx0cyAmJiBvcHRzLnN0cmljdFNjaGVtYSkge1xuICAgICAgICAoMCwgdXRpbF8xLmNoZWNrU3RyaWN0TW9kZSkoaXQsIFwiZGVmYXVsdCBpcyBpZ25vcmVkIGluIHRoZSBzY2hlbWEgcm9vdFwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiB1cGRhdGVDb250ZXh0KGl0KSB7XG4gICAgY29uc3Qgc2NoSWQgPSBpdC5zY2hlbWFbaXQub3B0cy5zY2hlbWFJZF07XG4gICAgaWYgKHNjaElkKVxuICAgICAgICBpdC5iYXNlSWQgPSAoMCwgcmVzb2x2ZV8xLnJlc29sdmVVcmwpKGl0Lm9wdHMudXJpUmVzb2x2ZXIsIGl0LmJhc2VJZCwgc2NoSWQpO1xufVxuZnVuY3Rpb24gY2hlY2tBc3luY1NjaGVtYShpdCkge1xuICAgIGlmIChpdC5zY2hlbWEuJGFzeW5jICYmICFpdC5zY2hlbWFFbnYuJGFzeW5jKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhc3luYyBzY2hlbWEgaW4gc3luYyBzY2hlbWFcIik7XG59XG5mdW5jdGlvbiBjb21tZW50S2V5d29yZCh7IGdlbiwgc2NoZW1hRW52LCBzY2hlbWEsIGVyclNjaGVtYVBhdGgsIG9wdHMgfSkge1xuICAgIGNvbnN0IG1zZyA9IHNjaGVtYS4kY29tbWVudDtcbiAgICBpZiAob3B0cy4kY29tbWVudCA9PT0gdHJ1ZSkge1xuICAgICAgICBnZW4uY29kZSgoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC5zZWxmfS5sb2dnZXIubG9nKCR7bXNnfSlgKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIG9wdHMuJGNvbW1lbnQgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IHNjaGVtYVBhdGggPSAoMCwgY29kZWdlbl8xLnN0cikgYCR7ZXJyU2NoZW1hUGF0aH0vJGNvbW1lbnRgO1xuICAgICAgICBjb25zdCByb290TmFtZSA9IGdlbi5zY29wZVZhbHVlKFwicm9vdFwiLCB7IHJlZjogc2NoZW1hRW52LnJvb3QgfSk7XG4gICAgICAgIGdlbi5jb2RlKCgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LnNlbGZ9Lm9wdHMuJGNvbW1lbnQoJHttc2d9LCAke3NjaGVtYVBhdGh9LCAke3Jvb3ROYW1lfS5zY2hlbWEpYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmV0dXJuUmVzdWx0cyhpdCkge1xuICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWFFbnYsIHZhbGlkYXRlTmFtZSwgVmFsaWRhdGlvbkVycm9yLCBvcHRzIH0gPSBpdDtcbiAgICBpZiAoc2NoZW1hRW52LiRhc3luYykge1xuICAgICAgICAvLyBUT0RPIGFzc2lnbiB1bmV2YWx1YXRlZFxuICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQuZXJyb3JzfSA9PT0gMGAsICgpID0+IGdlbi5yZXR1cm4obmFtZXNfMS5kZWZhdWx0LmRhdGEpLCAoKSA9PiBnZW4udGhyb3coKDAsIGNvZGVnZW5fMS5fKSBgbmV3ICR7VmFsaWRhdGlvbkVycm9yfSgke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfSlgKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnZW4uYXNzaWduKCgwLCBjb2RlZ2VuXzEuXykgYCR7dmFsaWRhdGVOYW1lfS5lcnJvcnNgLCBuYW1lc18xLmRlZmF1bHQudkVycm9ycyk7XG4gICAgICAgIGlmIChvcHRzLnVuZXZhbHVhdGVkKVxuICAgICAgICAgICAgYXNzaWduRXZhbHVhdGVkKGl0KTtcbiAgICAgICAgZ2VuLnJldHVybigoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC5lcnJvcnN9ID09PSAwYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYXNzaWduRXZhbHVhdGVkKHsgZ2VuLCBldmFsdWF0ZWQsIHByb3BzLCBpdGVtcyB9KSB7XG4gICAgaWYgKHByb3BzIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUpXG4gICAgICAgIGdlbi5hc3NpZ24oKDAsIGNvZGVnZW5fMS5fKSBgJHtldmFsdWF0ZWR9LnByb3BzYCwgcHJvcHMpO1xuICAgIGlmIChpdGVtcyBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lKVxuICAgICAgICBnZW4uYXNzaWduKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZXZhbHVhdGVkfS5pdGVtc2AsIGl0ZW1zKTtcbn1cbmZ1bmN0aW9uIHNjaGVtYUtleXdvcmRzKGl0LCB0eXBlcywgdHlwZUVycm9ycywgZXJyc0NvdW50KSB7XG4gICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgZGF0YSwgYWxsRXJyb3JzLCBvcHRzLCBzZWxmIH0gPSBpdDtcbiAgICBjb25zdCB7IFJVTEVTIH0gPSBzZWxmO1xuICAgIGlmIChzY2hlbWEuJHJlZiAmJiAob3B0cy5pZ25vcmVLZXl3b3Jkc1dpdGhSZWYgfHwgISgwLCB1dGlsXzEuc2NoZW1hSGFzUnVsZXNCdXRSZWYpKHNjaGVtYSwgUlVMRVMpKSkge1xuICAgICAgICBnZW4uYmxvY2soKCkgPT4ga2V5d29yZENvZGUoaXQsIFwiJHJlZlwiLCBSVUxFUy5hbGwuJHJlZi5kZWZpbml0aW9uKSk7IC8vIFRPRE8gdHlwZWNhc3RcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIW9wdHMuanRkKVxuICAgICAgICBjaGVja1N0cmljdFR5cGVzKGl0LCB0eXBlcyk7XG4gICAgZ2VuLmJsb2NrKCgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBncm91cCBvZiBSVUxFUy5ydWxlcylcbiAgICAgICAgICAgIGdyb3VwS2V5d29yZHMoZ3JvdXApO1xuICAgICAgICBncm91cEtleXdvcmRzKFJVTEVTLnBvc3QpO1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGdyb3VwS2V5d29yZHMoZ3JvdXApIHtcbiAgICAgICAgaWYgKCEoMCwgYXBwbGljYWJpbGl0eV8xLnNob3VsZFVzZUdyb3VwKShzY2hlbWEsIGdyb3VwKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGdyb3VwLnR5cGUpIHtcbiAgICAgICAgICAgIGdlbi5pZigoMCwgZGF0YVR5cGVfMi5jaGVja0RhdGFUeXBlKShncm91cC50eXBlLCBkYXRhLCBvcHRzLnN0cmljdE51bWJlcnMpKTtcbiAgICAgICAgICAgIGl0ZXJhdGVLZXl3b3JkcyhpdCwgZ3JvdXApO1xuICAgICAgICAgICAgaWYgKHR5cGVzLmxlbmd0aCA9PT0gMSAmJiB0eXBlc1swXSA9PT0gZ3JvdXAudHlwZSAmJiB0eXBlRXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgZ2VuLmVsc2UoKTtcbiAgICAgICAgICAgICAgICAoMCwgZGF0YVR5cGVfMi5yZXBvcnRUeXBlRXJyb3IpKGl0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdlbi5lbmRJZigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaXRlcmF0ZUtleXdvcmRzKGl0LCBncm91cCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETyBtYWtlIGl0IFwib2tcIiBjYWxsP1xuICAgICAgICBpZiAoIWFsbEVycm9ycylcbiAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC5lcnJvcnN9ID09PSAke2VycnNDb3VudCB8fCAwfWApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGl0ZXJhdGVLZXl3b3JkcyhpdCwgZ3JvdXApIHtcbiAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBvcHRzOiB7IHVzZURlZmF1bHRzIH0sIH0gPSBpdDtcbiAgICBpZiAodXNlRGVmYXVsdHMpXG4gICAgICAgICgwLCBkZWZhdWx0c18xLmFzc2lnbkRlZmF1bHRzKShpdCwgZ3JvdXAudHlwZSk7XG4gICAgZ2VuLmJsb2NrKCgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBydWxlIG9mIGdyb3VwLnJ1bGVzKSB7XG4gICAgICAgICAgICBpZiAoKDAsIGFwcGxpY2FiaWxpdHlfMS5zaG91bGRVc2VSdWxlKShzY2hlbWEsIHJ1bGUpKSB7XG4gICAgICAgICAgICAgICAga2V5d29yZENvZGUoaXQsIHJ1bGUua2V5d29yZCwgcnVsZS5kZWZpbml0aW9uLCBncm91cC50eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gY2hlY2tTdHJpY3RUeXBlcyhpdCwgdHlwZXMpIHtcbiAgICBpZiAoaXQuc2NoZW1hRW52Lm1ldGEgfHwgIWl0Lm9wdHMuc3RyaWN0VHlwZXMpXG4gICAgICAgIHJldHVybjtcbiAgICBjaGVja0NvbnRleHRUeXBlcyhpdCwgdHlwZXMpO1xuICAgIGlmICghaXQub3B0cy5hbGxvd1VuaW9uVHlwZXMpXG4gICAgICAgIGNoZWNrTXVsdGlwbGVUeXBlcyhpdCwgdHlwZXMpO1xuICAgIGNoZWNrS2V5d29yZFR5cGVzKGl0LCBpdC5kYXRhVHlwZXMpO1xufVxuZnVuY3Rpb24gY2hlY2tDb250ZXh0VHlwZXMoaXQsIHR5cGVzKSB7XG4gICAgaWYgKCF0eXBlcy5sZW5ndGgpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoIWl0LmRhdGFUeXBlcy5sZW5ndGgpIHtcbiAgICAgICAgaXQuZGF0YVR5cGVzID0gdHlwZXM7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHlwZXMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgICBpZiAoIWluY2x1ZGVzVHlwZShpdC5kYXRhVHlwZXMsIHQpKSB7XG4gICAgICAgICAgICBzdHJpY3RUeXBlc0Vycm9yKGl0LCBgdHlwZSBcIiR7dH1cIiBub3QgYWxsb3dlZCBieSBjb250ZXh0IFwiJHtpdC5kYXRhVHlwZXMuam9pbihcIixcIil9XCJgKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIG5hcnJvd1NjaGVtYVR5cGVzKGl0LCB0eXBlcyk7XG59XG5mdW5jdGlvbiBjaGVja011bHRpcGxlVHlwZXMoaXQsIHRzKSB7XG4gICAgaWYgKHRzLmxlbmd0aCA+IDEgJiYgISh0cy5sZW5ndGggPT09IDIgJiYgdHMuaW5jbHVkZXMoXCJudWxsXCIpKSkge1xuICAgICAgICBzdHJpY3RUeXBlc0Vycm9yKGl0LCBcInVzZSBhbGxvd1VuaW9uVHlwZXMgdG8gYWxsb3cgdW5pb24gdHlwZSBrZXl3b3JkXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrS2V5d29yZFR5cGVzKGl0LCB0cykge1xuICAgIGNvbnN0IHJ1bGVzID0gaXQuc2VsZi5SVUxFUy5hbGw7XG4gICAgZm9yIChjb25zdCBrZXl3b3JkIGluIHJ1bGVzKSB7XG4gICAgICAgIGNvbnN0IHJ1bGUgPSBydWxlc1trZXl3b3JkXTtcbiAgICAgICAgaWYgKHR5cGVvZiBydWxlID09IFwib2JqZWN0XCIgJiYgKDAsIGFwcGxpY2FiaWxpdHlfMS5zaG91bGRVc2VSdWxlKShpdC5zY2hlbWEsIHJ1bGUpKSB7XG4gICAgICAgICAgICBjb25zdCB7IHR5cGUgfSA9IHJ1bGUuZGVmaW5pdGlvbjtcbiAgICAgICAgICAgIGlmICh0eXBlLmxlbmd0aCAmJiAhdHlwZS5zb21lKCh0KSA9PiBoYXNBcHBsaWNhYmxlVHlwZSh0cywgdCkpKSB7XG4gICAgICAgICAgICAgICAgc3RyaWN0VHlwZXNFcnJvcihpdCwgYG1pc3NpbmcgdHlwZSBcIiR7dHlwZS5qb2luKFwiLFwiKX1cIiBmb3Iga2V5d29yZCBcIiR7a2V5d29yZH1cImApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gaGFzQXBwbGljYWJsZVR5cGUoc2NoVHMsIGt3ZFQpIHtcbiAgICByZXR1cm4gc2NoVHMuaW5jbHVkZXMoa3dkVCkgfHwgKGt3ZFQgPT09IFwibnVtYmVyXCIgJiYgc2NoVHMuaW5jbHVkZXMoXCJpbnRlZ2VyXCIpKTtcbn1cbmZ1bmN0aW9uIGluY2x1ZGVzVHlwZSh0cywgdCkge1xuICAgIHJldHVybiB0cy5pbmNsdWRlcyh0KSB8fCAodCA9PT0gXCJpbnRlZ2VyXCIgJiYgdHMuaW5jbHVkZXMoXCJudW1iZXJcIikpO1xufVxuZnVuY3Rpb24gbmFycm93U2NoZW1hVHlwZXMoaXQsIHdpdGhUeXBlcykge1xuICAgIGNvbnN0IHRzID0gW107XG4gICAgZm9yIChjb25zdCB0IG9mIGl0LmRhdGFUeXBlcykge1xuICAgICAgICBpZiAoaW5jbHVkZXNUeXBlKHdpdGhUeXBlcywgdCkpXG4gICAgICAgICAgICB0cy5wdXNoKHQpO1xuICAgICAgICBlbHNlIGlmICh3aXRoVHlwZXMuaW5jbHVkZXMoXCJpbnRlZ2VyXCIpICYmIHQgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB0cy5wdXNoKFwiaW50ZWdlclwiKTtcbiAgICB9XG4gICAgaXQuZGF0YVR5cGVzID0gdHM7XG59XG5mdW5jdGlvbiBzdHJpY3RUeXBlc0Vycm9yKGl0LCBtc2cpIHtcbiAgICBjb25zdCBzY2hlbWFQYXRoID0gaXQuc2NoZW1hRW52LmJhc2VJZCArIGl0LmVyclNjaGVtYVBhdGg7XG4gICAgbXNnICs9IGAgYXQgXCIke3NjaGVtYVBhdGh9XCIgKHN0cmljdFR5cGVzKWA7XG4gICAgKDAsIHV0aWxfMS5jaGVja1N0cmljdE1vZGUpKGl0LCBtc2csIGl0Lm9wdHMuc3RyaWN0VHlwZXMpO1xufVxuY2xhc3MgS2V5d29yZEN4dCB7XG4gICAgY29uc3RydWN0b3IoaXQsIGRlZiwga2V5d29yZCkge1xuICAgICAgICAoMCwga2V5d29yZF8xLnZhbGlkYXRlS2V5d29yZFVzYWdlKShpdCwgZGVmLCBrZXl3b3JkKTtcbiAgICAgICAgdGhpcy5nZW4gPSBpdC5nZW47XG4gICAgICAgIHRoaXMuYWxsRXJyb3JzID0gaXQuYWxsRXJyb3JzO1xuICAgICAgICB0aGlzLmtleXdvcmQgPSBrZXl3b3JkO1xuICAgICAgICB0aGlzLmRhdGEgPSBpdC5kYXRhO1xuICAgICAgICB0aGlzLnNjaGVtYSA9IGl0LnNjaGVtYVtrZXl3b3JkXTtcbiAgICAgICAgdGhpcy4kZGF0YSA9IGRlZi4kZGF0YSAmJiBpdC5vcHRzLiRkYXRhICYmIHRoaXMuc2NoZW1hICYmIHRoaXMuc2NoZW1hLiRkYXRhO1xuICAgICAgICB0aGlzLnNjaGVtYVZhbHVlID0gKDAsIHV0aWxfMS5zY2hlbWFSZWZPclZhbCkoaXQsIHRoaXMuc2NoZW1hLCBrZXl3b3JkLCB0aGlzLiRkYXRhKTtcbiAgICAgICAgdGhpcy5zY2hlbWFUeXBlID0gZGVmLnNjaGVtYVR5cGU7XG4gICAgICAgIHRoaXMucGFyZW50U2NoZW1hID0gaXQuc2NoZW1hO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IHt9O1xuICAgICAgICB0aGlzLml0ID0gaXQ7XG4gICAgICAgIHRoaXMuZGVmID0gZGVmO1xuICAgICAgICBpZiAodGhpcy4kZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5zY2hlbWFDb2RlID0gaXQuZ2VuLmNvbnN0KFwidlNjaGVtYVwiLCBnZXREYXRhKHRoaXMuJGRhdGEsIGl0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNjaGVtYUNvZGUgPSB0aGlzLnNjaGVtYVZhbHVlO1xuICAgICAgICAgICAgaWYgKCEoMCwga2V5d29yZF8xLnZhbGlkU2NoZW1hVHlwZSkodGhpcy5zY2hlbWEsIGRlZi5zY2hlbWFUeXBlLCBkZWYuYWxsb3dVbmRlZmluZWQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2tleXdvcmR9IHZhbHVlIG11c3QgYmUgJHtKU09OLnN0cmluZ2lmeShkZWYuc2NoZW1hVHlwZSl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwiY29kZVwiIGluIGRlZiA/IGRlZi50cmFja0Vycm9ycyA6IGRlZi5lcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLmVycnNDb3VudCA9IGl0Lmdlbi5jb25zdChcIl9lcnJzXCIsIG5hbWVzXzEuZGVmYXVsdC5lcnJvcnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlc3VsdChjb25kaXRpb24sIHN1Y2Nlc3NBY3Rpb24sIGZhaWxBY3Rpb24pIHtcbiAgICAgICAgdGhpcy5mYWlsUmVzdWx0KCgwLCBjb2RlZ2VuXzEubm90KShjb25kaXRpb24pLCBzdWNjZXNzQWN0aW9uLCBmYWlsQWN0aW9uKTtcbiAgICB9XG4gICAgZmFpbFJlc3VsdChjb25kaXRpb24sIHN1Y2Nlc3NBY3Rpb24sIGZhaWxBY3Rpb24pIHtcbiAgICAgICAgdGhpcy5nZW4uaWYoY29uZGl0aW9uKTtcbiAgICAgICAgaWYgKGZhaWxBY3Rpb24pXG4gICAgICAgICAgICBmYWlsQWN0aW9uKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoKTtcbiAgICAgICAgaWYgKHN1Y2Nlc3NBY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZ2VuLmVsc2UoKTtcbiAgICAgICAgICAgIHN1Y2Nlc3NBY3Rpb24oKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmFsbEVycm9ycylcbiAgICAgICAgICAgICAgICB0aGlzLmdlbi5lbmRJZigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgIHRoaXMuZ2VuLmVuZElmKCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5nZW4uZWxzZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBhc3MoY29uZGl0aW9uLCBmYWlsQWN0aW9uKSB7XG4gICAgICAgIHRoaXMuZmFpbFJlc3VsdCgoMCwgY29kZWdlbl8xLm5vdCkoY29uZGl0aW9uKSwgdW5kZWZpbmVkLCBmYWlsQWN0aW9uKTtcbiAgICB9XG4gICAgZmFpbChjb25kaXRpb24pIHtcbiAgICAgICAgaWYgKGNvbmRpdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgIHRoaXMuZ2VuLmlmKGZhbHNlKTsgLy8gdGhpcyBicmFuY2ggd2lsbCBiZSByZW1vdmVkIGJ5IGdlbi5vcHRpbWl6ZVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ2VuLmlmKGNvbmRpdGlvbik7XG4gICAgICAgIHRoaXMuZXJyb3IoKTtcbiAgICAgICAgaWYgKHRoaXMuYWxsRXJyb3JzKVxuICAgICAgICAgICAgdGhpcy5nZW4uZW5kSWYoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5nZW4uZWxzZSgpO1xuICAgIH1cbiAgICBmYWlsJGRhdGEoY29uZGl0aW9uKSB7XG4gICAgICAgIGlmICghdGhpcy4kZGF0YSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZhaWwoY29uZGl0aW9uKTtcbiAgICAgICAgY29uc3QgeyBzY2hlbWFDb2RlIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLmZhaWwoKDAsIGNvZGVnZW5fMS5fKSBgJHtzY2hlbWFDb2RlfSAhPT0gdW5kZWZpbmVkICYmICgkeygwLCBjb2RlZ2VuXzEub3IpKHRoaXMuaW52YWxpZCRkYXRhKCksIGNvbmRpdGlvbil9KWApO1xuICAgIH1cbiAgICBlcnJvcihhcHBlbmQsIGVycm9yUGFyYW1zLCBlcnJvclBhdGhzKSB7XG4gICAgICAgIGlmIChlcnJvclBhcmFtcykge1xuICAgICAgICAgICAgdGhpcy5zZXRQYXJhbXMoZXJyb3JQYXJhbXMpO1xuICAgICAgICAgICAgdGhpcy5fZXJyb3IoYXBwZW5kLCBlcnJvclBhdGhzKTtcbiAgICAgICAgICAgIHRoaXMuc2V0UGFyYW1zKHt9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9lcnJvcihhcHBlbmQsIGVycm9yUGF0aHMpO1xuICAgIH1cbiAgICBfZXJyb3IoYXBwZW5kLCBlcnJvclBhdGhzKSB7XG4gICAgICAgIDtcbiAgICAgICAgKGFwcGVuZCA/IGVycm9yc18xLnJlcG9ydEV4dHJhRXJyb3IgOiBlcnJvcnNfMS5yZXBvcnRFcnJvcikodGhpcywgdGhpcy5kZWYuZXJyb3IsIGVycm9yUGF0aHMpO1xuICAgIH1cbiAgICAkZGF0YUVycm9yKCkge1xuICAgICAgICAoMCwgZXJyb3JzXzEucmVwb3J0RXJyb3IpKHRoaXMsIHRoaXMuZGVmLiRkYXRhRXJyb3IgfHwgZXJyb3JzXzEua2V5d29yZCREYXRhRXJyb3IpO1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZXJyc0NvdW50ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FkZCBcInRyYWNrRXJyb3JzXCIgdG8ga2V5d29yZCBkZWZpbml0aW9uJyk7XG4gICAgICAgICgwLCBlcnJvcnNfMS5yZXNldEVycm9yc0NvdW50KSh0aGlzLmdlbiwgdGhpcy5lcnJzQ291bnQpO1xuICAgIH1cbiAgICBvayhjb25kKSB7XG4gICAgICAgIGlmICghdGhpcy5hbGxFcnJvcnMpXG4gICAgICAgICAgICB0aGlzLmdlbi5pZihjb25kKTtcbiAgICB9XG4gICAgc2V0UGFyYW1zKG9iaiwgYXNzaWduKSB7XG4gICAgICAgIGlmIChhc3NpZ24pXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMucGFyYW1zLCBvYmopO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnBhcmFtcyA9IG9iajtcbiAgICB9XG4gICAgYmxvY2skZGF0YSh2YWxpZCwgY29kZUJsb2NrLCAkZGF0YVZhbGlkID0gY29kZWdlbl8xLm5pbCkge1xuICAgICAgICB0aGlzLmdlbi5ibG9jaygoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrJGRhdGEodmFsaWQsICRkYXRhVmFsaWQpO1xuICAgICAgICAgICAgY29kZUJsb2NrKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjaGVjayRkYXRhKHZhbGlkID0gY29kZWdlbl8xLm5pbCwgJGRhdGFWYWxpZCA9IGNvZGVnZW5fMS5uaWwpIHtcbiAgICAgICAgaWYgKCF0aGlzLiRkYXRhKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB7IGdlbiwgc2NoZW1hQ29kZSwgc2NoZW1hVHlwZSwgZGVmIH0gPSB0aGlzO1xuICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5vcikoKDAsIGNvZGVnZW5fMS5fKSBgJHtzY2hlbWFDb2RlfSA9PT0gdW5kZWZpbmVkYCwgJGRhdGFWYWxpZCkpO1xuICAgICAgICBpZiAodmFsaWQgIT09IGNvZGVnZW5fMS5uaWwpXG4gICAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCB0cnVlKTtcbiAgICAgICAgaWYgKHNjaGVtYVR5cGUubGVuZ3RoIHx8IGRlZi52YWxpZGF0ZVNjaGVtYSkge1xuICAgICAgICAgICAgZ2VuLmVsc2VJZih0aGlzLmludmFsaWQkZGF0YSgpKTtcbiAgICAgICAgICAgIHRoaXMuJGRhdGFFcnJvcigpO1xuICAgICAgICAgICAgaWYgKHZhbGlkICE9PSBjb2RlZ2VuXzEubmlsKVxuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBnZW4uZWxzZSgpO1xuICAgIH1cbiAgICBpbnZhbGlkJGRhdGEoKSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWFDb2RlLCBzY2hlbWFUeXBlLCBkZWYsIGl0IH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gKDAsIGNvZGVnZW5fMS5vcikod3JvbmckRGF0YVR5cGUoKSwgaW52YWxpZCREYXRhU2NoZW1hKCkpO1xuICAgICAgICBmdW5jdGlvbiB3cm9uZyREYXRhVHlwZSgpIHtcbiAgICAgICAgICAgIGlmIChzY2hlbWFUeXBlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgIGlmICghKHNjaGVtYUNvZGUgaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFqdiBpbXBsZW1lbnRhdGlvbiBlcnJvclwiKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdCA9IEFycmF5LmlzQXJyYXkoc2NoZW1hVHlwZSkgPyBzY2hlbWFUeXBlIDogW3NjaGVtYVR5cGVdO1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLl8pIGAkeygwLCBkYXRhVHlwZV8yLmNoZWNrRGF0YVR5cGVzKShzdCwgc2NoZW1hQ29kZSwgaXQub3B0cy5zdHJpY3ROdW1iZXJzLCBkYXRhVHlwZV8yLkRhdGFUeXBlLldyb25nKX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvZGVnZW5fMS5uaWw7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaW52YWxpZCREYXRhU2NoZW1hKCkge1xuICAgICAgICAgICAgaWYgKGRlZi52YWxpZGF0ZVNjaGVtYSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkYXRlU2NoZW1hUmVmID0gZ2VuLnNjb3BlVmFsdWUoXCJ2YWxpZGF0ZSRkYXRhXCIsIHsgcmVmOiBkZWYudmFsaWRhdGVTY2hlbWEgfSk7IC8vIFRPRE8gdmFsdWUuY29kZSBmb3Igc3RhbmRhbG9uZVxuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLl8pIGAhJHt2YWxpZGF0ZVNjaGVtYVJlZn0oJHtzY2hlbWFDb2RlfSlgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvZGVnZW5fMS5uaWw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3Vic2NoZW1hKGFwcGwsIHZhbGlkKSB7XG4gICAgICAgIGNvbnN0IHN1YnNjaGVtYSA9ICgwLCBzdWJzY2hlbWFfMS5nZXRTdWJzY2hlbWEpKHRoaXMuaXQsIGFwcGwpO1xuICAgICAgICAoMCwgc3Vic2NoZW1hXzEuZXh0ZW5kU3Vic2NoZW1hRGF0YSkoc3Vic2NoZW1hLCB0aGlzLml0LCBhcHBsKTtcbiAgICAgICAgKDAsIHN1YnNjaGVtYV8xLmV4dGVuZFN1YnNjaGVtYU1vZGUpKHN1YnNjaGVtYSwgYXBwbCk7XG4gICAgICAgIGNvbnN0IG5leHRDb250ZXh0ID0geyAuLi50aGlzLml0LCAuLi5zdWJzY2hlbWEsIGl0ZW1zOiB1bmRlZmluZWQsIHByb3BzOiB1bmRlZmluZWQgfTtcbiAgICAgICAgc3Vic2NoZW1hQ29kZShuZXh0Q29udGV4dCwgdmFsaWQpO1xuICAgICAgICByZXR1cm4gbmV4dENvbnRleHQ7XG4gICAgfVxuICAgIG1lcmdlRXZhbHVhdGVkKHNjaGVtYUN4dCwgdG9OYW1lKSB7XG4gICAgICAgIGNvbnN0IHsgaXQsIGdlbiB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFpdC5vcHRzLnVuZXZhbHVhdGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoaXQucHJvcHMgIT09IHRydWUgJiYgc2NoZW1hQ3h0LnByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGl0LnByb3BzID0gdXRpbF8xLm1lcmdlRXZhbHVhdGVkLnByb3BzKGdlbiwgc2NoZW1hQ3h0LnByb3BzLCBpdC5wcm9wcywgdG9OYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXQuaXRlbXMgIT09IHRydWUgJiYgc2NoZW1hQ3h0Lml0ZW1zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGl0Lml0ZW1zID0gdXRpbF8xLm1lcmdlRXZhbHVhdGVkLml0ZW1zKGdlbiwgc2NoZW1hQ3h0Lml0ZW1zLCBpdC5pdGVtcywgdG9OYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtZXJnZVZhbGlkRXZhbHVhdGVkKHNjaGVtYUN4dCwgdmFsaWQpIHtcbiAgICAgICAgY29uc3QgeyBpdCwgZ2VuIH0gPSB0aGlzO1xuICAgICAgICBpZiAoaXQub3B0cy51bmV2YWx1YXRlZCAmJiAoaXQucHJvcHMgIT09IHRydWUgfHwgaXQuaXRlbXMgIT09IHRydWUpKSB7XG4gICAgICAgICAgICBnZW4uaWYodmFsaWQsICgpID0+IHRoaXMubWVyZ2VFdmFsdWF0ZWQoc2NoZW1hQ3h0LCBjb2RlZ2VuXzEuTmFtZSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLktleXdvcmRDeHQgPSBLZXl3b3JkQ3h0O1xuZnVuY3Rpb24ga2V5d29yZENvZGUoaXQsIGtleXdvcmQsIGRlZiwgcnVsZVR5cGUpIHtcbiAgICBjb25zdCBjeHQgPSBuZXcgS2V5d29yZEN4dChpdCwgZGVmLCBrZXl3b3JkKTtcbiAgICBpZiAoXCJjb2RlXCIgaW4gZGVmKSB7XG4gICAgICAgIGRlZi5jb2RlKGN4dCwgcnVsZVR5cGUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjeHQuJGRhdGEgJiYgZGVmLnZhbGlkYXRlKSB7XG4gICAgICAgICgwLCBrZXl3b3JkXzEuZnVuY0tleXdvcmRDb2RlKShjeHQsIGRlZik7XG4gICAgfVxuICAgIGVsc2UgaWYgKFwibWFjcm9cIiBpbiBkZWYpIHtcbiAgICAgICAgKDAsIGtleXdvcmRfMS5tYWNyb0tleXdvcmRDb2RlKShjeHQsIGRlZik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRlZi5jb21waWxlIHx8IGRlZi52YWxpZGF0ZSkge1xuICAgICAgICAoMCwga2V5d29yZF8xLmZ1bmNLZXl3b3JkQ29kZSkoY3h0LCBkZWYpO1xuICAgIH1cbn1cbmNvbnN0IEpTT05fUE9JTlRFUiA9IC9eXFwvKD86W15+XXx+MHx+MSkqJC87XG5jb25zdCBSRUxBVElWRV9KU09OX1BPSU5URVIgPSAvXihbMC05XSspKCN8XFwvKD86W15+XXx+MHx+MSkqKT8kLztcbmZ1bmN0aW9uIGdldERhdGEoJGRhdGEsIHsgZGF0YUxldmVsLCBkYXRhTmFtZXMsIGRhdGFQYXRoQXJyIH0pIHtcbiAgICBsZXQganNvblBvaW50ZXI7XG4gICAgbGV0IGRhdGE7XG4gICAgaWYgKCRkYXRhID09PSBcIlwiKVxuICAgICAgICByZXR1cm4gbmFtZXNfMS5kZWZhdWx0LnJvb3REYXRhO1xuICAgIGlmICgkZGF0YVswXSA9PT0gXCIvXCIpIHtcbiAgICAgICAgaWYgKCFKU09OX1BPSU5URVIudGVzdCgkZGF0YSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgSlNPTi1wb2ludGVyOiAkeyRkYXRhfWApO1xuICAgICAgICBqc29uUG9pbnRlciA9ICRkYXRhO1xuICAgICAgICBkYXRhID0gbmFtZXNfMS5kZWZhdWx0LnJvb3REYXRhO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IFJFTEFUSVZFX0pTT05fUE9JTlRFUi5leGVjKCRkYXRhKTtcbiAgICAgICAgaWYgKCFtYXRjaGVzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIEpTT04tcG9pbnRlcjogJHskZGF0YX1gKTtcbiAgICAgICAgY29uc3QgdXAgPSArbWF0Y2hlc1sxXTtcbiAgICAgICAganNvblBvaW50ZXIgPSBtYXRjaGVzWzJdO1xuICAgICAgICBpZiAoanNvblBvaW50ZXIgPT09IFwiI1wiKSB7XG4gICAgICAgICAgICBpZiAodXAgPj0gZGF0YUxldmVsKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1zZyhcInByb3BlcnR5L2luZGV4XCIsIHVwKSk7XG4gICAgICAgICAgICByZXR1cm4gZGF0YVBhdGhBcnJbZGF0YUxldmVsIC0gdXBdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cCA+IGRhdGFMZXZlbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1zZyhcImRhdGFcIiwgdXApKTtcbiAgICAgICAgZGF0YSA9IGRhdGFOYW1lc1tkYXRhTGV2ZWwgLSB1cF07XG4gICAgICAgIGlmICghanNvblBvaW50ZXIpXG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgbGV0IGV4cHIgPSBkYXRhO1xuICAgIGNvbnN0IHNlZ21lbnRzID0ganNvblBvaW50ZXIuc3BsaXQoXCIvXCIpO1xuICAgIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xuICAgICAgICBpZiAoc2VnbWVudCkge1xuICAgICAgICAgICAgZGF0YSA9ICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0keygwLCBjb2RlZ2VuXzEuZ2V0UHJvcGVydHkpKCgwLCB1dGlsXzEudW5lc2NhcGVKc29uUG9pbnRlcikoc2VnbWVudCkpfWA7XG4gICAgICAgICAgICBleHByID0gKDAsIGNvZGVnZW5fMS5fKSBgJHtleHByfSAmJiAke2RhdGF9YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXhwcjtcbiAgICBmdW5jdGlvbiBlcnJvck1zZyhwb2ludGVyVHlwZSwgdXApIHtcbiAgICAgICAgcmV0dXJuIGBDYW5ub3QgYWNjZXNzICR7cG9pbnRlclR5cGV9ICR7dXB9IGxldmVscyB1cCwgY3VycmVudCBsZXZlbCBpcyAke2RhdGFMZXZlbH1gO1xuICAgIH1cbn1cbmV4cG9ydHMuZ2V0RGF0YSA9IGdldERhdGE7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIFZhbGlkYXRpb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihlcnJvcnMpIHtcbiAgICAgICAgc3VwZXIoXCJ2YWxpZGF0aW9uIGZhaWxlZFwiKTtcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgIHRoaXMuYWp2ID0gdGhpcy52YWxpZGF0aW9uID0gdHJ1ZTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBWYWxpZGF0aW9uRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12YWxpZGF0aW9uX2Vycm9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgcmVzb2x2ZV8xID0gcmVxdWlyZShcIi4vcmVzb2x2ZVwiKTtcbmNsYXNzIE1pc3NpbmdSZWZFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihyZXNvbHZlciwgYmFzZUlkLCByZWYsIG1zZykge1xuICAgICAgICBzdXBlcihtc2cgfHwgYGNhbid0IHJlc29sdmUgcmVmZXJlbmNlICR7cmVmfSBmcm9tIGlkICR7YmFzZUlkfWApO1xuICAgICAgICB0aGlzLm1pc3NpbmdSZWYgPSAoMCwgcmVzb2x2ZV8xLnJlc29sdmVVcmwpKHJlc29sdmVyLCBiYXNlSWQsIHJlZik7XG4gICAgICAgIHRoaXMubWlzc2luZ1NjaGVtYSA9ICgwLCByZXNvbHZlXzEubm9ybWFsaXplSWQpKCgwLCByZXNvbHZlXzEuZ2V0RnVsbFBhdGgpKHJlc29sdmVyLCB0aGlzLm1pc3NpbmdSZWYpKTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBNaXNzaW5nUmVmRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWZfZXJyb3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJlc29sdmVTY2hlbWEgPSBleHBvcnRzLmdldENvbXBpbGluZ1NjaGVtYSA9IGV4cG9ydHMucmVzb2x2ZVJlZiA9IGV4cG9ydHMuY29tcGlsZVNjaGVtYSA9IGV4cG9ydHMuU2NoZW1hRW52ID0gdm9pZCAwO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4vY29kZWdlblwiKTtcbmNvbnN0IHZhbGlkYXRpb25fZXJyb3JfMSA9IHJlcXVpcmUoXCIuLi9ydW50aW1lL3ZhbGlkYXRpb25fZXJyb3JcIik7XG5jb25zdCBuYW1lc18xID0gcmVxdWlyZShcIi4vbmFtZXNcIik7XG5jb25zdCByZXNvbHZlXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZlXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbmNvbnN0IHZhbGlkYXRlXzEgPSByZXF1aXJlKFwiLi92YWxpZGF0ZVwiKTtcbmNsYXNzIFNjaGVtYUVudiB7XG4gICAgY29uc3RydWN0b3IoZW52KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5yZWZzID0ge307XG4gICAgICAgIHRoaXMuZHluYW1pY0FuY2hvcnMgPSB7fTtcbiAgICAgICAgbGV0IHNjaGVtYTtcbiAgICAgICAgaWYgKHR5cGVvZiBlbnYuc2NoZW1hID09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICBzY2hlbWEgPSBlbnYuc2NoZW1hO1xuICAgICAgICB0aGlzLnNjaGVtYSA9IGVudi5zY2hlbWE7XG4gICAgICAgIHRoaXMuc2NoZW1hSWQgPSBlbnYuc2NoZW1hSWQ7XG4gICAgICAgIHRoaXMucm9vdCA9IGVudi5yb290IHx8IHRoaXM7XG4gICAgICAgIHRoaXMuYmFzZUlkID0gKF9hID0gZW52LmJhc2VJZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKDAsIHJlc29sdmVfMS5ub3JtYWxpemVJZCkoc2NoZW1hID09PSBudWxsIHx8IHNjaGVtYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2NoZW1hW2Vudi5zY2hlbWFJZCB8fCBcIiRpZFwiXSk7XG4gICAgICAgIHRoaXMuc2NoZW1hUGF0aCA9IGVudi5zY2hlbWFQYXRoO1xuICAgICAgICB0aGlzLmxvY2FsUmVmcyA9IGVudi5sb2NhbFJlZnM7XG4gICAgICAgIHRoaXMubWV0YSA9IGVudi5tZXRhO1xuICAgICAgICB0aGlzLiRhc3luYyA9IHNjaGVtYSA9PT0gbnVsbCB8fCBzY2hlbWEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNjaGVtYS4kYXN5bmM7XG4gICAgICAgIHRoaXMucmVmcyA9IHt9O1xuICAgIH1cbn1cbmV4cG9ydHMuU2NoZW1hRW52ID0gU2NoZW1hRW52O1xuLy8gbGV0IGNvZGVTaXplID0gMFxuLy8gbGV0IG5vZGVDb3VudCA9IDBcbi8vIENvbXBpbGVzIHNjaGVtYSBpbiBTY2hlbWFFbnZcbmZ1bmN0aW9uIGNvbXBpbGVTY2hlbWEoc2NoKSB7XG4gICAgLy8gVE9ETyByZWZhY3RvciAtIHJlbW92ZSBjb21waWxhdGlvbnNcbiAgICBjb25zdCBfc2NoID0gZ2V0Q29tcGlsaW5nU2NoZW1hLmNhbGwodGhpcywgc2NoKTtcbiAgICBpZiAoX3NjaClcbiAgICAgICAgcmV0dXJuIF9zY2g7XG4gICAgY29uc3Qgcm9vdElkID0gKDAsIHJlc29sdmVfMS5nZXRGdWxsUGF0aCkodGhpcy5vcHRzLnVyaVJlc29sdmVyLCBzY2gucm9vdC5iYXNlSWQpOyAvLyBUT0RPIGlmIGdldEZ1bGxQYXRoIHJlbW92ZWQgMSB0ZXN0cyBmYWlsc1xuICAgIGNvbnN0IHsgZXM1LCBsaW5lcyB9ID0gdGhpcy5vcHRzLmNvZGU7XG4gICAgY29uc3QgeyBvd25Qcm9wZXJ0aWVzIH0gPSB0aGlzLm9wdHM7XG4gICAgY29uc3QgZ2VuID0gbmV3IGNvZGVnZW5fMS5Db2RlR2VuKHRoaXMuc2NvcGUsIHsgZXM1LCBsaW5lcywgb3duUHJvcGVydGllcyB9KTtcbiAgICBsZXQgX1ZhbGlkYXRpb25FcnJvcjtcbiAgICBpZiAoc2NoLiRhc3luYykge1xuICAgICAgICBfVmFsaWRhdGlvbkVycm9yID0gZ2VuLnNjb3BlVmFsdWUoXCJFcnJvclwiLCB7XG4gICAgICAgICAgICByZWY6IHZhbGlkYXRpb25fZXJyb3JfMS5kZWZhdWx0LFxuICAgICAgICAgICAgY29kZTogKDAsIGNvZGVnZW5fMS5fKSBgcmVxdWlyZShcImFqdi9kaXN0L3J1bnRpbWUvdmFsaWRhdGlvbl9lcnJvclwiKS5kZWZhdWx0YCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHZhbGlkYXRlTmFtZSA9IGdlbi5zY29wZU5hbWUoXCJ2YWxpZGF0ZVwiKTtcbiAgICBzY2gudmFsaWRhdGVOYW1lID0gdmFsaWRhdGVOYW1lO1xuICAgIGNvbnN0IHNjaGVtYUN4dCA9IHtcbiAgICAgICAgZ2VuLFxuICAgICAgICBhbGxFcnJvcnM6IHRoaXMub3B0cy5hbGxFcnJvcnMsXG4gICAgICAgIGRhdGE6IG5hbWVzXzEuZGVmYXVsdC5kYXRhLFxuICAgICAgICBwYXJlbnREYXRhOiBuYW1lc18xLmRlZmF1bHQucGFyZW50RGF0YSxcbiAgICAgICAgcGFyZW50RGF0YVByb3BlcnR5OiBuYW1lc18xLmRlZmF1bHQucGFyZW50RGF0YVByb3BlcnR5LFxuICAgICAgICBkYXRhTmFtZXM6IFtuYW1lc18xLmRlZmF1bHQuZGF0YV0sXG4gICAgICAgIGRhdGFQYXRoQXJyOiBbY29kZWdlbl8xLm5pbF0sIC8vIFRPRE8gY2FuIGl0cyBsZW5ndGggYmUgdXNlZCBhcyBkYXRhTGV2ZWwgaWYgbmlsIGlzIHJlbW92ZWQ/XG4gICAgICAgIGRhdGFMZXZlbDogMCxcbiAgICAgICAgZGF0YVR5cGVzOiBbXSxcbiAgICAgICAgZGVmaW5lZFByb3BlcnRpZXM6IG5ldyBTZXQoKSxcbiAgICAgICAgdG9wU2NoZW1hUmVmOiBnZW4uc2NvcGVWYWx1ZShcInNjaGVtYVwiLCB0aGlzLm9wdHMuY29kZS5zb3VyY2UgPT09IHRydWVcbiAgICAgICAgICAgID8geyByZWY6IHNjaC5zY2hlbWEsIGNvZGU6ICgwLCBjb2RlZ2VuXzEuc3RyaW5naWZ5KShzY2guc2NoZW1hKSB9XG4gICAgICAgICAgICA6IHsgcmVmOiBzY2guc2NoZW1hIH0pLFxuICAgICAgICB2YWxpZGF0ZU5hbWUsXG4gICAgICAgIFZhbGlkYXRpb25FcnJvcjogX1ZhbGlkYXRpb25FcnJvcixcbiAgICAgICAgc2NoZW1hOiBzY2guc2NoZW1hLFxuICAgICAgICBzY2hlbWFFbnY6IHNjaCxcbiAgICAgICAgcm9vdElkLFxuICAgICAgICBiYXNlSWQ6IHNjaC5iYXNlSWQgfHwgcm9vdElkLFxuICAgICAgICBzY2hlbWFQYXRoOiBjb2RlZ2VuXzEubmlsLFxuICAgICAgICBlcnJTY2hlbWFQYXRoOiBzY2guc2NoZW1hUGF0aCB8fCAodGhpcy5vcHRzLmp0ZCA/IFwiXCIgOiBcIiNcIiksXG4gICAgICAgIGVycm9yUGF0aDogKDAsIGNvZGVnZW5fMS5fKSBgXCJcImAsXG4gICAgICAgIG9wdHM6IHRoaXMub3B0cyxcbiAgICAgICAgc2VsZjogdGhpcyxcbiAgICB9O1xuICAgIGxldCBzb3VyY2VDb2RlO1xuICAgIHRyeSB7XG4gICAgICAgIHRoaXMuX2NvbXBpbGF0aW9ucy5hZGQoc2NoKTtcbiAgICAgICAgKDAsIHZhbGlkYXRlXzEudmFsaWRhdGVGdW5jdGlvbkNvZGUpKHNjaGVtYUN4dCk7XG4gICAgICAgIGdlbi5vcHRpbWl6ZSh0aGlzLm9wdHMuY29kZS5vcHRpbWl6ZSk7XG4gICAgICAgIC8vIGdlbi5vcHRpbWl6ZSgxKVxuICAgICAgICBjb25zdCB2YWxpZGF0ZUNvZGUgPSBnZW4udG9TdHJpbmcoKTtcbiAgICAgICAgc291cmNlQ29kZSA9IGAke2dlbi5zY29wZVJlZnMobmFtZXNfMS5kZWZhdWx0LnNjb3BlKX1yZXR1cm4gJHt2YWxpZGF0ZUNvZGV9YDtcbiAgICAgICAgLy8gY29uc29sZS5sb2coKGNvZGVTaXplICs9IHNvdXJjZUNvZGUubGVuZ3RoKSwgKG5vZGVDb3VudCArPSBnZW4ubm9kZUNvdW50KSlcbiAgICAgICAgaWYgKHRoaXMub3B0cy5jb2RlLnByb2Nlc3MpXG4gICAgICAgICAgICBzb3VyY2VDb2RlID0gdGhpcy5vcHRzLmNvZGUucHJvY2Vzcyhzb3VyY2VDb2RlLCBzY2gpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIlxcblxcblxcbiAqKiogXFxuXCIsIHNvdXJjZUNvZGUpXG4gICAgICAgIGNvbnN0IG1ha2VWYWxpZGF0ZSA9IG5ldyBGdW5jdGlvbihgJHtuYW1lc18xLmRlZmF1bHQuc2VsZn1gLCBgJHtuYW1lc18xLmRlZmF1bHQuc2NvcGV9YCwgc291cmNlQ29kZSk7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRlID0gbWFrZVZhbGlkYXRlKHRoaXMsIHRoaXMuc2NvcGUuZ2V0KCkpO1xuICAgICAgICB0aGlzLnNjb3BlLnZhbHVlKHZhbGlkYXRlTmFtZSwgeyByZWY6IHZhbGlkYXRlIH0pO1xuICAgICAgICB2YWxpZGF0ZS5lcnJvcnMgPSBudWxsO1xuICAgICAgICB2YWxpZGF0ZS5zY2hlbWEgPSBzY2guc2NoZW1hO1xuICAgICAgICB2YWxpZGF0ZS5zY2hlbWFFbnYgPSBzY2g7XG4gICAgICAgIGlmIChzY2guJGFzeW5jKVxuICAgICAgICAgICAgdmFsaWRhdGUuJGFzeW5jID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMub3B0cy5jb2RlLnNvdXJjZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFsaWRhdGUuc291cmNlID0geyB2YWxpZGF0ZU5hbWUsIHZhbGlkYXRlQ29kZSwgc2NvcGVWYWx1ZXM6IGdlbi5fdmFsdWVzIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0cy51bmV2YWx1YXRlZCkge1xuICAgICAgICAgICAgY29uc3QgeyBwcm9wcywgaXRlbXMgfSA9IHNjaGVtYUN4dDtcbiAgICAgICAgICAgIHZhbGlkYXRlLmV2YWx1YXRlZCA9IHtcbiAgICAgICAgICAgICAgICBwcm9wczogcHJvcHMgaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSA/IHVuZGVmaW5lZCA6IHByb3BzLFxuICAgICAgICAgICAgICAgIGl0ZW1zOiBpdGVtcyBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lID8gdW5kZWZpbmVkIDogaXRlbXMsXG4gICAgICAgICAgICAgICAgZHluYW1pY1Byb3BzOiBwcm9wcyBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lLFxuICAgICAgICAgICAgICAgIGR5bmFtaWNJdGVtczogaXRlbXMgaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodmFsaWRhdGUuc291cmNlKVxuICAgICAgICAgICAgICAgIHZhbGlkYXRlLnNvdXJjZS5ldmFsdWF0ZWQgPSAoMCwgY29kZWdlbl8xLnN0cmluZ2lmeSkodmFsaWRhdGUuZXZhbHVhdGVkKTtcbiAgICAgICAgfVxuICAgICAgICBzY2gudmFsaWRhdGUgPSB2YWxpZGF0ZTtcbiAgICAgICAgcmV0dXJuIHNjaDtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgZGVsZXRlIHNjaC52YWxpZGF0ZTtcbiAgICAgICAgZGVsZXRlIHNjaC52YWxpZGF0ZU5hbWU7XG4gICAgICAgIGlmIChzb3VyY2VDb2RlKVxuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXCJFcnJvciBjb21waWxpbmcgc2NoZW1hLCBmdW5jdGlvbiBjb2RlOlwiLCBzb3VyY2VDb2RlKTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJcXG5cXG5cXG4gKioqIFxcblwiLCBzb3VyY2VDb2RlLCB0aGlzLm9wdHMpXG4gICAgICAgIHRocm93IGU7XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0aGlzLl9jb21waWxhdGlvbnMuZGVsZXRlKHNjaCk7XG4gICAgfVxufVxuZXhwb3J0cy5jb21waWxlU2NoZW1hID0gY29tcGlsZVNjaGVtYTtcbmZ1bmN0aW9uIHJlc29sdmVSZWYocm9vdCwgYmFzZUlkLCByZWYpIHtcbiAgICB2YXIgX2E7XG4gICAgcmVmID0gKDAsIHJlc29sdmVfMS5yZXNvbHZlVXJsKSh0aGlzLm9wdHMudXJpUmVzb2x2ZXIsIGJhc2VJZCwgcmVmKTtcbiAgICBjb25zdCBzY2hPckZ1bmMgPSByb290LnJlZnNbcmVmXTtcbiAgICBpZiAoc2NoT3JGdW5jKVxuICAgICAgICByZXR1cm4gc2NoT3JGdW5jO1xuICAgIGxldCBfc2NoID0gcmVzb2x2ZS5jYWxsKHRoaXMsIHJvb3QsIHJlZik7XG4gICAgaWYgKF9zY2ggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBzY2hlbWEgPSAoX2EgPSByb290LmxvY2FsUmVmcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW3JlZl07IC8vIFRPRE8gbWF5YmUgbG9jYWxSZWZzIHNob3VsZCBob2xkIFNjaGVtYUVudlxuICAgICAgICBjb25zdCB7IHNjaGVtYUlkIH0gPSB0aGlzLm9wdHM7XG4gICAgICAgIGlmIChzY2hlbWEpXG4gICAgICAgICAgICBfc2NoID0gbmV3IFNjaGVtYUVudih7IHNjaGVtYSwgc2NoZW1hSWQsIHJvb3QsIGJhc2VJZCB9KTtcbiAgICB9XG4gICAgaWYgKF9zY2ggPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuO1xuICAgIHJldHVybiAocm9vdC5yZWZzW3JlZl0gPSBpbmxpbmVPckNvbXBpbGUuY2FsbCh0aGlzLCBfc2NoKSk7XG59XG5leHBvcnRzLnJlc29sdmVSZWYgPSByZXNvbHZlUmVmO1xuZnVuY3Rpb24gaW5saW5lT3JDb21waWxlKHNjaCkge1xuICAgIGlmICgoMCwgcmVzb2x2ZV8xLmlubGluZVJlZikoc2NoLnNjaGVtYSwgdGhpcy5vcHRzLmlubGluZVJlZnMpKVxuICAgICAgICByZXR1cm4gc2NoLnNjaGVtYTtcbiAgICByZXR1cm4gc2NoLnZhbGlkYXRlID8gc2NoIDogY29tcGlsZVNjaGVtYS5jYWxsKHRoaXMsIHNjaCk7XG59XG4vLyBJbmRleCBvZiBzY2hlbWEgY29tcGlsYXRpb24gaW4gdGhlIGN1cnJlbnRseSBjb21waWxlZCBsaXN0XG5mdW5jdGlvbiBnZXRDb21waWxpbmdTY2hlbWEoc2NoRW52KSB7XG4gICAgZm9yIChjb25zdCBzY2ggb2YgdGhpcy5fY29tcGlsYXRpb25zKSB7XG4gICAgICAgIGlmIChzYW1lU2NoZW1hRW52KHNjaCwgc2NoRW52KSlcbiAgICAgICAgICAgIHJldHVybiBzY2g7XG4gICAgfVxufVxuZXhwb3J0cy5nZXRDb21waWxpbmdTY2hlbWEgPSBnZXRDb21waWxpbmdTY2hlbWE7XG5mdW5jdGlvbiBzYW1lU2NoZW1hRW52KHMxLCBzMikge1xuICAgIHJldHVybiBzMS5zY2hlbWEgPT09IHMyLnNjaGVtYSAmJiBzMS5yb290ID09PSBzMi5yb290ICYmIHMxLmJhc2VJZCA9PT0gczIuYmFzZUlkO1xufVxuLy8gcmVzb2x2ZSBhbmQgY29tcGlsZSB0aGUgcmVmZXJlbmNlcyAoJHJlZilcbi8vIFRPRE8gcmV0dXJucyBBbnlTY2hlbWFPYmplY3QgKGlmIHRoZSBzY2hlbWEgY2FuIGJlIGlubGluZWQpIG9yIHZhbGlkYXRpb24gZnVuY3Rpb25cbmZ1bmN0aW9uIHJlc29sdmUocm9vdCwgLy8gaW5mb3JtYXRpb24gYWJvdXQgdGhlIHJvb3Qgc2NoZW1hIGZvciB0aGUgY3VycmVudCBzY2hlbWFcbnJlZiAvLyByZWZlcmVuY2UgdG8gcmVzb2x2ZVxuKSB7XG4gICAgbGV0IHNjaDtcbiAgICB3aGlsZSAodHlwZW9mIChzY2ggPSB0aGlzLnJlZnNbcmVmXSkgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmVmID0gc2NoO1xuICAgIHJldHVybiBzY2ggfHwgdGhpcy5zY2hlbWFzW3JlZl0gfHwgcmVzb2x2ZVNjaGVtYS5jYWxsKHRoaXMsIHJvb3QsIHJlZik7XG59XG4vLyBSZXNvbHZlIHNjaGVtYSwgaXRzIHJvb3QgYW5kIGJhc2VJZFxuZnVuY3Rpb24gcmVzb2x2ZVNjaGVtYShyb290LCAvLyByb290IG9iamVjdCB3aXRoIHByb3BlcnRpZXMgc2NoZW1hLCByZWZzIFRPRE8gYmVsb3cgU2NoZW1hRW52IGlzIGFzc2lnbmVkIHRvIGl0XG5yZWYgLy8gcmVmZXJlbmNlIHRvIHJlc29sdmVcbikge1xuICAgIGNvbnN0IHAgPSB0aGlzLm9wdHMudXJpUmVzb2x2ZXIucGFyc2UocmVmKTtcbiAgICBjb25zdCByZWZQYXRoID0gKDAsIHJlc29sdmVfMS5fZ2V0RnVsbFBhdGgpKHRoaXMub3B0cy51cmlSZXNvbHZlciwgcCk7XG4gICAgbGV0IGJhc2VJZCA9ICgwLCByZXNvbHZlXzEuZ2V0RnVsbFBhdGgpKHRoaXMub3B0cy51cmlSZXNvbHZlciwgcm9vdC5iYXNlSWQsIHVuZGVmaW5lZCk7XG4gICAgLy8gVE9ETyBgT2JqZWN0LmtleXMocm9vdC5zY2hlbWEpLmxlbmd0aCA+IDBgIHNob3VsZCBub3QgYmUgbmVlZGVkIC0gYnV0IHJlbW92aW5nIGJyZWFrcyAyIHRlc3RzXG4gICAgaWYgKE9iamVjdC5rZXlzKHJvb3Quc2NoZW1hKS5sZW5ndGggPiAwICYmIHJlZlBhdGggPT09IGJhc2VJZCkge1xuICAgICAgICByZXR1cm4gZ2V0SnNvblBvaW50ZXIuY2FsbCh0aGlzLCBwLCByb290KTtcbiAgICB9XG4gICAgY29uc3QgaWQgPSAoMCwgcmVzb2x2ZV8xLm5vcm1hbGl6ZUlkKShyZWZQYXRoKTtcbiAgICBjb25zdCBzY2hPclJlZiA9IHRoaXMucmVmc1tpZF0gfHwgdGhpcy5zY2hlbWFzW2lkXTtcbiAgICBpZiAodHlwZW9mIHNjaE9yUmVmID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29uc3Qgc2NoID0gcmVzb2x2ZVNjaGVtYS5jYWxsKHRoaXMsIHJvb3QsIHNjaE9yUmVmKTtcbiAgICAgICAgaWYgKHR5cGVvZiAoc2NoID09PSBudWxsIHx8IHNjaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2NoLnNjaGVtYSkgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHJldHVybiBnZXRKc29uUG9pbnRlci5jYWxsKHRoaXMsIHAsIHNjaCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHNjaE9yUmVmID09PSBudWxsIHx8IHNjaE9yUmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY2hPclJlZi5zY2hlbWEpICE9PSBcIm9iamVjdFwiKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKCFzY2hPclJlZi52YWxpZGF0ZSlcbiAgICAgICAgY29tcGlsZVNjaGVtYS5jYWxsKHRoaXMsIHNjaE9yUmVmKTtcbiAgICBpZiAoaWQgPT09ICgwLCByZXNvbHZlXzEubm9ybWFsaXplSWQpKHJlZikpIHtcbiAgICAgICAgY29uc3QgeyBzY2hlbWEgfSA9IHNjaE9yUmVmO1xuICAgICAgICBjb25zdCB7IHNjaGVtYUlkIH0gPSB0aGlzLm9wdHM7XG4gICAgICAgIGNvbnN0IHNjaElkID0gc2NoZW1hW3NjaGVtYUlkXTtcbiAgICAgICAgaWYgKHNjaElkKVxuICAgICAgICAgICAgYmFzZUlkID0gKDAsIHJlc29sdmVfMS5yZXNvbHZlVXJsKSh0aGlzLm9wdHMudXJpUmVzb2x2ZXIsIGJhc2VJZCwgc2NoSWQpO1xuICAgICAgICByZXR1cm4gbmV3IFNjaGVtYUVudih7IHNjaGVtYSwgc2NoZW1hSWQsIHJvb3QsIGJhc2VJZCB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGdldEpzb25Qb2ludGVyLmNhbGwodGhpcywgcCwgc2NoT3JSZWYpO1xufVxuZXhwb3J0cy5yZXNvbHZlU2NoZW1hID0gcmVzb2x2ZVNjaGVtYTtcbmNvbnN0IFBSRVZFTlRfU0NPUEVfQ0hBTkdFID0gbmV3IFNldChbXG4gICAgXCJwcm9wZXJ0aWVzXCIsXG4gICAgXCJwYXR0ZXJuUHJvcGVydGllc1wiLFxuICAgIFwiZW51bVwiLFxuICAgIFwiZGVwZW5kZW5jaWVzXCIsXG4gICAgXCJkZWZpbml0aW9uc1wiLFxuXSk7XG5mdW5jdGlvbiBnZXRKc29uUG9pbnRlcihwYXJzZWRSZWYsIHsgYmFzZUlkLCBzY2hlbWEsIHJvb3QgfSkge1xuICAgIHZhciBfYTtcbiAgICBpZiAoKChfYSA9IHBhcnNlZFJlZi5mcmFnbWVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdKSAhPT0gXCIvXCIpXG4gICAgICAgIHJldHVybjtcbiAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFyc2VkUmVmLmZyYWdtZW50LnNsaWNlKDEpLnNwbGl0KFwiL1wiKSkge1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYSA9PT0gXCJib29sZWFuXCIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHBhcnRTY2hlbWEgPSBzY2hlbWFbKDAsIHV0aWxfMS51bmVzY2FwZUZyYWdtZW50KShwYXJ0KV07XG4gICAgICAgIGlmIChwYXJ0U2NoZW1hID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHNjaGVtYSA9IHBhcnRTY2hlbWE7XG4gICAgICAgIC8vIFRPRE8gUFJFVkVOVF9TQ09QRV9DSEFOR0UgY291bGQgYmUgZGVmaW5lZCBpbiBrZXl3b3JkIGRlZj9cbiAgICAgICAgY29uc3Qgc2NoSWQgPSB0eXBlb2Ygc2NoZW1hID09PSBcIm9iamVjdFwiICYmIHNjaGVtYVt0aGlzLm9wdHMuc2NoZW1hSWRdO1xuICAgICAgICBpZiAoIVBSRVZFTlRfU0NPUEVfQ0hBTkdFLmhhcyhwYXJ0KSAmJiBzY2hJZCkge1xuICAgICAgICAgICAgYmFzZUlkID0gKDAsIHJlc29sdmVfMS5yZXNvbHZlVXJsKSh0aGlzLm9wdHMudXJpUmVzb2x2ZXIsIGJhc2VJZCwgc2NoSWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBlbnY7XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgIT0gXCJib29sZWFuXCIgJiYgc2NoZW1hLiRyZWYgJiYgISgwLCB1dGlsXzEuc2NoZW1hSGFzUnVsZXNCdXRSZWYpKHNjaGVtYSwgdGhpcy5SVUxFUykpIHtcbiAgICAgICAgY29uc3QgJHJlZiA9ICgwLCByZXNvbHZlXzEucmVzb2x2ZVVybCkodGhpcy5vcHRzLnVyaVJlc29sdmVyLCBiYXNlSWQsIHNjaGVtYS4kcmVmKTtcbiAgICAgICAgZW52ID0gcmVzb2x2ZVNjaGVtYS5jYWxsKHRoaXMsIHJvb3QsICRyZWYpO1xuICAgIH1cbiAgICAvLyBldmVuIHRob3VnaCByZXNvbHV0aW9uIGZhaWxlZCB3ZSBuZWVkIHRvIHJldHVybiBTY2hlbWFFbnYgdG8gdGhyb3cgZXhjZXB0aW9uXG4gICAgLy8gc28gdGhhdCBjb21waWxlQXN5bmMgbG9hZHMgbWlzc2luZyBzY2hlbWEuXG4gICAgY29uc3QgeyBzY2hlbWFJZCB9ID0gdGhpcy5vcHRzO1xuICAgIGVudiA9IGVudiB8fCBuZXcgU2NoZW1hRW52KHsgc2NoZW1hLCBzY2hlbWFJZCwgcm9vdCwgYmFzZUlkIH0pO1xuICAgIGlmIChlbnYuc2NoZW1hICE9PSBlbnYucm9vdC5zY2hlbWEpXG4gICAgICAgIHJldHVybiBlbnY7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIntcbiAgXCIkaWRcIjogXCJodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vYWp2LXZhbGlkYXRvci9hanYvbWFzdGVyL2xpYi9yZWZzL2RhdGEuanNvbiNcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIk1ldGEtc2NoZW1hIGZvciAkZGF0YSByZWZlcmVuY2UgKEpTT04gQW55U2NoZW1hIGV4dGVuc2lvbiBwcm9wb3NhbClcIixcbiAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gIFwicmVxdWlyZWRcIjogW1wiJGRhdGFcIl0sXG4gIFwicHJvcGVydGllc1wiOiB7XG4gICAgXCIkZGF0YVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiYW55T2ZcIjogW3tcImZvcm1hdFwiOiBcInJlbGF0aXZlLWpzb24tcG9pbnRlclwifSwge1wiZm9ybWF0XCI6IFwianNvbi1wb2ludGVyXCJ9XVxuICAgIH1cbiAgfSxcbiAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiBmYWxzZVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbi8qKiBAdHlwZSB7KHZhbHVlOiBzdHJpbmcpID0+IGJvb2xlYW59ICovXG5jb25zdCBpc1VVSUQgPSBSZWdFeHAucHJvdG90eXBlLnRlc3QuYmluZCgvXltcXGRhLWZdezh9LVtcXGRhLWZdezR9LVtcXGRhLWZdezR9LVtcXGRhLWZdezR9LVtcXGRhLWZdezEyfSQvaXUpXG5cbi8qKiBAdHlwZSB7KHZhbHVlOiBzdHJpbmcpID0+IGJvb2xlYW59ICovXG5jb25zdCBpc0lQdjQgPSBSZWdFeHAucHJvdG90eXBlLnRlc3QuYmluZCgvXig/Oig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGR7Mn18WzEtOV1cXGR8XFxkKVxcLil7M30oPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkezJ9fFsxLTldXFxkfFxcZCkkL3UpXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBpbnB1dFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gc3RyaW5nQXJyYXlUb0hleFN0cmlwcGVkIChpbnB1dCkge1xuICBsZXQgYWNjID0gJydcbiAgbGV0IGNvZGUgPSAwXG4gIGxldCBpID0gMFxuXG4gIGZvciAoaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgIGNvZGUgPSBpbnB1dFtpXS5jaGFyQ29kZUF0KDApXG4gICAgaWYgKGNvZGUgPT09IDQ4KSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBpZiAoISgoY29kZSA+PSA0OCAmJiBjb2RlIDw9IDU3KSB8fCAoY29kZSA+PSA2NSAmJiBjb2RlIDw9IDcwKSB8fCAoY29kZSA+PSA5NyAmJiBjb2RlIDw9IDEwMikpKSB7XG4gICAgICByZXR1cm4gJydcbiAgICB9XG4gICAgYWNjICs9IGlucHV0W2ldXG4gICAgYnJlYWtcbiAgfVxuXG4gIGZvciAoaSArPSAxOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICBjb2RlID0gaW5wdXRbaV0uY2hhckNvZGVBdCgwKVxuICAgIGlmICghKChjb2RlID49IDQ4ICYmIGNvZGUgPD0gNTcpIHx8IChjb2RlID49IDY1ICYmIGNvZGUgPD0gNzApIHx8IChjb2RlID49IDk3ICYmIGNvZGUgPD0gMTAyKSkpIHtcbiAgICAgIHJldHVybiAnJ1xuICAgIH1cbiAgICBhY2MgKz0gaW5wdXRbaV1cbiAgfVxuICByZXR1cm4gYWNjXG59XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gR2V0SVBWNlJlc3VsdFxuICogQHByb3BlcnR5IHtib29sZWFufSBlcnJvciAtIEluZGljYXRlcyBpZiB0aGVyZSB3YXMgYW4gZXJyb3IgcGFyc2luZyB0aGUgSVB2NiBhZGRyZXNzLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGFkZHJlc3MgLSBUaGUgcGFyc2VkIElQdjYgYWRkcmVzcy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbem9uZV0gLSBUaGUgem9uZSBpZGVudGlmaWVyLCBpZiBwcmVzZW50LlxuICovXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuY29uc3Qgbm9uU2ltcGxlRG9tYWluID0gUmVnRXhwLnByb3RvdHlwZS50ZXN0LmJpbmQoL1teIVwiJCYnKCkqKyxcXC0uOz1fYGEtent9fl0vdSlcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGJ1ZmZlclxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGNvbnN1bWVJc1pvbmUgKGJ1ZmZlcikge1xuICBidWZmZXIubGVuZ3RoID0gMFxuICByZXR1cm4gdHJ1ZVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gYnVmZmVyXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGFkZHJlc3NcbiAqIEBwYXJhbSB7R2V0SVBWNlJlc3VsdH0gb3V0cHV0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gY29uc3VtZUhleHRldHMgKGJ1ZmZlciwgYWRkcmVzcywgb3V0cHV0KSB7XG4gIGlmIChidWZmZXIubGVuZ3RoKSB7XG4gICAgY29uc3QgaGV4ID0gc3RyaW5nQXJyYXlUb0hleFN0cmlwcGVkKGJ1ZmZlcilcbiAgICBpZiAoaGV4ICE9PSAnJykge1xuICAgICAgYWRkcmVzcy5wdXNoKGhleClcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LmVycm9yID0gdHJ1ZVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGJ1ZmZlci5sZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRcbiAqIEByZXR1cm5zIHtHZXRJUFY2UmVzdWx0fVxuICovXG5mdW5jdGlvbiBnZXRJUFY2IChpbnB1dCkge1xuICBsZXQgdG9rZW5Db3VudCA9IDBcbiAgY29uc3Qgb3V0cHV0ID0geyBlcnJvcjogZmFsc2UsIGFkZHJlc3M6ICcnLCB6b25lOiAnJyB9XG4gIC8qKiBAdHlwZSB7QXJyYXk8c3RyaW5nPn0gKi9cbiAgY29uc3QgYWRkcmVzcyA9IFtdXG4gIC8qKiBAdHlwZSB7QXJyYXk8c3RyaW5nPn0gKi9cbiAgY29uc3QgYnVmZmVyID0gW11cbiAgbGV0IGVuZGlwdjZFbmNvdW50ZXJlZCA9IGZhbHNlXG4gIGxldCBlbmRJcHY2ID0gZmFsc2VcblxuICBsZXQgY29uc3VtZSA9IGNvbnN1bWVIZXh0ZXRzXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGN1cnNvciA9IGlucHV0W2ldXG4gICAgaWYgKGN1cnNvciA9PT0gJ1snIHx8IGN1cnNvciA9PT0gJ10nKSB7IGNvbnRpbnVlIH1cbiAgICBpZiAoY3Vyc29yID09PSAnOicpIHtcbiAgICAgIGlmIChlbmRpcHY2RW5jb3VudGVyZWQgPT09IHRydWUpIHtcbiAgICAgICAgZW5kSXB2NiA9IHRydWVcbiAgICAgIH1cbiAgICAgIGlmICghY29uc3VtZShidWZmZXIsIGFkZHJlc3MsIG91dHB1dCkpIHsgYnJlYWsgfVxuICAgICAgaWYgKCsrdG9rZW5Db3VudCA+IDcpIHtcbiAgICAgICAgLy8gbm90IHZhbGlkXG4gICAgICAgIG91dHB1dC5lcnJvciA9IHRydWVcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGlmIChpID4gMCAmJiBpbnB1dFtpIC0gMV0gPT09ICc6Jykge1xuICAgICAgICBlbmRpcHY2RW5jb3VudGVyZWQgPSB0cnVlXG4gICAgICB9XG4gICAgICBhZGRyZXNzLnB1c2goJzonKVxuICAgICAgY29udGludWVcbiAgICB9IGVsc2UgaWYgKGN1cnNvciA9PT0gJyUnKSB7XG4gICAgICBpZiAoIWNvbnN1bWUoYnVmZmVyLCBhZGRyZXNzLCBvdXRwdXQpKSB7IGJyZWFrIH1cbiAgICAgIC8vIHN3aXRjaCB0byB6b25lIGRldGVjdGlvblxuICAgICAgY29uc3VtZSA9IGNvbnN1bWVJc1pvbmVcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmZmVyLnB1c2goY3Vyc29yKVxuICAgICAgY29udGludWVcbiAgICB9XG4gIH1cbiAgaWYgKGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoY29uc3VtZSA9PT0gY29uc3VtZUlzWm9uZSkge1xuICAgICAgb3V0cHV0LnpvbmUgPSBidWZmZXIuam9pbignJylcbiAgICB9IGVsc2UgaWYgKGVuZElwdjYpIHtcbiAgICAgIGFkZHJlc3MucHVzaChidWZmZXIuam9pbignJykpXG4gICAgfSBlbHNlIHtcbiAgICAgIGFkZHJlc3MucHVzaChzdHJpbmdBcnJheVRvSGV4U3RyaXBwZWQoYnVmZmVyKSlcbiAgICB9XG4gIH1cbiAgb3V0cHV0LmFkZHJlc3MgPSBhZGRyZXNzLmpvaW4oJycpXG4gIHJldHVybiBvdXRwdXRcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBOb3JtYWxpemVJUHY2UmVzdWx0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gaG9zdCAtIFRoZSBub3JtYWxpemVkIGhvc3QuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2VzY2FwZWRIb3N0XSAtIFRoZSBlc2NhcGVkIGhvc3QuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzSVBWNiAtIEluZGljYXRlcyBpZiB0aGUgaG9zdCBpcyBhbiBJUHY2IGFkZHJlc3MuXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gaG9zdFxuICogQHJldHVybnMge05vcm1hbGl6ZUlQdjZSZXN1bHR9XG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUlQdjYgKGhvc3QpIHtcbiAgaWYgKGZpbmRUb2tlbihob3N0LCAnOicpIDwgMikgeyByZXR1cm4geyBob3N0LCBpc0lQVjY6IGZhbHNlIH0gfVxuICBjb25zdCBpcHY2ID0gZ2V0SVBWNihob3N0KVxuXG4gIGlmICghaXB2Ni5lcnJvcikge1xuICAgIGxldCBuZXdIb3N0ID0gaXB2Ni5hZGRyZXNzXG4gICAgbGV0IGVzY2FwZWRIb3N0ID0gaXB2Ni5hZGRyZXNzXG4gICAgaWYgKGlwdjYuem9uZSkge1xuICAgICAgbmV3SG9zdCArPSAnJScgKyBpcHY2LnpvbmVcbiAgICAgIGVzY2FwZWRIb3N0ICs9ICclMjUnICsgaXB2Ni56b25lXG4gICAgfVxuICAgIHJldHVybiB7IGhvc3Q6IG5ld0hvc3QsIGlzSVBWNjogdHJ1ZSwgZXNjYXBlZEhvc3QgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB7IGhvc3QsIGlzSVBWNjogZmFsc2UgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHBhcmFtIHtzdHJpbmd9IHRva2VuXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBmaW5kVG9rZW4gKHN0ciwgdG9rZW4pIHtcbiAgbGV0IGluZCA9IDBcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3RyW2ldID09PSB0b2tlbikgaW5kKytcbiAgfVxuICByZXR1cm4gaW5kXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKlxuICogQHNlZSBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzM5ODYjc2VjdGlvbi01LjIuNFxuICovXG5mdW5jdGlvbiByZW1vdmVEb3RTZWdtZW50cyAocGF0aCkge1xuICBsZXQgaW5wdXQgPSBwYXRoXG4gIGNvbnN0IG91dHB1dCA9IFtdXG4gIGxldCBuZXh0U2xhc2ggPSAtMVxuICBsZXQgbGVuID0gMFxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25kLWFzc2lnblxuICB3aGlsZSAobGVuID0gaW5wdXQubGVuZ3RoKSB7XG4gICAgaWYgKGxlbiA9PT0gMSkge1xuICAgICAgaWYgKGlucHV0ID09PSAnLicpIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH0gZWxzZSBpZiAoaW5wdXQgPT09ICcvJykge1xuICAgICAgICBvdXRwdXQucHVzaCgnLycpXG4gICAgICAgIGJyZWFrXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXRwdXQucHVzaChpbnB1dClcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxlbiA9PT0gMikge1xuICAgICAgaWYgKGlucHV0WzBdID09PSAnLicpIHtcbiAgICAgICAgaWYgKGlucHV0WzFdID09PSAnLicpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9IGVsc2UgaWYgKGlucHV0WzFdID09PSAnLycpIHtcbiAgICAgICAgICBpbnB1dCA9IGlucHV0LnNsaWNlKDIpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpbnB1dFswXSA9PT0gJy8nKSB7XG4gICAgICAgIGlmIChpbnB1dFsxXSA9PT0gJy4nIHx8IGlucHV0WzFdID09PSAnLycpIHtcbiAgICAgICAgICBvdXRwdXQucHVzaCgnLycpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobGVuID09PSAzKSB7XG4gICAgICBpZiAoaW5wdXQgPT09ICcvLi4nKSB7XG4gICAgICAgIGlmIChvdXRwdXQubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgb3V0cHV0LnBvcCgpXG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0LnB1c2goJy8nKVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaW5wdXRbMF0gPT09ICcuJykge1xuICAgICAgaWYgKGlucHV0WzFdID09PSAnLicpIHtcbiAgICAgICAgaWYgKGlucHV0WzJdID09PSAnLycpIHtcbiAgICAgICAgICBpbnB1dCA9IGlucHV0LnNsaWNlKDMpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpbnB1dFsxXSA9PT0gJy8nKSB7XG4gICAgICAgIGlucHV0ID0gaW5wdXQuc2xpY2UoMilcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlucHV0WzBdID09PSAnLycpIHtcbiAgICAgIGlmIChpbnB1dFsxXSA9PT0gJy4nKSB7XG4gICAgICAgIGlmIChpbnB1dFsyXSA9PT0gJy8nKSB7XG4gICAgICAgICAgaW5wdXQgPSBpbnB1dC5zbGljZSgyKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXRbMl0gPT09ICcuJykge1xuICAgICAgICAgIGlmIChpbnB1dFszXSA9PT0gJy8nKSB7XG4gICAgICAgICAgICBpbnB1dCA9IGlucHV0LnNsaWNlKDMpXG4gICAgICAgICAgICBpZiAob3V0cHV0Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICBvdXRwdXQucG9wKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUnVsZSAyRTogTW92ZSBub3JtYWwgcGF0aCBzZWdtZW50IHRvIG91dHB1dFxuICAgIGlmICgobmV4dFNsYXNoID0gaW5wdXQuaW5kZXhPZignLycsIDEpKSA9PT0gLTEpIHtcbiAgICAgIG91dHB1dC5wdXNoKGlucHV0KVxuICAgICAgYnJlYWtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goaW5wdXQuc2xpY2UoMCwgbmV4dFNsYXNoKSlcbiAgICAgIGlucHV0ID0gaW5wdXQuc2xpY2UobmV4dFNsYXNoKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vdHlwZXMvaW5kZXgnKS5VUklDb21wb25lbnR9IGNvbXBvbmVudFxuICogQHBhcmFtIHtib29sZWFufSBlc2NcbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4uL3R5cGVzL2luZGV4JykuVVJJQ29tcG9uZW50fVxuICovXG5mdW5jdGlvbiBub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyAoY29tcG9uZW50LCBlc2MpIHtcbiAgY29uc3QgZnVuYyA9IGVzYyAhPT0gdHJ1ZSA/IGVzY2FwZSA6IHVuZXNjYXBlXG4gIGlmIChjb21wb25lbnQuc2NoZW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb21wb25lbnQuc2NoZW1lID0gZnVuYyhjb21wb25lbnQuc2NoZW1lKVxuICB9XG4gIGlmIChjb21wb25lbnQudXNlcmluZm8gIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbXBvbmVudC51c2VyaW5mbyA9IGZ1bmMoY29tcG9uZW50LnVzZXJpbmZvKVxuICB9XG4gIGlmIChjb21wb25lbnQuaG9zdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29tcG9uZW50Lmhvc3QgPSBmdW5jKGNvbXBvbmVudC5ob3N0KVxuICB9XG4gIGlmIChjb21wb25lbnQucGF0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29tcG9uZW50LnBhdGggPSBmdW5jKGNvbXBvbmVudC5wYXRoKVxuICB9XG4gIGlmIChjb21wb25lbnQucXVlcnkgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbXBvbmVudC5xdWVyeSA9IGZ1bmMoY29tcG9uZW50LnF1ZXJ5KVxuICB9XG4gIGlmIChjb21wb25lbnQuZnJhZ21lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbXBvbmVudC5mcmFnbWVudCA9IGZ1bmMoY29tcG9uZW50LmZyYWdtZW50KVxuICB9XG4gIHJldHVybiBjb21wb25lbnRcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vdHlwZXMvaW5kZXgnKS5VUklDb21wb25lbnR9IGNvbXBvbmVudFxuICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIHJlY29tcG9zZUF1dGhvcml0eSAoY29tcG9uZW50KSB7XG4gIGNvbnN0IHVyaVRva2VucyA9IFtdXG5cbiAgaWYgKGNvbXBvbmVudC51c2VyaW5mbyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdXJpVG9rZW5zLnB1c2goY29tcG9uZW50LnVzZXJpbmZvKVxuICAgIHVyaVRva2Vucy5wdXNoKCdAJylcbiAgfVxuXG4gIGlmIChjb21wb25lbnQuaG9zdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgbGV0IGhvc3QgPSB1bmVzY2FwZShjb21wb25lbnQuaG9zdClcbiAgICBpZiAoIWlzSVB2NChob3N0KSkge1xuICAgICAgY29uc3QgaXBWNnJlcyA9IG5vcm1hbGl6ZUlQdjYoaG9zdClcbiAgICAgIGlmIChpcFY2cmVzLmlzSVBWNiA9PT0gdHJ1ZSkge1xuICAgICAgICBob3N0ID0gYFske2lwVjZyZXMuZXNjYXBlZEhvc3R9XWBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhvc3QgPSBjb21wb25lbnQuaG9zdFxuICAgICAgfVxuICAgIH1cbiAgICB1cmlUb2tlbnMucHVzaChob3N0KVxuICB9XG5cbiAgaWYgKHR5cGVvZiBjb21wb25lbnQucG9ydCA9PT0gJ251bWJlcicgfHwgdHlwZW9mIGNvbXBvbmVudC5wb3J0ID09PSAnc3RyaW5nJykge1xuICAgIHVyaVRva2Vucy5wdXNoKCc6JylcbiAgICB1cmlUb2tlbnMucHVzaChTdHJpbmcoY29tcG9uZW50LnBvcnQpKVxuICB9XG5cbiAgcmV0dXJuIHVyaVRva2Vucy5sZW5ndGggPyB1cmlUb2tlbnMuam9pbignJykgOiB1bmRlZmluZWRcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBub25TaW1wbGVEb21haW4sXG4gIHJlY29tcG9zZUF1dGhvcml0eSxcbiAgbm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcsXG4gIHJlbW92ZURvdFNlZ21lbnRzLFxuICBpc0lQdjQsXG4gIGlzVVVJRCxcbiAgbm9ybWFsaXplSVB2NixcbiAgc3RyaW5nQXJyYXlUb0hleFN0cmlwcGVkXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgeyBpc1VVSUQgfSA9IHJlcXVpcmUoJy4vdXRpbHMnKVxuY29uc3QgVVJOX1JFRyA9IC8oW1xcZGEtel1bXFxkXFwtYS16XXswLDMxfSk6KCg/OltcXHchJCcoKSorLFxcLS46Oz1AXXwlW1xcZGEtZl17Mn0pKykvaXVcblxuY29uc3Qgc3VwcG9ydGVkU2NoZW1lTmFtZXMgPSAvKiogQHR5cGUge2NvbnN0fSAqLyAoWydodHRwJywgJ2h0dHBzJywgJ3dzJyxcbiAgJ3dzcycsICd1cm4nLCAndXJuOnV1aWQnXSlcblxuLyoqIEB0eXBlZGVmIHtzdXBwb3J0ZWRTY2hlbWVOYW1lc1tudW1iZXJdfSBTY2hlbWVOYW1lICovXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtuYW1lIGlzIFNjaGVtZU5hbWV9XG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRTY2hlbWVOYW1lIChuYW1lKSB7XG4gIHJldHVybiBzdXBwb3J0ZWRTY2hlbWVOYW1lcy5pbmRleE9mKC8qKiBAdHlwZSB7Kn0gKi8gKG5hbWUpKSAhPT0gLTFcbn1cblxuLyoqXG4gKiBAY2FsbGJhY2sgU2NoZW1lRm5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi90eXBlcy9pbmRleCcpLlVSSUNvbXBvbmVudH0gY29tcG9uZW50XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vdHlwZXMvaW5kZXgnKS5PcHRpb25zfSBvcHRpb25zXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuLi90eXBlcy9pbmRleCcpLlVSSUNvbXBvbmVudH1cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFNjaGVtZUhhbmRsZXJcbiAqIEBwcm9wZXJ0eSB7U2NoZW1lTmFtZX0gc2NoZW1lIC0gVGhlIHNjaGVtZSBuYW1lLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbZG9tYWluSG9zdF0gLSBJbmRpY2F0ZXMgaWYgdGhlIHNjaGVtZSBzdXBwb3J0cyBkb21haW4gaG9zdHMuXG4gKiBAcHJvcGVydHkge1NjaGVtZUZufSBwYXJzZSAtIEZ1bmN0aW9uIHRvIHBhcnNlIHRoZSBVUkkgY29tcG9uZW50IGZvciB0aGlzIHNjaGVtZS5cbiAqIEBwcm9wZXJ0eSB7U2NoZW1lRm59IHNlcmlhbGl6ZSAtIEZ1bmN0aW9uIHRvIHNlcmlhbGl6ZSB0aGUgVVJJIGNvbXBvbmVudCBmb3IgdGhpcyBzY2hlbWUuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtza2lwTm9ybWFsaXplXSAtIEluZGljYXRlcyBpZiBub3JtYWxpemF0aW9uIHNob3VsZCBiZSBza2lwcGVkIGZvciB0aGlzIHNjaGVtZS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2Fic29sdXRlUGF0aF0gLSBJbmRpY2F0ZXMgaWYgdGhlIHNjaGVtZSB1c2VzIGFic29sdXRlIHBhdGhzLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbdW5pY29kZVN1cHBvcnRdIC0gSW5kaWNhdGVzIGlmIHRoZSBzY2hlbWUgc3VwcG9ydHMgVW5pY29kZS5cbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi90eXBlcy9pbmRleCcpLlVSSUNvbXBvbmVudH0gd3NDb21wb25lbnRcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiB3c0lzU2VjdXJlICh3c0NvbXBvbmVudCkge1xuICBpZiAod3NDb21wb25lbnQuc2VjdXJlID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfSBlbHNlIGlmICh3c0NvbXBvbmVudC5zZWN1cmUgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBpZiAod3NDb21wb25lbnQuc2NoZW1lKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHdzQ29tcG9uZW50LnNjaGVtZS5sZW5ndGggPT09IDMgJiZcbiAgICAgICh3c0NvbXBvbmVudC5zY2hlbWVbMF0gPT09ICd3JyB8fCB3c0NvbXBvbmVudC5zY2hlbWVbMF0gPT09ICdXJykgJiZcbiAgICAgICh3c0NvbXBvbmVudC5zY2hlbWVbMV0gPT09ICdzJyB8fCB3c0NvbXBvbmVudC5zY2hlbWVbMV0gPT09ICdTJykgJiZcbiAgICAgICh3c0NvbXBvbmVudC5zY2hlbWVbMl0gPT09ICdzJyB8fCB3c0NvbXBvbmVudC5zY2hlbWVbMl0gPT09ICdTJylcbiAgICApXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuLyoqIEB0eXBlIHtTY2hlbWVGbn0gKi9cbmZ1bmN0aW9uIGh0dHBQYXJzZSAoY29tcG9uZW50KSB7XG4gIGlmICghY29tcG9uZW50Lmhvc3QpIHtcbiAgICBjb21wb25lbnQuZXJyb3IgPSBjb21wb25lbnQuZXJyb3IgfHwgJ0hUVFAgVVJJcyBtdXN0IGhhdmUgYSBob3N0LidcbiAgfVxuXG4gIHJldHVybiBjb21wb25lbnRcbn1cblxuLyoqIEB0eXBlIHtTY2hlbWVGbn0gKi9cbmZ1bmN0aW9uIGh0dHBTZXJpYWxpemUgKGNvbXBvbmVudCkge1xuICBjb25zdCBzZWN1cmUgPSBTdHJpbmcoY29tcG9uZW50LnNjaGVtZSkudG9Mb3dlckNhc2UoKSA9PT0gJ2h0dHBzJ1xuXG4gIC8vIG5vcm1hbGl6ZSB0aGUgZGVmYXVsdCBwb3J0XG4gIGlmIChjb21wb25lbnQucG9ydCA9PT0gKHNlY3VyZSA/IDQ0MyA6IDgwKSB8fCBjb21wb25lbnQucG9ydCA9PT0gJycpIHtcbiAgICBjb21wb25lbnQucG9ydCA9IHVuZGVmaW5lZFxuICB9XG5cbiAgLy8gbm9ybWFsaXplIHRoZSBlbXB0eSBwYXRoXG4gIGlmICghY29tcG9uZW50LnBhdGgpIHtcbiAgICBjb21wb25lbnQucGF0aCA9ICcvJ1xuICB9XG5cbiAgLy8gTk9URTogV2UgZG8gbm90IHBhcnNlIHF1ZXJ5IHN0cmluZ3MgZm9yIEhUVFAgVVJJc1xuICAvLyBhcyBXV1cgRm9ybSBVcmwgRW5jb2RlZCBxdWVyeSBzdHJpbmdzIGFyZSBwYXJ0IG9mIHRoZSBIVE1MNCsgc3BlYyxcbiAgLy8gYW5kIG5vdCB0aGUgSFRUUCBzcGVjLlxuXG4gIHJldHVybiBjb21wb25lbnRcbn1cblxuLyoqIEB0eXBlIHtTY2hlbWVGbn0gKi9cbmZ1bmN0aW9uIHdzUGFyc2UgKHdzQ29tcG9uZW50KSB7XG4vLyBpbmRpY2F0ZSBpZiB0aGUgc2VjdXJlIGZsYWcgaXMgc2V0XG4gIHdzQ29tcG9uZW50LnNlY3VyZSA9IHdzSXNTZWN1cmUod3NDb21wb25lbnQpXG5cbiAgLy8gY29uc3RydWN0IHJlc291Y2UgbmFtZVxuICB3c0NvbXBvbmVudC5yZXNvdXJjZU5hbWUgPSAod3NDb21wb25lbnQucGF0aCB8fCAnLycpICsgKHdzQ29tcG9uZW50LnF1ZXJ5ID8gJz8nICsgd3NDb21wb25lbnQucXVlcnkgOiAnJylcbiAgd3NDb21wb25lbnQucGF0aCA9IHVuZGVmaW5lZFxuICB3c0NvbXBvbmVudC5xdWVyeSA9IHVuZGVmaW5lZFxuXG4gIHJldHVybiB3c0NvbXBvbmVudFxufVxuXG4vKiogQHR5cGUge1NjaGVtZUZufSAqL1xuZnVuY3Rpb24gd3NTZXJpYWxpemUgKHdzQ29tcG9uZW50KSB7XG4vLyBub3JtYWxpemUgdGhlIGRlZmF1bHQgcG9ydFxuICBpZiAod3NDb21wb25lbnQucG9ydCA9PT0gKHdzSXNTZWN1cmUod3NDb21wb25lbnQpID8gNDQzIDogODApIHx8IHdzQ29tcG9uZW50LnBvcnQgPT09ICcnKSB7XG4gICAgd3NDb21wb25lbnQucG9ydCA9IHVuZGVmaW5lZFxuICB9XG5cbiAgLy8gZW5zdXJlIHNjaGVtZSBtYXRjaGVzIHNlY3VyZSBmbGFnXG4gIGlmICh0eXBlb2Ygd3NDb21wb25lbnQuc2VjdXJlID09PSAnYm9vbGVhbicpIHtcbiAgICB3c0NvbXBvbmVudC5zY2hlbWUgPSAod3NDb21wb25lbnQuc2VjdXJlID8gJ3dzcycgOiAnd3MnKVxuICAgIHdzQ29tcG9uZW50LnNlY3VyZSA9IHVuZGVmaW5lZFxuICB9XG5cbiAgLy8gcmVjb25zdHJ1Y3QgcGF0aCBmcm9tIHJlc291cmNlIG5hbWVcbiAgaWYgKHdzQ29tcG9uZW50LnJlc291cmNlTmFtZSkge1xuICAgIGNvbnN0IFtwYXRoLCBxdWVyeV0gPSB3c0NvbXBvbmVudC5yZXNvdXJjZU5hbWUuc3BsaXQoJz8nKVxuICAgIHdzQ29tcG9uZW50LnBhdGggPSAocGF0aCAmJiBwYXRoICE9PSAnLycgPyBwYXRoIDogdW5kZWZpbmVkKVxuICAgIHdzQ29tcG9uZW50LnF1ZXJ5ID0gcXVlcnlcbiAgICB3c0NvbXBvbmVudC5yZXNvdXJjZU5hbWUgPSB1bmRlZmluZWRcbiAgfVxuXG4gIC8vIGZvcmJpZCBmcmFnbWVudCBjb21wb25lbnRcbiAgd3NDb21wb25lbnQuZnJhZ21lbnQgPSB1bmRlZmluZWRcblxuICByZXR1cm4gd3NDb21wb25lbnRcbn1cblxuLyoqIEB0eXBlIHtTY2hlbWVGbn0gKi9cbmZ1bmN0aW9uIHVyblBhcnNlICh1cm5Db21wb25lbnQsIG9wdGlvbnMpIHtcbiAgaWYgKCF1cm5Db21wb25lbnQucGF0aCkge1xuICAgIHVybkNvbXBvbmVudC5lcnJvciA9ICdVUk4gY2FuIG5vdCBiZSBwYXJzZWQnXG4gICAgcmV0dXJuIHVybkNvbXBvbmVudFxuICB9XG4gIGNvbnN0IG1hdGNoZXMgPSB1cm5Db21wb25lbnQucGF0aC5tYXRjaChVUk5fUkVHKVxuICBpZiAobWF0Y2hlcykge1xuICAgIGNvbnN0IHNjaGVtZSA9IG9wdGlvbnMuc2NoZW1lIHx8IHVybkNvbXBvbmVudC5zY2hlbWUgfHwgJ3VybidcbiAgICB1cm5Db21wb25lbnQubmlkID0gbWF0Y2hlc1sxXS50b0xvd2VyQ2FzZSgpXG4gICAgdXJuQ29tcG9uZW50Lm5zcyA9IG1hdGNoZXNbMl1cbiAgICBjb25zdCB1cm5TY2hlbWUgPSBgJHtzY2hlbWV9OiR7b3B0aW9ucy5uaWQgfHwgdXJuQ29tcG9uZW50Lm5pZH1gXG4gICAgY29uc3Qgc2NoZW1lSGFuZGxlciA9IGdldFNjaGVtZUhhbmRsZXIodXJuU2NoZW1lKVxuICAgIHVybkNvbXBvbmVudC5wYXRoID0gdW5kZWZpbmVkXG5cbiAgICBpZiAoc2NoZW1lSGFuZGxlcikge1xuICAgICAgdXJuQ29tcG9uZW50ID0gc2NoZW1lSGFuZGxlci5wYXJzZSh1cm5Db21wb25lbnQsIG9wdGlvbnMpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHVybkNvbXBvbmVudC5lcnJvciA9IHVybkNvbXBvbmVudC5lcnJvciB8fCAnVVJOIGNhbiBub3QgYmUgcGFyc2VkLidcbiAgfVxuXG4gIHJldHVybiB1cm5Db21wb25lbnRcbn1cblxuLyoqIEB0eXBlIHtTY2hlbWVGbn0gKi9cbmZ1bmN0aW9uIHVyblNlcmlhbGl6ZSAodXJuQ29tcG9uZW50LCBvcHRpb25zKSB7XG4gIGlmICh1cm5Db21wb25lbnQubmlkID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VSTiB3aXRob3V0IG5pZCBjYW5ub3QgYmUgc2VyaWFsaXplZCcpXG4gIH1cbiAgY29uc3Qgc2NoZW1lID0gb3B0aW9ucy5zY2hlbWUgfHwgdXJuQ29tcG9uZW50LnNjaGVtZSB8fCAndXJuJ1xuICBjb25zdCBuaWQgPSB1cm5Db21wb25lbnQubmlkLnRvTG93ZXJDYXNlKClcbiAgY29uc3QgdXJuU2NoZW1lID0gYCR7c2NoZW1lfToke29wdGlvbnMubmlkIHx8IG5pZH1gXG4gIGNvbnN0IHNjaGVtZUhhbmRsZXIgPSBnZXRTY2hlbWVIYW5kbGVyKHVyblNjaGVtZSlcblxuICBpZiAoc2NoZW1lSGFuZGxlcikge1xuICAgIHVybkNvbXBvbmVudCA9IHNjaGVtZUhhbmRsZXIuc2VyaWFsaXplKHVybkNvbXBvbmVudCwgb3B0aW9ucylcbiAgfVxuXG4gIGNvbnN0IHVyaUNvbXBvbmVudCA9IHVybkNvbXBvbmVudFxuICBjb25zdCBuc3MgPSB1cm5Db21wb25lbnQubnNzXG4gIHVyaUNvbXBvbmVudC5wYXRoID0gYCR7bmlkIHx8IG9wdGlvbnMubmlkfToke25zc31gXG5cbiAgb3B0aW9ucy5za2lwRXNjYXBlID0gdHJ1ZVxuICByZXR1cm4gdXJpQ29tcG9uZW50XG59XG5cbi8qKiBAdHlwZSB7U2NoZW1lRm59ICovXG5mdW5jdGlvbiB1cm51dWlkUGFyc2UgKHVybkNvbXBvbmVudCwgb3B0aW9ucykge1xuICBjb25zdCB1dWlkQ29tcG9uZW50ID0gdXJuQ29tcG9uZW50XG4gIHV1aWRDb21wb25lbnQudXVpZCA9IHV1aWRDb21wb25lbnQubnNzXG4gIHV1aWRDb21wb25lbnQubnNzID0gdW5kZWZpbmVkXG5cbiAgaWYgKCFvcHRpb25zLnRvbGVyYW50ICYmICghdXVpZENvbXBvbmVudC51dWlkIHx8ICFpc1VVSUQodXVpZENvbXBvbmVudC51dWlkKSkpIHtcbiAgICB1dWlkQ29tcG9uZW50LmVycm9yID0gdXVpZENvbXBvbmVudC5lcnJvciB8fCAnVVVJRCBpcyBub3QgdmFsaWQuJ1xuICB9XG5cbiAgcmV0dXJuIHV1aWRDb21wb25lbnRcbn1cblxuLyoqIEB0eXBlIHtTY2hlbWVGbn0gKi9cbmZ1bmN0aW9uIHVybnV1aWRTZXJpYWxpemUgKHV1aWRDb21wb25lbnQpIHtcbiAgY29uc3QgdXJuQ29tcG9uZW50ID0gdXVpZENvbXBvbmVudFxuICAvLyBub3JtYWxpemUgVVVJRFxuICB1cm5Db21wb25lbnQubnNzID0gKHV1aWRDb21wb25lbnQudXVpZCB8fCAnJykudG9Mb3dlckNhc2UoKVxuICByZXR1cm4gdXJuQ29tcG9uZW50XG59XG5cbmNvbnN0IGh0dHAgPSAvKiogQHR5cGUge1NjaGVtZUhhbmRsZXJ9ICovICh7XG4gIHNjaGVtZTogJ2h0dHAnLFxuICBkb21haW5Ib3N0OiB0cnVlLFxuICBwYXJzZTogaHR0cFBhcnNlLFxuICBzZXJpYWxpemU6IGh0dHBTZXJpYWxpemVcbn0pXG5cbmNvbnN0IGh0dHBzID0gLyoqIEB0eXBlIHtTY2hlbWVIYW5kbGVyfSAqLyAoe1xuICBzY2hlbWU6ICdodHRwcycsXG4gIGRvbWFpbkhvc3Q6IGh0dHAuZG9tYWluSG9zdCxcbiAgcGFyc2U6IGh0dHBQYXJzZSxcbiAgc2VyaWFsaXplOiBodHRwU2VyaWFsaXplXG59KVxuXG5jb25zdCB3cyA9IC8qKiBAdHlwZSB7U2NoZW1lSGFuZGxlcn0gKi8gKHtcbiAgc2NoZW1lOiAnd3MnLFxuICBkb21haW5Ib3N0OiB0cnVlLFxuICBwYXJzZTogd3NQYXJzZSxcbiAgc2VyaWFsaXplOiB3c1NlcmlhbGl6ZVxufSlcblxuY29uc3Qgd3NzID0gLyoqIEB0eXBlIHtTY2hlbWVIYW5kbGVyfSAqLyAoe1xuICBzY2hlbWU6ICd3c3MnLFxuICBkb21haW5Ib3N0OiB3cy5kb21haW5Ib3N0LFxuICBwYXJzZTogd3MucGFyc2UsXG4gIHNlcmlhbGl6ZTogd3Muc2VyaWFsaXplXG59KVxuXG5jb25zdCB1cm4gPSAvKiogQHR5cGUge1NjaGVtZUhhbmRsZXJ9ICovICh7XG4gIHNjaGVtZTogJ3VybicsXG4gIHBhcnNlOiB1cm5QYXJzZSxcbiAgc2VyaWFsaXplOiB1cm5TZXJpYWxpemUsXG4gIHNraXBOb3JtYWxpemU6IHRydWVcbn0pXG5cbmNvbnN0IHVybnV1aWQgPSAvKiogQHR5cGUge1NjaGVtZUhhbmRsZXJ9ICovICh7XG4gIHNjaGVtZTogJ3Vybjp1dWlkJyxcbiAgcGFyc2U6IHVybnV1aWRQYXJzZSxcbiAgc2VyaWFsaXplOiB1cm51dWlkU2VyaWFsaXplLFxuICBza2lwTm9ybWFsaXplOiB0cnVlXG59KVxuXG5jb25zdCBTQ0hFTUVTID0gLyoqIEB0eXBlIHtSZWNvcmQ8U2NoZW1lTmFtZSwgU2NoZW1lSGFuZGxlcj59ICovICh7XG4gIGh0dHAsXG4gIGh0dHBzLFxuICB3cyxcbiAgd3NzLFxuICB1cm4sXG4gICd1cm46dXVpZCc6IHVybnV1aWRcbn0pXG5cbk9iamVjdC5zZXRQcm90b3R5cGVPZihTQ0hFTUVTLCBudWxsKVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gc2NoZW1lXG4gKiBAcmV0dXJucyB7U2NoZW1lSGFuZGxlcnx1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIGdldFNjaGVtZUhhbmRsZXIgKHNjaGVtZSkge1xuICByZXR1cm4gKFxuICAgIHNjaGVtZSAmJiAoXG4gICAgICBTQ0hFTUVTWy8qKiBAdHlwZSB7U2NoZW1lTmFtZX0gKi8gKHNjaGVtZSldIHx8XG4gICAgICBTQ0hFTUVTWy8qKiBAdHlwZSB7U2NoZW1lTmFtZX0gKi8oc2NoZW1lLnRvTG93ZXJDYXNlKCkpXSlcbiAgKSB8fFxuICAgIHVuZGVmaW5lZFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgd3NJc1NlY3VyZSxcbiAgU0NIRU1FUyxcbiAgaXNWYWxpZFNjaGVtZU5hbWUsXG4gIGdldFNjaGVtZUhhbmRsZXIsXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgeyBub3JtYWxpemVJUHY2LCByZW1vdmVEb3RTZWdtZW50cywgcmVjb21wb3NlQXV0aG9yaXR5LCBub3JtYWxpemVDb21wb25lbnRFbmNvZGluZywgaXNJUHY0LCBub25TaW1wbGVEb21haW4gfSA9IHJlcXVpcmUoJy4vbGliL3V0aWxzJylcbmNvbnN0IHsgU0NIRU1FUywgZ2V0U2NoZW1lSGFuZGxlciB9ID0gcmVxdWlyZSgnLi9saWIvc2NoZW1lcycpXG5cbi8qKlxuICogQHRlbXBsYXRlIHtpbXBvcnQoJy4vdHlwZXMvaW5kZXgnKS5VUklDb21wb25lbnR8c3RyaW5nfSBUXG4gKiBAcGFyYW0ge1R9IHVyaVxuICogQHBhcmFtIHtpbXBvcnQoJy4vdHlwZXMvaW5kZXgnKS5PcHRpb25zfSBbb3B0aW9uc11cbiAqIEByZXR1cm5zIHtUfVxuICovXG5mdW5jdGlvbiBub3JtYWxpemUgKHVyaSwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHVyaSA9PT0gJ3N0cmluZycpIHtcbiAgICB1cmkgPSAvKiogQHR5cGUge1R9ICovIChzZXJpYWxpemUocGFyc2UodXJpLCBvcHRpb25zKSwgb3B0aW9ucykpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHVyaSA9PT0gJ29iamVjdCcpIHtcbiAgICB1cmkgPSAvKiogQHR5cGUge1R9ICovIChwYXJzZShzZXJpYWxpemUodXJpLCBvcHRpb25zKSwgb3B0aW9ucykpXG4gIH1cbiAgcmV0dXJuIHVyaVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJJXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVsYXRpdmVVUklcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3R5cGVzL2luZGV4JykuT3B0aW9uc30gW29wdGlvbnNdXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiByZXNvbHZlIChiYXNlVVJJLCByZWxhdGl2ZVVSSSwgb3B0aW9ucykge1xuICBjb25zdCBzY2hlbWVsZXNzT3B0aW9ucyA9IG9wdGlvbnMgPyBPYmplY3QuYXNzaWduKHsgc2NoZW1lOiAnbnVsbCcgfSwgb3B0aW9ucykgOiB7IHNjaGVtZTogJ251bGwnIH1cbiAgY29uc3QgcmVzb2x2ZWQgPSByZXNvbHZlQ29tcG9uZW50KHBhcnNlKGJhc2VVUkksIHNjaGVtZWxlc3NPcHRpb25zKSwgcGFyc2UocmVsYXRpdmVVUkksIHNjaGVtZWxlc3NPcHRpb25zKSwgc2NoZW1lbGVzc09wdGlvbnMsIHRydWUpXG4gIHNjaGVtZWxlc3NPcHRpb25zLnNraXBFc2NhcGUgPSB0cnVlXG4gIHJldHVybiBzZXJpYWxpemUocmVzb2x2ZWQsIHNjaGVtZWxlc3NPcHRpb25zKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0ICgnLi90eXBlcy9pbmRleCcpLlVSSUNvbXBvbmVudH0gYmFzZVxuICogQHBhcmFtIHtpbXBvcnQgKCcuL3R5cGVzL2luZGV4JykuVVJJQ29tcG9uZW50fSByZWxhdGl2ZVxuICogQHBhcmFtIHtpbXBvcnQoJy4vdHlwZXMvaW5kZXgnKS5PcHRpb25zfSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NraXBOb3JtYWxpemF0aW9uPWZhbHNlXVxuICogQHJldHVybnMge2ltcG9ydCAoJy4vdHlwZXMvaW5kZXgnKS5VUklDb21wb25lbnR9XG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVDb21wb25lbnQgKGJhc2UsIHJlbGF0aXZlLCBvcHRpb25zLCBza2lwTm9ybWFsaXphdGlvbikge1xuICAvKiogQHR5cGUge2ltcG9ydCgnLi90eXBlcy9pbmRleCcpLlVSSUNvbXBvbmVudH0gKi9cbiAgY29uc3QgdGFyZ2V0ID0ge31cbiAgaWYgKCFza2lwTm9ybWFsaXphdGlvbikge1xuICAgIGJhc2UgPSBwYXJzZShzZXJpYWxpemUoYmFzZSwgb3B0aW9ucyksIG9wdGlvbnMpIC8vIG5vcm1hbGl6ZSBiYXNlIGNvbXBvbmVudFxuICAgIHJlbGF0aXZlID0gcGFyc2Uoc2VyaWFsaXplKHJlbGF0aXZlLCBvcHRpb25zKSwgb3B0aW9ucykgLy8gbm9ybWFsaXplIHJlbGF0aXZlIGNvbXBvbmVudFxuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgaWYgKCFvcHRpb25zLnRvbGVyYW50ICYmIHJlbGF0aXZlLnNjaGVtZSkge1xuICAgIHRhcmdldC5zY2hlbWUgPSByZWxhdGl2ZS5zY2hlbWVcbiAgICAvLyB0YXJnZXQuYXV0aG9yaXR5ID0gcmVsYXRpdmUuYXV0aG9yaXR5O1xuICAgIHRhcmdldC51c2VyaW5mbyA9IHJlbGF0aXZlLnVzZXJpbmZvXG4gICAgdGFyZ2V0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0XG4gICAgdGFyZ2V0LnBvcnQgPSByZWxhdGl2ZS5wb3J0XG4gICAgdGFyZ2V0LnBhdGggPSByZW1vdmVEb3RTZWdtZW50cyhyZWxhdGl2ZS5wYXRoIHx8ICcnKVxuICAgIHRhcmdldC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5XG4gIH0gZWxzZSB7XG4gICAgaWYgKHJlbGF0aXZlLnVzZXJpbmZvICE9PSB1bmRlZmluZWQgfHwgcmVsYXRpdmUuaG9zdCAhPT0gdW5kZWZpbmVkIHx8IHJlbGF0aXZlLnBvcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gdGFyZ2V0LmF1dGhvcml0eSA9IHJlbGF0aXZlLmF1dGhvcml0eTtcbiAgICAgIHRhcmdldC51c2VyaW5mbyA9IHJlbGF0aXZlLnVzZXJpbmZvXG4gICAgICB0YXJnZXQuaG9zdCA9IHJlbGF0aXZlLmhvc3RcbiAgICAgIHRhcmdldC5wb3J0ID0gcmVsYXRpdmUucG9ydFxuICAgICAgdGFyZ2V0LnBhdGggPSByZW1vdmVEb3RTZWdtZW50cyhyZWxhdGl2ZS5wYXRoIHx8ICcnKVxuICAgICAgdGFyZ2V0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnlcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFyZWxhdGl2ZS5wYXRoKSB7XG4gICAgICAgIHRhcmdldC5wYXRoID0gYmFzZS5wYXRoXG4gICAgICAgIGlmIChyZWxhdGl2ZS5xdWVyeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGFyZ2V0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXQucXVlcnkgPSBiYXNlLnF1ZXJ5XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChyZWxhdGl2ZS5wYXRoWzBdID09PSAnLycpIHtcbiAgICAgICAgICB0YXJnZXQucGF0aCA9IHJlbW92ZURvdFNlZ21lbnRzKHJlbGF0aXZlLnBhdGgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKChiYXNlLnVzZXJpbmZvICE9PSB1bmRlZmluZWQgfHwgYmFzZS5ob3N0ICE9PSB1bmRlZmluZWQgfHwgYmFzZS5wb3J0ICE9PSB1bmRlZmluZWQpICYmICFiYXNlLnBhdGgpIHtcbiAgICAgICAgICAgIHRhcmdldC5wYXRoID0gJy8nICsgcmVsYXRpdmUucGF0aFxuICAgICAgICAgIH0gZWxzZSBpZiAoIWJhc2UucGF0aCkge1xuICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSByZWxhdGl2ZS5wYXRoXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldC5wYXRoID0gYmFzZS5wYXRoLnNsaWNlKDAsIGJhc2UucGF0aC5sYXN0SW5kZXhPZignLycpICsgMSkgKyByZWxhdGl2ZS5wYXRoXG4gICAgICAgICAgfVxuICAgICAgICAgIHRhcmdldC5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHModGFyZ2V0LnBhdGgpXG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnlcbiAgICAgIH1cbiAgICAgIC8vIHRhcmdldC5hdXRob3JpdHkgPSBiYXNlLmF1dGhvcml0eTtcbiAgICAgIHRhcmdldC51c2VyaW5mbyA9IGJhc2UudXNlcmluZm9cbiAgICAgIHRhcmdldC5ob3N0ID0gYmFzZS5ob3N0XG4gICAgICB0YXJnZXQucG9ydCA9IGJhc2UucG9ydFxuICAgIH1cbiAgICB0YXJnZXQuc2NoZW1lID0gYmFzZS5zY2hlbWVcbiAgfVxuXG4gIHRhcmdldC5mcmFnbWVudCA9IHJlbGF0aXZlLmZyYWdtZW50XG5cbiAgcmV0dXJuIHRhcmdldFxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0ICgnLi90eXBlcy9pbmRleCcpLlVSSUNvbXBvbmVudHxzdHJpbmd9IHVyaUFcbiAqIEBwYXJhbSB7aW1wb3J0ICgnLi90eXBlcy9pbmRleCcpLlVSSUNvbXBvbmVudHxzdHJpbmd9IHVyaUJcbiAqIEBwYXJhbSB7aW1wb3J0ICgnLi90eXBlcy9pbmRleCcpLk9wdGlvbnN9IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBlcXVhbCAodXJpQSwgdXJpQiwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHVyaUEgPT09ICdzdHJpbmcnKSB7XG4gICAgdXJpQSA9IHVuZXNjYXBlKHVyaUEpXG4gICAgdXJpQSA9IHNlcmlhbGl6ZShub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyhwYXJzZSh1cmlBLCBvcHRpb25zKSwgdHJ1ZSksIHsgLi4ub3B0aW9ucywgc2tpcEVzY2FwZTogdHJ1ZSB9KVxuICB9IGVsc2UgaWYgKHR5cGVvZiB1cmlBID09PSAnb2JqZWN0Jykge1xuICAgIHVyaUEgPSBzZXJpYWxpemUobm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcodXJpQSwgdHJ1ZSksIHsgLi4ub3B0aW9ucywgc2tpcEVzY2FwZTogdHJ1ZSB9KVxuICB9XG5cbiAgaWYgKHR5cGVvZiB1cmlCID09PSAnc3RyaW5nJykge1xuICAgIHVyaUIgPSB1bmVzY2FwZSh1cmlCKVxuICAgIHVyaUIgPSBzZXJpYWxpemUobm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcocGFyc2UodXJpQiwgb3B0aW9ucyksIHRydWUpLCB7IC4uLm9wdGlvbnMsIHNraXBFc2NhcGU6IHRydWUgfSlcbiAgfSBlbHNlIGlmICh0eXBlb2YgdXJpQiA9PT0gJ29iamVjdCcpIHtcbiAgICB1cmlCID0gc2VyaWFsaXplKG5vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nKHVyaUIsIHRydWUpLCB7IC4uLm9wdGlvbnMsIHNraXBFc2NhcGU6IHRydWUgfSlcbiAgfVxuXG4gIHJldHVybiB1cmlBLnRvTG93ZXJDYXNlKCkgPT09IHVyaUIudG9Mb3dlckNhc2UoKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVhZG9ubHk8aW1wb3J0KCcuL3R5cGVzL2luZGV4JykuVVJJQ29tcG9uZW50Pn0gY21wdHNcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3R5cGVzL2luZGV4JykuT3B0aW9uc30gW29wdHNdXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBzZXJpYWxpemUgKGNtcHRzLCBvcHRzKSB7XG4gIGNvbnN0IGNvbXBvbmVudCA9IHtcbiAgICBob3N0OiBjbXB0cy5ob3N0LFxuICAgIHNjaGVtZTogY21wdHMuc2NoZW1lLFxuICAgIHVzZXJpbmZvOiBjbXB0cy51c2VyaW5mbyxcbiAgICBwb3J0OiBjbXB0cy5wb3J0LFxuICAgIHBhdGg6IGNtcHRzLnBhdGgsXG4gICAgcXVlcnk6IGNtcHRzLnF1ZXJ5LFxuICAgIG5pZDogY21wdHMubmlkLFxuICAgIG5zczogY21wdHMubnNzLFxuICAgIHV1aWQ6IGNtcHRzLnV1aWQsXG4gICAgZnJhZ21lbnQ6IGNtcHRzLmZyYWdtZW50LFxuICAgIHJlZmVyZW5jZTogY21wdHMucmVmZXJlbmNlLFxuICAgIHJlc291cmNlTmFtZTogY21wdHMucmVzb3VyY2VOYW1lLFxuICAgIHNlY3VyZTogY21wdHMuc2VjdXJlLFxuICAgIGVycm9yOiAnJ1xuICB9XG4gIGNvbnN0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRzKVxuICBjb25zdCB1cmlUb2tlbnMgPSBbXVxuXG4gIC8vIGZpbmQgc2NoZW1lIGhhbmRsZXJcbiAgY29uc3Qgc2NoZW1lSGFuZGxlciA9IGdldFNjaGVtZUhhbmRsZXIob3B0aW9ucy5zY2hlbWUgfHwgY29tcG9uZW50LnNjaGVtZSlcblxuICAvLyBwZXJmb3JtIHNjaGVtZSBzcGVjaWZpYyBzZXJpYWxpemF0aW9uXG4gIGlmIChzY2hlbWVIYW5kbGVyICYmIHNjaGVtZUhhbmRsZXIuc2VyaWFsaXplKSBzY2hlbWVIYW5kbGVyLnNlcmlhbGl6ZShjb21wb25lbnQsIG9wdGlvbnMpXG5cbiAgaWYgKGNvbXBvbmVudC5wYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoIW9wdGlvbnMuc2tpcEVzY2FwZSkge1xuICAgICAgY29tcG9uZW50LnBhdGggPSBlc2NhcGUoY29tcG9uZW50LnBhdGgpXG5cbiAgICAgIGlmIChjb21wb25lbnQuc2NoZW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29tcG9uZW50LnBhdGggPSBjb21wb25lbnQucGF0aC5zcGxpdCgnJTNBJykuam9pbignOicpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXBvbmVudC5wYXRoID0gdW5lc2NhcGUoY29tcG9uZW50LnBhdGgpXG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdGlvbnMucmVmZXJlbmNlICE9PSAnc3VmZml4JyAmJiBjb21wb25lbnQuc2NoZW1lKSB7XG4gICAgdXJpVG9rZW5zLnB1c2goY29tcG9uZW50LnNjaGVtZSwgJzonKVxuICB9XG5cbiAgY29uc3QgYXV0aG9yaXR5ID0gcmVjb21wb3NlQXV0aG9yaXR5KGNvbXBvbmVudClcbiAgaWYgKGF1dGhvcml0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKG9wdGlvbnMucmVmZXJlbmNlICE9PSAnc3VmZml4Jykge1xuICAgICAgdXJpVG9rZW5zLnB1c2goJy8vJylcbiAgICB9XG5cbiAgICB1cmlUb2tlbnMucHVzaChhdXRob3JpdHkpXG5cbiAgICBpZiAoY29tcG9uZW50LnBhdGggJiYgY29tcG9uZW50LnBhdGhbMF0gIT09ICcvJykge1xuICAgICAgdXJpVG9rZW5zLnB1c2goJy8nKVxuICAgIH1cbiAgfVxuICBpZiAoY29tcG9uZW50LnBhdGggIT09IHVuZGVmaW5lZCkge1xuICAgIGxldCBzID0gY29tcG9uZW50LnBhdGhcblxuICAgIGlmICghb3B0aW9ucy5hYnNvbHV0ZVBhdGggJiYgKCFzY2hlbWVIYW5kbGVyIHx8ICFzY2hlbWVIYW5kbGVyLmFic29sdXRlUGF0aCkpIHtcbiAgICAgIHMgPSByZW1vdmVEb3RTZWdtZW50cyhzKVxuICAgIH1cblxuICAgIGlmIChcbiAgICAgIGF1dGhvcml0eSA9PT0gdW5kZWZpbmVkICYmXG4gICAgICBzWzBdID09PSAnLycgJiZcbiAgICAgIHNbMV0gPT09ICcvJ1xuICAgICkge1xuICAgICAgLy8gZG9uJ3QgYWxsb3cgdGhlIHBhdGggdG8gc3RhcnQgd2l0aCBcIi8vXCJcbiAgICAgIHMgPSAnLyUyRicgKyBzLnNsaWNlKDIpXG4gICAgfVxuXG4gICAgdXJpVG9rZW5zLnB1c2gocylcbiAgfVxuXG4gIGlmIChjb21wb25lbnQucXVlcnkgIT09IHVuZGVmaW5lZCkge1xuICAgIHVyaVRva2Vucy5wdXNoKCc/JywgY29tcG9uZW50LnF1ZXJ5KVxuICB9XG5cbiAgaWYgKGNvbXBvbmVudC5mcmFnbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdXJpVG9rZW5zLnB1c2goJyMnLCBjb21wb25lbnQuZnJhZ21lbnQpXG4gIH1cbiAgcmV0dXJuIHVyaVRva2Vucy5qb2luKCcnKVxufVxuXG5jb25zdCBVUklfUEFSU0UgPSAvXig/OihbXiMvOj9dKyk6KT8oPzpcXC9cXC8oKD86KFteIy8/QF0qKUApPyhcXFtbXiMvP1xcXV0rXFxdfFteIy86P10qKSg/OjooXFxkKikpPykpPyhbXiM/XSopKD86XFw/KFteI10qKSk/KD86IygoPzoufFtcXG5cXHJdKSopKT8vdVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmlcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3R5cGVzL2luZGV4JykuT3B0aW9uc30gW29wdHNdXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBwYXJzZSAodXJpLCBvcHRzKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRzKVxuICAvKiogQHR5cGUge2ltcG9ydCgnLi90eXBlcy9pbmRleCcpLlVSSUNvbXBvbmVudH0gKi9cbiAgY29uc3QgcGFyc2VkID0ge1xuICAgIHNjaGVtZTogdW5kZWZpbmVkLFxuICAgIHVzZXJpbmZvOiB1bmRlZmluZWQsXG4gICAgaG9zdDogJycsXG4gICAgcG9ydDogdW5kZWZpbmVkLFxuICAgIHBhdGg6ICcnLFxuICAgIHF1ZXJ5OiB1bmRlZmluZWQsXG4gICAgZnJhZ21lbnQ6IHVuZGVmaW5lZFxuICB9XG5cbiAgbGV0IGlzSVAgPSBmYWxzZVxuICBpZiAob3B0aW9ucy5yZWZlcmVuY2UgPT09ICdzdWZmaXgnKSB7XG4gICAgaWYgKG9wdGlvbnMuc2NoZW1lKSB7XG4gICAgICB1cmkgPSBvcHRpb25zLnNjaGVtZSArICc6JyArIHVyaVxuICAgIH0gZWxzZSB7XG4gICAgICB1cmkgPSAnLy8nICsgdXJpXG4gICAgfVxuICB9XG5cbiAgY29uc3QgbWF0Y2hlcyA9IHVyaS5tYXRjaChVUklfUEFSU0UpXG5cbiAgaWYgKG1hdGNoZXMpIHtcbiAgICAvLyBzdG9yZSBlYWNoIGNvbXBvbmVudFxuICAgIHBhcnNlZC5zY2hlbWUgPSBtYXRjaGVzWzFdXG4gICAgcGFyc2VkLnVzZXJpbmZvID0gbWF0Y2hlc1szXVxuICAgIHBhcnNlZC5ob3N0ID0gbWF0Y2hlc1s0XVxuICAgIHBhcnNlZC5wb3J0ID0gcGFyc2VJbnQobWF0Y2hlc1s1XSwgMTApXG4gICAgcGFyc2VkLnBhdGggPSBtYXRjaGVzWzZdIHx8ICcnXG4gICAgcGFyc2VkLnF1ZXJ5ID0gbWF0Y2hlc1s3XVxuICAgIHBhcnNlZC5mcmFnbWVudCA9IG1hdGNoZXNbOF1cblxuICAgIC8vIGZpeCBwb3J0IG51bWJlclxuICAgIGlmIChpc05hTihwYXJzZWQucG9ydCkpIHtcbiAgICAgIHBhcnNlZC5wb3J0ID0gbWF0Y2hlc1s1XVxuICAgIH1cbiAgICBpZiAocGFyc2VkLmhvc3QpIHtcbiAgICAgIGNvbnN0IGlwdjRyZXN1bHQgPSBpc0lQdjQocGFyc2VkLmhvc3QpXG4gICAgICBpZiAoaXB2NHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgaXB2NnJlc3VsdCA9IG5vcm1hbGl6ZUlQdjYocGFyc2VkLmhvc3QpXG4gICAgICAgIHBhcnNlZC5ob3N0ID0gaXB2NnJlc3VsdC5ob3N0LnRvTG93ZXJDYXNlKClcbiAgICAgICAgaXNJUCA9IGlwdjZyZXN1bHQuaXNJUFY2XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpc0lQID0gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAocGFyc2VkLnNjaGVtZSA9PT0gdW5kZWZpbmVkICYmIHBhcnNlZC51c2VyaW5mbyA9PT0gdW5kZWZpbmVkICYmIHBhcnNlZC5ob3N0ID09PSB1bmRlZmluZWQgJiYgcGFyc2VkLnBvcnQgPT09IHVuZGVmaW5lZCAmJiBwYXJzZWQucXVlcnkgPT09IHVuZGVmaW5lZCAmJiAhcGFyc2VkLnBhdGgpIHtcbiAgICAgIHBhcnNlZC5yZWZlcmVuY2UgPSAnc2FtZS1kb2N1bWVudCdcbiAgICB9IGVsc2UgaWYgKHBhcnNlZC5zY2hlbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcGFyc2VkLnJlZmVyZW5jZSA9ICdyZWxhdGl2ZSdcbiAgICB9IGVsc2UgaWYgKHBhcnNlZC5mcmFnbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBwYXJzZWQucmVmZXJlbmNlID0gJ2Fic29sdXRlJ1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJzZWQucmVmZXJlbmNlID0gJ3VyaSdcbiAgICB9XG5cbiAgICAvLyBjaGVjayBmb3IgcmVmZXJlbmNlIGVycm9yc1xuICAgIGlmIChvcHRpb25zLnJlZmVyZW5jZSAmJiBvcHRpb25zLnJlZmVyZW5jZSAhPT0gJ3N1ZmZpeCcgJiYgb3B0aW9ucy5yZWZlcmVuY2UgIT09IHBhcnNlZC5yZWZlcmVuY2UpIHtcbiAgICAgIHBhcnNlZC5lcnJvciA9IHBhcnNlZC5lcnJvciB8fCAnVVJJIGlzIG5vdCBhICcgKyBvcHRpb25zLnJlZmVyZW5jZSArICcgcmVmZXJlbmNlLidcbiAgICB9XG5cbiAgICAvLyBmaW5kIHNjaGVtZSBoYW5kbGVyXG4gICAgY29uc3Qgc2NoZW1lSGFuZGxlciA9IGdldFNjaGVtZUhhbmRsZXIob3B0aW9ucy5zY2hlbWUgfHwgcGFyc2VkLnNjaGVtZSlcblxuICAgIC8vIGNoZWNrIGlmIHNjaGVtZSBjYW4ndCBoYW5kbGUgSVJJc1xuICAgIGlmICghb3B0aW9ucy51bmljb2RlU3VwcG9ydCAmJiAoIXNjaGVtZUhhbmRsZXIgfHwgIXNjaGVtZUhhbmRsZXIudW5pY29kZVN1cHBvcnQpKSB7XG4gICAgICAvLyBpZiBob3N0IGNvbXBvbmVudCBpcyBhIGRvbWFpbiBuYW1lXG4gICAgICBpZiAocGFyc2VkLmhvc3QgJiYgKG9wdGlvbnMuZG9tYWluSG9zdCB8fCAoc2NoZW1lSGFuZGxlciAmJiBzY2hlbWVIYW5kbGVyLmRvbWFpbkhvc3QpKSAmJiBpc0lQID09PSBmYWxzZSAmJiBub25TaW1wbGVEb21haW4ocGFyc2VkLmhvc3QpKSB7XG4gICAgICAgIC8vIGNvbnZlcnQgVW5pY29kZSBJRE4gLT4gQVNDSUkgSUROXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcGFyc2VkLmhvc3QgPSBVUkwuZG9tYWluVG9BU0NJSShwYXJzZWQuaG9zdC50b0xvd2VyQ2FzZSgpKVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcGFyc2VkLmVycm9yID0gcGFyc2VkLmVycm9yIHx8IFwiSG9zdCdzIGRvbWFpbiBuYW1lIGNhbiBub3QgYmUgY29udmVydGVkIHRvIEFTQ0lJOiBcIiArIGVcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gY29udmVydCBJUkkgLT4gVVJJXG4gICAgfVxuXG4gICAgaWYgKCFzY2hlbWVIYW5kbGVyIHx8IChzY2hlbWVIYW5kbGVyICYmICFzY2hlbWVIYW5kbGVyLnNraXBOb3JtYWxpemUpKSB7XG4gICAgICBpZiAodXJpLmluZGV4T2YoJyUnKSAhPT0gLTEpIHtcbiAgICAgICAgaWYgKHBhcnNlZC5zY2hlbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHBhcnNlZC5zY2hlbWUgPSB1bmVzY2FwZShwYXJzZWQuc2NoZW1lKVxuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJzZWQuaG9zdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcGFyc2VkLmhvc3QgPSB1bmVzY2FwZShwYXJzZWQuaG9zdClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBhcnNlZC5wYXRoKSB7XG4gICAgICAgIHBhcnNlZC5wYXRoID0gZXNjYXBlKHVuZXNjYXBlKHBhcnNlZC5wYXRoKSlcbiAgICAgIH1cbiAgICAgIGlmIChwYXJzZWQuZnJhZ21lbnQpIHtcbiAgICAgICAgcGFyc2VkLmZyYWdtZW50ID0gZW5jb2RlVVJJKGRlY29kZVVSSUNvbXBvbmVudChwYXJzZWQuZnJhZ21lbnQpKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHBlcmZvcm0gc2NoZW1lIHNwZWNpZmljIHBhcnNpbmdcbiAgICBpZiAoc2NoZW1lSGFuZGxlciAmJiBzY2hlbWVIYW5kbGVyLnBhcnNlKSB7XG4gICAgICBzY2hlbWVIYW5kbGVyLnBhcnNlKHBhcnNlZCwgb3B0aW9ucylcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcGFyc2VkLmVycm9yID0gcGFyc2VkLmVycm9yIHx8ICdVUkkgY2FuIG5vdCBiZSBwYXJzZWQuJ1xuICB9XG4gIHJldHVybiBwYXJzZWRcbn1cblxuY29uc3QgZmFzdFVyaSA9IHtcbiAgU0NIRU1FUyxcbiAgbm9ybWFsaXplLFxuICByZXNvbHZlLFxuICByZXNvbHZlQ29tcG9uZW50LFxuICBlcXVhbCxcbiAgc2VyaWFsaXplLFxuICBwYXJzZVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZhc3RVcmlcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBmYXN0VXJpXG5tb2R1bGUuZXhwb3J0cy5mYXN0VXJpID0gZmFzdFVyaVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB1cmkgPSByZXF1aXJlKFwiZmFzdC11cmlcIik7XG51cmkuY29kZSA9ICdyZXF1aXJlKFwiYWp2L2Rpc3QvcnVudGltZS91cmlcIikuZGVmYXVsdCc7XG5leHBvcnRzLmRlZmF1bHQgPSB1cmk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11cmkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvZGVHZW4gPSBleHBvcnRzLk5hbWUgPSBleHBvcnRzLm5pbCA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gZXhwb3J0cy5zdHIgPSBleHBvcnRzLl8gPSBleHBvcnRzLktleXdvcmRDeHQgPSB2b2lkIDA7XG52YXIgdmFsaWRhdGVfMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvdmFsaWRhdGVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJLZXl3b3JkQ3h0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB2YWxpZGF0ZV8xLktleXdvcmRDeHQ7IH0gfSk7XG52YXIgY29kZWdlbl8xID0gcmVxdWlyZShcIi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLl87IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdHJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVnZW5fMS5zdHI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdHJpbmdpZnlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVnZW5fMS5zdHJpbmdpZnk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJuaWxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVnZW5fMS5uaWw7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOYW1lXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuTmFtZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvZGVHZW5cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVnZW5fMS5Db2RlR2VuOyB9IH0pO1xuY29uc3QgdmFsaWRhdGlvbl9lcnJvcl8xID0gcmVxdWlyZShcIi4vcnVudGltZS92YWxpZGF0aW9uX2Vycm9yXCIpO1xuY29uc3QgcmVmX2Vycm9yXzEgPSByZXF1aXJlKFwiLi9jb21waWxlL3JlZl9lcnJvclwiKTtcbmNvbnN0IHJ1bGVzXzEgPSByZXF1aXJlKFwiLi9jb21waWxlL3J1bGVzXCIpO1xuY29uc3QgY29tcGlsZV8xID0gcmVxdWlyZShcIi4vY29tcGlsZVwiKTtcbmNvbnN0IGNvZGVnZW5fMiA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHJlc29sdmVfMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvcmVzb2x2ZVwiKTtcbmNvbnN0IGRhdGFUeXBlXzEgPSByZXF1aXJlKFwiLi9jb21waWxlL3ZhbGlkYXRlL2RhdGFUeXBlXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgJGRhdGFSZWZTY2hlbWEgPSByZXF1aXJlKFwiLi9yZWZzL2RhdGEuanNvblwiKTtcbmNvbnN0IHVyaV8xID0gcmVxdWlyZShcIi4vcnVudGltZS91cmlcIik7XG5jb25zdCBkZWZhdWx0UmVnRXhwID0gKHN0ciwgZmxhZ3MpID0+IG5ldyBSZWdFeHAoc3RyLCBmbGFncyk7XG5kZWZhdWx0UmVnRXhwLmNvZGUgPSBcIm5ldyBSZWdFeHBcIjtcbmNvbnN0IE1FVEFfSUdOT1JFX09QVElPTlMgPSBbXCJyZW1vdmVBZGRpdGlvbmFsXCIsIFwidXNlRGVmYXVsdHNcIiwgXCJjb2VyY2VUeXBlc1wiXTtcbmNvbnN0IEVYVF9TQ09QRV9OQU1FUyA9IG5ldyBTZXQoW1xuICAgIFwidmFsaWRhdGVcIixcbiAgICBcInNlcmlhbGl6ZVwiLFxuICAgIFwicGFyc2VcIixcbiAgICBcIndyYXBwZXJcIixcbiAgICBcInJvb3RcIixcbiAgICBcInNjaGVtYVwiLFxuICAgIFwia2V5d29yZFwiLFxuICAgIFwicGF0dGVyblwiLFxuICAgIFwiZm9ybWF0c1wiLFxuICAgIFwidmFsaWRhdGUkZGF0YVwiLFxuICAgIFwiZnVuY1wiLFxuICAgIFwib2JqXCIsXG4gICAgXCJFcnJvclwiLFxuXSk7XG5jb25zdCByZW1vdmVkT3B0aW9ucyA9IHtcbiAgICBlcnJvckRhdGFQYXRoOiBcIlwiLFxuICAgIGZvcm1hdDogXCJgdmFsaWRhdGVGb3JtYXRzOiBmYWxzZWAgY2FuIGJlIHVzZWQgaW5zdGVhZC5cIixcbiAgICBudWxsYWJsZTogJ1wibnVsbGFibGVcIiBrZXl3b3JkIGlzIHN1cHBvcnRlZCBieSBkZWZhdWx0LicsXG4gICAganNvblBvaW50ZXJzOiBcIkRlcHJlY2F0ZWQganNQcm9wZXJ0eVN5bnRheCBjYW4gYmUgdXNlZCBpbnN0ZWFkLlwiLFxuICAgIGV4dGVuZFJlZnM6IFwiRGVwcmVjYXRlZCBpZ25vcmVLZXl3b3Jkc1dpdGhSZWYgY2FuIGJlIHVzZWQgaW5zdGVhZC5cIixcbiAgICBtaXNzaW5nUmVmczogXCJQYXNzIGVtcHR5IHNjaGVtYSB3aXRoICRpZCB0aGF0IHNob3VsZCBiZSBpZ25vcmVkIHRvIGFqdi5hZGRTY2hlbWEuXCIsXG4gICAgcHJvY2Vzc0NvZGU6IFwiVXNlIG9wdGlvbiBgY29kZToge3Byb2Nlc3M6IChjb2RlLCBzY2hlbWFFbnY6IG9iamVjdCkgPT4gc3RyaW5nfWBcIixcbiAgICBzb3VyY2VDb2RlOiBcIlVzZSBvcHRpb24gYGNvZGU6IHtzb3VyY2U6IHRydWV9YFwiLFxuICAgIHN0cmljdERlZmF1bHRzOiBcIkl0IGlzIGRlZmF1bHQgbm93LCBzZWUgb3B0aW9uIGBzdHJpY3RgLlwiLFxuICAgIHN0cmljdEtleXdvcmRzOiBcIkl0IGlzIGRlZmF1bHQgbm93LCBzZWUgb3B0aW9uIGBzdHJpY3RgLlwiLFxuICAgIHVuaXF1ZUl0ZW1zOiAnXCJ1bmlxdWVJdGVtc1wiIGtleXdvcmQgaXMgYWx3YXlzIHZhbGlkYXRlZC4nLFxuICAgIHVua25vd25Gb3JtYXRzOiBcIkRpc2FibGUgc3RyaWN0IG1vZGUgb3IgcGFzcyBgdHJ1ZWAgdG8gYGFqdi5hZGRGb3JtYXRgIChvciBgZm9ybWF0c2Agb3B0aW9uKS5cIixcbiAgICBjYWNoZTogXCJNYXAgaXMgdXNlZCBhcyBjYWNoZSwgc2NoZW1hIG9iamVjdCBhcyBrZXkuXCIsXG4gICAgc2VyaWFsaXplOiBcIk1hcCBpcyB1c2VkIGFzIGNhY2hlLCBzY2hlbWEgb2JqZWN0IGFzIGtleS5cIixcbiAgICBhanZFcnJvcnM6IFwiSXQgaXMgZGVmYXVsdCBub3cuXCIsXG59O1xuY29uc3QgZGVwcmVjYXRlZE9wdGlvbnMgPSB7XG4gICAgaWdub3JlS2V5d29yZHNXaXRoUmVmOiBcIlwiLFxuICAgIGpzUHJvcGVydHlTeW50YXg6IFwiXCIsXG4gICAgdW5pY29kZTogJ1wibWluTGVuZ3RoXCIvXCJtYXhMZW5ndGhcIiBhY2NvdW50IGZvciB1bmljb2RlIGNoYXJhY3RlcnMgYnkgZGVmYXVsdC4nLFxufTtcbmNvbnN0IE1BWF9FWFBSRVNTSU9OID0gMjAwO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmZ1bmN0aW9uIHJlcXVpcmVkT3B0aW9ucyhvKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2osIF9rLCBfbCwgX20sIF9vLCBfcCwgX3EsIF9yLCBfcywgX3QsIF91LCBfdiwgX3csIF94LCBfeSwgX3osIF8wO1xuICAgIGNvbnN0IHMgPSBvLnN0cmljdDtcbiAgICBjb25zdCBfb3B0eiA9IChfYSA9IG8uY29kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9wdGltaXplO1xuICAgIGNvbnN0IG9wdGltaXplID0gX29wdHogPT09IHRydWUgfHwgX29wdHogPT09IHVuZGVmaW5lZCA/IDEgOiBfb3B0eiB8fCAwO1xuICAgIGNvbnN0IHJlZ0V4cCA9IChfYyA9IChfYiA9IG8uY29kZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnJlZ0V4cCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogZGVmYXVsdFJlZ0V4cDtcbiAgICBjb25zdCB1cmlSZXNvbHZlciA9IChfZCA9IG8udXJpUmVzb2x2ZXIpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHVyaV8xLmRlZmF1bHQ7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RyaWN0U2NoZW1hOiAoX2YgPSAoX2UgPSBvLnN0cmljdFNjaGVtYSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogcykgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogdHJ1ZSxcbiAgICAgICAgc3RyaWN0TnVtYmVyczogKF9oID0gKF9nID0gby5zdHJpY3ROdW1iZXJzKSAhPT0gbnVsbCAmJiBfZyAhPT0gdm9pZCAwID8gX2cgOiBzKSAhPT0gbnVsbCAmJiBfaCAhPT0gdm9pZCAwID8gX2ggOiB0cnVlLFxuICAgICAgICBzdHJpY3RUeXBlczogKF9rID0gKF9qID0gby5zdHJpY3RUeXBlcykgIT09IG51bGwgJiYgX2ogIT09IHZvaWQgMCA/IF9qIDogcykgIT09IG51bGwgJiYgX2sgIT09IHZvaWQgMCA/IF9rIDogXCJsb2dcIixcbiAgICAgICAgc3RyaWN0VHVwbGVzOiAoX20gPSAoX2wgPSBvLnN0cmljdFR1cGxlcykgIT09IG51bGwgJiYgX2wgIT09IHZvaWQgMCA/IF9sIDogcykgIT09IG51bGwgJiYgX20gIT09IHZvaWQgMCA/IF9tIDogXCJsb2dcIixcbiAgICAgICAgc3RyaWN0UmVxdWlyZWQ6IChfcCA9IChfbyA9IG8uc3RyaWN0UmVxdWlyZWQpICE9PSBudWxsICYmIF9vICE9PSB2b2lkIDAgPyBfbyA6IHMpICE9PSBudWxsICYmIF9wICE9PSB2b2lkIDAgPyBfcCA6IGZhbHNlLFxuICAgICAgICBjb2RlOiBvLmNvZGUgPyB7IC4uLm8uY29kZSwgb3B0aW1pemUsIHJlZ0V4cCB9IDogeyBvcHRpbWl6ZSwgcmVnRXhwIH0sXG4gICAgICAgIGxvb3BSZXF1aXJlZDogKF9xID0gby5sb29wUmVxdWlyZWQpICE9PSBudWxsICYmIF9xICE9PSB2b2lkIDAgPyBfcSA6IE1BWF9FWFBSRVNTSU9OLFxuICAgICAgICBsb29wRW51bTogKF9yID0gby5sb29wRW51bSkgIT09IG51bGwgJiYgX3IgIT09IHZvaWQgMCA/IF9yIDogTUFYX0VYUFJFU1NJT04sXG4gICAgICAgIG1ldGE6IChfcyA9IG8ubWV0YSkgIT09IG51bGwgJiYgX3MgIT09IHZvaWQgMCA/IF9zIDogdHJ1ZSxcbiAgICAgICAgbWVzc2FnZXM6IChfdCA9IG8ubWVzc2FnZXMpICE9PSBudWxsICYmIF90ICE9PSB2b2lkIDAgPyBfdCA6IHRydWUsXG4gICAgICAgIGlubGluZVJlZnM6IChfdSA9IG8uaW5saW5lUmVmcykgIT09IG51bGwgJiYgX3UgIT09IHZvaWQgMCA/IF91IDogdHJ1ZSxcbiAgICAgICAgc2NoZW1hSWQ6IChfdiA9IG8uc2NoZW1hSWQpICE9PSBudWxsICYmIF92ICE9PSB2b2lkIDAgPyBfdiA6IFwiJGlkXCIsXG4gICAgICAgIGFkZFVzZWRTY2hlbWE6IChfdyA9IG8uYWRkVXNlZFNjaGVtYSkgIT09IG51bGwgJiYgX3cgIT09IHZvaWQgMCA/IF93IDogdHJ1ZSxcbiAgICAgICAgdmFsaWRhdGVTY2hlbWE6IChfeCA9IG8udmFsaWRhdGVTY2hlbWEpICE9PSBudWxsICYmIF94ICE9PSB2b2lkIDAgPyBfeCA6IHRydWUsXG4gICAgICAgIHZhbGlkYXRlRm9ybWF0czogKF95ID0gby52YWxpZGF0ZUZvcm1hdHMpICE9PSBudWxsICYmIF95ICE9PSB2b2lkIDAgPyBfeSA6IHRydWUsXG4gICAgICAgIHVuaWNvZGVSZWdFeHA6IChfeiA9IG8udW5pY29kZVJlZ0V4cCkgIT09IG51bGwgJiYgX3ogIT09IHZvaWQgMCA/IF96IDogdHJ1ZSxcbiAgICAgICAgaW50MzJyYW5nZTogKF8wID0gby5pbnQzMnJhbmdlKSAhPT0gbnVsbCAmJiBfMCAhPT0gdm9pZCAwID8gXzAgOiB0cnVlLFxuICAgICAgICB1cmlSZXNvbHZlcjogdXJpUmVzb2x2ZXIsXG4gICAgfTtcbn1cbmNsYXNzIEFqdiB7XG4gICAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgICAgIHRoaXMuc2NoZW1hcyA9IHt9O1xuICAgICAgICB0aGlzLnJlZnMgPSB7fTtcbiAgICAgICAgdGhpcy5mb3JtYXRzID0ge307XG4gICAgICAgIHRoaXMuX2NvbXBpbGF0aW9ucyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5fbG9hZGluZyA9IHt9O1xuICAgICAgICB0aGlzLl9jYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgb3B0cyA9IHRoaXMub3B0cyA9IHsgLi4ub3B0cywgLi4ucmVxdWlyZWRPcHRpb25zKG9wdHMpIH07XG4gICAgICAgIGNvbnN0IHsgZXM1LCBsaW5lcyB9ID0gdGhpcy5vcHRzLmNvZGU7XG4gICAgICAgIHRoaXMuc2NvcGUgPSBuZXcgY29kZWdlbl8yLlZhbHVlU2NvcGUoeyBzY29wZToge30sIHByZWZpeGVzOiBFWFRfU0NPUEVfTkFNRVMsIGVzNSwgbGluZXMgfSk7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gZ2V0TG9nZ2VyKG9wdHMubG9nZ2VyKTtcbiAgICAgICAgY29uc3QgZm9ybWF0T3B0ID0gb3B0cy52YWxpZGF0ZUZvcm1hdHM7XG4gICAgICAgIG9wdHMudmFsaWRhdGVGb3JtYXRzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuUlVMRVMgPSAoMCwgcnVsZXNfMS5nZXRSdWxlcykoKTtcbiAgICAgICAgY2hlY2tPcHRpb25zLmNhbGwodGhpcywgcmVtb3ZlZE9wdGlvbnMsIG9wdHMsIFwiTk9UIFNVUFBPUlRFRFwiKTtcbiAgICAgICAgY2hlY2tPcHRpb25zLmNhbGwodGhpcywgZGVwcmVjYXRlZE9wdGlvbnMsIG9wdHMsIFwiREVQUkVDQVRFRFwiLCBcIndhcm5cIik7XG4gICAgICAgIHRoaXMuX21ldGFPcHRzID0gZ2V0TWV0YVNjaGVtYU9wdGlvbnMuY2FsbCh0aGlzKTtcbiAgICAgICAgaWYgKG9wdHMuZm9ybWF0cylcbiAgICAgICAgICAgIGFkZEluaXRpYWxGb3JtYXRzLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuX2FkZFZvY2FidWxhcmllcygpO1xuICAgICAgICB0aGlzLl9hZGREZWZhdWx0TWV0YVNjaGVtYSgpO1xuICAgICAgICBpZiAob3B0cy5rZXl3b3JkcylcbiAgICAgICAgICAgIGFkZEluaXRpYWxLZXl3b3Jkcy5jYWxsKHRoaXMsIG9wdHMua2V5d29yZHMpO1xuICAgICAgICBpZiAodHlwZW9mIG9wdHMubWV0YSA9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgdGhpcy5hZGRNZXRhU2NoZW1hKG9wdHMubWV0YSk7XG4gICAgICAgIGFkZEluaXRpYWxTY2hlbWFzLmNhbGwodGhpcyk7XG4gICAgICAgIG9wdHMudmFsaWRhdGVGb3JtYXRzID0gZm9ybWF0T3B0O1xuICAgIH1cbiAgICBfYWRkVm9jYWJ1bGFyaWVzKCkge1xuICAgICAgICB0aGlzLmFkZEtleXdvcmQoXCIkYXN5bmNcIik7XG4gICAgfVxuICAgIF9hZGREZWZhdWx0TWV0YVNjaGVtYSgpIHtcbiAgICAgICAgY29uc3QgeyAkZGF0YSwgbWV0YSwgc2NoZW1hSWQgfSA9IHRoaXMub3B0cztcbiAgICAgICAgbGV0IF9kYXRhUmVmU2NoZW1hID0gJGRhdGFSZWZTY2hlbWE7XG4gICAgICAgIGlmIChzY2hlbWFJZCA9PT0gXCJpZFwiKSB7XG4gICAgICAgICAgICBfZGF0YVJlZlNjaGVtYSA9IHsgLi4uJGRhdGFSZWZTY2hlbWEgfTtcbiAgICAgICAgICAgIF9kYXRhUmVmU2NoZW1hLmlkID0gX2RhdGFSZWZTY2hlbWEuJGlkO1xuICAgICAgICAgICAgZGVsZXRlIF9kYXRhUmVmU2NoZW1hLiRpZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0YSAmJiAkZGF0YSlcbiAgICAgICAgICAgIHRoaXMuYWRkTWV0YVNjaGVtYShfZGF0YVJlZlNjaGVtYSwgX2RhdGFSZWZTY2hlbWFbc2NoZW1hSWRdLCBmYWxzZSk7XG4gICAgfVxuICAgIGRlZmF1bHRNZXRhKCkge1xuICAgICAgICBjb25zdCB7IG1ldGEsIHNjaGVtYUlkIH0gPSB0aGlzLm9wdHM7XG4gICAgICAgIHJldHVybiAodGhpcy5vcHRzLmRlZmF1bHRNZXRhID0gdHlwZW9mIG1ldGEgPT0gXCJvYmplY3RcIiA/IG1ldGFbc2NoZW1hSWRdIHx8IG1ldGEgOiB1bmRlZmluZWQpO1xuICAgIH1cbiAgICB2YWxpZGF0ZShzY2hlbWFLZXlSZWYsIC8vIGtleSwgcmVmIG9yIHNjaGVtYSBvYmplY3RcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlZHVuZGFudC10eXBlLWNvbnN0aXR1ZW50c1xuICAgIGRhdGEgLy8gdG8gYmUgdmFsaWRhdGVkXG4gICAgKSB7XG4gICAgICAgIGxldCB2O1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYUtleVJlZiA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB2ID0gdGhpcy5nZXRTY2hlbWEoc2NoZW1hS2V5UmVmKTtcbiAgICAgICAgICAgIGlmICghdilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG5vIHNjaGVtYSB3aXRoIGtleSBvciByZWYgXCIke3NjaGVtYUtleVJlZn1cImApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdiA9IHRoaXMuY29tcGlsZShzY2hlbWFLZXlSZWYpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbGlkID0gdihkYXRhKTtcbiAgICAgICAgaWYgKCEoXCIkYXN5bmNcIiBpbiB2KSlcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzID0gdi5lcnJvcnM7XG4gICAgICAgIHJldHVybiB2YWxpZDtcbiAgICB9XG4gICAgY29tcGlsZShzY2hlbWEsIF9tZXRhKSB7XG4gICAgICAgIGNvbnN0IHNjaCA9IHRoaXMuX2FkZFNjaGVtYShzY2hlbWEsIF9tZXRhKTtcbiAgICAgICAgcmV0dXJuIChzY2gudmFsaWRhdGUgfHwgdGhpcy5fY29tcGlsZVNjaGVtYUVudihzY2gpKTtcbiAgICB9XG4gICAgY29tcGlsZUFzeW5jKHNjaGVtYSwgbWV0YSkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0cy5sb2FkU2NoZW1hICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwib3B0aW9ucy5sb2FkU2NoZW1hIHNob3VsZCBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgbG9hZFNjaGVtYSB9ID0gdGhpcy5vcHRzO1xuICAgICAgICByZXR1cm4gcnVuQ29tcGlsZUFzeW5jLmNhbGwodGhpcywgc2NoZW1hLCBtZXRhKTtcbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gcnVuQ29tcGlsZUFzeW5jKF9zY2hlbWEsIF9tZXRhKSB7XG4gICAgICAgICAgICBhd2FpdCBsb2FkTWV0YVNjaGVtYS5jYWxsKHRoaXMsIF9zY2hlbWEuJHNjaGVtYSk7XG4gICAgICAgICAgICBjb25zdCBzY2ggPSB0aGlzLl9hZGRTY2hlbWEoX3NjaGVtYSwgX21ldGEpO1xuICAgICAgICAgICAgcmV0dXJuIHNjaC52YWxpZGF0ZSB8fCBfY29tcGlsZUFzeW5jLmNhbGwodGhpcywgc2NoKTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBmdW5jdGlvbiBsb2FkTWV0YVNjaGVtYSgkcmVmKSB7XG4gICAgICAgICAgICBpZiAoJHJlZiAmJiAhdGhpcy5nZXRTY2hlbWEoJHJlZikpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBydW5Db21waWxlQXN5bmMuY2FsbCh0aGlzLCB7ICRyZWYgfSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gX2NvbXBpbGVBc3luYyhzY2gpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXBpbGVTY2hlbWFFbnYoc2NoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIHJlZl9lcnJvcl8xLmRlZmF1bHQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgIGNoZWNrTG9hZGVkLmNhbGwodGhpcywgZSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgbG9hZE1pc3NpbmdTY2hlbWEuY2FsbCh0aGlzLCBlLm1pc3NpbmdTY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29tcGlsZUFzeW5jLmNhbGwodGhpcywgc2NoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjaGVja0xvYWRlZCh7IG1pc3NpbmdTY2hlbWE6IHJlZiwgbWlzc2luZ1JlZiB9KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWZzW3JlZl0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFueVNjaGVtYSAke3JlZn0gaXMgbG9hZGVkIGJ1dCAke21pc3NpbmdSZWZ9IGNhbm5vdCBiZSByZXNvbHZlZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGxvYWRNaXNzaW5nU2NoZW1hKHJlZikge1xuICAgICAgICAgICAgY29uc3QgX3NjaGVtYSA9IGF3YWl0IF9sb2FkU2NoZW1hLmNhbGwodGhpcywgcmVmKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5yZWZzW3JlZl0pXG4gICAgICAgICAgICAgICAgYXdhaXQgbG9hZE1ldGFTY2hlbWEuY2FsbCh0aGlzLCBfc2NoZW1hLiRzY2hlbWEpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJlZnNbcmVmXSlcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFNjaGVtYShfc2NoZW1hLCByZWYsIG1ldGEpO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIF9sb2FkU2NoZW1hKHJlZikge1xuICAgICAgICAgICAgY29uc3QgcCA9IHRoaXMuX2xvYWRpbmdbcmVmXTtcbiAgICAgICAgICAgIGlmIChwKVxuICAgICAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgKHRoaXMuX2xvYWRpbmdbcmVmXSA9IGxvYWRTY2hlbWEocmVmKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fbG9hZGluZ1tyZWZdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEFkZHMgc2NoZW1hIHRvIHRoZSBpbnN0YW5jZVxuICAgIGFkZFNjaGVtYShzY2hlbWEsIC8vIElmIGFycmF5IGlzIHBhc3NlZCwgYGtleWAgd2lsbCBiZSBpZ25vcmVkXG4gICAga2V5LCAvLyBPcHRpb25hbCBzY2hlbWEga2V5LiBDYW4gYmUgcGFzc2VkIHRvIGB2YWxpZGF0ZWAgbWV0aG9kIGluc3RlYWQgb2Ygc2NoZW1hIG9iamVjdCBvciBpZC9yZWYuIE9uZSBzY2hlbWEgcGVyIGluc3RhbmNlIGNhbiBoYXZlIGVtcHR5IGBpZGAgYW5kIGBrZXlgLlxuICAgIF9tZXRhLCAvLyB0cnVlIGlmIHNjaGVtYSBpcyBhIG1ldGEtc2NoZW1hLiBVc2VkIGludGVybmFsbHksIGFkZE1ldGFTY2hlbWEgc2hvdWxkIGJlIHVzZWQgaW5zdGVhZC5cbiAgICBfdmFsaWRhdGVTY2hlbWEgPSB0aGlzLm9wdHMudmFsaWRhdGVTY2hlbWEgLy8gZmFsc2UgdG8gc2tpcCBzY2hlbWEgdmFsaWRhdGlvbi4gVXNlZCBpbnRlcm5hbGx5LCBvcHRpb24gdmFsaWRhdGVTY2hlbWEgc2hvdWxkIGJlIHVzZWQgaW5zdGVhZC5cbiAgICApIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBzY2ggb2Ygc2NoZW1hKVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkU2NoZW1hKHNjaCwgdW5kZWZpbmVkLCBfbWV0YSwgX3ZhbGlkYXRlU2NoZW1hKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpZDtcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgc2NoZW1hSWQgfSA9IHRoaXMub3B0cztcbiAgICAgICAgICAgIGlkID0gc2NoZW1hW3NjaGVtYUlkXTtcbiAgICAgICAgICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBpZCAhPSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzY2hlbWEgJHtzY2hlbWFJZH0gbXVzdCBiZSBzdHJpbmdgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBrZXkgPSAoMCwgcmVzb2x2ZV8xLm5vcm1hbGl6ZUlkKShrZXkgfHwgaWQpO1xuICAgICAgICB0aGlzLl9jaGVja1VuaXF1ZShrZXkpO1xuICAgICAgICB0aGlzLnNjaGVtYXNba2V5XSA9IHRoaXMuX2FkZFNjaGVtYShzY2hlbWEsIF9tZXRhLCBrZXksIF92YWxpZGF0ZVNjaGVtYSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBBZGQgc2NoZW1hIHRoYXQgd2lsbCBiZSB1c2VkIHRvIHZhbGlkYXRlIG90aGVyIHNjaGVtYXNcbiAgICAvLyBvcHRpb25zIGluIE1FVEFfSUdOT1JFX09QVElPTlMgYXJlIGFsd2F5IHNldCB0byBmYWxzZVxuICAgIGFkZE1ldGFTY2hlbWEoc2NoZW1hLCBrZXksIC8vIHNjaGVtYSBrZXlcbiAgICBfdmFsaWRhdGVTY2hlbWEgPSB0aGlzLm9wdHMudmFsaWRhdGVTY2hlbWEgLy8gZmFsc2UgdG8gc2tpcCBzY2hlbWEgdmFsaWRhdGlvbiwgY2FuIGJlIHVzZWQgdG8gb3ZlcnJpZGUgdmFsaWRhdGVTY2hlbWEgb3B0aW9uIGZvciBtZXRhLXNjaGVtYVxuICAgICkge1xuICAgICAgICB0aGlzLmFkZFNjaGVtYShzY2hlbWEsIGtleSwgdHJ1ZSwgX3ZhbGlkYXRlU2NoZW1hKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vICBWYWxpZGF0ZSBzY2hlbWEgYWdhaW5zdCBpdHMgbWV0YS1zY2hlbWFcbiAgICB2YWxpZGF0ZVNjaGVtYShzY2hlbWEsIHRocm93T3JMb2dFcnJvcikge1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIilcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBsZXQgJHNjaGVtYTtcbiAgICAgICAgJHNjaGVtYSA9IHNjaGVtYS4kc2NoZW1hO1xuICAgICAgICBpZiAoJHNjaGVtYSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiAkc2NoZW1hICE9IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIiRzY2hlbWEgbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICAkc2NoZW1hID0gJHNjaGVtYSB8fCB0aGlzLm9wdHMuZGVmYXVsdE1ldGEgfHwgdGhpcy5kZWZhdWx0TWV0YSgpO1xuICAgICAgICBpZiAoISRzY2hlbWEpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJtZXRhLXNjaGVtYSBub3QgYXZhaWxhYmxlXCIpO1xuICAgICAgICAgICAgdGhpcy5lcnJvcnMgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsaWQgPSB0aGlzLnZhbGlkYXRlKCRzY2hlbWEsIHNjaGVtYSk7XG4gICAgICAgIGlmICghdmFsaWQgJiYgdGhyb3dPckxvZ0Vycm9yKSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gXCJzY2hlbWEgaXMgaW52YWxpZDogXCIgKyB0aGlzLmVycm9yc1RleHQoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdHMudmFsaWRhdGVTY2hlbWEgPT09IFwibG9nXCIpXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWxpZDtcbiAgICB9XG4gICAgLy8gR2V0IGNvbXBpbGVkIHNjaGVtYSBieSBga2V5YCBvciBgcmVmYC5cbiAgICAvLyAoYGtleWAgdGhhdCB3YXMgcGFzc2VkIHRvIGBhZGRTY2hlbWFgIG9yIGZ1bGwgc2NoZW1hIHJlZmVyZW5jZSAtIGBzY2hlbWEuJGlkYCBvciByZXNvbHZlZCBpZClcbiAgICBnZXRTY2hlbWEoa2V5UmVmKSB7XG4gICAgICAgIGxldCBzY2g7XG4gICAgICAgIHdoaWxlICh0eXBlb2YgKHNjaCA9IGdldFNjaEVudi5jYWxsKHRoaXMsIGtleVJlZikpID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICBrZXlSZWYgPSBzY2g7XG4gICAgICAgIGlmIChzY2ggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgeyBzY2hlbWFJZCB9ID0gdGhpcy5vcHRzO1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IG5ldyBjb21waWxlXzEuU2NoZW1hRW52KHsgc2NoZW1hOiB7fSwgc2NoZW1hSWQgfSk7XG4gICAgICAgICAgICBzY2ggPSBjb21waWxlXzEucmVzb2x2ZVNjaGVtYS5jYWxsKHRoaXMsIHJvb3QsIGtleVJlZik7XG4gICAgICAgICAgICBpZiAoIXNjaClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLnJlZnNba2V5UmVmXSA9IHNjaDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHNjaC52YWxpZGF0ZSB8fCB0aGlzLl9jb21waWxlU2NoZW1hRW52KHNjaCkpO1xuICAgIH1cbiAgICAvLyBSZW1vdmUgY2FjaGVkIHNjaGVtYShzKS5cbiAgICAvLyBJZiBubyBwYXJhbWV0ZXIgaXMgcGFzc2VkIGFsbCBzY2hlbWFzIGJ1dCBtZXRhLXNjaGVtYXMgYXJlIHJlbW92ZWQuXG4gICAgLy8gSWYgUmVnRXhwIGlzIHBhc3NlZCBhbGwgc2NoZW1hcyB3aXRoIGtleS9pZCBtYXRjaGluZyBwYXR0ZXJuIGJ1dCBtZXRhLXNjaGVtYXMgYXJlIHJlbW92ZWQuXG4gICAgLy8gRXZlbiBpZiBzY2hlbWEgaXMgcmVmZXJlbmNlZCBieSBvdGhlciBzY2hlbWFzIGl0IHN0aWxsIGNhbiBiZSByZW1vdmVkIGFzIG90aGVyIHNjaGVtYXMgaGF2ZSBsb2NhbCByZWZlcmVuY2VzLlxuICAgIHJlbW92ZVNjaGVtYShzY2hlbWFLZXlSZWYpIHtcbiAgICAgICAgaWYgKHNjaGVtYUtleVJlZiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlQWxsU2NoZW1hcyh0aGlzLnNjaGVtYXMsIHNjaGVtYUtleVJlZik7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVBbGxTY2hlbWFzKHRoaXMucmVmcywgc2NoZW1hS2V5UmVmKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodHlwZW9mIHNjaGVtYUtleVJlZikge1xuICAgICAgICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUFsbFNjaGVtYXModGhpcy5zY2hlbWFzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVBbGxTY2hlbWFzKHRoaXMucmVmcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGUuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjaCA9IGdldFNjaEVudi5jYWxsKHRoaXMsIHNjaGVtYUtleVJlZik7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzY2ggPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FjaGUuZGVsZXRlKHNjaC5zY2hlbWEpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNjaGVtYXNbc2NoZW1hS2V5UmVmXTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5yZWZzW3NjaGVtYUtleVJlZl07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwib2JqZWN0XCI6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYWNoZUtleSA9IHNjaGVtYUtleVJlZjtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZS5kZWxldGUoY2FjaGVLZXkpO1xuICAgICAgICAgICAgICAgIGxldCBpZCA9IHNjaGVtYUtleVJlZlt0aGlzLm9wdHMuc2NoZW1hSWRdO1xuICAgICAgICAgICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgICAgICAgICBpZCA9ICgwLCByZXNvbHZlXzEubm9ybWFsaXplSWQpKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuc2NoZW1hc1tpZF07XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnJlZnNbaWRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2LnJlbW92ZVNjaGVtYTogaW52YWxpZCBwYXJhbWV0ZXJcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYWRkIFwidm9jYWJ1bGFyeVwiIC0gYSBjb2xsZWN0aW9uIG9mIGtleXdvcmRzXG4gICAgYWRkVm9jYWJ1bGFyeShkZWZpbml0aW9ucykge1xuICAgICAgICBmb3IgKGNvbnN0IGRlZiBvZiBkZWZpbml0aW9ucylcbiAgICAgICAgICAgIHRoaXMuYWRkS2V5d29yZChkZWYpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYWRkS2V5d29yZChrd2RPckRlZiwgZGVmIC8vIGRlcHJlY2F0ZWRcbiAgICApIHtcbiAgICAgICAgbGV0IGtleXdvcmQ7XG4gICAgICAgIGlmICh0eXBlb2Yga3dkT3JEZWYgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAga2V5d29yZCA9IGt3ZE9yRGVmO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWYgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJ0aGVzZSBwYXJhbWV0ZXJzIGFyZSBkZXByZWNhdGVkLCBzZWUgZG9jcyBmb3IgYWRkS2V5d29yZFwiKTtcbiAgICAgICAgICAgICAgICBkZWYua2V5d29yZCA9IGtleXdvcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGt3ZE9yRGVmID09IFwib2JqZWN0XCIgJiYgZGVmID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRlZiA9IGt3ZE9yRGVmO1xuICAgICAgICAgICAga2V5d29yZCA9IGRlZi5rZXl3b3JkO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoa2V5d29yZCkgJiYgIWtleXdvcmQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWRkS2V5d29yZHM6IGtleXdvcmQgbXVzdCBiZSBzdHJpbmcgb3Igbm9uLWVtcHR5IGFycmF5XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBhZGRLZXl3b3JkcyBwYXJhbWV0ZXJzXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrS2V5d29yZC5jYWxsKHRoaXMsIGtleXdvcmQsIGRlZik7XG4gICAgICAgIGlmICghZGVmKSB7XG4gICAgICAgICAgICAoMCwgdXRpbF8xLmVhY2hJdGVtKShrZXl3b3JkLCAoa3dkKSA9PiBhZGRSdWxlLmNhbGwodGhpcywga3dkKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBrZXl3b3JkTWV0YXNjaGVtYS5jYWxsKHRoaXMsIGRlZik7XG4gICAgICAgIGNvbnN0IGRlZmluaXRpb24gPSB7XG4gICAgICAgICAgICAuLi5kZWYsXG4gICAgICAgICAgICB0eXBlOiAoMCwgZGF0YVR5cGVfMS5nZXRKU09OVHlwZXMpKGRlZi50eXBlKSxcbiAgICAgICAgICAgIHNjaGVtYVR5cGU6ICgwLCBkYXRhVHlwZV8xLmdldEpTT05UeXBlcykoZGVmLnNjaGVtYVR5cGUpLFxuICAgICAgICB9O1xuICAgICAgICAoMCwgdXRpbF8xLmVhY2hJdGVtKShrZXl3b3JkLCBkZWZpbml0aW9uLnR5cGUubGVuZ3RoID09PSAwXG4gICAgICAgICAgICA/IChrKSA9PiBhZGRSdWxlLmNhbGwodGhpcywgaywgZGVmaW5pdGlvbilcbiAgICAgICAgICAgIDogKGspID0+IGRlZmluaXRpb24udHlwZS5mb3JFYWNoKCh0KSA9PiBhZGRSdWxlLmNhbGwodGhpcywgaywgZGVmaW5pdGlvbiwgdCkpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldEtleXdvcmQoa2V5d29yZCkge1xuICAgICAgICBjb25zdCBydWxlID0gdGhpcy5SVUxFUy5hbGxba2V5d29yZF07XG4gICAgICAgIHJldHVybiB0eXBlb2YgcnVsZSA9PSBcIm9iamVjdFwiID8gcnVsZS5kZWZpbml0aW9uIDogISFydWxlO1xuICAgIH1cbiAgICAvLyBSZW1vdmUga2V5d29yZFxuICAgIHJlbW92ZUtleXdvcmQoa2V5d29yZCkge1xuICAgICAgICAvLyBUT0RPIHJldHVybiB0eXBlIHNob3VsZCBiZSBBanZcbiAgICAgICAgY29uc3QgeyBSVUxFUyB9ID0gdGhpcztcbiAgICAgICAgZGVsZXRlIFJVTEVTLmtleXdvcmRzW2tleXdvcmRdO1xuICAgICAgICBkZWxldGUgUlVMRVMuYWxsW2tleXdvcmRdO1xuICAgICAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIFJVTEVTLnJ1bGVzKSB7XG4gICAgICAgICAgICBjb25zdCBpID0gZ3JvdXAucnVsZXMuZmluZEluZGV4KChydWxlKSA9PiBydWxlLmtleXdvcmQgPT09IGtleXdvcmQpO1xuICAgICAgICAgICAgaWYgKGkgPj0gMClcbiAgICAgICAgICAgICAgICBncm91cC5ydWxlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIEFkZCBmb3JtYXRcbiAgICBhZGRGb3JtYXQobmFtZSwgZm9ybWF0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZm9ybWF0ID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICBmb3JtYXQgPSBuZXcgUmVnRXhwKGZvcm1hdCk7XG4gICAgICAgIHRoaXMuZm9ybWF0c1tuYW1lXSA9IGZvcm1hdDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGVycm9yc1RleHQoZXJyb3JzID0gdGhpcy5lcnJvcnMsIC8vIG9wdGlvbmFsIGFycmF5IG9mIHZhbGlkYXRpb24gZXJyb3JzXG4gICAgeyBzZXBhcmF0b3IgPSBcIiwgXCIsIGRhdGFWYXIgPSBcImRhdGFcIiB9ID0ge30gLy8gb3B0aW9uYWwgb3B0aW9ucyB3aXRoIHByb3BlcnRpZXMgYHNlcGFyYXRvcmAgYW5kIGBkYXRhVmFyYFxuICAgICkge1xuICAgICAgICBpZiAoIWVycm9ycyB8fCBlcnJvcnMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIFwiTm8gZXJyb3JzXCI7XG4gICAgICAgIHJldHVybiBlcnJvcnNcbiAgICAgICAgICAgIC5tYXAoKGUpID0+IGAke2RhdGFWYXJ9JHtlLmluc3RhbmNlUGF0aH0gJHtlLm1lc3NhZ2V9YClcbiAgICAgICAgICAgIC5yZWR1Y2UoKHRleHQsIG1zZykgPT4gdGV4dCArIHNlcGFyYXRvciArIG1zZyk7XG4gICAgfVxuICAgICRkYXRhTWV0YVNjaGVtYShtZXRhU2NoZW1hLCBrZXl3b3Jkc0pzb25Qb2ludGVycykge1xuICAgICAgICBjb25zdCBydWxlcyA9IHRoaXMuUlVMRVMuYWxsO1xuICAgICAgICBtZXRhU2NoZW1hID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShtZXRhU2NoZW1hKSk7XG4gICAgICAgIGZvciAoY29uc3QganNvblBvaW50ZXIgb2Yga2V5d29yZHNKc29uUG9pbnRlcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlZ21lbnRzID0ganNvblBvaW50ZXIuc3BsaXQoXCIvXCIpLnNsaWNlKDEpOyAvLyBmaXJzdCBzZWdtZW50IGlzIGFuIGVtcHR5IHN0cmluZ1xuICAgICAgICAgICAgbGV0IGtleXdvcmRzID0gbWV0YVNjaGVtYTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc2VnIG9mIHNlZ21lbnRzKVxuICAgICAgICAgICAgICAgIGtleXdvcmRzID0ga2V5d29yZHNbc2VnXTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHJ1bGVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcnVsZSA9IHJ1bGVzW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBydWxlICE9IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgJGRhdGEgfSA9IHJ1bGUuZGVmaW5pdGlvbjtcbiAgICAgICAgICAgICAgICBjb25zdCBzY2hlbWEgPSBrZXl3b3Jkc1trZXldO1xuICAgICAgICAgICAgICAgIGlmICgkZGF0YSAmJiBzY2hlbWEpXG4gICAgICAgICAgICAgICAgICAgIGtleXdvcmRzW2tleV0gPSBzY2hlbWFPckRhdGEoc2NoZW1hKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWV0YVNjaGVtYTtcbiAgICB9XG4gICAgX3JlbW92ZUFsbFNjaGVtYXMoc2NoZW1hcywgcmVnZXgpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXlSZWYgaW4gc2NoZW1hcykge1xuICAgICAgICAgICAgY29uc3Qgc2NoID0gc2NoZW1hc1trZXlSZWZdO1xuICAgICAgICAgICAgaWYgKCFyZWdleCB8fCByZWdleC50ZXN0KGtleVJlZikpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNjaCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzY2hlbWFzW2tleVJlZl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNjaCAmJiAhc2NoLm1ldGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FjaGUuZGVsZXRlKHNjaC5zY2hlbWEpO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc2NoZW1hc1trZXlSZWZdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBfYWRkU2NoZW1hKHNjaGVtYSwgbWV0YSwgYmFzZUlkLCB2YWxpZGF0ZVNjaGVtYSA9IHRoaXMub3B0cy52YWxpZGF0ZVNjaGVtYSwgYWRkU2NoZW1hID0gdGhpcy5vcHRzLmFkZFVzZWRTY2hlbWEpIHtcbiAgICAgICAgbGV0IGlkO1xuICAgICAgICBjb25zdCB7IHNjaGVtYUlkIH0gPSB0aGlzLm9wdHM7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGlkID0gc2NoZW1hW3NjaGVtYUlkXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdHMuanRkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInNjaGVtYSBtdXN0IGJlIG9iamVjdFwiKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzY2hlbWEgIT0gXCJib29sZWFuXCIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2NoZW1hIG11c3QgYmUgb2JqZWN0IG9yIGJvb2xlYW5cIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNjaCA9IHRoaXMuX2NhY2hlLmdldChzY2hlbWEpO1xuICAgICAgICBpZiAoc2NoICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gc2NoO1xuICAgICAgICBiYXNlSWQgPSAoMCwgcmVzb2x2ZV8xLm5vcm1hbGl6ZUlkKShpZCB8fCBiYXNlSWQpO1xuICAgICAgICBjb25zdCBsb2NhbFJlZnMgPSByZXNvbHZlXzEuZ2V0U2NoZW1hUmVmcy5jYWxsKHRoaXMsIHNjaGVtYSwgYmFzZUlkKTtcbiAgICAgICAgc2NoID0gbmV3IGNvbXBpbGVfMS5TY2hlbWFFbnYoeyBzY2hlbWEsIHNjaGVtYUlkLCBtZXRhLCBiYXNlSWQsIGxvY2FsUmVmcyB9KTtcbiAgICAgICAgdGhpcy5fY2FjaGUuc2V0KHNjaC5zY2hlbWEsIHNjaCk7XG4gICAgICAgIGlmIChhZGRTY2hlbWEgJiYgIWJhc2VJZC5zdGFydHNXaXRoKFwiI1wiKSkge1xuICAgICAgICAgICAgLy8gVE9ETyBhdG0gaXQgaXMgYWxsb3dlZCB0byBvdmVyd3JpdGUgc2NoZW1hcyB3aXRob3V0IGlkIChpbnN0ZWFkIG9mIG5vdCBhZGRpbmcgdGhlbSlcbiAgICAgICAgICAgIGlmIChiYXNlSWQpXG4gICAgICAgICAgICAgICAgdGhpcy5fY2hlY2tVbmlxdWUoYmFzZUlkKTtcbiAgICAgICAgICAgIHRoaXMucmVmc1tiYXNlSWRdID0gc2NoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWxpZGF0ZVNjaGVtYSlcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGVTY2hlbWEoc2NoZW1hLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHNjaDtcbiAgICB9XG4gICAgX2NoZWNrVW5pcXVlKGlkKSB7XG4gICAgICAgIGlmICh0aGlzLnNjaGVtYXNbaWRdIHx8IHRoaXMucmVmc1tpZF0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgc2NoZW1hIHdpdGgga2V5IG9yIGlkIFwiJHtpZH1cIiBhbHJlYWR5IGV4aXN0c2ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9jb21waWxlU2NoZW1hRW52KHNjaCkge1xuICAgICAgICBpZiAoc2NoLm1ldGEpXG4gICAgICAgICAgICB0aGlzLl9jb21waWxlTWV0YVNjaGVtYShzY2gpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBjb21waWxlXzEuY29tcGlsZVNjaGVtYS5jYWxsKHRoaXMsIHNjaCk7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIXNjaC52YWxpZGF0ZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFqdiBpbXBsZW1lbnRhdGlvbiBlcnJvclwiKTtcbiAgICAgICAgcmV0dXJuIHNjaC52YWxpZGF0ZTtcbiAgICB9XG4gICAgX2NvbXBpbGVNZXRhU2NoZW1hKHNjaCkge1xuICAgICAgICBjb25zdCBjdXJyZW50T3B0cyA9IHRoaXMub3B0cztcbiAgICAgICAgdGhpcy5vcHRzID0gdGhpcy5fbWV0YU9wdHM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb21waWxlXzEuY29tcGlsZVNjaGVtYS5jYWxsKHRoaXMsIHNjaCk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLm9wdHMgPSBjdXJyZW50T3B0cztcbiAgICAgICAgfVxuICAgIH1cbn1cbkFqdi5WYWxpZGF0aW9uRXJyb3IgPSB2YWxpZGF0aW9uX2Vycm9yXzEuZGVmYXVsdDtcbkFqdi5NaXNzaW5nUmVmRXJyb3IgPSByZWZfZXJyb3JfMS5kZWZhdWx0O1xuZXhwb3J0cy5kZWZhdWx0ID0gQWp2O1xuZnVuY3Rpb24gY2hlY2tPcHRpb25zKGNoZWNrT3B0cywgb3B0aW9ucywgbXNnLCBsb2cgPSBcImVycm9yXCIpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBjaGVja09wdHMpIHtcbiAgICAgICAgY29uc3Qgb3B0ID0ga2V5O1xuICAgICAgICBpZiAob3B0IGluIG9wdGlvbnMpXG4gICAgICAgICAgICB0aGlzLmxvZ2dlcltsb2ddKGAke21zZ306IG9wdGlvbiAke2tleX0uICR7Y2hlY2tPcHRzW29wdF19YCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0U2NoRW52KGtleVJlZikge1xuICAgIGtleVJlZiA9ICgwLCByZXNvbHZlXzEubm9ybWFsaXplSWQpKGtleVJlZik7IC8vIFRPRE8gdGVzdHMgZmFpbCB3aXRob3V0IHRoaXMgbGluZVxuICAgIHJldHVybiB0aGlzLnNjaGVtYXNba2V5UmVmXSB8fCB0aGlzLnJlZnNba2V5UmVmXTtcbn1cbmZ1bmN0aW9uIGFkZEluaXRpYWxTY2hlbWFzKCkge1xuICAgIGNvbnN0IG9wdHNTY2hlbWFzID0gdGhpcy5vcHRzLnNjaGVtYXM7XG4gICAgaWYgKCFvcHRzU2NoZW1hcylcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdHNTY2hlbWFzKSlcbiAgICAgICAgdGhpcy5hZGRTY2hlbWEob3B0c1NjaGVtYXMpO1xuICAgIGVsc2VcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb3B0c1NjaGVtYXMpXG4gICAgICAgICAgICB0aGlzLmFkZFNjaGVtYShvcHRzU2NoZW1hc1trZXldLCBrZXkpO1xufVxuZnVuY3Rpb24gYWRkSW5pdGlhbEZvcm1hdHMoKSB7XG4gICAgZm9yIChjb25zdCBuYW1lIGluIHRoaXMub3B0cy5mb3JtYXRzKSB7XG4gICAgICAgIGNvbnN0IGZvcm1hdCA9IHRoaXMub3B0cy5mb3JtYXRzW25hbWVdO1xuICAgICAgICBpZiAoZm9ybWF0KVxuICAgICAgICAgICAgdGhpcy5hZGRGb3JtYXQobmFtZSwgZm9ybWF0KTtcbiAgICB9XG59XG5mdW5jdGlvbiBhZGRJbml0aWFsS2V5d29yZHMoZGVmcykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGRlZnMpKSB7XG4gICAgICAgIHRoaXMuYWRkVm9jYWJ1bGFyeShkZWZzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmxvZ2dlci53YXJuKFwia2V5d29yZHMgb3B0aW9uIGFzIG1hcCBpcyBkZXByZWNhdGVkLCBwYXNzIGFycmF5XCIpO1xuICAgIGZvciAoY29uc3Qga2V5d29yZCBpbiBkZWZzKSB7XG4gICAgICAgIGNvbnN0IGRlZiA9IGRlZnNba2V5d29yZF07XG4gICAgICAgIGlmICghZGVmLmtleXdvcmQpXG4gICAgICAgICAgICBkZWYua2V5d29yZCA9IGtleXdvcmQ7XG4gICAgICAgIHRoaXMuYWRkS2V5d29yZChkZWYpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldE1ldGFTY2hlbWFPcHRpb25zKCkge1xuICAgIGNvbnN0IG1ldGFPcHRzID0geyAuLi50aGlzLm9wdHMgfTtcbiAgICBmb3IgKGNvbnN0IG9wdCBvZiBNRVRBX0lHTk9SRV9PUFRJT05TKVxuICAgICAgICBkZWxldGUgbWV0YU9wdHNbb3B0XTtcbiAgICByZXR1cm4gbWV0YU9wdHM7XG59XG5jb25zdCBub0xvZ3MgPSB7IGxvZygpIHsgfSwgd2FybigpIHsgfSwgZXJyb3IoKSB7IH0gfTtcbmZ1bmN0aW9uIGdldExvZ2dlcihsb2dnZXIpIHtcbiAgICBpZiAobG9nZ2VyID09PSBmYWxzZSlcbiAgICAgICAgcmV0dXJuIG5vTG9ncztcbiAgICBpZiAobG9nZ2VyID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiBjb25zb2xlO1xuICAgIGlmIChsb2dnZXIubG9nICYmIGxvZ2dlci53YXJuICYmIGxvZ2dlci5lcnJvcilcbiAgICAgICAgcmV0dXJuIGxvZ2dlcjtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJsb2dnZXIgbXVzdCBpbXBsZW1lbnQgbG9nLCB3YXJuIGFuZCBlcnJvciBtZXRob2RzXCIpO1xufVxuY29uc3QgS0VZV09SRF9OQU1FID0gL15bYS16XyRdW2EtejAtOV8kOi1dKiQvaTtcbmZ1bmN0aW9uIGNoZWNrS2V5d29yZChrZXl3b3JkLCBkZWYpIHtcbiAgICBjb25zdCB7IFJVTEVTIH0gPSB0aGlzO1xuICAgICgwLCB1dGlsXzEuZWFjaEl0ZW0pKGtleXdvcmQsIChrd2QpID0+IHtcbiAgICAgICAgaWYgKFJVTEVTLmtleXdvcmRzW2t3ZF0pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEtleXdvcmQgJHtrd2R9IGlzIGFscmVhZHkgZGVmaW5lZGApO1xuICAgICAgICBpZiAoIUtFWVdPUkRfTkFNRS50ZXN0KGt3ZCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEtleXdvcmQgJHtrd2R9IGhhcyBpbnZhbGlkIG5hbWVgKTtcbiAgICB9KTtcbiAgICBpZiAoIWRlZilcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmIChkZWYuJGRhdGEgJiYgIShcImNvZGVcIiBpbiBkZWYgfHwgXCJ2YWxpZGF0ZVwiIGluIGRlZikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCckZGF0YSBrZXl3b3JkIG11c3QgaGF2ZSBcImNvZGVcIiBvciBcInZhbGlkYXRlXCIgZnVuY3Rpb24nKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhZGRSdWxlKGtleXdvcmQsIGRlZmluaXRpb24sIGRhdGFUeXBlKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHBvc3QgPSBkZWZpbml0aW9uID09PSBudWxsIHx8IGRlZmluaXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRlZmluaXRpb24ucG9zdDtcbiAgICBpZiAoZGF0YVR5cGUgJiYgcG9zdClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdrZXl3b3JkIHdpdGggXCJwb3N0XCIgZmxhZyBjYW5ub3QgaGF2ZSBcInR5cGVcIicpO1xuICAgIGNvbnN0IHsgUlVMRVMgfSA9IHRoaXM7XG4gICAgbGV0IHJ1bGVHcm91cCA9IHBvc3QgPyBSVUxFUy5wb3N0IDogUlVMRVMucnVsZXMuZmluZCgoeyB0eXBlOiB0IH0pID0+IHQgPT09IGRhdGFUeXBlKTtcbiAgICBpZiAoIXJ1bGVHcm91cCkge1xuICAgICAgICBydWxlR3JvdXAgPSB7IHR5cGU6IGRhdGFUeXBlLCBydWxlczogW10gfTtcbiAgICAgICAgUlVMRVMucnVsZXMucHVzaChydWxlR3JvdXApO1xuICAgIH1cbiAgICBSVUxFUy5rZXl3b3Jkc1trZXl3b3JkXSA9IHRydWU7XG4gICAgaWYgKCFkZWZpbml0aW9uKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgcnVsZSA9IHtcbiAgICAgICAga2V5d29yZCxcbiAgICAgICAgZGVmaW5pdGlvbjoge1xuICAgICAgICAgICAgLi4uZGVmaW5pdGlvbixcbiAgICAgICAgICAgIHR5cGU6ICgwLCBkYXRhVHlwZV8xLmdldEpTT05UeXBlcykoZGVmaW5pdGlvbi50eXBlKSxcbiAgICAgICAgICAgIHNjaGVtYVR5cGU6ICgwLCBkYXRhVHlwZV8xLmdldEpTT05UeXBlcykoZGVmaW5pdGlvbi5zY2hlbWFUeXBlKSxcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIGlmIChkZWZpbml0aW9uLmJlZm9yZSlcbiAgICAgICAgYWRkQmVmb3JlUnVsZS5jYWxsKHRoaXMsIHJ1bGVHcm91cCwgcnVsZSwgZGVmaW5pdGlvbi5iZWZvcmUpO1xuICAgIGVsc2VcbiAgICAgICAgcnVsZUdyb3VwLnJ1bGVzLnB1c2gocnVsZSk7XG4gICAgUlVMRVMuYWxsW2tleXdvcmRdID0gcnVsZTtcbiAgICAoX2EgPSBkZWZpbml0aW9uLmltcGxlbWVudHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JFYWNoKChrd2QpID0+IHRoaXMuYWRkS2V5d29yZChrd2QpKTtcbn1cbmZ1bmN0aW9uIGFkZEJlZm9yZVJ1bGUocnVsZUdyb3VwLCBydWxlLCBiZWZvcmUpIHtcbiAgICBjb25zdCBpID0gcnVsZUdyb3VwLnJ1bGVzLmZpbmRJbmRleCgoX3J1bGUpID0+IF9ydWxlLmtleXdvcmQgPT09IGJlZm9yZSk7XG4gICAgaWYgKGkgPj0gMCkge1xuICAgICAgICBydWxlR3JvdXAucnVsZXMuc3BsaWNlKGksIDAsIHJ1bGUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcnVsZUdyb3VwLnJ1bGVzLnB1c2gocnVsZSk7XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4oYHJ1bGUgJHtiZWZvcmV9IGlzIG5vdCBkZWZpbmVkYCk7XG4gICAgfVxufVxuZnVuY3Rpb24ga2V5d29yZE1ldGFzY2hlbWEoZGVmKSB7XG4gICAgbGV0IHsgbWV0YVNjaGVtYSB9ID0gZGVmO1xuICAgIGlmIChtZXRhU2NoZW1hID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoZGVmLiRkYXRhICYmIHRoaXMub3B0cy4kZGF0YSlcbiAgICAgICAgbWV0YVNjaGVtYSA9IHNjaGVtYU9yRGF0YShtZXRhU2NoZW1hKTtcbiAgICBkZWYudmFsaWRhdGVTY2hlbWEgPSB0aGlzLmNvbXBpbGUobWV0YVNjaGVtYSwgdHJ1ZSk7XG59XG5jb25zdCAkZGF0YVJlZiA9IHtcbiAgICAkcmVmOiBcImh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9hanYtdmFsaWRhdG9yL2Fqdi9tYXN0ZXIvbGliL3JlZnMvZGF0YS5qc29uI1wiLFxufTtcbmZ1bmN0aW9uIHNjaGVtYU9yRGF0YShzY2hlbWEpIHtcbiAgICByZXR1cm4geyBhbnlPZjogW3NjaGVtYSwgJGRhdGFSZWZdIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb3JlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiaWRcIixcbiAgICBjb2RlKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05PVCBTVVBQT1JURUQ6IGtleXdvcmQgXCJpZFwiLCB1c2UgXCIkaWRcIiBmb3Igc2NoZW1hIElEJyk7XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY2FsbFJlZiA9IGV4cG9ydHMuZ2V0VmFsaWRhdGUgPSB2b2lkIDA7XG5jb25zdCByZWZfZXJyb3JfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3JlZl9lcnJvclwiKTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi9jb2RlXCIpO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IG5hbWVzXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9uYW1lc1wiKTtcbmNvbnN0IGNvbXBpbGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcIiRyZWZcIixcbiAgICBzY2hlbWFUeXBlOiBcInN0cmluZ1wiLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWE6ICRyZWYsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGNvbnN0IHsgYmFzZUlkLCBzY2hlbWFFbnY6IGVudiwgdmFsaWRhdGVOYW1lLCBvcHRzLCBzZWxmIH0gPSBpdDtcbiAgICAgICAgY29uc3QgeyByb290IH0gPSBlbnY7XG4gICAgICAgIGlmICgoJHJlZiA9PT0gXCIjXCIgfHwgJHJlZiA9PT0gXCIjL1wiKSAmJiBiYXNlSWQgPT09IHJvb3QuYmFzZUlkKVxuICAgICAgICAgICAgcmV0dXJuIGNhbGxSb290UmVmKCk7XG4gICAgICAgIGNvbnN0IHNjaE9yRW52ID0gY29tcGlsZV8xLnJlc29sdmVSZWYuY2FsbChzZWxmLCByb290LCBiYXNlSWQsICRyZWYpO1xuICAgICAgICBpZiAoc2NoT3JFbnYgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyByZWZfZXJyb3JfMS5kZWZhdWx0KGl0Lm9wdHMudXJpUmVzb2x2ZXIsIGJhc2VJZCwgJHJlZik7XG4gICAgICAgIGlmIChzY2hPckVudiBpbnN0YW5jZW9mIGNvbXBpbGVfMS5TY2hlbWFFbnYpXG4gICAgICAgICAgICByZXR1cm4gY2FsbFZhbGlkYXRlKHNjaE9yRW52KTtcbiAgICAgICAgcmV0dXJuIGlubGluZVJlZlNjaGVtYShzY2hPckVudik7XG4gICAgICAgIGZ1bmN0aW9uIGNhbGxSb290UmVmKCkge1xuICAgICAgICAgICAgaWYgKGVudiA9PT0gcm9vdClcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbFJlZihjeHQsIHZhbGlkYXRlTmFtZSwgZW52LCBlbnYuJGFzeW5jKTtcbiAgICAgICAgICAgIGNvbnN0IHJvb3ROYW1lID0gZ2VuLnNjb3BlVmFsdWUoXCJyb290XCIsIHsgcmVmOiByb290IH0pO1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxSZWYoY3h0LCAoMCwgY29kZWdlbl8xLl8pIGAke3Jvb3ROYW1lfS52YWxpZGF0ZWAsIHJvb3QsIHJvb3QuJGFzeW5jKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjYWxsVmFsaWRhdGUoc2NoKSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gZ2V0VmFsaWRhdGUoY3h0LCBzY2gpO1xuICAgICAgICAgICAgY2FsbFJlZihjeHQsIHYsIHNjaCwgc2NoLiRhc3luYyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaW5saW5lUmVmU2NoZW1hKHNjaCkge1xuICAgICAgICAgICAgY29uc3Qgc2NoTmFtZSA9IGdlbi5zY29wZVZhbHVlKFwic2NoZW1hXCIsIG9wdHMuY29kZS5zb3VyY2UgPT09IHRydWUgPyB7IHJlZjogc2NoLCBjb2RlOiAoMCwgY29kZWdlbl8xLnN0cmluZ2lmeSkoc2NoKSB9IDogeyByZWY6IHNjaCB9KTtcbiAgICAgICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICAgICAgICAgIGNvbnN0IHNjaEN4dCA9IGN4dC5zdWJzY2hlbWEoe1xuICAgICAgICAgICAgICAgIHNjaGVtYTogc2NoLFxuICAgICAgICAgICAgICAgIGRhdGFUeXBlczogW10sXG4gICAgICAgICAgICAgICAgc2NoZW1hUGF0aDogY29kZWdlbl8xLm5pbCxcbiAgICAgICAgICAgICAgICB0b3BTY2hlbWFSZWY6IHNjaE5hbWUsXG4gICAgICAgICAgICAgICAgZXJyU2NoZW1hUGF0aDogJHJlZixcbiAgICAgICAgICAgIH0sIHZhbGlkKTtcbiAgICAgICAgICAgIGN4dC5tZXJnZUV2YWx1YXRlZChzY2hDeHQpO1xuICAgICAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZnVuY3Rpb24gZ2V0VmFsaWRhdGUoY3h0LCBzY2gpIHtcbiAgICBjb25zdCB7IGdlbiB9ID0gY3h0O1xuICAgIHJldHVybiBzY2gudmFsaWRhdGVcbiAgICAgICAgPyBnZW4uc2NvcGVWYWx1ZShcInZhbGlkYXRlXCIsIHsgcmVmOiBzY2gudmFsaWRhdGUgfSlcbiAgICAgICAgOiAoMCwgY29kZWdlbl8xLl8pIGAke2dlbi5zY29wZVZhbHVlKFwid3JhcHBlclwiLCB7IHJlZjogc2NoIH0pfS52YWxpZGF0ZWA7XG59XG5leHBvcnRzLmdldFZhbGlkYXRlID0gZ2V0VmFsaWRhdGU7XG5mdW5jdGlvbiBjYWxsUmVmKGN4dCwgdiwgc2NoLCAkYXN5bmMpIHtcbiAgICBjb25zdCB7IGdlbiwgaXQgfSA9IGN4dDtcbiAgICBjb25zdCB7IGFsbEVycm9ycywgc2NoZW1hRW52OiBlbnYsIG9wdHMgfSA9IGl0O1xuICAgIGNvbnN0IHBhc3NDeHQgPSBvcHRzLnBhc3NDb250ZXh0ID8gbmFtZXNfMS5kZWZhdWx0LnRoaXMgOiBjb2RlZ2VuXzEubmlsO1xuICAgIGlmICgkYXN5bmMpXG4gICAgICAgIGNhbGxBc3luY1JlZigpO1xuICAgIGVsc2VcbiAgICAgICAgY2FsbFN5bmNSZWYoKTtcbiAgICBmdW5jdGlvbiBjYWxsQXN5bmNSZWYoKSB7XG4gICAgICAgIGlmICghZW52LiRhc3luYylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFzeW5jIHNjaGVtYSByZWZlcmVuY2VkIGJ5IHN5bmMgc2NoZW1hXCIpO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiKTtcbiAgICAgICAgZ2VuLnRyeSgoKSA9PiB7XG4gICAgICAgICAgICBnZW4uY29kZSgoMCwgY29kZWdlbl8xLl8pIGBhd2FpdCAkeygwLCBjb2RlXzEuY2FsbFZhbGlkYXRlQ29kZSkoY3h0LCB2LCBwYXNzQ3h0KX1gKTtcbiAgICAgICAgICAgIGFkZEV2YWx1YXRlZEZyb20odik7IC8vIFRPRE8gd2lsbCBub3Qgd29yayB3aXRoIGFzeW5jLCBpdCBoYXMgdG8gYmUgcmV0dXJuZWQgd2l0aCB0aGUgcmVzdWx0XG4gICAgICAgICAgICBpZiAoIWFsbEVycm9ycylcbiAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCB0cnVlKTtcbiAgICAgICAgfSwgKGUpID0+IHtcbiAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAhKCR7ZX0gaW5zdGFuY2VvZiAke2l0LlZhbGlkYXRpb25FcnJvcn0pYCwgKCkgPT4gZ2VuLnRocm93KGUpKTtcbiAgICAgICAgICAgIGFkZEVycm9yc0Zyb20oZSk7XG4gICAgICAgICAgICBpZiAoIWFsbEVycm9ycylcbiAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCBmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjeHQub2sodmFsaWQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjYWxsU3luY1JlZigpIHtcbiAgICAgICAgY3h0LnJlc3VsdCgoMCwgY29kZV8xLmNhbGxWYWxpZGF0ZUNvZGUpKGN4dCwgdiwgcGFzc0N4dCksICgpID0+IGFkZEV2YWx1YXRlZEZyb20odiksICgpID0+IGFkZEVycm9yc0Zyb20odikpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZGRFcnJvcnNGcm9tKHNvdXJjZSkge1xuICAgICAgICBjb25zdCBlcnJzID0gKDAsIGNvZGVnZW5fMS5fKSBgJHtzb3VyY2V9LmVycm9yc2A7XG4gICAgICAgIGdlbi5hc3NpZ24obmFtZXNfMS5kZWZhdWx0LnZFcnJvcnMsICgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9ID09PSBudWxsID8gJHtlcnJzfSA6ICR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9LmNvbmNhdCgke2VycnN9KWApOyAvLyBUT0RPIHRhZ2dlZFxuICAgICAgICBnZW4uYXNzaWduKG5hbWVzXzEuZGVmYXVsdC5lcnJvcnMsICgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9Lmxlbmd0aGApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZGRFdmFsdWF0ZWRGcm9tKHNvdXJjZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghaXQub3B0cy51bmV2YWx1YXRlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3Qgc2NoRXZhbHVhdGVkID0gKF9hID0gc2NoID09PSBudWxsIHx8IHNjaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2NoLnZhbGlkYXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZXZhbHVhdGVkO1xuICAgICAgICAvLyBUT0RPIHJlZmFjdG9yXG4gICAgICAgIGlmIChpdC5wcm9wcyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgaWYgKHNjaEV2YWx1YXRlZCAmJiAhc2NoRXZhbHVhdGVkLmR5bmFtaWNQcm9wcykge1xuICAgICAgICAgICAgICAgIGlmIChzY2hFdmFsdWF0ZWQucHJvcHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBpdC5wcm9wcyA9IHV0aWxfMS5tZXJnZUV2YWx1YXRlZC5wcm9wcyhnZW4sIHNjaEV2YWx1YXRlZC5wcm9wcywgaXQucHJvcHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BzID0gZ2VuLnZhcihcInByb3BzXCIsICgwLCBjb2RlZ2VuXzEuXykgYCR7c291cmNlfS5ldmFsdWF0ZWQucHJvcHNgKTtcbiAgICAgICAgICAgICAgICBpdC5wcm9wcyA9IHV0aWxfMS5tZXJnZUV2YWx1YXRlZC5wcm9wcyhnZW4sIHByb3BzLCBpdC5wcm9wcywgY29kZWdlbl8xLk5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpdC5pdGVtcyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgaWYgKHNjaEV2YWx1YXRlZCAmJiAhc2NoRXZhbHVhdGVkLmR5bmFtaWNJdGVtcykge1xuICAgICAgICAgICAgICAgIGlmIChzY2hFdmFsdWF0ZWQuaXRlbXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBpdC5pdGVtcyA9IHV0aWxfMS5tZXJnZUV2YWx1YXRlZC5pdGVtcyhnZW4sIHNjaEV2YWx1YXRlZC5pdGVtcywgaXQuaXRlbXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1zID0gZ2VuLnZhcihcIml0ZW1zXCIsICgwLCBjb2RlZ2VuXzEuXykgYCR7c291cmNlfS5ldmFsdWF0ZWQuaXRlbXNgKTtcbiAgICAgICAgICAgICAgICBpdC5pdGVtcyA9IHV0aWxfMS5tZXJnZUV2YWx1YXRlZC5pdGVtcyhnZW4sIGl0ZW1zLCBpdC5pdGVtcywgY29kZWdlbl8xLk5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5jYWxsUmVmID0gY2FsbFJlZjtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGlkXzEgPSByZXF1aXJlKFwiLi9pZFwiKTtcbmNvbnN0IHJlZl8xID0gcmVxdWlyZShcIi4vcmVmXCIpO1xuY29uc3QgY29yZSA9IFtcbiAgICBcIiRzY2hlbWFcIixcbiAgICBcIiRpZFwiLFxuICAgIFwiJGRlZnNcIixcbiAgICBcIiR2b2NhYnVsYXJ5XCIsXG4gICAgeyBrZXl3b3JkOiBcIiRjb21tZW50XCIgfSxcbiAgICBcImRlZmluaXRpb25zXCIsXG4gICAgaWRfMS5kZWZhdWx0LFxuICAgIHJlZl8xLmRlZmF1bHQsXG5dO1xuZXhwb3J0cy5kZWZhdWx0ID0gY29yZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IG9wcyA9IGNvZGVnZW5fMS5vcGVyYXRvcnM7XG5jb25zdCBLV0RzID0ge1xuICAgIG1heGltdW06IHsgb2tTdHI6IFwiPD1cIiwgb2s6IG9wcy5MVEUsIGZhaWw6IG9wcy5HVCB9LFxuICAgIG1pbmltdW06IHsgb2tTdHI6IFwiPj1cIiwgb2s6IG9wcy5HVEUsIGZhaWw6IG9wcy5MVCB9LFxuICAgIGV4Y2x1c2l2ZU1heGltdW06IHsgb2tTdHI6IFwiPFwiLCBvazogb3BzLkxULCBmYWlsOiBvcHMuR1RFIH0sXG4gICAgZXhjbHVzaXZlTWluaW11bTogeyBva1N0cjogXCI+XCIsIG9rOiBvcHMuR1QsIGZhaWw6IG9wcy5MVEUgfSxcbn07XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBrZXl3b3JkLCBzY2hlbWFDb2RlIH0pID0+ICgwLCBjb2RlZ2VuXzEuc3RyKSBgbXVzdCBiZSAke0tXRHNba2V5d29yZF0ub2tTdHJ9ICR7c2NoZW1hQ29kZX1gLFxuICAgIHBhcmFtczogKHsga2V5d29yZCwgc2NoZW1hQ29kZSB9KSA9PiAoMCwgY29kZWdlbl8xLl8pIGB7Y29tcGFyaXNvbjogJHtLV0RzW2tleXdvcmRdLm9rU3RyfSwgbGltaXQ6ICR7c2NoZW1hQ29kZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogT2JqZWN0LmtleXMoS1dEcyksXG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBzY2hlbWFUeXBlOiBcIm51bWJlclwiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsga2V5d29yZCwgZGF0YSwgc2NoZW1hQ29kZSB9ID0gY3h0O1xuICAgICAgICBjeHQuZmFpbCRkYXRhKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0gJHtLV0RzW2tleXdvcmRdLmZhaWx9ICR7c2NoZW1hQ29kZX0gfHwgaXNOYU4oJHtkYXRhfSlgKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpbWl0TnVtYmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHNjaGVtYUNvZGUgfSkgPT4gKDAsIGNvZGVnZW5fMS5zdHIpIGBtdXN0IGJlIG11bHRpcGxlIG9mICR7c2NoZW1hQ29kZX1gLFxuICAgIHBhcmFtczogKHsgc2NoZW1hQ29kZSB9KSA9PiAoMCwgY29kZWdlbl8xLl8pIGB7bXVsdGlwbGVPZjogJHtzY2hlbWFDb2RlfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcIm11bHRpcGxlT2ZcIixcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIHNjaGVtYVR5cGU6IFwibnVtYmVyXCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIGRhdGEsIHNjaGVtYUNvZGUsIGl0IH0gPSBjeHQ7XG4gICAgICAgIC8vIGNvbnN0IGJkdCA9IGJhZCREYXRhVHlwZShzY2hlbWFDb2RlLCA8c3RyaW5nPmRlZi5zY2hlbWFUeXBlLCAkZGF0YSlcbiAgICAgICAgY29uc3QgcHJlYyA9IGl0Lm9wdHMubXVsdGlwbGVPZlByZWNpc2lvbjtcbiAgICAgICAgY29uc3QgcmVzID0gZ2VuLmxldChcInJlc1wiKTtcbiAgICAgICAgY29uc3QgaW52YWxpZCA9IHByZWNcbiAgICAgICAgICAgID8gKDAsIGNvZGVnZW5fMS5fKSBgTWF0aC5hYnMoTWF0aC5yb3VuZCgke3Jlc30pIC0gJHtyZXN9KSA+IDFlLSR7cHJlY31gXG4gICAgICAgICAgICA6ICgwLCBjb2RlZ2VuXzEuXykgYCR7cmVzfSAhPT0gcGFyc2VJbnQoJHtyZXN9KWA7XG4gICAgICAgIGN4dC5mYWlsJGRhdGEoKDAsIGNvZGVnZW5fMS5fKSBgKCR7c2NoZW1hQ29kZX0gPT09IDAgfHwgKCR7cmVzfSA9ICR7ZGF0YX0vJHtzY2hlbWFDb2RlfSwgJHtpbnZhbGlkfSkpYCk7XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tdWx0aXBsZU9mLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8gaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmdcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iZXN0aWVqcy9wdW55Y29kZS5qcyAtIHB1bnljb2RlLnVjczIuZGVjb2RlXG5mdW5jdGlvbiB1Y3MybGVuZ3RoKHN0cikge1xuICAgIGNvbnN0IGxlbiA9IHN0ci5sZW5ndGg7XG4gICAgbGV0IGxlbmd0aCA9IDA7XG4gICAgbGV0IHBvcyA9IDA7XG4gICAgbGV0IHZhbHVlO1xuICAgIHdoaWxlIChwb3MgPCBsZW4pIHtcbiAgICAgICAgbGVuZ3RoKys7XG4gICAgICAgIHZhbHVlID0gc3RyLmNoYXJDb2RlQXQocG9zKyspO1xuICAgICAgICBpZiAodmFsdWUgPj0gMHhkODAwICYmIHZhbHVlIDw9IDB4ZGJmZiAmJiBwb3MgPCBsZW4pIHtcbiAgICAgICAgICAgIC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuICAgICAgICAgICAgdmFsdWUgPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICAgICAgaWYgKCh2YWx1ZSAmIDB4ZmMwMCkgPT09IDB4ZGMwMClcbiAgICAgICAgICAgICAgICBwb3MrKzsgLy8gbG93IHN1cnJvZ2F0ZVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsZW5ndGg7XG59XG5leHBvcnRzLmRlZmF1bHQgPSB1Y3MybGVuZ3RoO1xudWNzMmxlbmd0aC5jb2RlID0gJ3JlcXVpcmUoXCJhanYvZGlzdC9ydW50aW1lL3VjczJsZW5ndGhcIikuZGVmYXVsdCc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11Y3MybGVuZ3RoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCB1Y3MybGVuZ3RoXzEgPSByZXF1aXJlKFwiLi4vLi4vcnVudGltZS91Y3MybGVuZ3RoXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZSh7IGtleXdvcmQsIHNjaGVtYUNvZGUgfSkge1xuICAgICAgICBjb25zdCBjb21wID0ga2V5d29yZCA9PT0gXCJtYXhMZW5ndGhcIiA/IFwibW9yZVwiIDogXCJmZXdlclwiO1xuICAgICAgICByZXR1cm4gKDAsIGNvZGVnZW5fMS5zdHIpIGBtdXN0IE5PVCBoYXZlICR7Y29tcH0gdGhhbiAke3NjaGVtYUNvZGV9IGNoYXJhY3RlcnNgO1xuICAgIH0sXG4gICAgcGFyYW1zOiAoeyBzY2hlbWFDb2RlIH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHtsaW1pdDogJHtzY2hlbWFDb2RlfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBbXCJtYXhMZW5ndGhcIiwgXCJtaW5MZW5ndGhcIl0sXG4gICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICBzY2hlbWFUeXBlOiBcIm51bWJlclwiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsga2V5d29yZCwgZGF0YSwgc2NoZW1hQ29kZSwgaXQgfSA9IGN4dDtcbiAgICAgICAgY29uc3Qgb3AgPSBrZXl3b3JkID09PSBcIm1heExlbmd0aFwiID8gY29kZWdlbl8xLm9wZXJhdG9ycy5HVCA6IGNvZGVnZW5fMS5vcGVyYXRvcnMuTFQ7XG4gICAgICAgIGNvbnN0IGxlbiA9IGl0Lm9wdHMudW5pY29kZSA9PT0gZmFsc2UgPyAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9Lmxlbmd0aGAgOiAoMCwgY29kZWdlbl8xLl8pIGAkeygwLCB1dGlsXzEudXNlRnVuYykoY3h0LmdlbiwgdWNzMmxlbmd0aF8xLmRlZmF1bHQpfSgke2RhdGF9KWA7XG4gICAgICAgIGN4dC5mYWlsJGRhdGEoKDAsIGNvZGVnZW5fMS5fKSBgJHtsZW59ICR7b3B9ICR7c2NoZW1hQ29kZX1gKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpbWl0TGVuZ3RoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uL2NvZGVcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsgc2NoZW1hQ29kZSB9KSA9PiAoMCwgY29kZWdlbl8xLnN0cikgYG11c3QgbWF0Y2ggcGF0dGVybiBcIiR7c2NoZW1hQ29kZX1cImAsXG4gICAgcGFyYW1zOiAoeyBzY2hlbWFDb2RlIH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHtwYXR0ZXJuOiAke3NjaGVtYUNvZGV9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwicGF0dGVyblwiLFxuICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgc2NoZW1hVHlwZTogXCJzdHJpbmdcIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGRhdGEsICRkYXRhLCBzY2hlbWEsIHNjaGVtYUNvZGUsIGl0IH0gPSBjeHQ7XG4gICAgICAgIC8vIFRPRE8gcmVnZXhwIHNob3VsZCBiZSB3cmFwcGVkIGluIHRyeS9jYXRjaHNcbiAgICAgICAgY29uc3QgdSA9IGl0Lm9wdHMudW5pY29kZVJlZ0V4cCA/IFwidVwiIDogXCJcIjtcbiAgICAgICAgY29uc3QgcmVnRXhwID0gJGRhdGEgPyAoMCwgY29kZWdlbl8xLl8pIGAobmV3IFJlZ0V4cCgke3NjaGVtYUNvZGV9LCAke3V9KSlgIDogKDAsIGNvZGVfMS51c2VQYXR0ZXJuKShjeHQsIHNjaGVtYSk7XG4gICAgICAgIGN4dC5mYWlsJGRhdGEoKDAsIGNvZGVnZW5fMS5fKSBgISR7cmVnRXhwfS50ZXN0KCR7ZGF0YX0pYCk7XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXR0ZXJuLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2UoeyBrZXl3b3JkLCBzY2hlbWFDb2RlIH0pIHtcbiAgICAgICAgY29uc3QgY29tcCA9IGtleXdvcmQgPT09IFwibWF4UHJvcGVydGllc1wiID8gXCJtb3JlXCIgOiBcImZld2VyXCI7XG4gICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLnN0cikgYG11c3QgTk9UIGhhdmUgJHtjb21wfSB0aGFuICR7c2NoZW1hQ29kZX0gcHJvcGVydGllc2A7XG4gICAgfSxcbiAgICBwYXJhbXM6ICh7IHNjaGVtYUNvZGUgfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge2xpbWl0OiAke3NjaGVtYUNvZGV9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFtcIm1heFByb3BlcnRpZXNcIiwgXCJtaW5Qcm9wZXJ0aWVzXCJdLFxuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgc2NoZW1hVHlwZTogXCJudW1iZXJcIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGtleXdvcmQsIGRhdGEsIHNjaGVtYUNvZGUgfSA9IGN4dDtcbiAgICAgICAgY29uc3Qgb3AgPSBrZXl3b3JkID09PSBcIm1heFByb3BlcnRpZXNcIiA/IGNvZGVnZW5fMS5vcGVyYXRvcnMuR1QgOiBjb2RlZ2VuXzEub3BlcmF0b3JzLkxUO1xuICAgICAgICBjeHQuZmFpbCRkYXRhKCgwLCBjb2RlZ2VuXzEuXykgYE9iamVjdC5rZXlzKCR7ZGF0YX0pLmxlbmd0aCAke29wfSAke3NjaGVtYUNvZGV9YCk7XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saW1pdFByb3BlcnRpZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi4vY29kZVwiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsgcGFyYW1zOiB7IG1pc3NpbmdQcm9wZXJ0eSB9IH0pID0+ICgwLCBjb2RlZ2VuXzEuc3RyKSBgbXVzdCBoYXZlIHJlcXVpcmVkIHByb3BlcnR5ICcke21pc3NpbmdQcm9wZXJ0eX0nYCxcbiAgICBwYXJhbXM6ICh7IHBhcmFtczogeyBtaXNzaW5nUHJvcGVydHkgfSB9KSA9PiAoMCwgY29kZWdlbl8xLl8pIGB7bWlzc2luZ1Byb3BlcnR5OiAke21pc3NpbmdQcm9wZXJ0eX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJyZXF1aXJlZFwiLFxuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgc2NoZW1hVHlwZTogXCJhcnJheVwiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIHNjaGVtYUNvZGUsIGRhdGEsICRkYXRhLCBpdCB9ID0gY3h0O1xuICAgICAgICBjb25zdCB7IG9wdHMgfSA9IGl0O1xuICAgICAgICBpZiAoISRkYXRhICYmIHNjaGVtYS5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHVzZUxvb3AgPSBzY2hlbWEubGVuZ3RoID49IG9wdHMubG9vcFJlcXVpcmVkO1xuICAgICAgICBpZiAoaXQuYWxsRXJyb3JzKVxuICAgICAgICAgICAgYWxsRXJyb3JzTW9kZSgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBleGl0T25FcnJvck1vZGUoKTtcbiAgICAgICAgaWYgKG9wdHMuc3RyaWN0UmVxdWlyZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3BzID0gY3h0LnBhcmVudFNjaGVtYS5wcm9wZXJ0aWVzO1xuICAgICAgICAgICAgY29uc3QgeyBkZWZpbmVkUHJvcGVydGllcyB9ID0gY3h0Lml0O1xuICAgICAgICAgICAgZm9yIChjb25zdCByZXF1aXJlZEtleSBvZiBzY2hlbWEpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHByb3BzID09PSBudWxsIHx8IHByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm9wc1tyZXF1aXJlZEtleV0pID09PSB1bmRlZmluZWQgJiYgIWRlZmluZWRQcm9wZXJ0aWVzLmhhcyhyZXF1aXJlZEtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2NoZW1hUGF0aCA9IGl0LnNjaGVtYUVudi5iYXNlSWQgKyBpdC5lcnJTY2hlbWFQYXRoO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSBgcmVxdWlyZWQgcHJvcGVydHkgXCIke3JlcXVpcmVkS2V5fVwiIGlzIG5vdCBkZWZpbmVkIGF0IFwiJHtzY2hlbWFQYXRofVwiIChzdHJpY3RSZXF1aXJlZClgO1xuICAgICAgICAgICAgICAgICAgICAoMCwgdXRpbF8xLmNoZWNrU3RyaWN0TW9kZSkoaXQsIG1zZywgaXQub3B0cy5zdHJpY3RSZXF1aXJlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFsbEVycm9yc01vZGUoKSB7XG4gICAgICAgICAgICBpZiAodXNlTG9vcCB8fCAkZGF0YSkge1xuICAgICAgICAgICAgICAgIGN4dC5ibG9jayRkYXRhKGNvZGVnZW5fMS5uaWwsIGxvb3BBbGxSZXF1aXJlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHByb3Agb2Ygc2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgICgwLCBjb2RlXzEuY2hlY2tSZXBvcnRNaXNzaW5nUHJvcCkoY3h0LCBwcm9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZXhpdE9uRXJyb3JNb2RlKCkge1xuICAgICAgICAgICAgY29uc3QgbWlzc2luZyA9IGdlbi5sZXQoXCJtaXNzaW5nXCIpO1xuICAgICAgICAgICAgaWYgKHVzZUxvb3AgfHwgJGRhdGEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBjeHQuYmxvY2skZGF0YSh2YWxpZCwgKCkgPT4gbG9vcFVudGlsTWlzc2luZyhtaXNzaW5nLCB2YWxpZCkpO1xuICAgICAgICAgICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVfMS5jaGVja01pc3NpbmdQcm9wKShjeHQsIHNjaGVtYSwgbWlzc2luZykpO1xuICAgICAgICAgICAgICAgICgwLCBjb2RlXzEucmVwb3J0TWlzc2luZ1Byb3ApKGN4dCwgbWlzc2luZyk7XG4gICAgICAgICAgICAgICAgZ2VuLmVsc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBsb29wQWxsUmVxdWlyZWQoKSB7XG4gICAgICAgICAgICBnZW4uZm9yT2YoXCJwcm9wXCIsIHNjaGVtYUNvZGUsIChwcm9wKSA9PiB7XG4gICAgICAgICAgICAgICAgY3h0LnNldFBhcmFtcyh7IG1pc3NpbmdQcm9wZXJ0eTogcHJvcCB9KTtcbiAgICAgICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVfMS5ub1Byb3BlcnR5SW5EYXRhKShnZW4sIGRhdGEsIHByb3AsIG9wdHMub3duUHJvcGVydGllcyksICgpID0+IGN4dC5lcnJvcigpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGxvb3BVbnRpbE1pc3NpbmcobWlzc2luZywgdmFsaWQpIHtcbiAgICAgICAgICAgIGN4dC5zZXRQYXJhbXMoeyBtaXNzaW5nUHJvcGVydHk6IG1pc3NpbmcgfSk7XG4gICAgICAgICAgICBnZW4uZm9yT2YobWlzc2luZywgc2NoZW1hQ29kZSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsICgwLCBjb2RlXzEucHJvcGVydHlJbkRhdGEpKGdlbiwgZGF0YSwgbWlzc2luZywgb3B0cy5vd25Qcm9wZXJ0aWVzKSk7XG4gICAgICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEubm90KSh2YWxpZCksICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY3h0LmVycm9yKCk7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5icmVhaygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgY29kZWdlbl8xLm5pbCk7XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlcXVpcmVkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2UoeyBrZXl3b3JkLCBzY2hlbWFDb2RlIH0pIHtcbiAgICAgICAgY29uc3QgY29tcCA9IGtleXdvcmQgPT09IFwibWF4SXRlbXNcIiA/IFwibW9yZVwiIDogXCJmZXdlclwiO1xuICAgICAgICByZXR1cm4gKDAsIGNvZGVnZW5fMS5zdHIpIGBtdXN0IE5PVCBoYXZlICR7Y29tcH0gdGhhbiAke3NjaGVtYUNvZGV9IGl0ZW1zYDtcbiAgICB9LFxuICAgIHBhcmFtczogKHsgc2NoZW1hQ29kZSB9KSA9PiAoMCwgY29kZWdlbl8xLl8pIGB7bGltaXQ6ICR7c2NoZW1hQ29kZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogW1wibWF4SXRlbXNcIiwgXCJtaW5JdGVtc1wiXSxcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgc2NoZW1hVHlwZTogXCJudW1iZXJcIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGtleXdvcmQsIGRhdGEsIHNjaGVtYUNvZGUgfSA9IGN4dDtcbiAgICAgICAgY29uc3Qgb3AgPSBrZXl3b3JkID09PSBcIm1heEl0ZW1zXCIgPyBjb2RlZ2VuXzEub3BlcmF0b3JzLkdUIDogY29kZWdlbl8xLm9wZXJhdG9ycy5MVDtcbiAgICAgICAgY3h0LmZhaWwkZGF0YSgoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9Lmxlbmd0aCAke29wfSAke3NjaGVtYUNvZGV9YCk7XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saW1pdEl0ZW1zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Fqdi12YWxpZGF0b3IvYWp2L2lzc3Vlcy84ODlcbmNvbnN0IGVxdWFsID0gcmVxdWlyZShcImZhc3QtZGVlcC1lcXVhbFwiKTtcbmVxdWFsLmNvZGUgPSAncmVxdWlyZShcImFqdi9kaXN0L3J1bnRpbWUvZXF1YWxcIikuZGVmYXVsdCc7XG5leHBvcnRzLmRlZmF1bHQgPSBlcXVhbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVxdWFsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgZGF0YVR5cGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlL2RhdGFUeXBlXCIpO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBlcXVhbF8xID0gcmVxdWlyZShcIi4uLy4uL3J1bnRpbWUvZXF1YWxcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBwYXJhbXM6IHsgaSwgaiB9IH0pID0+ICgwLCBjb2RlZ2VuXzEuc3RyKSBgbXVzdCBOT1QgaGF2ZSBkdXBsaWNhdGUgaXRlbXMgKGl0ZW1zICMjICR7an0gYW5kICR7aX0gYXJlIGlkZW50aWNhbClgLFxuICAgIHBhcmFtczogKHsgcGFyYW1zOiB7IGksIGogfSB9KSA9PiAoMCwgY29kZWdlbl8xLl8pIGB7aTogJHtpfSwgajogJHtqfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcInVuaXF1ZUl0ZW1zXCIsXG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHNjaGVtYVR5cGU6IFwiYm9vbGVhblwiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCAkZGF0YSwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIHNjaGVtYUNvZGUsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGlmICghJGRhdGEgJiYgIXNjaGVtYSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIik7XG4gICAgICAgIGNvbnN0IGl0ZW1UeXBlcyA9IHBhcmVudFNjaGVtYS5pdGVtcyA/ICgwLCBkYXRhVHlwZV8xLmdldFNjaGVtYVR5cGVzKShwYXJlbnRTY2hlbWEuaXRlbXMpIDogW107XG4gICAgICAgIGN4dC5ibG9jayRkYXRhKHZhbGlkLCB2YWxpZGF0ZVVuaXF1ZUl0ZW1zLCAoMCwgY29kZWdlbl8xLl8pIGAke3NjaGVtYUNvZGV9ID09PSBmYWxzZWApO1xuICAgICAgICBjeHQub2sodmFsaWQpO1xuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZVVuaXF1ZUl0ZW1zKCkge1xuICAgICAgICAgICAgY29uc3QgaSA9IGdlbi5sZXQoXCJpXCIsICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0ubGVuZ3RoYCk7XG4gICAgICAgICAgICBjb25zdCBqID0gZ2VuLmxldChcImpcIik7XG4gICAgICAgICAgICBjeHQuc2V0UGFyYW1zKHsgaSwgaiB9KTtcbiAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIHRydWUpO1xuICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7aX0gPiAxYCwgKCkgPT4gKGNhbk9wdGltaXplKCkgPyBsb29wTiA6IGxvb3BOMikoaSwgaikpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNhbk9wdGltaXplKCkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW1UeXBlcy5sZW5ndGggPiAwICYmICFpdGVtVHlwZXMuc29tZSgodCkgPT4gdCA9PT0gXCJvYmplY3RcIiB8fCB0ID09PSBcImFycmF5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGxvb3BOKGksIGopIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBnZW4ubmFtZShcIml0ZW1cIik7XG4gICAgICAgICAgICBjb25zdCB3cm9uZ1R5cGUgPSAoMCwgZGF0YVR5cGVfMS5jaGVja0RhdGFUeXBlcykoaXRlbVR5cGVzLCBpdGVtLCBpdC5vcHRzLnN0cmljdE51bWJlcnMsIGRhdGFUeXBlXzEuRGF0YVR5cGUuV3JvbmcpO1xuICAgICAgICAgICAgY29uc3QgaW5kaWNlcyA9IGdlbi5jb25zdChcImluZGljZXNcIiwgKDAsIGNvZGVnZW5fMS5fKSBge31gKTtcbiAgICAgICAgICAgIGdlbi5mb3IoKDAsIGNvZGVnZW5fMS5fKSBgOyR7aX0tLTtgLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZ2VuLmxldChpdGVtLCAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9WyR7aX1dYCk7XG4gICAgICAgICAgICAgICAgZ2VuLmlmKHdyb25nVHlwZSwgKDAsIGNvZGVnZW5fMS5fKSBgY29udGludWVgKTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbVR5cGVzLmxlbmd0aCA+IDEpXG4gICAgICAgICAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGB0eXBlb2YgJHtpdGVtfSA9PSBcInN0cmluZ1wiYCwgKDAsIGNvZGVnZW5fMS5fKSBgJHtpdGVtfSArPSBcIl9cImApO1xuICAgICAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgICAgICAgICAuaWYoKDAsIGNvZGVnZW5fMS5fKSBgdHlwZW9mICR7aW5kaWNlc31bJHtpdGVtfV0gPT0gXCJudW1iZXJcImAsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbihqLCAoMCwgY29kZWdlbl8xLl8pIGAke2luZGljZXN9WyR7aXRlbX1dYCk7XG4gICAgICAgICAgICAgICAgICAgIGN4dC5lcnJvcigpO1xuICAgICAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCBmYWxzZSkuYnJlYWsoKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuY29kZSgoMCwgY29kZWdlbl8xLl8pIGAke2luZGljZXN9WyR7aXRlbX1dID0gJHtpfWApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbG9vcE4yKGksIGopIHtcbiAgICAgICAgICAgIGNvbnN0IGVxbCA9ICgwLCB1dGlsXzEudXNlRnVuYykoZ2VuLCBlcXVhbF8xLmRlZmF1bHQpO1xuICAgICAgICAgICAgY29uc3Qgb3V0ZXIgPSBnZW4ubmFtZShcIm91dGVyXCIpO1xuICAgICAgICAgICAgZ2VuLmxhYmVsKG91dGVyKS5mb3IoKDAsIGNvZGVnZW5fMS5fKSBgOyR7aX0tLTtgLCAoKSA9PiBnZW4uZm9yKCgwLCBjb2RlZ2VuXzEuXykgYCR7an0gPSAke2l9OyAke2p9LS07YCwgKCkgPT4gZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZXFsfSgke2RhdGF9WyR7aX1dLCAke2RhdGF9WyR7an1dKWAsICgpID0+IHtcbiAgICAgICAgICAgICAgICBjeHQuZXJyb3IoKTtcbiAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCBmYWxzZSkuYnJlYWsob3V0ZXIpO1xuICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dW5pcXVlSXRlbXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVxdWFsXzEgPSByZXF1aXJlKFwiLi4vLi4vcnVudGltZS9lcXVhbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6IFwibXVzdCBiZSBlcXVhbCB0byBjb25zdGFudFwiLFxuICAgIHBhcmFtczogKHsgc2NoZW1hQ29kZSB9KSA9PiAoMCwgY29kZWdlbl8xLl8pIGB7YWxsb3dlZFZhbHVlOiAke3NjaGVtYUNvZGV9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiY29uc3RcIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgZGF0YSwgJGRhdGEsIHNjaGVtYUNvZGUsIHNjaGVtYSB9ID0gY3h0O1xuICAgICAgICBpZiAoJGRhdGEgfHwgKHNjaGVtYSAmJiB0eXBlb2Ygc2NoZW1hID09IFwib2JqZWN0XCIpKSB7XG4gICAgICAgICAgICBjeHQuZmFpbCRkYXRhKCgwLCBjb2RlZ2VuXzEuXykgYCEkeygwLCB1dGlsXzEudXNlRnVuYykoZ2VuLCBlcXVhbF8xLmRlZmF1bHQpfSgke2RhdGF9LCAke3NjaGVtYUNvZGV9KWApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3h0LmZhaWwoKDAsIGNvZGVnZW5fMS5fKSBgJHtzY2hlbWF9ICE9PSAke2RhdGF9YCk7XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBlcXVhbF8xID0gcmVxdWlyZShcIi4uLy4uL3J1bnRpbWUvZXF1YWxcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiBcIm11c3QgYmUgZXF1YWwgdG8gb25lIG9mIHRoZSBhbGxvd2VkIHZhbHVlc1wiLFxuICAgIHBhcmFtczogKHsgc2NoZW1hQ29kZSB9KSA9PiAoMCwgY29kZWdlbl8xLl8pIGB7YWxsb3dlZFZhbHVlczogJHtzY2hlbWFDb2RlfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImVudW1cIixcbiAgICBzY2hlbWFUeXBlOiBcImFycmF5XCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIGRhdGEsICRkYXRhLCBzY2hlbWEsIHNjaGVtYUNvZGUsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGlmICghJGRhdGEgJiYgc2NoZW1hLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImVudW0gbXVzdCBoYXZlIG5vbi1lbXB0eSBhcnJheVwiKTtcbiAgICAgICAgY29uc3QgdXNlTG9vcCA9IHNjaGVtYS5sZW5ndGggPj0gaXQub3B0cy5sb29wRW51bTtcbiAgICAgICAgbGV0IGVxbDtcbiAgICAgICAgY29uc3QgZ2V0RXFsID0gKCkgPT4gKGVxbCAhPT0gbnVsbCAmJiBlcWwgIT09IHZvaWQgMCA/IGVxbCA6IChlcWwgPSAoMCwgdXRpbF8xLnVzZUZ1bmMpKGdlbiwgZXF1YWxfMS5kZWZhdWx0KSkpO1xuICAgICAgICBsZXQgdmFsaWQ7XG4gICAgICAgIGlmICh1c2VMb29wIHx8ICRkYXRhKSB7XG4gICAgICAgICAgICB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiKTtcbiAgICAgICAgICAgIGN4dC5ibG9jayRkYXRhKHZhbGlkLCBsb29wRW51bSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzY2hlbWEpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFqdiBpbXBsZW1lbnRhdGlvbiBlcnJvclwiKTtcbiAgICAgICAgICAgIGNvbnN0IHZTY2hlbWEgPSBnZW4uY29uc3QoXCJ2U2NoZW1hXCIsIHNjaGVtYUNvZGUpO1xuICAgICAgICAgICAgdmFsaWQgPSAoMCwgY29kZWdlbl8xLm9yKSguLi5zY2hlbWEubWFwKChfeCwgaSkgPT4gZXF1YWxDb2RlKHZTY2hlbWEsIGkpKSk7XG4gICAgICAgIH1cbiAgICAgICAgY3h0LnBhc3ModmFsaWQpO1xuICAgICAgICBmdW5jdGlvbiBsb29wRW51bSgpIHtcbiAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIGZhbHNlKTtcbiAgICAgICAgICAgIGdlbi5mb3JPZihcInZcIiwgc2NoZW1hQ29kZSwgKHYpID0+IGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke2dldEVxbCgpfSgke2RhdGF9LCAke3Z9KWAsICgpID0+IGdlbi5hc3NpZ24odmFsaWQsIHRydWUpLmJyZWFrKCkpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBlcXVhbENvZGUodlNjaGVtYSwgaSkge1xuICAgICAgICAgICAgY29uc3Qgc2NoID0gc2NoZW1hW2ldO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBzY2ggPT09IFwib2JqZWN0XCIgJiYgc2NoICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyAoMCwgY29kZWdlbl8xLl8pIGAke2dldEVxbCgpfSgke2RhdGF9LCAke3ZTY2hlbWF9WyR7aX1dKWBcbiAgICAgICAgICAgICAgICA6ICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0gPT09ICR7c2NofWA7XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVudW0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBsaW1pdE51bWJlcl8xID0gcmVxdWlyZShcIi4vbGltaXROdW1iZXJcIik7XG5jb25zdCBtdWx0aXBsZU9mXzEgPSByZXF1aXJlKFwiLi9tdWx0aXBsZU9mXCIpO1xuY29uc3QgbGltaXRMZW5ndGhfMSA9IHJlcXVpcmUoXCIuL2xpbWl0TGVuZ3RoXCIpO1xuY29uc3QgcGF0dGVybl8xID0gcmVxdWlyZShcIi4vcGF0dGVyblwiKTtcbmNvbnN0IGxpbWl0UHJvcGVydGllc18xID0gcmVxdWlyZShcIi4vbGltaXRQcm9wZXJ0aWVzXCIpO1xuY29uc3QgcmVxdWlyZWRfMSA9IHJlcXVpcmUoXCIuL3JlcXVpcmVkXCIpO1xuY29uc3QgbGltaXRJdGVtc18xID0gcmVxdWlyZShcIi4vbGltaXRJdGVtc1wiKTtcbmNvbnN0IHVuaXF1ZUl0ZW1zXzEgPSByZXF1aXJlKFwiLi91bmlxdWVJdGVtc1wiKTtcbmNvbnN0IGNvbnN0XzEgPSByZXF1aXJlKFwiLi9jb25zdFwiKTtcbmNvbnN0IGVudW1fMSA9IHJlcXVpcmUoXCIuL2VudW1cIik7XG5jb25zdCB2YWxpZGF0aW9uID0gW1xuICAgIC8vIG51bWJlclxuICAgIGxpbWl0TnVtYmVyXzEuZGVmYXVsdCxcbiAgICBtdWx0aXBsZU9mXzEuZGVmYXVsdCxcbiAgICAvLyBzdHJpbmdcbiAgICBsaW1pdExlbmd0aF8xLmRlZmF1bHQsXG4gICAgcGF0dGVybl8xLmRlZmF1bHQsXG4gICAgLy8gb2JqZWN0XG4gICAgbGltaXRQcm9wZXJ0aWVzXzEuZGVmYXVsdCxcbiAgICByZXF1aXJlZF8xLmRlZmF1bHQsXG4gICAgLy8gYXJyYXlcbiAgICBsaW1pdEl0ZW1zXzEuZGVmYXVsdCxcbiAgICB1bmlxdWVJdGVtc18xLmRlZmF1bHQsXG4gICAgLy8gYW55XG4gICAgeyBrZXl3b3JkOiBcInR5cGVcIiwgc2NoZW1hVHlwZTogW1wic3RyaW5nXCIsIFwiYXJyYXlcIl0gfSxcbiAgICB7IGtleXdvcmQ6IFwibnVsbGFibGVcIiwgc2NoZW1hVHlwZTogXCJib29sZWFuXCIgfSxcbiAgICBjb25zdF8xLmRlZmF1bHQsXG4gICAgZW51bV8xLmRlZmF1bHQsXG5dO1xuZXhwb3J0cy5kZWZhdWx0ID0gdmFsaWRhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52YWxpZGF0ZUFkZGl0aW9uYWxJdGVtcyA9IHZvaWQgMDtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsgcGFyYW1zOiB7IGxlbiB9IH0pID0+ICgwLCBjb2RlZ2VuXzEuc3RyKSBgbXVzdCBOT1QgaGF2ZSBtb3JlIHRoYW4gJHtsZW59IGl0ZW1zYCxcbiAgICBwYXJhbXM6ICh7IHBhcmFtczogeyBsZW4gfSB9KSA9PiAoMCwgY29kZWdlbl8xLl8pIGB7bGltaXQ6ICR7bGVufX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImFkZGl0aW9uYWxJdGVtc1wiLFxuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBzY2hlbWFUeXBlOiBbXCJib29sZWFuXCIsIFwib2JqZWN0XCJdLFxuICAgIGJlZm9yZTogXCJ1bmlxdWVJdGVtc1wiLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgcGFyZW50U2NoZW1hLCBpdCB9ID0gY3h0O1xuICAgICAgICBjb25zdCB7IGl0ZW1zIH0gPSBwYXJlbnRTY2hlbWE7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpdGVtcykpIHtcbiAgICAgICAgICAgICgwLCB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKShpdCwgJ1wiYWRkaXRpb25hbEl0ZW1zXCIgaXMgaWdub3JlZCB3aGVuIFwiaXRlbXNcIiBpcyBub3QgYW4gYXJyYXkgb2Ygc2NoZW1hcycpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhbGlkYXRlQWRkaXRpb25hbEl0ZW1zKGN4dCwgaXRlbXMpO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gdmFsaWRhdGVBZGRpdGlvbmFsSXRlbXMoY3h0LCBpdGVtcykge1xuICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIGRhdGEsIGtleXdvcmQsIGl0IH0gPSBjeHQ7XG4gICAgaXQuaXRlbXMgPSB0cnVlO1xuICAgIGNvbnN0IGxlbiA9IGdlbi5jb25zdChcImxlblwiLCAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9Lmxlbmd0aGApO1xuICAgIGlmIChzY2hlbWEgPT09IGZhbHNlKSB7XG4gICAgICAgIGN4dC5zZXRQYXJhbXMoeyBsZW46IGl0ZW1zLmxlbmd0aCB9KTtcbiAgICAgICAgY3h0LnBhc3MoKDAsIGNvZGVnZW5fMS5fKSBgJHtsZW59IDw9ICR7aXRlbXMubGVuZ3RofWApO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Ygc2NoZW1hID09IFwib2JqZWN0XCIgJiYgISgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2hlbWEpKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLnZhcihcInZhbGlkXCIsICgwLCBjb2RlZ2VuXzEuXykgYCR7bGVufSA8PSAke2l0ZW1zLmxlbmd0aH1gKTsgLy8gVE9ETyB2YXJcbiAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEubm90KSh2YWxpZCksICgpID0+IHZhbGlkYXRlSXRlbXModmFsaWQpKTtcbiAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVJdGVtcyh2YWxpZCkge1xuICAgICAgICBnZW4uZm9yUmFuZ2UoXCJpXCIsIGl0ZW1zLmxlbmd0aCwgbGVuLCAoaSkgPT4ge1xuICAgICAgICAgICAgY3h0LnN1YnNjaGVtYSh7IGtleXdvcmQsIGRhdGFQcm9wOiBpLCBkYXRhUHJvcFR5cGU6IHV0aWxfMS5UeXBlLk51bSB9LCB2YWxpZCk7XG4gICAgICAgICAgICBpZiAoIWl0LmFsbEVycm9ycylcbiAgICAgICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5ub3QpKHZhbGlkKSwgKCkgPT4gZ2VuLmJyZWFrKCkpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlQWRkaXRpb25hbEl0ZW1zID0gdmFsaWRhdGVBZGRpdGlvbmFsSXRlbXM7XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRpdGlvbmFsSXRlbXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlVHVwbGUgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi9jb2RlXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiaXRlbXNcIixcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgc2NoZW1hVHlwZTogW1wib2JqZWN0XCIsIFwiYXJyYXlcIiwgXCJib29sZWFuXCJdLFxuICAgIGJlZm9yZTogXCJ1bmlxdWVJdGVtc1wiLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgc2NoZW1hLCBpdCB9ID0gY3h0O1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEpKVxuICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlVHVwbGUoY3h0LCBcImFkZGl0aW9uYWxJdGVtc1wiLCBzY2hlbWEpO1xuICAgICAgICBpdC5pdGVtcyA9IHRydWU7XG4gICAgICAgIGlmICgoMCwgdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKShpdCwgc2NoZW1hKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY3h0Lm9rKCgwLCBjb2RlXzEudmFsaWRhdGVBcnJheSkoY3h0KSk7XG4gICAgfSxcbn07XG5mdW5jdGlvbiB2YWxpZGF0ZVR1cGxlKGN4dCwgZXh0cmFJdGVtcywgc2NoQXJyID0gY3h0LnNjaGVtYSkge1xuICAgIGNvbnN0IHsgZ2VuLCBwYXJlbnRTY2hlbWEsIGRhdGEsIGtleXdvcmQsIGl0IH0gPSBjeHQ7XG4gICAgY2hlY2tTdHJpY3RUdXBsZShwYXJlbnRTY2hlbWEpO1xuICAgIGlmIChpdC5vcHRzLnVuZXZhbHVhdGVkICYmIHNjaEFyci5sZW5ndGggJiYgaXQuaXRlbXMgIT09IHRydWUpIHtcbiAgICAgICAgaXQuaXRlbXMgPSB1dGlsXzEubWVyZ2VFdmFsdWF0ZWQuaXRlbXMoZ2VuLCBzY2hBcnIubGVuZ3RoLCBpdC5pdGVtcyk7XG4gICAgfVxuICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICBjb25zdCBsZW4gPSBnZW4uY29uc3QoXCJsZW5cIiwgKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfS5sZW5ndGhgKTtcbiAgICBzY2hBcnIuZm9yRWFjaCgoc2NoLCBpKSA9PiB7XG4gICAgICAgIGlmICgoMCwgdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKShpdCwgc2NoKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7bGVufSA+ICR7aX1gLCAoKSA9PiBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgIGtleXdvcmQsXG4gICAgICAgICAgICBzY2hlbWFQcm9wOiBpLFxuICAgICAgICAgICAgZGF0YVByb3A6IGksXG4gICAgICAgIH0sIHZhbGlkKSk7XG4gICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gY2hlY2tTdHJpY3RUdXBsZShzY2gpIHtcbiAgICAgICAgY29uc3QgeyBvcHRzLCBlcnJTY2hlbWFQYXRoIH0gPSBpdDtcbiAgICAgICAgY29uc3QgbCA9IHNjaEFyci5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGZ1bGxUdXBsZSA9IGwgPT09IHNjaC5taW5JdGVtcyAmJiAobCA9PT0gc2NoLm1heEl0ZW1zIHx8IHNjaFtleHRyYUl0ZW1zXSA9PT0gZmFsc2UpO1xuICAgICAgICBpZiAob3B0cy5zdHJpY3RUdXBsZXMgJiYgIWZ1bGxUdXBsZSkge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gYFwiJHtrZXl3b3JkfVwiIGlzICR7bH0tdHVwbGUsIGJ1dCBtaW5JdGVtcyBvciBtYXhJdGVtcy8ke2V4dHJhSXRlbXN9IGFyZSBub3Qgc3BlY2lmaWVkIG9yIGRpZmZlcmVudCBhdCBwYXRoIFwiJHtlcnJTY2hlbWFQYXRofVwiYDtcbiAgICAgICAgICAgICgwLCB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKShpdCwgbXNnLCBvcHRzLnN0cmljdFR1cGxlcyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlVHVwbGUgPSB2YWxpZGF0ZVR1cGxlO1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXRlbXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBpdGVtc18xID0gcmVxdWlyZShcIi4vaXRlbXNcIik7XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJwcmVmaXhJdGVtc1wiLFxuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBzY2hlbWFUeXBlOiBbXCJhcnJheVwiXSxcbiAgICBiZWZvcmU6IFwidW5pcXVlSXRlbXNcIixcbiAgICBjb2RlOiAoY3h0KSA9PiAoMCwgaXRlbXNfMS52YWxpZGF0ZVR1cGxlKShjeHQsIFwiaXRlbXNcIiksXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJlZml4SXRlbXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi9jb2RlXCIpO1xuY29uc3QgYWRkaXRpb25hbEl0ZW1zXzEgPSByZXF1aXJlKFwiLi9hZGRpdGlvbmFsSXRlbXNcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBwYXJhbXM6IHsgbGVuIH0gfSkgPT4gKDAsIGNvZGVnZW5fMS5zdHIpIGBtdXN0IE5PVCBoYXZlIG1vcmUgdGhhbiAke2xlbn0gaXRlbXNgLFxuICAgIHBhcmFtczogKHsgcGFyYW1zOiB7IGxlbiB9IH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHtsaW1pdDogJHtsZW59fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiaXRlbXNcIixcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgc2NoZW1hVHlwZTogW1wib2JqZWN0XCIsIFwiYm9vbGVhblwiXSxcbiAgICBiZWZvcmU6IFwidW5pcXVlSXRlbXNcIixcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IHNjaGVtYSwgcGFyZW50U2NoZW1hLCBpdCB9ID0gY3h0O1xuICAgICAgICBjb25zdCB7IHByZWZpeEl0ZW1zIH0gPSBwYXJlbnRTY2hlbWE7XG4gICAgICAgIGl0Lml0ZW1zID0gdHJ1ZTtcbiAgICAgICAgaWYgKCgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2hlbWEpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAocHJlZml4SXRlbXMpXG4gICAgICAgICAgICAoMCwgYWRkaXRpb25hbEl0ZW1zXzEudmFsaWRhdGVBZGRpdGlvbmFsSXRlbXMpKGN4dCwgcHJlZml4SXRlbXMpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBjeHQub2soKDAsIGNvZGVfMS52YWxpZGF0ZUFycmF5KShjeHQpKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWl0ZW1zMjAyMC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsgcGFyYW1zOiB7IG1pbiwgbWF4IH0gfSkgPT4gbWF4ID09PSB1bmRlZmluZWRcbiAgICAgICAgPyAoMCwgY29kZWdlbl8xLnN0cikgYG11c3QgY29udGFpbiBhdCBsZWFzdCAke21pbn0gdmFsaWQgaXRlbShzKWBcbiAgICAgICAgOiAoMCwgY29kZWdlbl8xLnN0cikgYG11c3QgY29udGFpbiBhdCBsZWFzdCAke21pbn0gYW5kIG5vIG1vcmUgdGhhbiAke21heH0gdmFsaWQgaXRlbShzKWAsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXM6IHsgbWluLCBtYXggfSB9KSA9PiBtYXggPT09IHVuZGVmaW5lZCA/ICgwLCBjb2RlZ2VuXzEuXykgYHttaW5Db250YWluczogJHttaW59fWAgOiAoMCwgY29kZWdlbl8xLl8pIGB7bWluQ29udGFpbnM6ICR7bWlufSwgbWF4Q29udGFpbnM6ICR7bWF4fX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImNvbnRhaW5zXCIsXG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHNjaGVtYVR5cGU6IFtcIm9iamVjdFwiLCBcImJvb2xlYW5cIl0sXG4gICAgYmVmb3JlOiBcInVuaXF1ZUl0ZW1zXCIsXG4gICAgdHJhY2tFcnJvcnM6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBkYXRhLCBpdCB9ID0gY3h0O1xuICAgICAgICBsZXQgbWluO1xuICAgICAgICBsZXQgbWF4O1xuICAgICAgICBjb25zdCB7IG1pbkNvbnRhaW5zLCBtYXhDb250YWlucyB9ID0gcGFyZW50U2NoZW1hO1xuICAgICAgICBpZiAoaXQub3B0cy5uZXh0KSB7XG4gICAgICAgICAgICBtaW4gPSBtaW5Db250YWlucyA9PT0gdW5kZWZpbmVkID8gMSA6IG1pbkNvbnRhaW5zO1xuICAgICAgICAgICAgbWF4ID0gbWF4Q29udGFpbnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtaW4gPSAxO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlbiA9IGdlbi5jb25zdChcImxlblwiLCAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9Lmxlbmd0aGApO1xuICAgICAgICBjeHQuc2V0UGFyYW1zKHsgbWluLCBtYXggfSk7XG4gICAgICAgIGlmIChtYXggPT09IHVuZGVmaW5lZCAmJiBtaW4gPT09IDApIHtcbiAgICAgICAgICAgICgwLCB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKShpdCwgYFwibWluQ29udGFpbnNcIiA9PSAwIHdpdGhvdXQgXCJtYXhDb250YWluc1wiOiBcImNvbnRhaW5zXCIga2V5d29yZCBpZ25vcmVkYCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heCAhPT0gdW5kZWZpbmVkICYmIG1pbiA+IG1heCkge1xuICAgICAgICAgICAgKDAsIHV0aWxfMS5jaGVja1N0cmljdE1vZGUpKGl0LCBgXCJtaW5Db250YWluc1wiID4gXCJtYXhDb250YWluc1wiIGlzIGFsd2F5cyBpbnZhbGlkYCk7XG4gICAgICAgICAgICBjeHQuZmFpbCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoMCwgdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKShpdCwgc2NoZW1hKSkge1xuICAgICAgICAgICAgbGV0IGNvbmQgPSAoMCwgY29kZWdlbl8xLl8pIGAke2xlbn0gPj0gJHttaW59YDtcbiAgICAgICAgICAgIGlmIChtYXggIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBjb25kID0gKDAsIGNvZGVnZW5fMS5fKSBgJHtjb25kfSAmJiAke2xlbn0gPD0gJHttYXh9YDtcbiAgICAgICAgICAgIGN4dC5wYXNzKGNvbmQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGl0Lml0ZW1zID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgICAgICBpZiAobWF4ID09PSB1bmRlZmluZWQgJiYgbWluID09PSAxKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUl0ZW1zKHZhbGlkLCAoKSA9PiBnZW4uaWYodmFsaWQsICgpID0+IGdlbi5icmVhaygpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobWluID09PSAwKSB7XG4gICAgICAgICAgICBnZW4ubGV0KHZhbGlkLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChtYXggIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfS5sZW5ndGggPiAwYCwgdmFsaWRhdGVJdGVtc1dpdGhDb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnZW4ubGV0KHZhbGlkLCBmYWxzZSk7XG4gICAgICAgICAgICB2YWxpZGF0ZUl0ZW1zV2l0aENvdW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgY3h0LnJlc3VsdCh2YWxpZCwgKCkgPT4gY3h0LnJlc2V0KCkpO1xuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZUl0ZW1zV2l0aENvdW50KCkge1xuICAgICAgICAgICAgY29uc3Qgc2NoVmFsaWQgPSBnZW4ubmFtZShcIl92YWxpZFwiKTtcbiAgICAgICAgICAgIGNvbnN0IGNvdW50ID0gZ2VuLmxldChcImNvdW50XCIsIDApO1xuICAgICAgICAgICAgdmFsaWRhdGVJdGVtcyhzY2hWYWxpZCwgKCkgPT4gZ2VuLmlmKHNjaFZhbGlkLCAoKSA9PiBjaGVja0xpbWl0cyhjb3VudCkpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZUl0ZW1zKF92YWxpZCwgYmxvY2spIHtcbiAgICAgICAgICAgIGdlbi5mb3JSYW5nZShcImlcIiwgMCwgbGVuLCAoaSkgPT4ge1xuICAgICAgICAgICAgICAgIGN4dC5zdWJzY2hlbWEoe1xuICAgICAgICAgICAgICAgICAgICBrZXl3b3JkOiBcImNvbnRhaW5zXCIsXG4gICAgICAgICAgICAgICAgICAgIGRhdGFQcm9wOiBpLFxuICAgICAgICAgICAgICAgICAgICBkYXRhUHJvcFR5cGU6IHV0aWxfMS5UeXBlLk51bSxcbiAgICAgICAgICAgICAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9LCBfdmFsaWQpO1xuICAgICAgICAgICAgICAgIGJsb2NrKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjaGVja0xpbWl0cyhjb3VudCkge1xuICAgICAgICAgICAgZ2VuLmNvZGUoKDAsIGNvZGVnZW5fMS5fKSBgJHtjb3VudH0rK2ApO1xuICAgICAgICAgICAgaWYgKG1heCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7Y291bnR9ID49ICR7bWlufWAsICgpID0+IGdlbi5hc3NpZ24odmFsaWQsIHRydWUpLmJyZWFrKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7Y291bnR9ID4gJHttYXh9YCwgKCkgPT4gZ2VuLmFzc2lnbih2YWxpZCwgZmFsc2UpLmJyZWFrKCkpO1xuICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IDEpXG4gICAgICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIHRydWUpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7Y291bnR9ID49ICR7bWlufWAsICgpID0+IGdlbi5hc3NpZ24odmFsaWQsIHRydWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udGFpbnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlU2NoZW1hRGVwcyA9IGV4cG9ydHMudmFsaWRhdGVQcm9wZXJ0eURlcHMgPSBleHBvcnRzLmVycm9yID0gdm9pZCAwO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi4vY29kZVwiKTtcbmV4cG9ydHMuZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsgcGFyYW1zOiB7IHByb3BlcnR5LCBkZXBzQ291bnQsIGRlcHMgfSB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHByb3BlcnR5X2llcyA9IGRlcHNDb3VudCA9PT0gMSA/IFwicHJvcGVydHlcIiA6IFwicHJvcGVydGllc1wiO1xuICAgICAgICByZXR1cm4gKDAsIGNvZGVnZW5fMS5zdHIpIGBtdXN0IGhhdmUgJHtwcm9wZXJ0eV9pZXN9ICR7ZGVwc30gd2hlbiBwcm9wZXJ0eSAke3Byb3BlcnR5fSBpcyBwcmVzZW50YDtcbiAgICB9LFxuICAgIHBhcmFtczogKHsgcGFyYW1zOiB7IHByb3BlcnR5LCBkZXBzQ291bnQsIGRlcHMsIG1pc3NpbmdQcm9wZXJ0eSB9IH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHtwcm9wZXJ0eTogJHtwcm9wZXJ0eX0sXG4gICAgbWlzc2luZ1Byb3BlcnR5OiAke21pc3NpbmdQcm9wZXJ0eX0sXG4gICAgZGVwc0NvdW50OiAke2RlcHNDb3VudH0sXG4gICAgZGVwczogJHtkZXBzfX1gLCAvLyBUT0RPIGNoYW5nZSB0byByZWZlcmVuY2Vcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJkZXBlbmRlbmNpZXNcIixcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIHNjaGVtYVR5cGU6IFwib2JqZWN0XCIsXG4gICAgZXJyb3I6IGV4cG9ydHMuZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgW3Byb3BEZXBzLCBzY2hEZXBzXSA9IHNwbGl0RGVwZW5kZW5jaWVzKGN4dCk7XG4gICAgICAgIHZhbGlkYXRlUHJvcGVydHlEZXBzKGN4dCwgcHJvcERlcHMpO1xuICAgICAgICB2YWxpZGF0ZVNjaGVtYURlcHMoY3h0LCBzY2hEZXBzKTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIHNwbGl0RGVwZW5kZW5jaWVzKHsgc2NoZW1hIH0pIHtcbiAgICBjb25zdCBwcm9wZXJ0eURlcHMgPSB7fTtcbiAgICBjb25zdCBzY2hlbWFEZXBzID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSB7XG4gICAgICAgIGlmIChrZXkgPT09IFwiX19wcm90b19fXCIpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgZGVwcyA9IEFycmF5LmlzQXJyYXkoc2NoZW1hW2tleV0pID8gcHJvcGVydHlEZXBzIDogc2NoZW1hRGVwcztcbiAgICAgICAgZGVwc1trZXldID0gc2NoZW1hW2tleV07XG4gICAgfVxuICAgIHJldHVybiBbcHJvcGVydHlEZXBzLCBzY2hlbWFEZXBzXTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydHlEZXBzKGN4dCwgcHJvcGVydHlEZXBzID0gY3h0LnNjaGVtYSkge1xuICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBpdCB9ID0gY3h0O1xuICAgIGlmIChPYmplY3Qua2V5cyhwcm9wZXJ0eURlcHMpLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG1pc3NpbmcgPSBnZW4ubGV0KFwibWlzc2luZ1wiKTtcbiAgICBmb3IgKGNvbnN0IHByb3AgaW4gcHJvcGVydHlEZXBzKSB7XG4gICAgICAgIGNvbnN0IGRlcHMgPSBwcm9wZXJ0eURlcHNbcHJvcF07XG4gICAgICAgIGlmIChkZXBzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBoYXNQcm9wZXJ0eSA9ICgwLCBjb2RlXzEucHJvcGVydHlJbkRhdGEpKGdlbiwgZGF0YSwgcHJvcCwgaXQub3B0cy5vd25Qcm9wZXJ0aWVzKTtcbiAgICAgICAgY3h0LnNldFBhcmFtcyh7XG4gICAgICAgICAgICBwcm9wZXJ0eTogcHJvcCxcbiAgICAgICAgICAgIGRlcHNDb3VudDogZGVwcy5sZW5ndGgsXG4gICAgICAgICAgICBkZXBzOiBkZXBzLmpvaW4oXCIsIFwiKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpdC5hbGxFcnJvcnMpIHtcbiAgICAgICAgICAgIGdlbi5pZihoYXNQcm9wZXJ0eSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZGVwUHJvcCBvZiBkZXBzKSB7XG4gICAgICAgICAgICAgICAgICAgICgwLCBjb2RlXzEuY2hlY2tSZXBvcnRNaXNzaW5nUHJvcCkoY3h0LCBkZXBQcm9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke2hhc1Byb3BlcnR5fSAmJiAoJHsoMCwgY29kZV8xLmNoZWNrTWlzc2luZ1Byb3ApKGN4dCwgZGVwcywgbWlzc2luZyl9KWApO1xuICAgICAgICAgICAgKDAsIGNvZGVfMS5yZXBvcnRNaXNzaW5nUHJvcCkoY3h0LCBtaXNzaW5nKTtcbiAgICAgICAgICAgIGdlbi5lbHNlKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlUHJvcGVydHlEZXBzID0gdmFsaWRhdGVQcm9wZXJ0eURlcHM7XG5mdW5jdGlvbiB2YWxpZGF0ZVNjaGVtYURlcHMoY3h0LCBzY2hlbWFEZXBzID0gY3h0LnNjaGVtYSkge1xuICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBrZXl3b3JkLCBpdCB9ID0gY3h0O1xuICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICBmb3IgKGNvbnN0IHByb3AgaW4gc2NoZW1hRGVwcykge1xuICAgICAgICBpZiAoKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaGVtYURlcHNbcHJvcF0pKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGdlbi5pZigoMCwgY29kZV8xLnByb3BlcnR5SW5EYXRhKShnZW4sIGRhdGEsIHByb3AsIGl0Lm9wdHMub3duUHJvcGVydGllcyksICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNjaEN4dCA9IGN4dC5zdWJzY2hlbWEoeyBrZXl3b3JkLCBzY2hlbWFQcm9wOiBwcm9wIH0sIHZhbGlkKTtcbiAgICAgICAgICAgIGN4dC5tZXJnZVZhbGlkRXZhbHVhdGVkKHNjaEN4dCwgdmFsaWQpO1xuICAgICAgICB9LCAoKSA9PiBnZW4udmFyKHZhbGlkLCB0cnVlKSAvLyBUT0RPIHZhclxuICAgICAgICApO1xuICAgICAgICBjeHQub2sodmFsaWQpO1xuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVTY2hlbWFEZXBzID0gdmFsaWRhdGVTY2hlbWFEZXBzO1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVwZW5kZW5jaWVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiBcInByb3BlcnR5IG5hbWUgbXVzdCBiZSB2YWxpZFwiLFxuICAgIHBhcmFtczogKHsgcGFyYW1zIH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHtwcm9wZXJ0eU5hbWU6ICR7cGFyYW1zLnByb3BlcnR5TmFtZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJwcm9wZXJ0eU5hbWVzXCIsXG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICBzY2hlbWFUeXBlOiBbXCJvYmplY3RcIiwgXCJib29sZWFuXCJdLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIGRhdGEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGlmICgoMCwgdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKShpdCwgc2NoZW1hKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgICAgICBnZW4uZm9ySW4oXCJrZXlcIiwgZGF0YSwgKGtleSkgPT4ge1xuICAgICAgICAgICAgY3h0LnNldFBhcmFtcyh7IHByb3BlcnR5TmFtZToga2V5IH0pO1xuICAgICAgICAgICAgY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICAgICAga2V5d29yZDogXCJwcm9wZXJ0eU5hbWVzXCIsXG4gICAgICAgICAgICAgICAgZGF0YToga2V5LFxuICAgICAgICAgICAgICAgIGRhdGFUeXBlczogW1wic3RyaW5nXCJdLFxuICAgICAgICAgICAgICAgIHByb3BlcnR5TmFtZToga2V5LFxuICAgICAgICAgICAgICAgIGNvbXBvc2l0ZVJ1bGU6IHRydWUsXG4gICAgICAgICAgICB9LCB2YWxpZCk7XG4gICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5ub3QpKHZhbGlkKSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGN4dC5lcnJvcih0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAoIWl0LmFsbEVycm9ycylcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmJyZWFrKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9wZXJ0eU5hbWVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uL2NvZGVcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgbmFtZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL25hbWVzXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6IFwibXVzdCBOT1QgaGF2ZSBhZGRpdGlvbmFsIHByb3BlcnRpZXNcIixcbiAgICBwYXJhbXM6ICh7IHBhcmFtcyB9KSA9PiAoMCwgY29kZWdlbl8xLl8pIGB7YWRkaXRpb25hbFByb3BlcnR5OiAke3BhcmFtcy5hZGRpdGlvbmFsUHJvcGVydHl9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIixcbiAgICB0eXBlOiBbXCJvYmplY3RcIl0sXG4gICAgc2NoZW1hVHlwZTogW1wiYm9vbGVhblwiLCBcIm9iamVjdFwiXSxcbiAgICBhbGxvd1VuZGVmaW5lZDogdHJ1ZSxcbiAgICB0cmFja0Vycm9yczogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGRhdGEsIGVycnNDb3VudCwgaXQgfSA9IGN4dDtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghZXJyc0NvdW50KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgICAgICBjb25zdCB7IGFsbEVycm9ycywgb3B0cyB9ID0gaXQ7XG4gICAgICAgIGl0LnByb3BzID0gdHJ1ZTtcbiAgICAgICAgaWYgKG9wdHMucmVtb3ZlQWRkaXRpb25hbCAhPT0gXCJhbGxcIiAmJiAoMCwgdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKShpdCwgc2NoZW1hKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgcHJvcHMgPSAoMCwgY29kZV8xLmFsbFNjaGVtYVByb3BlcnRpZXMpKHBhcmVudFNjaGVtYS5wcm9wZXJ0aWVzKTtcbiAgICAgICAgY29uc3QgcGF0UHJvcHMgPSAoMCwgY29kZV8xLmFsbFNjaGVtYVByb3BlcnRpZXMpKHBhcmVudFNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcyk7XG4gICAgICAgIGNoZWNrQWRkaXRpb25hbFByb3BlcnRpZXMoKTtcbiAgICAgICAgY3h0Lm9rKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZXJyc0NvdW50fSA9PT0gJHtuYW1lc18xLmRlZmF1bHQuZXJyb3JzfWApO1xuICAgICAgICBmdW5jdGlvbiBjaGVja0FkZGl0aW9uYWxQcm9wZXJ0aWVzKCkge1xuICAgICAgICAgICAgZ2VuLmZvckluKFwia2V5XCIsIGRhdGEsIChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXByb3BzLmxlbmd0aCAmJiAhcGF0UHJvcHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBhZGRpdGlvbmFsUHJvcGVydHlDb2RlKGtleSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBnZW4uaWYoaXNBZGRpdGlvbmFsKGtleSksICgpID0+IGFkZGl0aW9uYWxQcm9wZXJ0eUNvZGUoa2V5KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc0FkZGl0aW9uYWwoa2V5KSB7XG4gICAgICAgICAgICBsZXQgZGVmaW5lZFByb3A7XG4gICAgICAgICAgICBpZiAocHJvcHMubGVuZ3RoID4gOCkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gbWF5YmUgYW4gb3B0aW9uIGluc3RlYWQgb2YgaGFyZC1jb2RlZCA4P1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BzU2NoZW1hID0gKDAsIHV0aWxfMS5zY2hlbWFSZWZPclZhbCkoaXQsIHBhcmVudFNjaGVtYS5wcm9wZXJ0aWVzLCBcInByb3BlcnRpZXNcIik7XG4gICAgICAgICAgICAgICAgZGVmaW5lZFByb3AgPSAoMCwgY29kZV8xLmlzT3duUHJvcGVydHkpKGdlbiwgcHJvcHNTY2hlbWEsIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwcm9wcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVkUHJvcCA9ICgwLCBjb2RlZ2VuXzEub3IpKC4uLnByb3BzLm1hcCgocCkgPT4gKDAsIGNvZGVnZW5fMS5fKSBgJHtrZXl9ID09PSAke3B9YCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVmaW5lZFByb3AgPSBjb2RlZ2VuXzEubmlsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhdFByb3BzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGRlZmluZWRQcm9wID0gKDAsIGNvZGVnZW5fMS5vcikoZGVmaW5lZFByb3AsIC4uLnBhdFByb3BzLm1hcCgocCkgPT4gKDAsIGNvZGVnZW5fMS5fKSBgJHsoMCwgY29kZV8xLnVzZVBhdHRlcm4pKGN4dCwgcCl9LnRlc3QoJHtrZXl9KWApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLm5vdCkoZGVmaW5lZFByb3ApO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGRlbGV0ZUFkZGl0aW9uYWwoa2V5KSB7XG4gICAgICAgICAgICBnZW4uY29kZSgoMCwgY29kZWdlbl8xLl8pIGBkZWxldGUgJHtkYXRhfVske2tleX1dYCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYWRkaXRpb25hbFByb3BlcnR5Q29kZShrZXkpIHtcbiAgICAgICAgICAgIGlmIChvcHRzLnJlbW92ZUFkZGl0aW9uYWwgPT09IFwiYWxsXCIgfHwgKG9wdHMucmVtb3ZlQWRkaXRpb25hbCAmJiBzY2hlbWEgPT09IGZhbHNlKSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZUFkZGl0aW9uYWwoa2V5KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2NoZW1hID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGN4dC5zZXRQYXJhbXMoeyBhZGRpdGlvbmFsUHJvcGVydHk6IGtleSB9KTtcbiAgICAgICAgICAgICAgICBjeHQuZXJyb3IoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWFsbEVycm9ycylcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmJyZWFrKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIiAmJiAhKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaGVtYSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgICAgICAgICAgICAgaWYgKG9wdHMucmVtb3ZlQWRkaXRpb25hbCA9PT0gXCJmYWlsaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYXBwbHlBZGRpdGlvbmFsU2NoZW1hKGtleSwgdmFsaWQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEubm90KSh2YWxpZCksICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN4dC5yZXNldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlQWRkaXRpb25hbChrZXkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFwcGx5QWRkaXRpb25hbFNjaGVtYShrZXksIHZhbGlkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhbGxFcnJvcnMpXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5ub3QpKHZhbGlkKSwgKCkgPT4gZ2VuLmJyZWFrKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhcHBseUFkZGl0aW9uYWxTY2hlbWEoa2V5LCB2YWxpZCwgZXJyb3JzKSB7XG4gICAgICAgICAgICBjb25zdCBzdWJzY2hlbWEgPSB7XG4gICAgICAgICAgICAgICAga2V5d29yZDogXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiLFxuICAgICAgICAgICAgICAgIGRhdGFQcm9wOiBrZXksXG4gICAgICAgICAgICAgICAgZGF0YVByb3BUeXBlOiB1dGlsXzEuVHlwZS5TdHIsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGVycm9ycyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHN1YnNjaGVtYSwge1xuICAgICAgICAgICAgICAgICAgICBjb21wb3NpdGVSdWxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVFcnJvcnM6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBhbGxFcnJvcnM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3h0LnN1YnNjaGVtYShzdWJzY2hlbWEsIHZhbGlkKTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkaXRpb25hbFByb3BlcnRpZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB2YWxpZGF0ZV8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGVcIik7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi4vY29kZVwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBhZGRpdGlvbmFsUHJvcGVydGllc18xID0gcmVxdWlyZShcIi4vYWRkaXRpb25hbFByb3BlcnRpZXNcIik7XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJwcm9wZXJ0aWVzXCIsXG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICBzY2hlbWFUeXBlOiBcIm9iamVjdFwiLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgZGF0YSwgaXQgfSA9IGN4dDtcbiAgICAgICAgaWYgKGl0Lm9wdHMucmVtb3ZlQWRkaXRpb25hbCA9PT0gXCJhbGxcIiAmJiBwYXJlbnRTY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXNfMS5kZWZhdWx0LmNvZGUobmV3IHZhbGlkYXRlXzEuS2V5d29yZEN4dChpdCwgYWRkaXRpb25hbFByb3BlcnRpZXNfMS5kZWZhdWx0LCBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhbGxQcm9wcyA9ICgwLCBjb2RlXzEuYWxsU2NoZW1hUHJvcGVydGllcykoc2NoZW1hKTtcbiAgICAgICAgZm9yIChjb25zdCBwcm9wIG9mIGFsbFByb3BzKSB7XG4gICAgICAgICAgICBpdC5kZWZpbmVkUHJvcGVydGllcy5hZGQocHJvcCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0Lm9wdHMudW5ldmFsdWF0ZWQgJiYgYWxsUHJvcHMubGVuZ3RoICYmIGl0LnByb3BzICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBpdC5wcm9wcyA9IHV0aWxfMS5tZXJnZUV2YWx1YXRlZC5wcm9wcyhnZW4sICgwLCB1dGlsXzEudG9IYXNoKShhbGxQcm9wcyksIGl0LnByb3BzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9wZXJ0aWVzID0gYWxsUHJvcHMuZmlsdGVyKChwKSA9PiAhKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaGVtYVtwXSkpO1xuICAgICAgICBpZiAocHJvcGVydGllcy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICAgICAgZm9yIChjb25zdCBwcm9wIG9mIHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGlmIChoYXNEZWZhdWx0KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgYXBwbHlQcm9wZXJ0eVNjaGVtYShwcm9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZV8xLnByb3BlcnR5SW5EYXRhKShnZW4sIGRhdGEsIHByb3AsIGl0Lm9wdHMub3duUHJvcGVydGllcykpO1xuICAgICAgICAgICAgICAgIGFwcGx5UHJvcGVydHlTY2hlbWEocHJvcCk7XG4gICAgICAgICAgICAgICAgaWYgKCFpdC5hbGxFcnJvcnMpXG4gICAgICAgICAgICAgICAgICAgIGdlbi5lbHNlKCkudmFyKHZhbGlkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBnZW4uZW5kSWYoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN4dC5pdC5kZWZpbmVkUHJvcGVydGllcy5hZGQocHJvcCk7XG4gICAgICAgICAgICBjeHQub2sodmFsaWQpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGhhc0RlZmF1bHQocHJvcCkge1xuICAgICAgICAgICAgcmV0dXJuIGl0Lm9wdHMudXNlRGVmYXVsdHMgJiYgIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgc2NoZW1hW3Byb3BdLmRlZmF1bHQgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhcHBseVByb3BlcnR5U2NoZW1hKHByb3ApIHtcbiAgICAgICAgICAgIGN4dC5zdWJzY2hlbWEoe1xuICAgICAgICAgICAgICAgIGtleXdvcmQ6IFwicHJvcGVydGllc1wiLFxuICAgICAgICAgICAgICAgIHNjaGVtYVByb3A6IHByb3AsXG4gICAgICAgICAgICAgICAgZGF0YVByb3A6IHByb3AsXG4gICAgICAgICAgICB9LCB2YWxpZCk7XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3BlcnRpZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi4vY29kZVwiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgdXRpbF8yID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcInBhdHRlcm5Qcm9wZXJ0aWVzXCIsXG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICBzY2hlbWFUeXBlOiBcIm9iamVjdFwiLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIGRhdGEsIHBhcmVudFNjaGVtYSwgaXQgfSA9IGN4dDtcbiAgICAgICAgY29uc3QgeyBvcHRzIH0gPSBpdDtcbiAgICAgICAgY29uc3QgcGF0dGVybnMgPSAoMCwgY29kZV8xLmFsbFNjaGVtYVByb3BlcnRpZXMpKHNjaGVtYSk7XG4gICAgICAgIGNvbnN0IGFsd2F5c1ZhbGlkUGF0dGVybnMgPSBwYXR0ZXJucy5maWx0ZXIoKHApID0+ICgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2hlbWFbcF0pKTtcbiAgICAgICAgaWYgKHBhdHRlcm5zLmxlbmd0aCA9PT0gMCB8fFxuICAgICAgICAgICAgKGFsd2F5c1ZhbGlkUGF0dGVybnMubGVuZ3RoID09PSBwYXR0ZXJucy5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAoIWl0Lm9wdHMudW5ldmFsdWF0ZWQgfHwgaXQucHJvcHMgPT09IHRydWUpKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoZWNrUHJvcGVydGllcyA9IG9wdHMuc3RyaWN0U2NoZW1hICYmICFvcHRzLmFsbG93TWF0Y2hpbmdQcm9wZXJ0aWVzICYmIHBhcmVudFNjaGVtYS5wcm9wZXJ0aWVzO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgICAgIGlmIChpdC5wcm9wcyAhPT0gdHJ1ZSAmJiAhKGl0LnByb3BzIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUpKSB7XG4gICAgICAgICAgICBpdC5wcm9wcyA9ICgwLCB1dGlsXzIuZXZhbHVhdGVkUHJvcHNUb05hbWUpKGdlbiwgaXQucHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgcHJvcHMgfSA9IGl0O1xuICAgICAgICB2YWxpZGF0ZVBhdHRlcm5Qcm9wZXJ0aWVzKCk7XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlUGF0dGVyblByb3BlcnRpZXMoKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBhdCBvZiBwYXR0ZXJucykge1xuICAgICAgICAgICAgICAgIGlmIChjaGVja1Byb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrTWF0Y2hpbmdQcm9wZXJ0aWVzKHBhdCk7XG4gICAgICAgICAgICAgICAgaWYgKGl0LmFsbEVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZVByb3BlcnRpZXMocGF0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdlbi52YXIodmFsaWQsIHRydWUpOyAvLyBUT0RPIHZhclxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZVByb3BlcnRpZXMocGF0KTtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmlmKHZhbGlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2hlY2tNYXRjaGluZ1Byb3BlcnRpZXMocGF0KSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gY2hlY2tQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5ldyBSZWdFeHAocGF0KS50ZXN0KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgICgwLCB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKShpdCwgYHByb3BlcnR5ICR7cHJvcH0gbWF0Y2hlcyBwYXR0ZXJuICR7cGF0fSAodXNlIGFsbG93TWF0Y2hpbmdQcm9wZXJ0aWVzKWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnRpZXMocGF0KSB7XG4gICAgICAgICAgICBnZW4uZm9ySW4oXCJrZXlcIiwgZGF0YSwgKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAkeygwLCBjb2RlXzEudXNlUGF0dGVybikoY3h0LCBwYXQpfS50ZXN0KCR7a2V5fSlgLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFsd2F5c1ZhbGlkID0gYWx3YXlzVmFsaWRQYXR0ZXJucy5pbmNsdWRlcyhwYXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWFsd2F5c1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXl3b3JkOiBcInBhdHRlcm5Qcm9wZXJ0aWVzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NoZW1hUHJvcDogcGF0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFQcm9wOiBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVByb3BUeXBlOiB1dGlsXzIuVHlwZS5TdHIsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB2YWxpZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0Lm9wdHMudW5ldmFsdWF0ZWQgJiYgcHJvcHMgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24oKDAsIGNvZGVnZW5fMS5fKSBgJHtwcm9wc31bJHtrZXl9XWAsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFhbHdheXNWYWxpZCAmJiAhaXQuYWxsRXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYW4gc2hvcnQtY2lyY3VpdCBpZiBgdW5ldmFsdWF0ZWRQcm9wZXJ0aWVzYCBpcyBub3Qgc3VwcG9ydGVkIChvcHRzLm5leHQgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3IgaWYgYWxsIHByb3BlcnRpZXMgd2VyZSBldmFsdWF0ZWQgKHByb3BzID09PSB0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEubm90KSh2YWxpZCksICgpID0+IGdlbi5icmVhaygpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhdHRlcm5Qcm9wZXJ0aWVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcIm5vdFwiLFxuICAgIHNjaGVtYVR5cGU6IFtcIm9iamVjdFwiLCBcImJvb2xlYW5cIl0sXG4gICAgdHJhY2tFcnJvcnM6IHRydWUsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgaXQgfSA9IGN4dDtcbiAgICAgICAgaWYgKCgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2hlbWEpKSB7XG4gICAgICAgICAgICBjeHQuZmFpbCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICAgICAgY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICBrZXl3b3JkOiBcIm5vdFwiLFxuICAgICAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNyZWF0ZUVycm9yczogZmFsc2UsXG4gICAgICAgICAgICBhbGxFcnJvcnM6IGZhbHNlLFxuICAgICAgICB9LCB2YWxpZCk7XG4gICAgICAgIGN4dC5mYWlsUmVzdWx0KHZhbGlkLCAoKSA9PiBjeHQucmVzZXQoKSwgKCkgPT4gY3h0LmVycm9yKCkpO1xuICAgIH0sXG4gICAgZXJyb3I6IHsgbWVzc2FnZTogXCJtdXN0IE5PVCBiZSB2YWxpZFwiIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bm90LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uL2NvZGVcIik7XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJhbnlPZlwiLFxuICAgIHNjaGVtYVR5cGU6IFwiYXJyYXlcIixcbiAgICB0cmFja0Vycm9yczogdHJ1ZSxcbiAgICBjb2RlOiBjb2RlXzEudmFsaWRhdGVVbmlvbixcbiAgICBlcnJvcjogeyBtZXNzYWdlOiBcIm11c3QgbWF0Y2ggYSBzY2hlbWEgaW4gYW55T2ZcIiB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFueU9mLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiBcIm11c3QgbWF0Y2ggZXhhY3RseSBvbmUgc2NoZW1hIGluIG9uZU9mXCIsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXMgfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge3Bhc3NpbmdTY2hlbWFzOiAke3BhcmFtcy5wYXNzaW5nfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcIm9uZU9mXCIsXG4gICAgc2NoZW1hVHlwZTogXCJhcnJheVwiLFxuICAgIHRyYWNrRXJyb3JzOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgaXQgfSA9IGN4dDtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzY2hlbWEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgICAgICBpZiAoaXQub3B0cy5kaXNjcmltaW5hdG9yICYmIHBhcmVudFNjaGVtYS5kaXNjcmltaW5hdG9yKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBzY2hBcnIgPSBzY2hlbWE7XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIsIGZhbHNlKTtcbiAgICAgICAgY29uc3QgcGFzc2luZyA9IGdlbi5sZXQoXCJwYXNzaW5nXCIsIG51bGwpO1xuICAgICAgICBjb25zdCBzY2hWYWxpZCA9IGdlbi5uYW1lKFwiX3ZhbGlkXCIpO1xuICAgICAgICBjeHQuc2V0UGFyYW1zKHsgcGFzc2luZyB9KTtcbiAgICAgICAgLy8gVE9ETyBwb3NzaWJseSBmYWlsIHN0cmFpZ2h0IGF3YXkgKHdpdGggd2FybmluZyBvciBleGNlcHRpb24pIGlmIHRoZXJlIGFyZSB0d28gZW1wdHkgYWx3YXlzIHZhbGlkIHNjaGVtYXNcbiAgICAgICAgZ2VuLmJsb2NrKHZhbGlkYXRlT25lT2YpO1xuICAgICAgICBjeHQucmVzdWx0KHZhbGlkLCAoKSA9PiBjeHQucmVzZXQoKSwgKCkgPT4gY3h0LmVycm9yKHRydWUpKTtcbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVPbmVPZigpIHtcbiAgICAgICAgICAgIHNjaEFyci5mb3JFYWNoKChzY2gsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgc2NoQ3h0O1xuICAgICAgICAgICAgICAgIGlmICgoMCwgdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKShpdCwgc2NoKSkge1xuICAgICAgICAgICAgICAgICAgICBnZW4udmFyKHNjaFZhbGlkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNjaEN4dCA9IGN4dC5zdWJzY2hlbWEoe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5d29yZDogXCJvbmVPZlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2NoZW1hUHJvcDogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvc2l0ZVJ1bGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIH0sIHNjaFZhbGlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgICAgICAgICAgICAgLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7c2NoVmFsaWR9ICYmICR7dmFsaWR9YClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hc3NpZ24odmFsaWQsIGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFzc2lnbihwYXNzaW5nLCAoMCwgY29kZWdlbl8xLl8pIGBbJHtwYXNzaW5nfSwgJHtpfV1gKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmVsc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ2VuLmlmKHNjaFZhbGlkLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHBhc3NpbmcsIGkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2NoQ3h0KVxuICAgICAgICAgICAgICAgICAgICAgICAgY3h0Lm1lcmdlRXZhbHVhdGVkKHNjaEN4dCwgY29kZWdlbl8xLk5hbWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9uZU9mLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImFsbE9mXCIsXG4gICAgc2NoZW1hVHlwZTogXCJhcnJheVwiLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFqdiBpbXBsZW1lbnRhdGlvbiBlcnJvclwiKTtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgICAgICBzY2hlbWEuZm9yRWFjaCgoc2NoLCBpKSA9PiB7XG4gICAgICAgICAgICBpZiAoKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7IGtleXdvcmQ6IFwiYWxsT2ZcIiwgc2NoZW1hUHJvcDogaSB9LCB2YWxpZCk7XG4gICAgICAgICAgICBjeHQub2sodmFsaWQpO1xuICAgICAgICAgICAgY3h0Lm1lcmdlRXZhbHVhdGVkKHNjaEN4dCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWxsT2YuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHBhcmFtcyB9KSA9PiAoMCwgY29kZWdlbl8xLnN0cikgYG11c3QgbWF0Y2ggXCIke3BhcmFtcy5pZkNsYXVzZX1cIiBzY2hlbWFgLFxuICAgIHBhcmFtczogKHsgcGFyYW1zIH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHtmYWlsaW5nS2V5d29yZDogJHtwYXJhbXMuaWZDbGF1c2V9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiaWZcIixcbiAgICBzY2hlbWFUeXBlOiBbXCJvYmplY3RcIiwgXCJib29sZWFuXCJdLFxuICAgIHRyYWNrRXJyb3JzOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBwYXJlbnRTY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGlmIChwYXJlbnRTY2hlbWEudGhlbiA9PT0gdW5kZWZpbmVkICYmIHBhcmVudFNjaGVtYS5lbHNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICgwLCB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKShpdCwgJ1wiaWZcIiB3aXRob3V0IFwidGhlblwiIGFuZCBcImVsc2VcIiBpcyBpZ25vcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFzVGhlbiA9IGhhc1NjaGVtYShpdCwgXCJ0aGVuXCIpO1xuICAgICAgICBjb25zdCBoYXNFbHNlID0gaGFzU2NoZW1hKGl0LCBcImVsc2VcIik7XG4gICAgICAgIGlmICghaGFzVGhlbiAmJiAhaGFzRWxzZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIiwgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IHNjaFZhbGlkID0gZ2VuLm5hbWUoXCJfdmFsaWRcIik7XG4gICAgICAgIHZhbGlkYXRlSWYoKTtcbiAgICAgICAgY3h0LnJlc2V0KCk7XG4gICAgICAgIGlmIChoYXNUaGVuICYmIGhhc0Vsc2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGlmQ2xhdXNlID0gZ2VuLmxldChcImlmQ2xhdXNlXCIpO1xuICAgICAgICAgICAgY3h0LnNldFBhcmFtcyh7IGlmQ2xhdXNlIH0pO1xuICAgICAgICAgICAgZ2VuLmlmKHNjaFZhbGlkLCB2YWxpZGF0ZUNsYXVzZShcInRoZW5cIiwgaWZDbGF1c2UpLCB2YWxpZGF0ZUNsYXVzZShcImVsc2VcIiwgaWZDbGF1c2UpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoYXNUaGVuKSB7XG4gICAgICAgICAgICBnZW4uaWYoc2NoVmFsaWQsIHZhbGlkYXRlQ2xhdXNlKFwidGhlblwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5ub3QpKHNjaFZhbGlkKSwgdmFsaWRhdGVDbGF1c2UoXCJlbHNlXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBjeHQucGFzcyh2YWxpZCwgKCkgPT4gY3h0LmVycm9yKHRydWUpKTtcbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVJZigpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjaEN4dCA9IGN4dC5zdWJzY2hlbWEoe1xuICAgICAgICAgICAgICAgIGtleXdvcmQ6IFwiaWZcIixcbiAgICAgICAgICAgICAgICBjb21wb3NpdGVSdWxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNyZWF0ZUVycm9yczogZmFsc2UsXG4gICAgICAgICAgICAgICAgYWxsRXJyb3JzOiBmYWxzZSxcbiAgICAgICAgICAgIH0sIHNjaFZhbGlkKTtcbiAgICAgICAgICAgIGN4dC5tZXJnZUV2YWx1YXRlZChzY2hDeHQpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlQ2xhdXNlKGtleXdvcmQsIGlmQ2xhdXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjaEN4dCA9IGN4dC5zdWJzY2hlbWEoeyBrZXl3b3JkIH0sIHNjaFZhbGlkKTtcbiAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCBzY2hWYWxpZCk7XG4gICAgICAgICAgICAgICAgY3h0Lm1lcmdlVmFsaWRFdmFsdWF0ZWQoc2NoQ3h0LCB2YWxpZCk7XG4gICAgICAgICAgICAgICAgaWYgKGlmQ2xhdXNlKVxuICAgICAgICAgICAgICAgICAgICBnZW4uYXNzaWduKGlmQ2xhdXNlLCAoMCwgY29kZWdlbl8xLl8pIGAke2tleXdvcmR9YCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBjeHQuc2V0UGFyYW1zKHsgaWZDbGF1c2U6IGtleXdvcmQgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSxcbn07XG5mdW5jdGlvbiBoYXNTY2hlbWEoaXQsIGtleXdvcmQpIHtcbiAgICBjb25zdCBzY2hlbWEgPSBpdC5zY2hlbWFba2V5d29yZF07XG4gICAgcmV0dXJuIHNjaGVtYSAhPT0gdW5kZWZpbmVkICYmICEoMCwgdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKShpdCwgc2NoZW1hKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlmLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBbXCJ0aGVuXCIsIFwiZWxzZVwiXSxcbiAgICBzY2hlbWFUeXBlOiBbXCJvYmplY3RcIiwgXCJib29sZWFuXCJdLFxuICAgIGNvZGUoeyBrZXl3b3JkLCBwYXJlbnRTY2hlbWEsIGl0IH0pIHtcbiAgICAgICAgaWYgKHBhcmVudFNjaGVtYS5pZiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgKDAsIHV0aWxfMS5jaGVja1N0cmljdE1vZGUpKGl0LCBgXCIke2tleXdvcmR9XCIgd2l0aG91dCBcImlmXCIgaXMgaWdub3JlZGApO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGhlbkVsc2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBhZGRpdGlvbmFsSXRlbXNfMSA9IHJlcXVpcmUoXCIuL2FkZGl0aW9uYWxJdGVtc1wiKTtcbmNvbnN0IHByZWZpeEl0ZW1zXzEgPSByZXF1aXJlKFwiLi9wcmVmaXhJdGVtc1wiKTtcbmNvbnN0IGl0ZW1zXzEgPSByZXF1aXJlKFwiLi9pdGVtc1wiKTtcbmNvbnN0IGl0ZW1zMjAyMF8xID0gcmVxdWlyZShcIi4vaXRlbXMyMDIwXCIpO1xuY29uc3QgY29udGFpbnNfMSA9IHJlcXVpcmUoXCIuL2NvbnRhaW5zXCIpO1xuY29uc3QgZGVwZW5kZW5jaWVzXzEgPSByZXF1aXJlKFwiLi9kZXBlbmRlbmNpZXNcIik7XG5jb25zdCBwcm9wZXJ0eU5hbWVzXzEgPSByZXF1aXJlKFwiLi9wcm9wZXJ0eU5hbWVzXCIpO1xuY29uc3QgYWRkaXRpb25hbFByb3BlcnRpZXNfMSA9IHJlcXVpcmUoXCIuL2FkZGl0aW9uYWxQcm9wZXJ0aWVzXCIpO1xuY29uc3QgcHJvcGVydGllc18xID0gcmVxdWlyZShcIi4vcHJvcGVydGllc1wiKTtcbmNvbnN0IHBhdHRlcm5Qcm9wZXJ0aWVzXzEgPSByZXF1aXJlKFwiLi9wYXR0ZXJuUHJvcGVydGllc1wiKTtcbmNvbnN0IG5vdF8xID0gcmVxdWlyZShcIi4vbm90XCIpO1xuY29uc3QgYW55T2ZfMSA9IHJlcXVpcmUoXCIuL2FueU9mXCIpO1xuY29uc3Qgb25lT2ZfMSA9IHJlcXVpcmUoXCIuL29uZU9mXCIpO1xuY29uc3QgYWxsT2ZfMSA9IHJlcXVpcmUoXCIuL2FsbE9mXCIpO1xuY29uc3QgaWZfMSA9IHJlcXVpcmUoXCIuL2lmXCIpO1xuY29uc3QgdGhlbkVsc2VfMSA9IHJlcXVpcmUoXCIuL3RoZW5FbHNlXCIpO1xuZnVuY3Rpb24gZ2V0QXBwbGljYXRvcihkcmFmdDIwMjAgPSBmYWxzZSkge1xuICAgIGNvbnN0IGFwcGxpY2F0b3IgPSBbXG4gICAgICAgIC8vIGFueVxuICAgICAgICBub3RfMS5kZWZhdWx0LFxuICAgICAgICBhbnlPZl8xLmRlZmF1bHQsXG4gICAgICAgIG9uZU9mXzEuZGVmYXVsdCxcbiAgICAgICAgYWxsT2ZfMS5kZWZhdWx0LFxuICAgICAgICBpZl8xLmRlZmF1bHQsXG4gICAgICAgIHRoZW5FbHNlXzEuZGVmYXVsdCxcbiAgICAgICAgLy8gb2JqZWN0XG4gICAgICAgIHByb3BlcnR5TmFtZXNfMS5kZWZhdWx0LFxuICAgICAgICBhZGRpdGlvbmFsUHJvcGVydGllc18xLmRlZmF1bHQsXG4gICAgICAgIGRlcGVuZGVuY2llc18xLmRlZmF1bHQsXG4gICAgICAgIHByb3BlcnRpZXNfMS5kZWZhdWx0LFxuICAgICAgICBwYXR0ZXJuUHJvcGVydGllc18xLmRlZmF1bHQsXG4gICAgXTtcbiAgICAvLyBhcnJheVxuICAgIGlmIChkcmFmdDIwMjApXG4gICAgICAgIGFwcGxpY2F0b3IucHVzaChwcmVmaXhJdGVtc18xLmRlZmF1bHQsIGl0ZW1zMjAyMF8xLmRlZmF1bHQpO1xuICAgIGVsc2VcbiAgICAgICAgYXBwbGljYXRvci5wdXNoKGFkZGl0aW9uYWxJdGVtc18xLmRlZmF1bHQsIGl0ZW1zXzEuZGVmYXVsdCk7XG4gICAgYXBwbGljYXRvci5wdXNoKGNvbnRhaW5zXzEuZGVmYXVsdCk7XG4gICAgcmV0dXJuIGFwcGxpY2F0b3I7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBnZXRBcHBsaWNhdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsgc2NoZW1hQ29kZSB9KSA9PiAoMCwgY29kZWdlbl8xLnN0cikgYG11c3QgbWF0Y2ggZm9ybWF0IFwiJHtzY2hlbWFDb2RlfVwiYCxcbiAgICBwYXJhbXM6ICh7IHNjaGVtYUNvZGUgfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge2Zvcm1hdDogJHtzY2hlbWFDb2RlfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImZvcm1hdFwiLFxuICAgIHR5cGU6IFtcIm51bWJlclwiLCBcInN0cmluZ1wiXSxcbiAgICBzY2hlbWFUeXBlOiBcInN0cmluZ1wiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0LCBydWxlVHlwZSkge1xuICAgICAgICBjb25zdCB7IGdlbiwgZGF0YSwgJGRhdGEsIHNjaGVtYSwgc2NoZW1hQ29kZSwgaXQgfSA9IGN4dDtcbiAgICAgICAgY29uc3QgeyBvcHRzLCBlcnJTY2hlbWFQYXRoLCBzY2hlbWFFbnYsIHNlbGYgfSA9IGl0O1xuICAgICAgICBpZiAoIW9wdHMudmFsaWRhdGVGb3JtYXRzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoJGRhdGEpXG4gICAgICAgICAgICB2YWxpZGF0ZSREYXRhRm9ybWF0KCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHZhbGlkYXRlRm9ybWF0KCk7XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlJERhdGFGb3JtYXQoKSB7XG4gICAgICAgICAgICBjb25zdCBmbXRzID0gZ2VuLnNjb3BlVmFsdWUoXCJmb3JtYXRzXCIsIHtcbiAgICAgICAgICAgICAgICByZWY6IHNlbGYuZm9ybWF0cyxcbiAgICAgICAgICAgICAgICBjb2RlOiBvcHRzLmNvZGUuZm9ybWF0cyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgZkRlZiA9IGdlbi5jb25zdChcImZEZWZcIiwgKDAsIGNvZGVnZW5fMS5fKSBgJHtmbXRzfVske3NjaGVtYUNvZGV9XWApO1xuICAgICAgICAgICAgY29uc3QgZlR5cGUgPSBnZW4ubGV0KFwiZlR5cGVcIik7XG4gICAgICAgICAgICBjb25zdCBmb3JtYXQgPSBnZW4ubGV0KFwiZm9ybWF0XCIpO1xuICAgICAgICAgICAgLy8gVE9ETyBzaW1wbGlmeVxuICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYHR5cGVvZiAke2ZEZWZ9ID09IFwib2JqZWN0XCIgJiYgISgke2ZEZWZ9IGluc3RhbmNlb2YgUmVnRXhwKWAsICgpID0+IGdlbi5hc3NpZ24oZlR5cGUsICgwLCBjb2RlZ2VuXzEuXykgYCR7ZkRlZn0udHlwZSB8fCBcInN0cmluZ1wiYCkuYXNzaWduKGZvcm1hdCwgKDAsIGNvZGVnZW5fMS5fKSBgJHtmRGVmfS52YWxpZGF0ZWApLCAoKSA9PiBnZW4uYXNzaWduKGZUeXBlLCAoMCwgY29kZWdlbl8xLl8pIGBcInN0cmluZ1wiYCkuYXNzaWduKGZvcm1hdCwgZkRlZikpO1xuICAgICAgICAgICAgY3h0LmZhaWwkZGF0YSgoMCwgY29kZWdlbl8xLm9yKSh1bmtub3duRm10KCksIGludmFsaWRGbXQoKSkpO1xuICAgICAgICAgICAgZnVuY3Rpb24gdW5rbm93bkZtdCgpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0cy5zdHJpY3RTY2hlbWEgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29kZWdlbl8xLm5pbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGNvZGVnZW5fMS5fKSBgJHtzY2hlbWFDb2RlfSAmJiAhJHtmb3JtYXR9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGludmFsaWRGbXQoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FsbEZvcm1hdCA9IHNjaGVtYUVudi4kYXN5bmNcbiAgICAgICAgICAgICAgICAgICAgPyAoMCwgY29kZWdlbl8xLl8pIGAoJHtmRGVmfS5hc3luYyA/IGF3YWl0ICR7Zm9ybWF0fSgke2RhdGF9KSA6ICR7Zm9ybWF0fSgke2RhdGF9KSlgXG4gICAgICAgICAgICAgICAgICAgIDogKDAsIGNvZGVnZW5fMS5fKSBgJHtmb3JtYXR9KCR7ZGF0YX0pYDtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWxpZERhdGEgPSAoMCwgY29kZWdlbl8xLl8pIGAodHlwZW9mICR7Zm9ybWF0fSA9PSBcImZ1bmN0aW9uXCIgPyAke2NhbGxGb3JtYXR9IDogJHtmb3JtYXR9LnRlc3QoJHtkYXRhfSkpYDtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGNvZGVnZW5fMS5fKSBgJHtmb3JtYXR9ICYmICR7Zm9ybWF0fSAhPT0gdHJ1ZSAmJiAke2ZUeXBlfSA9PT0gJHtydWxlVHlwZX0gJiYgISR7dmFsaWREYXRhfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQoKSB7XG4gICAgICAgICAgICBjb25zdCBmb3JtYXREZWYgPSBzZWxmLmZvcm1hdHNbc2NoZW1hXTtcbiAgICAgICAgICAgIGlmICghZm9ybWF0RGVmKSB7XG4gICAgICAgICAgICAgICAgdW5rbm93bkZvcm1hdCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3JtYXREZWYgPT09IHRydWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgW2ZtdFR5cGUsIGZvcm1hdCwgZm10UmVmXSA9IGdldEZvcm1hdChmb3JtYXREZWYpO1xuICAgICAgICAgICAgaWYgKGZtdFR5cGUgPT09IHJ1bGVUeXBlKVxuICAgICAgICAgICAgICAgIGN4dC5wYXNzKHZhbGlkQ29uZGl0aW9uKCkpO1xuICAgICAgICAgICAgZnVuY3Rpb24gdW5rbm93bkZvcm1hdCgpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0cy5zdHJpY3RTY2hlbWEgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYubG9nZ2VyLndhcm4odW5rbm93bk1zZygpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodW5rbm93bk1zZygpKTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB1bmtub3duTXNnKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYHVua25vd24gZm9ybWF0IFwiJHtzY2hlbWF9XCIgaWdub3JlZCBpbiBzY2hlbWEgYXQgcGF0aCBcIiR7ZXJyU2NoZW1hUGF0aH1cImA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0Rm9ybWF0KGZtdERlZikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBmbXREZWYgaW5zdGFuY2VvZiBSZWdFeHBcbiAgICAgICAgICAgICAgICAgICAgPyAoMCwgY29kZWdlbl8xLnJlZ2V4cENvZGUpKGZtdERlZilcbiAgICAgICAgICAgICAgICAgICAgOiBvcHRzLmNvZGUuZm9ybWF0c1xuICAgICAgICAgICAgICAgICAgICAgICAgPyAoMCwgY29kZWdlbl8xLl8pIGAke29wdHMuY29kZS5mb3JtYXRzfSR7KDAsIGNvZGVnZW5fMS5nZXRQcm9wZXJ0eSkoc2NoZW1hKX1gXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBjb25zdCBmbXQgPSBnZW4uc2NvcGVWYWx1ZShcImZvcm1hdHNcIiwgeyBrZXk6IHNjaGVtYSwgcmVmOiBmbXREZWYsIGNvZGUgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbXREZWYgPT0gXCJvYmplY3RcIiAmJiAhKGZtdERlZiBpbnN0YW5jZW9mIFJlZ0V4cCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtmbXREZWYudHlwZSB8fCBcInN0cmluZ1wiLCBmbXREZWYudmFsaWRhdGUsICgwLCBjb2RlZ2VuXzEuXykgYCR7Zm10fS52YWxpZGF0ZWBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gW1wic3RyaW5nXCIsIGZtdERlZiwgZm10XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHZhbGlkQ29uZGl0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm9ybWF0RGVmID09IFwib2JqZWN0XCIgJiYgIShmb3JtYXREZWYgaW5zdGFuY2VvZiBSZWdFeHApICYmIGZvcm1hdERlZi5hc3luYykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNjaGVtYUVudi4kYXN5bmMpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhc3luYyBmb3JtYXQgaW4gc3luYyBzY2hlbWFcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLl8pIGBhd2FpdCAke2ZtdFJlZn0oJHtkYXRhfSlgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIGZvcm1hdCA9PSBcImZ1bmN0aW9uXCIgPyAoMCwgY29kZWdlbl8xLl8pIGAke2ZtdFJlZn0oJHtkYXRhfSlgIDogKDAsIGNvZGVnZW5fMS5fKSBgJHtmbXRSZWZ9LnRlc3QoJHtkYXRhfSlgO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb3JtYXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBmb3JtYXRfMSA9IHJlcXVpcmUoXCIuL2Zvcm1hdFwiKTtcbmNvbnN0IGZvcm1hdCA9IFtmb3JtYXRfMS5kZWZhdWx0XTtcbmV4cG9ydHMuZGVmYXVsdCA9IGZvcm1hdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jb250ZW50Vm9jYWJ1bGFyeSA9IGV4cG9ydHMubWV0YWRhdGFWb2NhYnVsYXJ5ID0gdm9pZCAwO1xuZXhwb3J0cy5tZXRhZGF0YVZvY2FidWxhcnkgPSBbXG4gICAgXCJ0aXRsZVwiLFxuICAgIFwiZGVzY3JpcHRpb25cIixcbiAgICBcImRlZmF1bHRcIixcbiAgICBcImRlcHJlY2F0ZWRcIixcbiAgICBcInJlYWRPbmx5XCIsXG4gICAgXCJ3cml0ZU9ubHlcIixcbiAgICBcImV4YW1wbGVzXCIsXG5dO1xuZXhwb3J0cy5jb250ZW50Vm9jYWJ1bGFyeSA9IFtcbiAgICBcImNvbnRlbnRNZWRpYVR5cGVcIixcbiAgICBcImNvbnRlbnRFbmNvZGluZ1wiLFxuICAgIFwiY29udGVudFNjaGVtYVwiLFxuXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1ldGFkYXRhLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29yZV8xID0gcmVxdWlyZShcIi4vY29yZVwiKTtcbmNvbnN0IHZhbGlkYXRpb25fMSA9IHJlcXVpcmUoXCIuL3ZhbGlkYXRpb25cIik7XG5jb25zdCBhcHBsaWNhdG9yXzEgPSByZXF1aXJlKFwiLi9hcHBsaWNhdG9yXCIpO1xuY29uc3QgZm9ybWF0XzEgPSByZXF1aXJlKFwiLi9mb3JtYXRcIik7XG5jb25zdCBtZXRhZGF0YV8xID0gcmVxdWlyZShcIi4vbWV0YWRhdGFcIik7XG5jb25zdCBkcmFmdDdWb2NhYnVsYXJpZXMgPSBbXG4gICAgY29yZV8xLmRlZmF1bHQsXG4gICAgdmFsaWRhdGlvbl8xLmRlZmF1bHQsXG4gICAgKDAsIGFwcGxpY2F0b3JfMS5kZWZhdWx0KSgpLFxuICAgIGZvcm1hdF8xLmRlZmF1bHQsXG4gICAgbWV0YWRhdGFfMS5tZXRhZGF0YVZvY2FidWxhcnksXG4gICAgbWV0YWRhdGFfMS5jb250ZW50Vm9jYWJ1bGFyeSxcbl07XG5leHBvcnRzLmRlZmF1bHQgPSBkcmFmdDdWb2NhYnVsYXJpZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kcmFmdDcuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRpc2NyRXJyb3IgPSB2b2lkIDA7XG52YXIgRGlzY3JFcnJvcjtcbihmdW5jdGlvbiAoRGlzY3JFcnJvcikge1xuICAgIERpc2NyRXJyb3JbXCJUYWdcIl0gPSBcInRhZ1wiO1xuICAgIERpc2NyRXJyb3JbXCJNYXBwaW5nXCJdID0gXCJtYXBwaW5nXCI7XG59KShEaXNjckVycm9yIHx8IChleHBvcnRzLkRpc2NyRXJyb3IgPSBEaXNjckVycm9yID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKFwiLi4vZGlzY3JpbWluYXRvci90eXBlc1wiKTtcbmNvbnN0IGNvbXBpbGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlXCIpO1xuY29uc3QgcmVmX2Vycm9yXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9yZWZfZXJyb3JcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsgcGFyYW1zOiB7IGRpc2NyRXJyb3IsIHRhZ05hbWUgfSB9KSA9PiBkaXNjckVycm9yID09PSB0eXBlc18xLkRpc2NyRXJyb3IuVGFnXG4gICAgICAgID8gYHRhZyBcIiR7dGFnTmFtZX1cIiBtdXN0IGJlIHN0cmluZ2BcbiAgICAgICAgOiBgdmFsdWUgb2YgdGFnIFwiJHt0YWdOYW1lfVwiIG11c3QgYmUgaW4gb25lT2ZgLFxuICAgIHBhcmFtczogKHsgcGFyYW1zOiB7IGRpc2NyRXJyb3IsIHRhZywgdGFnTmFtZSB9IH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHtlcnJvcjogJHtkaXNjckVycm9yfSwgdGFnOiAke3RhZ05hbWV9LCB0YWdWYWx1ZTogJHt0YWd9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiZGlzY3JpbWluYXRvclwiLFxuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgc2NoZW1hVHlwZTogXCJvYmplY3RcIixcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgZGF0YSwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGNvbnN0IHsgb25lT2YgfSA9IHBhcmVudFNjaGVtYTtcbiAgICAgICAgaWYgKCFpdC5vcHRzLmRpc2NyaW1pbmF0b3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImRpc2NyaW1pbmF0b3I6IHJlcXVpcmVzIGRpc2NyaW1pbmF0b3Igb3B0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhZ05hbWUgPSBzY2hlbWEucHJvcGVydHlOYW1lO1xuICAgICAgICBpZiAodHlwZW9mIHRhZ05hbWUgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImRpc2NyaW1pbmF0b3I6IHJlcXVpcmVzIHByb3BlcnR5TmFtZVwiKTtcbiAgICAgICAgaWYgKHNjaGVtYS5tYXBwaW5nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGlzY3JpbWluYXRvcjogbWFwcGluZyBpcyBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICBpZiAoIW9uZU9mKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGlzY3JpbWluYXRvcjogcmVxdWlyZXMgb25lT2Yga2V5d29yZFwiKTtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIiwgZmFsc2UpO1xuICAgICAgICBjb25zdCB0YWcgPSBnZW4uY29uc3QoXCJ0YWdcIiwgKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfSR7KDAsIGNvZGVnZW5fMS5nZXRQcm9wZXJ0eSkodGFnTmFtZSl9YCk7XG4gICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGB0eXBlb2YgJHt0YWd9ID09IFwic3RyaW5nXCJgLCAoKSA9PiB2YWxpZGF0ZU1hcHBpbmcoKSwgKCkgPT4gY3h0LmVycm9yKGZhbHNlLCB7IGRpc2NyRXJyb3I6IHR5cGVzXzEuRGlzY3JFcnJvci5UYWcsIHRhZywgdGFnTmFtZSB9KSk7XG4gICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlTWFwcGluZygpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hcHBpbmcgPSBnZXRNYXBwaW5nKCk7XG4gICAgICAgICAgICBnZW4uaWYoZmFsc2UpO1xuICAgICAgICAgICAgZm9yIChjb25zdCB0YWdWYWx1ZSBpbiBtYXBwaW5nKSB7XG4gICAgICAgICAgICAgICAgZ2VuLmVsc2VJZigoMCwgY29kZWdlbl8xLl8pIGAke3RhZ30gPT09ICR7dGFnVmFsdWV9YCk7XG4gICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgYXBwbHlUYWdTY2hlbWEobWFwcGluZ1t0YWdWYWx1ZV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdlbi5lbHNlKCk7XG4gICAgICAgICAgICBjeHQuZXJyb3IoZmFsc2UsIHsgZGlzY3JFcnJvcjogdHlwZXNfMS5EaXNjckVycm9yLk1hcHBpbmcsIHRhZywgdGFnTmFtZSB9KTtcbiAgICAgICAgICAgIGdlbi5lbmRJZigpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFwcGx5VGFnU2NoZW1hKHNjaGVtYVByb3ApIHtcbiAgICAgICAgICAgIGNvbnN0IF92YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgICAgICAgICBjb25zdCBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKHsga2V5d29yZDogXCJvbmVPZlwiLCBzY2hlbWFQcm9wIH0sIF92YWxpZCk7XG4gICAgICAgICAgICBjeHQubWVyZ2VFdmFsdWF0ZWQoc2NoQ3h0LCBjb2RlZ2VuXzEuTmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gX3ZhbGlkO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldE1hcHBpbmcoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCBvbmVPZk1hcHBpbmcgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IHRvcFJlcXVpcmVkID0gaGFzUmVxdWlyZWQocGFyZW50U2NoZW1hKTtcbiAgICAgICAgICAgIGxldCB0YWdSZXF1aXJlZCA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9uZU9mLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHNjaCA9IG9uZU9mW2ldO1xuICAgICAgICAgICAgICAgIGlmICgoc2NoID09PSBudWxsIHx8IHNjaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2NoLiRyZWYpICYmICEoMCwgdXRpbF8xLnNjaGVtYUhhc1J1bGVzQnV0UmVmKShzY2gsIGl0LnNlbGYuUlVMRVMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlZiA9IHNjaC4kcmVmO1xuICAgICAgICAgICAgICAgICAgICBzY2ggPSBjb21waWxlXzEucmVzb2x2ZVJlZi5jYWxsKGl0LnNlbGYsIGl0LnNjaGVtYUVudi5yb290LCBpdC5iYXNlSWQsIHJlZik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY2ggaW5zdGFuY2VvZiBjb21waWxlXzEuU2NoZW1hRW52KVxuICAgICAgICAgICAgICAgICAgICAgICAgc2NoID0gc2NoLnNjaGVtYTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjaCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IHJlZl9lcnJvcl8xLmRlZmF1bHQoaXQub3B0cy51cmlSZXNvbHZlciwgaXQuYmFzZUlkLCByZWYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wU2NoID0gKF9hID0gc2NoID09PSBudWxsIHx8IHNjaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2NoLnByb3BlcnRpZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVt0YWdOYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHByb3BTY2ggIT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRpc2NyaW1pbmF0b3I6IG9uZU9mIHN1YnNjaGVtYXMgKG9yIHJlZmVyZW5jZWQgc2NoZW1hcykgbXVzdCBoYXZlIFwicHJvcGVydGllcy8ke3RhZ05hbWV9XCJgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGFnUmVxdWlyZWQgPSB0YWdSZXF1aXJlZCAmJiAodG9wUmVxdWlyZWQgfHwgaGFzUmVxdWlyZWQoc2NoKSk7XG4gICAgICAgICAgICAgICAgYWRkTWFwcGluZ3MocHJvcFNjaCwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRhZ1JlcXVpcmVkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZGlzY3JpbWluYXRvcjogXCIke3RhZ05hbWV9XCIgbXVzdCBiZSByZXF1aXJlZGApO1xuICAgICAgICAgICAgcmV0dXJuIG9uZU9mTWFwcGluZztcbiAgICAgICAgICAgIGZ1bmN0aW9uIGhhc1JlcXVpcmVkKHsgcmVxdWlyZWQgfSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHJlcXVpcmVkKSAmJiByZXF1aXJlZC5pbmNsdWRlcyh0YWdOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGFkZE1hcHBpbmdzKHNjaCwgaSkge1xuICAgICAgICAgICAgICAgIGlmIChzY2guY29uc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkTWFwcGluZyhzY2guY29uc3QsIGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzY2guZW51bSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHRhZ1ZhbHVlIG9mIHNjaC5lbnVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRNYXBwaW5nKHRhZ1ZhbHVlLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkaXNjcmltaW5hdG9yOiBcInByb3BlcnRpZXMvJHt0YWdOYW1lfVwiIG11c3QgaGF2ZSBcImNvbnN0XCIgb3IgXCJlbnVtXCJgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBhZGRNYXBwaW5nKHRhZ1ZhbHVlLCBpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0YWdWYWx1ZSAhPSBcInN0cmluZ1wiIHx8IHRhZ1ZhbHVlIGluIG9uZU9mTWFwcGluZykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRpc2NyaW1pbmF0b3I6IFwiJHt0YWdOYW1lfVwiIHZhbHVlcyBtdXN0IGJlIHVuaXF1ZSBzdHJpbmdzYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9uZU9mTWFwcGluZ1t0YWdWYWx1ZV0gPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJ7XG4gIFwiJHNjaGVtYVwiOiBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDcvc2NoZW1hI1wiLFxuICBcIiRpZFwiOiBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDcvc2NoZW1hI1wiLFxuICBcInRpdGxlXCI6IFwiQ29yZSBzY2hlbWEgbWV0YS1zY2hlbWFcIixcbiAgXCJkZWZpbml0aW9uc1wiOiB7XG4gICAgXCJzY2hlbWFBcnJheVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgXCJtaW5JdGVtc1wiOiAxLFxuICAgICAgXCJpdGVtc1wiOiB7XCIkcmVmXCI6IFwiI1wifVxuICAgIH0sXG4gICAgXCJub25OZWdhdGl2ZUludGVnZXJcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiLFxuICAgICAgXCJtaW5pbXVtXCI6IDBcbiAgICB9LFxuICAgIFwibm9uTmVnYXRpdmVJbnRlZ2VyRGVmYXVsdDBcIjoge1xuICAgICAgXCJhbGxPZlwiOiBbe1wiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvbm9uTmVnYXRpdmVJbnRlZ2VyXCJ9LCB7XCJkZWZhdWx0XCI6IDB9XVxuICAgIH0sXG4gICAgXCJzaW1wbGVUeXBlc1wiOiB7XG4gICAgICBcImVudW1cIjogW1wiYXJyYXlcIiwgXCJib29sZWFuXCIsIFwiaW50ZWdlclwiLCBcIm51bGxcIiwgXCJudW1iZXJcIiwgXCJvYmplY3RcIiwgXCJzdHJpbmdcIl1cbiAgICB9LFxuICAgIFwic3RyaW5nQXJyYXlcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwiaXRlbXNcIjoge1widHlwZVwiOiBcInN0cmluZ1wifSxcbiAgICAgIFwidW5pcXVlSXRlbXNcIjogdHJ1ZSxcbiAgICAgIFwiZGVmYXVsdFwiOiBbXVxuICAgIH1cbiAgfSxcbiAgXCJ0eXBlXCI6IFtcIm9iamVjdFwiLCBcImJvb2xlYW5cIl0sXG4gIFwicHJvcGVydGllc1wiOiB7XG4gICAgXCIkaWRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImZvcm1hdFwiOiBcInVyaS1yZWZlcmVuY2VcIlxuICAgIH0sXG4gICAgXCIkc2NoZW1hXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJmb3JtYXRcIjogXCJ1cmlcIlxuICAgIH0sXG4gICAgXCIkcmVmXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJmb3JtYXRcIjogXCJ1cmktcmVmZXJlbmNlXCJcbiAgICB9LFxuICAgIFwiJGNvbW1lbnRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICB9LFxuICAgIFwidGl0bGVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICB9LFxuICAgIFwiZGVzY3JpcHRpb25cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICB9LFxuICAgIFwiZGVmYXVsdFwiOiB0cnVlLFxuICAgIFwicmVhZE9ubHlcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgXCJkZWZhdWx0XCI6IGZhbHNlXG4gICAgfSxcbiAgICBcImV4YW1wbGVzXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcIml0ZW1zXCI6IHRydWVcbiAgICB9LFxuICAgIFwibXVsdGlwbGVPZlwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZXhjbHVzaXZlTWluaW11bVwiOiAwXG4gICAgfSxcbiAgICBcIm1heGltdW1cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCJcbiAgICB9LFxuICAgIFwiZXhjbHVzaXZlTWF4aW11bVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIlxuICAgIH0sXG4gICAgXCJtaW5pbXVtXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiXG4gICAgfSxcbiAgICBcImV4Y2x1c2l2ZU1pbmltdW1cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCJcbiAgICB9LFxuICAgIFwibWF4TGVuZ3RoXCI6IHtcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL25vbk5lZ2F0aXZlSW50ZWdlclwifSxcbiAgICBcIm1pbkxlbmd0aFwiOiB7XCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9ub25OZWdhdGl2ZUludGVnZXJEZWZhdWx0MFwifSxcbiAgICBcInBhdHRlcm5cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImZvcm1hdFwiOiBcInJlZ2V4XCJcbiAgICB9LFxuICAgIFwiYWRkaXRpb25hbEl0ZW1zXCI6IHtcIiRyZWZcIjogXCIjXCJ9LFxuICAgIFwiaXRlbXNcIjoge1xuICAgICAgXCJhbnlPZlwiOiBbe1wiJHJlZlwiOiBcIiNcIn0sIHtcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL3NjaGVtYUFycmF5XCJ9XSxcbiAgICAgIFwiZGVmYXVsdFwiOiB0cnVlXG4gICAgfSxcbiAgICBcIm1heEl0ZW1zXCI6IHtcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL25vbk5lZ2F0aXZlSW50ZWdlclwifSxcbiAgICBcIm1pbkl0ZW1zXCI6IHtcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL25vbk5lZ2F0aXZlSW50ZWdlckRlZmF1bHQwXCJ9LFxuICAgIFwidW5pcXVlSXRlbXNcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgXCJkZWZhdWx0XCI6IGZhbHNlXG4gICAgfSxcbiAgICBcImNvbnRhaW5zXCI6IHtcIiRyZWZcIjogXCIjXCJ9LFxuICAgIFwibWF4UHJvcGVydGllc1wiOiB7XCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9ub25OZWdhdGl2ZUludGVnZXJcIn0sXG4gICAgXCJtaW5Qcm9wZXJ0aWVzXCI6IHtcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL25vbk5lZ2F0aXZlSW50ZWdlckRlZmF1bHQwXCJ9LFxuICAgIFwicmVxdWlyZWRcIjoge1wiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvc3RyaW5nQXJyYXlcIn0sXG4gICAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiB7XCIkcmVmXCI6IFwiI1wifSxcbiAgICBcImRlZmluaXRpb25zXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICAgICAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiB7XCIkcmVmXCI6IFwiI1wifSxcbiAgICAgIFwiZGVmYXVsdFwiOiB7fVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICAgICAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiB7XCIkcmVmXCI6IFwiI1wifSxcbiAgICAgIFwiZGVmYXVsdFwiOiB7fVxuICAgIH0sXG4gICAgXCJwYXR0ZXJuUHJvcGVydGllc1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgICAgIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjoge1wiJHJlZlwiOiBcIiNcIn0sXG4gICAgICBcInByb3BlcnR5TmFtZXNcIjoge1wiZm9ybWF0XCI6IFwicmVnZXhcIn0sXG4gICAgICBcImRlZmF1bHRcIjoge31cbiAgICB9LFxuICAgIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICAgICAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiB7XG4gICAgICAgIFwiYW55T2ZcIjogW3tcIiRyZWZcIjogXCIjXCJ9LCB7XCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9zdHJpbmdBcnJheVwifV1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwicHJvcGVydHlOYW1lc1wiOiB7XCIkcmVmXCI6IFwiI1wifSxcbiAgICBcImNvbnN0XCI6IHRydWUsXG4gICAgXCJlbnVtXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcIml0ZW1zXCI6IHRydWUsXG4gICAgICBcIm1pbkl0ZW1zXCI6IDEsXG4gICAgICBcInVuaXF1ZUl0ZW1zXCI6IHRydWVcbiAgICB9LFxuICAgIFwidHlwZVwiOiB7XG4gICAgICBcImFueU9mXCI6IFtcbiAgICAgICAge1wiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvc2ltcGxlVHlwZXNcIn0sXG4gICAgICAgIHtcbiAgICAgICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgICAgIFwiaXRlbXNcIjoge1wiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvc2ltcGxlVHlwZXNcIn0sXG4gICAgICAgICAgXCJtaW5JdGVtc1wiOiAxLFxuICAgICAgICAgIFwidW5pcXVlSXRlbXNcIjogdHJ1ZVxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSxcbiAgICBcImZvcm1hdFwiOiB7XCJ0eXBlXCI6IFwic3RyaW5nXCJ9LFxuICAgIFwiY29udGVudE1lZGlhVHlwZVwiOiB7XCJ0eXBlXCI6IFwic3RyaW5nXCJ9LFxuICAgIFwiY29udGVudEVuY29kaW5nXCI6IHtcInR5cGVcIjogXCJzdHJpbmdcIn0sXG4gICAgXCJpZlwiOiB7XCIkcmVmXCI6IFwiI1wifSxcbiAgICBcInRoZW5cIjoge1wiJHJlZlwiOiBcIiNcIn0sXG4gICAgXCJlbHNlXCI6IHtcIiRyZWZcIjogXCIjXCJ9LFxuICAgIFwiYWxsT2ZcIjoge1wiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvc2NoZW1hQXJyYXlcIn0sXG4gICAgXCJhbnlPZlwiOiB7XCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9zY2hlbWFBcnJheVwifSxcbiAgICBcIm9uZU9mXCI6IHtcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL3NjaGVtYUFycmF5XCJ9LFxuICAgIFwibm90XCI6IHtcIiRyZWZcIjogXCIjXCJ9XG4gIH0sXG4gIFwiZGVmYXVsdFwiOiB0cnVlXG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWlzc2luZ1JlZkVycm9yID0gZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IgPSBleHBvcnRzLkNvZGVHZW4gPSBleHBvcnRzLk5hbWUgPSBleHBvcnRzLm5pbCA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gZXhwb3J0cy5zdHIgPSBleHBvcnRzLl8gPSBleHBvcnRzLktleXdvcmRDeHQgPSBleHBvcnRzLkFqdiA9IHZvaWQgMDtcbmNvbnN0IGNvcmVfMSA9IHJlcXVpcmUoXCIuL2NvcmVcIik7XG5jb25zdCBkcmFmdDdfMSA9IHJlcXVpcmUoXCIuL3ZvY2FidWxhcmllcy9kcmFmdDdcIik7XG5jb25zdCBkaXNjcmltaW5hdG9yXzEgPSByZXF1aXJlKFwiLi92b2NhYnVsYXJpZXMvZGlzY3JpbWluYXRvclwiKTtcbmNvbnN0IGRyYWZ0N01ldGFTY2hlbWEgPSByZXF1aXJlKFwiLi9yZWZzL2pzb24tc2NoZW1hLWRyYWZ0LTA3Lmpzb25cIik7XG5jb25zdCBNRVRBX1NVUFBPUlRfREFUQSA9IFtcIi9wcm9wZXJ0aWVzXCJdO1xuY29uc3QgTUVUQV9TQ0hFTUFfSUQgPSBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDcvc2NoZW1hXCI7XG5jbGFzcyBBanYgZXh0ZW5kcyBjb3JlXzEuZGVmYXVsdCB7XG4gICAgX2FkZFZvY2FidWxhcmllcygpIHtcbiAgICAgICAgc3VwZXIuX2FkZFZvY2FidWxhcmllcygpO1xuICAgICAgICBkcmFmdDdfMS5kZWZhdWx0LmZvckVhY2goKHYpID0+IHRoaXMuYWRkVm9jYWJ1bGFyeSh2KSk7XG4gICAgICAgIGlmICh0aGlzLm9wdHMuZGlzY3JpbWluYXRvcilcbiAgICAgICAgICAgIHRoaXMuYWRkS2V5d29yZChkaXNjcmltaW5hdG9yXzEuZGVmYXVsdCk7XG4gICAgfVxuICAgIF9hZGREZWZhdWx0TWV0YVNjaGVtYSgpIHtcbiAgICAgICAgc3VwZXIuX2FkZERlZmF1bHRNZXRhU2NoZW1hKCk7XG4gICAgICAgIGlmICghdGhpcy5vcHRzLm1ldGEpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IG1ldGFTY2hlbWEgPSB0aGlzLm9wdHMuJGRhdGFcbiAgICAgICAgICAgID8gdGhpcy4kZGF0YU1ldGFTY2hlbWEoZHJhZnQ3TWV0YVNjaGVtYSwgTUVUQV9TVVBQT1JUX0RBVEEpXG4gICAgICAgICAgICA6IGRyYWZ0N01ldGFTY2hlbWE7XG4gICAgICAgIHRoaXMuYWRkTWV0YVNjaGVtYShtZXRhU2NoZW1hLCBNRVRBX1NDSEVNQV9JRCwgZmFsc2UpO1xuICAgICAgICB0aGlzLnJlZnNbXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL3NjaGVtYVwiXSA9IE1FVEFfU0NIRU1BX0lEO1xuICAgIH1cbiAgICBkZWZhdWx0TWV0YSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLm9wdHMuZGVmYXVsdE1ldGEgPVxuICAgICAgICAgICAgc3VwZXIuZGVmYXVsdE1ldGEoKSB8fCAodGhpcy5nZXRTY2hlbWEoTUVUQV9TQ0hFTUFfSUQpID8gTUVUQV9TQ0hFTUFfSUQgOiB1bmRlZmluZWQpKTtcbiAgICB9XG59XG5leHBvcnRzLkFqdiA9IEFqdjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IEFqdjtcbm1vZHVsZS5leHBvcnRzLkFqdiA9IEFqdjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEFqdjtcbnZhciB2YWxpZGF0ZV8xID0gcmVxdWlyZShcIi4vY29tcGlsZS92YWxpZGF0ZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIktleXdvcmRDeHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbGlkYXRlXzEuS2V5d29yZEN4dDsgfSB9KTtcbnZhciBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi9jb21waWxlL2NvZGVnZW5cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuXzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0clwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLnN0cjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0cmluZ2lmeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLnN0cmluZ2lmeTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm5pbFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLm5pbDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5hbWVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVnZW5fMS5OYW1lOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29kZUdlblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLkNvZGVHZW47IH0gfSk7XG52YXIgdmFsaWRhdGlvbl9lcnJvcl8xID0gcmVxdWlyZShcIi4vcnVudGltZS92YWxpZGF0aW9uX2Vycm9yXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVmFsaWRhdGlvbkVycm9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB2YWxpZGF0aW9uX2Vycm9yXzEuZGVmYXVsdDsgfSB9KTtcbnZhciByZWZfZXJyb3JfMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvcmVmX2Vycm9yXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTWlzc2luZ1JlZkVycm9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWZfZXJyb3JfMS5kZWZhdWx0OyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWp2LmpzLm1hcCIsIlxuXG5jb25zdCBGTlZfT0ZGU0VUXzEgPSAweGNiZjI5Y2U0ODQyMjIzMjVuO1xuY29uc3QgRk5WX09GRlNFVF8yID0gMHg4NDIyMjMyNWNiZjI5Y2U0bjtcbmNvbnN0IEZOVl9QUklNRSA9IDB4MTAwMDAwMDAxYjNuO1xuY29uc3QgTUFTS182NCA9ICgxbiA8PCA2NG4pIC0gMW47XG5cbmNvbnN0IGhhc2g2NCA9ICh2YWx1ZTogc3RyaW5nLCBvZmZzZXQ6IGJpZ2ludCk6IGJpZ2ludCA9PiB7XG4gIGxldCBoYXNoID0gb2Zmc2V0O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgaGFzaCBePSBCaWdJbnQodmFsdWUuY2hhckNvZGVBdChpKSk7XG4gICAgaGFzaCA9IChoYXNoICogRk5WX1BSSU1FKSAmIE1BU0tfNjQ7XG4gIH1cbiAgcmV0dXJuIGhhc2g7XG59O1xuXG5jb25zdCB0b0hleDY0ID0gKHZhbHVlOiBiaWdpbnQpID0+IHZhbHVlLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgxNiwgXCIwXCIpO1xuXG5leHBvcnQgY29uc3QgaGFzaDEyOCA9ICguLi5kYXRhOmFueSk6IHN0cmluZyA9PiB7XG4gIGNvbnN0IGlucHV0ID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gIGNvbnN0IGhpZ2ggPSBoYXNoNjQoaW5wdXQsIEZOVl9PRkZTRVRfMSk7XG4gIGNvbnN0IGxvdyA9IGhhc2g2NChpbnB1dCwgRk5WX09GRlNFVF8yKTtcbiAgcmV0dXJuIGAke3RvSGV4NjQoaGlnaCl9JHt0b0hleDY0KGxvdyl9YDtcbn07XG4iLCJpbXBvcnQgeyBoYXNoMTI4IH0gZnJvbSBcIi4vaGFzaFwiXG5jb25zdCBzdHJpbmcgPSB7IHR5cGUgOiBcInN0cmluZ1wifVxuY29uc3QgbnVtYmVyID0geyB0eXBlIDogXCJudW1iZXJcIn1cbmNvbnN0IG9iamVjdCA9IChwcm9wZXJ0aWVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LCBleHRyYTogYW55ID0ge30pID0+ICh7XG4gIHR5cGU6IFwib2JqZWN0XCIsXG4gIHByb3BlcnRpZXMsXG4gIHJlcXVpcmVkOiBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSxcbiAgLi4uZXh0cmEsXG59KVxuXG50eXBlIE5vdGVEYXRhID0geyBzY2hlbWFIYXNoOiBcIjBcIiwgZGF0YTogXCJ7fVwiIH0gfCB7IHNjaGVtYUhhc2g6IHN0cmluZywgZGF0YTogc3RyaW5nIH1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc2hEYXRhKGRhdGE6IHN0cmluZywgc2NoZW1hSGFzaDogc3RyaW5nKXtcbiAgaWYgKHNjaGVtYUhhc2ggPT09IFwiMFwiICYmIGRhdGEgIT0gXCJ7fVwiKSB0aHJvdyBuZXcgRXJyb3IoXCJzY2hlbWEgaGFzaCBpcyAwIGJ1dCBkYXRhIGlzIG5vdCBlbXB0eVwiKVxuICByZXR1cm4gaGFzaDEyOChTdHJpbmcoc2NoZW1hSGFzaCksIGRhdGEpIFxufVxuXG5mdW5jdGlvbiBOb3RlRGF0YShzY2hlbWE6IE5vdGVEYXRhLCBkYXRhOiBhbnkpOiBOb3RlRGF0YXtcblxuICByZXR1cm4ge1xuICAgIHNjaGVtYUhhc2g6IGhhc2hEYXRhKHNjaGVtYS5kYXRhLCBzY2hlbWEuc2NoZW1hSGFzaCksXG4gICAgZGF0YTogSlNPTi5zdHJpbmdpZnkoZGF0YSlcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgdG9wOiBOb3RlRGF0YSA9IHtzY2hlbWFIYXNoOlwiMFwiLCBkYXRhOiBcInt9XCJ9XG5cbmNvbnN0IHNjcmlwdF9zY2hlbWEgPSBOb3RlRGF0YSh0b3AsIG9iamVjdCh7XG4gIHRpdGxlOiBzdHJpbmcsXG4gIGNvZGU6IHN0cmluZyxcbn0sIHtcbiAgdGl0bGU6IFwic2NyaXB0X3NjaGVtYVwiXG59KSlcblxuZXhwb3J0IGNvbnN0IHNjaGVtYXMgOiBOb3RlRGF0YVtdID0gW1xuICBzY3JpcHRfc2NoZW1hXG5dXG5cbiIsImltcG9ydCB7IHNjaGVtYSwgdGFibGUsIHQsIFNlbmRlckVycm9yIH0gZnJvbSAnc3BhY2V0aW1lZGIvc2VydmVyJztcbmltcG9ydCB7IEFqdiB9IGZyb20gJ2Fqdic7XG5pbXBvcnQgeyBoYXNoRGF0YSwgc2NoZW1hcyB9IGZyb20gJy4vc2NoZW1hcyc7XG5pbXBvcnQgeyBoYXNoMTI4IH0gZnJvbSAnLi9oYXNoJztcblxuY29uc3QgSnNvbk5vdGVzID0gdGFibGUoXG4gIHtcbiAgICBuYW1lOiAnbm90ZScsXG4gICAgcHVibGljOiB0cnVlLFxuICB9LFxuICB7XG4gICAgaWQ6IHQudTY0KCkucHJpbWFyeUtleSgpLFxuICAgIHNjaGVtYUlkOiB0LnU2NCgpLFxuICAgIGRhdGE6IHQuc3RyaW5nKCksXG4gICAgaGFzaDogdC5zdHJpbmcoKS51bmlxdWUoKSxcbiAgfVxuKTtcblxuZXhwb3J0IGNvbnN0IHNwYWNldGltZWRiID0gc2NoZW1hKEpzb25Ob3Rlcyk7XG5cbmNvbnN0IGFqdiA9IG5ldyBBanYoKTtcblxuY29uc3QgYWRkX25vdGUgPSBzcGFjZXRpbWVkYi5yZWR1Y2VyKCdhZGRfbm90ZScsIHtcbiAgc2NoZW1hSWQ6IHQudTEyOCgpLFxuICBkYXRhOiB0LnN0cmluZygpLFxufSwgKGN0eCwgeyBzY2hlbWFJZCwgZGF0YSB9KSA9PiB7XG5cbiAgY29uc3Qgc2NoZW1hUm93ID0gY3R4LmRiLm5vdGUuaWQuZmluZChzY2hlbWFJZCk7XG4gIGlmICghc2NoZW1hUm93KSB0aHJvdyBuZXcgU2VuZGVyRXJyb3IoJ1NjaGVtYSBub3QgZm91bmQnKTtcblxuICBjb25zdCB2YWxpZGF0ZSA9IGFqdi5jb21waWxlKEpTT04ucGFyc2Uoc2NoZW1hUm93LmRhdGEpKTtcbiAgaWYgKCF2YWxpZGF0ZShKU09OLnBhcnNlKGRhdGEpKSkgdGhyb3cgbmV3IFNlbmRlckVycm9yKHZhbGlkYXRlLmVycm9ycz8ubWFwKChlKSA9PiBlLm1lc3NhZ2UpLmpvaW4oJywgJykgfHwgJ0ludmFsaWQgZGF0YScpO1xuICBsZXQgaWQgPSBjdHguZGIubm90ZS5jb3VudCgpO1xuXG4gIGNvbnN0IGhhc2ggPSBoYXNoRGF0YShkYXRhLCBTdHJpbmcoc2NoZW1hUm93Lmhhc2gpKTtcbiAgaWYgKGN0eC5kYi5ub3RlLmhhc2guZmluZChoYXNoKSkgcmV0dXJuO1xuICBjdHguZGIubm90ZS5pbnNlcnQoeyBpZCwgc2NoZW1hSWQsIGRhdGEsIGhhc2h9KVxuXG59KTtcblxuXG5jb25zdCBzZXR1cCA9IHNwYWNldGltZWRiLnJlZHVjZXIoJ3NldHVwJywge30sIChjdHgpID0+IHtcbiAgdHJ5e1xuICAgIGN0eC5kYi5ub3RlLmluc2VydCh7aWQ6IDBuLCBzY2hlbWFJZDogMG4sIGRhdGE6IFwie31cIiwgaGFzaDogIGhhc2hEYXRhKFwie31cIiwgXCIwXCIpfSlcbiAgfWNhdGNoIHt9XG4gIGZvciAoY29uc3Qgbm90ZSBvZiBzY2hlbWFzKSB7XG4gICAgY29uc3Qgc2NoZW1hUm93ID0gY3R4LmRiLm5vdGUuaGFzaC5maW5kKG5vdGUuc2NoZW1hSGFzaClcbiAgICBpZiAoIXNjaGVtYVJvdykgdGhyb3cgbmV3IEVycm9yKFwiU2NoZW1hIG5vdCBmb3VuZFwiKVxuICAgIGFkZF9ub3RlKGN0eCwge3NjaGVtYUlkOiBzY2hlbWFSb3cuaWQsIGRhdGE6IG5vdGUuZGF0YX0pXG4gIH1cbn0pXG5cbnNwYWNldGltZWRiLmluaXQoc2V0dXApXG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLElBQUlBLGFBQVcsT0FBTztBQUN0QixJQUFJQyxjQUFZLE9BQU87QUFDdkIsSUFBSUMscUJBQW1CLE9BQU87QUFDOUIsSUFBSUMsc0JBQW9CLE9BQU87QUFDL0IsSUFBSUMsaUJBQWUsT0FBTztBQUMxQixJQUFJQyxpQkFBZSxPQUFPLFVBQVU7QUFDcEMsSUFBSUMsZ0JBQWMsSUFBSSxRQUFRLFNBQVMsWUFBWTtBQUNqRCxRQUFPLFFBQVEsR0FBRyxHQUFHSCxvQkFBa0IsR0FBRyxDQUFDLE1BQU0sTUFBTSxFQUFFLFNBQVMsRUFBRSxFQUFFLEVBQUUsU0FBUyxJQUFJLEVBQUUsSUFBSTs7QUFFN0YsSUFBSUksaUJBQWUsSUFBSSxNQUFNLFFBQVEsU0FBUztBQUM1QyxLQUFJLFFBQVEsT0FBTyxTQUFT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aEI7Q0FDRSxNQUFNO0NBQ04sUUFBUTtDQUNULEVBQ0Q7Q0FDRSxJQUFJLEVBQUUsS0FBSyxDQUFDLFlBQVk7Q0FDeEIsVUFBVSxFQUFFLEtBQUs7Q0FDakIsTUFBTSxFQUFFLFFBQVE7Q0FDaEIsTUFBTSxFQUFFLFFBQVEsQ0FBQyxRQUFRO0NBQzFCLENBQ0Y7QUFFRCxNQUFhLGNBQWMsT0FBTyxVQUFVO0FBRTVDLE1BQU0sTUFBTSxJQUFJQyxnQkFBSztBQUVyQixNQUFNLFdBQVcsWUFBWSxRQUFRLFlBQVk7Q0FDL0MsVUFBVSxFQUFFLE1BQU07Q0FDbEIsTUFBTSxFQUFFLFFBQVE7Q0FDakIsR0FBRyxLQUFLLEVBQUUsVUFBVSxXQUFXO0NBRTlCLE1BQU0sWUFBWSxJQUFJLEdBQUcsS0FBSyxHQUFHLEtBQUssU0FBUztBQUMvQyxLQUFJLENBQUMsVUFBVyxPQUFNLElBQUksWUFBWSxtQkFBbUI7Q0FFekQsTUFBTSxXQUFXLElBQUksUUFBUSxLQUFLLE1BQU0sVUFBVSxLQUFLLENBQUM7QUFDeEQsS0FBSSxDQUFDLFNBQVMsS0FBSyxNQUFNLEtBQUssQ0FBQyxDQUFFLE9BQU0sSUFBSSxZQUFZLFNBQVMsUUFBUSxLQUFLLE1BQU0sRUFBRSxRQUFRLENBQUMsS0FBSyxLQUFLLElBQUksZUFBZTtDQUMzSCxJQUFJLEtBQUssSUFBSSxHQUFHLEtBQUssT0FBTztDQUU1QixNQUFNLE9BQU8sU0FBUyxNQUFNLE9BQU8sVUFBVSxLQUFLLENBQUM7QUFDbkQsS0FBSSxJQUFJLEdBQUcsS0FBSyxLQUFLLEtBQUssS0FBSyxDQUFFO0FBQ2pDLEtBQUksR0FBRyxLQUFLLE9BQU87RUFBRTtFQUFJO0VBQVU7RUFBTTtFQUFLLENBQUM7RUFFL0M7QUFHRixNQUFNLFFBQVEsWUFBWSxRQUFRLFNBQVMsRUFBRSxHQUFHLFFBQVE7QUFDdEQsS0FBRztBQUNELE1BQUksR0FBRyxLQUFLLE9BQU87R0FBQyxJQUFJO0dBQUksVUFBVTtHQUFJLE1BQU07R0FBTSxNQUFPLFNBQVMsTUFBTSxJQUFJO0dBQUMsQ0FBQztTQUM3RTtBQUNQLE1BQUssTUFBTSxRQUFRLFNBQVM7RUFDMUIsTUFBTSxZQUFZLElBQUksR0FBRyxLQUFLLEtBQUssS0FBSyxLQUFLLFdBQVc7QUFDeEQsTUFBSSxDQUFDLFVBQVcsT0FBTSxJQUFJLE1BQU0sbUJBQW1CO0FBQ25ELFdBQVMsS0FBSztHQUFDLFVBQVUsVUFBVTtHQUFJLE1BQU0sS0FBSztHQUFLLENBQUM7O0VBRTFEO0FBRUYsWUFBWSxLQUFLLE1BQU0iLCJkZWJ1Z0lkIjoiM2UwZGU3NjYtNTkwYi00YmUyLTgwZDctM2U4Y2I1MTBmMTY0In0=