import * as _syscalls1_0 from "spacetime:sys@1.0";
import { register_hooks } from "spacetime:sys@1.0";
import { register_hooks as register_hooks$1 } from "spacetime:sys@1.1";
import * as _syscalls1_2 from "spacetime:sys@1.2";
import { register_hooks as register_hooks$2 } from "spacetime:sys@1.2";

//#region rolldown:runtime
var __create$2 = Object.create;
var __defProp$2 = Object.defineProperty;
var __getOwnPropDesc$2 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames$2 = Object.getOwnPropertyNames;
var __getProtoOf$2 = Object.getPrototypeOf;
var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
var __commonJS$2 = (cb, mod) => function() {
	return mod || (0, cb[__getOwnPropNames$2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps$2 = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") for (var keys = __getOwnPropNames$2(from), i = 0, n = keys.length, key; i < n; i++) {
		key = keys[i];
		if (!__hasOwnProp$2.call(to, key) && key !== except) __defProp$2(to, key, {
			get: ((k) => from[k]).bind(null, key),
			enumerable: !(desc = __getOwnPropDesc$2(from, key)) || desc.enumerable
		});
	}
	return to;
};
var __toESM$2 = (mod, isNodeMode, target) => (target = mod != null ? __create$2(__getProtoOf$2(mod)) : {}, __copyProps$2(isNodeMode || !mod || !mod.__esModule ? __defProp$2(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));

//#endregion
//#region ../node_modules/headers-polyfill/lib/index.mjs
var __create$1 = Object.create;
var __defProp$1 = Object.defineProperty;
var __getOwnPropDesc$1 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames$1 = Object.getOwnPropertyNames;
var __getProtoOf$1 = Object.getPrototypeOf;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __commonJS$1 = (cb, mod) => function __require() {
	return mod || (0, cb[__getOwnPropNames$1(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps$1 = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") {
		for (let key of __getOwnPropNames$1(from)) if (!__hasOwnProp$1.call(to, key) && key !== except) __defProp$1(to, key, {
			get: () => from[key],
			enumerable: !(desc = __getOwnPropDesc$1(from, key)) || desc.enumerable
		});
	}
	return to;
};
var __toESM$1 = (mod, isNodeMode, target) => (target = mod != null ? __create$1(__getProtoOf$1(mod)) : {}, __copyProps$1(isNodeMode || !mod || !mod.__esModule ? __defProp$1(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));
var import_set_cookie_parser = __toESM$1(__commonJS$1({ "node_modules/set-cookie-parser/lib/set-cookie.js"(exports$1, module$1) {
	var defaultParseOptions = {
		decodeValues: true,
		map: false,
		silent: false
	};
	function isNonEmptyString(str$1) {
		return typeof str$1 === "string" && !!str$1.trim();
	}
	function parseString(setCookieValue, options) {
		var parts = setCookieValue.split(";").filter(isNonEmptyString);
		var parsed = parseNameValuePair(parts.shift());
		var name = parsed.name;
		var value = parsed.value;
		options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
		try {
			value = options.decodeValues ? decodeURIComponent(value) : value;
		} catch (e) {
			console.error("set-cookie-parser encountered an error while decoding a cookie with value '" + value + "'. Set options.decodeValues to false to disable this feature.", e);
		}
		var cookie = {
			name,
			value
		};
		parts.forEach(function(part) {
			var sides = part.split("=");
			var key = sides.shift().trimLeft().toLowerCase();
			var value2 = sides.join("=");
			if (key === "expires") cookie.expires = new Date(value2);
			else if (key === "max-age") cookie.maxAge = parseInt(value2, 10);
			else if (key === "secure") cookie.secure = true;
			else if (key === "httponly") cookie.httpOnly = true;
			else if (key === "samesite") cookie.sameSite = value2;
			else cookie[key] = value2;
		});
		return cookie;
	}
	function parseNameValuePair(nameValuePairStr) {
		var name = "";
		var value = "";
		var nameValueArr = nameValuePairStr.split("=");
		if (nameValueArr.length > 1) {
			name = nameValueArr.shift();
			value = nameValueArr.join("=");
		} else value = nameValuePairStr;
		return {
			name,
			value
		};
	}
	function parse$2(input, options) {
		options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
		if (!input) if (!options.map) return [];
		else return {};
		if (input.headers) if (typeof input.headers.getSetCookie === "function") input = input.headers.getSetCookie();
		else if (input.headers["set-cookie"]) input = input.headers["set-cookie"];
		else {
			var sch = input.headers[Object.keys(input.headers).find(function(key) {
				return key.toLowerCase() === "set-cookie";
			})];
			if (!sch && input.headers.cookie && !options.silent) console.warn("Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning.");
			input = sch;
		}
		if (!Array.isArray(input)) input = [input];
		options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
		if (!options.map) return input.filter(isNonEmptyString).map(function(str$1) {
			return parseString(str$1, options);
		});
		else return input.filter(isNonEmptyString).reduce(function(cookies2, str$1) {
			var cookie = parseString(str$1, options);
			cookies2[cookie.name] = cookie;
			return cookies2;
		}, {});
	}
	function splitCookiesString2(cookiesString) {
		if (Array.isArray(cookiesString)) return cookiesString;
		if (typeof cookiesString !== "string") return [];
		var cookiesStrings = [];
		var pos = 0;
		var start;
		var ch;
		var lastComma;
		var nextStart;
		var cookiesSeparatorFound;
		function skipWhitespace() {
			while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) pos += 1;
			return pos < cookiesString.length;
		}
		function notSpecialChar() {
			ch = cookiesString.charAt(pos);
			return ch !== "=" && ch !== ";" && ch !== ",";
		}
		while (pos < cookiesString.length) {
			start = pos;
			cookiesSeparatorFound = false;
			while (skipWhitespace()) {
				ch = cookiesString.charAt(pos);
				if (ch === ",") {
					lastComma = pos;
					pos += 1;
					skipWhitespace();
					nextStart = pos;
					while (pos < cookiesString.length && notSpecialChar()) pos += 1;
					if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
						cookiesSeparatorFound = true;
						pos = nextStart;
						cookiesStrings.push(cookiesString.substring(start, lastComma));
						start = pos;
					} else pos = lastComma + 1;
				} else pos += 1;
			}
			if (!cookiesSeparatorFound || pos >= cookiesString.length) cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
		}
		return cookiesStrings;
	}
	module$1.exports = parse$2;
	module$1.exports.parse = parse$2;
	module$1.exports.parseString = parseString;
	module$1.exports.splitCookiesString = splitCookiesString2;
} })());
var HEADERS_INVALID_CHARACTERS = /[^a-z0-9\-#$%&'*+.^_`|~]/i;
function normalizeHeaderName(name) {
	if (HEADERS_INVALID_CHARACTERS.test(name) || name.trim() === "") throw new TypeError("Invalid character in header field name");
	return name.trim().toLowerCase();
}
var charCodesToRemove = [
	String.fromCharCode(10),
	String.fromCharCode(13),
	String.fromCharCode(9),
	String.fromCharCode(32)
];
var HEADER_VALUE_REMOVE_REGEXP = new RegExp(`(^[${charCodesToRemove.join("")}]|$[${charCodesToRemove.join("")}])`, "g");
function normalizeHeaderValue(value) {
	return value.replace(HEADER_VALUE_REMOVE_REGEXP, "");
}
function isValidHeaderName(value) {
	if (typeof value !== "string") return false;
	if (value.length === 0) return false;
	for (let i = 0; i < value.length; i++) {
		const character = value.charCodeAt(i);
		if (character > 127 || !isToken(character)) return false;
	}
	return true;
}
function isToken(value) {
	return ![
		127,
		32,
		"(",
		")",
		"<",
		">",
		"@",
		",",
		";",
		":",
		"\\",
		"\"",
		"/",
		"[",
		"]",
		"?",
		"=",
		"{",
		"}"
	].includes(value);
}
function isValidHeaderValue(value) {
	if (typeof value !== "string") return false;
	if (value.trim() !== value) return false;
	for (let i = 0; i < value.length; i++) {
		const character = value.charCodeAt(i);
		if (character === 0 || character === 10 || character === 13) return false;
	}
	return true;
}
var NORMALIZED_HEADERS = Symbol("normalizedHeaders");
var RAW_HEADER_NAMES = Symbol("rawHeaderNames");
var HEADER_VALUE_DELIMITER = ", ";
var _a, _b, _c;
var Headers = class _Headers {
	constructor(init$1) {
		this[_a] = {};
		this[_b] = /* @__PURE__ */ new Map();
		this[_c] = "Headers";
		if (["Headers", "HeadersPolyfill"].includes(init$1?.constructor.name) || init$1 instanceof _Headers || typeof globalThis.Headers !== "undefined" && init$1 instanceof globalThis.Headers) init$1.forEach((value, name) => {
			this.append(name, value);
		}, this);
		else if (Array.isArray(init$1)) init$1.forEach(([name, value]) => {
			this.append(name, Array.isArray(value) ? value.join(HEADER_VALUE_DELIMITER) : value);
		});
		else if (init$1) Object.getOwnPropertyNames(init$1).forEach((name) => {
			const value = init$1[name];
			this.append(name, Array.isArray(value) ? value.join(HEADER_VALUE_DELIMITER) : value);
		});
	}
	[(_a = NORMALIZED_HEADERS, _b = RAW_HEADER_NAMES, _c = Symbol.toStringTag, Symbol.iterator)]() {
		return this.entries();
	}
	*keys() {
		for (const [name] of this.entries()) yield name;
	}
	*values() {
		for (const [, value] of this.entries()) yield value;
	}
	*entries() {
		let sortedKeys = Object.keys(this[NORMALIZED_HEADERS]).sort((a, b) => a.localeCompare(b));
		for (const name of sortedKeys) if (name === "set-cookie") for (const value of this.getSetCookie()) yield [name, value];
		else yield [name, this.get(name)];
	}
	/**
	* Returns a boolean stating whether a `Headers` object contains a certain header.
	*/
	has(name) {
		if (!isValidHeaderName(name)) throw new TypeError(`Invalid header name "${name}"`);
		return this[NORMALIZED_HEADERS].hasOwnProperty(normalizeHeaderName(name));
	}
	/**
	* Returns a `ByteString` sequence of all the values of a header with a given name.
	*/
	get(name) {
		if (!isValidHeaderName(name)) throw TypeError(`Invalid header name "${name}"`);
		return this[NORMALIZED_HEADERS][normalizeHeaderName(name)] ?? null;
	}
	/**
	* Sets a new value for an existing header inside a `Headers` object, or adds the header if it does not already exist.
	*/
	set(name, value) {
		if (!isValidHeaderName(name) || !isValidHeaderValue(value)) return;
		const normalizedName = normalizeHeaderName(name);
		const normalizedValue = normalizeHeaderValue(value);
		this[NORMALIZED_HEADERS][normalizedName] = normalizeHeaderValue(normalizedValue);
		this[RAW_HEADER_NAMES].set(normalizedName, name);
	}
	/**
	* Appends a new value onto an existing header inside a `Headers` object, or adds the header if it does not already exist.
	*/
	append(name, value) {
		if (!isValidHeaderName(name) || !isValidHeaderValue(value)) return;
		const normalizedName = normalizeHeaderName(name);
		const normalizedValue = normalizeHeaderValue(value);
		let resolvedValue = this.has(normalizedName) ? `${this.get(normalizedName)}, ${normalizedValue}` : normalizedValue;
		this.set(name, resolvedValue);
	}
	/**
	* Deletes a header from the `Headers` object.
	*/
	delete(name) {
		if (!isValidHeaderName(name)) return;
		if (!this.has(name)) return;
		const normalizedName = normalizeHeaderName(name);
		delete this[NORMALIZED_HEADERS][normalizedName];
		this[RAW_HEADER_NAMES].delete(normalizedName);
	}
	/**
	* Traverses the `Headers` object,
	* calling the given callback for each header.
	*/
	forEach(callback, thisArg) {
		for (const [name, value] of this.entries()) callback.call(thisArg, value, name, this);
	}
	/**
	* Returns an array containing the values
	* of all Set-Cookie headers associated
	* with a response
	*/
	getSetCookie() {
		const setCookieHeader = this.get("set-cookie");
		if (setCookieHeader === null) return [];
		if (setCookieHeader === "") return [""];
		return (0, import_set_cookie_parser.splitCookiesString)(setCookieHeader);
	}
};
function headersToList(headers) {
	const headersList = [];
	headers.forEach((value, name) => {
		const resolvedValue = value.includes(",") ? value.split(",").map((value2) => value2.trim()) : value;
		headersList.push([name, resolvedValue]);
	});
	return headersList;
}

//#endregion
//#region ../node_modules/spacetimedb/dist/server/index.mjs
typeof globalThis !== "undefined" && (globalThis.global = globalThis.global || globalThis, globalThis.window = globalThis.window || globalThis);
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError = (msg) => {
	throw TypeError(msg);
};
var __commonJS = (cb, mod) => function __require() {
	return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") {
		for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
			get: () => from[key],
			enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
		});
	}
	return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(__defProp(target, "default", {
	value: mod,
	enumerable: true
}), mod));
var __using = (stack, value, async) => {
	if (value != null) {
		if (typeof value !== "object" && typeof value !== "function") __typeError("Object expected");
		var dispose, inner;
		if (dispose === void 0) dispose = value[__knownSymbol("dispose")];
		if (typeof dispose !== "function") __typeError("Object not disposable");
		if (inner) dispose = function() {
			try {
				inner.call(this);
			} catch (e) {
				return Promise.reject(e);
			}
		};
		stack.push([
			async,
			dispose,
			value
		]);
	}
	return value;
};
var __callDispose = (stack, error, hasError) => {
	var E$1 = typeof SuppressedError === "function" ? SuppressedError : function(e, s, m, _$1) {
		return _$1 = Error(m), _$1.name = "SuppressedError", _$1.error = e, _$1.suppressed = s, _$1;
	};
	var fail = (e) => error = hasError ? new E$1(e, error, "An error was suppressed during disposal") : (hasError = true, e);
	var next = (it) => {
		while (it = stack.pop()) try {
			var result = it[1] && it[1].call(it[2]);
			if (it[0]) return Promise.resolve(result).then(next, (e) => (fail(e), next()));
		} catch (e) {
			fail(e);
		}
		if (hasError) throw error;
	};
	return next();
};
var require_base64_js = __commonJS({ "../../node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js"(exports$1) {
	exports$1.byteLength = byteLength;
	exports$1.toByteArray = toByteArray;
	exports$1.fromByteArray = fromByteArray2;
	var lookup = [];
	var revLookup = [];
	var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
	var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	for (i = 0, len = code.length; i < len; ++i) {
		lookup[i] = code[i];
		revLookup[code.charCodeAt(i)] = i;
	}
	var i;
	var len;
	revLookup["-".charCodeAt(0)] = 62;
	revLookup["_".charCodeAt(0)] = 63;
	function getLens(b64) {
		var len2 = b64.length;
		if (len2 % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
		var validLen = b64.indexOf("=");
		if (validLen === -1) validLen = len2;
		var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
		return [validLen, placeHoldersLen];
	}
	function byteLength(b64) {
		var lens = getLens(b64);
		var validLen = lens[0];
		var placeHoldersLen = lens[1];
		return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
	}
	function _byteLength(b64, validLen, placeHoldersLen) {
		return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
	}
	function toByteArray(b64) {
		var tmp;
		var lens = getLens(b64);
		var validLen = lens[0];
		var placeHoldersLen = lens[1];
		var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
		var curByte = 0;
		var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
		var i2;
		for (i2 = 0; i2 < len2; i2 += 4) {
			tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
			arr[curByte++] = tmp >> 16 & 255;
			arr[curByte++] = tmp >> 8 & 255;
			arr[curByte++] = tmp & 255;
		}
		if (placeHoldersLen === 2) {
			tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
			arr[curByte++] = tmp & 255;
		}
		if (placeHoldersLen === 1) {
			tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
			arr[curByte++] = tmp >> 8 & 255;
			arr[curByte++] = tmp & 255;
		}
		return arr;
	}
	function tripletToBase64(num) {
		return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
	}
	function encodeChunk(uint8, start, end) {
		var tmp;
		var output = [];
		for (var i2 = start; i2 < end; i2 += 3) {
			tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
			output.push(tripletToBase64(tmp));
		}
		return output.join("");
	}
	function fromByteArray2(uint8) {
		var tmp;
		var len2 = uint8.length;
		var extraBytes = len2 % 3;
		var parts = [];
		var maxChunkLength = 16383;
		for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
		if (extraBytes === 1) {
			tmp = uint8[len2 - 1];
			parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
		} else if (extraBytes === 2) {
			tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
			parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
		}
		return parts.join("");
	}
} });
var require_text_min = __commonJS({ "../../node_modules/.pnpm/fast-text-encoding@1.0.6/node_modules/fast-text-encoding/text.min.js"(exports$1) {
	(function(scope) {
		function B(r, e) {
			var f;
			return r instanceof Buffer ? f = r : f = Buffer.from(r.buffer, r.byteOffset, r.byteLength), f.toString(e);
		}
		var w = function(r) {
			return Buffer.from(r);
		};
		function h(r) {
			for (var e = 0, f = Math.min(256 * 256, r.length + 1), n = new Uint16Array(f), i = [], o = 0;;) {
				var t2 = e < r.length;
				if (!t2 || o >= f - 1) {
					var m = n.subarray(0, o);
					if (i.push(String.fromCharCode.apply(null, m)), !t2) return i.join("");
					r = r.subarray(e), e = 0, o = 0;
				}
				var a = r[e++];
				if ((a & 128) === 0) n[o++] = a;
				else if ((a & 224) === 192) {
					var d = r[e++] & 63;
					n[o++] = (a & 31) << 6 | d;
				} else if ((a & 240) === 224) {
					var d = r[e++] & 63, l = r[e++] & 63;
					n[o++] = (a & 31) << 12 | d << 6 | l;
				} else if ((a & 248) === 240) {
					var d = r[e++] & 63, l = r[e++] & 63, R = r[e++] & 63, c = (a & 7) << 18 | d << 12 | l << 6 | R;
					c > 65535 && (c -= 65536, n[o++] = c >>> 10 & 1023 | 55296, c = 56320 | c & 1023), n[o++] = c;
				}
			}
		}
		function F(r) {
			for (var e = 0, f = r.length, n = 0, i = Math.max(32, f + (f >>> 1) + 7), o = new Uint8Array(i >>> 3 << 3); e < f;) {
				var t2 = r.charCodeAt(e++);
				if (t2 >= 55296 && t2 <= 56319) {
					if (e < f) {
						var s = r.charCodeAt(e);
						(s & 64512) === 56320 && (++e, t2 = ((t2 & 1023) << 10) + (s & 1023) + 65536);
					}
					if (t2 >= 55296 && t2 <= 56319) continue;
				}
				if (n + 4 > o.length) {
					i += 8, i *= 1 + e / r.length * 2, i = i >>> 3 << 3;
					var m = new Uint8Array(i);
					m.set(o), o = m;
				}
				if ((t2 & 4294967168) === 0) {
					o[n++] = t2;
					continue;
				} else if ((t2 & 4294965248) === 0) o[n++] = t2 >>> 6 & 31 | 192;
				else if ((t2 & 4294901760) === 0) o[n++] = t2 >>> 12 & 15 | 224, o[n++] = t2 >>> 6 & 63 | 128;
				else if ((t2 & 4292870144) === 0) o[n++] = t2 >>> 18 & 7 | 240, o[n++] = t2 >>> 12 & 63 | 128, o[n++] = t2 >>> 6 & 63 | 128;
				else continue;
				o[n++] = t2 & 63 | 128;
			}
			return o.slice ? o.slice(0, n) : o.subarray(0, n);
		}
		var u = "Failed to ", p = function(r, e, f) {
			if (r) throw new Error("".concat(u).concat(e, ": the '").concat(f, "' option is unsupported."));
		};
		var x = typeof Buffer == "function" && Buffer.from;
		var A = x ? w : F;
		function v() {
			this.encoding = "utf-8";
		}
		v.prototype.encode = function(r, e) {
			return p(e && e.stream, "encode", "stream"), A(r);
		};
		function U(r) {
			var e;
			try {
				var f = new Blob([r], { type: "text/plain;charset=UTF-8" });
				e = URL.createObjectURL(f);
				var n = new XMLHttpRequest();
				return n.open("GET", e, false), n.send(), n.responseText;
			} finally {
				e && URL.revokeObjectURL(e);
			}
		}
		var O = !x && typeof Blob == "function" && typeof URL == "function" && typeof URL.createObjectURL == "function", S = [
			"utf-8",
			"utf8",
			"unicode-1-1-utf-8"
		], T = h;
		x ? T = B : O && (T = function(r) {
			try {
				return U(r);
			} catch (e) {
				return h(r);
			}
		});
		var y = "construct 'TextDecoder'", E$1 = "".concat(u, " ").concat(y, ": the ");
		function g(r, e) {
			p(e && e.fatal, y, "fatal"), r = r || "utf-8";
			var f;
			if (x ? f = Buffer.isEncoding(r) : f = S.indexOf(r.toLowerCase()) !== -1, !f) throw new RangeError("".concat(E$1, " encoding label provided ('").concat(r, "') is invalid."));
			this.encoding = r, this.fatal = false, this.ignoreBOM = false;
		}
		g.prototype.decode = function(r, e) {
			p(e && e.stream, "decode", "stream");
			var f;
			return r instanceof Uint8Array ? f = r : r.buffer instanceof ArrayBuffer ? f = new Uint8Array(r.buffer) : f = new Uint8Array(r), T(f, this.encoding);
		};
		scope.TextEncoder = scope.TextEncoder || v;
		scope.TextDecoder = scope.TextDecoder || g;
	})(typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : exports$1);
} });
var require_codes = __commonJS({ "../../node_modules/.pnpm/statuses@2.0.2/node_modules/statuses/codes.json"(exports$1, module$1) {
	module$1.exports = {
		"100": "Continue",
		"101": "Switching Protocols",
		"102": "Processing",
		"103": "Early Hints",
		"200": "OK",
		"201": "Created",
		"202": "Accepted",
		"203": "Non-Authoritative Information",
		"204": "No Content",
		"205": "Reset Content",
		"206": "Partial Content",
		"207": "Multi-Status",
		"208": "Already Reported",
		"226": "IM Used",
		"300": "Multiple Choices",
		"301": "Moved Permanently",
		"302": "Found",
		"303": "See Other",
		"304": "Not Modified",
		"305": "Use Proxy",
		"307": "Temporary Redirect",
		"308": "Permanent Redirect",
		"400": "Bad Request",
		"401": "Unauthorized",
		"402": "Payment Required",
		"403": "Forbidden",
		"404": "Not Found",
		"405": "Method Not Allowed",
		"406": "Not Acceptable",
		"407": "Proxy Authentication Required",
		"408": "Request Timeout",
		"409": "Conflict",
		"410": "Gone",
		"411": "Length Required",
		"412": "Precondition Failed",
		"413": "Payload Too Large",
		"414": "URI Too Long",
		"415": "Unsupported Media Type",
		"416": "Range Not Satisfiable",
		"417": "Expectation Failed",
		"418": "I'm a Teapot",
		"421": "Misdirected Request",
		"422": "Unprocessable Entity",
		"423": "Locked",
		"424": "Failed Dependency",
		"425": "Too Early",
		"426": "Upgrade Required",
		"428": "Precondition Required",
		"429": "Too Many Requests",
		"431": "Request Header Fields Too Large",
		"451": "Unavailable For Legal Reasons",
		"500": "Internal Server Error",
		"501": "Not Implemented",
		"502": "Bad Gateway",
		"503": "Service Unavailable",
		"504": "Gateway Timeout",
		"505": "HTTP Version Not Supported",
		"506": "Variant Also Negotiates",
		"507": "Insufficient Storage",
		"508": "Loop Detected",
		"509": "Bandwidth Limit Exceeded",
		"510": "Not Extended",
		"511": "Network Authentication Required"
	};
} });
var require_statuses = __commonJS({ "../../node_modules/.pnpm/statuses@2.0.2/node_modules/statuses/index.js"(exports$1, module$1) {
	var codes = require_codes();
	module$1.exports = status2;
	status2.message = codes;
	status2.code = createMessageToStatusCodeMap(codes);
	status2.codes = createStatusCodeList(codes);
	status2.redirect = {
		300: true,
		301: true,
		302: true,
		303: true,
		305: true,
		307: true,
		308: true
	};
	status2.empty = {
		204: true,
		205: true,
		304: true
	};
	status2.retry = {
		502: true,
		503: true,
		504: true
	};
	function createMessageToStatusCodeMap(codes2) {
		var map = {};
		Object.keys(codes2).forEach(function forEachCode(code) {
			var message = codes2[code];
			var status3 = Number(code);
			map[message.toLowerCase()] = status3;
		});
		return map;
	}
	function createStatusCodeList(codes2) {
		return Object.keys(codes2).map(function mapCode(code) {
			return Number(code);
		});
	}
	function getStatusCode(message) {
		var msg = message.toLowerCase();
		if (!Object.prototype.hasOwnProperty.call(status2.code, msg)) throw new Error("invalid status message: \"" + message + "\"");
		return status2.code[msg];
	}
	function getStatusMessage(code) {
		if (!Object.prototype.hasOwnProperty.call(status2.message, code)) throw new Error("invalid status code: " + code);
		return status2.message[code];
	}
	function status2(code) {
		if (typeof code === "number") return getStatusMessage(code);
		if (typeof code !== "string") throw new TypeError("code must be a number or string");
		var n = parseInt(code, 10);
		if (!isNaN(n)) return getStatusMessage(n);
		return getStatusCode(code);
	}
} });
var TimeDuration = class _TimeDuration {
	__time_duration_micros__;
	static MICROS_PER_MILLIS = 1000n;
	/**
	* Get the algebraic type representation of the {@link TimeDuration} type.
	* @returns The algebraic type representation of the type.
	*/
	static getAlgebraicType() {
		return AlgebraicType.Product({ elements: [{
			name: "__time_duration_micros__",
			algebraicType: AlgebraicType.I64
		}] });
	}
	static isTimeDuration(algebraicType) {
		if (algebraicType.tag !== "Product") return false;
		const elements = algebraicType.value.elements;
		if (elements.length !== 1) return false;
		const microsElement = elements[0];
		return microsElement.name === "__time_duration_micros__" && microsElement.algebraicType.tag === "I64";
	}
	get micros() {
		return this.__time_duration_micros__;
	}
	get millis() {
		return Number(this.micros / _TimeDuration.MICROS_PER_MILLIS);
	}
	constructor(micros) {
		this.__time_duration_micros__ = micros;
	}
	static fromMillis(millis) {
		return new _TimeDuration(BigInt(millis) * _TimeDuration.MICROS_PER_MILLIS);
	}
	/** This outputs the same string format that we use in the host and in Rust modules */
	toString() {
		const micros = this.micros;
		const sign = micros < 0 ? "-" : "+";
		const pos = micros < 0 ? -micros : micros;
		const secs = pos / 1000000n;
		const micros_remaining = pos % 1000000n;
		return `${sign}${secs}.${String(micros_remaining).padStart(6, "0")}`;
	}
};
var Timestamp = class _Timestamp {
	__timestamp_micros_since_unix_epoch__;
	static MICROS_PER_MILLIS = 1000n;
	get microsSinceUnixEpoch() {
		return this.__timestamp_micros_since_unix_epoch__;
	}
	constructor(micros) {
		this.__timestamp_micros_since_unix_epoch__ = micros;
	}
	/**
	* Get the algebraic type representation of the {@link Timestamp} type.
	* @returns The algebraic type representation of the type.
	*/
	static getAlgebraicType() {
		return AlgebraicType.Product({ elements: [{
			name: "__timestamp_micros_since_unix_epoch__",
			algebraicType: AlgebraicType.I64
		}] });
	}
	static isTimestamp(algebraicType) {
		if (algebraicType.tag !== "Product") return false;
		const elements = algebraicType.value.elements;
		if (elements.length !== 1) return false;
		const microsElement = elements[0];
		return microsElement.name === "__timestamp_micros_since_unix_epoch__" && microsElement.algebraicType.tag === "I64";
	}
	/**
	* The Unix epoch, the midnight at the beginning of January 1, 1970, UTC.
	*/
	static UNIX_EPOCH = new _Timestamp(0n);
	/**
	* Get a `Timestamp` representing the execution environment's belief of the current moment in time.
	*/
	static now() {
		return _Timestamp.fromDate(/* @__PURE__ */ new Date());
	}
	/** Convert to milliseconds since Unix epoch. */
	toMillis() {
		return this.microsSinceUnixEpoch / 1000n;
	}
	/**
	* Get a `Timestamp` representing the same point in time as `date`.
	*/
	static fromDate(date) {
		const millis = date.getTime();
		return new _Timestamp(BigInt(millis) * _Timestamp.MICROS_PER_MILLIS);
	}
	/**
	* Get a `Date` representing approximately the same point in time as `this`.
	*
	* This method truncates to millisecond precision,
	* and throws `RangeError` if the `Timestamp` is outside the range representable as a `Date`.
	*/
	toDate() {
		const millis = this.__timestamp_micros_since_unix_epoch__ / _Timestamp.MICROS_PER_MILLIS;
		if (millis > BigInt(Number.MAX_SAFE_INTEGER) || millis < BigInt(Number.MIN_SAFE_INTEGER)) throw new RangeError("Timestamp is outside of the representable range of JS's Date");
		return new Date(Number(millis));
	}
	since(other) {
		return new TimeDuration(this.__timestamp_micros_since_unix_epoch__ - other.__timestamp_micros_since_unix_epoch__);
	}
};
var Uuid = class _Uuid {
	__uuid__;
	/**
	* The nil UUID (all zeros).
	*
	* @example
	* ```ts
	* const uuid = Uuid.NIL;
	* console.assert(
	*   uuid.toString() === "00000000-0000-0000-0000-000000000000"
	* );
	* ```
	*/
	static NIL = new _Uuid(0n);
	static MAX_UUID_BIGINT = 340282366920938463463374607431768211455n;
	/**
	* The max UUID (all ones).
	*
	* @example
	* ```ts
	* const uuid = Uuid.MAX;
	* console.assert(
	*   uuid.toString() === "ffffffff-ffff-ffff-ffff-ffffffffffff"
	* );
	* ```
	*/
	static MAX = new _Uuid(_Uuid.MAX_UUID_BIGINT);
	/**
	* Create a UUID from a raw 128-bit value.
	*
	* @param u - Unsigned 128-bit integer
	* @throws {Error} If the value is outside the valid UUID range
	*/
	constructor(u) {
		if (u < 0n || u > _Uuid.MAX_UUID_BIGINT) throw new Error("Invalid UUID: must be between 0 and `MAX_UUID_BIGINT`");
		this.__uuid__ = u;
	}
	/**
	* Create a UUID `v4` from explicit random bytes.
	*
	* This method assumes the bytes are already sufficiently random.
	* It only sets the appropriate bits for the UUID version and variant.
	*
	* @param bytes - Exactly 16 random bytes
	* @returns A UUID `v4`
	* @throws {Error} If `bytes.length !== 16`
	*
	* @example
	* ```ts
	* const randomBytes = new Uint8Array(16);
	* const uuid = Uuid.fromRandomBytesV4(randomBytes);
	*
	* console.assert(
	*   uuid.toString() === "00000000-0000-4000-8000-000000000000"
	* );
	* ```
	*/
	static fromRandomBytesV4(bytes) {
		if (bytes.length !== 16) throw new Error("UUID v4 requires 16 bytes");
		const arr = new Uint8Array(bytes);
		arr[6] = arr[6] & 15 | 64;
		arr[8] = arr[8] & 63 | 128;
		return new _Uuid(_Uuid.bytesToBigInt(arr));
	}
	/**
	* Generate a UUID `v7` using a monotonic counter from `0` to `2^31 - 1`,
	* a timestamp, and 4 random bytes.
	*
	* The counter wraps around on overflow.
	*
	* The UUID `v7` is structured as follows:
	*
	* ```ascii
	* ┌───────────────────────────────────────────────┬───────────────────┐
	* | B0  | B1  | B2  | B3  | B4  | B5              |         B6        |
	* ├───────────────────────────────────────────────┼───────────────────┤
	* |                 unix_ts_ms                    |      version 7    |
	* └───────────────────────────────────────────────┴───────────────────┘
	* ┌──────────────┬─────────┬──────────────────┬───────────────────────┐
	* | B7           | B8      | B9  | B10 | B11  | B12 | B13 | B14 | B15 |
	* ├──────────────┼─────────┼──────────────────┼───────────────────────┤
	* | counter_high | variant |    counter_low   |        random         |
	* └──────────────┴─────────┴──────────────────┴───────────────────────┘
	* ```
	*
	* @param counter - Mutable monotonic counter (31-bit)
	* @param now - Timestamp since the Unix epoch
	* @param randomBytes - Exactly 4 random bytes
	* @returns A UUID `v7`
	*
	* @throws {Error} If the `counter` is negative
	* @throws {Error} If the `timestamp` is before the Unix epoch
	* @throws {Error} If `randomBytes.length !== 4`
	*
	* @example
	* ```ts
	* const now = Timestamp.fromMillis(1_686_000_000_000n);
	* const counter = { value: 1 };
	* const randomBytes = new Uint8Array(4);
	*
	* const uuid = Uuid.fromCounterV7(counter, now, randomBytes);
	*
	* console.assert(
	*   uuid.toString() === "0000647e-5180-7000-8000-000200000000"
	* );
	* ```
	*/
	static fromCounterV7(counter, now, randomBytes) {
		if (randomBytes.length !== 4) throw new Error("`fromCounterV7` requires `randomBytes.length == 4`");
		if (counter.value < 0) throw new Error("`fromCounterV7` uuid `counter` must be non-negative");
		if (now.__timestamp_micros_since_unix_epoch__ < 0) throw new Error("`fromCounterV7` `timestamp` before unix epoch");
		const counterVal = counter.value;
		counter.value = counterVal + 1 & 2147483647;
		const tsMs = now.toMillis() & 281474976710655n;
		const bytes = new Uint8Array(16);
		bytes[0] = Number(tsMs >> 40n & 255n);
		bytes[1] = Number(tsMs >> 32n & 255n);
		bytes[2] = Number(tsMs >> 24n & 255n);
		bytes[3] = Number(tsMs >> 16n & 255n);
		bytes[4] = Number(tsMs >> 8n & 255n);
		bytes[5] = Number(tsMs & 255n);
		bytes[7] = counterVal >>> 23 & 255;
		bytes[9] = counterVal >>> 15 & 255;
		bytes[10] = counterVal >>> 7 & 255;
		bytes[11] = (counterVal & 127) << 1 & 255;
		bytes[12] |= randomBytes[0] & 127;
		bytes[13] = randomBytes[1];
		bytes[14] = randomBytes[2];
		bytes[15] = randomBytes[3];
		bytes[6] = bytes[6] & 15 | 112;
		bytes[8] = bytes[8] & 63 | 128;
		return new _Uuid(_Uuid.bytesToBigInt(bytes));
	}
	/**
	* Parse a UUID from a string representation.
	*
	* @param s - UUID string
	* @returns Parsed UUID
	* @throws {Error} If the string is not a valid UUID
	*
	* @example
	* ```ts
	* const s = "01888d6e-5c00-7000-8000-000000000000";
	* const uuid = Uuid.parse(s);
	*
	* console.assert(uuid.toString() === s);
	* ```
	*/
	static parse(s) {
		const hex = s.replace(/-/g, "");
		if (hex.length !== 32) throw new Error("Invalid hex UUID");
		let v = 0n;
		for (let i = 0; i < 32; i += 2) v = v << 8n | BigInt(parseInt(hex.slice(i, i + 2), 16));
		return new _Uuid(v);
	}
	/** Convert to string (hyphenated form). */
	toString() {
		const hex = [..._Uuid.bigIntToBytes(this.__uuid__)].map((b) => b.toString(16).padStart(2, "0")).join("");
		return hex.slice(0, 8) + "-" + hex.slice(8, 12) + "-" + hex.slice(12, 16) + "-" + hex.slice(16, 20) + "-" + hex.slice(20);
	}
	/** Convert to bigint (u128). */
	asBigInt() {
		return this.__uuid__;
	}
	/** Return a `Uint8Array` of 16 bytes. */
	toBytes() {
		return _Uuid.bigIntToBytes(this.__uuid__);
	}
	static bytesToBigInt(bytes) {
		let result = 0n;
		for (const b of bytes) result = result << 8n | BigInt(b);
		return result;
	}
	static bigIntToBytes(value) {
		const bytes = new Uint8Array(16);
		for (let i = 15; i >= 0; i--) {
			bytes[i] = Number(value & 255n);
			value >>= 8n;
		}
		return bytes;
	}
	/**
	* Returns the version of this UUID.
	*
	* This represents the algorithm used to generate the value.
	*
	* @returns A `UuidVersion`
	* @throws {Error} If the version field is not recognized
	*/
	getVersion() {
		const version = this.toBytes()[6] >> 4 & 15;
		switch (version) {
			case 4: return "V4";
			case 7: return "V7";
			default:
				if (this == _Uuid.NIL) return "Nil";
				if (this == _Uuid.MAX) return "Max";
				throw new Error(`Unsupported UUID version: ${version}`);
		}
	}
	/**
	* Extract the monotonic counter from a UUIDv7.
	*
	* Intended for testing and diagnostics.
	* Behavior is undefined if called on a non-V7 UUID.
	*
	* @returns 31-bit counter value
	*/
	getCounter() {
		const bytes = this.toBytes();
		const high = bytes[7];
		const mid1 = bytes[9];
		const mid2 = bytes[10];
		const low = bytes[11] >>> 1;
		return high << 23 | mid1 << 15 | mid2 << 7 | low | 0;
	}
	compareTo(other) {
		if (this.__uuid__ < other.__uuid__) return -1;
		if (this.__uuid__ > other.__uuid__) return 1;
		return 0;
	}
	static getAlgebraicType() {
		return AlgebraicType.Product({ elements: [{
			name: "__uuid__",
			algebraicType: AlgebraicType.U128
		}] });
	}
};
var BinaryReader = class {
	/**
	* The DataView used to read values from the binary data.
	*
	* Note: The DataView's `byteOffset` is relative to the beginning of the
	* underlying ArrayBuffer, not the start of the provided Uint8Array input.
	* This `BinaryReader`'s `#offset` field is used to track the current read position
	* relative to the start of the provided Uint8Array input.
	*/
	#view;
	/**
	* Represents the offset (in bytes) relative to the start of the DataView
	* and provided Uint8Array input.
	*
	* Note: This is *not* the absolute byte offset within the underlying ArrayBuffer.
	*/
	#offset = 0;
	constructor(input) {
		this.#view = new DataView(input.buffer, input.byteOffset, input.byteLength);
		this.#offset = 0;
	}
	get offset() {
		return this.#offset;
	}
	get remaining() {
		return this.#view.byteLength - this.#offset;
	}
	/** Ensure we have at least `n` bytes left to read */
	#ensure(n) {
		if (this.#offset + n > this.#view.byteLength) throw new RangeError(`Tried to read ${n} byte(s) at relative offset ${this.#offset}, but only ${this.remaining} byte(s) remain`);
	}
	readUInt8Array() {
		const length = this.readU32();
		this.#ensure(length);
		return this.readBytes(length);
	}
	readBool() {
		const value = this.#view.getUint8(this.#offset);
		this.#offset += 1;
		return value !== 0;
	}
	readByte() {
		const value = this.#view.getUint8(this.#offset);
		this.#offset += 1;
		return value;
	}
	readBytes(length) {
		const array = new Uint8Array(this.#view.buffer, this.#view.byteOffset + this.#offset, length);
		this.#offset += length;
		return array;
	}
	readI8() {
		const value = this.#view.getInt8(this.#offset);
		this.#offset += 1;
		return value;
	}
	readU8() {
		return this.readByte();
	}
	readI16() {
		const value = this.#view.getInt16(this.#offset, true);
		this.#offset += 2;
		return value;
	}
	readU16() {
		const value = this.#view.getUint16(this.#offset, true);
		this.#offset += 2;
		return value;
	}
	readI32() {
		const value = this.#view.getInt32(this.#offset, true);
		this.#offset += 4;
		return value;
	}
	readU32() {
		const value = this.#view.getUint32(this.#offset, true);
		this.#offset += 4;
		return value;
	}
	readI64() {
		const value = this.#view.getBigInt64(this.#offset, true);
		this.#offset += 8;
		return value;
	}
	readU64() {
		const value = this.#view.getBigUint64(this.#offset, true);
		this.#offset += 8;
		return value;
	}
	readU128() {
		const lowerPart = this.#view.getBigUint64(this.#offset, true);
		const upperPart = this.#view.getBigUint64(this.#offset + 8, true);
		this.#offset += 16;
		return (upperPart << BigInt(64)) + lowerPart;
	}
	readI128() {
		const lowerPart = this.#view.getBigUint64(this.#offset, true);
		const upperPart = this.#view.getBigInt64(this.#offset + 8, true);
		this.#offset += 16;
		return (upperPart << BigInt(64)) + lowerPart;
	}
	readU256() {
		const p0 = this.#view.getBigUint64(this.#offset, true);
		const p1 = this.#view.getBigUint64(this.#offset + 8, true);
		const p2 = this.#view.getBigUint64(this.#offset + 16, true);
		const p3 = this.#view.getBigUint64(this.#offset + 24, true);
		this.#offset += 32;
		return (p3 << BigInt(192)) + (p2 << BigInt(128)) + (p1 << BigInt(64)) + p0;
	}
	readI256() {
		const p0 = this.#view.getBigUint64(this.#offset, true);
		const p1 = this.#view.getBigUint64(this.#offset + 8, true);
		const p2 = this.#view.getBigUint64(this.#offset + 16, true);
		const p3 = this.#view.getBigInt64(this.#offset + 24, true);
		this.#offset += 32;
		return (p3 << BigInt(192)) + (p2 << BigInt(128)) + (p1 << BigInt(64)) + p0;
	}
	readF32() {
		const value = this.#view.getFloat32(this.#offset, true);
		this.#offset += 4;
		return value;
	}
	readF64() {
		const value = this.#view.getFloat64(this.#offset, true);
		this.#offset += 8;
		return value;
	}
	readString() {
		const uint8Array = this.readUInt8Array();
		return new TextDecoder("utf-8").decode(uint8Array);
	}
};
var import_base64_js = __toESM(require_base64_js());
var BinaryWriter = class {
	#buffer;
	#view;
	#offset = 0;
	constructor(size) {
		this.#buffer = new Uint8Array(size);
		this.#view = new DataView(this.#buffer.buffer);
	}
	#expandBuffer(additionalCapacity) {
		const minCapacity = this.#offset + additionalCapacity + 1;
		if (minCapacity <= this.#buffer.length) return;
		let newCapacity = this.#buffer.length * 2;
		if (newCapacity < minCapacity) newCapacity = minCapacity;
		const newBuffer = new Uint8Array(newCapacity);
		newBuffer.set(this.#buffer);
		this.#buffer = newBuffer;
		this.#view = new DataView(this.#buffer.buffer);
	}
	toBase64() {
		return (0, import_base64_js.fromByteArray)(this.#buffer.subarray(0, this.#offset));
	}
	getBuffer() {
		return this.#buffer.slice(0, this.#offset);
	}
	get offset() {
		return this.#offset;
	}
	writeUInt8Array(value) {
		const length = value.length;
		this.#expandBuffer(4 + length);
		this.writeU32(length);
		this.#buffer.set(value, this.#offset);
		this.#offset += value.length;
	}
	writeBool(value) {
		this.#expandBuffer(1);
		this.#view.setUint8(this.#offset, value ? 1 : 0);
		this.#offset += 1;
	}
	writeByte(value) {
		this.#expandBuffer(1);
		this.#view.setUint8(this.#offset, value);
		this.#offset += 1;
	}
	writeI8(value) {
		this.#expandBuffer(1);
		this.#view.setInt8(this.#offset, value);
		this.#offset += 1;
	}
	writeU8(value) {
		this.#expandBuffer(1);
		this.#view.setUint8(this.#offset, value);
		this.#offset += 1;
	}
	writeI16(value) {
		this.#expandBuffer(2);
		this.#view.setInt16(this.#offset, value, true);
		this.#offset += 2;
	}
	writeU16(value) {
		this.#expandBuffer(2);
		this.#view.setUint16(this.#offset, value, true);
		this.#offset += 2;
	}
	writeI32(value) {
		this.#expandBuffer(4);
		this.#view.setInt32(this.#offset, value, true);
		this.#offset += 4;
	}
	writeU32(value) {
		this.#expandBuffer(4);
		this.#view.setUint32(this.#offset, value, true);
		this.#offset += 4;
	}
	writeI64(value) {
		this.#expandBuffer(8);
		this.#view.setBigInt64(this.#offset, value, true);
		this.#offset += 8;
	}
	writeU64(value) {
		this.#expandBuffer(8);
		this.#view.setBigUint64(this.#offset, value, true);
		this.#offset += 8;
	}
	writeU128(value) {
		this.#expandBuffer(16);
		const lowerPart = value & BigInt("0xFFFFFFFFFFFFFFFF");
		const upperPart = value >> BigInt(64);
		this.#view.setBigUint64(this.#offset, lowerPart, true);
		this.#view.setBigUint64(this.#offset + 8, upperPart, true);
		this.#offset += 16;
	}
	writeI128(value) {
		this.#expandBuffer(16);
		const lowerPart = value & BigInt("0xFFFFFFFFFFFFFFFF");
		const upperPart = value >> BigInt(64);
		this.#view.setBigInt64(this.#offset, lowerPart, true);
		this.#view.setBigInt64(this.#offset + 8, upperPart, true);
		this.#offset += 16;
	}
	writeU256(value) {
		this.#expandBuffer(32);
		const low_64_mask = BigInt("0xFFFFFFFFFFFFFFFF");
		const p0 = value & low_64_mask;
		const p1 = value >> BigInt(64) & low_64_mask;
		const p2 = value >> BigInt(128) & low_64_mask;
		const p3 = value >> BigInt(192);
		this.#view.setBigUint64(this.#offset + 0, p0, true);
		this.#view.setBigUint64(this.#offset + 8, p1, true);
		this.#view.setBigUint64(this.#offset + 16, p2, true);
		this.#view.setBigUint64(this.#offset + 24, p3, true);
		this.#offset += 32;
	}
	writeI256(value) {
		this.#expandBuffer(32);
		const low_64_mask = BigInt("0xFFFFFFFFFFFFFFFF");
		const p0 = value & low_64_mask;
		const p1 = value >> BigInt(64) & low_64_mask;
		const p2 = value >> BigInt(128) & low_64_mask;
		const p3 = value >> BigInt(192);
		this.#view.setBigUint64(this.#offset + 0, p0, true);
		this.#view.setBigUint64(this.#offset + 8, p1, true);
		this.#view.setBigUint64(this.#offset + 16, p2, true);
		this.#view.setBigInt64(this.#offset + 24, p3, true);
		this.#offset += 32;
	}
	writeF32(value) {
		this.#expandBuffer(4);
		this.#view.setFloat32(this.#offset, value, true);
		this.#offset += 4;
	}
	writeF64(value) {
		this.#expandBuffer(8);
		this.#view.setFloat64(this.#offset, value, true);
		this.#offset += 8;
	}
	writeString(value) {
		const encodedString = new TextEncoder().encode(value);
		this.writeU32(encodedString.length);
		this.#expandBuffer(encodedString.length);
		this.#buffer.set(encodedString, this.#offset);
		this.#offset += encodedString.length;
	}
};
function toPascalCase(s) {
	const str$1 = s.replace(/([-_][a-z])/gi, ($1) => {
		return $1.toUpperCase().replace("-", "").replace("_", "");
	});
	return str$1.charAt(0).toUpperCase() + str$1.slice(1);
}
function uint8ArrayToHexString(array) {
	return Array.prototype.map.call(array.reverse(), (x) => ("00" + x.toString(16)).slice(-2)).join("");
}
function uint8ArrayToU128(array) {
	if (array.length != 16) throw new Error(`Uint8Array is not 16 bytes long: ${array}`);
	return new BinaryReader(array).readU128();
}
function uint8ArrayToU256(array) {
	if (array.length != 32) throw new Error(`Uint8Array is not 32 bytes long: [${array}]`);
	return new BinaryReader(array).readU256();
}
function hexStringToUint8Array(str$1) {
	if (str$1.startsWith("0x")) str$1 = str$1.slice(2);
	const matches = str$1.match(/.{1,2}/g) || [];
	return Uint8Array.from(matches.map((byte) => parseInt(byte, 16))).reverse();
}
function hexStringToU128(str$1) {
	return uint8ArrayToU128(hexStringToUint8Array(str$1));
}
function hexStringToU256(str$1) {
	return uint8ArrayToU256(hexStringToUint8Array(str$1));
}
function u128ToUint8Array(data) {
	const writer = new BinaryWriter(16);
	writer.writeU128(data);
	return writer.getBuffer();
}
function u128ToHexString(data) {
	return uint8ArrayToHexString(u128ToUint8Array(data));
}
function u256ToUint8Array(data) {
	const writer = new BinaryWriter(32);
	writer.writeU256(data);
	return writer.getBuffer();
}
function u256ToHexString(data) {
	return uint8ArrayToHexString(u256ToUint8Array(data));
}
function toCamelCase(str$1) {
	return str$1.replace(/[-_]+/g, "_").replace(/_([a-zA-Z0-9])/g, (_$1, c) => c.toUpperCase());
}
function bsatnBaseSize(typespace, ty) {
	const assumedArrayLength = 4;
	while (ty.tag === "Ref") ty = typespace.types[ty.value];
	if (ty.tag === "Product") {
		let sum = 0;
		for (const { algebraicType: elem } of ty.value.elements) sum += bsatnBaseSize(typespace, elem);
		return sum;
	} else if (ty.tag === "Sum") {
		let min = Infinity;
		for (const { algebraicType: vari } of ty.value.variants) {
			const vSize = bsatnBaseSize(typespace, vari);
			if (vSize < min) min = vSize;
		}
		if (min === Infinity) min = 0;
		return 4 + min;
	} else if (ty.tag == "Array") return 4 + assumedArrayLength * bsatnBaseSize(typespace, ty.value);
	return {
		String: 4 + assumedArrayLength,
		Sum: 1,
		Bool: 1,
		I8: 1,
		U8: 1,
		I16: 2,
		U16: 2,
		I32: 4,
		U32: 4,
		F32: 4,
		I64: 8,
		U64: 8,
		F64: 8,
		I128: 16,
		U128: 16,
		I256: 32,
		U256: 32
	}[ty.tag];
}
var ConnectionId = class _ConnectionId {
	__connection_id__;
	/**
	* Creates a new `ConnectionId`.
	*/
	constructor(data) {
		this.__connection_id__ = data;
	}
	/**
	* Get the algebraic type representation of the {@link ConnectionId} type.
	* @returns The algebraic type representation of the type.
	*/
	static getAlgebraicType() {
		return AlgebraicType.Product({ elements: [{
			name: "__connection_id__",
			algebraicType: AlgebraicType.U128
		}] });
	}
	isZero() {
		return this.__connection_id__ === BigInt(0);
	}
	static nullIfZero(addr) {
		if (addr.isZero()) return null;
		else return addr;
	}
	static random() {
		function randomU8() {
			return Math.floor(Math.random() * 255);
		}
		let result = BigInt(0);
		for (let i = 0; i < 16; i++) result = result << BigInt(8) | BigInt(randomU8());
		return new _ConnectionId(result);
	}
	/**
	* Compare two connection IDs for equality.
	*/
	isEqual(other) {
		return this.__connection_id__ == other.__connection_id__;
	}
	/**
	* Check if two connection IDs are equal.
	*/
	equals(other) {
		return this.isEqual(other);
	}
	/**
	* Print the connection ID as a hexadecimal string.
	*/
	toHexString() {
		return u128ToHexString(this.__connection_id__);
	}
	/**
	* Convert the connection ID to a Uint8Array.
	*/
	toUint8Array() {
		return u128ToUint8Array(this.__connection_id__);
	}
	/**
	* Parse a connection ID from a hexadecimal string.
	*/
	static fromString(str$1) {
		return new _ConnectionId(hexStringToU128(str$1));
	}
	static fromStringOrNull(str$1) {
		const addr = _ConnectionId.fromString(str$1);
		if (addr.isZero()) return null;
		else return addr;
	}
};
var Identity = class _Identity {
	__identity__;
	/**
	* Creates a new `Identity`.
	*
	* `data` can be a hexadecimal string or a `bigint`.
	*/
	constructor(data) {
		this.__identity__ = typeof data === "string" ? hexStringToU256(data) : data;
	}
	/**
	* Get the algebraic type representation of the {@link Identity} type.
	* @returns The algebraic type representation of the type.
	*/
	static getAlgebraicType() {
		return AlgebraicType.Product({ elements: [{
			name: "__identity__",
			algebraicType: AlgebraicType.U256
		}] });
	}
	/**
	* Check if two identities are equal.
	*/
	isEqual(other) {
		return this.toHexString() === other.toHexString();
	}
	/**
	* Check if two identities are equal.
	*/
	equals(other) {
		return this.isEqual(other);
	}
	/**
	* Print the identity as a hexadecimal string.
	*/
	toHexString() {
		return u256ToHexString(this.__identity__);
	}
	/**
	* Convert the address to a Uint8Array.
	*/
	toUint8Array() {
		return u256ToUint8Array(this.__identity__);
	}
	/**
	* Parse an Identity from a hexadecimal string.
	*/
	static fromString(str$1) {
		return new _Identity(str$1);
	}
	/**
	* Zero identity (0x0000000000000000000000000000000000000000000000000000000000000000)
	*/
	static zero() {
		return new _Identity(0n);
	}
	toString() {
		return this.toHexString();
	}
};
var AlgebraicType = {
	Ref: (value) => ({
		tag: "Ref",
		value
	}),
	Sum: (value) => ({
		tag: "Sum",
		value
	}),
	Product: (value) => ({
		tag: "Product",
		value
	}),
	Array: (value) => ({
		tag: "Array",
		value
	}),
	String: { tag: "String" },
	Bool: { tag: "Bool" },
	I8: { tag: "I8" },
	U8: { tag: "U8" },
	I16: { tag: "I16" },
	U16: { tag: "U16" },
	I32: { tag: "I32" },
	U32: { tag: "U32" },
	I64: { tag: "I64" },
	U64: { tag: "U64" },
	I128: { tag: "I128" },
	U128: { tag: "U128" },
	I256: { tag: "I256" },
	U256: { tag: "U256" },
	F32: { tag: "F32" },
	F64: { tag: "F64" },
	serializeValue(writer, ty, value, typespace) {
		if (ty.tag === "Ref") {
			if (!typespace) throw new Error("cannot serialize refs without a typespace");
			while (ty.tag === "Ref") ty = typespace.types[ty.value];
		}
		switch (ty.tag) {
			case "Product":
				ProductType.serializeValue(writer, ty.value, value, typespace);
				break;
			case "Sum":
				SumType.serializeValue(writer, ty.value, value, typespace);
				break;
			case "Array":
				if (ty.value.tag === "U8") writer.writeUInt8Array(value);
				else {
					const elemType = ty.value;
					writer.writeU32(value.length);
					for (const elem of value) AlgebraicType.serializeValue(writer, elemType, elem, typespace);
				}
				break;
			case "Bool":
				writer.writeBool(value);
				break;
			case "I8":
				writer.writeI8(value);
				break;
			case "U8":
				writer.writeU8(value);
				break;
			case "I16":
				writer.writeI16(value);
				break;
			case "U16":
				writer.writeU16(value);
				break;
			case "I32":
				writer.writeI32(value);
				break;
			case "U32":
				writer.writeU32(value);
				break;
			case "I64":
				writer.writeI64(value);
				break;
			case "U64":
				writer.writeU64(value);
				break;
			case "I128":
				writer.writeI128(value);
				break;
			case "U128":
				writer.writeU128(value);
				break;
			case "I256":
				writer.writeI256(value);
				break;
			case "U256":
				writer.writeU256(value);
				break;
			case "F32":
				writer.writeF32(value);
				break;
			case "F64":
				writer.writeF64(value);
				break;
			case "String":
				writer.writeString(value);
				break;
		}
	},
	deserializeValue: function(reader, ty, typespace) {
		if (ty.tag === "Ref") {
			if (!typespace) throw new Error("cannot deserialize refs without a typespace");
			while (ty.tag === "Ref") ty = typespace.types[ty.value];
		}
		switch (ty.tag) {
			case "Product": return ProductType.deserializeValue(reader, ty.value, typespace);
			case "Sum": return SumType.deserializeValue(reader, ty.value, typespace);
			case "Array": if (ty.value.tag === "U8") return reader.readUInt8Array();
			else {
				const elemType = ty.value;
				const length = reader.readU32();
				const result = [];
				for (let i = 0; i < length; i++) result.push(AlgebraicType.deserializeValue(reader, elemType, typespace));
				return result;
			}
			case "Bool": return reader.readBool();
			case "I8": return reader.readI8();
			case "U8": return reader.readU8();
			case "I16": return reader.readI16();
			case "U16": return reader.readU16();
			case "I32": return reader.readI32();
			case "U32": return reader.readU32();
			case "I64": return reader.readI64();
			case "U64": return reader.readU64();
			case "I128": return reader.readI128();
			case "U128": return reader.readU128();
			case "I256": return reader.readI256();
			case "U256": return reader.readU256();
			case "F32": return reader.readF32();
			case "F64": return reader.readF64();
			case "String": return reader.readString();
		}
	},
	intoMapKey: function(ty, value) {
		switch (ty.tag) {
			case "U8":
			case "U16":
			case "U32":
			case "U64":
			case "U128":
			case "U256":
			case "I8":
			case "I16":
			case "I32":
			case "I64":
			case "I128":
			case "I256":
			case "F32":
			case "F64":
			case "String":
			case "Bool": return value;
			case "Product": return ProductType.intoMapKey(ty.value, value);
			default: {
				const writer = new BinaryWriter(10);
				AlgebraicType.serializeValue(writer, ty, value);
				return writer.toBase64();
			}
		}
	}
};
var ProductType = {
	serializeValue(writer, ty, value, typespace) {
		for (const element of ty.elements) AlgebraicType.serializeValue(writer, element.algebraicType, value[element.name], typespace);
	},
	deserializeValue(reader, ty, typespace) {
		const result = {};
		if (ty.elements.length === 1) {
			if (ty.elements[0].name === "__time_duration_micros__") return new TimeDuration(reader.readI64());
			if (ty.elements[0].name === "__timestamp_micros_since_unix_epoch__") return new Timestamp(reader.readI64());
			if (ty.elements[0].name === "__identity__") return new Identity(reader.readU256());
			if (ty.elements[0].name === "__connection_id__") return new ConnectionId(reader.readU128());
			if (ty.elements[0].name === "__uuid__") return new Uuid(reader.readU128());
		}
		for (const element of ty.elements) result[element.name] = AlgebraicType.deserializeValue(reader, element.algebraicType, typespace);
		return result;
	},
	intoMapKey(ty, value) {
		if (ty.elements.length === 1) {
			if (ty.elements[0].name === "__time_duration_micros__") return value.__time_duration_micros__;
			if (ty.elements[0].name === "__timestamp_micros_since_unix_epoch__") return value.__timestamp_micros_since_unix_epoch__;
			if (ty.elements[0].name === "__identity__") return value.__identity__;
			if (ty.elements[0].name === "__connection_id__") return value.__connection_id__;
			if (ty.elements[0].name === "__uuid__") return value.__uuid__;
		}
		const writer = new BinaryWriter(10);
		AlgebraicType.serializeValue(writer, AlgebraicType.Product(ty), value);
		return writer.toBase64();
	}
};
var SumType = {
	serializeValue: function(writer, ty, value, typespace) {
		if (ty.variants.length == 2 && ty.variants[0].name === "some" && ty.variants[1].name === "none") if (value !== null && value !== void 0) {
			writer.writeByte(0);
			AlgebraicType.serializeValue(writer, ty.variants[0].algebraicType, value, typespace);
		} else writer.writeByte(1);
		else if (ty.variants.length == 2 && ty.variants[0].name === "ok" && ty.variants[1].name === "err") {
			let variantName;
			let innerValue;
			let index;
			if ("ok" in value) {
				variantName = "ok";
				innerValue = value.ok;
				index = 0;
			} else {
				variantName = "err";
				innerValue = value.err;
				index = 1;
			}
			if (index < 0) throw `Result serialization error: variant '${variantName}' not found in ${JSON.stringify(ty)}`;
			writer.writeU8(index);
			AlgebraicType.serializeValue(writer, ty.variants[index].algebraicType, innerValue, typespace);
		} else {
			const variant = value["tag"];
			const index = ty.variants.findIndex((v) => v.name === variant);
			if (index < 0) throw `Can't serialize a sum type, couldn't find ${value.tag} tag ${JSON.stringify(value)} in variants ${JSON.stringify(ty)}`;
			writer.writeU8(index);
			AlgebraicType.serializeValue(writer, ty.variants[index].algebraicType, value["value"], typespace);
		}
	},
	deserializeValue: function(reader, ty, typespace) {
		const tag = reader.readU8();
		if (ty.variants.length == 2 && ty.variants[0].name === "some" && ty.variants[1].name === "none") if (tag === 0) return AlgebraicType.deserializeValue(reader, ty.variants[0].algebraicType, typespace);
		else if (tag === 1) return;
		else throw `Can't deserialize an option type, couldn't find ${tag} tag`;
		else if (ty.variants.length == 2 && ty.variants[0].name === "ok" && ty.variants[1].name === "err") if (tag === 0) return { ok: AlgebraicType.deserializeValue(reader, ty.variants[0].algebraicType, typespace) };
		else if (tag === 1) return { err: AlgebraicType.deserializeValue(reader, ty.variants[1].algebraicType, typespace) };
		else throw `Can't deserialize a result type, couldn't find ${tag} tag`;
		else {
			const variant = ty.variants[tag];
			const value = AlgebraicType.deserializeValue(reader, variant.algebraicType, typespace);
			return {
				tag: variant.name,
				value
			};
		}
	}
};
var Option = { getAlgebraicType(innerType) {
	return AlgebraicType.Sum({ variants: [{
		name: "some",
		algebraicType: innerType
	}, {
		name: "none",
		algebraicType: AlgebraicType.Product({ elements: [] })
	}] });
} };
var Result = { getAlgebraicType(okType, errType) {
	return AlgebraicType.Sum({ variants: [{
		name: "ok",
		algebraicType: okType
	}, {
		name: "err",
		algebraicType: errType
	}] });
} };
var ScheduleAt = {
	interval(value) {
		return Interval(value);
	},
	time(value) {
		return Time(value);
	},
	getAlgebraicType() {
		return AlgebraicType.Sum({ variants: [{
			name: "Interval",
			algebraicType: TimeDuration.getAlgebraicType()
		}, {
			name: "Time",
			algebraicType: Timestamp.getAlgebraicType()
		}] });
	},
	isScheduleAt(algebraicType) {
		if (algebraicType.tag !== "Sum") return false;
		const variants = algebraicType.value.variants;
		if (variants.length !== 2) return false;
		const intervalVariant = variants.find((v) => v.name === "Interval");
		const timeVariant = variants.find((v) => v.name === "Time");
		if (!intervalVariant || !timeVariant) return false;
		return TimeDuration.isTimeDuration(intervalVariant.algebraicType) && Timestamp.isTimestamp(timeVariant.algebraicType);
	}
};
var Interval = (micros) => ({
	tag: "Interval",
	value: new TimeDuration(micros)
});
var Time = (microsSinceUnixEpoch) => ({
	tag: "Time",
	value: new Timestamp(microsSinceUnixEpoch)
});
var schedule_at_default = ScheduleAt;
function set(x, t2) {
	return {
		...x,
		...t2
	};
}
var TypeBuilder = class {
	/**
	* The TypeScript phantom type. This is not stored at runtime,
	* but is visible to the compiler
	*/
	type;
	/**
	* The SpacetimeDB algebraic type (run‑time value). In addition to storing
	* the runtime representation of the `AlgebraicType`, it also captures
	* the TypeScript type information of the `AlgebraicType`. That is to say
	* the value is not merely an `AlgebraicType`, but is constructed to be
	* the corresponding concrete `AlgebraicType` for the TypeScript type `Type`.
	*
	* e.g. `string` corresponds to `AlgebraicType.String`
	*/
	algebraicType;
	constructor(algebraicType) {
		this.algebraicType = algebraicType;
	}
	optional() {
		return new OptionBuilder(this);
	}
	serialize(writer, value) {
		AlgebraicType.serializeValue(writer, this.algebraicType, value);
	}
	deserialize(reader) {
		return AlgebraicType.deserializeValue(reader, this.algebraicType);
	}
};
var U8Builder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.U8);
	}
	index(algorithm = "btree") {
		return new U8ColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new U8ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new U8ColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new U8ColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new U8ColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new U8ColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var U16Builder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.U16);
	}
	index(algorithm = "btree") {
		return new U16ColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new U16ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new U16ColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new U16ColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new U16ColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new U16ColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var U32Builder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.U32);
	}
	index(algorithm = "btree") {
		return new U32ColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new U32ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new U32ColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new U32ColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new U32ColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new U32ColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var U64Builder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.U64);
	}
	index(algorithm = "btree") {
		return new U64ColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new U64ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new U64ColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new U64ColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new U64ColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new U64ColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var U128Builder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.U128);
	}
	index(algorithm = "btree") {
		return new U128ColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new U128ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new U128ColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new U128ColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new U128ColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new U128ColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var U256Builder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.U256);
	}
	index(algorithm = "btree") {
		return new U256ColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new U256ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new U256ColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new U256ColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new U256ColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new U256ColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var I8Builder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.I8);
	}
	index(algorithm = "btree") {
		return new I8ColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new I8ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new I8ColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new I8ColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new I8ColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new I8ColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var I16Builder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.I16);
	}
	index(algorithm = "btree") {
		return new I16ColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new I16ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new I16ColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new I16ColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new I16ColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new I16ColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var I32Builder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.I32);
	}
	index(algorithm = "btree") {
		return new I32ColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new I32ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new I32ColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new I32ColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new I32ColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new I32ColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var I64Builder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.I64);
	}
	index(algorithm = "btree") {
		return new I64ColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new I64ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new I64ColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new I64ColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new I64ColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new I64ColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var I128Builder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.I128);
	}
	index(algorithm = "btree") {
		return new I128ColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new I128ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new I128ColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new I128ColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new I128ColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new I128ColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var I256Builder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.I256);
	}
	index(algorithm = "btree") {
		return new I256ColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new I256ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new I256ColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new I256ColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new I256ColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new I256ColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var F32Builder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.F32);
	}
	default(value) {
		return new F32ColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new F32ColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var F64Builder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.F64);
	}
	default(value) {
		return new F64ColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new F64ColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var BoolBuilder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.Bool);
	}
	index(algorithm = "btree") {
		return new BoolColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new BoolColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new BoolColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	default(value) {
		return new BoolColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new BoolColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var StringBuilder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.String);
	}
	index(algorithm = "btree") {
		return new StringColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new StringColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new StringColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	default(value) {
		return new StringColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new StringColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var ArrayBuilder = class extends TypeBuilder {
	element;
	constructor(element) {
		super(AlgebraicType.Array(element.algebraicType));
		this.element = element;
	}
	default(value) {
		return new ArrayColumnBuilder(this.element, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new ArrayColumnBuilder(this.element, set(defaultMetadata, { name }));
	}
};
var ByteArrayBuilder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.Array(AlgebraicType.U8));
	}
	default(value) {
		return new ByteArrayColumnBuilder(set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new ByteArrayColumnBuilder(set(defaultMetadata, { name }));
	}
};
var OptionBuilder = class extends TypeBuilder {
	value;
	constructor(value) {
		super(Option.getAlgebraicType(value.algebraicType));
		this.value = value;
	}
	default(value) {
		return new OptionColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new OptionColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var ProductBuilder = class extends TypeBuilder {
	typeName;
	elements;
	constructor(elements, name) {
		function elementsArrayFromElementsObj(obj) {
			return Object.keys(obj).map((key) => ({
				name: key,
				get algebraicType() {
					return obj[key].algebraicType;
				}
			}));
		}
		super(AlgebraicType.Product({ elements: elementsArrayFromElementsObj(elements) }));
		this.typeName = name;
		this.elements = elements;
	}
	default(value) {
		return new ProductColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new ProductColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var ResultBuilder = class extends TypeBuilder {
	ok;
	err;
	constructor(ok, err) {
		super(Result.getAlgebraicType(ok.algebraicType, err.algebraicType));
		this.ok = ok;
		this.err = err;
	}
	default(value) {
		return new ResultColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
};
var UnitBuilder = class extends TypeBuilder {
	constructor() {
		super({
			tag: "Product",
			value: { elements: [] }
		});
	}
};
var RowBuilder = class extends TypeBuilder {
	row;
	typeName;
	constructor(row, name) {
		const mappedRow = Object.fromEntries(Object.entries(row).map(([colName, builder]) => [colName, builder instanceof ColumnBuilder ? builder : new ColumnBuilder(builder, {})]));
		const elements = Object.keys(mappedRow).map((name2) => ({
			name: name2,
			get algebraicType() {
				return mappedRow[name2].typeBuilder.algebraicType;
			}
		}));
		super(AlgebraicType.Product({ elements }));
		this.row = mappedRow;
		this.typeName = name;
	}
};
var SumBuilderImpl = class extends TypeBuilder {
	variants;
	typeName;
	constructor(variants, name) {
		function variantsArrayFromVariantsObj(variants2) {
			return Object.keys(variants2).map((key) => ({
				name: key,
				get algebraicType() {
					return variants2[key].algebraicType;
				}
			}));
		}
		super(AlgebraicType.Sum({ variants: variantsArrayFromVariantsObj(variants) }));
		this.variants = variants;
		this.typeName = name;
		for (const key of Object.keys(variants)) {
			const desc = Object.getOwnPropertyDescriptor(variants, key);
			const isAccessor = !!desc && (typeof desc.get === "function" || typeof desc.set === "function");
			let isUnit2 = false;
			if (!isAccessor) isUnit2 = variants[key] instanceof UnitBuilder;
			if (isUnit2) {
				const constant = this.create(key);
				Object.defineProperty(this, key, {
					value: constant,
					writable: false,
					enumerable: true,
					configurable: false
				});
			} else {
				const fn = ((value) => this.create(key, value));
				Object.defineProperty(this, key, {
					value: fn,
					writable: false,
					enumerable: true,
					configurable: false
				});
			}
		}
	}
	create(tag, value) {
		return value === void 0 ? { tag } : {
			tag,
			value
		};
	}
	default(value) {
		return new SumColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new SumColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var SumBuilder = SumBuilderImpl;
var SimpleSumBuilderImpl = class extends SumBuilderImpl {
	index(algorithm = "btree") {
		return new SimpleSumColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	primaryKey() {
		return new SimpleSumColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
};
var ScheduleAtBuilder = class extends TypeBuilder {
	constructor() {
		super(schedule_at_default.getAlgebraicType());
	}
	default(value) {
		return new ScheduleAtColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new ScheduleAtColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var IdentityBuilder = class extends TypeBuilder {
	constructor() {
		super(Identity.getAlgebraicType());
	}
	index(algorithm = "btree") {
		return new IdentityColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new IdentityColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new IdentityColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new IdentityColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new IdentityColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new IdentityColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var ConnectionIdBuilder = class extends TypeBuilder {
	constructor() {
		super(ConnectionId.getAlgebraicType());
	}
	index(algorithm = "btree") {
		return new ConnectionIdColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new ConnectionIdColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new ConnectionIdColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new ConnectionIdColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new ConnectionIdColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new ConnectionIdColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var TimestampBuilder = class extends TypeBuilder {
	constructor() {
		super(Timestamp.getAlgebraicType());
	}
	index(algorithm = "btree") {
		return new TimestampColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new TimestampColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new TimestampColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new TimestampColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new TimestampColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new TimestampColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var TimeDurationBuilder = class extends TypeBuilder {
	constructor() {
		super(TimeDuration.getAlgebraicType());
	}
	index(algorithm = "btree") {
		return new TimeDurationColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new TimeDurationColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new TimeDurationColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new TimeDurationColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new TimeDurationColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new TimeDurationColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var UuidBuilder = class extends TypeBuilder {
	constructor() {
		super(Uuid.getAlgebraicType());
	}
	index(algorithm = "btree") {
		return new UuidColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new UuidColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new UuidColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new UuidColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new UuidColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
};
var defaultMetadata = {};
var ColumnBuilder = class {
	typeBuilder;
	columnMetadata;
	constructor(typeBuilder, metadata) {
		this.typeBuilder = typeBuilder;
		this.columnMetadata = metadata;
	}
	serialize(writer, value) {
		AlgebraicType.serializeValue(writer, this.typeBuilder.algebraicType, value);
	}
	deserialize(reader) {
		return AlgebraicType.deserializeValue(reader, this.typeBuilder.algebraicType);
	}
};
var U8ColumnBuilder = class _U8ColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _U8ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _U8ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _U8ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new _U8ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new _U8ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _U8ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var U16ColumnBuilder = class _U16ColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _U16ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _U16ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _U16ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new _U16ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new _U16ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _U16ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var U32ColumnBuilder = class _U32ColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _U32ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _U32ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _U32ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new _U32ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new _U32ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _U32ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var U64ColumnBuilder = class _U64ColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _U64ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _U64ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _U64ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new _U64ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new _U64ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _U64ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var U128ColumnBuilder = class _U128ColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _U128ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _U128ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _U128ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new _U128ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new _U128ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _U128ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var U256ColumnBuilder = class _U256ColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _U256ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _U256ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _U256ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new _U256ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new _U256ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _U256ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var I8ColumnBuilder = class _I8ColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _I8ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _I8ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _I8ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new _I8ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new _I8ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _I8ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var I16ColumnBuilder = class _I16ColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _I16ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _I16ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _I16ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new _I16ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new _I16ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _I16ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var I32ColumnBuilder = class _I32ColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _I32ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _I32ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _I32ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new _I32ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new _I32ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _I32ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var I64ColumnBuilder = class _I64ColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _I64ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _I64ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _I64ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new _I64ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new _I64ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _I64ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var I128ColumnBuilder = class _I128ColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _I128ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _I128ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _I128ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new _I128ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new _I128ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _I128ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var I256ColumnBuilder = class _I256ColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _I256ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _I256ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _I256ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new _I256ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new _I256ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _I256ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var F32ColumnBuilder = class _F32ColumnBuilder extends ColumnBuilder {
	default(value) {
		return new _F32ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _F32ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var F64ColumnBuilder = class _F64ColumnBuilder extends ColumnBuilder {
	default(value) {
		return new _F64ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _F64ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var BoolColumnBuilder = class _BoolColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _BoolColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _BoolColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _BoolColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	default(value) {
		return new _BoolColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _BoolColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var StringColumnBuilder = class _StringColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _StringColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _StringColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _StringColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	default(value) {
		return new _StringColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _StringColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var ArrayColumnBuilder = class _ArrayColumnBuilder extends ColumnBuilder {
	default(value) {
		return new _ArrayColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _ArrayColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var ByteArrayColumnBuilder = class _ByteArrayColumnBuilder extends ColumnBuilder {
	constructor(metadata) {
		super(new TypeBuilder(AlgebraicType.Array(AlgebraicType.U8)), metadata);
	}
	default(value) {
		return new _ByteArrayColumnBuilder(set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _ByteArrayColumnBuilder(set(this.columnMetadata, { name }));
	}
};
var OptionColumnBuilder = class _OptionColumnBuilder extends ColumnBuilder {
	default(value) {
		return new _OptionColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _OptionColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var ResultColumnBuilder = class _ResultColumnBuilder extends ColumnBuilder {
	constructor(typeBuilder, metadata) {
		super(typeBuilder, metadata);
	}
	default(value) {
		return new _ResultColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
};
var ProductColumnBuilder = class _ProductColumnBuilder extends ColumnBuilder {
	default(value) {
		return new _ProductColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _ProductColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var SumColumnBuilder = class _SumColumnBuilder extends ColumnBuilder {
	default(value) {
		return new _SumColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _SumColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var SimpleSumColumnBuilder = class _SimpleSumColumnBuilder extends SumColumnBuilder {
	index(algorithm = "btree") {
		return new _SimpleSumColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	primaryKey() {
		return new _SimpleSumColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
};
var ScheduleAtColumnBuilder = class _ScheduleAtColumnBuilder extends ColumnBuilder {
	default(value) {
		return new _ScheduleAtColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _ScheduleAtColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var IdentityColumnBuilder = class _IdentityColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _IdentityColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _IdentityColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _IdentityColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	default(value) {
		return new _IdentityColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _IdentityColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var ConnectionIdColumnBuilder = class _ConnectionIdColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _ConnectionIdColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _ConnectionIdColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _ConnectionIdColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	default(value) {
		return new _ConnectionIdColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _ConnectionIdColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var TimestampColumnBuilder = class _TimestampColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _TimestampColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _TimestampColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _TimestampColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	default(value) {
		return new _TimestampColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _TimestampColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var TimeDurationColumnBuilder = class _TimeDurationColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _TimeDurationColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _TimeDurationColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _TimeDurationColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	default(value) {
		return new _TimeDurationColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _TimeDurationColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var UuidColumnBuilder = class _UuidColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _UuidColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _UuidColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _UuidColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	default(value) {
		return new _UuidColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
};
var RefBuilder = class extends TypeBuilder {
	ref;
	/** The phantom type of the pointee of this ref. */
	__spacetimeType;
	constructor(ref) {
		super(AlgebraicType.Ref(ref));
		this.ref = ref;
	}
};
var enumImpl = ((nameOrObj, maybeObj) => {
	let obj = nameOrObj;
	let name = void 0;
	if (typeof nameOrObj === "string") {
		if (!maybeObj) throw new TypeError("When providing a name, you must also provide the variants object or array.");
		obj = maybeObj;
		name = nameOrObj;
	}
	if (Array.isArray(obj)) {
		const simpleVariantsObj = {};
		for (const variant of obj) simpleVariantsObj[variant] = new UnitBuilder();
		return new SimpleSumBuilderImpl(simpleVariantsObj, name);
	}
	return new SumBuilder(obj, name);
});
var t = {
	bool: () => new BoolBuilder(),
	string: () => new StringBuilder(),
	number: () => new F64Builder(),
	i8: () => new I8Builder(),
	u8: () => new U8Builder(),
	i16: () => new I16Builder(),
	u16: () => new U16Builder(),
	i32: () => new I32Builder(),
	u32: () => new U32Builder(),
	i64: () => new I64Builder(),
	u64: () => new U64Builder(),
	i128: () => new I128Builder(),
	u128: () => new U128Builder(),
	i256: () => new I256Builder(),
	u256: () => new U256Builder(),
	f32: () => new F32Builder(),
	f64: () => new F64Builder(),
	object: ((nameOrObj, maybeObj) => {
		if (typeof nameOrObj === "string") {
			if (!maybeObj) throw new TypeError("When providing a name, you must also provide the object.");
			return new ProductBuilder(maybeObj, nameOrObj);
		}
		return new ProductBuilder(nameOrObj, void 0);
	}),
	row: ((nameOrObj, maybeObj) => {
		const [obj, name] = typeof nameOrObj === "string" ? [maybeObj, nameOrObj] : [nameOrObj, void 0];
		return new RowBuilder(obj, name);
	}),
	array(e) {
		return new ArrayBuilder(e);
	},
	enum: enumImpl,
	unit() {
		return new UnitBuilder();
	},
	lazy(thunk) {
		let cached = null;
		const get = () => cached ??= thunk();
		return new Proxy({}, {
			get(_t, prop, recv) {
				const target = get();
				const val = Reflect.get(target, prop, recv);
				return typeof val === "function" ? val.bind(target) : val;
			},
			set(_t, prop, value, recv) {
				return Reflect.set(get(), prop, value, recv);
			},
			has(_t, prop) {
				return prop in get();
			},
			ownKeys() {
				return Reflect.ownKeys(get());
			},
			getOwnPropertyDescriptor(_t, prop) {
				return Object.getOwnPropertyDescriptor(get(), prop);
			},
			getPrototypeOf() {
				return Object.getPrototypeOf(get());
			}
		});
	},
	scheduleAt: () => {
		return new ScheduleAtBuilder();
	},
	option(value) {
		return new OptionBuilder(value);
	},
	result(ok, err) {
		return new ResultBuilder(ok, err);
	},
	identity: () => {
		return new IdentityBuilder();
	},
	connectionId: () => {
		return new ConnectionIdBuilder();
	},
	timestamp: () => {
		return new TimestampBuilder();
	},
	timeDuration: () => {
		return new TimeDurationBuilder();
	},
	uuid: () => {
		return new UuidBuilder();
	},
	byteArray: () => {
		return new ByteArrayBuilder();
	}
};
var lifecycle_type_default = t.enum("Lifecycle", {
	Init: t.unit(),
	OnConnect: t.unit(),
	OnDisconnect: t.unit()
});
function pushReducer(name, params, fn, lifecycle) {
	if (existingReducers.has(name)) throw new TypeError(`There is already a reducer with the name '${name}'`);
	existingReducers.add(name);
	if (!(params instanceof RowBuilder)) params = new RowBuilder(params);
	if (params.typeName === void 0) params.typeName = toPascalCase(name);
	const ref = registerTypesRecursively(params);
	const paramsType = resolveType(MODULE_DEF.typespace, ref).value;
	MODULE_DEF.reducers.push({
		name,
		params: paramsType,
		lifecycle
	});
	if (!fn.name) Object.defineProperty(fn, "name", {
		value: name,
		writable: false
	});
	REDUCERS.push(fn);
}
var existingReducers = /* @__PURE__ */ new Set();
var REDUCERS = [];
function reducer(name, params, fn) {
	pushReducer(name, params, fn);
}
function init(name, params, fn) {
	pushReducer(name, params, fn, lifecycle_type_default.Init);
}
function clientConnected(name, params, fn) {
	pushReducer(name, params, fn, lifecycle_type_default.OnConnect);
}
function clientDisconnected(name, params, fn) {
	pushReducer(name, params, fn, lifecycle_type_default.OnDisconnect);
}
var QueryBrand = Symbol("QueryBrand");
var isRowTypedQuery = (val) => !!val && typeof val === "object" && QueryBrand in val;
function toSql(q) {
	return q.toSql();
}
var SemijoinImpl = class _SemijoinImpl {
	constructor(sourceQuery, filterQuery, joinCondition) {
		this.sourceQuery = sourceQuery;
		this.filterQuery = filterQuery;
		this.joinCondition = joinCondition;
		if (sourceQuery.table.name === filterQuery.table.name) throw new Error("Cannot semijoin a table to itself");
	}
	[QueryBrand] = true;
	type = "semijoin";
	build() {
		return this;
	}
	where(predicate) {
		return new _SemijoinImpl(this.sourceQuery.where(predicate), this.filterQuery, this.joinCondition);
	}
	toSql() {
		const left = this.filterQuery;
		const right = this.sourceQuery;
		const leftTable = quoteIdentifier(left.table.name);
		const rightTable = quoteIdentifier(right.table.name);
		let sql = `SELECT ${rightTable}.* FROM ${leftTable} JOIN ${rightTable} ON ${booleanExprToSql(this.joinCondition)}`;
		const clauses = [];
		if (left.whereClause) clauses.push(booleanExprToSql(left.whereClause));
		if (right.whereClause) clauses.push(booleanExprToSql(right.whereClause));
		if (clauses.length > 0) {
			const whereSql = clauses.length === 1 ? clauses[0] : clauses.map(wrapInParens).join(" AND ");
			sql += ` WHERE ${whereSql}`;
		}
		return sql;
	}
};
var FromBuilder = class _FromBuilder {
	constructor(table2, whereClause) {
		this.table = table2;
		this.whereClause = whereClause;
	}
	[QueryBrand] = true;
	where(predicate) {
		const newCondition = predicate(this.table.cols);
		const nextWhere = this.whereClause ? and$1(this.whereClause, newCondition) : newCondition;
		return new _FromBuilder(this.table, nextWhere);
	}
	rightSemijoin(right, on) {
		const sourceQuery = new _FromBuilder(right);
		const joinCondition = on(this.table.indexedCols, right.indexedCols);
		return new SemijoinImpl(sourceQuery, this, joinCondition);
	}
	leftSemijoin(right, on) {
		const filterQuery = new _FromBuilder(right);
		const joinCondition = on(this.table.indexedCols, right.indexedCols);
		return new SemijoinImpl(this, filterQuery, joinCondition);
	}
	toSql() {
		return renderSelectSqlWithJoins(this.table, this.whereClause);
	}
	build() {
		return this;
	}
};
var TableRefImpl = class {
	type = "table";
	name;
	cols;
	indexedCols;
	tableDef;
	constructor(tableDef) {
		this.name = tableDef.name;
		this.cols = createRowExpr(tableDef);
		this.indexedCols = this.cols;
		this.tableDef = tableDef;
		Object.freeze(this);
	}
	asFrom() {
		return new FromBuilder(this);
	}
	rightSemijoin(other, on) {
		return this.asFrom().rightSemijoin(other, on);
	}
	leftSemijoin(other, on) {
		return this.asFrom().leftSemijoin(other, on);
	}
	build() {
		return this.asFrom().build();
	}
	toSql() {
		return this.asFrom().toSql();
	}
	where(predicate) {
		return this.asFrom().where(predicate);
	}
};
function createTableRefFromDef(tableDef) {
	return new TableRefImpl(tableDef);
}
function makeQueryBuilder(schema2) {
	const qb = /* @__PURE__ */ Object.create(null);
	for (const table2 of schema2.tables) {
		const ref = createTableRefFromDef(table2);
		qb[table2.name] = ref;
	}
	return Object.freeze(qb);
}
function createRowExpr(tableDef) {
	const row = {};
	for (const columnName of Object.keys(tableDef.columns)) {
		const columnBuilder = tableDef.columns[columnName];
		const column = new ColumnExpression(tableDef.name, columnName, columnBuilder.typeBuilder.algebraicType);
		row[columnName] = Object.freeze(column);
	}
	return Object.freeze(row);
}
function renderSelectSqlWithJoins(table2, where, extraClauses = []) {
	const sql = `SELECT * FROM ${quoteIdentifier(table2.name)}`;
	const clauses = [];
	if (where) clauses.push(booleanExprToSql(where));
	clauses.push(...extraClauses);
	if (clauses.length === 0) return sql;
	return `${sql} WHERE ${clauses.length === 1 ? clauses[0] : clauses.map(wrapInParens).join(" AND ")}`;
}
var ColumnExpression = class {
	type = "column";
	column;
	table;
	tsValueType;
	spacetimeType;
	constructor(table2, column, spacetimeType) {
		this.table = table2;
		this.column = column;
		this.spacetimeType = spacetimeType;
	}
	eq(x) {
		return {
			type: "eq",
			left: this,
			right: normalizeValue(x)
		};
	}
	lt(x) {
		return {
			type: "lt",
			left: this,
			right: normalizeValue(x)
		};
	}
	lte(x) {
		return {
			type: "lte",
			left: this,
			right: normalizeValue(x)
		};
	}
	gt(x) {
		return {
			type: "gt",
			left: this,
			right: normalizeValue(x)
		};
	}
	gte(x) {
		return {
			type: "gte",
			left: this,
			right: normalizeValue(x)
		};
	}
};
function literal(value) {
	return {
		type: "literal",
		value
	};
}
function normalizeValue(val) {
	if (val.type === "literal") return val;
	if (typeof val === "object" && val != null && "type" in val && val.type === "column") return val;
	return literal(val);
}
function and$1(...clauses) {
	return {
		type: "and",
		clauses
	};
}
function booleanExprToSql(expr, tableAlias) {
	switch (expr.type) {
		case "eq": return `${valueExprToSql(expr.left)} = ${valueExprToSql(expr.right)}`;
		case "ne": return `${valueExprToSql(expr.left)} <> ${valueExprToSql(expr.right)}`;
		case "gt": return `${valueExprToSql(expr.left)} > ${valueExprToSql(expr.right)}`;
		case "gte": return `${valueExprToSql(expr.left)} >= ${valueExprToSql(expr.right)}`;
		case "lt": return `${valueExprToSql(expr.left)} < ${valueExprToSql(expr.right)}`;
		case "lte": return `${valueExprToSql(expr.left)} <= ${valueExprToSql(expr.right)}`;
		case "and": return expr.clauses.map((c) => booleanExprToSql(c)).map(wrapInParens).join(" AND ");
		case "or": return expr.clauses.map((c) => booleanExprToSql(c)).map(wrapInParens).join(" OR ");
		case "not": return `NOT ${wrapInParens(booleanExprToSql(expr.clause))}`;
	}
}
function wrapInParens(sql) {
	return `(${sql})`;
}
function valueExprToSql(expr, tableAlias) {
	if (isLiteralExpr(expr)) return literalValueToSql(expr.value);
	const table2 = expr.table;
	return `${quoteIdentifier(table2)}.${quoteIdentifier(expr.column)}`;
}
function literalValueToSql(value) {
	if (value === null || value === void 0) return "NULL";
	if (value instanceof Identity || value instanceof ConnectionId) return `0x${value.toHexString()}`;
	switch (typeof value) {
		case "number":
		case "bigint": return String(value);
		case "boolean": return value ? "TRUE" : "FALSE";
		case "string": return `'${value.replace(/'/g, "''")}'`;
		default: return `'${JSON.stringify(value).replace(/'/g, "''")}'`;
	}
}
function quoteIdentifier(name) {
	return `"${name.replace(/"/g, "\"\"")}"`;
}
function isLiteralExpr(expr) {
	return expr.type === "literal";
}
function defineView(opts, anon, params, ret, fn) {
	const paramsBuilder = new RowBuilder(params, toPascalCase(opts.name));
	let returnType = registerTypesRecursively(ret).algebraicType;
	const { value: paramType } = resolveType(MODULE_DEF.typespace, registerTypesRecursively(paramsBuilder));
	MODULE_DEF.miscExports.push({
		tag: "View",
		value: {
			name: opts.name,
			index: (anon ? ANON_VIEWS : VIEWS).length,
			isPublic: opts.public,
			isAnonymous: anon,
			params: paramType,
			returnType
		}
	});
	if (returnType.tag == "Sum") {
		const originalFn = fn;
		fn = ((ctx, args) => {
			const ret2 = originalFn(ctx, args);
			return ret2 == null ? [] : [ret2];
		});
		returnType = AlgebraicType.Array(returnType.value.variants[0].algebraicType);
	}
	(anon ? ANON_VIEWS : VIEWS).push({
		fn,
		params: paramType,
		returnType,
		returnTypeBaseSize: bsatnBaseSize(MODULE_DEF.typespace, returnType)
	});
}
var VIEWS = [];
var ANON_VIEWS = [];
function procedure(name, params, ret, fn) {
	const paramsType = { elements: Object.entries(params).map(([n, c]) => ({
		name: n,
		algebraicType: registerTypesRecursively("typeBuilder" in c ? c.typeBuilder : c).algebraicType
	})) };
	const returnType = registerTypesRecursively(ret).algebraicType;
	MODULE_DEF.miscExports.push({
		tag: "Procedure",
		value: {
			name,
			params: paramsType,
			returnType
		}
	});
	PROCEDURES.push({
		fn,
		paramsType,
		returnType,
		returnTypeBaseSize: bsatnBaseSize(MODULE_DEF.typespace, returnType)
	});
}
var PROCEDURES = [];
var REGISTERED_SCHEMA = null;
function getRegisteredSchema() {
	if (REGISTERED_SCHEMA == null) throw new Error("Schema has not been registered yet. Call schema() first.");
	return REGISTERED_SCHEMA;
}
function tablesToSchema(tables) {
	return { tables: tables.map(tableToSchema) };
}
function tableToSchema(schema2) {
	const getColName = (i) => schema2.rowType.algebraicType.value.elements[i].name;
	return {
		name: schema2.tableName,
		accessorName: toCamelCase(schema2.tableName),
		columns: schema2.rowType.row,
		rowType: schema2.rowSpacetimeType,
		constraints: schema2.tableDef.constraints.map((c) => ({
			name: c.name,
			constraint: "unique",
			columns: c.data.value.columns.map(getColName)
		})),
		indexes: schema2.tableDef.indexes.map((idx) => {
			const columnIds = idx.algorithm.tag === "Direct" ? [idx.algorithm.value] : idx.algorithm.value;
			return {
				name: idx.accessorName,
				unique: schema2.tableDef.constraints.some((c) => c.data.value.columns.every((col) => columnIds.includes(col))),
				algorithm: idx.algorithm.tag.toLowerCase(),
				columns: columnIds.map(getColName)
			};
		})
	};
}
var MODULE_DEF = {
	typespace: { types: [] },
	tables: [],
	reducers: [],
	types: [],
	miscExports: [],
	rowLevelSecurity: []
};
var COMPOUND_TYPES = /* @__PURE__ */ new Map();
function resolveType(typespace, typeBuilder) {
	let ty = typeBuilder.algebraicType;
	while (ty.tag === "Ref") ty = typespace.types[ty.value];
	return ty;
}
function registerTypesRecursively(typeBuilder) {
	if (typeBuilder instanceof ProductBuilder && !isUnit(typeBuilder) || typeBuilder instanceof SumBuilder || typeBuilder instanceof RowBuilder) return registerCompoundTypeRecursively(typeBuilder);
	else if (typeBuilder instanceof OptionBuilder) return new OptionBuilder(registerTypesRecursively(typeBuilder.value));
	else if (typeBuilder instanceof ResultBuilder) return new ResultBuilder(registerTypesRecursively(typeBuilder.ok), registerTypesRecursively(typeBuilder.err));
	else if (typeBuilder instanceof ArrayBuilder) return new ArrayBuilder(registerTypesRecursively(typeBuilder.element));
	else return typeBuilder;
}
function registerCompoundTypeRecursively(typeBuilder) {
	const ty = typeBuilder.algebraicType;
	const name = typeBuilder.typeName;
	if (name === void 0) throw new Error(`Missing type name for ${typeBuilder.constructor.name ?? "TypeBuilder"} ${JSON.stringify(typeBuilder)}`);
	let r = COMPOUND_TYPES.get(ty);
	if (r != null) return r;
	const newTy = typeBuilder instanceof RowBuilder || typeBuilder instanceof ProductBuilder ? {
		tag: "Product",
		value: { elements: [] }
	} : {
		tag: "Sum",
		value: { variants: [] }
	};
	r = new RefBuilder(MODULE_DEF.typespace.types.length);
	MODULE_DEF.typespace.types.push(newTy);
	COMPOUND_TYPES.set(ty, r);
	if (typeBuilder instanceof RowBuilder) for (const [name2, elem] of Object.entries(typeBuilder.row)) newTy.value.elements.push({
		name: name2,
		algebraicType: registerTypesRecursively(elem.typeBuilder).algebraicType
	});
	else if (typeBuilder instanceof ProductBuilder) for (const [name2, elem] of Object.entries(typeBuilder.elements)) newTy.value.elements.push({
		name: name2,
		algebraicType: registerTypesRecursively(elem).algebraicType
	});
	else if (typeBuilder instanceof SumBuilder) for (const [name2, variant] of Object.entries(typeBuilder.variants)) newTy.value.variants.push({
		name: name2,
		algebraicType: registerTypesRecursively(variant).algebraicType
	});
	MODULE_DEF.types.push({
		name: splitName(name),
		ty: r.ref,
		customOrdering: true
	});
	return r;
}
function isUnit(typeBuilder) {
	return typeBuilder.typeName == null && typeBuilder.algebraicType.value.elements.length === 0;
}
function splitName(name) {
	const scope = name.split(".");
	return {
		name: scope.pop(),
		scope
	};
}
var Schema = class {
	tablesDef;
	typespace;
	schemaType;
	constructor(tables, typespace, handles) {
		this.tablesDef = { tables };
		this.typespace = typespace;
		this.schemaType = tablesToSchema(handles);
	}
	reducer(name, paramsOrFn, fn) {
		if (typeof paramsOrFn === "function") {
			reducer(name, {}, paramsOrFn);
			return paramsOrFn;
		} else {
			reducer(name, paramsOrFn, fn);
			return fn;
		}
	}
	init(nameOrFn, maybeFn) {
		const [name, fn] = typeof nameOrFn === "string" ? [nameOrFn, maybeFn] : ["init", nameOrFn];
		init(name, {}, fn);
	}
	clientConnected(nameOrFn, maybeFn) {
		const [name, fn] = typeof nameOrFn === "string" ? [nameOrFn, maybeFn] : ["on_connect", nameOrFn];
		clientConnected(name, {}, fn);
	}
	clientDisconnected(nameOrFn, maybeFn) {
		const [name, fn] = typeof nameOrFn === "string" ? [nameOrFn, maybeFn] : ["on_disconnect", nameOrFn];
		clientDisconnected(name, {}, fn);
	}
	view(opts, ret, fn) {
		defineView(opts, false, {}, ret, fn);
	}
	anonymousView(opts, ret, fn) {
		defineView(opts, true, {}, ret, fn);
	}
	procedure(name, paramsOrRet, retOrFn, maybeFn) {
		if (typeof retOrFn === "function") {
			procedure(name, {}, paramsOrRet, retOrFn);
			return retOrFn;
		} else {
			procedure(name, paramsOrRet, retOrFn, maybeFn);
			return maybeFn;
		}
	}
	clientVisibilityFilter = { sql(filter) {
		MODULE_DEF.rowLevelSecurity.push({ sql: filter });
	} };
};
function schema(...args) {
	const handles = args.length === 1 && Array.isArray(args[0]) ? args[0] : args;
	const tableDefs = handles.map((h) => h.tableDef);
	MODULE_DEF.tables.push(...tableDefs);
	REGISTERED_SCHEMA = { tables: handles.map((handle) => ({
		name: handle.tableName,
		accessorName: handle.tableName,
		columns: handle.rowType.row,
		rowType: handle.rowSpacetimeType,
		indexes: handle.idxs,
		constraints: handle.constraints
	})) };
	return new Schema(tableDefs, MODULE_DEF.typespace, handles);
}
var raw_index_algorithm_type_default = t.enum("RawIndexAlgorithm", {
	BTree: t.array(t.u16()),
	Hash: t.array(t.u16()),
	Direct: t.u16()
});
function table(opts, row) {
	const { name, public: isPublic = false, indexes: userIndexes = [], scheduled } = opts;
	const colIds = /* @__PURE__ */ new Map();
	const colNameList = [];
	if (!(row instanceof RowBuilder)) row = new RowBuilder(row);
	if (row.typeName === void 0) row.typeName = toPascalCase(name);
	const rowTypeRef = registerTypesRecursively(row);
	row.algebraicType.value.elements.forEach((elem, i) => {
		colIds.set(elem.name, i);
		colNameList.push(elem.name);
	});
	const pk = [];
	const indexes = [];
	const constraints = [];
	const sequences = [];
	let scheduleAtCol;
	for (const [name2, builder] of Object.entries(row.row)) {
		const meta = builder.columnMetadata;
		if (meta.isPrimaryKey) pk.push(colIds.get(name2));
		const isUnique = meta.isUnique || meta.isPrimaryKey;
		if (meta.indexType || isUnique) {
			const algo = meta.indexType ?? "btree";
			const id = colIds.get(name2);
			let algorithm;
			switch (algo) {
				case "btree":
					algorithm = raw_index_algorithm_type_default.BTree([id]);
					break;
				case "direct":
					algorithm = raw_index_algorithm_type_default.Direct(id);
					break;
			}
			indexes.push({
				name: void 0,
				accessorName: name2,
				algorithm
			});
		}
		if (isUnique) constraints.push({
			name: void 0,
			data: {
				tag: "Unique",
				value: { columns: [colIds.get(name2)] }
			}
		});
		if (meta.isAutoIncrement) sequences.push({
			name: void 0,
			start: void 0,
			minValue: void 0,
			maxValue: void 0,
			column: colIds.get(name2),
			increment: 1n
		});
		if (scheduled) {
			const algebraicType = builder.typeBuilder.algebraicType;
			if (schedule_at_default.isScheduleAt(algebraicType)) scheduleAtCol = colIds.get(name2);
		}
	}
	for (const indexOpts of userIndexes ?? []) {
		let algorithm;
		switch (indexOpts.algorithm) {
			case "btree":
				algorithm = {
					tag: "BTree",
					value: indexOpts.columns.map((c) => colIds.get(c))
				};
				break;
			case "direct":
				algorithm = {
					tag: "Direct",
					value: colIds.get(indexOpts.column)
				};
				break;
		}
		indexes.push({
			name: void 0,
			accessorName: indexOpts.name,
			algorithm
		});
	}
	for (const constraintOpts of opts.constraints ?? []) if (constraintOpts.constraint === "unique") {
		const data = {
			tag: "Unique",
			value: { columns: constraintOpts.columns.map((c) => colIds.get(c)) }
		};
		constraints.push({
			name: constraintOpts.name,
			data
		});
		continue;
	}
	for (const index of indexes) index.name = `${name}_${(index.algorithm.tag === "Direct" ? [index.algorithm.value] : index.algorithm.value).map((i) => colNameList[i]).join("_")}_idx_${index.algorithm.tag.toLowerCase()}`;
	const tableDef = {
		name,
		productTypeRef: rowTypeRef.ref,
		primaryKey: pk,
		indexes,
		constraints,
		sequences,
		schedule: scheduled && scheduleAtCol !== void 0 ? {
			name: void 0,
			reducerName: scheduled,
			scheduledAtColumn: scheduleAtCol
		} : void 0,
		tableType: { tag: "User" },
		tableAccess: { tag: isPublic ? "Public" : "Private" }
	};
	const productType = row.algebraicType.value;
	return {
		rowType: row,
		tableName: name,
		rowSpacetimeType: productType,
		tableDef,
		idxs: {},
		constraints
	};
}
var SpacetimeHostError = class _SpacetimeHostError extends Error {
	code;
	message;
	constructor(code, message) {
		super();
		const proto = Object.getPrototypeOf(this);
		let cls;
		if (errorProtoypes.has(proto)) {
			cls = proto.constructor;
			if (code !== cls.CODE) throw new TypeError(`invalid error code for ${cls.name}`);
		} else if (proto === _SpacetimeHostError.prototype) {
			cls = errnoToClass.get(code);
			if (!cls) throw new RangeError(`unknown error code ${code}`);
		} else throw new TypeError("cannot subclass SpacetimeError");
		Object.setPrototypeOf(this, cls.prototype);
		this.code = cls.CODE;
		this.message = message ?? cls.MESSAGE;
	}
	get name() {
		return errnoToClass.get(this.code)?.name ?? "SpacetimeHostError";
	}
};
var SenderError = class extends Error {
	constructor(message) {
		super(message);
	}
	get name() {
		return "SenderError";
	}
};
var errorData = {
	HostCallFailure: [1, "ABI called by host returned an error"],
	NotInTransaction: [2, "ABI call can only be made while in a transaction"],
	BsatnDecodeError: [3, "Couldn't decode the BSATN to the expected type"],
	NoSuchTable: [4, "No such table"],
	NoSuchIndex: [5, "No such index"],
	NoSuchIter: [6, "The provided row iterator is not valid"],
	NoSuchConsoleTimer: [7, "The provided console timer does not exist"],
	NoSuchBytes: [8, "The provided bytes source or sink is not valid"],
	NoSpace: [9, "The provided sink has no more space left"],
	BufferTooSmall: [11, "The provided buffer is not large enough to store the data"],
	UniqueAlreadyExists: [12, "Value with given unique identifier already exists"],
	ScheduleAtDelayTooLong: [13, "Specified delay in scheduling row was too long"],
	IndexNotUnique: [14, "The index was not unique"],
	NoSuchRow: [15, "The row was not found, e.g., in an update call"],
	AutoIncOverflow: [16, "The auto-increment sequence overflowed"],
	WouldBlockTransaction: [17, "Attempted async or blocking op while holding open a transaction"],
	TransactionNotAnonymous: [18, "Not in an anonymous transaction. Called by a reducer?"],
	TransactionIsReadOnly: [19, "ABI call can only be made while within a mutable transaction"],
	TransactionIsMut: [20, "ABI call can only be made while within a read-only transaction"],
	HttpError: [21, "The HTTP request failed"]
};
function mapEntries(x, f) {
	return Object.fromEntries(Object.entries(x).map(([k, v]) => [k, f(k, v)]));
}
var errors = Object.freeze(mapEntries(errorData, (name, [code, message]) => Object.defineProperty(class extends SpacetimeHostError {
	static CODE = code;
	static MESSAGE = message;
	constructor() {
		super(code);
	}
}, "name", {
	value: name,
	writable: false
})));
var errorProtoypes = new Set(Object.values(errors).map((cls) => cls.prototype));
var errnoToClass = new Map(Object.values(errors).map((cls) => [cls.CODE, cls]));
__toESM(require_text_min());
var sum_type_variant_type_default = t.object("SumTypeVariant", {
	name: t.option(t.string()),
	get algebraicType() {
		return algebraic_type_type_default;
	}
});
var sum_type_type_default = t.object("SumType", { get variants() {
	return t.array(sum_type_variant_type_default);
} });
var product_type_element_type_default = t.object("ProductTypeElement", {
	name: t.option(t.string()),
	get algebraicType() {
		return algebraic_type_type_default;
	}
});
var product_type_type_default = t.object("ProductType", { get elements() {
	return t.array(product_type_element_type_default);
} });
var AlgebraicType2 = t.enum("AlgebraicType", {
	Ref: t.u32(),
	get Sum() {
		return sum_type_type_default;
	},
	get Product() {
		return product_type_type_default;
	},
	get Array() {
		return AlgebraicType2;
	},
	String: t.unit(),
	Bool: t.unit(),
	I8: t.unit(),
	U8: t.unit(),
	I16: t.unit(),
	U16: t.unit(),
	I32: t.unit(),
	U32: t.unit(),
	I64: t.unit(),
	U64: t.unit(),
	I128: t.unit(),
	U128: t.unit(),
	I256: t.unit(),
	U256: t.unit(),
	F32: t.unit(),
	F64: t.unit()
});
var algebraic_type_type_default = AlgebraicType2;
var typespace_type_default = t.object("Typespace", { get types() {
	return t.array(algebraic_type_type_default);
} });
var raw_column_def_v_8_type_default = t.object("RawColumnDefV8", {
	colName: t.string(),
	get colType() {
		return algebraic_type_type_default;
	}
});
var index_type_type_default = t.enum("IndexType", {
	BTree: t.unit(),
	Hash: t.unit()
});
var raw_index_def_v_8_type_default = t.object("RawIndexDefV8", {
	indexName: t.string(),
	isUnique: t.bool(),
	get indexType() {
		return index_type_type_default;
	},
	columns: t.array(t.u16())
});
var raw_constraint_def_v_8_type_default = t.object("RawConstraintDefV8", {
	constraintName: t.string(),
	constraints: t.u8(),
	columns: t.array(t.u16())
});
var raw_sequence_def_v_8_type_default = t.object("RawSequenceDefV8", {
	sequenceName: t.string(),
	colPos: t.u16(),
	increment: t.i128(),
	start: t.option(t.i128()),
	minValue: t.option(t.i128()),
	maxValue: t.option(t.i128()),
	allocated: t.i128()
});
var raw_table_def_v_8_type_default = t.object("RawTableDefV8", {
	tableName: t.string(),
	get columns() {
		return t.array(raw_column_def_v_8_type_default);
	},
	get indexes() {
		return t.array(raw_index_def_v_8_type_default);
	},
	get constraints() {
		return t.array(raw_constraint_def_v_8_type_default);
	},
	get sequences() {
		return t.array(raw_sequence_def_v_8_type_default);
	},
	tableType: t.string(),
	tableAccess: t.string(),
	scheduled: t.option(t.string())
});
var table_desc_type_default = t.object("TableDesc", {
	get schema() {
		return raw_table_def_v_8_type_default;
	},
	data: t.u32()
});
var reducer_def_type_default = t.object("ReducerDef", {
	name: t.string(),
	get args() {
		return t.array(product_type_element_type_default);
	}
});
var type_alias_type_default = t.object("TypeAlias", {
	name: t.string(),
	ty: t.u32()
});
var misc_module_export_type_default = t.enum("MiscModuleExport", { get TypeAlias() {
	return type_alias_type_default;
} });
var raw_module_def_v_8_type_default = t.object("RawModuleDefV8", {
	get typespace() {
		return typespace_type_default;
	},
	get tables() {
		return t.array(table_desc_type_default);
	},
	get reducers() {
		return t.array(reducer_def_type_default);
	},
	get miscExports() {
		return t.array(misc_module_export_type_default);
	}
});
var raw_index_def_v_9_type_default = t.object("RawIndexDefV9", {
	name: t.option(t.string()),
	accessorName: t.option(t.string()),
	get algorithm() {
		return raw_index_algorithm_type_default;
	}
});
var raw_unique_constraint_data_v_9_type_default = t.object("RawUniqueConstraintDataV9", { columns: t.array(t.u16()) });
var raw_constraint_data_v_9_type_default = t.enum("RawConstraintDataV9", { get Unique() {
	return raw_unique_constraint_data_v_9_type_default;
} });
var raw_constraint_def_v_9_type_default = t.object("RawConstraintDefV9", {
	name: t.option(t.string()),
	get data() {
		return raw_constraint_data_v_9_type_default;
	}
});
var raw_sequence_def_v_9_type_default = t.object("RawSequenceDefV9", {
	name: t.option(t.string()),
	column: t.u16(),
	start: t.option(t.i128()),
	minValue: t.option(t.i128()),
	maxValue: t.option(t.i128()),
	increment: t.i128()
});
var raw_schedule_def_v_9_type_default = t.object("RawScheduleDefV9", {
	name: t.option(t.string()),
	reducerName: t.string(),
	scheduledAtColumn: t.u16()
});
var table_type_type_default = t.enum("TableType", {
	System: t.unit(),
	User: t.unit()
});
var table_access_type_default = t.enum("TableAccess", {
	Public: t.unit(),
	Private: t.unit()
});
var raw_table_def_v_9_type_default = t.object("RawTableDefV9", {
	name: t.string(),
	productTypeRef: t.u32(),
	primaryKey: t.array(t.u16()),
	get indexes() {
		return t.array(raw_index_def_v_9_type_default);
	},
	get constraints() {
		return t.array(raw_constraint_def_v_9_type_default);
	},
	get sequences() {
		return t.array(raw_sequence_def_v_9_type_default);
	},
	get schedule() {
		return t.option(raw_schedule_def_v_9_type_default);
	},
	get tableType() {
		return table_type_type_default;
	},
	get tableAccess() {
		return table_access_type_default;
	}
});
var raw_reducer_def_v_9_type_default = t.object("RawReducerDefV9", {
	name: t.string(),
	get params() {
		return product_type_type_default;
	},
	get lifecycle() {
		return t.option(lifecycle_type_default);
	}
});
var raw_scoped_type_name_v_9_type_default = t.object("RawScopedTypeNameV9", {
	scope: t.array(t.string()),
	name: t.string()
});
var raw_type_def_v_9_type_default = t.object("RawTypeDefV9", {
	get name() {
		return raw_scoped_type_name_v_9_type_default;
	},
	ty: t.u32(),
	customOrdering: t.bool()
});
var raw_column_default_value_v_9_type_default = t.object("RawColumnDefaultValueV9", {
	table: t.string(),
	colId: t.u16(),
	value: t.byteArray()
});
var raw_procedure_def_v_9_type_default = t.object("RawProcedureDefV9", {
	name: t.string(),
	get params() {
		return product_type_type_default;
	},
	get returnType() {
		return algebraic_type_type_default;
	}
});
var raw_view_def_v_9_type_default = t.object("RawViewDefV9", {
	name: t.string(),
	index: t.u32(),
	isPublic: t.bool(),
	isAnonymous: t.bool(),
	get params() {
		return product_type_type_default;
	},
	get returnType() {
		return algebraic_type_type_default;
	}
});
var raw_misc_module_export_v_9_type_default = t.enum("RawMiscModuleExportV9", {
	get ColumnDefaultValue() {
		return raw_column_default_value_v_9_type_default;
	},
	get Procedure() {
		return raw_procedure_def_v_9_type_default;
	},
	get View() {
		return raw_view_def_v_9_type_default;
	}
});
var raw_row_level_security_def_v_9_type_default = t.object("RawRowLevelSecurityDefV9", { sql: t.string() });
var raw_module_def_v_9_type_default = t.object("RawModuleDefV9", {
	get typespace() {
		return typespace_type_default;
	},
	get tables() {
		return t.array(raw_table_def_v_9_type_default);
	},
	get reducers() {
		return t.array(raw_reducer_def_v_9_type_default);
	},
	get types() {
		return t.array(raw_type_def_v_9_type_default);
	},
	get miscExports() {
		return t.array(raw_misc_module_export_v_9_type_default);
	},
	get rowLevelSecurity() {
		return t.array(raw_row_level_security_def_v_9_type_default);
	}
});
var raw_module_def_type_default = t.enum("RawModuleDef", {
	get V8BackCompat() {
		return raw_module_def_v_8_type_default;
	},
	get V9() {
		return raw_module_def_v_9_type_default;
	}
});
var Range = class {
	#from;
	#to;
	constructor(from, to) {
		this.#from = from ?? { tag: "unbounded" };
		this.#to = to ?? { tag: "unbounded" };
	}
	get from() {
		return this.#from;
	}
	get to() {
		return this.#to;
	}
};
var import_statuses = __toESM(require_statuses());
var http_header_pair_type_default = t.object("HttpHeaderPair", {
	name: t.string(),
	value: t.byteArray()
});
var http_headers_type_default = t.object("HttpHeaders", { get entries() {
	return t.array(http_header_pair_type_default);
} });
var http_method_type_default = t.enum("HttpMethod", {
	Get: t.unit(),
	Head: t.unit(),
	Post: t.unit(),
	Put: t.unit(),
	Delete: t.unit(),
	Connect: t.unit(),
	Options: t.unit(),
	Trace: t.unit(),
	Patch: t.unit(),
	Extension: t.string()
});
var http_version_type_default = t.enum("HttpVersion", {
	Http09: t.unit(),
	Http10: t.unit(),
	Http11: t.unit(),
	Http2: t.unit(),
	Http3: t.unit()
});
var http_request_type_default = t.object("HttpRequest", {
	get method() {
		return http_method_type_default;
	},
	get headers() {
		return http_headers_type_default;
	},
	timeout: t.option(t.timeDuration()),
	uri: t.string(),
	get version() {
		return http_version_type_default;
	}
});
var http_response_type_default = t.object("HttpResponse", {
	get headers() {
		return http_headers_type_default;
	},
	get version() {
		return http_version_type_default;
	},
	code: t.u16()
});
var { freeze } = Object;
var textEncoder = new TextEncoder();
var textDecoder = new TextDecoder("utf-8");
var makeResponse = Symbol("makeResponse");
var SyncResponse = class _SyncResponse {
	#body;
	#inner;
	constructor(body, init2) {
		if (body == null) this.#body = null;
		else if (typeof body === "string") this.#body = body;
		else this.#body = new Uint8Array(body).buffer;
		this.#inner = {
			headers: new Headers(init2?.headers),
			status: init2?.status ?? 200,
			statusText: init2?.statusText ?? "",
			type: "default",
			url: null,
			aborted: false
		};
	}
	static [makeResponse](body, inner) {
		const me = new _SyncResponse(body);
		me.#inner = inner;
		return me;
	}
	get headers() {
		return this.#inner.headers;
	}
	get status() {
		return this.#inner.status;
	}
	get statusText() {
		return this.#inner.statusText;
	}
	get ok() {
		return 200 <= this.#inner.status && this.#inner.status <= 299;
	}
	get url() {
		return this.#inner.url ?? "";
	}
	get type() {
		return this.#inner.type;
	}
	arrayBuffer() {
		return this.bytes().buffer;
	}
	bytes() {
		if (this.#body == null) return new Uint8Array();
		else if (typeof this.#body === "string") return textEncoder.encode(this.#body);
		else return new Uint8Array(this.#body);
	}
	json() {
		return JSON.parse(this.text());
	}
	text() {
		if (this.#body == null) return "";
		else if (typeof this.#body === "string") return this.#body;
		else return textDecoder.decode(this.#body);
	}
};
var requestBaseSize = bsatnBaseSize({ types: [] }, http_request_type_default.algebraicType);
var methods = /* @__PURE__ */ new Map([
	["GET", { tag: "Get" }],
	["HEAD", { tag: "Head" }],
	["POST", { tag: "Post" }],
	["PUT", { tag: "Put" }],
	["DELETE", { tag: "Delete" }],
	["CONNECT", { tag: "Connect" }],
	["OPTIONS", { tag: "Options" }],
	["TRACE", { tag: "Trace" }],
	["PATCH", { tag: "Patch" }]
]);
function fetch(url, init2 = {}) {
	const method = methods.get(init2.method?.toUpperCase() ?? "GET") ?? {
		tag: "Extension",
		value: init2.method
	};
	const headers = { entries: headersToList(new Headers(init2.headers)).flatMap(([k, v]) => Array.isArray(v) ? v.map((v2) => [k, v2]) : [[k, v]]).map(([name, value]) => ({
		name,
		value: textEncoder.encode(value)
	})) };
	const uri$1 = "" + url;
	const request = freeze({
		method,
		headers,
		timeout: init2.timeout,
		uri: uri$1,
		version: { tag: "Http11" }
	});
	const requestBuf = new BinaryWriter(requestBaseSize);
	http_request_type_default.serialize(requestBuf, request);
	const body = init2.body == null ? new Uint8Array() : typeof init2.body === "string" ? init2.body : new Uint8Array(init2.body);
	const [responseBuf, responseBody] = sys.procedure_http_request(requestBuf.getBuffer(), body);
	const response = http_response_type_default.deserialize(new BinaryReader(responseBuf));
	return SyncResponse[makeResponse](responseBody, {
		type: "basic",
		url: uri$1,
		status: response.code,
		statusText: (0, import_statuses.default)(response.code),
		headers: new Headers(),
		aborted: false
	});
}
freeze(fetch);
var httpClient = freeze({ fetch });
var { freeze: freeze2 } = Object;
function callProcedure(id, sender, connectionId, timestamp, argsBuf) {
	const { fn, paramsType, returnType, returnTypeBaseSize } = PROCEDURES[id];
	const args = ProductType.deserializeValue(new BinaryReader(argsBuf), paramsType, MODULE_DEF.typespace);
	const ctx = {
		sender,
		timestamp,
		connectionId,
		http: httpClient,
		counter_uuid: { value: 0 },
		get identity() {
			return new Identity(sys.identity().__identity__);
		},
		withTx(body) {
			const run = () => {
				const timestamp2 = sys.procedure_start_mut_tx();
				try {
					return body(new ReducerCtxImpl(sender, new Timestamp(timestamp2), connectionId));
				} catch (e) {
					sys.procedure_abort_mut_tx();
					throw e;
				}
			};
			let res = run();
			try {
				sys.procedure_commit_mut_tx();
				return res;
			} catch {}
			console.warn("committing anonymous transaction failed");
			res = run();
			try {
				sys.procedure_commit_mut_tx();
				return res;
			} catch (e) {
				throw new Error("transaction retry failed again", { cause: e });
			}
		},
		newUuidV4() {
			const bytes = crypto.getRandomValues(new Uint8Array(16));
			return Uuid.fromRandomBytesV4(bytes);
		},
		newUuidV7() {
			const bytes = crypto.getRandomValues(new Uint8Array(10));
			return Uuid.fromCounterV7(this.counter_uuid, this.timestamp, bytes);
		}
	};
	freeze2(ctx);
	const ret = callUserFunction(fn, ctx, args);
	const retBuf = new BinaryWriter(returnTypeBaseSize);
	AlgebraicType.serializeValue(retBuf, returnType, ret, MODULE_DEF.typespace);
	return retBuf.getBuffer();
}
var view_result_header_type_default = t.enum("ViewResultHeader", {
	RowData: t.unit(),
	RawSql: t.string()
});
var { freeze: freeze3 } = Object;
var sys = freeze3(wrapSyscalls(_syscalls1_0, _syscalls1_2));
function parseJsonObject(json) {
	let value;
	try {
		value = JSON.parse(json);
	} catch {
		throw new Error("Invalid JSON: failed to parse string");
	}
	if (value === null || typeof value !== "object" || Array.isArray(value)) throw new Error("Expected a JSON object at the top level");
	return value;
}
var JwtClaimsImpl = class {
	/**
	* Creates a new JwtClaims instance.
	* @param rawPayload The JWT payload as a raw JSON string.
	* @param identity The identity for this JWT. We are only taking this because we don't have a blake3 implementation (which we need to compute it).
	*/
	constructor(rawPayload, identity) {
		this.rawPayload = rawPayload;
		this.fullPayload = parseJsonObject(rawPayload);
		this._identity = identity;
	}
	fullPayload;
	_identity;
	get identity() {
		return this._identity;
	}
	get subject() {
		return this.fullPayload["sub"];
	}
	get issuer() {
		return this.fullPayload["iss"];
	}
	get audience() {
		const aud = this.fullPayload["aud"];
		if (aud == null) return [];
		return typeof aud === "string" ? [aud] : aud;
	}
};
var AuthCtxImpl = class _AuthCtxImpl {
	isInternal;
	_jwtSource;
	_initializedJWT = false;
	_jwtClaims;
	_senderIdentity;
	constructor(opts) {
		this.isInternal = opts.isInternal;
		this._jwtSource = opts.jwtSource;
		this._senderIdentity = opts.senderIdentity;
	}
	_initializeJWT() {
		if (this._initializedJWT) return;
		this._initializedJWT = true;
		const token = this._jwtSource();
		if (!token) this._jwtClaims = null;
		else this._jwtClaims = new JwtClaimsImpl(token, this._senderIdentity);
		Object.freeze(this);
	}
	/** Lazily compute whether a JWT exists and is parseable. */
	get hasJWT() {
		this._initializeJWT();
		return this._jwtClaims !== null;
	}
	/** Lazily parse the JwtClaims only when accessed. */
	get jwt() {
		this._initializeJWT();
		return this._jwtClaims;
	}
	/** Create a context representing internal (non-user) requests. */
	static internal() {
		return new _AuthCtxImpl({
			isInternal: true,
			jwtSource: () => null,
			senderIdentity: Identity.zero()
		});
	}
	/** If there is a connection id, look up the JWT payload from the system tables. */
	static fromSystemTables(connectionId, sender) {
		if (connectionId === null) return new _AuthCtxImpl({
			isInternal: false,
			jwtSource: () => null,
			senderIdentity: sender
		});
		return new _AuthCtxImpl({
			isInternal: false,
			jwtSource: () => {
				const payloadBuf = sys.get_jwt_payload(connectionId.__connection_id__);
				if (payloadBuf.length === 0) return null;
				return new TextDecoder().decode(payloadBuf);
			},
			senderIdentity: sender
		});
	}
};
var ReducerCtxImpl = class ReducerCtx {
	#identity;
	#senderAuth;
	#uuidCounter;
	sender;
	timestamp;
	connectionId;
	db;
	constructor(sender, timestamp, connectionId) {
		Object.seal(this);
		this.sender = sender;
		this.timestamp = timestamp;
		this.connectionId = connectionId;
		this.db = getDbView();
	}
	get identity() {
		return this.#identity ??= new Identity(sys.identity().__identity__);
	}
	get senderAuth() {
		return this.#senderAuth ??= AuthCtxImpl.fromSystemTables(this.connectionId, this.sender);
	}
	/**
	* Create a new random {@link Uuid} `v4` using the {@link crypto} RNG.
	*
	* WARN: Until we use a spacetime RNG this make calls non-deterministic.
	*/
	newUuidV4() {
		const bytes = crypto.getRandomValues(new Uint8Array(16));
		return Uuid.fromRandomBytesV4(bytes);
	}
	/**
	* Create a new sortable {@link Uuid} `v7` using the {@link crypto} RNG, counter,
	* and the timestamp.
	*
	* WARN: Until we use a spacetime RNG this make calls non-deterministic.
	*/
	newUuidV7() {
		const bytes = crypto.getRandomValues(new Uint8Array(4));
		const counter = this.#uuidCounter ??= { value: 0 };
		return Uuid.fromCounterV7(counter, this.timestamp, bytes);
	}
};
var callUserFunction = function __spacetimedb_end_short_backtrace(fn, ...args) {
	return fn(...args);
};
var hooks = {
	__describe_module__() {
		const writer = new BinaryWriter(128);
		AlgebraicType.serializeValue(writer, raw_module_def_type_default.algebraicType, raw_module_def_type_default.V9(MODULE_DEF));
		return writer.getBuffer();
	},
	__call_reducer__(reducerId, sender, connId, timestamp, argsBuf) {
		const argsType = AlgebraicType.Product(MODULE_DEF.reducers[reducerId].params);
		const args = AlgebraicType.deserializeValue(new BinaryReader(argsBuf), argsType, MODULE_DEF.typespace);
		const ctx = new ReducerCtxImpl(new Identity(sender), new Timestamp(timestamp), ConnectionId.nullIfZero(new ConnectionId(connId)));
		try {
			return callUserFunction(REDUCERS[reducerId], ctx, args) ?? { tag: "ok" };
		} catch (e) {
			if (e instanceof SenderError) return {
				tag: "err",
				value: e.message
			};
			throw e;
		}
	}
};
var hooks_v1_1 = {
	__call_view__(id, sender, argsBuf) {
		const { fn, params, returnType, returnTypeBaseSize } = VIEWS[id];
		const ret = callUserFunction(fn, freeze3({
			sender: new Identity(sender),
			db: getDbView(),
			from: makeQueryBuilder(getRegisteredSchema())
		}), ProductType.deserializeValue(new BinaryReader(argsBuf), params, MODULE_DEF.typespace));
		const retBuf = new BinaryWriter(returnTypeBaseSize);
		if (isRowTypedQuery(ret)) {
			const query = toSql(ret);
			const v = view_result_header_type_default.RawSql(query);
			AlgebraicType.serializeValue(retBuf, view_result_header_type_default.algebraicType, v, MODULE_DEF.typespace);
			return { data: retBuf.getBuffer() };
		} else {
			AlgebraicType.serializeValue(retBuf, view_result_header_type_default.algebraicType, view_result_header_type_default.RowData, MODULE_DEF.typespace);
			AlgebraicType.serializeValue(retBuf, returnType, ret, MODULE_DEF.typespace);
			return { data: retBuf.getBuffer() };
		}
	},
	__call_view_anon__(id, argsBuf) {
		const { fn, params, returnType, returnTypeBaseSize } = ANON_VIEWS[id];
		const ret = callUserFunction(fn, freeze3({
			db: getDbView(),
			from: makeQueryBuilder(getRegisteredSchema())
		}), ProductType.deserializeValue(new BinaryReader(argsBuf), params, MODULE_DEF.typespace));
		const retBuf = new BinaryWriter(returnTypeBaseSize);
		if (isRowTypedQuery(ret)) {
			const query = toSql(ret);
			const v = view_result_header_type_default.RawSql(query);
			AlgebraicType.serializeValue(retBuf, view_result_header_type_default.algebraicType, v, MODULE_DEF.typespace);
			return { data: retBuf.getBuffer() };
		} else {
			AlgebraicType.serializeValue(retBuf, view_result_header_type_default.algebraicType, view_result_header_type_default.RowData, MODULE_DEF.typespace);
			AlgebraicType.serializeValue(retBuf, returnType, ret, MODULE_DEF.typespace);
			return { data: retBuf.getBuffer() };
		}
	}
};
var hooks_v1_2 = { __call_procedure__(id, sender, connection_id, timestamp, args) {
	return callProcedure(id, new Identity(sender), ConnectionId.nullIfZero(new ConnectionId(connection_id)), new Timestamp(timestamp), args);
} };
var DB_VIEW = null;
function getDbView() {
	DB_VIEW ??= makeDbView(MODULE_DEF);
	return DB_VIEW;
}
function makeDbView(moduleDef) {
	return freeze3(Object.fromEntries(moduleDef.tables.map((table2) => [toCamelCase(table2.name), makeTableView(moduleDef.typespace, table2)])));
}
function makeTableView(typespace, table2) {
	const table_id = sys.table_id_from_name(table2.name);
	const rowType = typespace.types[table2.productTypeRef];
	if (rowType.tag !== "Product") throw "impossible";
	const baseSize = bsatnBaseSize(typespace, rowType);
	const sequences = table2.sequences.map((seq) => {
		const col = rowType.value.elements[seq.column];
		const colType = col.algebraicType;
		let sequenceTrigger;
		switch (colType.tag) {
			case "U8":
			case "I8":
			case "U16":
			case "I16":
			case "U32":
			case "I32":
				sequenceTrigger = 0;
				break;
			case "U64":
			case "I64":
			case "U128":
			case "I128":
			case "U256":
			case "I256":
				sequenceTrigger = 0n;
				break;
			default: throw new TypeError("invalid sequence type");
		}
		return {
			colName: col.name,
			sequenceTrigger,
			read: (reader) => AlgebraicType.deserializeValue(reader, colType, typespace)
		};
	});
	const hasAutoIncrement = sequences.length > 0;
	const iter = () => tableIterator(sys.datastore_table_scan_bsatn(table_id), rowType);
	const integrateGeneratedColumns = hasAutoIncrement ? (row, ret_buf) => {
		const reader = new BinaryReader(ret_buf);
		for (const { colName, read, sequenceTrigger } of sequences) if (row[colName] === sequenceTrigger) row[colName] = read(reader);
	} : null;
	const tableMethods = {
		count: () => sys.datastore_table_row_count(table_id),
		iter,
		[Symbol.iterator]: () => iter(),
		insert: (row) => {
			const writer = new BinaryWriter(baseSize);
			AlgebraicType.serializeValue(writer, rowType, row, typespace);
			const ret_buf = sys.datastore_insert_bsatn(table_id, writer.getBuffer());
			const ret = { ...row };
			integrateGeneratedColumns?.(ret, ret_buf);
			return ret;
		},
		delete: (row) => {
			const writer = new BinaryWriter(4 + baseSize);
			writer.writeU32(1);
			AlgebraicType.serializeValue(writer, rowType, row, typespace);
			return sys.datastore_delete_all_by_eq_bsatn(table_id, writer.getBuffer()) > 0;
		}
	};
	const tableView = Object.assign(/* @__PURE__ */ Object.create(null), tableMethods);
	for (const indexDef of table2.indexes) {
		const index_id = sys.index_id_from_name(indexDef.name);
		let column_ids;
		switch (indexDef.algorithm.tag) {
			case "BTree":
				column_ids = indexDef.algorithm.value;
				break;
			case "Hash": throw new Error("impossible");
			case "Direct":
				column_ids = [indexDef.algorithm.value];
				break;
		}
		const numColumns = column_ids.length;
		const columnSet = new Set(column_ids);
		const isUnique = table2.constraints.filter((x) => x.data.tag === "Unique").some((x) => columnSet.isSubsetOf(new Set(x.data.value.columns)));
		const indexType = AlgebraicType.Product({ elements: column_ids.map((id) => rowType.value.elements[id]) });
		const baseSize2 = bsatnBaseSize(typespace, indexType);
		const serializePrefix = (writer, prefix, prefix_elems) => {
			if (prefix_elems > numColumns - 1) throw new TypeError("too many elements in prefix");
			for (let i = 0; i < prefix_elems; i++) {
				const elemType = indexType.value.elements[i].algebraicType;
				AlgebraicType.serializeValue(writer, elemType, prefix[i], typespace);
			}
			return writer;
		};
		let index;
		if (isUnique) {
			const serializeBound = (colVal) => {
				if (colVal.length !== numColumns) throw new TypeError("wrong number of elements");
				const writer = new BinaryWriter(baseSize2 + 1);
				const prefix_elems = numColumns - 1;
				serializePrefix(writer, colVal, prefix_elems);
				const rstartOffset = writer.offset;
				writer.writeU8(0);
				AlgebraicType.serializeValue(writer, indexType.value.elements[numColumns - 1].algebraicType, colVal[numColumns - 1], typespace);
				const buffer = writer.getBuffer();
				const prefix = buffer.slice(0, rstartOffset);
				const rstart = buffer.slice(rstartOffset);
				return [
					prefix,
					prefix_elems,
					rstart,
					rstart
				];
			};
			index = {
				find: (colVal) => {
					if (numColumns === 1) colVal = [colVal];
					const args = serializeBound(colVal);
					const iter2 = tableIterator(sys.datastore_index_scan_range_bsatn(index_id, ...args), rowType);
					const { value, done } = iter2.next();
					if (done) return null;
					if (!iter2.next().done) throw new Error("`datastore_index_scan_range_bsatn` on unique field cannot return >1 rows");
					return value;
				},
				delete: (colVal) => {
					if (numColumns === 1) colVal = [colVal];
					const args = serializeBound(colVal);
					return sys.datastore_delete_by_index_scan_range_bsatn(index_id, ...args) > 0;
				},
				update: (row) => {
					const writer = new BinaryWriter(baseSize2);
					AlgebraicType.serializeValue(writer, rowType, row, typespace);
					const ret_buf = sys.datastore_update_bsatn(table_id, index_id, writer.getBuffer());
					integrateGeneratedColumns?.(row, ret_buf);
					return row;
				}
			};
		} else {
			const serializeRange = (range) => {
				if (range.length > numColumns) throw new TypeError("too many elements");
				const writer = new BinaryWriter(baseSize2 + 1);
				const prefix_elems = range.length - 1;
				serializePrefix(writer, range, prefix_elems);
				const rstartOffset = writer.offset;
				const term = range[range.length - 1];
				const termType = indexType.value.elements[range.length - 1].algebraicType;
				let rstart, rend;
				if (term instanceof Range) {
					const writeBound = (bound) => {
						writer.writeU8({
							included: 0,
							excluded: 1,
							unbounded: 2
						}[bound.tag]);
						if (bound.tag !== "unbounded") AlgebraicType.serializeValue(writer, termType, bound.value, typespace);
					};
					writeBound(term.from);
					const rendOffset = writer.offset;
					writeBound(term.to);
					rstart = writer.getBuffer().slice(rstartOffset, rendOffset);
					rend = writer.getBuffer().slice(rendOffset);
				} else {
					writer.writeU8(0);
					AlgebraicType.serializeValue(writer, termType, term, typespace);
					rstart = rend = writer.getBuffer().slice(rstartOffset);
				}
				return [
					writer.getBuffer().slice(0, rstartOffset),
					prefix_elems,
					rstart,
					rend
				];
			};
			index = {
				filter: (range) => {
					if (numColumns === 1) range = [range];
					const args = serializeRange(range);
					return tableIterator(sys.datastore_index_scan_range_bsatn(index_id, ...args), rowType);
				},
				delete: (range) => {
					if (numColumns === 1) range = [range];
					const args = serializeRange(range);
					return sys.datastore_delete_by_index_scan_range_bsatn(index_id, ...args);
				}
			};
		}
		if (Object.hasOwn(tableView, indexDef.accessorName)) freeze3(Object.assign(tableView[indexDef.accessorName], index));
		else tableView[indexDef.accessorName] = freeze3(index);
	}
	return freeze3(tableView);
}
function hasOwn(o, k) {
	return Object.hasOwn(o, k);
}
function* tableIterator(id, ty) {
	var _stack = [];
	try {
		const iter = __using(_stack, new IteratorHandle(id));
		const { typespace } = MODULE_DEF;
		let buf;
		while ((buf = advanceIter(iter)) != null) {
			const reader = new BinaryReader(buf);
			while (reader.remaining > 0) yield AlgebraicType.deserializeValue(reader, ty, typespace);
		}
	} catch (_$1) {
		var _error = _$1, _hasError = true;
	} finally {
		__callDispose(_stack, _error, _hasError);
	}
}
function advanceIter(iter) {
	let buf_max_len = 65536;
	while (true) try {
		return iter.advance(buf_max_len);
	} catch (e) {
		if (e && typeof e === "object" && hasOwn(e, "__buffer_too_small__")) {
			buf_max_len = e.__buffer_too_small__;
			continue;
		}
		throw e;
	}
}
var IteratorHandle = class _IteratorHandle {
	#id;
	static #finalizationRegistry = new FinalizationRegistry(sys.row_iter_bsatn_close);
	constructor(id) {
		this.#id = id;
		_IteratorHandle.#finalizationRegistry.register(this, id, this);
	}
	/** Unregister this object with the finalization registry and return the id */
	#detach() {
		const id = this.#id;
		this.#id = -1;
		_IteratorHandle.#finalizationRegistry.unregister(this);
		return id;
	}
	/** Call `row_iter_bsatn_advance`, returning null if this iterator was already exhausted. */
	advance(buf_max_len) {
		if (this.#id === -1) return null;
		const { 0: done, 1: buf } = sys.row_iter_bsatn_advance(this.#id, buf_max_len);
		if (done) this.#detach();
		return buf;
	}
	[Symbol.dispose]() {
		if (this.#id >= 0) {
			const id = this.#detach();
			sys.row_iter_bsatn_close(id);
		}
	}
};
function wrapSyscalls(...modules) {
	return Object.fromEntries(modules.flatMap(Object.entries).map(([k, v]) => [k, wrapSyscall(v)]));
}
function wrapSyscall(func) {
	const name = func.name;
	return { [name](...args) {
		try {
			return func(...args);
		} catch (e) {
			if (e !== null && typeof e === "object" && hasOwn(e, "__code_error__") && typeof e.__code_error__ == "number") {
				const message = hasOwn(e, "__error_message__") && typeof e.__error_message__ === "string" ? e.__error_message__ : void 0;
				throw new SpacetimeHostError(e.__code_error__, message);
			}
			throw e;
		}
	} }[name];
}
function fmtLog(...data) {
	return data.join(" ");
}
var console_level_error = 0;
var console_level_warn = 1;
var console_level_info = 2;
var console_level_debug = 3;
var console_level_trace = 4;
var timerMap = /* @__PURE__ */ new Map();
var console2 = {
	__proto__: {},
	[Symbol.toStringTag]: "console",
	assert: (condition = false, ...data) => {
		if (!condition) sys.console_log(console_level_error, fmtLog(...data));
	},
	clear: () => {},
	debug: (...data) => {
		sys.console_log(console_level_debug, fmtLog(...data));
	},
	error: (...data) => {
		sys.console_log(console_level_error, fmtLog(...data));
	},
	info: (...data) => {
		sys.console_log(console_level_info, fmtLog(...data));
	},
	log: (...data) => {
		sys.console_log(console_level_info, fmtLog(...data));
	},
	table: (tabularData, _properties) => {
		sys.console_log(console_level_info, fmtLog(tabularData));
	},
	trace: (...data) => {
		sys.console_log(console_level_trace, fmtLog(...data));
	},
	warn: (...data) => {
		sys.console_log(console_level_warn, fmtLog(...data));
	},
	dir: (_item, _options) => {},
	dirxml: (..._data) => {},
	count: (_label = "default") => {},
	countReset: (_label = "default") => {},
	group: (..._data) => {},
	groupCollapsed: (..._data) => {},
	groupEnd: () => {},
	time: (label = "default") => {
		if (timerMap.has(label)) {
			sys.console_log(console_level_warn, `Timer '${label}' already exists.`);
			return;
		}
		timerMap.set(label, sys.console_timer_start(label));
	},
	timeLog: (label = "default", ...data) => {
		sys.console_log(console_level_info, fmtLog(label, ...data));
	},
	timeEnd: (label = "default") => {
		const spanId = timerMap.get(label);
		if (spanId === void 0) {
			sys.console_log(console_level_warn, `Timer '${label}' does not exist.`);
			return;
		}
		sys.console_timer_end(spanId);
		timerMap.delete(label);
	},
	timeStamp: () => {},
	profile: () => {},
	profileEnd: () => {}
};
console2.Console = console2;
globalThis.console = console2;
register_hooks(hooks);
register_hooks$1(hooks_v1_1);
register_hooks$2(hooks_v1_2);

//#endregion
//#region ../node_modules/ajv/dist/compile/codegen/code.js
var require_code$1 = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/compile/codegen/code.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;
	var _CodeOrName = class {};
	exports._CodeOrName = _CodeOrName;
	exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
	var Name = class extends _CodeOrName {
		constructor(s) {
			super();
			if (!exports.IDENTIFIER.test(s)) throw new Error("CodeGen: name must be a valid identifier");
			this.str = s;
		}
		toString() {
			return this.str;
		}
		emptyStr() {
			return false;
		}
		get names() {
			return { [this.str]: 1 };
		}
	};
	exports.Name = Name;
	var _Code = class extends _CodeOrName {
		constructor(code) {
			super();
			this._items = typeof code === "string" ? [code] : code;
		}
		toString() {
			return this.str;
		}
		emptyStr() {
			if (this._items.length > 1) return false;
			const item = this._items[0];
			return item === "" || item === "\"\"";
		}
		get str() {
			var _a$1;
			return (_a$1 = this._str) !== null && _a$1 !== void 0 ? _a$1 : this._str = this._items.reduce((s, c) => `${s}${c}`, "");
		}
		get names() {
			var _a$1;
			return (_a$1 = this._names) !== null && _a$1 !== void 0 ? _a$1 : this._names = this._items.reduce((names$1, c) => {
				if (c instanceof Name) names$1[c.str] = (names$1[c.str] || 0) + 1;
				return names$1;
			}, {});
		}
	};
	exports._Code = _Code;
	exports.nil = new _Code("");
	function _(strs, ...args) {
		const code = [strs[0]];
		let i = 0;
		while (i < args.length) {
			addCodeArg(code, args[i]);
			code.push(strs[++i]);
		}
		return new _Code(code);
	}
	exports._ = _;
	const plus = new _Code("+");
	function str(strs, ...args) {
		const expr = [safeStringify(strs[0])];
		let i = 0;
		while (i < args.length) {
			expr.push(plus);
			addCodeArg(expr, args[i]);
			expr.push(plus, safeStringify(strs[++i]));
		}
		optimize(expr);
		return new _Code(expr);
	}
	exports.str = str;
	function addCodeArg(code, arg) {
		if (arg instanceof _Code) code.push(...arg._items);
		else if (arg instanceof Name) code.push(arg);
		else code.push(interpolate(arg));
	}
	exports.addCodeArg = addCodeArg;
	function optimize(expr) {
		let i = 1;
		while (i < expr.length - 1) {
			if (expr[i] === plus) {
				const res = mergeExprItems(expr[i - 1], expr[i + 1]);
				if (res !== void 0) {
					expr.splice(i - 1, 3, res);
					continue;
				}
				expr[i++] = "+";
			}
			i++;
		}
	}
	function mergeExprItems(a, b) {
		if (b === "\"\"") return a;
		if (a === "\"\"") return b;
		if (typeof a == "string") {
			if (b instanceof Name || a[a.length - 1] !== "\"") return;
			if (typeof b != "string") return `${a.slice(0, -1)}${b}"`;
			if (b[0] === "\"") return a.slice(0, -1) + b.slice(1);
			return;
		}
		if (typeof b == "string" && b[0] === "\"" && !(a instanceof Name)) return `"${a}${b.slice(1)}`;
	}
	function strConcat(c1, c2) {
		return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
	}
	exports.strConcat = strConcat;
	function interpolate(x) {
		return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
	}
	function stringify(x) {
		return new _Code(safeStringify(x));
	}
	exports.stringify = stringify;
	function safeStringify(x) {
		return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
	}
	exports.safeStringify = safeStringify;
	function getProperty(key) {
		return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
	}
	exports.getProperty = getProperty;
	function getEsmExportName(key) {
		if (typeof key == "string" && exports.IDENTIFIER.test(key)) return new _Code(`${key}`);
		throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
	}
	exports.getEsmExportName = getEsmExportName;
	function regexpCode(rx) {
		return new _Code(rx.toString());
	}
	exports.regexpCode = regexpCode;
}) });

//#endregion
//#region ../node_modules/ajv/dist/compile/codegen/scope.js
var require_scope = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/compile/codegen/scope.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;
	const code_1$12 = require_code$1();
	var ValueError = class extends Error {
		constructor(name) {
			super(`CodeGen: "code" for ${name} not defined`);
			this.value = name.value;
		}
	};
	var UsedValueState;
	(function(UsedValueState$1) {
		UsedValueState$1[UsedValueState$1["Started"] = 0] = "Started";
		UsedValueState$1[UsedValueState$1["Completed"] = 1] = "Completed";
	})(UsedValueState || (exports.UsedValueState = UsedValueState = {}));
	exports.varKinds = {
		const: new code_1$12.Name("const"),
		let: new code_1$12.Name("let"),
		var: new code_1$12.Name("var")
	};
	var Scope = class {
		constructor({ prefixes, parent } = {}) {
			this._names = {};
			this._prefixes = prefixes;
			this._parent = parent;
		}
		toName(nameOrPrefix) {
			return nameOrPrefix instanceof code_1$12.Name ? nameOrPrefix : this.name(nameOrPrefix);
		}
		name(prefix) {
			return new code_1$12.Name(this._newName(prefix));
		}
		_newName(prefix) {
			const ng = this._names[prefix] || this._nameGroup(prefix);
			return `${prefix}${ng.index++}`;
		}
		_nameGroup(prefix) {
			var _a$1, _b$1;
			if (((_b$1 = (_a$1 = this._parent) === null || _a$1 === void 0 ? void 0 : _a$1._prefixes) === null || _b$1 === void 0 ? void 0 : _b$1.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
			return this._names[prefix] = {
				prefix,
				index: 0
			};
		}
	};
	exports.Scope = Scope;
	var ValueScopeName = class extends code_1$12.Name {
		constructor(prefix, nameStr) {
			super(nameStr);
			this.prefix = prefix;
		}
		setValue(value, { property, itemIndex }) {
			this.value = value;
			this.scopePath = (0, code_1$12._)`.${new code_1$12.Name(property)}[${itemIndex}]`;
		}
	};
	exports.ValueScopeName = ValueScopeName;
	const line = (0, code_1$12._)`\n`;
	var ValueScope = class extends Scope {
		constructor(opts) {
			super(opts);
			this._values = {};
			this._scope = opts.scope;
			this.opts = {
				...opts,
				_n: opts.lines ? line : code_1$12.nil
			};
		}
		get() {
			return this._scope;
		}
		name(prefix) {
			return new ValueScopeName(prefix, this._newName(prefix));
		}
		value(nameOrPrefix, value) {
			var _a$1;
			if (value.ref === void 0) throw new Error("CodeGen: ref must be passed in value");
			const name = this.toName(nameOrPrefix);
			const { prefix } = name;
			const valueKey = (_a$1 = value.key) !== null && _a$1 !== void 0 ? _a$1 : value.ref;
			let vs = this._values[prefix];
			if (vs) {
				const _name = vs.get(valueKey);
				if (_name) return _name;
			} else vs = this._values[prefix] = /* @__PURE__ */ new Map();
			vs.set(valueKey, name);
			const s = this._scope[prefix] || (this._scope[prefix] = []);
			const itemIndex = s.length;
			s[itemIndex] = value.ref;
			name.setValue(value, {
				property: prefix,
				itemIndex
			});
			return name;
		}
		getValue(prefix, keyOrRef) {
			const vs = this._values[prefix];
			if (!vs) return;
			return vs.get(keyOrRef);
		}
		scopeRefs(scopeName, values = this._values) {
			return this._reduceValues(values, (name) => {
				if (name.scopePath === void 0) throw new Error(`CodeGen: name "${name}" has no value`);
				return (0, code_1$12._)`${scopeName}${name.scopePath}`;
			});
		}
		scopeCode(values = this._values, usedValues, getCode) {
			return this._reduceValues(values, (name) => {
				if (name.value === void 0) throw new Error(`CodeGen: name "${name}" has no value`);
				return name.value.code;
			}, usedValues, getCode);
		}
		_reduceValues(values, valueCode, usedValues = {}, getCode) {
			let code = code_1$12.nil;
			for (const prefix in values) {
				const vs = values[prefix];
				if (!vs) continue;
				const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
				vs.forEach((name) => {
					if (nameSet.has(name)) return;
					nameSet.set(name, UsedValueState.Started);
					let c = valueCode(name);
					if (c) {
						const def$30 = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
						code = (0, code_1$12._)`${code}${def$30} ${name} = ${c};${this.opts._n}`;
					} else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) code = (0, code_1$12._)`${code}${c}${this.opts._n}`;
					else throw new ValueError(name);
					nameSet.set(name, UsedValueState.Completed);
				});
			}
			return code;
		}
	};
	exports.ValueScope = ValueScope;
}) });

//#endregion
//#region ../node_modules/ajv/dist/compile/codegen/index.js
var require_codegen = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/compile/codegen/index.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;
	const code_1$11 = require_code$1();
	const scope_1 = require_scope();
	var code_2 = require_code$1();
	Object.defineProperty(exports, "_", {
		enumerable: true,
		get: function() {
			return code_2._;
		}
	});
	Object.defineProperty(exports, "str", {
		enumerable: true,
		get: function() {
			return code_2.str;
		}
	});
	Object.defineProperty(exports, "strConcat", {
		enumerable: true,
		get: function() {
			return code_2.strConcat;
		}
	});
	Object.defineProperty(exports, "nil", {
		enumerable: true,
		get: function() {
			return code_2.nil;
		}
	});
	Object.defineProperty(exports, "getProperty", {
		enumerable: true,
		get: function() {
			return code_2.getProperty;
		}
	});
	Object.defineProperty(exports, "stringify", {
		enumerable: true,
		get: function() {
			return code_2.stringify;
		}
	});
	Object.defineProperty(exports, "regexpCode", {
		enumerable: true,
		get: function() {
			return code_2.regexpCode;
		}
	});
	Object.defineProperty(exports, "Name", {
		enumerable: true,
		get: function() {
			return code_2.Name;
		}
	});
	var scope_2 = require_scope();
	Object.defineProperty(exports, "Scope", {
		enumerable: true,
		get: function() {
			return scope_2.Scope;
		}
	});
	Object.defineProperty(exports, "ValueScope", {
		enumerable: true,
		get: function() {
			return scope_2.ValueScope;
		}
	});
	Object.defineProperty(exports, "ValueScopeName", {
		enumerable: true,
		get: function() {
			return scope_2.ValueScopeName;
		}
	});
	Object.defineProperty(exports, "varKinds", {
		enumerable: true,
		get: function() {
			return scope_2.varKinds;
		}
	});
	exports.operators = {
		GT: new code_1$11._Code(">"),
		GTE: new code_1$11._Code(">="),
		LT: new code_1$11._Code("<"),
		LTE: new code_1$11._Code("<="),
		EQ: new code_1$11._Code("==="),
		NEQ: new code_1$11._Code("!=="),
		NOT: new code_1$11._Code("!"),
		OR: new code_1$11._Code("||"),
		AND: new code_1$11._Code("&&"),
		ADD: new code_1$11._Code("+")
	};
	var Node = class {
		optimizeNodes() {
			return this;
		}
		optimizeNames(_names, _constants) {
			return this;
		}
	};
	var Def = class extends Node {
		constructor(varKind, name, rhs) {
			super();
			this.varKind = varKind;
			this.name = name;
			this.rhs = rhs;
		}
		render({ es5, _n }) {
			const varKind = es5 ? scope_1.varKinds.var : this.varKind;
			const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
			return `${varKind} ${this.name}${rhs};` + _n;
		}
		optimizeNames(names$1, constants) {
			if (!names$1[this.name.str]) return;
			if (this.rhs) this.rhs = optimizeExpr(this.rhs, names$1, constants);
			return this;
		}
		get names() {
			return this.rhs instanceof code_1$11._CodeOrName ? this.rhs.names : {};
		}
	};
	var Assign = class extends Node {
		constructor(lhs, rhs, sideEffects) {
			super();
			this.lhs = lhs;
			this.rhs = rhs;
			this.sideEffects = sideEffects;
		}
		render({ _n }) {
			return `${this.lhs} = ${this.rhs};` + _n;
		}
		optimizeNames(names$1, constants) {
			if (this.lhs instanceof code_1$11.Name && !names$1[this.lhs.str] && !this.sideEffects) return;
			this.rhs = optimizeExpr(this.rhs, names$1, constants);
			return this;
		}
		get names() {
			return addExprNames(this.lhs instanceof code_1$11.Name ? {} : { ...this.lhs.names }, this.rhs);
		}
	};
	var AssignOp = class extends Assign {
		constructor(lhs, op, rhs, sideEffects) {
			super(lhs, rhs, sideEffects);
			this.op = op;
		}
		render({ _n }) {
			return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
		}
	};
	var Label = class extends Node {
		constructor(label) {
			super();
			this.label = label;
			this.names = {};
		}
		render({ _n }) {
			return `${this.label}:` + _n;
		}
	};
	var Break = class extends Node {
		constructor(label) {
			super();
			this.label = label;
			this.names = {};
		}
		render({ _n }) {
			return `break${this.label ? ` ${this.label}` : ""};` + _n;
		}
	};
	var Throw = class extends Node {
		constructor(error) {
			super();
			this.error = error;
		}
		render({ _n }) {
			return `throw ${this.error};` + _n;
		}
		get names() {
			return this.error.names;
		}
	};
	var AnyCode = class extends Node {
		constructor(code) {
			super();
			this.code = code;
		}
		render({ _n }) {
			return `${this.code};` + _n;
		}
		optimizeNodes() {
			return `${this.code}` ? this : void 0;
		}
		optimizeNames(names$1, constants) {
			this.code = optimizeExpr(this.code, names$1, constants);
			return this;
		}
		get names() {
			return this.code instanceof code_1$11._CodeOrName ? this.code.names : {};
		}
	};
	var ParentNode = class extends Node {
		constructor(nodes = []) {
			super();
			this.nodes = nodes;
		}
		render(opts) {
			return this.nodes.reduce((code, n) => code + n.render(opts), "");
		}
		optimizeNodes() {
			const { nodes } = this;
			let i = nodes.length;
			while (i--) {
				const n = nodes[i].optimizeNodes();
				if (Array.isArray(n)) nodes.splice(i, 1, ...n);
				else if (n) nodes[i] = n;
				else nodes.splice(i, 1);
			}
			return nodes.length > 0 ? this : void 0;
		}
		optimizeNames(names$1, constants) {
			const { nodes } = this;
			let i = nodes.length;
			while (i--) {
				const n = nodes[i];
				if (n.optimizeNames(names$1, constants)) continue;
				subtractNames(names$1, n.names);
				nodes.splice(i, 1);
			}
			return nodes.length > 0 ? this : void 0;
		}
		get names() {
			return this.nodes.reduce((names$1, n) => addNames(names$1, n.names), {});
		}
	};
	var BlockNode = class extends ParentNode {
		render(opts) {
			return "{" + opts._n + super.render(opts) + "}" + opts._n;
		}
	};
	var Root = class extends ParentNode {};
	var Else = class extends BlockNode {};
	Else.kind = "else";
	var If = class If extends BlockNode {
		constructor(condition, nodes) {
			super(nodes);
			this.condition = condition;
		}
		render(opts) {
			let code = `if(${this.condition})` + super.render(opts);
			if (this.else) code += "else " + this.else.render(opts);
			return code;
		}
		optimizeNodes() {
			super.optimizeNodes();
			const cond = this.condition;
			if (cond === true) return this.nodes;
			let e = this.else;
			if (e) {
				const ns = e.optimizeNodes();
				e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
			}
			if (e) {
				if (cond === false) return e instanceof If ? e : e.nodes;
				if (this.nodes.length) return this;
				return new If(not(cond), e instanceof If ? [e] : e.nodes);
			}
			if (cond === false || !this.nodes.length) return void 0;
			return this;
		}
		optimizeNames(names$1, constants) {
			var _a$1;
			this.else = (_a$1 = this.else) === null || _a$1 === void 0 ? void 0 : _a$1.optimizeNames(names$1, constants);
			if (!(super.optimizeNames(names$1, constants) || this.else)) return;
			this.condition = optimizeExpr(this.condition, names$1, constants);
			return this;
		}
		get names() {
			const names$1 = super.names;
			addExprNames(names$1, this.condition);
			if (this.else) addNames(names$1, this.else.names);
			return names$1;
		}
	};
	If.kind = "if";
	var For = class extends BlockNode {};
	For.kind = "for";
	var ForLoop = class extends For {
		constructor(iteration) {
			super();
			this.iteration = iteration;
		}
		render(opts) {
			return `for(${this.iteration})` + super.render(opts);
		}
		optimizeNames(names$1, constants) {
			if (!super.optimizeNames(names$1, constants)) return;
			this.iteration = optimizeExpr(this.iteration, names$1, constants);
			return this;
		}
		get names() {
			return addNames(super.names, this.iteration.names);
		}
	};
	var ForRange = class extends For {
		constructor(varKind, name, from, to) {
			super();
			this.varKind = varKind;
			this.name = name;
			this.from = from;
			this.to = to;
		}
		render(opts) {
			const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
			const { name, from, to } = this;
			return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
		}
		get names() {
			return addExprNames(addExprNames(super.names, this.from), this.to);
		}
	};
	var ForIter = class extends For {
		constructor(loop, varKind, name, iterable) {
			super();
			this.loop = loop;
			this.varKind = varKind;
			this.name = name;
			this.iterable = iterable;
		}
		render(opts) {
			return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
		}
		optimizeNames(names$1, constants) {
			if (!super.optimizeNames(names$1, constants)) return;
			this.iterable = optimizeExpr(this.iterable, names$1, constants);
			return this;
		}
		get names() {
			return addNames(super.names, this.iterable.names);
		}
	};
	var Func = class extends BlockNode {
		constructor(name, args, async) {
			super();
			this.name = name;
			this.args = args;
			this.async = async;
		}
		render(opts) {
			return `${this.async ? "async " : ""}function ${this.name}(${this.args})` + super.render(opts);
		}
	};
	Func.kind = "func";
	var Return = class extends ParentNode {
		render(opts) {
			return "return " + super.render(opts);
		}
	};
	Return.kind = "return";
	var Try = class extends BlockNode {
		render(opts) {
			let code = "try" + super.render(opts);
			if (this.catch) code += this.catch.render(opts);
			if (this.finally) code += this.finally.render(opts);
			return code;
		}
		optimizeNodes() {
			var _a$1, _b$1;
			super.optimizeNodes();
			(_a$1 = this.catch) === null || _a$1 === void 0 || _a$1.optimizeNodes();
			(_b$1 = this.finally) === null || _b$1 === void 0 || _b$1.optimizeNodes();
			return this;
		}
		optimizeNames(names$1, constants) {
			var _a$1, _b$1;
			super.optimizeNames(names$1, constants);
			(_a$1 = this.catch) === null || _a$1 === void 0 || _a$1.optimizeNames(names$1, constants);
			(_b$1 = this.finally) === null || _b$1 === void 0 || _b$1.optimizeNames(names$1, constants);
			return this;
		}
		get names() {
			const names$1 = super.names;
			if (this.catch) addNames(names$1, this.catch.names);
			if (this.finally) addNames(names$1, this.finally.names);
			return names$1;
		}
	};
	var Catch = class extends BlockNode {
		constructor(error) {
			super();
			this.error = error;
		}
		render(opts) {
			return `catch(${this.error})` + super.render(opts);
		}
	};
	Catch.kind = "catch";
	var Finally = class extends BlockNode {
		render(opts) {
			return "finally" + super.render(opts);
		}
	};
	Finally.kind = "finally";
	var CodeGen = class {
		constructor(extScope, opts = {}) {
			this._values = {};
			this._blockStarts = [];
			this._constants = {};
			this.opts = {
				...opts,
				_n: opts.lines ? "\n" : ""
			};
			this._extScope = extScope;
			this._scope = new scope_1.Scope({ parent: extScope });
			this._nodes = [new Root()];
		}
		toString() {
			return this._root.render(this.opts);
		}
		name(prefix) {
			return this._scope.name(prefix);
		}
		scopeName(prefix) {
			return this._extScope.name(prefix);
		}
		scopeValue(prefixOrName, value) {
			const name = this._extScope.value(prefixOrName, value);
			(this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set())).add(name);
			return name;
		}
		getScopeValue(prefix, keyOrRef) {
			return this._extScope.getValue(prefix, keyOrRef);
		}
		scopeRefs(scopeName) {
			return this._extScope.scopeRefs(scopeName, this._values);
		}
		scopeCode() {
			return this._extScope.scopeCode(this._values);
		}
		_def(varKind, nameOrPrefix, rhs, constant) {
			const name = this._scope.toName(nameOrPrefix);
			if (rhs !== void 0 && constant) this._constants[name.str] = rhs;
			this._leafNode(new Def(varKind, name, rhs));
			return name;
		}
		const(nameOrPrefix, rhs, _constant) {
			return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
		}
		let(nameOrPrefix, rhs, _constant) {
			return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
		}
		var(nameOrPrefix, rhs, _constant) {
			return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
		}
		assign(lhs, rhs, sideEffects) {
			return this._leafNode(new Assign(lhs, rhs, sideEffects));
		}
		add(lhs, rhs) {
			return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
		}
		code(c) {
			if (typeof c == "function") c();
			else if (c !== code_1$11.nil) this._leafNode(new AnyCode(c));
			return this;
		}
		object(...keyValues) {
			const code = ["{"];
			for (const [key, value] of keyValues) {
				if (code.length > 1) code.push(",");
				code.push(key);
				if (key !== value || this.opts.es5) {
					code.push(":");
					(0, code_1$11.addCodeArg)(code, value);
				}
			}
			code.push("}");
			return new code_1$11._Code(code);
		}
		if(condition, thenBody, elseBody) {
			this._blockNode(new If(condition));
			if (thenBody && elseBody) this.code(thenBody).else().code(elseBody).endIf();
			else if (thenBody) this.code(thenBody).endIf();
			else if (elseBody) throw new Error("CodeGen: \"else\" body without \"then\" body");
			return this;
		}
		elseIf(condition) {
			return this._elseNode(new If(condition));
		}
		else() {
			return this._elseNode(new Else());
		}
		endIf() {
			return this._endBlockNode(If, Else);
		}
		_for(node, forBody) {
			this._blockNode(node);
			if (forBody) this.code(forBody).endFor();
			return this;
		}
		for(iteration, forBody) {
			return this._for(new ForLoop(iteration), forBody);
		}
		forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
			const name = this._scope.toName(nameOrPrefix);
			return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
		}
		forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
			const name = this._scope.toName(nameOrPrefix);
			if (this.opts.es5) {
				const arr = iterable instanceof code_1$11.Name ? iterable : this.var("_arr", iterable);
				return this.forRange("_i", 0, (0, code_1$11._)`${arr}.length`, (i) => {
					this.var(name, (0, code_1$11._)`${arr}[${i}]`);
					forBody(name);
				});
			}
			return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
		}
		forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
			if (this.opts.ownProperties) return this.forOf(nameOrPrefix, (0, code_1$11._)`Object.keys(${obj})`, forBody);
			const name = this._scope.toName(nameOrPrefix);
			return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
		}
		endFor() {
			return this._endBlockNode(For);
		}
		label(label) {
			return this._leafNode(new Label(label));
		}
		break(label) {
			return this._leafNode(new Break(label));
		}
		return(value) {
			const node = new Return();
			this._blockNode(node);
			this.code(value);
			if (node.nodes.length !== 1) throw new Error("CodeGen: \"return\" should have one node");
			return this._endBlockNode(Return);
		}
		try(tryBody, catchCode, finallyCode) {
			if (!catchCode && !finallyCode) throw new Error("CodeGen: \"try\" without \"catch\" and \"finally\"");
			const node = new Try();
			this._blockNode(node);
			this.code(tryBody);
			if (catchCode) {
				const error = this.name("e");
				this._currNode = node.catch = new Catch(error);
				catchCode(error);
			}
			if (finallyCode) {
				this._currNode = node.finally = new Finally();
				this.code(finallyCode);
			}
			return this._endBlockNode(Catch, Finally);
		}
		throw(error) {
			return this._leafNode(new Throw(error));
		}
		block(body, nodeCount) {
			this._blockStarts.push(this._nodes.length);
			if (body) this.code(body).endBlock(nodeCount);
			return this;
		}
		endBlock(nodeCount) {
			const len = this._blockStarts.pop();
			if (len === void 0) throw new Error("CodeGen: not in self-balancing block");
			const toClose = this._nodes.length - len;
			if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
			this._nodes.length = len;
			return this;
		}
		func(name, args = code_1$11.nil, async, funcBody) {
			this._blockNode(new Func(name, args, async));
			if (funcBody) this.code(funcBody).endFunc();
			return this;
		}
		endFunc() {
			return this._endBlockNode(Func);
		}
		optimize(n = 1) {
			while (n-- > 0) {
				this._root.optimizeNodes();
				this._root.optimizeNames(this._root.names, this._constants);
			}
		}
		_leafNode(node) {
			this._currNode.nodes.push(node);
			return this;
		}
		_blockNode(node) {
			this._currNode.nodes.push(node);
			this._nodes.push(node);
		}
		_endBlockNode(N1, N2) {
			const n = this._currNode;
			if (n instanceof N1 || N2 && n instanceof N2) {
				this._nodes.pop();
				return this;
			}
			throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
		}
		_elseNode(node) {
			const n = this._currNode;
			if (!(n instanceof If)) throw new Error("CodeGen: \"else\" without \"if\"");
			this._currNode = n.else = node;
			return this;
		}
		get _root() {
			return this._nodes[0];
		}
		get _currNode() {
			const ns = this._nodes;
			return ns[ns.length - 1];
		}
		set _currNode(node) {
			const ns = this._nodes;
			ns[ns.length - 1] = node;
		}
	};
	exports.CodeGen = CodeGen;
	function addNames(names$1, from) {
		for (const n in from) names$1[n] = (names$1[n] || 0) + (from[n] || 0);
		return names$1;
	}
	function addExprNames(names$1, from) {
		return from instanceof code_1$11._CodeOrName ? addNames(names$1, from.names) : names$1;
	}
	function optimizeExpr(expr, names$1, constants) {
		if (expr instanceof code_1$11.Name) return replaceName(expr);
		if (!canOptimize(expr)) return expr;
		return new code_1$11._Code(expr._items.reduce((items, c) => {
			if (c instanceof code_1$11.Name) c = replaceName(c);
			if (c instanceof code_1$11._Code) items.push(...c._items);
			else items.push(c);
			return items;
		}, []));
		function replaceName(n) {
			const c = constants[n.str];
			if (c === void 0 || names$1[n.str] !== 1) return n;
			delete names$1[n.str];
			return c;
		}
		function canOptimize(e) {
			return e instanceof code_1$11._Code && e._items.some((c) => c instanceof code_1$11.Name && names$1[c.str] === 1 && constants[c.str] !== void 0);
		}
	}
	function subtractNames(names$1, from) {
		for (const n in from) names$1[n] = (names$1[n] || 0) - (from[n] || 0);
	}
	function not(x) {
		return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1$11._)`!${par(x)}`;
	}
	exports.not = not;
	const andCode = mappend(exports.operators.AND);
	function and(...args) {
		return args.reduce(andCode);
	}
	exports.and = and;
	const orCode = mappend(exports.operators.OR);
	function or(...args) {
		return args.reduce(orCode);
	}
	exports.or = or;
	function mappend(op) {
		return (x, y) => x === code_1$11.nil ? y : y === code_1$11.nil ? x : (0, code_1$11._)`${par(x)} ${op} ${par(y)}`;
	}
	function par(x) {
		return x instanceof code_1$11.Name ? x : (0, code_1$11._)`(${x})`;
	}
}) });

//#endregion
//#region ../node_modules/ajv/dist/compile/util.js
var require_util = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/compile/util.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$35 = require_codegen();
	const code_1$10 = require_code$1();
	function toHash(arr) {
		const hash = {};
		for (const item of arr) hash[item] = true;
		return hash;
	}
	exports.toHash = toHash;
	function alwaysValidSchema(it, schema$1) {
		if (typeof schema$1 == "boolean") return schema$1;
		if (Object.keys(schema$1).length === 0) return true;
		checkUnknownRules(it, schema$1);
		return !schemaHasRules(schema$1, it.self.RULES.all);
	}
	exports.alwaysValidSchema = alwaysValidSchema;
	function checkUnknownRules(it, schema$1 = it.schema) {
		const { opts, self } = it;
		if (!opts.strictSchema) return;
		if (typeof schema$1 === "boolean") return;
		const rules = self.RULES.keywords;
		for (const key in schema$1) if (!rules[key]) checkStrictMode(it, `unknown keyword: "${key}"`);
	}
	exports.checkUnknownRules = checkUnknownRules;
	function schemaHasRules(schema$1, rules) {
		if (typeof schema$1 == "boolean") return !schema$1;
		for (const key in schema$1) if (rules[key]) return true;
		return false;
	}
	exports.schemaHasRules = schemaHasRules;
	function schemaHasRulesButRef(schema$1, RULES) {
		if (typeof schema$1 == "boolean") return !schema$1;
		for (const key in schema$1) if (key !== "$ref" && RULES.all[key]) return true;
		return false;
	}
	exports.schemaHasRulesButRef = schemaHasRulesButRef;
	function schemaRefOrVal({ topSchemaRef, schemaPath }, schema$1, keyword, $data) {
		if (!$data) {
			if (typeof schema$1 == "number" || typeof schema$1 == "boolean") return schema$1;
			if (typeof schema$1 == "string") return (0, codegen_1$35._)`${schema$1}`;
		}
		return (0, codegen_1$35._)`${topSchemaRef}${schemaPath}${(0, codegen_1$35.getProperty)(keyword)}`;
	}
	exports.schemaRefOrVal = schemaRefOrVal;
	function unescapeFragment(str$1) {
		return unescapeJsonPointer(decodeURIComponent(str$1));
	}
	exports.unescapeFragment = unescapeFragment;
	function escapeFragment(str$1) {
		return encodeURIComponent(escapeJsonPointer(str$1));
	}
	exports.escapeFragment = escapeFragment;
	function escapeJsonPointer(str$1) {
		if (typeof str$1 == "number") return `${str$1}`;
		return str$1.replace(/~/g, "~0").replace(/\//g, "~1");
	}
	exports.escapeJsonPointer = escapeJsonPointer;
	function unescapeJsonPointer(str$1) {
		return str$1.replace(/~1/g, "/").replace(/~0/g, "~");
	}
	exports.unescapeJsonPointer = unescapeJsonPointer;
	function eachItem(xs, f) {
		if (Array.isArray(xs)) for (const x of xs) f(x);
		else f(xs);
	}
	exports.eachItem = eachItem;
	function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName }) {
		return (gen, from, to, toName) => {
			const res = to === void 0 ? from : to instanceof codegen_1$35.Name ? (from instanceof codegen_1$35.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1$35.Name ? (mergeToName(gen, to, from), from) : mergeValues(from, to);
			return toName === codegen_1$35.Name && !(res instanceof codegen_1$35.Name) ? resultToName(gen, res) : res;
		};
	}
	exports.mergeEvaluated = {
		props: makeMergeEvaluated({
			mergeNames: (gen, from, to) => gen.if((0, codegen_1$35._)`${to} !== true && ${from} !== undefined`, () => {
				gen.if((0, codegen_1$35._)`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1$35._)`${to} || {}`).code((0, codegen_1$35._)`Object.assign(${to}, ${from})`));
			}),
			mergeToName: (gen, from, to) => gen.if((0, codegen_1$35._)`${to} !== true`, () => {
				if (from === true) gen.assign(to, true);
				else {
					gen.assign(to, (0, codegen_1$35._)`${to} || {}`);
					setEvaluated(gen, to, from);
				}
			}),
			mergeValues: (from, to) => from === true ? true : {
				...from,
				...to
			},
			resultToName: evaluatedPropsToName
		}),
		items: makeMergeEvaluated({
			mergeNames: (gen, from, to) => gen.if((0, codegen_1$35._)`${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1$35._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
			mergeToName: (gen, from, to) => gen.if((0, codegen_1$35._)`${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1$35._)`${to} > ${from} ? ${to} : ${from}`)),
			mergeValues: (from, to) => from === true ? true : Math.max(from, to),
			resultToName: (gen, items) => gen.var("items", items)
		})
	};
	function evaluatedPropsToName(gen, ps) {
		if (ps === true) return gen.var("props", true);
		const props = gen.var("props", (0, codegen_1$35._)`{}`);
		if (ps !== void 0) setEvaluated(gen, props, ps);
		return props;
	}
	exports.evaluatedPropsToName = evaluatedPropsToName;
	function setEvaluated(gen, props, ps) {
		Object.keys(ps).forEach((p) => gen.assign((0, codegen_1$35._)`${props}${(0, codegen_1$35.getProperty)(p)}`, true));
	}
	exports.setEvaluated = setEvaluated;
	const snippets = {};
	function useFunc(gen, f) {
		return gen.scopeValue("func", {
			ref: f,
			code: snippets[f.code] || (snippets[f.code] = new code_1$10._Code(f.code))
		});
	}
	exports.useFunc = useFunc;
	var Type;
	(function(Type$1) {
		Type$1[Type$1["Num"] = 0] = "Num";
		Type$1[Type$1["Str"] = 1] = "Str";
	})(Type || (exports.Type = Type = {}));
	function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
		if (dataProp instanceof codegen_1$35.Name) {
			const isNumber = dataPropType === Type.Num;
			return jsPropertySyntax ? isNumber ? (0, codegen_1$35._)`"[" + ${dataProp} + "]"` : (0, codegen_1$35._)`"['" + ${dataProp} + "']"` : isNumber ? (0, codegen_1$35._)`"/" + ${dataProp}` : (0, codegen_1$35._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
		}
		return jsPropertySyntax ? (0, codegen_1$35.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
	}
	exports.getErrorPath = getErrorPath;
	function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
		if (!mode) return;
		msg = `strict mode: ${msg}`;
		if (mode === true) throw new Error(msg);
		it.self.logger.warn(msg);
	}
	exports.checkStrictMode = checkStrictMode;
}) });

//#endregion
//#region ../node_modules/ajv/dist/compile/names.js
var require_names = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/compile/names.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$34 = require_codegen();
	const names = {
		data: new codegen_1$34.Name("data"),
		valCxt: new codegen_1$34.Name("valCxt"),
		instancePath: new codegen_1$34.Name("instancePath"),
		parentData: new codegen_1$34.Name("parentData"),
		parentDataProperty: new codegen_1$34.Name("parentDataProperty"),
		rootData: new codegen_1$34.Name("rootData"),
		dynamicAnchors: new codegen_1$34.Name("dynamicAnchors"),
		vErrors: new codegen_1$34.Name("vErrors"),
		errors: new codegen_1$34.Name("errors"),
		this: new codegen_1$34.Name("this"),
		self: new codegen_1$34.Name("self"),
		scope: new codegen_1$34.Name("scope"),
		json: new codegen_1$34.Name("json"),
		jsonPos: new codegen_1$34.Name("jsonPos"),
		jsonLen: new codegen_1$34.Name("jsonLen"),
		jsonPart: new codegen_1$34.Name("jsonPart")
	};
	exports.default = names;
}) });

//#endregion
//#region ../node_modules/ajv/dist/compile/errors.js
var require_errors = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/compile/errors.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;
	const codegen_1$33 = require_codegen();
	const util_1$29 = require_util();
	const names_1$7 = require_names();
	exports.keywordError = { message: ({ keyword }) => (0, codegen_1$33.str)`must pass "${keyword}" keyword validation` };
	exports.keyword$DataError = { message: ({ keyword, schemaType }) => schemaType ? (0, codegen_1$33.str)`"${keyword}" keyword must be ${schemaType} ($data)` : (0, codegen_1$33.str)`"${keyword}" keyword is invalid ($data)` };
	function reportError(cxt, error = exports.keywordError, errorPaths, overrideAllErrors) {
		const { it } = cxt;
		const { gen, compositeRule, allErrors } = it;
		const errObj = errorObjectCode(cxt, error, errorPaths);
		if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) addError(gen, errObj);
		else returnErrors(it, (0, codegen_1$33._)`[${errObj}]`);
	}
	exports.reportError = reportError;
	function reportExtraError(cxt, error = exports.keywordError, errorPaths) {
		const { it } = cxt;
		const { gen, compositeRule, allErrors } = it;
		addError(gen, errorObjectCode(cxt, error, errorPaths));
		if (!(compositeRule || allErrors)) returnErrors(it, names_1$7.default.vErrors);
	}
	exports.reportExtraError = reportExtraError;
	function resetErrorsCount(gen, errsCount) {
		gen.assign(names_1$7.default.errors, errsCount);
		gen.if((0, codegen_1$33._)`${names_1$7.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1$33._)`${names_1$7.default.vErrors}.length`, errsCount), () => gen.assign(names_1$7.default.vErrors, null)));
	}
	exports.resetErrorsCount = resetErrorsCount;
	function extendErrors({ gen, keyword, schemaValue, data, errsCount, it }) {
		/* istanbul ignore if */
		if (errsCount === void 0) throw new Error("ajv implementation error");
		const err = gen.name("err");
		gen.forRange("i", errsCount, names_1$7.default.errors, (i) => {
			gen.const(err, (0, codegen_1$33._)`${names_1$7.default.vErrors}[${i}]`);
			gen.if((0, codegen_1$33._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_1$33._)`${err}.instancePath`, (0, codegen_1$33.strConcat)(names_1$7.default.instancePath, it.errorPath)));
			gen.assign((0, codegen_1$33._)`${err}.schemaPath`, (0, codegen_1$33.str)`${it.errSchemaPath}/${keyword}`);
			if (it.opts.verbose) {
				gen.assign((0, codegen_1$33._)`${err}.schema`, schemaValue);
				gen.assign((0, codegen_1$33._)`${err}.data`, data);
			}
		});
	}
	exports.extendErrors = extendErrors;
	function addError(gen, errObj) {
		const err = gen.const("err", errObj);
		gen.if((0, codegen_1$33._)`${names_1$7.default.vErrors} === null`, () => gen.assign(names_1$7.default.vErrors, (0, codegen_1$33._)`[${err}]`), (0, codegen_1$33._)`${names_1$7.default.vErrors}.push(${err})`);
		gen.code((0, codegen_1$33._)`${names_1$7.default.errors}++`);
	}
	function returnErrors(it, errs) {
		const { gen, validateName, schemaEnv } = it;
		if (schemaEnv.$async) gen.throw((0, codegen_1$33._)`new ${it.ValidationError}(${errs})`);
		else {
			gen.assign((0, codegen_1$33._)`${validateName}.errors`, errs);
			gen.return(false);
		}
	}
	const E = {
		keyword: new codegen_1$33.Name("keyword"),
		schemaPath: new codegen_1$33.Name("schemaPath"),
		params: new codegen_1$33.Name("params"),
		propertyName: new codegen_1$33.Name("propertyName"),
		message: new codegen_1$33.Name("message"),
		schema: new codegen_1$33.Name("schema"),
		parentSchema: new codegen_1$33.Name("parentSchema")
	};
	function errorObjectCode(cxt, error, errorPaths) {
		const { createErrors } = cxt.it;
		if (createErrors === false) return (0, codegen_1$33._)`{}`;
		return errorObject(cxt, error, errorPaths);
	}
	function errorObject(cxt, error, errorPaths = {}) {
		const { gen, it } = cxt;
		const keyValues = [errorInstancePath(it, errorPaths), errorSchemaPath(cxt, errorPaths)];
		extraErrorProps(cxt, error, keyValues);
		return gen.object(...keyValues);
	}
	function errorInstancePath({ errorPath }, { instancePath }) {
		const instPath = instancePath ? (0, codegen_1$33.str)`${errorPath}${(0, util_1$29.getErrorPath)(instancePath, util_1$29.Type.Str)}` : errorPath;
		return [names_1$7.default.instancePath, (0, codegen_1$33.strConcat)(names_1$7.default.instancePath, instPath)];
	}
	function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
		let schPath = parentSchema ? errSchemaPath : (0, codegen_1$33.str)`${errSchemaPath}/${keyword}`;
		if (schemaPath) schPath = (0, codegen_1$33.str)`${schPath}${(0, util_1$29.getErrorPath)(schemaPath, util_1$29.Type.Str)}`;
		return [E.schemaPath, schPath];
	}
	function extraErrorProps(cxt, { params, message }, keyValues) {
		const { keyword, data, schemaValue, it } = cxt;
		const { opts, propertyName, topSchemaRef, schemaPath } = it;
		keyValues.push([E.keyword, keyword], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1$33._)`{}`]);
		if (opts.messages) keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
		if (opts.verbose) keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1$33._)`${topSchemaRef}${schemaPath}`], [names_1$7.default.data, data]);
		if (propertyName) keyValues.push([E.propertyName, propertyName]);
	}
}) });

//#endregion
//#region ../node_modules/ajv/dist/compile/validate/boolSchema.js
var require_boolSchema = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/compile/validate/boolSchema.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const errors_1$3 = require_errors();
	const codegen_1$32 = require_codegen();
	const names_1$6 = require_names();
	const boolError = { message: "boolean schema is false" };
	function topBoolOrEmptySchema(it) {
		const { gen, schema: schema$1, validateName } = it;
		if (schema$1 === false) falseSchemaError(it, false);
		else if (typeof schema$1 == "object" && schema$1.$async === true) gen.return(names_1$6.default.data);
		else {
			gen.assign((0, codegen_1$32._)`${validateName}.errors`, null);
			gen.return(true);
		}
	}
	exports.topBoolOrEmptySchema = topBoolOrEmptySchema;
	function boolOrEmptySchema(it, valid) {
		const { gen, schema: schema$1 } = it;
		if (schema$1 === false) {
			gen.var(valid, false);
			falseSchemaError(it);
		} else gen.var(valid, true);
	}
	exports.boolOrEmptySchema = boolOrEmptySchema;
	function falseSchemaError(it, overrideAllErrors) {
		const { gen, data } = it;
		const cxt = {
			gen,
			keyword: "false schema",
			data,
			schema: false,
			schemaCode: false,
			schemaValue: false,
			params: {},
			it
		};
		(0, errors_1$3.reportError)(cxt, boolError, void 0, overrideAllErrors);
	}
}) });

//#endregion
//#region ../node_modules/ajv/dist/compile/rules.js
var require_rules = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/compile/rules.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const jsonTypes = new Set([
		"string",
		"number",
		"integer",
		"boolean",
		"null",
		"object",
		"array"
	]);
	function isJSONType(x) {
		return typeof x == "string" && jsonTypes.has(x);
	}
	exports.isJSONType = isJSONType;
	function getRules() {
		const groups = {
			number: {
				type: "number",
				rules: []
			},
			string: {
				type: "string",
				rules: []
			},
			array: {
				type: "array",
				rules: []
			},
			object: {
				type: "object",
				rules: []
			}
		};
		return {
			types: {
				...groups,
				integer: true,
				boolean: true,
				null: true
			},
			rules: [
				{ rules: [] },
				groups.number,
				groups.string,
				groups.array,
				groups.object
			],
			post: { rules: [] },
			all: {},
			keywords: {}
		};
	}
	exports.getRules = getRules;
}) });

//#endregion
//#region ../node_modules/ajv/dist/compile/validate/applicability.js
var require_applicability = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/compile/validate/applicability.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	function schemaHasRulesForType({ schema: schema$1, self }, type) {
		const group = self.RULES.types[type];
		return group && group !== true && shouldUseGroup(schema$1, group);
	}
	exports.schemaHasRulesForType = schemaHasRulesForType;
	function shouldUseGroup(schema$1, group) {
		return group.rules.some((rule) => shouldUseRule(schema$1, rule));
	}
	exports.shouldUseGroup = shouldUseGroup;
	function shouldUseRule(schema$1, rule) {
		var _a$1;
		return schema$1[rule.keyword] !== void 0 || ((_a$1 = rule.definition.implements) === null || _a$1 === void 0 ? void 0 : _a$1.some((kwd) => schema$1[kwd] !== void 0));
	}
	exports.shouldUseRule = shouldUseRule;
}) });

//#endregion
//#region ../node_modules/ajv/dist/compile/validate/dataType.js
var require_dataType = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/compile/validate/dataType.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const rules_1$1 = require_rules();
	const applicability_1$1 = require_applicability();
	const errors_1$2 = require_errors();
	const codegen_1$31 = require_codegen();
	const util_1$28 = require_util();
	var DataType;
	(function(DataType$1) {
		DataType$1[DataType$1["Correct"] = 0] = "Correct";
		DataType$1[DataType$1["Wrong"] = 1] = "Wrong";
	})(DataType || (exports.DataType = DataType = {}));
	function getSchemaTypes(schema$1) {
		const types = getJSONTypes(schema$1.type);
		if (types.includes("null")) {
			if (schema$1.nullable === false) throw new Error("type: null contradicts nullable: false");
		} else {
			if (!types.length && schema$1.nullable !== void 0) throw new Error("\"nullable\" cannot be used without \"type\"");
			if (schema$1.nullable === true) types.push("null");
		}
		return types;
	}
	exports.getSchemaTypes = getSchemaTypes;
	function getJSONTypes(ts) {
		const types = Array.isArray(ts) ? ts : ts ? [ts] : [];
		if (types.every(rules_1$1.isJSONType)) return types;
		throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
	}
	exports.getJSONTypes = getJSONTypes;
	function coerceAndCheckDataType(it, types) {
		const { gen, data, opts } = it;
		const coerceTo = coerceToTypes(types, opts.coerceTypes);
		const checkTypes = types.length > 0 && !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1$1.schemaHasRulesForType)(it, types[0]));
		if (checkTypes) {
			const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);
			gen.if(wrongType, () => {
				if (coerceTo.length) coerceData(it, types, coerceTo);
				else reportTypeError(it);
			});
		}
		return checkTypes;
	}
	exports.coerceAndCheckDataType = coerceAndCheckDataType;
	const COERCIBLE = new Set([
		"string",
		"number",
		"integer",
		"boolean",
		"null"
	]);
	function coerceToTypes(types, coerceTypes) {
		return coerceTypes ? types.filter((t$1) => COERCIBLE.has(t$1) || coerceTypes === "array" && t$1 === "array") : [];
	}
	function coerceData(it, types, coerceTo) {
		const { gen, data, opts } = it;
		const dataType = gen.let("dataType", (0, codegen_1$31._)`typeof ${data}`);
		const coerced = gen.let("coerced", (0, codegen_1$31._)`undefined`);
		if (opts.coerceTypes === "array") gen.if((0, codegen_1$31._)`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1$31._)`${data}[0]`).assign(dataType, (0, codegen_1$31._)`typeof ${data}`).if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));
		gen.if((0, codegen_1$31._)`${coerced} !== undefined`);
		for (const t$1 of coerceTo) if (COERCIBLE.has(t$1) || t$1 === "array" && opts.coerceTypes === "array") coerceSpecificType(t$1);
		gen.else();
		reportTypeError(it);
		gen.endIf();
		gen.if((0, codegen_1$31._)`${coerced} !== undefined`, () => {
			gen.assign(data, coerced);
			assignParentData(it, coerced);
		});
		function coerceSpecificType(t$1) {
			switch (t$1) {
				case "string":
					gen.elseIf((0, codegen_1$31._)`${dataType} == "number" || ${dataType} == "boolean"`).assign(coerced, (0, codegen_1$31._)`"" + ${data}`).elseIf((0, codegen_1$31._)`${data} === null`).assign(coerced, (0, codegen_1$31._)`""`);
					return;
				case "number":
					gen.elseIf((0, codegen_1$31._)`${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1$31._)`+${data}`);
					return;
				case "integer":
					gen.elseIf((0, codegen_1$31._)`${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1$31._)`+${data}`);
					return;
				case "boolean":
					gen.elseIf((0, codegen_1$31._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1$31._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
					return;
				case "null":
					gen.elseIf((0, codegen_1$31._)`${data} === "" || ${data} === 0 || ${data} === false`);
					gen.assign(coerced, null);
					return;
				case "array": gen.elseIf((0, codegen_1$31._)`${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1$31._)`[${data}]`);
			}
		}
	}
	function assignParentData({ gen, parentData, parentDataProperty }, expr) {
		gen.if((0, codegen_1$31._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1$31._)`${parentData}[${parentDataProperty}]`, expr));
	}
	function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
		const EQ = correct === DataType.Correct ? codegen_1$31.operators.EQ : codegen_1$31.operators.NEQ;
		let cond;
		switch (dataType) {
			case "null": return (0, codegen_1$31._)`${data} ${EQ} null`;
			case "array":
				cond = (0, codegen_1$31._)`Array.isArray(${data})`;
				break;
			case "object":
				cond = (0, codegen_1$31._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
				break;
			case "integer":
				cond = numCond((0, codegen_1$31._)`!(${data} % 1) && !isNaN(${data})`);
				break;
			case "number":
				cond = numCond();
				break;
			default: return (0, codegen_1$31._)`typeof ${data} ${EQ} ${dataType}`;
		}
		return correct === DataType.Correct ? cond : (0, codegen_1$31.not)(cond);
		function numCond(_cond = codegen_1$31.nil) {
			return (0, codegen_1$31.and)((0, codegen_1$31._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1$31._)`isFinite(${data})` : codegen_1$31.nil);
		}
	}
	exports.checkDataType = checkDataType;
	function checkDataTypes(dataTypes, data, strictNums, correct) {
		if (dataTypes.length === 1) return checkDataType(dataTypes[0], data, strictNums, correct);
		let cond;
		const types = (0, util_1$28.toHash)(dataTypes);
		if (types.array && types.object) {
			const notObj = (0, codegen_1$31._)`typeof ${data} != "object"`;
			cond = types.null ? notObj : (0, codegen_1$31._)`!${data} || ${notObj}`;
			delete types.null;
			delete types.array;
			delete types.object;
		} else cond = codegen_1$31.nil;
		if (types.number) delete types.integer;
		for (const t$1 in types) cond = (0, codegen_1$31.and)(cond, checkDataType(t$1, data, strictNums, correct));
		return cond;
	}
	exports.checkDataTypes = checkDataTypes;
	const typeError = {
		message: ({ schema: schema$1 }) => `must be ${schema$1}`,
		params: ({ schema: schema$1, schemaValue }) => typeof schema$1 == "string" ? (0, codegen_1$31._)`{type: ${schema$1}}` : (0, codegen_1$31._)`{type: ${schemaValue}}`
	};
	function reportTypeError(it) {
		const cxt = getTypeErrorContext(it);
		(0, errors_1$2.reportError)(cxt, typeError);
	}
	exports.reportTypeError = reportTypeError;
	function getTypeErrorContext(it) {
		const { gen, data, schema: schema$1 } = it;
		const schemaCode = (0, util_1$28.schemaRefOrVal)(it, schema$1, "type");
		return {
			gen,
			keyword: "type",
			data,
			schema: schema$1.type,
			schemaCode,
			schemaValue: schemaCode,
			parentSchema: schema$1,
			params: {},
			it
		};
	}
}) });

//#endregion
//#region ../node_modules/ajv/dist/compile/validate/defaults.js
var require_defaults = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/compile/validate/defaults.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$30 = require_codegen();
	const util_1$27 = require_util();
	function assignDefaults(it, ty) {
		const { properties, items } = it.schema;
		if (ty === "object" && properties) for (const key in properties) assignDefault(it, key, properties[key].default);
		else if (ty === "array" && Array.isArray(items)) items.forEach((sch, i) => assignDefault(it, i, sch.default));
	}
	exports.assignDefaults = assignDefaults;
	function assignDefault(it, prop, defaultValue) {
		const { gen, compositeRule, data, opts } = it;
		if (defaultValue === void 0) return;
		const childData = (0, codegen_1$30._)`${data}${(0, codegen_1$30.getProperty)(prop)}`;
		if (compositeRule) {
			(0, util_1$27.checkStrictMode)(it, `default is ignored for: ${childData}`);
			return;
		}
		let condition = (0, codegen_1$30._)`${childData} === undefined`;
		if (opts.useDefaults === "empty") condition = (0, codegen_1$30._)`${condition} || ${childData} === null || ${childData} === ""`;
		gen.if(condition, (0, codegen_1$30._)`${childData} = ${(0, codegen_1$30.stringify)(defaultValue)}`);
	}
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/code.js
var require_code = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/code.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$29 = require_codegen();
	const util_1$26 = require_util();
	const names_1$5 = require_names();
	const util_2$1 = require_util();
	function checkReportMissingProp(cxt, prop) {
		const { gen, data, it } = cxt;
		gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
			cxt.setParams({ missingProperty: (0, codegen_1$29._)`${prop}` }, true);
			cxt.error();
		});
	}
	exports.checkReportMissingProp = checkReportMissingProp;
	function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
		return (0, codegen_1$29.or)(...properties.map((prop) => (0, codegen_1$29.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1$29._)`${missing} = ${prop}`)));
	}
	exports.checkMissingProp = checkMissingProp;
	function reportMissingProp(cxt, missing) {
		cxt.setParams({ missingProperty: missing }, true);
		cxt.error();
	}
	exports.reportMissingProp = reportMissingProp;
	function hasPropFunc(gen) {
		return gen.scopeValue("func", {
			ref: Object.prototype.hasOwnProperty,
			code: (0, codegen_1$29._)`Object.prototype.hasOwnProperty`
		});
	}
	exports.hasPropFunc = hasPropFunc;
	function isOwnProperty(gen, data, property) {
		return (0, codegen_1$29._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
	}
	exports.isOwnProperty = isOwnProperty;
	function propertyInData(gen, data, property, ownProperties) {
		const cond = (0, codegen_1$29._)`${data}${(0, codegen_1$29.getProperty)(property)} !== undefined`;
		return ownProperties ? (0, codegen_1$29._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
	}
	exports.propertyInData = propertyInData;
	function noPropertyInData(gen, data, property, ownProperties) {
		const cond = (0, codegen_1$29._)`${data}${(0, codegen_1$29.getProperty)(property)} === undefined`;
		return ownProperties ? (0, codegen_1$29.or)(cond, (0, codegen_1$29.not)(isOwnProperty(gen, data, property))) : cond;
	}
	exports.noPropertyInData = noPropertyInData;
	function allSchemaProperties(schemaMap) {
		return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
	}
	exports.allSchemaProperties = allSchemaProperties;
	function schemaProperties(it, schemaMap) {
		return allSchemaProperties(schemaMap).filter((p) => !(0, util_1$26.alwaysValidSchema)(it, schemaMap[p]));
	}
	exports.schemaProperties = schemaProperties;
	function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
		const dataAndSchema = passSchema ? (0, codegen_1$29._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
		const valCxt = [
			[names_1$5.default.instancePath, (0, codegen_1$29.strConcat)(names_1$5.default.instancePath, errorPath)],
			[names_1$5.default.parentData, it.parentData],
			[names_1$5.default.parentDataProperty, it.parentDataProperty],
			[names_1$5.default.rootData, names_1$5.default.rootData]
		];
		if (it.opts.dynamicRef) valCxt.push([names_1$5.default.dynamicAnchors, names_1$5.default.dynamicAnchors]);
		const args = (0, codegen_1$29._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
		return context !== codegen_1$29.nil ? (0, codegen_1$29._)`${func}.call(${context}, ${args})` : (0, codegen_1$29._)`${func}(${args})`;
	}
	exports.callValidateCode = callValidateCode;
	const newRegExp = (0, codegen_1$29._)`new RegExp`;
	function usePattern({ gen, it: { opts } }, pattern) {
		const u = opts.unicodeRegExp ? "u" : "";
		const { regExp } = opts.code;
		const rx = regExp(pattern, u);
		return gen.scopeValue("pattern", {
			key: rx.toString(),
			ref: rx,
			code: (0, codegen_1$29._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2$1.useFunc)(gen, regExp)}(${pattern}, ${u})`
		});
	}
	exports.usePattern = usePattern;
	function validateArray(cxt) {
		const { gen, data, keyword, it } = cxt;
		const valid = gen.name("valid");
		if (it.allErrors) {
			const validArr = gen.let("valid", true);
			validateItems(() => gen.assign(validArr, false));
			return validArr;
		}
		gen.var(valid, true);
		validateItems(() => gen.break());
		return valid;
		function validateItems(notValid) {
			const len = gen.const("len", (0, codegen_1$29._)`${data}.length`);
			gen.forRange("i", 0, len, (i) => {
				cxt.subschema({
					keyword,
					dataProp: i,
					dataPropType: util_1$26.Type.Num
				}, valid);
				gen.if((0, codegen_1$29.not)(valid), notValid);
			});
		}
	}
	exports.validateArray = validateArray;
	function validateUnion(cxt) {
		const { gen, schema: schema$1, keyword, it } = cxt;
		/* istanbul ignore if */
		if (!Array.isArray(schema$1)) throw new Error("ajv implementation error");
		if (schema$1.some((sch) => (0, util_1$26.alwaysValidSchema)(it, sch)) && !it.opts.unevaluated) return;
		const valid = gen.let("valid", false);
		const schValid = gen.name("_valid");
		gen.block(() => schema$1.forEach((_sch, i) => {
			const schCxt = cxt.subschema({
				keyword,
				schemaProp: i,
				compositeRule: true
			}, schValid);
			gen.assign(valid, (0, codegen_1$29._)`${valid} || ${schValid}`);
			if (!cxt.mergeValidEvaluated(schCxt, schValid)) gen.if((0, codegen_1$29.not)(valid));
		}));
		cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
	}
	exports.validateUnion = validateUnion;
}) });

//#endregion
//#region ../node_modules/ajv/dist/compile/validate/keyword.js
var require_keyword = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/compile/validate/keyword.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$28 = require_codegen();
	const names_1$4 = require_names();
	const code_1$9 = require_code();
	const errors_1$1 = require_errors();
	function macroKeywordCode(cxt, def$30) {
		const { gen, keyword, schema: schema$1, parentSchema, it } = cxt;
		const macroSchema = def$30.macro.call(it.self, schema$1, parentSchema, it);
		const schemaRef = useKeyword(gen, keyword, macroSchema);
		if (it.opts.validateSchema !== false) it.self.validateSchema(macroSchema, true);
		const valid = gen.name("valid");
		cxt.subschema({
			schema: macroSchema,
			schemaPath: codegen_1$28.nil,
			errSchemaPath: `${it.errSchemaPath}/${keyword}`,
			topSchemaRef: schemaRef,
			compositeRule: true
		}, valid);
		cxt.pass(valid, () => cxt.error(true));
	}
	exports.macroKeywordCode = macroKeywordCode;
	function funcKeywordCode(cxt, def$30) {
		var _a$1;
		const { gen, keyword, schema: schema$1, parentSchema, $data, it } = cxt;
		checkAsyncKeyword(it, def$30);
		const validateRef = useKeyword(gen, keyword, !$data && def$30.compile ? def$30.compile.call(it.self, schema$1, parentSchema, it) : def$30.validate);
		const valid = gen.let("valid");
		cxt.block$data(valid, validateKeyword);
		cxt.ok((_a$1 = def$30.valid) !== null && _a$1 !== void 0 ? _a$1 : valid);
		function validateKeyword() {
			if (def$30.errors === false) {
				assignValid();
				if (def$30.modifying) modifyData(cxt);
				reportErrs(() => cxt.error());
			} else {
				const ruleErrs = def$30.async ? validateAsync() : validateSync();
				if (def$30.modifying) modifyData(cxt);
				reportErrs(() => addErrs(cxt, ruleErrs));
			}
		}
		function validateAsync() {
			const ruleErrs = gen.let("ruleErrs", null);
			gen.try(() => assignValid((0, codegen_1$28._)`await `), (e) => gen.assign(valid, false).if((0, codegen_1$28._)`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1$28._)`${e}.errors`), () => gen.throw(e)));
			return ruleErrs;
		}
		function validateSync() {
			const validateErrs = (0, codegen_1$28._)`${validateRef}.errors`;
			gen.assign(validateErrs, null);
			assignValid(codegen_1$28.nil);
			return validateErrs;
		}
		function assignValid(_await = def$30.async ? (0, codegen_1$28._)`await ` : codegen_1$28.nil) {
			const passCxt = it.opts.passContext ? names_1$4.default.this : names_1$4.default.self;
			const passSchema = !("compile" in def$30 && !$data || def$30.schema === false);
			gen.assign(valid, (0, codegen_1$28._)`${_await}${(0, code_1$9.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def$30.modifying);
		}
		function reportErrs(errors$1) {
			var _a$2;
			gen.if((0, codegen_1$28.not)((_a$2 = def$30.valid) !== null && _a$2 !== void 0 ? _a$2 : valid), errors$1);
		}
	}
	exports.funcKeywordCode = funcKeywordCode;
	function modifyData(cxt) {
		const { gen, data, it } = cxt;
		gen.if(it.parentData, () => gen.assign(data, (0, codegen_1$28._)`${it.parentData}[${it.parentDataProperty}]`));
	}
	function addErrs(cxt, errs) {
		const { gen } = cxt;
		gen.if((0, codegen_1$28._)`Array.isArray(${errs})`, () => {
			gen.assign(names_1$4.default.vErrors, (0, codegen_1$28._)`${names_1$4.default.vErrors} === null ? ${errs} : ${names_1$4.default.vErrors}.concat(${errs})`).assign(names_1$4.default.errors, (0, codegen_1$28._)`${names_1$4.default.vErrors}.length`);
			(0, errors_1$1.extendErrors)(cxt);
		}, () => cxt.error());
	}
	function checkAsyncKeyword({ schemaEnv }, def$30) {
		if (def$30.async && !schemaEnv.$async) throw new Error("async keyword in sync schema");
	}
	function useKeyword(gen, keyword, result) {
		if (result === void 0) throw new Error(`keyword "${keyword}" failed to compile`);
		return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : {
			ref: result,
			code: (0, codegen_1$28.stringify)(result)
		});
	}
	function validSchemaType(schema$1, schemaType, allowUndefined = false) {
		return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema$1) : st === "object" ? schema$1 && typeof schema$1 == "object" && !Array.isArray(schema$1) : typeof schema$1 == st || allowUndefined && typeof schema$1 == "undefined");
	}
	exports.validSchemaType = validSchemaType;
	function validateKeywordUsage({ schema: schema$1, opts, self, errSchemaPath }, def$30, keyword) {
		/* istanbul ignore if */
		if (Array.isArray(def$30.keyword) ? !def$30.keyword.includes(keyword) : def$30.keyword !== keyword) throw new Error("ajv implementation error");
		const deps = def$30.dependencies;
		if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema$1, kwd))) throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
		if (def$30.validateSchema) {
			if (!def$30.validateSchema(schema$1[keyword])) {
				const msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` + self.errorsText(def$30.validateSchema.errors);
				if (opts.validateSchema === "log") self.logger.error(msg);
				else throw new Error(msg);
			}
		}
	}
	exports.validateKeywordUsage = validateKeywordUsage;
}) });

//#endregion
//#region ../node_modules/ajv/dist/compile/validate/subschema.js
var require_subschema = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/compile/validate/subschema.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$27 = require_codegen();
	const util_1$25 = require_util();
	function getSubschema(it, { keyword, schemaProp, schema: schema$1, schemaPath, errSchemaPath, topSchemaRef }) {
		if (keyword !== void 0 && schema$1 !== void 0) throw new Error("both \"keyword\" and \"schema\" passed, only one allowed");
		if (keyword !== void 0) {
			const sch = it.schema[keyword];
			return schemaProp === void 0 ? {
				schema: sch,
				schemaPath: (0, codegen_1$27._)`${it.schemaPath}${(0, codegen_1$27.getProperty)(keyword)}`,
				errSchemaPath: `${it.errSchemaPath}/${keyword}`
			} : {
				schema: sch[schemaProp],
				schemaPath: (0, codegen_1$27._)`${it.schemaPath}${(0, codegen_1$27.getProperty)(keyword)}${(0, codegen_1$27.getProperty)(schemaProp)}`,
				errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1$25.escapeFragment)(schemaProp)}`
			};
		}
		if (schema$1 !== void 0) {
			if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) throw new Error("\"schemaPath\", \"errSchemaPath\" and \"topSchemaRef\" are required with \"schema\"");
			return {
				schema: schema$1,
				schemaPath,
				topSchemaRef,
				errSchemaPath
			};
		}
		throw new Error("either \"keyword\" or \"schema\" must be passed");
	}
	exports.getSubschema = getSubschema;
	function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
		if (data !== void 0 && dataProp !== void 0) throw new Error("both \"data\" and \"dataProp\" passed, only one allowed");
		const { gen } = it;
		if (dataProp !== void 0) {
			const { errorPath, dataPathArr, opts } = it;
			dataContextProps(gen.let("data", (0, codegen_1$27._)`${it.data}${(0, codegen_1$27.getProperty)(dataProp)}`, true));
			subschema.errorPath = (0, codegen_1$27.str)`${errorPath}${(0, util_1$25.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
			subschema.parentDataProperty = (0, codegen_1$27._)`${dataProp}`;
			subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
		}
		if (data !== void 0) {
			dataContextProps(data instanceof codegen_1$27.Name ? data : gen.let("data", data, true));
			if (propertyName !== void 0) subschema.propertyName = propertyName;
		}
		if (dataTypes) subschema.dataTypes = dataTypes;
		function dataContextProps(_nextData) {
			subschema.data = _nextData;
			subschema.dataLevel = it.dataLevel + 1;
			subschema.dataTypes = [];
			it.definedProperties = /* @__PURE__ */ new Set();
			subschema.parentData = it.data;
			subschema.dataNames = [...it.dataNames, _nextData];
		}
	}
	exports.extendSubschemaData = extendSubschemaData;
	function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
		if (compositeRule !== void 0) subschema.compositeRule = compositeRule;
		if (createErrors !== void 0) subschema.createErrors = createErrors;
		if (allErrors !== void 0) subschema.allErrors = allErrors;
		subschema.jtdDiscriminator = jtdDiscriminator;
		subschema.jtdMetadata = jtdMetadata;
	}
	exports.extendSubschemaMode = extendSubschemaMode;
}) });

//#endregion
//#region ../node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = /* @__PURE__ */ __commonJS$2({ "../node_modules/fast-deep-equal/index.js": ((exports, module) => {
	module.exports = function equal$3(a, b) {
		if (a === b) return true;
		if (a && b && typeof a == "object" && typeof b == "object") {
			if (a.constructor !== b.constructor) return false;
			var length, i, keys;
			if (Array.isArray(a)) {
				length = a.length;
				if (length != b.length) return false;
				for (i = length; i-- !== 0;) if (!equal$3(a[i], b[i])) return false;
				return true;
			}
			if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
			if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
			if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
			keys = Object.keys(a);
			length = keys.length;
			if (length !== Object.keys(b).length) return false;
			for (i = length; i-- !== 0;) if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
			for (i = length; i-- !== 0;) {
				var key = keys[i];
				if (!equal$3(a[key], b[key])) return false;
			}
			return true;
		}
		return a !== a && b !== b;
	};
}) });

//#endregion
//#region ../node_modules/json-schema-traverse/index.js
var require_json_schema_traverse = /* @__PURE__ */ __commonJS$2({ "../node_modules/json-schema-traverse/index.js": ((exports, module) => {
	var traverse$1 = module.exports = function(schema$1, opts, cb) {
		if (typeof opts == "function") {
			cb = opts;
			opts = {};
		}
		cb = opts.cb || cb;
		var pre = typeof cb == "function" ? cb : cb.pre || function() {};
		var post = cb.post || function() {};
		_traverse(opts, pre, post, schema$1, "", schema$1);
	};
	traverse$1.keywords = {
		additionalItems: true,
		items: true,
		contains: true,
		additionalProperties: true,
		propertyNames: true,
		not: true,
		if: true,
		then: true,
		else: true
	};
	traverse$1.arrayKeywords = {
		items: true,
		allOf: true,
		anyOf: true,
		oneOf: true
	};
	traverse$1.propsKeywords = {
		$defs: true,
		definitions: true,
		properties: true,
		patternProperties: true,
		dependencies: true
	};
	traverse$1.skipKeywords = {
		default: true,
		enum: true,
		const: true,
		required: true,
		maximum: true,
		minimum: true,
		exclusiveMaximum: true,
		exclusiveMinimum: true,
		multipleOf: true,
		maxLength: true,
		minLength: true,
		pattern: true,
		format: true,
		maxItems: true,
		minItems: true,
		uniqueItems: true,
		maxProperties: true,
		minProperties: true
	};
	function _traverse(opts, pre, post, schema$1, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
		if (schema$1 && typeof schema$1 == "object" && !Array.isArray(schema$1)) {
			pre(schema$1, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
			for (var key in schema$1) {
				var sch = schema$1[key];
				if (Array.isArray(sch)) {
					if (key in traverse$1.arrayKeywords) for (var i = 0; i < sch.length; i++) _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema$1, i);
				} else if (key in traverse$1.propsKeywords) {
					if (sch && typeof sch == "object") for (var prop in sch) _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema$1, prop);
				} else if (key in traverse$1.keywords || opts.allKeys && !(key in traverse$1.skipKeywords)) _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema$1);
			}
			post(schema$1, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
		}
	}
	function escapeJsonPtr(str$1) {
		return str$1.replace(/~/g, "~0").replace(/\//g, "~1");
	}
}) });

//#endregion
//#region ../node_modules/ajv/dist/compile/resolve.js
var require_resolve = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/compile/resolve.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const util_1$24 = require_util();
	const equal$2 = require_fast_deep_equal();
	const traverse = require_json_schema_traverse();
	const SIMPLE_INLINED = new Set([
		"type",
		"format",
		"pattern",
		"maxLength",
		"minLength",
		"maxProperties",
		"minProperties",
		"maxItems",
		"minItems",
		"maximum",
		"minimum",
		"uniqueItems",
		"multipleOf",
		"required",
		"enum",
		"const"
	]);
	function inlineRef(schema$1, limit = true) {
		if (typeof schema$1 == "boolean") return true;
		if (limit === true) return !hasRef(schema$1);
		if (!limit) return false;
		return countKeys(schema$1) <= limit;
	}
	exports.inlineRef = inlineRef;
	const REF_KEYWORDS = new Set([
		"$ref",
		"$recursiveRef",
		"$recursiveAnchor",
		"$dynamicRef",
		"$dynamicAnchor"
	]);
	function hasRef(schema$1) {
		for (const key in schema$1) {
			if (REF_KEYWORDS.has(key)) return true;
			const sch = schema$1[key];
			if (Array.isArray(sch) && sch.some(hasRef)) return true;
			if (typeof sch == "object" && hasRef(sch)) return true;
		}
		return false;
	}
	function countKeys(schema$1) {
		let count = 0;
		for (const key in schema$1) {
			if (key === "$ref") return Infinity;
			count++;
			if (SIMPLE_INLINED.has(key)) continue;
			if (typeof schema$1[key] == "object") (0, util_1$24.eachItem)(schema$1[key], (sch) => count += countKeys(sch));
			if (count === Infinity) return Infinity;
		}
		return count;
	}
	function getFullPath(resolver, id = "", normalize$1) {
		if (normalize$1 !== false) id = normalizeId(id);
		return _getFullPath(resolver, resolver.parse(id));
	}
	exports.getFullPath = getFullPath;
	function _getFullPath(resolver, p) {
		return resolver.serialize(p).split("#")[0] + "#";
	}
	exports._getFullPath = _getFullPath;
	const TRAILING_SLASH_HASH = /#\/?$/;
	function normalizeId(id) {
		return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
	}
	exports.normalizeId = normalizeId;
	function resolveUrl(resolver, baseId, id) {
		id = normalizeId(id);
		return resolver.resolve(baseId, id);
	}
	exports.resolveUrl = resolveUrl;
	const ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
	function getSchemaRefs(schema$1, baseId) {
		if (typeof schema$1 == "boolean") return {};
		const { schemaId, uriResolver } = this.opts;
		const schId = normalizeId(schema$1[schemaId] || baseId);
		const baseIds = { "": schId };
		const pathPrefix = getFullPath(uriResolver, schId, false);
		const localRefs = {};
		const schemaRefs = /* @__PURE__ */ new Set();
		traverse(schema$1, { allKeys: true }, (sch, jsonPtr, _$1, parentJsonPtr) => {
			if (parentJsonPtr === void 0) return;
			const fullPath = pathPrefix + jsonPtr;
			let innerBaseId = baseIds[parentJsonPtr];
			if (typeof sch[schemaId] == "string") innerBaseId = addRef.call(this, sch[schemaId]);
			addAnchor.call(this, sch.$anchor);
			addAnchor.call(this, sch.$dynamicAnchor);
			baseIds[jsonPtr] = innerBaseId;
			function addRef(ref) {
				const _resolve = this.opts.uriResolver.resolve;
				ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref);
				if (schemaRefs.has(ref)) throw ambiguos(ref);
				schemaRefs.add(ref);
				let schOrRef = this.refs[ref];
				if (typeof schOrRef == "string") schOrRef = this.refs[schOrRef];
				if (typeof schOrRef == "object") checkAmbiguosRef(sch, schOrRef.schema, ref);
				else if (ref !== normalizeId(fullPath)) if (ref[0] === "#") {
					checkAmbiguosRef(sch, localRefs[ref], ref);
					localRefs[ref] = sch;
				} else this.refs[ref] = fullPath;
				return ref;
			}
			function addAnchor(anchor) {
				if (typeof anchor == "string") {
					if (!ANCHOR.test(anchor)) throw new Error(`invalid anchor "${anchor}"`);
					addRef.call(this, `#${anchor}`);
				}
			}
		});
		return localRefs;
		function checkAmbiguosRef(sch1, sch2, ref) {
			if (sch2 !== void 0 && !equal$2(sch1, sch2)) throw ambiguos(ref);
		}
		function ambiguos(ref) {
			return /* @__PURE__ */ new Error(`reference "${ref}" resolves to more than one schema`);
		}
	}
	exports.getSchemaRefs = getSchemaRefs;
}) });

//#endregion
//#region ../node_modules/ajv/dist/compile/validate/index.js
var require_validate = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/compile/validate/index.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const boolSchema_1 = require_boolSchema();
	const dataType_1$2 = require_dataType();
	const applicability_1 = require_applicability();
	const dataType_2 = require_dataType();
	const defaults_1 = require_defaults();
	const keyword_1 = require_keyword();
	const subschema_1 = require_subschema();
	const codegen_1$26 = require_codegen();
	const names_1$3 = require_names();
	const resolve_1$3 = require_resolve();
	const util_1$23 = require_util();
	const errors_1 = require_errors();
	function validateFunctionCode(it) {
		if (isSchemaObj(it)) {
			checkKeywords(it);
			if (schemaCxtHasRules(it)) {
				topSchemaObjCode(it);
				return;
			}
		}
		validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
	}
	exports.validateFunctionCode = validateFunctionCode;
	function validateFunction({ gen, validateName, schema: schema$1, schemaEnv, opts }, body) {
		if (opts.code.es5) gen.func(validateName, (0, codegen_1$26._)`${names_1$3.default.data}, ${names_1$3.default.valCxt}`, schemaEnv.$async, () => {
			gen.code((0, codegen_1$26._)`"use strict"; ${funcSourceUrl(schema$1, opts)}`);
			destructureValCxtES5(gen, opts);
			gen.code(body);
		});
		else gen.func(validateName, (0, codegen_1$26._)`${names_1$3.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema$1, opts)).code(body));
	}
	function destructureValCxt(opts) {
		return (0, codegen_1$26._)`{${names_1$3.default.instancePath}="", ${names_1$3.default.parentData}, ${names_1$3.default.parentDataProperty}, ${names_1$3.default.rootData}=${names_1$3.default.data}${opts.dynamicRef ? (0, codegen_1$26._)`, ${names_1$3.default.dynamicAnchors}={}` : codegen_1$26.nil}}={}`;
	}
	function destructureValCxtES5(gen, opts) {
		gen.if(names_1$3.default.valCxt, () => {
			gen.var(names_1$3.default.instancePath, (0, codegen_1$26._)`${names_1$3.default.valCxt}.${names_1$3.default.instancePath}`);
			gen.var(names_1$3.default.parentData, (0, codegen_1$26._)`${names_1$3.default.valCxt}.${names_1$3.default.parentData}`);
			gen.var(names_1$3.default.parentDataProperty, (0, codegen_1$26._)`${names_1$3.default.valCxt}.${names_1$3.default.parentDataProperty}`);
			gen.var(names_1$3.default.rootData, (0, codegen_1$26._)`${names_1$3.default.valCxt}.${names_1$3.default.rootData}`);
			if (opts.dynamicRef) gen.var(names_1$3.default.dynamicAnchors, (0, codegen_1$26._)`${names_1$3.default.valCxt}.${names_1$3.default.dynamicAnchors}`);
		}, () => {
			gen.var(names_1$3.default.instancePath, (0, codegen_1$26._)`""`);
			gen.var(names_1$3.default.parentData, (0, codegen_1$26._)`undefined`);
			gen.var(names_1$3.default.parentDataProperty, (0, codegen_1$26._)`undefined`);
			gen.var(names_1$3.default.rootData, names_1$3.default.data);
			if (opts.dynamicRef) gen.var(names_1$3.default.dynamicAnchors, (0, codegen_1$26._)`{}`);
		});
	}
	function topSchemaObjCode(it) {
		const { schema: schema$1, opts, gen } = it;
		validateFunction(it, () => {
			if (opts.$comment && schema$1.$comment) commentKeyword(it);
			checkNoDefault(it);
			gen.let(names_1$3.default.vErrors, null);
			gen.let(names_1$3.default.errors, 0);
			if (opts.unevaluated) resetEvaluated(it);
			typeAndKeywords(it);
			returnResults(it);
		});
	}
	function resetEvaluated(it) {
		const { gen, validateName } = it;
		it.evaluated = gen.const("evaluated", (0, codegen_1$26._)`${validateName}.evaluated`);
		gen.if((0, codegen_1$26._)`${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1$26._)`${it.evaluated}.props`, (0, codegen_1$26._)`undefined`));
		gen.if((0, codegen_1$26._)`${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1$26._)`${it.evaluated}.items`, (0, codegen_1$26._)`undefined`));
	}
	function funcSourceUrl(schema$1, opts) {
		const schId = typeof schema$1 == "object" && schema$1[opts.schemaId];
		return schId && (opts.code.source || opts.code.process) ? (0, codegen_1$26._)`/*# sourceURL=${schId} */` : codegen_1$26.nil;
	}
	function subschemaCode(it, valid) {
		if (isSchemaObj(it)) {
			checkKeywords(it);
			if (schemaCxtHasRules(it)) {
				subSchemaObjCode(it, valid);
				return;
			}
		}
		(0, boolSchema_1.boolOrEmptySchema)(it, valid);
	}
	function schemaCxtHasRules({ schema: schema$1, self }) {
		if (typeof schema$1 == "boolean") return !schema$1;
		for (const key in schema$1) if (self.RULES.all[key]) return true;
		return false;
	}
	function isSchemaObj(it) {
		return typeof it.schema != "boolean";
	}
	function subSchemaObjCode(it, valid) {
		const { schema: schema$1, gen, opts } = it;
		if (opts.$comment && schema$1.$comment) commentKeyword(it);
		updateContext(it);
		checkAsyncSchema(it);
		const errsCount = gen.const("_errs", names_1$3.default.errors);
		typeAndKeywords(it, errsCount);
		gen.var(valid, (0, codegen_1$26._)`${errsCount} === ${names_1$3.default.errors}`);
	}
	function checkKeywords(it) {
		(0, util_1$23.checkUnknownRules)(it);
		checkRefsAndKeywords(it);
	}
	function typeAndKeywords(it, errsCount) {
		if (it.opts.jtd) return schemaKeywords(it, [], false, errsCount);
		const types = (0, dataType_1$2.getSchemaTypes)(it.schema);
		schemaKeywords(it, types, !(0, dataType_1$2.coerceAndCheckDataType)(it, types), errsCount);
	}
	function checkRefsAndKeywords(it) {
		const { schema: schema$1, errSchemaPath, opts, self } = it;
		if (schema$1.$ref && opts.ignoreKeywordsWithRef && (0, util_1$23.schemaHasRulesButRef)(schema$1, self.RULES)) self.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
	}
	function checkNoDefault(it) {
		const { schema: schema$1, opts } = it;
		if (schema$1.default !== void 0 && opts.useDefaults && opts.strictSchema) (0, util_1$23.checkStrictMode)(it, "default is ignored in the schema root");
	}
	function updateContext(it) {
		const schId = it.schema[it.opts.schemaId];
		if (schId) it.baseId = (0, resolve_1$3.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
	}
	function checkAsyncSchema(it) {
		if (it.schema.$async && !it.schemaEnv.$async) throw new Error("async schema in sync schema");
	}
	function commentKeyword({ gen, schemaEnv, schema: schema$1, errSchemaPath, opts }) {
		const msg = schema$1.$comment;
		if (opts.$comment === true) gen.code((0, codegen_1$26._)`${names_1$3.default.self}.logger.log(${msg})`);
		else if (typeof opts.$comment == "function") {
			const schemaPath = (0, codegen_1$26.str)`${errSchemaPath}/$comment`;
			const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
			gen.code((0, codegen_1$26._)`${names_1$3.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
		}
	}
	function returnResults(it) {
		const { gen, schemaEnv, validateName, ValidationError: ValidationError$1, opts } = it;
		if (schemaEnv.$async) gen.if((0, codegen_1$26._)`${names_1$3.default.errors} === 0`, () => gen.return(names_1$3.default.data), () => gen.throw((0, codegen_1$26._)`new ${ValidationError$1}(${names_1$3.default.vErrors})`));
		else {
			gen.assign((0, codegen_1$26._)`${validateName}.errors`, names_1$3.default.vErrors);
			if (opts.unevaluated) assignEvaluated(it);
			gen.return((0, codegen_1$26._)`${names_1$3.default.errors} === 0`);
		}
	}
	function assignEvaluated({ gen, evaluated, props, items }) {
		if (props instanceof codegen_1$26.Name) gen.assign((0, codegen_1$26._)`${evaluated}.props`, props);
		if (items instanceof codegen_1$26.Name) gen.assign((0, codegen_1$26._)`${evaluated}.items`, items);
	}
	function schemaKeywords(it, types, typeErrors, errsCount) {
		const { gen, schema: schema$1, data, allErrors, opts, self } = it;
		const { RULES } = self;
		if (schema$1.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1$23.schemaHasRulesButRef)(schema$1, RULES))) {
			gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
			return;
		}
		if (!opts.jtd) checkStrictTypes(it, types);
		gen.block(() => {
			for (const group of RULES.rules) groupKeywords(group);
			groupKeywords(RULES.post);
		});
		function groupKeywords(group) {
			if (!(0, applicability_1.shouldUseGroup)(schema$1, group)) return;
			if (group.type) {
				gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
				iterateKeywords(it, group);
				if (types.length === 1 && types[0] === group.type && typeErrors) {
					gen.else();
					(0, dataType_2.reportTypeError)(it);
				}
				gen.endIf();
			} else iterateKeywords(it, group);
			if (!allErrors) gen.if((0, codegen_1$26._)`${names_1$3.default.errors} === ${errsCount || 0}`);
		}
	}
	function iterateKeywords(it, group) {
		const { gen, schema: schema$1, opts: { useDefaults } } = it;
		if (useDefaults) (0, defaults_1.assignDefaults)(it, group.type);
		gen.block(() => {
			for (const rule of group.rules) if ((0, applicability_1.shouldUseRule)(schema$1, rule)) keywordCode(it, rule.keyword, rule.definition, group.type);
		});
	}
	function checkStrictTypes(it, types) {
		if (it.schemaEnv.meta || !it.opts.strictTypes) return;
		checkContextTypes(it, types);
		if (!it.opts.allowUnionTypes) checkMultipleTypes(it, types);
		checkKeywordTypes(it, it.dataTypes);
	}
	function checkContextTypes(it, types) {
		if (!types.length) return;
		if (!it.dataTypes.length) {
			it.dataTypes = types;
			return;
		}
		types.forEach((t$1) => {
			if (!includesType(it.dataTypes, t$1)) strictTypesError(it, `type "${t$1}" not allowed by context "${it.dataTypes.join(",")}"`);
		});
		narrowSchemaTypes(it, types);
	}
	function checkMultipleTypes(it, ts) {
		if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) strictTypesError(it, "use allowUnionTypes to allow union type keyword");
	}
	function checkKeywordTypes(it, ts) {
		const rules = it.self.RULES.all;
		for (const keyword in rules) {
			const rule = rules[keyword];
			if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
				const { type } = rule.definition;
				if (type.length && !type.some((t$1) => hasApplicableType(ts, t$1))) strictTypesError(it, `missing type "${type.join(",")}" for keyword "${keyword}"`);
			}
		}
	}
	function hasApplicableType(schTs, kwdT) {
		return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
	}
	function includesType(ts, t$1) {
		return ts.includes(t$1) || t$1 === "integer" && ts.includes("number");
	}
	function narrowSchemaTypes(it, withTypes) {
		const ts = [];
		for (const t$1 of it.dataTypes) if (includesType(withTypes, t$1)) ts.push(t$1);
		else if (withTypes.includes("integer") && t$1 === "number") ts.push("integer");
		it.dataTypes = ts;
	}
	function strictTypesError(it, msg) {
		const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
		msg += ` at "${schemaPath}" (strictTypes)`;
		(0, util_1$23.checkStrictMode)(it, msg, it.opts.strictTypes);
	}
	var KeywordCxt = class {
		constructor(it, def$30, keyword) {
			(0, keyword_1.validateKeywordUsage)(it, def$30, keyword);
			this.gen = it.gen;
			this.allErrors = it.allErrors;
			this.keyword = keyword;
			this.data = it.data;
			this.schema = it.schema[keyword];
			this.$data = def$30.$data && it.opts.$data && this.schema && this.schema.$data;
			this.schemaValue = (0, util_1$23.schemaRefOrVal)(it, this.schema, keyword, this.$data);
			this.schemaType = def$30.schemaType;
			this.parentSchema = it.schema;
			this.params = {};
			this.it = it;
			this.def = def$30;
			if (this.$data) this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
			else {
				this.schemaCode = this.schemaValue;
				if (!(0, keyword_1.validSchemaType)(this.schema, def$30.schemaType, def$30.allowUndefined)) throw new Error(`${keyword} value must be ${JSON.stringify(def$30.schemaType)}`);
			}
			if ("code" in def$30 ? def$30.trackErrors : def$30.errors !== false) this.errsCount = it.gen.const("_errs", names_1$3.default.errors);
		}
		result(condition, successAction, failAction) {
			this.failResult((0, codegen_1$26.not)(condition), successAction, failAction);
		}
		failResult(condition, successAction, failAction) {
			this.gen.if(condition);
			if (failAction) failAction();
			else this.error();
			if (successAction) {
				this.gen.else();
				successAction();
				if (this.allErrors) this.gen.endIf();
			} else if (this.allErrors) this.gen.endIf();
			else this.gen.else();
		}
		pass(condition, failAction) {
			this.failResult((0, codegen_1$26.not)(condition), void 0, failAction);
		}
		fail(condition) {
			if (condition === void 0) {
				this.error();
				if (!this.allErrors) this.gen.if(false);
				return;
			}
			this.gen.if(condition);
			this.error();
			if (this.allErrors) this.gen.endIf();
			else this.gen.else();
		}
		fail$data(condition) {
			if (!this.$data) return this.fail(condition);
			const { schemaCode } = this;
			this.fail((0, codegen_1$26._)`${schemaCode} !== undefined && (${(0, codegen_1$26.or)(this.invalid$data(), condition)})`);
		}
		error(append, errorParams, errorPaths) {
			if (errorParams) {
				this.setParams(errorParams);
				this._error(append, errorPaths);
				this.setParams({});
				return;
			}
			this._error(append, errorPaths);
		}
		_error(append, errorPaths) {
			(append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
		}
		$dataError() {
			(0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
		}
		reset() {
			if (this.errsCount === void 0) throw new Error("add \"trackErrors\" to keyword definition");
			(0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
		}
		ok(cond) {
			if (!this.allErrors) this.gen.if(cond);
		}
		setParams(obj, assign) {
			if (assign) Object.assign(this.params, obj);
			else this.params = obj;
		}
		block$data(valid, codeBlock, $dataValid = codegen_1$26.nil) {
			this.gen.block(() => {
				this.check$data(valid, $dataValid);
				codeBlock();
			});
		}
		check$data(valid = codegen_1$26.nil, $dataValid = codegen_1$26.nil) {
			if (!this.$data) return;
			const { gen, schemaCode, schemaType, def: def$30 } = this;
			gen.if((0, codegen_1$26.or)((0, codegen_1$26._)`${schemaCode} === undefined`, $dataValid));
			if (valid !== codegen_1$26.nil) gen.assign(valid, true);
			if (schemaType.length || def$30.validateSchema) {
				gen.elseIf(this.invalid$data());
				this.$dataError();
				if (valid !== codegen_1$26.nil) gen.assign(valid, false);
			}
			gen.else();
		}
		invalid$data() {
			const { gen, schemaCode, schemaType, def: def$30, it } = this;
			return (0, codegen_1$26.or)(wrong$DataType(), invalid$DataSchema());
			function wrong$DataType() {
				if (schemaType.length) {
					/* istanbul ignore if */
					if (!(schemaCode instanceof codegen_1$26.Name)) throw new Error("ajv implementation error");
					const st = Array.isArray(schemaType) ? schemaType : [schemaType];
					return (0, codegen_1$26._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
				}
				return codegen_1$26.nil;
			}
			function invalid$DataSchema() {
				if (def$30.validateSchema) {
					const validateSchemaRef = gen.scopeValue("validate$data", { ref: def$30.validateSchema });
					return (0, codegen_1$26._)`!${validateSchemaRef}(${schemaCode})`;
				}
				return codegen_1$26.nil;
			}
		}
		subschema(appl, valid) {
			const subschema = (0, subschema_1.getSubschema)(this.it, appl);
			(0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
			(0, subschema_1.extendSubschemaMode)(subschema, appl);
			const nextContext = {
				...this.it,
				...subschema,
				items: void 0,
				props: void 0
			};
			subschemaCode(nextContext, valid);
			return nextContext;
		}
		mergeEvaluated(schemaCxt, toName) {
			const { it, gen } = this;
			if (!it.opts.unevaluated) return;
			if (it.props !== true && schemaCxt.props !== void 0) it.props = util_1$23.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
			if (it.items !== true && schemaCxt.items !== void 0) it.items = util_1$23.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
		}
		mergeValidEvaluated(schemaCxt, valid) {
			const { it, gen } = this;
			if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
				gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1$26.Name));
				return true;
			}
		}
	};
	exports.KeywordCxt = KeywordCxt;
	function keywordCode(it, keyword, def$30, ruleType) {
		const cxt = new KeywordCxt(it, def$30, keyword);
		if ("code" in def$30) def$30.code(cxt, ruleType);
		else if (cxt.$data && def$30.validate) (0, keyword_1.funcKeywordCode)(cxt, def$30);
		else if ("macro" in def$30) (0, keyword_1.macroKeywordCode)(cxt, def$30);
		else if (def$30.compile || def$30.validate) (0, keyword_1.funcKeywordCode)(cxt, def$30);
	}
	const JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
	const RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
	function getData($data, { dataLevel, dataNames, dataPathArr }) {
		let jsonPointer;
		let data;
		if ($data === "") return names_1$3.default.rootData;
		if ($data[0] === "/") {
			if (!JSON_POINTER.test($data)) throw new Error(`Invalid JSON-pointer: ${$data}`);
			jsonPointer = $data;
			data = names_1$3.default.rootData;
		} else {
			const matches = RELATIVE_JSON_POINTER.exec($data);
			if (!matches) throw new Error(`Invalid JSON-pointer: ${$data}`);
			const up = +matches[1];
			jsonPointer = matches[2];
			if (jsonPointer === "#") {
				if (up >= dataLevel) throw new Error(errorMsg("property/index", up));
				return dataPathArr[dataLevel - up];
			}
			if (up > dataLevel) throw new Error(errorMsg("data", up));
			data = dataNames[dataLevel - up];
			if (!jsonPointer) return data;
		}
		let expr = data;
		const segments = jsonPointer.split("/");
		for (const segment of segments) if (segment) {
			data = (0, codegen_1$26._)`${data}${(0, codegen_1$26.getProperty)((0, util_1$23.unescapeJsonPointer)(segment))}`;
			expr = (0, codegen_1$26._)`${expr} && ${data}`;
		}
		return expr;
		function errorMsg(pointerType, up) {
			return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
		}
	}
	exports.getData = getData;
}) });

//#endregion
//#region ../node_modules/ajv/dist/runtime/validation_error.js
var require_validation_error = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/runtime/validation_error.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var ValidationError = class extends Error {
		constructor(errors$1) {
			super("validation failed");
			this.errors = errors$1;
			this.ajv = this.validation = true;
		}
	};
	exports.default = ValidationError;
}) });

//#endregion
//#region ../node_modules/ajv/dist/compile/ref_error.js
var require_ref_error = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/compile/ref_error.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const resolve_1$2 = require_resolve();
	var MissingRefError = class extends Error {
		constructor(resolver, baseId, ref, msg) {
			super(msg || `can't resolve reference ${ref} from id ${baseId}`);
			this.missingRef = (0, resolve_1$2.resolveUrl)(resolver, baseId, ref);
			this.missingSchema = (0, resolve_1$2.normalizeId)((0, resolve_1$2.getFullPath)(resolver, this.missingRef));
		}
	};
	exports.default = MissingRefError;
}) });

//#endregion
//#region ../node_modules/ajv/dist/compile/index.js
var require_compile = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/compile/index.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$25 = require_codegen();
	const validation_error_1$2 = require_validation_error();
	const names_1$2 = require_names();
	const resolve_1$1 = require_resolve();
	const util_1$22 = require_util();
	const validate_1$3 = require_validate();
	var SchemaEnv = class {
		constructor(env) {
			var _a$1;
			this.refs = {};
			this.dynamicAnchors = {};
			let schema$1;
			if (typeof env.schema == "object") schema$1 = env.schema;
			this.schema = env.schema;
			this.schemaId = env.schemaId;
			this.root = env.root || this;
			this.baseId = (_a$1 = env.baseId) !== null && _a$1 !== void 0 ? _a$1 : (0, resolve_1$1.normalizeId)(schema$1 === null || schema$1 === void 0 ? void 0 : schema$1[env.schemaId || "$id"]);
			this.schemaPath = env.schemaPath;
			this.localRefs = env.localRefs;
			this.meta = env.meta;
			this.$async = schema$1 === null || schema$1 === void 0 ? void 0 : schema$1.$async;
			this.refs = {};
		}
	};
	exports.SchemaEnv = SchemaEnv;
	function compileSchema(sch) {
		const _sch = getCompilingSchema.call(this, sch);
		if (_sch) return _sch;
		const rootId = (0, resolve_1$1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
		const { es5, lines } = this.opts.code;
		const { ownProperties } = this.opts;
		const gen = new codegen_1$25.CodeGen(this.scope, {
			es5,
			lines,
			ownProperties
		});
		let _ValidationError;
		if (sch.$async) _ValidationError = gen.scopeValue("Error", {
			ref: validation_error_1$2.default,
			code: (0, codegen_1$25._)`require("ajv/dist/runtime/validation_error").default`
		});
		const validateName = gen.scopeName("validate");
		sch.validateName = validateName;
		const schemaCxt = {
			gen,
			allErrors: this.opts.allErrors,
			data: names_1$2.default.data,
			parentData: names_1$2.default.parentData,
			parentDataProperty: names_1$2.default.parentDataProperty,
			dataNames: [names_1$2.default.data],
			dataPathArr: [codegen_1$25.nil],
			dataLevel: 0,
			dataTypes: [],
			definedProperties: /* @__PURE__ */ new Set(),
			topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? {
				ref: sch.schema,
				code: (0, codegen_1$25.stringify)(sch.schema)
			} : { ref: sch.schema }),
			validateName,
			ValidationError: _ValidationError,
			schema: sch.schema,
			schemaEnv: sch,
			rootId,
			baseId: sch.baseId || rootId,
			schemaPath: codegen_1$25.nil,
			errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
			errorPath: (0, codegen_1$25._)`""`,
			opts: this.opts,
			self: this
		};
		let sourceCode;
		try {
			this._compilations.add(sch);
			(0, validate_1$3.validateFunctionCode)(schemaCxt);
			gen.optimize(this.opts.code.optimize);
			const validateCode = gen.toString();
			sourceCode = `${gen.scopeRefs(names_1$2.default.scope)}return ${validateCode}`;
			if (this.opts.code.process) sourceCode = this.opts.code.process(sourceCode, sch);
			const validate$1 = new Function(`${names_1$2.default.self}`, `${names_1$2.default.scope}`, sourceCode)(this, this.scope.get());
			this.scope.value(validateName, { ref: validate$1 });
			validate$1.errors = null;
			validate$1.schema = sch.schema;
			validate$1.schemaEnv = sch;
			if (sch.$async) validate$1.$async = true;
			if (this.opts.code.source === true) validate$1.source = {
				validateName,
				validateCode,
				scopeValues: gen._values
			};
			if (this.opts.unevaluated) {
				const { props, items } = schemaCxt;
				validate$1.evaluated = {
					props: props instanceof codegen_1$25.Name ? void 0 : props,
					items: items instanceof codegen_1$25.Name ? void 0 : items,
					dynamicProps: props instanceof codegen_1$25.Name,
					dynamicItems: items instanceof codegen_1$25.Name
				};
				if (validate$1.source) validate$1.source.evaluated = (0, codegen_1$25.stringify)(validate$1.evaluated);
			}
			sch.validate = validate$1;
			return sch;
		} catch (e) {
			delete sch.validate;
			delete sch.validateName;
			if (sourceCode) this.logger.error("Error compiling schema, function code:", sourceCode);
			throw e;
		} finally {
			this._compilations.delete(sch);
		}
	}
	exports.compileSchema = compileSchema;
	function resolveRef(root, baseId, ref) {
		var _a$1;
		ref = (0, resolve_1$1.resolveUrl)(this.opts.uriResolver, baseId, ref);
		const schOrFunc = root.refs[ref];
		if (schOrFunc) return schOrFunc;
		let _sch = resolve$1.call(this, root, ref);
		if (_sch === void 0) {
			const schema$1 = (_a$1 = root.localRefs) === null || _a$1 === void 0 ? void 0 : _a$1[ref];
			const { schemaId } = this.opts;
			if (schema$1) _sch = new SchemaEnv({
				schema: schema$1,
				schemaId,
				root,
				baseId
			});
		}
		if (_sch === void 0) return;
		return root.refs[ref] = inlineOrCompile.call(this, _sch);
	}
	exports.resolveRef = resolveRef;
	function inlineOrCompile(sch) {
		if ((0, resolve_1$1.inlineRef)(sch.schema, this.opts.inlineRefs)) return sch.schema;
		return sch.validate ? sch : compileSchema.call(this, sch);
	}
	function getCompilingSchema(schEnv) {
		for (const sch of this._compilations) if (sameSchemaEnv(sch, schEnv)) return sch;
	}
	exports.getCompilingSchema = getCompilingSchema;
	function sameSchemaEnv(s1, s2) {
		return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
	}
	function resolve$1(root, ref) {
		let sch;
		while (typeof (sch = this.refs[ref]) == "string") ref = sch;
		return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
	}
	function resolveSchema(root, ref) {
		const p = this.opts.uriResolver.parse(ref);
		const refPath = (0, resolve_1$1._getFullPath)(this.opts.uriResolver, p);
		let baseId = (0, resolve_1$1.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
		if (Object.keys(root.schema).length > 0 && refPath === baseId) return getJsonPointer.call(this, p, root);
		const id = (0, resolve_1$1.normalizeId)(refPath);
		const schOrRef = this.refs[id] || this.schemas[id];
		if (typeof schOrRef == "string") {
			const sch = resolveSchema.call(this, root, schOrRef);
			if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object") return;
			return getJsonPointer.call(this, p, sch);
		}
		if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object") return;
		if (!schOrRef.validate) compileSchema.call(this, schOrRef);
		if (id === (0, resolve_1$1.normalizeId)(ref)) {
			const { schema: schema$1 } = schOrRef;
			const { schemaId } = this.opts;
			const schId = schema$1[schemaId];
			if (schId) baseId = (0, resolve_1$1.resolveUrl)(this.opts.uriResolver, baseId, schId);
			return new SchemaEnv({
				schema: schema$1,
				schemaId,
				root,
				baseId
			});
		}
		return getJsonPointer.call(this, p, schOrRef);
	}
	exports.resolveSchema = resolveSchema;
	const PREVENT_SCOPE_CHANGE = new Set([
		"properties",
		"patternProperties",
		"enum",
		"dependencies",
		"definitions"
	]);
	function getJsonPointer(parsedRef, { baseId, schema: schema$1, root }) {
		var _a$1;
		if (((_a$1 = parsedRef.fragment) === null || _a$1 === void 0 ? void 0 : _a$1[0]) !== "/") return;
		for (const part of parsedRef.fragment.slice(1).split("/")) {
			if (typeof schema$1 === "boolean") return;
			const partSchema = schema$1[(0, util_1$22.unescapeFragment)(part)];
			if (partSchema === void 0) return;
			schema$1 = partSchema;
			const schId = typeof schema$1 === "object" && schema$1[this.opts.schemaId];
			if (!PREVENT_SCOPE_CHANGE.has(part) && schId) baseId = (0, resolve_1$1.resolveUrl)(this.opts.uriResolver, baseId, schId);
		}
		let env;
		if (typeof schema$1 != "boolean" && schema$1.$ref && !(0, util_1$22.schemaHasRulesButRef)(schema$1, this.RULES)) {
			const $ref = (0, resolve_1$1.resolveUrl)(this.opts.uriResolver, baseId, schema$1.$ref);
			env = resolveSchema.call(this, root, $ref);
		}
		const { schemaId } = this.opts;
		env = env || new SchemaEnv({
			schema: schema$1,
			schemaId,
			root,
			baseId
		});
		if (env.schema !== env.root.schema) return env;
	}
}) });

//#endregion
//#region ../node_modules/ajv/dist/refs/data.json
var require_data = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/refs/data.json": ((exports, module) => {
	module.exports = {
		"$id": "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
		"description": "Meta-schema for $data reference (JSON AnySchema extension proposal)",
		"type": "object",
		"required": ["$data"],
		"properties": { "$data": {
			"type": "string",
			"anyOf": [{ "format": "relative-json-pointer" }, { "format": "json-pointer" }]
		} },
		"additionalProperties": false
	};
}) });

//#endregion
//#region ../node_modules/fast-uri/lib/utils.js
var require_utils = /* @__PURE__ */ __commonJS$2({ "../node_modules/fast-uri/lib/utils.js": ((exports, module) => {
	/** @type {(value: string) => boolean} */
	const isUUID$1 = RegExp.prototype.test.bind(/^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu);
	/** @type {(value: string) => boolean} */
	const isIPv4$1 = RegExp.prototype.test.bind(/^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u);
	/**
	* @param {Array<string>} input
	* @returns {string}
	*/
	function stringArrayToHexStripped(input) {
		let acc = "";
		let code = 0;
		let i = 0;
		for (i = 0; i < input.length; i++) {
			code = input[i].charCodeAt(0);
			if (code === 48) continue;
			if (!(code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102)) return "";
			acc += input[i];
			break;
		}
		for (i += 1; i < input.length; i++) {
			code = input[i].charCodeAt(0);
			if (!(code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102)) return "";
			acc += input[i];
		}
		return acc;
	}
	/**
	* @typedef {Object} GetIPV6Result
	* @property {boolean} error - Indicates if there was an error parsing the IPv6 address.
	* @property {string} address - The parsed IPv6 address.
	* @property {string} [zone] - The zone identifier, if present.
	*/
	/**
	* @param {string} value
	* @returns {boolean}
	*/
	const nonSimpleDomain$1 = RegExp.prototype.test.bind(/[^!"$&'()*+,\-.;=_`a-z{}~]/u);
	/**
	* @param {Array<string>} buffer
	* @returns {boolean}
	*/
	function consumeIsZone(buffer) {
		buffer.length = 0;
		return true;
	}
	/**
	* @param {Array<string>} buffer
	* @param {Array<string>} address
	* @param {GetIPV6Result} output
	* @returns {boolean}
	*/
	function consumeHextets(buffer, address, output) {
		if (buffer.length) {
			const hex = stringArrayToHexStripped(buffer);
			if (hex !== "") address.push(hex);
			else {
				output.error = true;
				return false;
			}
			buffer.length = 0;
		}
		return true;
	}
	/**
	* @param {string} input
	* @returns {GetIPV6Result}
	*/
	function getIPV6(input) {
		let tokenCount = 0;
		const output = {
			error: false,
			address: "",
			zone: ""
		};
		/** @type {Array<string>} */
		const address = [];
		/** @type {Array<string>} */
		const buffer = [];
		let endipv6Encountered = false;
		let endIpv6 = false;
		let consume = consumeHextets;
		for (let i = 0; i < input.length; i++) {
			const cursor = input[i];
			if (cursor === "[" || cursor === "]") continue;
			if (cursor === ":") {
				if (endipv6Encountered === true) endIpv6 = true;
				if (!consume(buffer, address, output)) break;
				if (++tokenCount > 7) {
					output.error = true;
					break;
				}
				if (i > 0 && input[i - 1] === ":") endipv6Encountered = true;
				address.push(":");
				continue;
			} else if (cursor === "%") {
				if (!consume(buffer, address, output)) break;
				consume = consumeIsZone;
			} else {
				buffer.push(cursor);
				continue;
			}
		}
		if (buffer.length) if (consume === consumeIsZone) output.zone = buffer.join("");
		else if (endIpv6) address.push(buffer.join(""));
		else address.push(stringArrayToHexStripped(buffer));
		output.address = address.join("");
		return output;
	}
	/**
	* @typedef {Object} NormalizeIPv6Result
	* @property {string} host - The normalized host.
	* @property {string} [escapedHost] - The escaped host.
	* @property {boolean} isIPV6 - Indicates if the host is an IPv6 address.
	*/
	/**
	* @param {string} host
	* @returns {NormalizeIPv6Result}
	*/
	function normalizeIPv6$1(host) {
		if (findToken(host, ":") < 2) return {
			host,
			isIPV6: false
		};
		const ipv6 = getIPV6(host);
		if (!ipv6.error) {
			let newHost = ipv6.address;
			let escapedHost = ipv6.address;
			if (ipv6.zone) {
				newHost += "%" + ipv6.zone;
				escapedHost += "%25" + ipv6.zone;
			}
			return {
				host: newHost,
				isIPV6: true,
				escapedHost
			};
		} else return {
			host,
			isIPV6: false
		};
	}
	/**
	* @param {string} str
	* @param {string} token
	* @returns {number}
	*/
	function findToken(str$1, token) {
		let ind = 0;
		for (let i = 0; i < str$1.length; i++) if (str$1[i] === token) ind++;
		return ind;
	}
	/**
	* @param {string} path
	* @returns {string}
	*
	* @see https://datatracker.ietf.org/doc/html/rfc3986#section-5.2.4
	*/
	function removeDotSegments$1(path) {
		let input = path;
		const output = [];
		let nextSlash = -1;
		let len = 0;
		while (len = input.length) {
			if (len === 1) if (input === ".") break;
			else if (input === "/") {
				output.push("/");
				break;
			} else {
				output.push(input);
				break;
			}
			else if (len === 2) {
				if (input[0] === ".") {
					if (input[1] === ".") break;
					else if (input[1] === "/") {
						input = input.slice(2);
						continue;
					}
				} else if (input[0] === "/") {
					if (input[1] === "." || input[1] === "/") {
						output.push("/");
						break;
					}
				}
			} else if (len === 3) {
				if (input === "/..") {
					if (output.length !== 0) output.pop();
					output.push("/");
					break;
				}
			}
			if (input[0] === ".") {
				if (input[1] === ".") {
					if (input[2] === "/") {
						input = input.slice(3);
						continue;
					}
				} else if (input[1] === "/") {
					input = input.slice(2);
					continue;
				}
			} else if (input[0] === "/") {
				if (input[1] === ".") {
					if (input[2] === "/") {
						input = input.slice(2);
						continue;
					} else if (input[2] === ".") {
						if (input[3] === "/") {
							input = input.slice(3);
							if (output.length !== 0) output.pop();
							continue;
						}
					}
				}
			}
			if ((nextSlash = input.indexOf("/", 1)) === -1) {
				output.push(input);
				break;
			} else {
				output.push(input.slice(0, nextSlash));
				input = input.slice(nextSlash);
			}
		}
		return output.join("");
	}
	/**
	* @param {import('../types/index').URIComponent} component
	* @param {boolean} esc
	* @returns {import('../types/index').URIComponent}
	*/
	function normalizeComponentEncoding$1(component, esc) {
		const func = esc !== true ? escape : unescape;
		if (component.scheme !== void 0) component.scheme = func(component.scheme);
		if (component.userinfo !== void 0) component.userinfo = func(component.userinfo);
		if (component.host !== void 0) component.host = func(component.host);
		if (component.path !== void 0) component.path = func(component.path);
		if (component.query !== void 0) component.query = func(component.query);
		if (component.fragment !== void 0) component.fragment = func(component.fragment);
		return component;
	}
	/**
	* @param {import('../types/index').URIComponent} component
	* @returns {string|undefined}
	*/
	function recomposeAuthority$1(component) {
		const uriTokens = [];
		if (component.userinfo !== void 0) {
			uriTokens.push(component.userinfo);
			uriTokens.push("@");
		}
		if (component.host !== void 0) {
			let host = unescape(component.host);
			if (!isIPv4$1(host)) {
				const ipV6res = normalizeIPv6$1(host);
				if (ipV6res.isIPV6 === true) host = `[${ipV6res.escapedHost}]`;
				else host = component.host;
			}
			uriTokens.push(host);
		}
		if (typeof component.port === "number" || typeof component.port === "string") {
			uriTokens.push(":");
			uriTokens.push(String(component.port));
		}
		return uriTokens.length ? uriTokens.join("") : void 0;
	}
	module.exports = {
		nonSimpleDomain: nonSimpleDomain$1,
		recomposeAuthority: recomposeAuthority$1,
		normalizeComponentEncoding: normalizeComponentEncoding$1,
		removeDotSegments: removeDotSegments$1,
		isIPv4: isIPv4$1,
		isUUID: isUUID$1,
		normalizeIPv6: normalizeIPv6$1,
		stringArrayToHexStripped
	};
}) });

//#endregion
//#region ../node_modules/fast-uri/lib/schemes.js
var require_schemes = /* @__PURE__ */ __commonJS$2({ "../node_modules/fast-uri/lib/schemes.js": ((exports, module) => {
	const { isUUID } = require_utils();
	const URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
	const supportedSchemeNames = [
		"http",
		"https",
		"ws",
		"wss",
		"urn",
		"urn:uuid"
	];
	/** @typedef {supportedSchemeNames[number]} SchemeName */
	/**
	* @param {string} name
	* @returns {name is SchemeName}
	*/
	function isValidSchemeName(name) {
		return supportedSchemeNames.indexOf(name) !== -1;
	}
	/**
	* @callback SchemeFn
	* @param {import('../types/index').URIComponent} component
	* @param {import('../types/index').Options} options
	* @returns {import('../types/index').URIComponent}
	*/
	/**
	* @typedef {Object} SchemeHandler
	* @property {SchemeName} scheme - The scheme name.
	* @property {boolean} [domainHost] - Indicates if the scheme supports domain hosts.
	* @property {SchemeFn} parse - Function to parse the URI component for this scheme.
	* @property {SchemeFn} serialize - Function to serialize the URI component for this scheme.
	* @property {boolean} [skipNormalize] - Indicates if normalization should be skipped for this scheme.
	* @property {boolean} [absolutePath] - Indicates if the scheme uses absolute paths.
	* @property {boolean} [unicodeSupport] - Indicates if the scheme supports Unicode.
	*/
	/**
	* @param {import('../types/index').URIComponent} wsComponent
	* @returns {boolean}
	*/
	function wsIsSecure(wsComponent) {
		if (wsComponent.secure === true) return true;
		else if (wsComponent.secure === false) return false;
		else if (wsComponent.scheme) return wsComponent.scheme.length === 3 && (wsComponent.scheme[0] === "w" || wsComponent.scheme[0] === "W") && (wsComponent.scheme[1] === "s" || wsComponent.scheme[1] === "S") && (wsComponent.scheme[2] === "s" || wsComponent.scheme[2] === "S");
		else return false;
	}
	/** @type {SchemeFn} */
	function httpParse(component) {
		if (!component.host) component.error = component.error || "HTTP URIs must have a host.";
		return component;
	}
	/** @type {SchemeFn} */
	function httpSerialize(component) {
		const secure = String(component.scheme).toLowerCase() === "https";
		if (component.port === (secure ? 443 : 80) || component.port === "") component.port = void 0;
		if (!component.path) component.path = "/";
		return component;
	}
	/** @type {SchemeFn} */
	function wsParse(wsComponent) {
		wsComponent.secure = wsIsSecure(wsComponent);
		wsComponent.resourceName = (wsComponent.path || "/") + (wsComponent.query ? "?" + wsComponent.query : "");
		wsComponent.path = void 0;
		wsComponent.query = void 0;
		return wsComponent;
	}
	/** @type {SchemeFn} */
	function wsSerialize(wsComponent) {
		if (wsComponent.port === (wsIsSecure(wsComponent) ? 443 : 80) || wsComponent.port === "") wsComponent.port = void 0;
		if (typeof wsComponent.secure === "boolean") {
			wsComponent.scheme = wsComponent.secure ? "wss" : "ws";
			wsComponent.secure = void 0;
		}
		if (wsComponent.resourceName) {
			const [path, query] = wsComponent.resourceName.split("?");
			wsComponent.path = path && path !== "/" ? path : void 0;
			wsComponent.query = query;
			wsComponent.resourceName = void 0;
		}
		wsComponent.fragment = void 0;
		return wsComponent;
	}
	/** @type {SchemeFn} */
	function urnParse(urnComponent, options) {
		if (!urnComponent.path) {
			urnComponent.error = "URN can not be parsed";
			return urnComponent;
		}
		const matches = urnComponent.path.match(URN_REG);
		if (matches) {
			const scheme = options.scheme || urnComponent.scheme || "urn";
			urnComponent.nid = matches[1].toLowerCase();
			urnComponent.nss = matches[2];
			const schemeHandler = getSchemeHandler$1(`${scheme}:${options.nid || urnComponent.nid}`);
			urnComponent.path = void 0;
			if (schemeHandler) urnComponent = schemeHandler.parse(urnComponent, options);
		} else urnComponent.error = urnComponent.error || "URN can not be parsed.";
		return urnComponent;
	}
	/** @type {SchemeFn} */
	function urnSerialize(urnComponent, options) {
		if (urnComponent.nid === void 0) throw new Error("URN without nid cannot be serialized");
		const scheme = options.scheme || urnComponent.scheme || "urn";
		const nid = urnComponent.nid.toLowerCase();
		const schemeHandler = getSchemeHandler$1(`${scheme}:${options.nid || nid}`);
		if (schemeHandler) urnComponent = schemeHandler.serialize(urnComponent, options);
		const uriComponent = urnComponent;
		const nss = urnComponent.nss;
		uriComponent.path = `${nid || options.nid}:${nss}`;
		options.skipEscape = true;
		return uriComponent;
	}
	/** @type {SchemeFn} */
	function urnuuidParse(urnComponent, options) {
		const uuidComponent = urnComponent;
		uuidComponent.uuid = uuidComponent.nss;
		uuidComponent.nss = void 0;
		if (!options.tolerant && (!uuidComponent.uuid || !isUUID(uuidComponent.uuid))) uuidComponent.error = uuidComponent.error || "UUID is not valid.";
		return uuidComponent;
	}
	/** @type {SchemeFn} */
	function urnuuidSerialize(uuidComponent) {
		const urnComponent = uuidComponent;
		urnComponent.nss = (uuidComponent.uuid || "").toLowerCase();
		return urnComponent;
	}
	const http = {
		scheme: "http",
		domainHost: true,
		parse: httpParse,
		serialize: httpSerialize
	};
	const https = {
		scheme: "https",
		domainHost: http.domainHost,
		parse: httpParse,
		serialize: httpSerialize
	};
	const ws = {
		scheme: "ws",
		domainHost: true,
		parse: wsParse,
		serialize: wsSerialize
	};
	const wss = {
		scheme: "wss",
		domainHost: ws.domainHost,
		parse: ws.parse,
		serialize: ws.serialize
	};
	const urn = {
		scheme: "urn",
		parse: urnParse,
		serialize: urnSerialize,
		skipNormalize: true
	};
	const urnuuid = {
		scheme: "urn:uuid",
		parse: urnuuidParse,
		serialize: urnuuidSerialize,
		skipNormalize: true
	};
	const SCHEMES$1 = {
		http,
		https,
		ws,
		wss,
		urn,
		"urn:uuid": urnuuid
	};
	Object.setPrototypeOf(SCHEMES$1, null);
	/**
	* @param {string|undefined} scheme
	* @returns {SchemeHandler|undefined}
	*/
	function getSchemeHandler$1(scheme) {
		return scheme && (SCHEMES$1[scheme] || SCHEMES$1[scheme.toLowerCase()]) || void 0;
	}
	module.exports = {
		wsIsSecure,
		SCHEMES: SCHEMES$1,
		isValidSchemeName,
		getSchemeHandler: getSchemeHandler$1
	};
}) });

//#endregion
//#region ../node_modules/fast-uri/index.js
var require_fast_uri = /* @__PURE__ */ __commonJS$2({ "../node_modules/fast-uri/index.js": ((exports, module) => {
	const { normalizeIPv6, removeDotSegments, recomposeAuthority, normalizeComponentEncoding, isIPv4, nonSimpleDomain } = require_utils();
	const { SCHEMES, getSchemeHandler } = require_schemes();
	/**
	* @template {import('./types/index').URIComponent|string} T
	* @param {T} uri
	* @param {import('./types/index').Options} [options]
	* @returns {T}
	*/
	function normalize(uri$1, options) {
		if (typeof uri$1 === "string") uri$1 = serialize(parse$1(uri$1, options), options);
		else if (typeof uri$1 === "object") uri$1 = parse$1(serialize(uri$1, options), options);
		return uri$1;
	}
	/**
	* @param {string} baseURI
	* @param {string} relativeURI
	* @param {import('./types/index').Options} [options]
	* @returns {string}
	*/
	function resolve(baseURI, relativeURI, options) {
		const schemelessOptions = options ? Object.assign({ scheme: "null" }, options) : { scheme: "null" };
		const resolved = resolveComponent(parse$1(baseURI, schemelessOptions), parse$1(relativeURI, schemelessOptions), schemelessOptions, true);
		schemelessOptions.skipEscape = true;
		return serialize(resolved, schemelessOptions);
	}
	/**
	* @param {import ('./types/index').URIComponent} base
	* @param {import ('./types/index').URIComponent} relative
	* @param {import('./types/index').Options} [options]
	* @param {boolean} [skipNormalization=false]
	* @returns {import ('./types/index').URIComponent}
	*/
	function resolveComponent(base, relative, options, skipNormalization) {
		/** @type {import('./types/index').URIComponent} */
		const target = {};
		if (!skipNormalization) {
			base = parse$1(serialize(base, options), options);
			relative = parse$1(serialize(relative, options), options);
		}
		options = options || {};
		if (!options.tolerant && relative.scheme) {
			target.scheme = relative.scheme;
			target.userinfo = relative.userinfo;
			target.host = relative.host;
			target.port = relative.port;
			target.path = removeDotSegments(relative.path || "");
			target.query = relative.query;
		} else {
			if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
				target.userinfo = relative.userinfo;
				target.host = relative.host;
				target.port = relative.port;
				target.path = removeDotSegments(relative.path || "");
				target.query = relative.query;
			} else {
				if (!relative.path) {
					target.path = base.path;
					if (relative.query !== void 0) target.query = relative.query;
					else target.query = base.query;
				} else {
					if (relative.path[0] === "/") target.path = removeDotSegments(relative.path);
					else {
						if ((base.userinfo !== void 0 || base.host !== void 0 || base.port !== void 0) && !base.path) target.path = "/" + relative.path;
						else if (!base.path) target.path = relative.path;
						else target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
						target.path = removeDotSegments(target.path);
					}
					target.query = relative.query;
				}
				target.userinfo = base.userinfo;
				target.host = base.host;
				target.port = base.port;
			}
			target.scheme = base.scheme;
		}
		target.fragment = relative.fragment;
		return target;
	}
	/**
	* @param {import ('./types/index').URIComponent|string} uriA
	* @param {import ('./types/index').URIComponent|string} uriB
	* @param {import ('./types/index').Options} options
	* @returns {boolean}
	*/
	function equal$1(uriA, uriB, options) {
		if (typeof uriA === "string") {
			uriA = unescape(uriA);
			uriA = serialize(normalizeComponentEncoding(parse$1(uriA, options), true), {
				...options,
				skipEscape: true
			});
		} else if (typeof uriA === "object") uriA = serialize(normalizeComponentEncoding(uriA, true), {
			...options,
			skipEscape: true
		});
		if (typeof uriB === "string") {
			uriB = unescape(uriB);
			uriB = serialize(normalizeComponentEncoding(parse$1(uriB, options), true), {
				...options,
				skipEscape: true
			});
		} else if (typeof uriB === "object") uriB = serialize(normalizeComponentEncoding(uriB, true), {
			...options,
			skipEscape: true
		});
		return uriA.toLowerCase() === uriB.toLowerCase();
	}
	/**
	* @param {Readonly<import('./types/index').URIComponent>} cmpts
	* @param {import('./types/index').Options} [opts]
	* @returns {string}
	*/
	function serialize(cmpts, opts) {
		const component = {
			host: cmpts.host,
			scheme: cmpts.scheme,
			userinfo: cmpts.userinfo,
			port: cmpts.port,
			path: cmpts.path,
			query: cmpts.query,
			nid: cmpts.nid,
			nss: cmpts.nss,
			uuid: cmpts.uuid,
			fragment: cmpts.fragment,
			reference: cmpts.reference,
			resourceName: cmpts.resourceName,
			secure: cmpts.secure,
			error: ""
		};
		const options = Object.assign({}, opts);
		const uriTokens = [];
		const schemeHandler = getSchemeHandler(options.scheme || component.scheme);
		if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(component, options);
		if (component.path !== void 0) if (!options.skipEscape) {
			component.path = escape(component.path);
			if (component.scheme !== void 0) component.path = component.path.split("%3A").join(":");
		} else component.path = unescape(component.path);
		if (options.reference !== "suffix" && component.scheme) uriTokens.push(component.scheme, ":");
		const authority = recomposeAuthority(component);
		if (authority !== void 0) {
			if (options.reference !== "suffix") uriTokens.push("//");
			uriTokens.push(authority);
			if (component.path && component.path[0] !== "/") uriTokens.push("/");
		}
		if (component.path !== void 0) {
			let s = component.path;
			if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) s = removeDotSegments(s);
			if (authority === void 0 && s[0] === "/" && s[1] === "/") s = "/%2F" + s.slice(2);
			uriTokens.push(s);
		}
		if (component.query !== void 0) uriTokens.push("?", component.query);
		if (component.fragment !== void 0) uriTokens.push("#", component.fragment);
		return uriTokens.join("");
	}
	const URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
	/**
	* @param {string} uri
	* @param {import('./types/index').Options} [opts]
	* @returns
	*/
	function parse$1(uri$1, opts) {
		const options = Object.assign({}, opts);
		/** @type {import('./types/index').URIComponent} */
		const parsed = {
			scheme: void 0,
			userinfo: void 0,
			host: "",
			port: void 0,
			path: "",
			query: void 0,
			fragment: void 0
		};
		let isIP = false;
		if (options.reference === "suffix") if (options.scheme) uri$1 = options.scheme + ":" + uri$1;
		else uri$1 = "//" + uri$1;
		const matches = uri$1.match(URI_PARSE);
		if (matches) {
			parsed.scheme = matches[1];
			parsed.userinfo = matches[3];
			parsed.host = matches[4];
			parsed.port = parseInt(matches[5], 10);
			parsed.path = matches[6] || "";
			parsed.query = matches[7];
			parsed.fragment = matches[8];
			if (isNaN(parsed.port)) parsed.port = matches[5];
			if (parsed.host) if (isIPv4(parsed.host) === false) {
				const ipv6result = normalizeIPv6(parsed.host);
				parsed.host = ipv6result.host.toLowerCase();
				isIP = ipv6result.isIPV6;
			} else isIP = true;
			if (parsed.scheme === void 0 && parsed.userinfo === void 0 && parsed.host === void 0 && parsed.port === void 0 && parsed.query === void 0 && !parsed.path) parsed.reference = "same-document";
			else if (parsed.scheme === void 0) parsed.reference = "relative";
			else if (parsed.fragment === void 0) parsed.reference = "absolute";
			else parsed.reference = "uri";
			if (options.reference && options.reference !== "suffix" && options.reference !== parsed.reference) parsed.error = parsed.error || "URI is not a " + options.reference + " reference.";
			const schemeHandler = getSchemeHandler(options.scheme || parsed.scheme);
			if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
				if (parsed.host && (options.domainHost || schemeHandler && schemeHandler.domainHost) && isIP === false && nonSimpleDomain(parsed.host)) try {
					parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
				} catch (e) {
					parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e;
				}
			}
			if (!schemeHandler || schemeHandler && !schemeHandler.skipNormalize) {
				if (uri$1.indexOf("%") !== -1) {
					if (parsed.scheme !== void 0) parsed.scheme = unescape(parsed.scheme);
					if (parsed.host !== void 0) parsed.host = unescape(parsed.host);
				}
				if (parsed.path) parsed.path = escape(unescape(parsed.path));
				if (parsed.fragment) parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment));
			}
			if (schemeHandler && schemeHandler.parse) schemeHandler.parse(parsed, options);
		} else parsed.error = parsed.error || "URI can not be parsed.";
		return parsed;
	}
	const fastUri = {
		SCHEMES,
		normalize,
		resolve,
		resolveComponent,
		equal: equal$1,
		serialize,
		parse: parse$1
	};
	module.exports = fastUri;
	module.exports.default = fastUri;
	module.exports.fastUri = fastUri;
}) });

//#endregion
//#region ../node_modules/ajv/dist/runtime/uri.js
var require_uri = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/runtime/uri.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const uri = require_fast_uri();
	uri.code = "require(\"ajv/dist/runtime/uri\").default";
	exports.default = uri;
}) });

//#endregion
//#region ../node_modules/ajv/dist/core.js
var require_core$1 = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/core.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
	var validate_1$2 = require_validate();
	Object.defineProperty(exports, "KeywordCxt", {
		enumerable: true,
		get: function() {
			return validate_1$2.KeywordCxt;
		}
	});
	var codegen_1$24 = require_codegen();
	Object.defineProperty(exports, "_", {
		enumerable: true,
		get: function() {
			return codegen_1$24._;
		}
	});
	Object.defineProperty(exports, "str", {
		enumerable: true,
		get: function() {
			return codegen_1$24.str;
		}
	});
	Object.defineProperty(exports, "stringify", {
		enumerable: true,
		get: function() {
			return codegen_1$24.stringify;
		}
	});
	Object.defineProperty(exports, "nil", {
		enumerable: true,
		get: function() {
			return codegen_1$24.nil;
		}
	});
	Object.defineProperty(exports, "Name", {
		enumerable: true,
		get: function() {
			return codegen_1$24.Name;
		}
	});
	Object.defineProperty(exports, "CodeGen", {
		enumerable: true,
		get: function() {
			return codegen_1$24.CodeGen;
		}
	});
	const validation_error_1$1 = require_validation_error();
	const ref_error_1$3 = require_ref_error();
	const rules_1 = require_rules();
	const compile_1$2 = require_compile();
	const codegen_2 = require_codegen();
	const resolve_1 = require_resolve();
	const dataType_1$1 = require_dataType();
	const util_1$21 = require_util();
	const $dataRefSchema = require_data();
	const uri_1 = require_uri();
	const defaultRegExp = (str$1, flags) => new RegExp(str$1, flags);
	defaultRegExp.code = "new RegExp";
	const META_IGNORE_OPTIONS = [
		"removeAdditional",
		"useDefaults",
		"coerceTypes"
	];
	const EXT_SCOPE_NAMES = new Set([
		"validate",
		"serialize",
		"parse",
		"wrapper",
		"root",
		"schema",
		"keyword",
		"pattern",
		"formats",
		"validate$data",
		"func",
		"obj",
		"Error"
	]);
	const removedOptions = {
		errorDataPath: "",
		format: "`validateFormats: false` can be used instead.",
		nullable: "\"nullable\" keyword is supported by default.",
		jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
		extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
		missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
		processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
		sourceCode: "Use option `code: {source: true}`",
		strictDefaults: "It is default now, see option `strict`.",
		strictKeywords: "It is default now, see option `strict`.",
		uniqueItems: "\"uniqueItems\" keyword is always validated.",
		unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
		cache: "Map is used as cache, schema object as key.",
		serialize: "Map is used as cache, schema object as key.",
		ajvErrors: "It is default now."
	};
	const deprecatedOptions = {
		ignoreKeywordsWithRef: "",
		jsPropertySyntax: "",
		unicode: "\"minLength\"/\"maxLength\" account for unicode characters by default."
	};
	const MAX_EXPRESSION = 200;
	function requiredOptions(o) {
		var _a$1, _b$1, _c$1, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
		const s = o.strict;
		const _optz = (_a$1 = o.code) === null || _a$1 === void 0 ? void 0 : _a$1.optimize;
		const optimize$1 = _optz === true || _optz === void 0 ? 1 : _optz || 0;
		const regExp = (_c$1 = (_b$1 = o.code) === null || _b$1 === void 0 ? void 0 : _b$1.regExp) !== null && _c$1 !== void 0 ? _c$1 : defaultRegExp;
		const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
		return {
			strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
			strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
			strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
			strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
			strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
			code: o.code ? {
				...o.code,
				optimize: optimize$1,
				regExp
			} : {
				optimize: optimize$1,
				regExp
			},
			loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
			loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
			meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
			messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
			inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
			schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
			addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
			validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
			validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
			unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
			int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
			uriResolver
		};
	}
	var Ajv$2 = class {
		constructor(opts = {}) {
			this.schemas = {};
			this.refs = {};
			this.formats = {};
			this._compilations = /* @__PURE__ */ new Set();
			this._loading = {};
			this._cache = /* @__PURE__ */ new Map();
			opts = this.opts = {
				...opts,
				...requiredOptions(opts)
			};
			const { es5, lines } = this.opts.code;
			this.scope = new codegen_2.ValueScope({
				scope: {},
				prefixes: EXT_SCOPE_NAMES,
				es5,
				lines
			});
			this.logger = getLogger(opts.logger);
			const formatOpt = opts.validateFormats;
			opts.validateFormats = false;
			this.RULES = (0, rules_1.getRules)();
			checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
			checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
			this._metaOpts = getMetaSchemaOptions.call(this);
			if (opts.formats) addInitialFormats.call(this);
			this._addVocabularies();
			this._addDefaultMetaSchema();
			if (opts.keywords) addInitialKeywords.call(this, opts.keywords);
			if (typeof opts.meta == "object") this.addMetaSchema(opts.meta);
			addInitialSchemas.call(this);
			opts.validateFormats = formatOpt;
		}
		_addVocabularies() {
			this.addKeyword("$async");
		}
		_addDefaultMetaSchema() {
			const { $data, meta, schemaId } = this.opts;
			let _dataRefSchema = $dataRefSchema;
			if (schemaId === "id") {
				_dataRefSchema = { ...$dataRefSchema };
				_dataRefSchema.id = _dataRefSchema.$id;
				delete _dataRefSchema.$id;
			}
			if (meta && $data) this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
		}
		defaultMeta() {
			const { meta, schemaId } = this.opts;
			return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : void 0;
		}
		validate(schemaKeyRef, data) {
			let v;
			if (typeof schemaKeyRef == "string") {
				v = this.getSchema(schemaKeyRef);
				if (!v) throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
			} else v = this.compile(schemaKeyRef);
			const valid = v(data);
			if (!("$async" in v)) this.errors = v.errors;
			return valid;
		}
		compile(schema$1, _meta) {
			const sch = this._addSchema(schema$1, _meta);
			return sch.validate || this._compileSchemaEnv(sch);
		}
		compileAsync(schema$1, meta) {
			if (typeof this.opts.loadSchema != "function") throw new Error("options.loadSchema should be a function");
			const { loadSchema } = this.opts;
			return runCompileAsync.call(this, schema$1, meta);
			async function runCompileAsync(_schema, _meta) {
				await loadMetaSchema.call(this, _schema.$schema);
				const sch = this._addSchema(_schema, _meta);
				return sch.validate || _compileAsync.call(this, sch);
			}
			async function loadMetaSchema($ref) {
				if ($ref && !this.getSchema($ref)) await runCompileAsync.call(this, { $ref }, true);
			}
			async function _compileAsync(sch) {
				try {
					return this._compileSchemaEnv(sch);
				} catch (e) {
					if (!(e instanceof ref_error_1$3.default)) throw e;
					checkLoaded.call(this, e);
					await loadMissingSchema.call(this, e.missingSchema);
					return _compileAsync.call(this, sch);
				}
			}
			function checkLoaded({ missingSchema: ref, missingRef }) {
				if (this.refs[ref]) throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
			}
			async function loadMissingSchema(ref) {
				const _schema = await _loadSchema.call(this, ref);
				if (!this.refs[ref]) await loadMetaSchema.call(this, _schema.$schema);
				if (!this.refs[ref]) this.addSchema(_schema, ref, meta);
			}
			async function _loadSchema(ref) {
				const p = this._loading[ref];
				if (p) return p;
				try {
					return await (this._loading[ref] = loadSchema(ref));
				} finally {
					delete this._loading[ref];
				}
			}
		}
		addSchema(schema$1, key, _meta, _validateSchema = this.opts.validateSchema) {
			if (Array.isArray(schema$1)) {
				for (const sch of schema$1) this.addSchema(sch, void 0, _meta, _validateSchema);
				return this;
			}
			let id;
			if (typeof schema$1 === "object") {
				const { schemaId } = this.opts;
				id = schema$1[schemaId];
				if (id !== void 0 && typeof id != "string") throw new Error(`schema ${schemaId} must be string`);
			}
			key = (0, resolve_1.normalizeId)(key || id);
			this._checkUnique(key);
			this.schemas[key] = this._addSchema(schema$1, _meta, key, _validateSchema, true);
			return this;
		}
		addMetaSchema(schema$1, key, _validateSchema = this.opts.validateSchema) {
			this.addSchema(schema$1, key, true, _validateSchema);
			return this;
		}
		validateSchema(schema$1, throwOrLogError) {
			if (typeof schema$1 == "boolean") return true;
			let $schema;
			$schema = schema$1.$schema;
			if ($schema !== void 0 && typeof $schema != "string") throw new Error("$schema must be a string");
			$schema = $schema || this.opts.defaultMeta || this.defaultMeta();
			if (!$schema) {
				this.logger.warn("meta-schema not available");
				this.errors = null;
				return true;
			}
			const valid = this.validate($schema, schema$1);
			if (!valid && throwOrLogError) {
				const message = "schema is invalid: " + this.errorsText();
				if (this.opts.validateSchema === "log") this.logger.error(message);
				else throw new Error(message);
			}
			return valid;
		}
		getSchema(keyRef) {
			let sch;
			while (typeof (sch = getSchEnv.call(this, keyRef)) == "string") keyRef = sch;
			if (sch === void 0) {
				const { schemaId } = this.opts;
				const root = new compile_1$2.SchemaEnv({
					schema: {},
					schemaId
				});
				sch = compile_1$2.resolveSchema.call(this, root, keyRef);
				if (!sch) return;
				this.refs[keyRef] = sch;
			}
			return sch.validate || this._compileSchemaEnv(sch);
		}
		removeSchema(schemaKeyRef) {
			if (schemaKeyRef instanceof RegExp) {
				this._removeAllSchemas(this.schemas, schemaKeyRef);
				this._removeAllSchemas(this.refs, schemaKeyRef);
				return this;
			}
			switch (typeof schemaKeyRef) {
				case "undefined":
					this._removeAllSchemas(this.schemas);
					this._removeAllSchemas(this.refs);
					this._cache.clear();
					return this;
				case "string": {
					const sch = getSchEnv.call(this, schemaKeyRef);
					if (typeof sch == "object") this._cache.delete(sch.schema);
					delete this.schemas[schemaKeyRef];
					delete this.refs[schemaKeyRef];
					return this;
				}
				case "object": {
					const cacheKey = schemaKeyRef;
					this._cache.delete(cacheKey);
					let id = schemaKeyRef[this.opts.schemaId];
					if (id) {
						id = (0, resolve_1.normalizeId)(id);
						delete this.schemas[id];
						delete this.refs[id];
					}
					return this;
				}
				default: throw new Error("ajv.removeSchema: invalid parameter");
			}
		}
		addVocabulary(definitions) {
			for (const def$30 of definitions) this.addKeyword(def$30);
			return this;
		}
		addKeyword(kwdOrDef, def$30) {
			let keyword;
			if (typeof kwdOrDef == "string") {
				keyword = kwdOrDef;
				if (typeof def$30 == "object") {
					this.logger.warn("these parameters are deprecated, see docs for addKeyword");
					def$30.keyword = keyword;
				}
			} else if (typeof kwdOrDef == "object" && def$30 === void 0) {
				def$30 = kwdOrDef;
				keyword = def$30.keyword;
				if (Array.isArray(keyword) && !keyword.length) throw new Error("addKeywords: keyword must be string or non-empty array");
			} else throw new Error("invalid addKeywords parameters");
			checkKeyword.call(this, keyword, def$30);
			if (!def$30) {
				(0, util_1$21.eachItem)(keyword, (kwd) => addRule.call(this, kwd));
				return this;
			}
			keywordMetaschema.call(this, def$30);
			const definition = {
				...def$30,
				type: (0, dataType_1$1.getJSONTypes)(def$30.type),
				schemaType: (0, dataType_1$1.getJSONTypes)(def$30.schemaType)
			};
			(0, util_1$21.eachItem)(keyword, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t$1) => addRule.call(this, k, definition, t$1)));
			return this;
		}
		getKeyword(keyword) {
			const rule = this.RULES.all[keyword];
			return typeof rule == "object" ? rule.definition : !!rule;
		}
		removeKeyword(keyword) {
			const { RULES } = this;
			delete RULES.keywords[keyword];
			delete RULES.all[keyword];
			for (const group of RULES.rules) {
				const i = group.rules.findIndex((rule) => rule.keyword === keyword);
				if (i >= 0) group.rules.splice(i, 1);
			}
			return this;
		}
		addFormat(name, format$1) {
			if (typeof format$1 == "string") format$1 = new RegExp(format$1);
			this.formats[name] = format$1;
			return this;
		}
		errorsText(errors$1 = this.errors, { separator = ", ", dataVar = "data" } = {}) {
			if (!errors$1 || errors$1.length === 0) return "No errors";
			return errors$1.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);
		}
		$dataMetaSchema(metaSchema, keywordsJsonPointers) {
			const rules = this.RULES.all;
			metaSchema = JSON.parse(JSON.stringify(metaSchema));
			for (const jsonPointer of keywordsJsonPointers) {
				const segments = jsonPointer.split("/").slice(1);
				let keywords$1 = metaSchema;
				for (const seg of segments) keywords$1 = keywords$1[seg];
				for (const key in rules) {
					const rule = rules[key];
					if (typeof rule != "object") continue;
					const { $data } = rule.definition;
					const schema$1 = keywords$1[key];
					if ($data && schema$1) keywords$1[key] = schemaOrData(schema$1);
				}
			}
			return metaSchema;
		}
		_removeAllSchemas(schemas$1, regex) {
			for (const keyRef in schemas$1) {
				const sch = schemas$1[keyRef];
				if (!regex || regex.test(keyRef)) {
					if (typeof sch == "string") delete schemas$1[keyRef];
					else if (sch && !sch.meta) {
						this._cache.delete(sch.schema);
						delete schemas$1[keyRef];
					}
				}
			}
		}
		_addSchema(schema$1, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
			let id;
			const { schemaId } = this.opts;
			if (typeof schema$1 == "object") id = schema$1[schemaId];
			else if (this.opts.jtd) throw new Error("schema must be object");
			else if (typeof schema$1 != "boolean") throw new Error("schema must be object or boolean");
			let sch = this._cache.get(schema$1);
			if (sch !== void 0) return sch;
			baseId = (0, resolve_1.normalizeId)(id || baseId);
			const localRefs = resolve_1.getSchemaRefs.call(this, schema$1, baseId);
			sch = new compile_1$2.SchemaEnv({
				schema: schema$1,
				schemaId,
				meta,
				baseId,
				localRefs
			});
			this._cache.set(sch.schema, sch);
			if (addSchema && !baseId.startsWith("#")) {
				if (baseId) this._checkUnique(baseId);
				this.refs[baseId] = sch;
			}
			if (validateSchema) this.validateSchema(schema$1, true);
			return sch;
		}
		_checkUnique(id) {
			if (this.schemas[id] || this.refs[id]) throw new Error(`schema with key or id "${id}" already exists`);
		}
		_compileSchemaEnv(sch) {
			if (sch.meta) this._compileMetaSchema(sch);
			else compile_1$2.compileSchema.call(this, sch);
			/* istanbul ignore if */
			if (!sch.validate) throw new Error("ajv implementation error");
			return sch.validate;
		}
		_compileMetaSchema(sch) {
			const currentOpts = this.opts;
			this.opts = this._metaOpts;
			try {
				compile_1$2.compileSchema.call(this, sch);
			} finally {
				this.opts = currentOpts;
			}
		}
	};
	Ajv$2.ValidationError = validation_error_1$1.default;
	Ajv$2.MissingRefError = ref_error_1$3.default;
	exports.default = Ajv$2;
	function checkOptions(checkOpts, options, msg, log = "error") {
		for (const key in checkOpts) {
			const opt = key;
			if (opt in options) this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
		}
	}
	function getSchEnv(keyRef) {
		keyRef = (0, resolve_1.normalizeId)(keyRef);
		return this.schemas[keyRef] || this.refs[keyRef];
	}
	function addInitialSchemas() {
		const optsSchemas = this.opts.schemas;
		if (!optsSchemas) return;
		if (Array.isArray(optsSchemas)) this.addSchema(optsSchemas);
		else for (const key in optsSchemas) this.addSchema(optsSchemas[key], key);
	}
	function addInitialFormats() {
		for (const name in this.opts.formats) {
			const format$1 = this.opts.formats[name];
			if (format$1) this.addFormat(name, format$1);
		}
	}
	function addInitialKeywords(defs) {
		if (Array.isArray(defs)) {
			this.addVocabulary(defs);
			return;
		}
		this.logger.warn("keywords option as map is deprecated, pass array");
		for (const keyword in defs) {
			const def$30 = defs[keyword];
			if (!def$30.keyword) def$30.keyword = keyword;
			this.addKeyword(def$30);
		}
	}
	function getMetaSchemaOptions() {
		const metaOpts = { ...this.opts };
		for (const opt of META_IGNORE_OPTIONS) delete metaOpts[opt];
		return metaOpts;
	}
	const noLogs = {
		log() {},
		warn() {},
		error() {}
	};
	function getLogger(logger) {
		if (logger === false) return noLogs;
		if (logger === void 0) return console;
		if (logger.log && logger.warn && logger.error) return logger;
		throw new Error("logger must implement log, warn and error methods");
	}
	const KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
	function checkKeyword(keyword, def$30) {
		const { RULES } = this;
		(0, util_1$21.eachItem)(keyword, (kwd) => {
			if (RULES.keywords[kwd]) throw new Error(`Keyword ${kwd} is already defined`);
			if (!KEYWORD_NAME.test(kwd)) throw new Error(`Keyword ${kwd} has invalid name`);
		});
		if (!def$30) return;
		if (def$30.$data && !("code" in def$30 || "validate" in def$30)) throw new Error("$data keyword must have \"code\" or \"validate\" function");
	}
	function addRule(keyword, definition, dataType) {
		var _a$1;
		const post = definition === null || definition === void 0 ? void 0 : definition.post;
		if (dataType && post) throw new Error("keyword with \"post\" flag cannot have \"type\"");
		const { RULES } = this;
		let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t$1 }) => t$1 === dataType);
		if (!ruleGroup) {
			ruleGroup = {
				type: dataType,
				rules: []
			};
			RULES.rules.push(ruleGroup);
		}
		RULES.keywords[keyword] = true;
		if (!definition) return;
		const rule = {
			keyword,
			definition: {
				...definition,
				type: (0, dataType_1$1.getJSONTypes)(definition.type),
				schemaType: (0, dataType_1$1.getJSONTypes)(definition.schemaType)
			}
		};
		if (definition.before) addBeforeRule.call(this, ruleGroup, rule, definition.before);
		else ruleGroup.rules.push(rule);
		RULES.all[keyword] = rule;
		(_a$1 = definition.implements) === null || _a$1 === void 0 || _a$1.forEach((kwd) => this.addKeyword(kwd));
	}
	function addBeforeRule(ruleGroup, rule, before) {
		const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
		if (i >= 0) ruleGroup.rules.splice(i, 0, rule);
		else {
			ruleGroup.rules.push(rule);
			this.logger.warn(`rule ${before} is not defined`);
		}
	}
	function keywordMetaschema(def$30) {
		let { metaSchema } = def$30;
		if (metaSchema === void 0) return;
		if (def$30.$data && this.opts.$data) metaSchema = schemaOrData(metaSchema);
		def$30.validateSchema = this.compile(metaSchema, true);
	}
	const $dataRef = { $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" };
	function schemaOrData(schema$1) {
		return { anyOf: [schema$1, $dataRef] };
	}
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/core/id.js
var require_id = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/core/id.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const def$29 = {
		keyword: "id",
		code() {
			throw new Error("NOT SUPPORTED: keyword \"id\", use \"$id\" for schema ID");
		}
	};
	exports.default = def$29;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/core/ref.js
var require_ref = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/core/ref.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const ref_error_1$2 = require_ref_error();
	const code_1$8 = require_code();
	const codegen_1$23 = require_codegen();
	const names_1$1 = require_names();
	const compile_1$1 = require_compile();
	const util_1$20 = require_util();
	const def$28 = {
		keyword: "$ref",
		schemaType: "string",
		code(cxt) {
			const { gen, schema: $ref, it } = cxt;
			const { baseId, schemaEnv: env, validateName, opts, self } = it;
			const { root } = env;
			if (($ref === "#" || $ref === "#/") && baseId === root.baseId) return callRootRef();
			const schOrEnv = compile_1$1.resolveRef.call(self, root, baseId, $ref);
			if (schOrEnv === void 0) throw new ref_error_1$2.default(it.opts.uriResolver, baseId, $ref);
			if (schOrEnv instanceof compile_1$1.SchemaEnv) return callValidate(schOrEnv);
			return inlineRefSchema(schOrEnv);
			function callRootRef() {
				if (env === root) return callRef(cxt, validateName, env, env.$async);
				const rootName = gen.scopeValue("root", { ref: root });
				return callRef(cxt, (0, codegen_1$23._)`${rootName}.validate`, root, root.$async);
			}
			function callValidate(sch) {
				callRef(cxt, getValidate(cxt, sch), sch, sch.$async);
			}
			function inlineRefSchema(sch) {
				const schName = gen.scopeValue("schema", opts.code.source === true ? {
					ref: sch,
					code: (0, codegen_1$23.stringify)(sch)
				} : { ref: sch });
				const valid = gen.name("valid");
				const schCxt = cxt.subschema({
					schema: sch,
					dataTypes: [],
					schemaPath: codegen_1$23.nil,
					topSchemaRef: schName,
					errSchemaPath: $ref
				}, valid);
				cxt.mergeEvaluated(schCxt);
				cxt.ok(valid);
			}
		}
	};
	function getValidate(cxt, sch) {
		const { gen } = cxt;
		return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1$23._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
	}
	exports.getValidate = getValidate;
	function callRef(cxt, v, sch, $async) {
		const { gen, it } = cxt;
		const { allErrors, schemaEnv: env, opts } = it;
		const passCxt = opts.passContext ? names_1$1.default.this : codegen_1$23.nil;
		if ($async) callAsyncRef();
		else callSyncRef();
		function callAsyncRef() {
			if (!env.$async) throw new Error("async schema referenced by sync schema");
			const valid = gen.let("valid");
			gen.try(() => {
				gen.code((0, codegen_1$23._)`await ${(0, code_1$8.callValidateCode)(cxt, v, passCxt)}`);
				addEvaluatedFrom(v);
				if (!allErrors) gen.assign(valid, true);
			}, (e) => {
				gen.if((0, codegen_1$23._)`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
				addErrorsFrom(e);
				if (!allErrors) gen.assign(valid, false);
			});
			cxt.ok(valid);
		}
		function callSyncRef() {
			cxt.result((0, code_1$8.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
		}
		function addErrorsFrom(source) {
			const errs = (0, codegen_1$23._)`${source}.errors`;
			gen.assign(names_1$1.default.vErrors, (0, codegen_1$23._)`${names_1$1.default.vErrors} === null ? ${errs} : ${names_1$1.default.vErrors}.concat(${errs})`);
			gen.assign(names_1$1.default.errors, (0, codegen_1$23._)`${names_1$1.default.vErrors}.length`);
		}
		function addEvaluatedFrom(source) {
			var _a$1;
			if (!it.opts.unevaluated) return;
			const schEvaluated = (_a$1 = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a$1 === void 0 ? void 0 : _a$1.evaluated;
			if (it.props !== true) if (schEvaluated && !schEvaluated.dynamicProps) {
				if (schEvaluated.props !== void 0) it.props = util_1$20.mergeEvaluated.props(gen, schEvaluated.props, it.props);
			} else {
				const props = gen.var("props", (0, codegen_1$23._)`${source}.evaluated.props`);
				it.props = util_1$20.mergeEvaluated.props(gen, props, it.props, codegen_1$23.Name);
			}
			if (it.items !== true) if (schEvaluated && !schEvaluated.dynamicItems) {
				if (schEvaluated.items !== void 0) it.items = util_1$20.mergeEvaluated.items(gen, schEvaluated.items, it.items);
			} else {
				const items = gen.var("items", (0, codegen_1$23._)`${source}.evaluated.items`);
				it.items = util_1$20.mergeEvaluated.items(gen, items, it.items, codegen_1$23.Name);
			}
		}
	}
	exports.callRef = callRef;
	exports.default = def$28;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/core/index.js
var require_core = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/core/index.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const id_1 = require_id();
	const ref_1 = require_ref();
	const core = [
		"$schema",
		"$id",
		"$defs",
		"$vocabulary",
		{ keyword: "$comment" },
		"definitions",
		id_1.default,
		ref_1.default
	];
	exports.default = core;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/validation/limitNumber.js
var require_limitNumber = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/validation/limitNumber.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$22 = require_codegen();
	const ops = codegen_1$22.operators;
	const KWDs = {
		maximum: {
			okStr: "<=",
			ok: ops.LTE,
			fail: ops.GT
		},
		minimum: {
			okStr: ">=",
			ok: ops.GTE,
			fail: ops.LT
		},
		exclusiveMaximum: {
			okStr: "<",
			ok: ops.LT,
			fail: ops.GTE
		},
		exclusiveMinimum: {
			okStr: ">",
			ok: ops.GT,
			fail: ops.LTE
		}
	};
	const def$27 = {
		keyword: Object.keys(KWDs),
		type: "number",
		schemaType: "number",
		$data: true,
		error: {
			message: ({ keyword, schemaCode }) => (0, codegen_1$22.str)`must be ${KWDs[keyword].okStr} ${schemaCode}`,
			params: ({ keyword, schemaCode }) => (0, codegen_1$22._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
		},
		code(cxt) {
			const { keyword, data, schemaCode } = cxt;
			cxt.fail$data((0, codegen_1$22._)`${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
		}
	};
	exports.default = def$27;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/validation/multipleOf.js
var require_multipleOf = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/validation/multipleOf.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$21 = require_codegen();
	const def$26 = {
		keyword: "multipleOf",
		type: "number",
		schemaType: "number",
		$data: true,
		error: {
			message: ({ schemaCode }) => (0, codegen_1$21.str)`must be multiple of ${schemaCode}`,
			params: ({ schemaCode }) => (0, codegen_1$21._)`{multipleOf: ${schemaCode}}`
		},
		code(cxt) {
			const { gen, data, schemaCode, it } = cxt;
			const prec = it.opts.multipleOfPrecision;
			const res = gen.let("res");
			const invalid = prec ? (0, codegen_1$21._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1$21._)`${res} !== parseInt(${res})`;
			cxt.fail$data((0, codegen_1$21._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
		}
	};
	exports.default = def$26;
}) });

//#endregion
//#region ../node_modules/ajv/dist/runtime/ucs2length.js
var require_ucs2length = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/runtime/ucs2length.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	function ucs2length(str$1) {
		const len = str$1.length;
		let length = 0;
		let pos = 0;
		let value;
		while (pos < len) {
			length++;
			value = str$1.charCodeAt(pos++);
			if (value >= 55296 && value <= 56319 && pos < len) {
				value = str$1.charCodeAt(pos);
				if ((value & 64512) === 56320) pos++;
			}
		}
		return length;
	}
	exports.default = ucs2length;
	ucs2length.code = "require(\"ajv/dist/runtime/ucs2length\").default";
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/validation/limitLength.js
var require_limitLength = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/validation/limitLength.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$20 = require_codegen();
	const util_1$19 = require_util();
	const ucs2length_1 = require_ucs2length();
	const def$25 = {
		keyword: ["maxLength", "minLength"],
		type: "string",
		schemaType: "number",
		$data: true,
		error: {
			message({ keyword, schemaCode }) {
				const comp = keyword === "maxLength" ? "more" : "fewer";
				return (0, codegen_1$20.str)`must NOT have ${comp} than ${schemaCode} characters`;
			},
			params: ({ schemaCode }) => (0, codegen_1$20._)`{limit: ${schemaCode}}`
		},
		code(cxt) {
			const { keyword, data, schemaCode, it } = cxt;
			const op = keyword === "maxLength" ? codegen_1$20.operators.GT : codegen_1$20.operators.LT;
			const len = it.opts.unicode === false ? (0, codegen_1$20._)`${data}.length` : (0, codegen_1$20._)`${(0, util_1$19.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
			cxt.fail$data((0, codegen_1$20._)`${len} ${op} ${schemaCode}`);
		}
	};
	exports.default = def$25;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/validation/pattern.js
var require_pattern = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/validation/pattern.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const code_1$7 = require_code();
	const codegen_1$19 = require_codegen();
	const def$24 = {
		keyword: "pattern",
		type: "string",
		schemaType: "string",
		$data: true,
		error: {
			message: ({ schemaCode }) => (0, codegen_1$19.str)`must match pattern "${schemaCode}"`,
			params: ({ schemaCode }) => (0, codegen_1$19._)`{pattern: ${schemaCode}}`
		},
		code(cxt) {
			const { data, $data, schema: schema$1, schemaCode, it } = cxt;
			const u = it.opts.unicodeRegExp ? "u" : "";
			const regExp = $data ? (0, codegen_1$19._)`(new RegExp(${schemaCode}, ${u}))` : (0, code_1$7.usePattern)(cxt, schema$1);
			cxt.fail$data((0, codegen_1$19._)`!${regExp}.test(${data})`);
		}
	};
	exports.default = def$24;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/validation/limitProperties.js
var require_limitProperties = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/validation/limitProperties.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$18 = require_codegen();
	const def$23 = {
		keyword: ["maxProperties", "minProperties"],
		type: "object",
		schemaType: "number",
		$data: true,
		error: {
			message({ keyword, schemaCode }) {
				const comp = keyword === "maxProperties" ? "more" : "fewer";
				return (0, codegen_1$18.str)`must NOT have ${comp} than ${schemaCode} properties`;
			},
			params: ({ schemaCode }) => (0, codegen_1$18._)`{limit: ${schemaCode}}`
		},
		code(cxt) {
			const { keyword, data, schemaCode } = cxt;
			const op = keyword === "maxProperties" ? codegen_1$18.operators.GT : codegen_1$18.operators.LT;
			cxt.fail$data((0, codegen_1$18._)`Object.keys(${data}).length ${op} ${schemaCode}`);
		}
	};
	exports.default = def$23;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/validation/required.js
var require_required = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/validation/required.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const code_1$6 = require_code();
	const codegen_1$17 = require_codegen();
	const util_1$18 = require_util();
	const def$22 = {
		keyword: "required",
		type: "object",
		schemaType: "array",
		$data: true,
		error: {
			message: ({ params: { missingProperty } }) => (0, codegen_1$17.str)`must have required property '${missingProperty}'`,
			params: ({ params: { missingProperty } }) => (0, codegen_1$17._)`{missingProperty: ${missingProperty}}`
		},
		code(cxt) {
			const { gen, schema: schema$1, schemaCode, data, $data, it } = cxt;
			const { opts } = it;
			if (!$data && schema$1.length === 0) return;
			const useLoop = schema$1.length >= opts.loopRequired;
			if (it.allErrors) allErrorsMode();
			else exitOnErrorMode();
			if (opts.strictRequired) {
				const props = cxt.parentSchema.properties;
				const { definedProperties } = cxt.it;
				for (const requiredKey of schema$1) if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
					const msg = `required property "${requiredKey}" is not defined at "${it.schemaEnv.baseId + it.errSchemaPath}" (strictRequired)`;
					(0, util_1$18.checkStrictMode)(it, msg, it.opts.strictRequired);
				}
			}
			function allErrorsMode() {
				if (useLoop || $data) cxt.block$data(codegen_1$17.nil, loopAllRequired);
				else for (const prop of schema$1) (0, code_1$6.checkReportMissingProp)(cxt, prop);
			}
			function exitOnErrorMode() {
				const missing = gen.let("missing");
				if (useLoop || $data) {
					const valid = gen.let("valid", true);
					cxt.block$data(valid, () => loopUntilMissing(missing, valid));
					cxt.ok(valid);
				} else {
					gen.if((0, code_1$6.checkMissingProp)(cxt, schema$1, missing));
					(0, code_1$6.reportMissingProp)(cxt, missing);
					gen.else();
				}
			}
			function loopAllRequired() {
				gen.forOf("prop", schemaCode, (prop) => {
					cxt.setParams({ missingProperty: prop });
					gen.if((0, code_1$6.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
				});
			}
			function loopUntilMissing(missing, valid) {
				cxt.setParams({ missingProperty: missing });
				gen.forOf(missing, schemaCode, () => {
					gen.assign(valid, (0, code_1$6.propertyInData)(gen, data, missing, opts.ownProperties));
					gen.if((0, codegen_1$17.not)(valid), () => {
						cxt.error();
						gen.break();
					});
				}, codegen_1$17.nil);
			}
		}
	};
	exports.default = def$22;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/validation/limitItems.js
var require_limitItems = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/validation/limitItems.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$16 = require_codegen();
	const def$21 = {
		keyword: ["maxItems", "minItems"],
		type: "array",
		schemaType: "number",
		$data: true,
		error: {
			message({ keyword, schemaCode }) {
				const comp = keyword === "maxItems" ? "more" : "fewer";
				return (0, codegen_1$16.str)`must NOT have ${comp} than ${schemaCode} items`;
			},
			params: ({ schemaCode }) => (0, codegen_1$16._)`{limit: ${schemaCode}}`
		},
		code(cxt) {
			const { keyword, data, schemaCode } = cxt;
			const op = keyword === "maxItems" ? codegen_1$16.operators.GT : codegen_1$16.operators.LT;
			cxt.fail$data((0, codegen_1$16._)`${data}.length ${op} ${schemaCode}`);
		}
	};
	exports.default = def$21;
}) });

//#endregion
//#region ../node_modules/ajv/dist/runtime/equal.js
var require_equal = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/runtime/equal.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const equal = require_fast_deep_equal();
	equal.code = "require(\"ajv/dist/runtime/equal\").default";
	exports.default = equal;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/validation/uniqueItems.js
var require_uniqueItems = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/validation/uniqueItems.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const dataType_1 = require_dataType();
	const codegen_1$15 = require_codegen();
	const util_1$17 = require_util();
	const equal_1$2 = require_equal();
	const def$20 = {
		keyword: "uniqueItems",
		type: "array",
		schemaType: "boolean",
		$data: true,
		error: {
			message: ({ params: { i, j } }) => (0, codegen_1$15.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
			params: ({ params: { i, j } }) => (0, codegen_1$15._)`{i: ${i}, j: ${j}}`
		},
		code(cxt) {
			const { gen, data, $data, schema: schema$1, parentSchema, schemaCode, it } = cxt;
			if (!$data && !schema$1) return;
			const valid = gen.let("valid");
			const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
			cxt.block$data(valid, validateUniqueItems, (0, codegen_1$15._)`${schemaCode} === false`);
			cxt.ok(valid);
			function validateUniqueItems() {
				const i = gen.let("i", (0, codegen_1$15._)`${data}.length`);
				const j = gen.let("j");
				cxt.setParams({
					i,
					j
				});
				gen.assign(valid, true);
				gen.if((0, codegen_1$15._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
			}
			function canOptimize() {
				return itemTypes.length > 0 && !itemTypes.some((t$1) => t$1 === "object" || t$1 === "array");
			}
			function loopN(i, j) {
				const item = gen.name("item");
				const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
				const indices = gen.const("indices", (0, codegen_1$15._)`{}`);
				gen.for((0, codegen_1$15._)`;${i}--;`, () => {
					gen.let(item, (0, codegen_1$15._)`${data}[${i}]`);
					gen.if(wrongType, (0, codegen_1$15._)`continue`);
					if (itemTypes.length > 1) gen.if((0, codegen_1$15._)`typeof ${item} == "string"`, (0, codegen_1$15._)`${item} += "_"`);
					gen.if((0, codegen_1$15._)`typeof ${indices}[${item}] == "number"`, () => {
						gen.assign(j, (0, codegen_1$15._)`${indices}[${item}]`);
						cxt.error();
						gen.assign(valid, false).break();
					}).code((0, codegen_1$15._)`${indices}[${item}] = ${i}`);
				});
			}
			function loopN2(i, j) {
				const eql = (0, util_1$17.useFunc)(gen, equal_1$2.default);
				const outer = gen.name("outer");
				gen.label(outer).for((0, codegen_1$15._)`;${i}--;`, () => gen.for((0, codegen_1$15._)`${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1$15._)`${eql}(${data}[${i}], ${data}[${j}])`, () => {
					cxt.error();
					gen.assign(valid, false).break(outer);
				})));
			}
		}
	};
	exports.default = def$20;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/validation/const.js
var require_const = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/validation/const.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$14 = require_codegen();
	const util_1$16 = require_util();
	const equal_1$1 = require_equal();
	const def$19 = {
		keyword: "const",
		$data: true,
		error: {
			message: "must be equal to constant",
			params: ({ schemaCode }) => (0, codegen_1$14._)`{allowedValue: ${schemaCode}}`
		},
		code(cxt) {
			const { gen, data, $data, schemaCode, schema: schema$1 } = cxt;
			if ($data || schema$1 && typeof schema$1 == "object") cxt.fail$data((0, codegen_1$14._)`!${(0, util_1$16.useFunc)(gen, equal_1$1.default)}(${data}, ${schemaCode})`);
			else cxt.fail((0, codegen_1$14._)`${schema$1} !== ${data}`);
		}
	};
	exports.default = def$19;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/validation/enum.js
var require_enum = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/validation/enum.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$13 = require_codegen();
	const util_1$15 = require_util();
	const equal_1 = require_equal();
	const def$18 = {
		keyword: "enum",
		schemaType: "array",
		$data: true,
		error: {
			message: "must be equal to one of the allowed values",
			params: ({ schemaCode }) => (0, codegen_1$13._)`{allowedValues: ${schemaCode}}`
		},
		code(cxt) {
			const { gen, data, $data, schema: schema$1, schemaCode, it } = cxt;
			if (!$data && schema$1.length === 0) throw new Error("enum must have non-empty array");
			const useLoop = schema$1.length >= it.opts.loopEnum;
			let eql;
			const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1$15.useFunc)(gen, equal_1.default);
			let valid;
			if (useLoop || $data) {
				valid = gen.let("valid");
				cxt.block$data(valid, loopEnum);
			} else {
				/* istanbul ignore if */
				if (!Array.isArray(schema$1)) throw new Error("ajv implementation error");
				const vSchema = gen.const("vSchema", schemaCode);
				valid = (0, codegen_1$13.or)(...schema$1.map((_x, i) => equalCode(vSchema, i)));
			}
			cxt.pass(valid);
			function loopEnum() {
				gen.assign(valid, false);
				gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1$13._)`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));
			}
			function equalCode(vSchema, i) {
				const sch = schema$1[i];
				return typeof sch === "object" && sch !== null ? (0, codegen_1$13._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1$13._)`${data} === ${sch}`;
			}
		}
	};
	exports.default = def$18;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/validation/index.js
var require_validation = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/validation/index.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const limitNumber_1 = require_limitNumber();
	const multipleOf_1 = require_multipleOf();
	const limitLength_1 = require_limitLength();
	const pattern_1 = require_pattern();
	const limitProperties_1 = require_limitProperties();
	const required_1 = require_required();
	const limitItems_1 = require_limitItems();
	const uniqueItems_1 = require_uniqueItems();
	const const_1 = require_const();
	const enum_1 = require_enum();
	const validation = [
		limitNumber_1.default,
		multipleOf_1.default,
		limitLength_1.default,
		pattern_1.default,
		limitProperties_1.default,
		required_1.default,
		limitItems_1.default,
		uniqueItems_1.default,
		{
			keyword: "type",
			schemaType: ["string", "array"]
		},
		{
			keyword: "nullable",
			schemaType: "boolean"
		},
		const_1.default,
		enum_1.default
	];
	exports.default = validation;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/applicator/additionalItems.js
var require_additionalItems = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/applicator/additionalItems.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$12 = require_codegen();
	const util_1$14 = require_util();
	const def$17 = {
		keyword: "additionalItems",
		type: "array",
		schemaType: ["boolean", "object"],
		before: "uniqueItems",
		error: {
			message: ({ params: { len } }) => (0, codegen_1$12.str)`must NOT have more than ${len} items`,
			params: ({ params: { len } }) => (0, codegen_1$12._)`{limit: ${len}}`
		},
		code(cxt) {
			const { parentSchema, it } = cxt;
			const { items } = parentSchema;
			if (!Array.isArray(items)) {
				(0, util_1$14.checkStrictMode)(it, "\"additionalItems\" is ignored when \"items\" is not an array of schemas");
				return;
			}
			validateAdditionalItems(cxt, items);
		}
	};
	function validateAdditionalItems(cxt, items) {
		const { gen, schema: schema$1, data, keyword, it } = cxt;
		it.items = true;
		const len = gen.const("len", (0, codegen_1$12._)`${data}.length`);
		if (schema$1 === false) {
			cxt.setParams({ len: items.length });
			cxt.pass((0, codegen_1$12._)`${len} <= ${items.length}`);
		} else if (typeof schema$1 == "object" && !(0, util_1$14.alwaysValidSchema)(it, schema$1)) {
			const valid = gen.var("valid", (0, codegen_1$12._)`${len} <= ${items.length}`);
			gen.if((0, codegen_1$12.not)(valid), () => validateItems(valid));
			cxt.ok(valid);
		}
		function validateItems(valid) {
			gen.forRange("i", items.length, len, (i) => {
				cxt.subschema({
					keyword,
					dataProp: i,
					dataPropType: util_1$14.Type.Num
				}, valid);
				if (!it.allErrors) gen.if((0, codegen_1$12.not)(valid), () => gen.break());
			});
		}
	}
	exports.validateAdditionalItems = validateAdditionalItems;
	exports.default = def$17;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/applicator/items.js
var require_items = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/applicator/items.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$11 = require_codegen();
	const util_1$13 = require_util();
	const code_1$5 = require_code();
	const def$16 = {
		keyword: "items",
		type: "array",
		schemaType: [
			"object",
			"array",
			"boolean"
		],
		before: "uniqueItems",
		code(cxt) {
			const { schema: schema$1, it } = cxt;
			if (Array.isArray(schema$1)) return validateTuple(cxt, "additionalItems", schema$1);
			it.items = true;
			if ((0, util_1$13.alwaysValidSchema)(it, schema$1)) return;
			cxt.ok((0, code_1$5.validateArray)(cxt));
		}
	};
	function validateTuple(cxt, extraItems, schArr = cxt.schema) {
		const { gen, parentSchema, data, keyword, it } = cxt;
		checkStrictTuple(parentSchema);
		if (it.opts.unevaluated && schArr.length && it.items !== true) it.items = util_1$13.mergeEvaluated.items(gen, schArr.length, it.items);
		const valid = gen.name("valid");
		const len = gen.const("len", (0, codegen_1$11._)`${data}.length`);
		schArr.forEach((sch, i) => {
			if ((0, util_1$13.alwaysValidSchema)(it, sch)) return;
			gen.if((0, codegen_1$11._)`${len} > ${i}`, () => cxt.subschema({
				keyword,
				schemaProp: i,
				dataProp: i
			}, valid));
			cxt.ok(valid);
		});
		function checkStrictTuple(sch) {
			const { opts, errSchemaPath } = it;
			const l = schArr.length;
			const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
			if (opts.strictTuples && !fullTuple) {
				const msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
				(0, util_1$13.checkStrictMode)(it, msg, opts.strictTuples);
			}
		}
	}
	exports.validateTuple = validateTuple;
	exports.default = def$16;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/applicator/prefixItems.js
var require_prefixItems = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/applicator/prefixItems.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const items_1$1 = require_items();
	const def$15 = {
		keyword: "prefixItems",
		type: "array",
		schemaType: ["array"],
		before: "uniqueItems",
		code: (cxt) => (0, items_1$1.validateTuple)(cxt, "items")
	};
	exports.default = def$15;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/applicator/items2020.js
var require_items2020 = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/applicator/items2020.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$10 = require_codegen();
	const util_1$12 = require_util();
	const code_1$4 = require_code();
	const additionalItems_1$1 = require_additionalItems();
	const def$14 = {
		keyword: "items",
		type: "array",
		schemaType: ["object", "boolean"],
		before: "uniqueItems",
		error: {
			message: ({ params: { len } }) => (0, codegen_1$10.str)`must NOT have more than ${len} items`,
			params: ({ params: { len } }) => (0, codegen_1$10._)`{limit: ${len}}`
		},
		code(cxt) {
			const { schema: schema$1, parentSchema, it } = cxt;
			const { prefixItems } = parentSchema;
			it.items = true;
			if ((0, util_1$12.alwaysValidSchema)(it, schema$1)) return;
			if (prefixItems) (0, additionalItems_1$1.validateAdditionalItems)(cxt, prefixItems);
			else cxt.ok((0, code_1$4.validateArray)(cxt));
		}
	};
	exports.default = def$14;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/applicator/contains.js
var require_contains = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/applicator/contains.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$9 = require_codegen();
	const util_1$11 = require_util();
	const def$13 = {
		keyword: "contains",
		type: "array",
		schemaType: ["object", "boolean"],
		before: "uniqueItems",
		trackErrors: true,
		error: {
			message: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1$9.str)`must contain at least ${min} valid item(s)` : (0, codegen_1$9.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
			params: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1$9._)`{minContains: ${min}}` : (0, codegen_1$9._)`{minContains: ${min}, maxContains: ${max}}`
		},
		code(cxt) {
			const { gen, schema: schema$1, parentSchema, data, it } = cxt;
			let min;
			let max;
			const { minContains, maxContains } = parentSchema;
			if (it.opts.next) {
				min = minContains === void 0 ? 1 : minContains;
				max = maxContains;
			} else min = 1;
			const len = gen.const("len", (0, codegen_1$9._)`${data}.length`);
			cxt.setParams({
				min,
				max
			});
			if (max === void 0 && min === 0) {
				(0, util_1$11.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
				return;
			}
			if (max !== void 0 && min > max) {
				(0, util_1$11.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
				cxt.fail();
				return;
			}
			if ((0, util_1$11.alwaysValidSchema)(it, schema$1)) {
				let cond = (0, codegen_1$9._)`${len} >= ${min}`;
				if (max !== void 0) cond = (0, codegen_1$9._)`${cond} && ${len} <= ${max}`;
				cxt.pass(cond);
				return;
			}
			it.items = true;
			const valid = gen.name("valid");
			if (max === void 0 && min === 1) validateItems(valid, () => gen.if(valid, () => gen.break()));
			else if (min === 0) {
				gen.let(valid, true);
				if (max !== void 0) gen.if((0, codegen_1$9._)`${data}.length > 0`, validateItemsWithCount);
			} else {
				gen.let(valid, false);
				validateItemsWithCount();
			}
			cxt.result(valid, () => cxt.reset());
			function validateItemsWithCount() {
				const schValid = gen.name("_valid");
				const count = gen.let("count", 0);
				validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
			}
			function validateItems(_valid, block) {
				gen.forRange("i", 0, len, (i) => {
					cxt.subschema({
						keyword: "contains",
						dataProp: i,
						dataPropType: util_1$11.Type.Num,
						compositeRule: true
					}, _valid);
					block();
				});
			}
			function checkLimits(count) {
				gen.code((0, codegen_1$9._)`${count}++`);
				if (max === void 0) gen.if((0, codegen_1$9._)`${count} >= ${min}`, () => gen.assign(valid, true).break());
				else {
					gen.if((0, codegen_1$9._)`${count} > ${max}`, () => gen.assign(valid, false).break());
					if (min === 1) gen.assign(valid, true);
					else gen.if((0, codegen_1$9._)`${count} >= ${min}`, () => gen.assign(valid, true));
				}
			}
		}
	};
	exports.default = def$13;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/applicator/dependencies.js
var require_dependencies = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/applicator/dependencies.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;
	const codegen_1$8 = require_codegen();
	const util_1$10 = require_util();
	const code_1$3 = require_code();
	exports.error = {
		message: ({ params: { property, depsCount, deps } }) => {
			const property_ies = depsCount === 1 ? "property" : "properties";
			return (0, codegen_1$8.str)`must have ${property_ies} ${deps} when property ${property} is present`;
		},
		params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1$8._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
	};
	const def$12 = {
		keyword: "dependencies",
		type: "object",
		schemaType: "object",
		error: exports.error,
		code(cxt) {
			const [propDeps, schDeps] = splitDependencies(cxt);
			validatePropertyDeps(cxt, propDeps);
			validateSchemaDeps(cxt, schDeps);
		}
	};
	function splitDependencies({ schema: schema$1 }) {
		const propertyDeps = {};
		const schemaDeps = {};
		for (const key in schema$1) {
			if (key === "__proto__") continue;
			const deps = Array.isArray(schema$1[key]) ? propertyDeps : schemaDeps;
			deps[key] = schema$1[key];
		}
		return [propertyDeps, schemaDeps];
	}
	function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
		const { gen, data, it } = cxt;
		if (Object.keys(propertyDeps).length === 0) return;
		const missing = gen.let("missing");
		for (const prop in propertyDeps) {
			const deps = propertyDeps[prop];
			if (deps.length === 0) continue;
			const hasProperty = (0, code_1$3.propertyInData)(gen, data, prop, it.opts.ownProperties);
			cxt.setParams({
				property: prop,
				depsCount: deps.length,
				deps: deps.join(", ")
			});
			if (it.allErrors) gen.if(hasProperty, () => {
				for (const depProp of deps) (0, code_1$3.checkReportMissingProp)(cxt, depProp);
			});
			else {
				gen.if((0, codegen_1$8._)`${hasProperty} && (${(0, code_1$3.checkMissingProp)(cxt, deps, missing)})`);
				(0, code_1$3.reportMissingProp)(cxt, missing);
				gen.else();
			}
		}
	}
	exports.validatePropertyDeps = validatePropertyDeps;
	function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
		const { gen, data, keyword, it } = cxt;
		const valid = gen.name("valid");
		for (const prop in schemaDeps) {
			if ((0, util_1$10.alwaysValidSchema)(it, schemaDeps[prop])) continue;
			gen.if((0, code_1$3.propertyInData)(gen, data, prop, it.opts.ownProperties), () => {
				const schCxt = cxt.subschema({
					keyword,
					schemaProp: prop
				}, valid);
				cxt.mergeValidEvaluated(schCxt, valid);
			}, () => gen.var(valid, true));
			cxt.ok(valid);
		}
	}
	exports.validateSchemaDeps = validateSchemaDeps;
	exports.default = def$12;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/applicator/propertyNames.js
var require_propertyNames = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/applicator/propertyNames.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$7 = require_codegen();
	const util_1$9 = require_util();
	const def$11 = {
		keyword: "propertyNames",
		type: "object",
		schemaType: ["object", "boolean"],
		error: {
			message: "property name must be valid",
			params: ({ params }) => (0, codegen_1$7._)`{propertyName: ${params.propertyName}}`
		},
		code(cxt) {
			const { gen, schema: schema$1, data, it } = cxt;
			if ((0, util_1$9.alwaysValidSchema)(it, schema$1)) return;
			const valid = gen.name("valid");
			gen.forIn("key", data, (key) => {
				cxt.setParams({ propertyName: key });
				cxt.subschema({
					keyword: "propertyNames",
					data: key,
					dataTypes: ["string"],
					propertyName: key,
					compositeRule: true
				}, valid);
				gen.if((0, codegen_1$7.not)(valid), () => {
					cxt.error(true);
					if (!it.allErrors) gen.break();
				});
			});
			cxt.ok(valid);
		}
	};
	exports.default = def$11;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js
var require_additionalProperties = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const code_1$2 = require_code();
	const codegen_1$6 = require_codegen();
	const names_1 = require_names();
	const util_1$8 = require_util();
	const def$10 = {
		keyword: "additionalProperties",
		type: ["object"],
		schemaType: ["boolean", "object"],
		allowUndefined: true,
		trackErrors: true,
		error: {
			message: "must NOT have additional properties",
			params: ({ params }) => (0, codegen_1$6._)`{additionalProperty: ${params.additionalProperty}}`
		},
		code(cxt) {
			const { gen, schema: schema$1, parentSchema, data, errsCount, it } = cxt;
			/* istanbul ignore if */
			if (!errsCount) throw new Error("ajv implementation error");
			const { allErrors, opts } = it;
			it.props = true;
			if (opts.removeAdditional !== "all" && (0, util_1$8.alwaysValidSchema)(it, schema$1)) return;
			const props = (0, code_1$2.allSchemaProperties)(parentSchema.properties);
			const patProps = (0, code_1$2.allSchemaProperties)(parentSchema.patternProperties);
			checkAdditionalProperties();
			cxt.ok((0, codegen_1$6._)`${errsCount} === ${names_1.default.errors}`);
			function checkAdditionalProperties() {
				gen.forIn("key", data, (key) => {
					if (!props.length && !patProps.length) additionalPropertyCode(key);
					else gen.if(isAdditional(key), () => additionalPropertyCode(key));
				});
			}
			function isAdditional(key) {
				let definedProp;
				if (props.length > 8) {
					const propsSchema = (0, util_1$8.schemaRefOrVal)(it, parentSchema.properties, "properties");
					definedProp = (0, code_1$2.isOwnProperty)(gen, propsSchema, key);
				} else if (props.length) definedProp = (0, codegen_1$6.or)(...props.map((p) => (0, codegen_1$6._)`${key} === ${p}`));
				else definedProp = codegen_1$6.nil;
				if (patProps.length) definedProp = (0, codegen_1$6.or)(definedProp, ...patProps.map((p) => (0, codegen_1$6._)`${(0, code_1$2.usePattern)(cxt, p)}.test(${key})`));
				return (0, codegen_1$6.not)(definedProp);
			}
			function deleteAdditional(key) {
				gen.code((0, codegen_1$6._)`delete ${data}[${key}]`);
			}
			function additionalPropertyCode(key) {
				if (opts.removeAdditional === "all" || opts.removeAdditional && schema$1 === false) {
					deleteAdditional(key);
					return;
				}
				if (schema$1 === false) {
					cxt.setParams({ additionalProperty: key });
					cxt.error();
					if (!allErrors) gen.break();
					return;
				}
				if (typeof schema$1 == "object" && !(0, util_1$8.alwaysValidSchema)(it, schema$1)) {
					const valid = gen.name("valid");
					if (opts.removeAdditional === "failing") {
						applyAdditionalSchema(key, valid, false);
						gen.if((0, codegen_1$6.not)(valid), () => {
							cxt.reset();
							deleteAdditional(key);
						});
					} else {
						applyAdditionalSchema(key, valid);
						if (!allErrors) gen.if((0, codegen_1$6.not)(valid), () => gen.break());
					}
				}
			}
			function applyAdditionalSchema(key, valid, errors$1) {
				const subschema = {
					keyword: "additionalProperties",
					dataProp: key,
					dataPropType: util_1$8.Type.Str
				};
				if (errors$1 === false) Object.assign(subschema, {
					compositeRule: true,
					createErrors: false,
					allErrors: false
				});
				cxt.subschema(subschema, valid);
			}
		}
	};
	exports.default = def$10;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/applicator/properties.js
var require_properties = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/applicator/properties.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const validate_1$1 = require_validate();
	const code_1$1 = require_code();
	const util_1$7 = require_util();
	const additionalProperties_1$1 = require_additionalProperties();
	const def$9 = {
		keyword: "properties",
		type: "object",
		schemaType: "object",
		code(cxt) {
			const { gen, schema: schema$1, parentSchema, data, it } = cxt;
			if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) additionalProperties_1$1.default.code(new validate_1$1.KeywordCxt(it, additionalProperties_1$1.default, "additionalProperties"));
			const allProps = (0, code_1$1.allSchemaProperties)(schema$1);
			for (const prop of allProps) it.definedProperties.add(prop);
			if (it.opts.unevaluated && allProps.length && it.props !== true) it.props = util_1$7.mergeEvaluated.props(gen, (0, util_1$7.toHash)(allProps), it.props);
			const properties = allProps.filter((p) => !(0, util_1$7.alwaysValidSchema)(it, schema$1[p]));
			if (properties.length === 0) return;
			const valid = gen.name("valid");
			for (const prop of properties) {
				if (hasDefault(prop)) applyPropertySchema(prop);
				else {
					gen.if((0, code_1$1.propertyInData)(gen, data, prop, it.opts.ownProperties));
					applyPropertySchema(prop);
					if (!it.allErrors) gen.else().var(valid, true);
					gen.endIf();
				}
				cxt.it.definedProperties.add(prop);
				cxt.ok(valid);
			}
			function hasDefault(prop) {
				return it.opts.useDefaults && !it.compositeRule && schema$1[prop].default !== void 0;
			}
			function applyPropertySchema(prop) {
				cxt.subschema({
					keyword: "properties",
					schemaProp: prop,
					dataProp: prop
				}, valid);
			}
		}
	};
	exports.default = def$9;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/applicator/patternProperties.js
var require_patternProperties = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/applicator/patternProperties.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const code_1 = require_code();
	const codegen_1$5 = require_codegen();
	const util_1$6 = require_util();
	const util_2 = require_util();
	const def$8 = {
		keyword: "patternProperties",
		type: "object",
		schemaType: "object",
		code(cxt) {
			const { gen, schema: schema$1, data, parentSchema, it } = cxt;
			const { opts } = it;
			const patterns = (0, code_1.allSchemaProperties)(schema$1);
			const alwaysValidPatterns = patterns.filter((p) => (0, util_1$6.alwaysValidSchema)(it, schema$1[p]));
			if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) return;
			const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
			const valid = gen.name("valid");
			if (it.props !== true && !(it.props instanceof codegen_1$5.Name)) it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
			const { props } = it;
			validatePatternProperties();
			function validatePatternProperties() {
				for (const pat of patterns) {
					if (checkProperties) checkMatchingProperties(pat);
					if (it.allErrors) validateProperties(pat);
					else {
						gen.var(valid, true);
						validateProperties(pat);
						gen.if(valid);
					}
				}
			}
			function checkMatchingProperties(pat) {
				for (const prop in checkProperties) if (new RegExp(pat).test(prop)) (0, util_1$6.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
			}
			function validateProperties(pat) {
				gen.forIn("key", data, (key) => {
					gen.if((0, codegen_1$5._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
						const alwaysValid = alwaysValidPatterns.includes(pat);
						if (!alwaysValid) cxt.subschema({
							keyword: "patternProperties",
							schemaProp: pat,
							dataProp: key,
							dataPropType: util_2.Type.Str
						}, valid);
						if (it.opts.unevaluated && props !== true) gen.assign((0, codegen_1$5._)`${props}[${key}]`, true);
						else if (!alwaysValid && !it.allErrors) gen.if((0, codegen_1$5.not)(valid), () => gen.break());
					});
				});
			}
		}
	};
	exports.default = def$8;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/applicator/not.js
var require_not = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/applicator/not.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const util_1$5 = require_util();
	const def$7 = {
		keyword: "not",
		schemaType: ["object", "boolean"],
		trackErrors: true,
		code(cxt) {
			const { gen, schema: schema$1, it } = cxt;
			if ((0, util_1$5.alwaysValidSchema)(it, schema$1)) {
				cxt.fail();
				return;
			}
			const valid = gen.name("valid");
			cxt.subschema({
				keyword: "not",
				compositeRule: true,
				createErrors: false,
				allErrors: false
			}, valid);
			cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
		},
		error: { message: "must NOT be valid" }
	};
	exports.default = def$7;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/applicator/anyOf.js
var require_anyOf = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/applicator/anyOf.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const def$6 = {
		keyword: "anyOf",
		schemaType: "array",
		trackErrors: true,
		code: require_code().validateUnion,
		error: { message: "must match a schema in anyOf" }
	};
	exports.default = def$6;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/applicator/oneOf.js
var require_oneOf = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/applicator/oneOf.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$4 = require_codegen();
	const util_1$4 = require_util();
	const def$5 = {
		keyword: "oneOf",
		schemaType: "array",
		trackErrors: true,
		error: {
			message: "must match exactly one schema in oneOf",
			params: ({ params }) => (0, codegen_1$4._)`{passingSchemas: ${params.passing}}`
		},
		code(cxt) {
			const { gen, schema: schema$1, parentSchema, it } = cxt;
			/* istanbul ignore if */
			if (!Array.isArray(schema$1)) throw new Error("ajv implementation error");
			if (it.opts.discriminator && parentSchema.discriminator) return;
			const schArr = schema$1;
			const valid = gen.let("valid", false);
			const passing = gen.let("passing", null);
			const schValid = gen.name("_valid");
			cxt.setParams({ passing });
			gen.block(validateOneOf);
			cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
			function validateOneOf() {
				schArr.forEach((sch, i) => {
					let schCxt;
					if ((0, util_1$4.alwaysValidSchema)(it, sch)) gen.var(schValid, true);
					else schCxt = cxt.subschema({
						keyword: "oneOf",
						schemaProp: i,
						compositeRule: true
					}, schValid);
					if (i > 0) gen.if((0, codegen_1$4._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1$4._)`[${passing}, ${i}]`).else();
					gen.if(schValid, () => {
						gen.assign(valid, true);
						gen.assign(passing, i);
						if (schCxt) cxt.mergeEvaluated(schCxt, codegen_1$4.Name);
					});
				});
			}
		}
	};
	exports.default = def$5;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/applicator/allOf.js
var require_allOf = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/applicator/allOf.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const util_1$3 = require_util();
	const def$4 = {
		keyword: "allOf",
		schemaType: "array",
		code(cxt) {
			const { gen, schema: schema$1, it } = cxt;
			/* istanbul ignore if */
			if (!Array.isArray(schema$1)) throw new Error("ajv implementation error");
			const valid = gen.name("valid");
			schema$1.forEach((sch, i) => {
				if ((0, util_1$3.alwaysValidSchema)(it, sch)) return;
				const schCxt = cxt.subschema({
					keyword: "allOf",
					schemaProp: i
				}, valid);
				cxt.ok(valid);
				cxt.mergeEvaluated(schCxt);
			});
		}
	};
	exports.default = def$4;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/applicator/if.js
var require_if = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/applicator/if.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$3 = require_codegen();
	const util_1$2 = require_util();
	const def$3 = {
		keyword: "if",
		schemaType: ["object", "boolean"],
		trackErrors: true,
		error: {
			message: ({ params }) => (0, codegen_1$3.str)`must match "${params.ifClause}" schema`,
			params: ({ params }) => (0, codegen_1$3._)`{failingKeyword: ${params.ifClause}}`
		},
		code(cxt) {
			const { gen, parentSchema, it } = cxt;
			if (parentSchema.then === void 0 && parentSchema.else === void 0) (0, util_1$2.checkStrictMode)(it, "\"if\" without \"then\" and \"else\" is ignored");
			const hasThen = hasSchema(it, "then");
			const hasElse = hasSchema(it, "else");
			if (!hasThen && !hasElse) return;
			const valid = gen.let("valid", true);
			const schValid = gen.name("_valid");
			validateIf();
			cxt.reset();
			if (hasThen && hasElse) {
				const ifClause = gen.let("ifClause");
				cxt.setParams({ ifClause });
				gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
			} else if (hasThen) gen.if(schValid, validateClause("then"));
			else gen.if((0, codegen_1$3.not)(schValid), validateClause("else"));
			cxt.pass(valid, () => cxt.error(true));
			function validateIf() {
				const schCxt = cxt.subschema({
					keyword: "if",
					compositeRule: true,
					createErrors: false,
					allErrors: false
				}, schValid);
				cxt.mergeEvaluated(schCxt);
			}
			function validateClause(keyword, ifClause) {
				return () => {
					const schCxt = cxt.subschema({ keyword }, schValid);
					gen.assign(valid, schValid);
					cxt.mergeValidEvaluated(schCxt, valid);
					if (ifClause) gen.assign(ifClause, (0, codegen_1$3._)`${keyword}`);
					else cxt.setParams({ ifClause: keyword });
				};
			}
		}
	};
	function hasSchema(it, keyword) {
		const schema$1 = it.schema[keyword];
		return schema$1 !== void 0 && !(0, util_1$2.alwaysValidSchema)(it, schema$1);
	}
	exports.default = def$3;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/applicator/thenElse.js
var require_thenElse = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/applicator/thenElse.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const util_1$1 = require_util();
	const def$2 = {
		keyword: ["then", "else"],
		schemaType: ["object", "boolean"],
		code({ keyword, parentSchema, it }) {
			if (parentSchema.if === void 0) (0, util_1$1.checkStrictMode)(it, `"${keyword}" without "if" is ignored`);
		}
	};
	exports.default = def$2;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/applicator/index.js
var require_applicator = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/applicator/index.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const additionalItems_1 = require_additionalItems();
	const prefixItems_1 = require_prefixItems();
	const items_1 = require_items();
	const items2020_1 = require_items2020();
	const contains_1 = require_contains();
	const dependencies_1 = require_dependencies();
	const propertyNames_1 = require_propertyNames();
	const additionalProperties_1 = require_additionalProperties();
	const properties_1 = require_properties();
	const patternProperties_1 = require_patternProperties();
	const not_1 = require_not();
	const anyOf_1 = require_anyOf();
	const oneOf_1 = require_oneOf();
	const allOf_1 = require_allOf();
	const if_1 = require_if();
	const thenElse_1 = require_thenElse();
	function getApplicator(draft2020 = false) {
		const applicator = [
			not_1.default,
			anyOf_1.default,
			oneOf_1.default,
			allOf_1.default,
			if_1.default,
			thenElse_1.default,
			propertyNames_1.default,
			additionalProperties_1.default,
			dependencies_1.default,
			properties_1.default,
			patternProperties_1.default
		];
		if (draft2020) applicator.push(prefixItems_1.default, items2020_1.default);
		else applicator.push(additionalItems_1.default, items_1.default);
		applicator.push(contains_1.default);
		return applicator;
	}
	exports.default = getApplicator;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/format/format.js
var require_format$1 = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/format/format.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$2 = require_codegen();
	const def$1 = {
		keyword: "format",
		type: ["number", "string"],
		schemaType: "string",
		$data: true,
		error: {
			message: ({ schemaCode }) => (0, codegen_1$2.str)`must match format "${schemaCode}"`,
			params: ({ schemaCode }) => (0, codegen_1$2._)`{format: ${schemaCode}}`
		},
		code(cxt, ruleType) {
			const { gen, data, $data, schema: schema$1, schemaCode, it } = cxt;
			const { opts, errSchemaPath, schemaEnv, self } = it;
			if (!opts.validateFormats) return;
			if ($data) validate$DataFormat();
			else validateFormat();
			function validate$DataFormat() {
				const fmts = gen.scopeValue("formats", {
					ref: self.formats,
					code: opts.code.formats
				});
				const fDef = gen.const("fDef", (0, codegen_1$2._)`${fmts}[${schemaCode}]`);
				const fType = gen.let("fType");
				const format$1 = gen.let("format");
				gen.if((0, codegen_1$2._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1$2._)`${fDef}.type || "string"`).assign(format$1, (0, codegen_1$2._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1$2._)`"string"`).assign(format$1, fDef));
				cxt.fail$data((0, codegen_1$2.or)(unknownFmt(), invalidFmt()));
				function unknownFmt() {
					if (opts.strictSchema === false) return codegen_1$2.nil;
					return (0, codegen_1$2._)`${schemaCode} && !${format$1}`;
				}
				function invalidFmt() {
					const callFormat = schemaEnv.$async ? (0, codegen_1$2._)`(${fDef}.async ? await ${format$1}(${data}) : ${format$1}(${data}))` : (0, codegen_1$2._)`${format$1}(${data})`;
					const validData = (0, codegen_1$2._)`(typeof ${format$1} == "function" ? ${callFormat} : ${format$1}.test(${data}))`;
					return (0, codegen_1$2._)`${format$1} && ${format$1} !== true && ${fType} === ${ruleType} && !${validData}`;
				}
			}
			function validateFormat() {
				const formatDef = self.formats[schema$1];
				if (!formatDef) {
					unknownFormat();
					return;
				}
				if (formatDef === true) return;
				const [fmtType, format$1, fmtRef] = getFormat(formatDef);
				if (fmtType === ruleType) cxt.pass(validCondition());
				function unknownFormat() {
					if (opts.strictSchema === false) {
						self.logger.warn(unknownMsg());
						return;
					}
					throw new Error(unknownMsg());
					function unknownMsg() {
						return `unknown format "${schema$1}" ignored in schema at path "${errSchemaPath}"`;
					}
				}
				function getFormat(fmtDef) {
					const code = fmtDef instanceof RegExp ? (0, codegen_1$2.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1$2._)`${opts.code.formats}${(0, codegen_1$2.getProperty)(schema$1)}` : void 0;
					const fmt = gen.scopeValue("formats", {
						key: schema$1,
						ref: fmtDef,
						code
					});
					if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) return [
						fmtDef.type || "string",
						fmtDef.validate,
						(0, codegen_1$2._)`${fmt}.validate`
					];
					return [
						"string",
						fmtDef,
						fmt
					];
				}
				function validCondition() {
					if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
						if (!schemaEnv.$async) throw new Error("async format in sync schema");
						return (0, codegen_1$2._)`await ${fmtRef}(${data})`;
					}
					return typeof format$1 == "function" ? (0, codegen_1$2._)`${fmtRef}(${data})` : (0, codegen_1$2._)`${fmtRef}.test(${data})`;
				}
			}
		}
	};
	exports.default = def$1;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/format/index.js
var require_format = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/format/index.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const format = [require_format$1().default];
	exports.default = format;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/metadata.js
var require_metadata = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/metadata.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.metadataVocabulary = [
		"title",
		"description",
		"default",
		"deprecated",
		"readOnly",
		"writeOnly",
		"examples"
	];
	exports.contentVocabulary = [
		"contentMediaType",
		"contentEncoding",
		"contentSchema"
	];
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/draft7.js
var require_draft7 = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/draft7.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const core_1$1 = require_core();
	const validation_1 = require_validation();
	const applicator_1 = require_applicator();
	const format_1 = require_format();
	const metadata_1 = require_metadata();
	const draft7Vocabularies = [
		core_1$1.default,
		validation_1.default,
		(0, applicator_1.default)(),
		format_1.default,
		metadata_1.metadataVocabulary,
		metadata_1.contentVocabulary
	];
	exports.default = draft7Vocabularies;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/discriminator/types.js
var require_types = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/discriminator/types.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var DiscrError;
	(function(DiscrError$1) {
		DiscrError$1["Tag"] = "tag";
		DiscrError$1["Mapping"] = "mapping";
	})(DiscrError || (exports.DiscrError = DiscrError = {}));
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/discriminator/index.js
var require_discriminator = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/discriminator/index.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$1 = require_codegen();
	const types_1 = require_types();
	const compile_1 = require_compile();
	const ref_error_1$1 = require_ref_error();
	const util_1 = require_util();
	const def = {
		keyword: "discriminator",
		type: "object",
		schemaType: "object",
		error: {
			message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
			params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1$1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
		},
		code(cxt) {
			const { gen, data, schema: schema$1, parentSchema, it } = cxt;
			const { oneOf } = parentSchema;
			if (!it.opts.discriminator) throw new Error("discriminator: requires discriminator option");
			const tagName = schema$1.propertyName;
			if (typeof tagName != "string") throw new Error("discriminator: requires propertyName");
			if (schema$1.mapping) throw new Error("discriminator: mapping is not supported");
			if (!oneOf) throw new Error("discriminator: requires oneOf keyword");
			const valid = gen.let("valid", false);
			const tag = gen.const("tag", (0, codegen_1$1._)`${data}${(0, codegen_1$1.getProperty)(tagName)}`);
			gen.if((0, codegen_1$1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, {
				discrError: types_1.DiscrError.Tag,
				tag,
				tagName
			}));
			cxt.ok(valid);
			function validateMapping() {
				const mapping = getMapping();
				gen.if(false);
				for (const tagValue in mapping) {
					gen.elseIf((0, codegen_1$1._)`${tag} === ${tagValue}`);
					gen.assign(valid, applyTagSchema(mapping[tagValue]));
				}
				gen.else();
				cxt.error(false, {
					discrError: types_1.DiscrError.Mapping,
					tag,
					tagName
				});
				gen.endIf();
			}
			function applyTagSchema(schemaProp) {
				const _valid = gen.name("valid");
				const schCxt = cxt.subschema({
					keyword: "oneOf",
					schemaProp
				}, _valid);
				cxt.mergeEvaluated(schCxt, codegen_1$1.Name);
				return _valid;
			}
			function getMapping() {
				var _a$1;
				const oneOfMapping = {};
				const topRequired = hasRequired(parentSchema);
				let tagRequired = true;
				for (let i = 0; i < oneOf.length; i++) {
					let sch = oneOf[i];
					if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
						const ref = sch.$ref;
						sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref);
						if (sch instanceof compile_1.SchemaEnv) sch = sch.schema;
						if (sch === void 0) throw new ref_error_1$1.default(it.opts.uriResolver, it.baseId, ref);
					}
					const propSch = (_a$1 = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a$1 === void 0 ? void 0 : _a$1[tagName];
					if (typeof propSch != "object") throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
					tagRequired = tagRequired && (topRequired || hasRequired(sch));
					addMappings(propSch, i);
				}
				if (!tagRequired) throw new Error(`discriminator: "${tagName}" must be required`);
				return oneOfMapping;
				function hasRequired({ required }) {
					return Array.isArray(required) && required.includes(tagName);
				}
				function addMappings(sch, i) {
					if (sch.const) addMapping(sch.const, i);
					else if (sch.enum) for (const tagValue of sch.enum) addMapping(tagValue, i);
					else throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
				}
				function addMapping(tagValue, i) {
					if (typeof tagValue != "string" || tagValue in oneOfMapping) throw new Error(`discriminator: "${tagName}" values must be unique strings`);
					oneOfMapping[tagValue] = i;
				}
			}
		}
	};
	exports.default = def;
}) });

//#endregion
//#region ../node_modules/ajv/dist/refs/json-schema-draft-07.json
var require_json_schema_draft_07 = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/refs/json-schema-draft-07.json": ((exports, module) => {
	module.exports = {
		"$schema": "http://json-schema.org/draft-07/schema#",
		"$id": "http://json-schema.org/draft-07/schema#",
		"title": "Core schema meta-schema",
		"definitions": {
			"schemaArray": {
				"type": "array",
				"minItems": 1,
				"items": { "$ref": "#" }
			},
			"nonNegativeInteger": {
				"type": "integer",
				"minimum": 0
			},
			"nonNegativeIntegerDefault0": { "allOf": [{ "$ref": "#/definitions/nonNegativeInteger" }, { "default": 0 }] },
			"simpleTypes": { "enum": [
				"array",
				"boolean",
				"integer",
				"null",
				"number",
				"object",
				"string"
			] },
			"stringArray": {
				"type": "array",
				"items": { "type": "string" },
				"uniqueItems": true,
				"default": []
			}
		},
		"type": ["object", "boolean"],
		"properties": {
			"$id": {
				"type": "string",
				"format": "uri-reference"
			},
			"$schema": {
				"type": "string",
				"format": "uri"
			},
			"$ref": {
				"type": "string",
				"format": "uri-reference"
			},
			"$comment": { "type": "string" },
			"title": { "type": "string" },
			"description": { "type": "string" },
			"default": true,
			"readOnly": {
				"type": "boolean",
				"default": false
			},
			"examples": {
				"type": "array",
				"items": true
			},
			"multipleOf": {
				"type": "number",
				"exclusiveMinimum": 0
			},
			"maximum": { "type": "number" },
			"exclusiveMaximum": { "type": "number" },
			"minimum": { "type": "number" },
			"exclusiveMinimum": { "type": "number" },
			"maxLength": { "$ref": "#/definitions/nonNegativeInteger" },
			"minLength": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },
			"pattern": {
				"type": "string",
				"format": "regex"
			},
			"additionalItems": { "$ref": "#" },
			"items": {
				"anyOf": [{ "$ref": "#" }, { "$ref": "#/definitions/schemaArray" }],
				"default": true
			},
			"maxItems": { "$ref": "#/definitions/nonNegativeInteger" },
			"minItems": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },
			"uniqueItems": {
				"type": "boolean",
				"default": false
			},
			"contains": { "$ref": "#" },
			"maxProperties": { "$ref": "#/definitions/nonNegativeInteger" },
			"minProperties": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },
			"required": { "$ref": "#/definitions/stringArray" },
			"additionalProperties": { "$ref": "#" },
			"definitions": {
				"type": "object",
				"additionalProperties": { "$ref": "#" },
				"default": {}
			},
			"properties": {
				"type": "object",
				"additionalProperties": { "$ref": "#" },
				"default": {}
			},
			"patternProperties": {
				"type": "object",
				"additionalProperties": { "$ref": "#" },
				"propertyNames": { "format": "regex" },
				"default": {}
			},
			"dependencies": {
				"type": "object",
				"additionalProperties": { "anyOf": [{ "$ref": "#" }, { "$ref": "#/definitions/stringArray" }] }
			},
			"propertyNames": { "$ref": "#" },
			"const": true,
			"enum": {
				"type": "array",
				"items": true,
				"minItems": 1,
				"uniqueItems": true
			},
			"type": { "anyOf": [{ "$ref": "#/definitions/simpleTypes" }, {
				"type": "array",
				"items": { "$ref": "#/definitions/simpleTypes" },
				"minItems": 1,
				"uniqueItems": true
			}] },
			"format": { "type": "string" },
			"contentMediaType": { "type": "string" },
			"contentEncoding": { "type": "string" },
			"if": { "$ref": "#" },
			"then": { "$ref": "#" },
			"else": { "$ref": "#" },
			"allOf": { "$ref": "#/definitions/schemaArray" },
			"anyOf": { "$ref": "#/definitions/schemaArray" },
			"oneOf": { "$ref": "#/definitions/schemaArray" },
			"not": { "$ref": "#" }
		},
		"default": true
	};
}) });

//#endregion
//#region ../node_modules/ajv/dist/ajv.js
var require_ajv = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/ajv.js": ((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = exports.Ajv = void 0;
	const core_1 = require_core$1();
	const draft7_1 = require_draft7();
	const discriminator_1 = require_discriminator();
	const draft7MetaSchema = require_json_schema_draft_07();
	const META_SUPPORT_DATA = ["/properties"];
	const META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
	var Ajv$1 = class extends core_1.default {
		_addVocabularies() {
			super._addVocabularies();
			draft7_1.default.forEach((v) => this.addVocabulary(v));
			if (this.opts.discriminator) this.addKeyword(discriminator_1.default);
		}
		_addDefaultMetaSchema() {
			super._addDefaultMetaSchema();
			if (!this.opts.meta) return;
			const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
			this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
			this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
		}
		defaultMeta() {
			return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
		}
	};
	exports.Ajv = Ajv$1;
	module.exports = exports = Ajv$1;
	module.exports.Ajv = Ajv$1;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Ajv$1;
	var validate_1 = require_validate();
	Object.defineProperty(exports, "KeywordCxt", {
		enumerable: true,
		get: function() {
			return validate_1.KeywordCxt;
		}
	});
	var codegen_1 = require_codegen();
	Object.defineProperty(exports, "_", {
		enumerable: true,
		get: function() {
			return codegen_1._;
		}
	});
	Object.defineProperty(exports, "str", {
		enumerable: true,
		get: function() {
			return codegen_1.str;
		}
	});
	Object.defineProperty(exports, "stringify", {
		enumerable: true,
		get: function() {
			return codegen_1.stringify;
		}
	});
	Object.defineProperty(exports, "nil", {
		enumerable: true,
		get: function() {
			return codegen_1.nil;
		}
	});
	Object.defineProperty(exports, "Name", {
		enumerable: true,
		get: function() {
			return codegen_1.Name;
		}
	});
	Object.defineProperty(exports, "CodeGen", {
		enumerable: true,
		get: function() {
			return codegen_1.CodeGen;
		}
	});
	var validation_error_1 = require_validation_error();
	Object.defineProperty(exports, "ValidationError", {
		enumerable: true,
		get: function() {
			return validation_error_1.default;
		}
	});
	var ref_error_1 = require_ref_error();
	Object.defineProperty(exports, "MissingRefError", {
		enumerable: true,
		get: function() {
			return ref_error_1.default;
		}
	});
}) });

//#endregion
//#region src/hash.ts
var import_ajv = /* @__PURE__ */ __toESM$2(require_ajv(), 1);
const FNV_OFFSET_1 = 14695981039346656037n;
const FNV_OFFSET_2 = 9521211207457086692n;
const FNV_PRIME = 1099511628211n;
const MASK_64 = (1n << 64n) - 1n;
const hash64 = (value, offset) => {
	let hash = offset;
	for (let i = 0; i < value.length; i += 1) {
		hash ^= BigInt(value.charCodeAt(i));
		hash = hash * FNV_PRIME & MASK_64;
	}
	return hash;
};
const toHex64 = (value) => value.toString(16).padStart(16, "0");
const hash128 = (...data) => {
	const input = JSON.stringify(data);
	const high = hash64(input, FNV_OFFSET_1);
	const low = hash64(input, FNV_OFFSET_2);
	return `${toHex64(high)}${toHex64(low)}`;
};

//#endregion
//#region src/notes.ts
const string = { type: "string" };
const number = { type: "number" };
const object = (properties, extra = {}) => ({
	type: "object",
	properties,
	required: Object.keys(properties),
	...extra
});
const tojson = (x) => JSON.stringify(x, null, 2);
const fromjson = (x) => JSON.parse(x);
const validate = (data, schema$1) => {
	const validate$1 = new import_ajv.default().compile(schema$1);
	if (validate$1(data)) return true;
	else throw new Error(validate$1.errors?.map((e) => e.message).join(", ") || "Invalid data");
};
function hashData({ schemaHash, data }) {
	if (schemaHash === "0" && tojson(data) != "{}") throw new Error("schema hash is 0 but data is not empty :" + tojson(data));
	return hash128(schemaHash, data);
}
function NoteData(title, schema$1, data = {}) {
	return {
		schemaHash: hashData(schema$1),
		data: {
			...title ? { title } : {},
			...data
		}
	};
}
const top = {
	schemaHash: "0",
	data: {}
};
const script_schema = NoteData("script_schema", top, object({
	title: string,
	code: string
}));
const script_result_schema = NoteData("script_result_schema", top, object({
	title: string,
	script: "#" + hashData(script_schema),
	content: {}
}, { title: "script_result_schema" }));
const titled_schema = NoteData("titled_schema", top, object({ title: string }));
const has_titled_child = NoteData("has_titled_child", top, object({ "child": object({ title: string }) }));
const titled = NoteData("a titled", titled_schema, { title: "im child" });
const titled1 = NoteData("titled1", has_titled_child, { child: titled.data });
const titled2 = NoteData("titled2", has_titled_child, { child: `#${hashData(titled)}` });
const function_schema = NoteData("function schema", top, object({
	title: string,
	args: { additionalProperties: object({
		name: string,
		schema: {}
	}) },
	code: string,
	returnSchema: {}
}, { required: [
	"args",
	"code",
	"returnSchema"
] }));
const server_function = NoteData("server function", top, object({
	title: string,
	code: string
}, { required: ["code"] }));
const example_function = NoteData("example function", function_schema, {
	title: "example function",
	inputs: ["a", "b"],
	code: "return a + b"
});
const schemas = [
	script_schema,
	script_result_schema,
	NoteData("", top, string),
	NoteData("", top, number),
	titled_schema,
	has_titled_child,
	titled,
	titled1,
	titled2,
	function_schema,
	example_function,
	server_function
];
const isRef = (value) => typeof value == "string" && /^#([a-f0-9]{32})$/.exec(value);
const expandLinksSync = (value, resolve$2) => {
	if (typeof value === "string") {
		const match = isRef(value);
		if (!match) return value;
		const ref = match[1];
		return expandLinksSync(resolve$2(ref), resolve$2);
	}
	if (Array.isArray(value)) return value.map((v) => expandLinksSync(v, resolve$2));
	if (value && typeof value === "object") return Object.fromEntries(Object.entries(value).map(([k, v]) => [k, expandLinksSync(v, resolve$2)]));
	return value;
};
const normalizeRef = (ref) => ref[0] === "#" ? ref.slice(1) : ref;

//#endregion
//#region src/parser.ts
const keywords = new Set([
	"if",
	"else",
	"return",
	"let",
	"const",
	"for",
	"while",
	"in",
	"of",
	"break",
	"continue",
	"true",
	"false",
	"null"
]);
const isIdentStart = (c) => /[A-Za-z_$]/.test(c);
const isIdentPart = (c) => /[A-Za-z0-9_$]/.test(c);
const isDigit = (c) => /[0-9]/.test(c);
const tokenize = (src) => {
	const tokens = [];
	let i = 0;
	const push = (type, value, pos) => tokens.push({
		type,
		value,
		pos
	});
	const peek = () => src[i];
	const next = () => src[i++];
	while (i < src.length) {
		const c = peek();
		if (c === " " || c === "\n" || c === "\r" || c === "	") {
			i++;
			continue;
		}
		if (c === "/" && src[i + 1] === "/") {
			i += 2;
			while (i < src.length && src[i] !== "\n") i++;
			continue;
		}
		if (c === "/" && src[i + 1] === "*") {
			i += 2;
			while (i < src.length && !(src[i] === "*" && src[i + 1] === "/")) i++;
			i += 2;
			continue;
		}
		if (c === "'" || c === "\"") {
			const quote = next();
			let out = "";
			const start$1 = i - 1;
			while (i < src.length) {
				const ch = next();
				if (ch === "\\") {
					const esc = next();
					out += esc;
				} else if (ch === quote) break;
				else out += ch;
			}
			push("string", out, start$1);
			continue;
		}
		if (isDigit(c)) {
			const start$1 = i;
			let num = "";
			while (i < src.length && isDigit(peek())) num += next();
			if (peek() === ".") {
				num += next();
				while (i < src.length && isDigit(peek())) num += next();
			}
			push("number", num, start$1);
			continue;
		}
		if (isIdentStart(c)) {
			const start$1 = i;
			let id = "";
			while (i < src.length && isIdentPart(peek())) id += next();
			if (keywords.has(id)) push("keyword", id, start$1);
			else push("identifier", id, start$1);
			continue;
		}
		const start = i;
		const two = src.slice(i, i + 2);
		const three = src.slice(i, i + 3);
		if (three === "===" || three === "!==") {
			i += 3;
			push("operator", three, start);
			continue;
		}
		if (two === "&&" || two === "||" || two === "==" || two === "!=" || two === "<=" || two === ">=" || two === "=>" || two === "+=" || two === "-=" || two === "*=" || two === "/=" || two === "%=" || two === "++" || two === "--") {
			i += 2;
			push("operator", two, start);
			continue;
		}
		if ("+-*/%<>=!.,;:?(){}[]".includes(c)) {
			i++;
			push(".;,(){}[]".includes(c) ? "punct" : "operator", c, start);
			continue;
		}
		throw new Error(`Unexpected character '${c}' at ${i}`);
	}
	tokens.push({
		type: "eof",
		value: "",
		pos: i
	});
	return tokens;
};
const validateNoPrototype = (program) => {
	const errors$1 = [];
	const visitExpr = (e) => {
		switch (e.type) {
			case "MemberExpression":
				if (!e.computed && e.property.type === "Identifier" && e.property.name === "prototype") errors$1.push("prototype access");
				if (e.computed && e.property.type === "Literal" && e.property.value === "prototype") errors$1.push("prototype access");
				visitExpr(e.object);
				if (e.computed) visitExpr(e.property);
				return;
			case "CallExpression":
				visitExpr(e.callee);
				e.arguments.forEach(visitExpr);
				return;
			case "ArrayExpression":
				e.elements.forEach(visitExpr);
				return;
			case "ObjectExpression":
				e.properties.forEach((p) => visitExpr(p.value));
				return;
			case "AssignmentExpression":
				visitExpr(e.left);
				visitExpr(e.right);
				return;
			case "UpdateExpression":
				visitExpr(e.argument);
				return;
			case "BinaryExpression":
			case "LogicalExpression":
				visitExpr(e.left);
				visitExpr(e.right);
				return;
			case "UnaryExpression":
				visitExpr(e.argument);
				return;
			case "ConditionalExpression":
				visitExpr(e.test);
				visitExpr(e.consequent);
				visitExpr(e.alternate);
				return;
			case "ArrowFunctionExpression":
				if (e.body.type === "BlockStatement") visitStmt(e.body);
				else visitExpr(e.body);
				return;
			case "Identifier":
			case "Literal": return;
		}
	};
	const visitStmt = (s) => {
		switch (s.type) {
			case "BlockStatement":
				s.body.forEach(visitStmt);
				return;
			case "ExpressionStatement":
				visitExpr(s.expression);
				return;
			case "IfStatement":
				visitExpr(s.test);
				visitStmt(s.consequent);
				if (s.alternate) visitStmt(s.alternate);
				return;
			case "ReturnStatement":
				if (s.argument) visitExpr(s.argument);
				return;
			case "VariableDeclaration":
				s.declarations.forEach((d) => d.init && visitExpr(d.init));
				return;
			case "WhileStatement":
				visitExpr(s.test);
				visitStmt(s.body);
				return;
			case "ForStatement":
				if (Array.isArray(s.init)) s.init.forEach((d) => d.init && visitExpr(d.init));
				else if (s.init) visitExpr(s.init);
				if (s.test) visitExpr(s.test);
				if (s.update) visitExpr(s.update);
				visitStmt(s.body);
				return;
			case "ForInStatement":
			case "ForOfStatement":
				if (Array.isArray(s.left)) s.left.forEach((d) => d.init && visitExpr(d.init));
				else visitExpr(s.left);
				visitExpr(s.right);
				visitStmt(s.body);
				return;
			case "BreakStatement":
			case "ContinueStatement": return;
		}
	};
	program.body.forEach(visitStmt);
	return errors$1;
};
const renderLiteral = (v) => {
	if (v === null) return "null";
	if (typeof v === "string") return JSON.stringify(v);
	return String(v);
};
const renderExpr = (e) => {
	switch (e.type) {
		case "Identifier": return e.name;
		case "Literal": return renderLiteral(e.value);
		case "ArrayExpression": return `[${e.elements.map(renderExpr).join(", ")}]`;
		case "ObjectExpression": return `{${e.properties.map(renderProp).join(", ")}}`;
		case "CallExpression": {
			const calleeStr = renderExpr(e.callee);
			const needsParens = e.callee.type === "ArrowFunctionExpression";
			return `${needsParens ? "(" : ""}${calleeStr}${needsParens ? ")" : ""}(${e.arguments.map(renderExpr).join(", ")})`;
		}
		case "MemberExpression": return e.computed ? `${renderExpr(e.object)}[${renderExpr(e.property)}]` : `${renderExpr(e.object)}.${renderExpr(e.property)}`;
		case "AssignmentExpression": return `${renderExpr(e.left)} ${e.operator} ${renderExpr(e.right)}`;
		case "UpdateExpression": return e.prefix ? `${e.operator}${renderExpr(e.argument)}` : `${renderExpr(e.argument)}${e.operator}`;
		case "BinaryExpression":
		case "LogicalExpression": return `(${renderExpr(e.left)} ${e.operator} ${renderExpr(e.right)})`;
		case "UnaryExpression": return `(${e.operator}${renderExpr(e.argument)})`;
		case "ConditionalExpression": return `(${renderExpr(e.test)} ? ${renderExpr(e.consequent)} : ${renderExpr(e.alternate)})`;
		case "ArrowFunctionExpression": return renderArrow(e);
	}
};
const renderProp = (p) => {
	const key = p.key.type === "Identifier" ? p.key.name : renderLiteral(p.key.value);
	if (p.shorthand && p.value.type === "Identifier" && p.value.name === key) return key;
	return `${key}: ${renderExpr(p.value)}`;
};
const renderArrow = (e) => {
	const params = `(${e.params.map((p) => p.name).join(", ")})`;
	if (e.body.type === "BlockStatement") return `${params} => ${renderStmt(e.body, true)}`;
	return `${params} => { __burn(); return ${renderExpr(e.body)}; }`;
};
const renderStmt = (s, inFn = false) => {
	const burn = inFn ? "__burn();" : "";
	const renderLoopBody = (body) => {
		if (body.type === "BlockStatement") return `{__burn();${body.body.map((b) => renderStmt(b, inFn)).join("")}}`;
		return `{__burn();${renderStmt(body, inFn)}}`;
	};
	switch (s.type) {
		case "BlockStatement": return `{${s.body.map((b) => renderStmt(b, inFn)).join("")}}`;
		case "ExpressionStatement": return `${burn}${renderExpr(s.expression)};`;
		case "IfStatement": {
			const wrap = (stmt) => stmt.type === "BlockStatement" ? renderStmt(stmt, inFn) : `{${renderStmt(stmt, inFn)}}`;
			return `${burn}if (${renderExpr(s.test)}) ${wrap(s.consequent)}${s.alternate ? ` else ${wrap(s.alternate)}` : ""}`;
		}
		case "ReturnStatement": return `${burn}return${s.argument ? ` ${renderExpr(s.argument)}` : ""};`;
		case "VariableDeclaration": return `${burn}${s.kind} ${s.declarations.map(renderDecl).join(", ")};`;
		case "BreakStatement": return `${burn}break;`;
		case "ContinueStatement": return `${burn}continue;`;
		case "WhileStatement": return `${burn}while (${renderExpr(s.test)}) ${renderLoopBody(s.body)}`;
		case "ForStatement": return `${burn}for (${s.init == null ? "" : Array.isArray(s.init) ? `${s.initKind} ${s.init.map(renderDecl).join(", ")}` : renderExpr(s.init)}; ${s.test ? renderExpr(s.test) : ""}; ${s.update ? renderExpr(s.update) : ""}) ${renderLoopBody(s.body)}`;
		case "ForInStatement": return `${burn}for (${Array.isArray(s.left) ? `${s.leftKind} ${s.left.map(renderDecl).join(", ")}` : renderExpr(s.left)} in ${renderExpr(s.right)}) ${renderLoopBody(s.body)}`;
		case "ForOfStatement": return `${burn}for (${Array.isArray(s.left) ? `${s.leftKind} ${s.left.map(renderDecl).join(", ")}` : renderExpr(s.left)} of ${renderExpr(s.right)}) ${renderLoopBody(s.body)}`;
	}
};
const renderDecl = (d) => `${renderPattern(d.id)}${d.init ? ` = ${renderExpr(d.init)}` : ""}`;
const renderPattern = (p) => {
	if (p.type === "Identifier") return p.name;
	if (p.type === "ArrayPattern") return `[${p.elements.map((e) => e.name).join(", ")}]`;
	return `{${p.properties.map((e) => e.name).join(", ")}}`;
};
const renderRunnerWithFuelShared = (program, fuelRefName = "__fuel") => {
	return `${`const __burn = () => { if (--${fuelRefName}.value < 0) throw new Error("fuel exhausted"); };`}const __run = () => {${program.body.map((s) => renderStmt(s, true)).join("")}}; try { const ok = __run(); return { ok, fuel: ${fuelRefName}.value }; } catch (err) { return { err: String(err), fuel: ${fuelRefName}.value }; }`;
};
const stringifyError = (err) => {
	if (err instanceof Error) {
		const stack = err.stack || "";
		const prefix = `${err.name}: ${err.message}`;
		const cleanStack = stack.replace(/^[^\n]*\n?/, "").replace(/spacetimedb_module:(\d+):(\d+)/g, "<bundled:$1:$2>");
		return cleanStack ? `${prefix}\n${cleanStack}` : prefix;
	}
	if (typeof err === "object" && err !== null) try {
		return JSON.stringify(err);
	} catch {
		return String(err);
	}
	return String(err);
};
const runWithFuelShared = (src, fuelRef, env = {}, fuelRefName = "__fuel") => {
	try {
		const program = parse(src);
		if (validateNoPrototype(program).length) return {
			err: "prototype access",
			fuel: fuelRef.value
		};
		const code = renderRunnerWithFuelShared(program, fuelRefName);
		const fullEnv = {
			...env,
			[fuelRefName]: fuelRef
		};
		return new Function(...Object.keys(fullEnv), code)(...Object.values(fullEnv));
	} catch (err) {
		return {
			err: stringifyError(err),
			fuel: fuelRef.value
		};
	}
};
const parse = (src) => {
	const tokens = tokenize(src);
	let i = 0;
	const peek = () => tokens[i];
	const next = () => tokens[i++];
	const eat = (type, value) => {
		const t$1 = peek();
		if (t$1.type !== type || value !== void 0 && t$1.value !== value) throw new Error(`Expected ${value ?? type} at ${t$1.pos}`);
		return next();
	};
	const match = (type, value) => {
		const t$1 = peek();
		return t$1.type === type && (value === void 0 || t$1.value === value);
	};
	const parseProgram = () => {
		const body = [];
		while (!match("eof")) body.push(parseStatement());
		return {
			type: "Program",
			body
		};
	};
	const parseStatement = () => {
		if (match("punct", "{")) return parseBlock();
		if (match("keyword", "if")) return parseIf();
		if (match("keyword", "while")) return parseWhile();
		if (match("keyword", "for")) return parseFor();
		if (match("keyword", "break")) {
			next();
			if (match("punct", ";")) next();
			return { type: "BreakStatement" };
		}
		if (match("keyword", "continue")) {
			next();
			if (match("punct", ";")) next();
			return { type: "ContinueStatement" };
		}
		if (match("keyword", "return")) return parseReturn();
		if (match("keyword", "let") || match("keyword", "const")) return parseVarDecl();
		const expr = parseExpression();
		if (match("punct", ";")) next();
		return {
			type: "ExpressionStatement",
			expression: expr
		};
	};
	const parseBlock = () => {
		eat("punct", "{");
		const body = [];
		while (!match("punct", "}")) body.push(parseStatement());
		eat("punct", "}");
		return {
			type: "BlockStatement",
			body
		};
	};
	const parseIf = () => {
		eat("keyword", "if");
		eat("punct", "(");
		const test = parseExpression();
		eat("punct", ")");
		return {
			type: "IfStatement",
			test,
			consequent: parseStatement(),
			alternate: match("keyword", "else") ? (next(), parseStatement()) : null
		};
	};
	const parseReturn = () => {
		eat("keyword", "return");
		if (match("punct", ";")) {
			next();
			return {
				type: "ReturnStatement",
				argument: null
			};
		}
		const argument = match("punct", "}") ? null : parseExpression();
		if (match("punct", ";")) next();
		return {
			type: "ReturnStatement",
			argument
		};
	};
	const parseVarDeclCore = (consumeSemi) => {
		const kind = next().value;
		const declarations = [];
		do {
			const id = parsePattern();
			const init$1 = match("operator", "=") ? (next(), parseExpression()) : null;
			declarations.push({
				type: "VariableDeclarator",
				id,
				init: init$1
			});
			if (!match("punct", ",")) break;
			next();
		} while (true);
		if (consumeSemi && match("punct", ";")) next();
		return {
			kind,
			declarations
		};
	};
	const parseVarDecl = () => {
		const { kind, declarations } = parseVarDeclCore(true);
		return {
			type: "VariableDeclaration",
			kind,
			declarations
		};
	};
	const parseWhile = () => {
		eat("keyword", "while");
		eat("punct", "(");
		const test = parseExpression();
		eat("punct", ")");
		return {
			type: "WhileStatement",
			test,
			body: parseStatement()
		};
	};
	const parseFor = () => {
		eat("keyword", "for");
		eat("punct", "(");
		let init$1 = null;
		let initKind = null;
		if (!match("punct", ";")) if (match("keyword", "let") || match("keyword", "const")) {
			const parsed = parseVarDeclCore(false);
			init$1 = parsed.declarations;
			initKind = parsed.kind;
		} else init$1 = parseExpression();
		if (match("keyword", "in") || match("keyword", "of")) {
			const kind = next().value;
			const right = parseExpression();
			eat("punct", ")");
			const body$1 = parseStatement();
			if (!init$1) throw new Error(`Expected initializer before ${kind} at ${peek().pos}`);
			return kind === "in" ? {
				type: "ForInStatement",
				left: init$1,
				leftKind: initKind,
				right,
				body: body$1
			} : {
				type: "ForOfStatement",
				left: init$1,
				leftKind: initKind,
				right,
				body: body$1
			};
		}
		eat("punct", ";");
		const test = match("punct", ";") ? null : parseExpression();
		eat("punct", ";");
		const update = match("punct", ")") ? null : parseExpression();
		eat("punct", ")");
		const body = parseStatement();
		return {
			type: "ForStatement",
			init: init$1,
			initKind,
			test,
			update,
			body
		};
	};
	const parseExpression = () => parseAssignment();
	const parseAssignment = () => {
		const left = parseConditional();
		if (match("operator", "=") || match("operator", "+=") || match("operator", "-=") || match("operator", "*=") || match("operator", "/=") || match("operator", "%=")) return {
			type: "AssignmentExpression",
			operator: next().value,
			left,
			right: parseAssignment()
		};
		return left;
	};
	const parseConditional = () => {
		let test = parseLogicalOr();
		if (match("operator", "?")) {
			next();
			const consequent = parseExpression();
			eat("operator", ":");
			return {
				type: "ConditionalExpression",
				test,
				consequent,
				alternate: parseExpression()
			};
		}
		return test;
	};
	const parseLogicalOr = () => {
		let left = parseLogicalAnd();
		while (match("operator", "||")) {
			const op = next().value;
			const right = parseLogicalAnd();
			left = {
				type: "LogicalExpression",
				operator: op,
				left,
				right
			};
		}
		return left;
	};
	const parseLogicalAnd = () => {
		let left = parseEquality();
		while (match("operator", "&&")) {
			const op = next().value;
			const right = parseEquality();
			left = {
				type: "LogicalExpression",
				operator: op,
				left,
				right
			};
		}
		return left;
	};
	const parseEquality = () => {
		let left = parseRelational();
		while (match("operator", "==") || match("operator", "!=") || match("operator", "===") || match("operator", "!==")) {
			const op = next().value;
			const right = parseRelational();
			left = {
				type: "BinaryExpression",
				operator: op,
				left,
				right
			};
		}
		return left;
	};
	const parseRelational = () => {
		let left = parseAdditive();
		while (match("operator", "<") || match("operator", "<=") || match("operator", ">") || match("operator", ">=")) {
			const op = next().value;
			const right = parseAdditive();
			left = {
				type: "BinaryExpression",
				operator: op,
				left,
				right
			};
		}
		return left;
	};
	const parseAdditive = () => {
		let left = parseMultiplicative();
		while (match("operator", "+") || match("operator", "-")) {
			const op = next().value;
			const right = parseMultiplicative();
			left = {
				type: "BinaryExpression",
				operator: op,
				left,
				right
			};
		}
		return left;
	};
	const parseMultiplicative = () => {
		let left = parseUnary();
		while (match("operator", "*") || match("operator", "/") || match("operator", "%")) {
			const op = next().value;
			const right = parseUnary();
			left = {
				type: "BinaryExpression",
				operator: op,
				left,
				right
			};
		}
		return left;
	};
	const parseUnary = () => {
		if (match("operator", "++") || match("operator", "--")) return {
			type: "UpdateExpression",
			operator: next().value,
			argument: parseUnary(),
			prefix: true
		};
		if (match("operator", "!") || match("operator", "-") || match("operator", "+")) return {
			type: "UnaryExpression",
			operator: next().value,
			argument: parseUnary()
		};
		return parsePostfix();
	};
	const parsePostfix = () => {
		let expr = parseArrowOrPrimary();
		while (true) {
			if (match("operator", "++") || match("operator", "--")) {
				expr = {
					type: "UpdateExpression",
					operator: next().value,
					argument: expr,
					prefix: false
				};
				continue;
			}
			if (match("punct", "(")) {
				const args = parseArguments();
				expr = {
					type: "CallExpression",
					callee: expr,
					arguments: args
				};
				continue;
			}
			if (match("punct", ".")) {
				next();
				const prop = parseIdentifier();
				expr = {
					type: "MemberExpression",
					object: expr,
					property: prop,
					computed: false
				};
				continue;
			}
			if (match("punct", "[")) {
				next();
				const prop = parseExpression();
				eat("punct", "]");
				expr = {
					type: "MemberExpression",
					object: expr,
					property: prop,
					computed: true
				};
				continue;
			}
			break;
		}
		return expr;
	};
	const parseArrowOrPrimary = () => {
		if (match("identifier")) {
			const id = parseIdentifier();
			if (match("operator", "=>")) {
				next();
				const body = match("punct", "{") ? parseBlock() : parseExpression();
				return {
					type: "ArrowFunctionExpression",
					params: [id],
					body
				};
			}
			return id;
		}
		if (match("punct", "(")) {
			const start = i;
			next();
			const params = [];
			let isParams = true;
			if (!match("punct", ")")) do {
				if (!match("identifier")) {
					isParams = false;
					break;
				}
				params.push(parseIdentifier());
				if (!match("punct", ",")) break;
				next();
			} while (true);
			if (isParams && match("punct", ")")) {
				next();
				if (match("operator", "=>")) {
					next();
					return {
						type: "ArrowFunctionExpression",
						params,
						body: match("punct", "{") ? parseBlock() : parseExpression()
					};
				}
			}
			i = start;
			eat("punct", "(");
			const expr = parseExpression();
			eat("punct", ")");
			return expr;
		}
		return parsePrimary();
	};
	const parsePrimary = () => {
		if (match("number")) return {
			type: "Literal",
			value: Number(next().value)
		};
		if (match("string")) return {
			type: "Literal",
			value: next().value
		};
		if (match("keyword", "true")) {
			next();
			return {
				type: "Literal",
				value: true
			};
		}
		if (match("keyword", "false")) {
			next();
			return {
				type: "Literal",
				value: false
			};
		}
		if (match("keyword", "null")) {
			next();
			return {
				type: "Literal",
				value: null
			};
		}
		if (match("punct", "[")) return parseArray();
		if (match("punct", "{")) return parseObject();
		if (match("identifier")) return parseIdentifier();
		throw new Error(`Unexpected token ${peek().type} ${peek().value} at ${peek().pos}`);
	};
	const parseArray = () => {
		eat("punct", "[");
		const elements = [];
		if (!match("punct", "]")) do {
			elements.push(parseExpression());
			if (!match("punct", ",")) break;
			next();
		} while (true);
		eat("punct", "]");
		return {
			type: "ArrayExpression",
			elements
		};
	};
	const parseObject = () => {
		eat("punct", "{");
		const properties = [];
		if (!match("punct", "}")) do {
			let key;
			let shorthand = false;
			if (match("identifier")) key = parseIdentifier();
			else if (match("string")) key = {
				type: "Literal",
				value: next().value
			};
			else if (match("number")) key = {
				type: "Literal",
				value: Number(next().value)
			};
			else throw new Error(`Expected object key at ${peek().pos}`);
			let value;
			if (match("operator", ":")) {
				next();
				value = parseExpression();
			} else {
				if (key.type !== "Identifier") throw new Error(`Expected ':' after key at ${peek().pos}`);
				value = key;
				shorthand = true;
			}
			properties.push({
				type: "Property",
				key,
				value,
				shorthand
			});
			if (!match("punct", ",")) break;
			next();
		} while (true);
		eat("punct", "}");
		return {
			type: "ObjectExpression",
			properties
		};
	};
	const parseArguments = () => {
		eat("punct", "(");
		const args = [];
		if (!match("punct", ")")) do {
			args.push(parseExpression());
			if (!match("punct", ",")) break;
			next();
		} while (true);
		eat("punct", ")");
		return args;
	};
	const parseIdentifier = () => {
		return {
			type: "Identifier",
			name: eat("identifier").value
		};
	};
	const parsePattern = () => {
		if (match("punct", "[")) {
			eat("punct", "[");
			const elements = [];
			if (!match("punct", "]")) do {
				elements.push(parseIdentifier());
				if (!match("punct", ",")) break;
				next();
			} while (true);
			eat("punct", "]");
			return {
				type: "ArrayPattern",
				elements
			};
		}
		if (match("punct", "{")) {
			eat("punct", "{");
			const properties = [];
			if (!match("punct", "}")) do {
				properties.push(parseIdentifier());
				if (!match("punct", ",")) break;
				next();
			} while (true);
			eat("punct", "}");
			return {
				type: "ObjectPattern",
				properties
			};
		}
		return parseIdentifier();
	};
	return parseProgram();
};

//#endregion
//#region src/index.ts
const JsonNotes = table({
	name: "note",
	public: true
}, {
	hash: t.string().primaryKey(),
	schemaHash: t.string(),
	data: t.string()
});
const Store = table({
	name: "store",
	public: false
}, {
	key: t.string().primaryKey(),
	value: t.string()
});
const Links = table({
	name: "links",
	public: true
}, {
	to: t.string().primaryKey(),
	from: t.array(t.string())
});
const spacetimedb = schema(JsonNotes, Links, Store);
spacetimedb.view({
	name: "note_count",
	public: true
}, t.array(t.object("NoteCountRow", { count: t.u64() })), (ctx) => [{ count: ctx.db.note.count() }]);
spacetimedb.reducer("add_note", {
	schemaHash: t.string(),
	data: t.string()
}, (ctx, { schemaHash, data }) => {
	const schemaRow = ctx.db.note.hash.find(schemaHash);
	if (!schemaRow) throw new SenderError("Schema not found");
	try {
		const resolve$2 = (ref) => {
			const note = ctx.db.note.hash.find(normalizeRef(ref));
			if (!note) throw new SenderError("Note not found");
			return fromjson(note.data);
		};
		const parsed = fromjson(data);
		validate(expandLinksSync(parsed, resolve$2), expandLinksSync(fromjson(schemaRow.data), resolve$2));
		const hash = hashData({
			schemaHash,
			data: parsed
		});
		if (ctx.db.note.hash.find(hash)) return;
		ctx.db.note.insert({
			hash,
			schemaHash,
			data
		});
		const targets = new Set([schemaRow.hash]);
		const re = /#([a-f0-9]{32})/g;
		let match;
		while (match = re.exec(data)) targets.add(match[1]);
		for (const to of targets) {
			const existing = ctx.db.links.to.find(to);
			if (!existing) ctx.db.links.insert({
				to,
				from: [hash]
			});
			else if (!existing.from.some((x) => x === hash)) ctx.db.links.to.update({
				...existing,
				from: [...existing.from, hash]
			});
		}
		return;
	} catch (e) {
		throw new SenderError("INSERT ERROR: " + fromjson(schemaRow.data));
	}
});
const setup = spacetimedb.reducer("setup", {}, (ctx) => {
	try {
		ctx.db.note.insert({
			hash: hashData(top),
			schemaHash: top.schemaHash,
			data: tojson(top.data)
		});
	} catch {}
	for (const note of schemas) {
		const hash = hashData(note);
		if (ctx.db.note.hash.find(hash)) continue;
		ctx.db.note.insert({
			hash,
			schemaHash: note.schemaHash,
			data: tojson(note.data)
		});
	}
});
spacetimedb.init(setup);
spacetimedb.procedure("run_note_async", {
	hash: t.string(),
	arg: t.string()
}, t.string(), (ctx, { hash, arg }) => {
	const getNote = (ref) => ctx.withTx((c) => c.db.note.hash.find(normalizeRef(ref)));
	const fuelRef = { value: 1e4 };
	const fnSchemaHash = hashData(server_function);
	const call = (ref, arg$1) => {
		const fn = getNote(ref);
		if (fn == null) throw new SenderError("fn not found");
		if (fn.schemaHash != fnSchemaHash) throw new SenderError("not a server function");
		const keyFor = (key) => `${fn.hash}:${key}`;
		let ret = runWithFuelShared(`let args = ${arg$1}; ${fromjson(fn.data).code}`, fuelRef, {
			storage: {
				getItem: (key) => ctx.withTx((ctx$1) => ctx$1.db.store.key.find(keyFor(key))?.value ?? null),
				setItem: (key, value) => ctx.withTx((ctx$1) => {
					const k = keyFor(key);
					if (ctx$1.db.store.key.find(k)) ctx$1.db.store.key.update({
						key: k,
						value
					});
					else ctx$1.db.store.insert({
						key: k,
						value
					});
				})
			},
			call,
			hash: hash128
		});
		if ("err" in ret) throw new SenderError(String(ret.err));
		return ret.ok;
	};
	return tojson(call(hash, arg));
});

//#endregion
export { spacetimedb };
//# debugId=79305f98-cf68-4edf-afad-a7cc5d1c3562
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVuZGxlLmpzIiwibmFtZXMiOlsiX19jcmVhdGUiLCJfX2RlZlByb3AiLCJfX2dldE93blByb3BEZXNjIiwiX19nZXRPd25Qcm9wTmFtZXMiLCJfX2dldFByb3RvT2YiLCJfX2hhc093blByb3AiLCJfX2NvbW1vbkpTIiwiX19jb3B5UHJvcHMiLCJfX3RvRVNNIiwic3RyIiwicGFyc2UiLCJpbml0IiwiRSIsIl8iLCJleHBvcnRzIiwiI3ZpZXciLCIjb2Zmc2V0IiwiI2Vuc3VyZSIsIiNidWZmZXIiLCIjZXhwYW5kQnVmZmVyIiwic3RyIiwiYW5kIiwiI2Zyb20iLCIjdG8iLCIjYm9keSIsIiNpbm5lciIsInVyaSIsIiNpZGVudGl0eSIsIiNzZW5kZXJBdXRoIiwiI3V1aWRDb3VudGVyIiwiI2ZpbmFsaXphdGlvblJlZ2lzdHJ5IiwiI2lkIiwiI2RldGFjaCIsIl9hIiwibmFtZXMiLCJjb2RlXzEiLCJfYSIsIl9iIiwiZGVmIiwiY29kZV8xIiwibmFtZXMiLCJfYSIsIl9iIiwiY29kZWdlbl8xIiwiY29kZV8xIiwic2NoZW1hIiwic3RyIiwiY29kZWdlbl8xIiwiY29kZWdlbl8xIiwidXRpbF8xIiwibmFtZXNfMSIsImVycm9yc18xIiwiY29kZWdlbl8xIiwibmFtZXNfMSIsInNjaGVtYSIsInNjaGVtYSIsIl9hIiwicnVsZXNfMSIsImFwcGxpY2FiaWxpdHlfMSIsImVycm9yc18xIiwiY29kZWdlbl8xIiwidXRpbF8xIiwic2NoZW1hIiwidCIsImNvZGVnZW5fMSIsInV0aWxfMSIsImNvZGVnZW5fMSIsInV0aWxfMSIsIm5hbWVzXzEiLCJ1dGlsXzIiLCJzY2hlbWEiLCJjb2RlZ2VuXzEiLCJuYW1lc18xIiwiY29kZV8xIiwiZXJyb3JzXzEiLCJkZWYiLCJzY2hlbWEiLCJfYSIsImVycm9ycyIsImNvZGVnZW5fMSIsInV0aWxfMSIsInNjaGVtYSIsImVxdWFsIiwidHJhdmVyc2UiLCJzY2hlbWEiLCJzdHIiLCJ1dGlsXzEiLCJlcXVhbCIsInNjaGVtYSIsIm5vcm1hbGl6ZSIsImRhdGFUeXBlXzEiLCJjb2RlZ2VuXzEiLCJuYW1lc18xIiwicmVzb2x2ZV8xIiwidXRpbF8xIiwic2NoZW1hIiwiVmFsaWRhdGlvbkVycm9yIiwidCIsImRlZiIsImVycm9ycyIsInJlc29sdmVfMSIsImNvZGVnZW5fMSIsInZhbGlkYXRpb25fZXJyb3JfMSIsIm5hbWVzXzEiLCJyZXNvbHZlXzEiLCJ1dGlsXzEiLCJ2YWxpZGF0ZV8xIiwiX2EiLCJzY2hlbWEiLCJ2YWxpZGF0ZSIsInJlc29sdmUiLCJpc1VVSUQiLCJpc0lQdjQiLCJub25TaW1wbGVEb21haW4iLCJub3JtYWxpemVJUHY2Iiwic3RyIiwicmVtb3ZlRG90U2VnbWVudHMiLCJub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyIsInJlY29tcG9zZUF1dGhvcml0eSIsImdldFNjaGVtZUhhbmRsZXIiLCJTQ0hFTUVTIiwidXJpIiwicGFyc2UiLCJlcXVhbCIsInZhbGlkYXRlXzEiLCJjb2RlZ2VuXzEiLCJ2YWxpZGF0aW9uX2Vycm9yXzEiLCJyZWZfZXJyb3JfMSIsImNvbXBpbGVfMSIsImRhdGFUeXBlXzEiLCJ1dGlsXzEiLCJzdHIiLCJfYSIsIl9iIiwiX2MiLCJvcHRpbWl6ZSIsIkFqdiIsInNjaGVtYSIsImRlZiIsInQiLCJmb3JtYXQiLCJlcnJvcnMiLCJrZXl3b3JkcyIsInNjaGVtYXMiLCJkZWYiLCJyZWZfZXJyb3JfMSIsImNvZGVfMSIsImNvZGVnZW5fMSIsIm5hbWVzXzEiLCJjb21waWxlXzEiLCJ1dGlsXzEiLCJkZWYiLCJfYSIsImNvZGVnZW5fMSIsImRlZiIsImNvZGVnZW5fMSIsImRlZiIsInN0ciIsImNvZGVnZW5fMSIsInV0aWxfMSIsImRlZiIsImNvZGVfMSIsImNvZGVnZW5fMSIsImRlZiIsInNjaGVtYSIsImNvZGVnZW5fMSIsImRlZiIsImNvZGVfMSIsImNvZGVnZW5fMSIsInV0aWxfMSIsImRlZiIsInNjaGVtYSIsImNvZGVnZW5fMSIsImRlZiIsImNvZGVnZW5fMSIsInV0aWxfMSIsImVxdWFsXzEiLCJkZWYiLCJzY2hlbWEiLCJ0IiwiY29kZWdlbl8xIiwidXRpbF8xIiwiZXF1YWxfMSIsImRlZiIsInNjaGVtYSIsImNvZGVnZW5fMSIsInV0aWxfMSIsImRlZiIsInNjaGVtYSIsImNvZGVnZW5fMSIsInV0aWxfMSIsImRlZiIsInNjaGVtYSIsImNvZGVnZW5fMSIsInV0aWxfMSIsImNvZGVfMSIsImRlZiIsInNjaGVtYSIsIml0ZW1zXzEiLCJkZWYiLCJjb2RlZ2VuXzEiLCJ1dGlsXzEiLCJjb2RlXzEiLCJhZGRpdGlvbmFsSXRlbXNfMSIsImRlZiIsInNjaGVtYSIsImNvZGVnZW5fMSIsInV0aWxfMSIsImRlZiIsInNjaGVtYSIsImNvZGVnZW5fMSIsInV0aWxfMSIsImNvZGVfMSIsImRlZiIsInNjaGVtYSIsImNvZGVnZW5fMSIsInV0aWxfMSIsImRlZiIsInNjaGVtYSIsImNvZGVfMSIsImNvZGVnZW5fMSIsInV0aWxfMSIsImRlZiIsInNjaGVtYSIsImVycm9ycyIsInZhbGlkYXRlXzEiLCJjb2RlXzEiLCJ1dGlsXzEiLCJhZGRpdGlvbmFsUHJvcGVydGllc18xIiwiZGVmIiwic2NoZW1hIiwiY29kZWdlbl8xIiwidXRpbF8xIiwiZGVmIiwic2NoZW1hIiwidXRpbF8xIiwiZGVmIiwic2NoZW1hIiwiZGVmIiwiY29kZWdlbl8xIiwidXRpbF8xIiwiZGVmIiwic2NoZW1hIiwidXRpbF8xIiwiZGVmIiwic2NoZW1hIiwiY29kZWdlbl8xIiwidXRpbF8xIiwiZGVmIiwic2NoZW1hIiwidXRpbF8xIiwiZGVmIiwiY29kZWdlbl8xIiwiZGVmIiwiZm9ybWF0Iiwic2NoZW1hIiwiY29yZV8xIiwiY29kZWdlbl8xIiwicmVmX2Vycm9yXzEiLCJzY2hlbWEiLCJfYSIsIkFqdiIsInZhbGlkYXRlIiwiQWp2Iiwic2NoZW1hIiwidG9wOiBOb3RlRGF0YSIsInNjaGVtYXMgOiBOb3RlRGF0YVtdIiwicmVzb2x2ZSIsInRva2VuczogVG9rZW5bXSIsInN0YXJ0IiwiZXJyb3JzOiBzdHJpbmdbXSIsImVycm9ycyIsInQiLCJib2R5OiBTdG10W10iLCJkZWNsYXJhdGlvbnM6IFZhckRlY2xbXSIsImluaXQiLCJpbml0OiBWYXJEZWNsW10gfCBFeHByIHwgbnVsbCIsImluaXRLaW5kOiBcImxldFwiIHwgXCJjb25zdFwiIHwgbnVsbCIsImJvZHkiLCJwYXJhbXM6IElkZW50aWZpZXJbXSIsImVsZW1lbnRzOiBFeHByW10iLCJwcm9wZXJ0aWVzOiBQcm9wZXJ0eVtdIiwia2V5OiBJZGVudGlmaWVyIHwgTGl0ZXJhbCIsInZhbHVlOiBFeHByIiwiYXJnczogRXhwcltdIiwiZWxlbWVudHM6IElkZW50aWZpZXJbXSIsInByb3BlcnRpZXM6IElkZW50aWZpZXJbXSIsInJlc29sdmUiLCJtYXRjaDogUmVnRXhwRXhlY0FycmF5IHwgbnVsbCIsImFyZyIsImN0eCJdLCJzb3VyY2VzIjpbIi4uL25vZGVfbW9kdWxlcy9oZWFkZXJzLXBvbHlmaWxsL2xpYi9pbmRleC5tanMiLCIuLi9ub2RlX21vZHVsZXMvc3BhY2V0aW1lZGIvZGlzdC9zZXJ2ZXIvaW5kZXgubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvY29kZWdlbi9jb2RlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvY29kZWdlbi9zY29wZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL2NvZGVnZW4vaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS91dGlsLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvbmFtZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS9lcnJvcnMuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS92YWxpZGF0ZS9ib29sU2NoZW1hLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvcnVsZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS92YWxpZGF0ZS9hcHBsaWNhYmlsaXR5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvdmFsaWRhdGUvZGF0YVR5cGUuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS92YWxpZGF0ZS9kZWZhdWx0cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvY29kZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3ZhbGlkYXRlL2tleXdvcmQuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS92YWxpZGF0ZS9zdWJzY2hlbWEuanMiLCIuLi9ub2RlX21vZHVsZXMvZmFzdC1kZWVwLWVxdWFsL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2pzb24tc2NoZW1hLXRyYXZlcnNlL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvcmVzb2x2ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3ZhbGlkYXRlL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3J1bnRpbWUvdmFsaWRhdGlvbl9lcnJvci5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3JlZl9lcnJvci5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3JlZnMvZGF0YS5qc29uIiwiLi4vbm9kZV9tb2R1bGVzL2Zhc3QtdXJpL2xpYi91dGlscy5qcyIsIi4uL25vZGVfbW9kdWxlcy9mYXN0LXVyaS9saWIvc2NoZW1lcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9mYXN0LXVyaS9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9ydW50aW1lL3VyaS5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb3JlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9jb3JlL2lkLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9jb3JlL3JlZi5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvY29yZS9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9saW1pdE51bWJlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9tdWx0aXBsZU9mLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3J1bnRpbWUvdWNzMmxlbmd0aC5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9saW1pdExlbmd0aC5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9wYXR0ZXJuLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL2xpbWl0UHJvcGVydGllcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9yZXF1aXJlZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9saW1pdEl0ZW1zLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3J1bnRpbWUvZXF1YWwuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vdW5pcXVlSXRlbXMuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vY29uc3QuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vZW51bS5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9hZGRpdGlvbmFsSXRlbXMuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvaXRlbXMuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvcHJlZml4SXRlbXMuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvaXRlbXMyMDIwLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2NvbnRhaW5zLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2RlcGVuZGVuY2llcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9wcm9wZXJ0eU5hbWVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2FkZGl0aW9uYWxQcm9wZXJ0aWVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL3Byb3BlcnRpZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvcGF0dGVyblByb3BlcnRpZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3Ivbm90LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2FueU9mLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL29uZU9mLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2FsbE9mLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2lmLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL3RoZW5FbHNlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9mb3JtYXQvZm9ybWF0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9mb3JtYXQvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL21ldGFkYXRhLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9kcmFmdDcuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2Rpc2NyaW1pbmF0b3IvdHlwZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2Rpc2NyaW1pbmF0b3IvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvcmVmcy9qc29uLXNjaGVtYS1kcmFmdC0wNy5qc29uIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2Fqdi5qcyIsInNyYy9oYXNoLnRzIiwic3JjL25vdGVzLnRzIiwic3JjL3BhcnNlci50cyIsInNyYy9pbmRleC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fY29tbW9uSlMgPSAoY2IsIG1vZCkgPT4gZnVuY3Rpb24gX19yZXF1aXJlKCkge1xuICByZXR1cm4gbW9kIHx8ICgwLCBjYltfX2dldE93blByb3BOYW1lcyhjYilbMF1dKSgobW9kID0geyBleHBvcnRzOiB7fSB9KS5leHBvcnRzLCBtb2QpLCBtb2QuZXhwb3J0cztcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0VTTSA9IChtb2QsIGlzTm9kZU1vZGUsIHRhcmdldCkgPT4gKHRhcmdldCA9IG1vZCAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZCkpIDoge30sIF9fY29weVByb3BzKFxuICAvLyBJZiB0aGUgaW1wb3J0ZXIgaXMgaW4gbm9kZSBjb21wYXRpYmlsaXR5IG1vZGUgb3IgdGhpcyBpcyBub3QgYW4gRVNNXG4gIC8vIGZpbGUgdGhhdCBoYXMgYmVlbiBjb252ZXJ0ZWQgdG8gYSBDb21tb25KUyBmaWxlIHVzaW5nIGEgQmFiZWwtXG4gIC8vIGNvbXBhdGlibGUgdHJhbnNmb3JtIChpLmUuIFwiX19lc01vZHVsZVwiIGhhcyBub3QgYmVlbiBzZXQpLCB0aGVuIHNldFxuICAvLyBcImRlZmF1bHRcIiB0byB0aGUgQ29tbW9uSlMgXCJtb2R1bGUuZXhwb3J0c1wiIGZvciBub2RlIGNvbXBhdGliaWxpdHkuXG4gIGlzTm9kZU1vZGUgfHwgIW1vZCB8fCAhbW9kLl9fZXNNb2R1bGUgPyBfX2RlZlByb3AodGFyZ2V0LCBcImRlZmF1bHRcIiwgeyB2YWx1ZTogbW9kLCBlbnVtZXJhYmxlOiB0cnVlIH0pIDogdGFyZ2V0LFxuICBtb2RcbikpO1xuXG4vLyBub2RlX21vZHVsZXMvc2V0LWNvb2tpZS1wYXJzZXIvbGliL3NldC1jb29raWUuanNcbnZhciByZXF1aXJlX3NldF9jb29raWUgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvc2V0LWNvb2tpZS1wYXJzZXIvbGliL3NldC1jb29raWUuanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgZGVmYXVsdFBhcnNlT3B0aW9ucyA9IHtcbiAgICAgIGRlY29kZVZhbHVlczogdHJ1ZSxcbiAgICAgIG1hcDogZmFsc2UsXG4gICAgICBzaWxlbnQ6IGZhbHNlXG4gICAgfTtcbiAgICBmdW5jdGlvbiBpc05vbkVtcHR5U3RyaW5nKHN0cikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBzdHIgPT09IFwic3RyaW5nXCIgJiYgISFzdHIudHJpbSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZVN0cmluZyhzZXRDb29raWVWYWx1ZSwgb3B0aW9ucykge1xuICAgICAgdmFyIHBhcnRzID0gc2V0Q29va2llVmFsdWUuc3BsaXQoXCI7XCIpLmZpbHRlcihpc05vbkVtcHR5U3RyaW5nKTtcbiAgICAgIHZhciBuYW1lVmFsdWVQYWlyU3RyID0gcGFydHMuc2hpZnQoKTtcbiAgICAgIHZhciBwYXJzZWQgPSBwYXJzZU5hbWVWYWx1ZVBhaXIobmFtZVZhbHVlUGFpclN0cik7XG4gICAgICB2YXIgbmFtZSA9IHBhcnNlZC5uYW1lO1xuICAgICAgdmFyIHZhbHVlID0gcGFyc2VkLnZhbHVlO1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0UGFyc2VPcHRpb25zLCBvcHRpb25zKSA6IGRlZmF1bHRQYXJzZU9wdGlvbnM7XG4gICAgICB0cnkge1xuICAgICAgICB2YWx1ZSA9IG9wdGlvbnMuZGVjb2RlVmFsdWVzID8gZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKSA6IHZhbHVlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwic2V0LWNvb2tpZS1wYXJzZXIgZW5jb3VudGVyZWQgYW4gZXJyb3Igd2hpbGUgZGVjb2RpbmcgYSBjb29raWUgd2l0aCB2YWx1ZSAnXCIgKyB2YWx1ZSArIFwiJy4gU2V0IG9wdGlvbnMuZGVjb2RlVmFsdWVzIHRvIGZhbHNlIHRvIGRpc2FibGUgdGhpcyBmZWF0dXJlLlwiLFxuICAgICAgICAgIGVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHZhciBjb29raWUgPSB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIHZhbHVlXG4gICAgICB9O1xuICAgICAgcGFydHMuZm9yRWFjaChmdW5jdGlvbihwYXJ0KSB7XG4gICAgICAgIHZhciBzaWRlcyA9IHBhcnQuc3BsaXQoXCI9XCIpO1xuICAgICAgICB2YXIga2V5ID0gc2lkZXMuc2hpZnQoKS50cmltTGVmdCgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHZhciB2YWx1ZTIgPSBzaWRlcy5qb2luKFwiPVwiKTtcbiAgICAgICAgaWYgKGtleSA9PT0gXCJleHBpcmVzXCIpIHtcbiAgICAgICAgICBjb29raWUuZXhwaXJlcyA9IG5ldyBEYXRlKHZhbHVlMik7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcIm1heC1hZ2VcIikge1xuICAgICAgICAgIGNvb2tpZS5tYXhBZ2UgPSBwYXJzZUludCh2YWx1ZTIsIDEwKTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09IFwic2VjdXJlXCIpIHtcbiAgICAgICAgICBjb29raWUuc2VjdXJlID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09IFwiaHR0cG9ubHlcIikge1xuICAgICAgICAgIGNvb2tpZS5odHRwT25seSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcInNhbWVzaXRlXCIpIHtcbiAgICAgICAgICBjb29raWUuc2FtZVNpdGUgPSB2YWx1ZTI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29va2llW2tleV0gPSB2YWx1ZTI7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNvb2tpZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VOYW1lVmFsdWVQYWlyKG5hbWVWYWx1ZVBhaXJTdHIpIHtcbiAgICAgIHZhciBuYW1lID0gXCJcIjtcbiAgICAgIHZhciB2YWx1ZSA9IFwiXCI7XG4gICAgICB2YXIgbmFtZVZhbHVlQXJyID0gbmFtZVZhbHVlUGFpclN0ci5zcGxpdChcIj1cIik7XG4gICAgICBpZiAobmFtZVZhbHVlQXJyLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgbmFtZSA9IG5hbWVWYWx1ZUFyci5zaGlmdCgpO1xuICAgICAgICB2YWx1ZSA9IG5hbWVWYWx1ZUFyci5qb2luKFwiPVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gbmFtZVZhbHVlUGFpclN0cjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IG5hbWUsIHZhbHVlIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyA/IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRQYXJzZU9wdGlvbnMsIG9wdGlvbnMpIDogZGVmYXVsdFBhcnNlT3B0aW9ucztcbiAgICAgIGlmICghaW5wdXQpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zLm1hcCkge1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpbnB1dC5oZWFkZXJzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQuaGVhZGVycy5nZXRTZXRDb29raWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIGlucHV0ID0gaW5wdXQuaGVhZGVycy5nZXRTZXRDb29raWUoKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dC5oZWFkZXJzW1wic2V0LWNvb2tpZVwiXSkge1xuICAgICAgICAgIGlucHV0ID0gaW5wdXQuaGVhZGVyc1tcInNldC1jb29raWVcIl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHNjaCA9IGlucHV0LmhlYWRlcnNbT2JqZWN0LmtleXMoaW5wdXQuaGVhZGVycykuZmluZChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gXCJzZXQtY29va2llXCI7XG4gICAgICAgICAgfSldO1xuICAgICAgICAgIGlmICghc2NoICYmIGlucHV0LmhlYWRlcnMuY29va2llICYmICFvcHRpb25zLnNpbGVudCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICBcIldhcm5pbmc6IHNldC1jb29raWUtcGFyc2VyIGFwcGVhcnMgdG8gaGF2ZSBiZWVuIGNhbGxlZCBvbiBhIHJlcXVlc3Qgb2JqZWN0LiBJdCBpcyBkZXNpZ25lZCB0byBwYXJzZSBTZXQtQ29va2llIGhlYWRlcnMgZnJvbSByZXNwb25zZXMsIG5vdCBDb29raWUgaGVhZGVycyBmcm9tIHJlcXVlc3RzLiBTZXQgdGhlIG9wdGlvbiB7c2lsZW50OiB0cnVlfSB0byBzdXBwcmVzcyB0aGlzIHdhcm5pbmcuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlucHV0ID0gc2NoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgIGlucHV0ID0gW2lucHV0XTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zID8gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFBhcnNlT3B0aW9ucywgb3B0aW9ucykgOiBkZWZhdWx0UGFyc2VPcHRpb25zO1xuICAgICAgaWYgKCFvcHRpb25zLm1hcCkge1xuICAgICAgICByZXR1cm4gaW5wdXQuZmlsdGVyKGlzTm9uRW1wdHlTdHJpbmcpLm1hcChmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VTdHJpbmcoc3RyLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY29va2llcyA9IHt9O1xuICAgICAgICByZXR1cm4gaW5wdXQuZmlsdGVyKGlzTm9uRW1wdHlTdHJpbmcpLnJlZHVjZShmdW5jdGlvbihjb29raWVzMiwgc3RyKSB7XG4gICAgICAgICAgdmFyIGNvb2tpZSA9IHBhcnNlU3RyaW5nKHN0ciwgb3B0aW9ucyk7XG4gICAgICAgICAgY29va2llczJbY29va2llLm5hbWVdID0gY29va2llO1xuICAgICAgICAgIHJldHVybiBjb29raWVzMjtcbiAgICAgICAgfSwgY29va2llcyk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNwbGl0Q29va2llc1N0cmluZzIoY29va2llc1N0cmluZykge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29va2llc1N0cmluZykpIHtcbiAgICAgICAgcmV0dXJuIGNvb2tpZXNTdHJpbmc7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGNvb2tpZXNTdHJpbmcgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIGNvb2tpZXNTdHJpbmdzID0gW107XG4gICAgICB2YXIgcG9zID0gMDtcbiAgICAgIHZhciBzdGFydDtcbiAgICAgIHZhciBjaDtcbiAgICAgIHZhciBsYXN0Q29tbWE7XG4gICAgICB2YXIgbmV4dFN0YXJ0O1xuICAgICAgdmFyIGNvb2tpZXNTZXBhcmF0b3JGb3VuZDtcbiAgICAgIGZ1bmN0aW9uIHNraXBXaGl0ZXNwYWNlKCkge1xuICAgICAgICB3aGlsZSAocG9zIDwgY29va2llc1N0cmluZy5sZW5ndGggJiYgL1xccy8udGVzdChjb29raWVzU3RyaW5nLmNoYXJBdChwb3MpKSkge1xuICAgICAgICAgIHBvcyArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3MgPCBjb29raWVzU3RyaW5nLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG5vdFNwZWNpYWxDaGFyKCkge1xuICAgICAgICBjaCA9IGNvb2tpZXNTdHJpbmcuY2hhckF0KHBvcyk7XG4gICAgICAgIHJldHVybiBjaCAhPT0gXCI9XCIgJiYgY2ggIT09IFwiO1wiICYmIGNoICE9PSBcIixcIjtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChwb3MgPCBjb29raWVzU3RyaW5nLmxlbmd0aCkge1xuICAgICAgICBzdGFydCA9IHBvcztcbiAgICAgICAgY29va2llc1NlcGFyYXRvckZvdW5kID0gZmFsc2U7XG4gICAgICAgIHdoaWxlIChza2lwV2hpdGVzcGFjZSgpKSB7XG4gICAgICAgICAgY2ggPSBjb29raWVzU3RyaW5nLmNoYXJBdChwb3MpO1xuICAgICAgICAgIGlmIChjaCA9PT0gXCIsXCIpIHtcbiAgICAgICAgICAgIGxhc3RDb21tYSA9IHBvcztcbiAgICAgICAgICAgIHBvcyArPSAxO1xuICAgICAgICAgICAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgICAgICAgICAgIG5leHRTdGFydCA9IHBvcztcbiAgICAgICAgICAgIHdoaWxlIChwb3MgPCBjb29raWVzU3RyaW5nLmxlbmd0aCAmJiBub3RTcGVjaWFsQ2hhcigpKSB7XG4gICAgICAgICAgICAgIHBvcyArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvcyA8IGNvb2tpZXNTdHJpbmcubGVuZ3RoICYmIGNvb2tpZXNTdHJpbmcuY2hhckF0KHBvcykgPT09IFwiPVwiKSB7XG4gICAgICAgICAgICAgIGNvb2tpZXNTZXBhcmF0b3JGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgIHBvcyA9IG5leHRTdGFydDtcbiAgICAgICAgICAgICAgY29va2llc1N0cmluZ3MucHVzaChjb29raWVzU3RyaW5nLnN1YnN0cmluZyhzdGFydCwgbGFzdENvbW1hKSk7XG4gICAgICAgICAgICAgIHN0YXJ0ID0gcG9zO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcG9zID0gbGFzdENvbW1hICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9zICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghY29va2llc1NlcGFyYXRvckZvdW5kIHx8IHBvcyA+PSBjb29raWVzU3RyaW5nLmxlbmd0aCkge1xuICAgICAgICAgIGNvb2tpZXNTdHJpbmdzLnB1c2goY29va2llc1N0cmluZy5zdWJzdHJpbmcoc3RhcnQsIGNvb2tpZXNTdHJpbmcubGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjb29raWVzU3RyaW5ncztcbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBwYXJzZTtcbiAgICBtb2R1bGUuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuICAgIG1vZHVsZS5leHBvcnRzLnBhcnNlU3RyaW5nID0gcGFyc2VTdHJpbmc7XG4gICAgbW9kdWxlLmV4cG9ydHMuc3BsaXRDb29raWVzU3RyaW5nID0gc3BsaXRDb29raWVzU3RyaW5nMjtcbiAgfVxufSk7XG5cbi8vIHNyYy9IZWFkZXJzLnRzXG52YXIgaW1wb3J0X3NldF9jb29raWVfcGFyc2VyID0gX190b0VTTShyZXF1aXJlX3NldF9jb29raWUoKSk7XG5cbi8vIHNyYy91dGlscy9ub3JtYWxpemVIZWFkZXJOYW1lLnRzXG52YXIgSEVBREVSU19JTlZBTElEX0NIQVJBQ1RFUlMgPSAvW15hLXowLTlcXC0jJCUmJyorLl5fYHx+XS9pO1xuZnVuY3Rpb24gbm9ybWFsaXplSGVhZGVyTmFtZShuYW1lKSB7XG4gIGlmIChIRUFERVJTX0lOVkFMSURfQ0hBUkFDVEVSUy50ZXN0KG5hbWUpIHx8IG5hbWUudHJpbSgpID09PSBcIlwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgY2hhcmFjdGVyIGluIGhlYWRlciBmaWVsZCBuYW1lXCIpO1xuICB9XG4gIHJldHVybiBuYW1lLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xufVxuXG4vLyBzcmMvdXRpbHMvbm9ybWFsaXplSGVhZGVyVmFsdWUudHNcbnZhciBjaGFyQ29kZXNUb1JlbW92ZSA9IFtcbiAgU3RyaW5nLmZyb21DaGFyQ29kZSgxMCksXG4gIFN0cmluZy5mcm9tQ2hhckNvZGUoMTMpLFxuICBTdHJpbmcuZnJvbUNoYXJDb2RlKDkpLFxuICBTdHJpbmcuZnJvbUNoYXJDb2RlKDMyKVxuXTtcbnZhciBIRUFERVJfVkFMVUVfUkVNT1ZFX1JFR0VYUCA9IG5ldyBSZWdFeHAoXG4gIGAoXlske2NoYXJDb2Rlc1RvUmVtb3ZlLmpvaW4oXCJcIil9XXwkWyR7Y2hhckNvZGVzVG9SZW1vdmUuam9pbihcIlwiKX1dKWAsXG4gIFwiZ1wiXG4pO1xuZnVuY3Rpb24gbm9ybWFsaXplSGVhZGVyVmFsdWUodmFsdWUpIHtcbiAgY29uc3QgbmV4dFZhbHVlID0gdmFsdWUucmVwbGFjZShIRUFERVJfVkFMVUVfUkVNT1ZFX1JFR0VYUCwgXCJcIik7XG4gIHJldHVybiBuZXh0VmFsdWU7XG59XG5cbi8vIHNyYy91dGlscy9pc1ZhbGlkSGVhZGVyTmFtZS50c1xuZnVuY3Rpb24gaXNWYWxpZEhlYWRlck5hbWUodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGFyYWN0ZXIgPSB2YWx1ZS5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjaGFyYWN0ZXIgPiAxMjcgfHwgIWlzVG9rZW4oY2hhcmFjdGVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGlzVG9rZW4odmFsdWUpIHtcbiAgcmV0dXJuICFbXG4gICAgMTI3LFxuICAgIDMyLFxuICAgIFwiKFwiLFxuICAgIFwiKVwiLFxuICAgIFwiPFwiLFxuICAgIFwiPlwiLFxuICAgIFwiQFwiLFxuICAgIFwiLFwiLFxuICAgIFwiO1wiLFxuICAgIFwiOlwiLFxuICAgIFwiXFxcXFwiLFxuICAgICdcIicsXG4gICAgXCIvXCIsXG4gICAgXCJbXCIsXG4gICAgXCJdXCIsXG4gICAgXCI/XCIsXG4gICAgXCI9XCIsXG4gICAgXCJ7XCIsXG4gICAgXCJ9XCJcbiAgXS5pbmNsdWRlcyh2YWx1ZSk7XG59XG5cbi8vIHNyYy91dGlscy9pc1ZhbGlkSGVhZGVyVmFsdWUudHNcbmZ1bmN0aW9uIGlzVmFsaWRIZWFkZXJWYWx1ZSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh2YWx1ZS50cmltKCkgIT09IHZhbHVlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGFyYWN0ZXIgPSB2YWx1ZS5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChcbiAgICAgIC8vIE5VTC5cbiAgICAgIGNoYXJhY3RlciA9PT0gMCB8fCAvLyBIVFRQIG5ld2xpbmUgYnl0ZXMuXG4gICAgICBjaGFyYWN0ZXIgPT09IDEwIHx8IGNoYXJhY3RlciA9PT0gMTNcbiAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIHNyYy9IZWFkZXJzLnRzXG52YXIgTk9STUFMSVpFRF9IRUFERVJTID0gU3ltYm9sKFwibm9ybWFsaXplZEhlYWRlcnNcIik7XG52YXIgUkFXX0hFQURFUl9OQU1FUyA9IFN5bWJvbChcInJhd0hlYWRlck5hbWVzXCIpO1xudmFyIEhFQURFUl9WQUxVRV9ERUxJTUlURVIgPSBcIiwgXCI7XG52YXIgX2EsIF9iLCBfYztcbnZhciBIZWFkZXJzID0gY2xhc3MgX0hlYWRlcnMge1xuICBjb25zdHJ1Y3Rvcihpbml0KSB7XG4gICAgLy8gTm9ybWFsaXplZCBoZWFkZXIge1wibmFtZVwiOlwiYSwgYlwifSBzdG9yYWdlLlxuICAgIHRoaXNbX2FdID0ge307XG4gICAgLy8gS2VlcHMgdGhlIG1hcHBpbmcgYmV0d2VlbiB0aGUgcmF3IGhlYWRlciBuYW1lXG4gICAgLy8gYW5kIHRoZSBub3JtYWxpemVkIGhlYWRlciBuYW1lIHRvIGVhc2UgdGhlIGxvb2t1cC5cbiAgICB0aGlzW19iXSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpc1tfY10gPSBcIkhlYWRlcnNcIjtcbiAgICBpZiAoW1wiSGVhZGVyc1wiLCBcIkhlYWRlcnNQb2x5ZmlsbFwiXS5pbmNsdWRlcyhpbml0Py5jb25zdHJ1Y3Rvci5uYW1lKSB8fCBpbml0IGluc3RhbmNlb2YgX0hlYWRlcnMgfHwgdHlwZW9mIGdsb2JhbFRoaXMuSGVhZGVycyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpbml0IGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5IZWFkZXJzKSB7XG4gICAgICBjb25zdCBpbml0aWFsSGVhZGVycyA9IGluaXQ7XG4gICAgICBpbml0aWFsSGVhZGVycy5mb3JFYWNoKCh2YWx1ZSwgbmFtZSkgPT4ge1xuICAgICAgICB0aGlzLmFwcGVuZChuYW1lLCB2YWx1ZSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaW5pdCkpIHtcbiAgICAgIGluaXQuZm9yRWFjaCgoW25hbWUsIHZhbHVlXSkgPT4ge1xuICAgICAgICB0aGlzLmFwcGVuZChcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUuam9pbihIRUFERVJfVkFMVUVfREVMSU1JVEVSKSA6IHZhbHVlXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGluaXQpIHtcbiAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGluaXQpLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBpbml0W25hbWVdO1xuICAgICAgICB0aGlzLmFwcGVuZChcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUuam9pbihIRUFERVJfVkFMVUVfREVMSU1JVEVSKSA6IHZhbHVlXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgWyhfYSA9IE5PUk1BTElaRURfSEVBREVSUywgX2IgPSBSQVdfSEVBREVSX05BTUVTLCBfYyA9IFN5bWJvbC50b1N0cmluZ1RhZywgU3ltYm9sLml0ZXJhdG9yKV0oKSB7XG4gICAgcmV0dXJuIHRoaXMuZW50cmllcygpO1xuICB9XG4gICprZXlzKCkge1xuICAgIGZvciAoY29uc3QgW25hbWVdIG9mIHRoaXMuZW50cmllcygpKSB7XG4gICAgICB5aWVsZCBuYW1lO1xuICAgIH1cbiAgfVxuICAqdmFsdWVzKCkge1xuICAgIGZvciAoY29uc3QgWywgdmFsdWVdIG9mIHRoaXMuZW50cmllcygpKSB7XG4gICAgICB5aWVsZCB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgKmVudHJpZXMoKSB7XG4gICAgbGV0IHNvcnRlZEtleXMgPSBPYmplY3Qua2V5cyh0aGlzW05PUk1BTElaRURfSEVBREVSU10pLnNvcnQoXG4gICAgICAoYSwgYikgPT4gYS5sb2NhbGVDb21wYXJlKGIpXG4gICAgKTtcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2Ygc29ydGVkS2V5cykge1xuICAgICAgaWYgKG5hbWUgPT09IFwic2V0LWNvb2tpZVwiKSB7XG4gICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdGhpcy5nZXRTZXRDb29raWUoKSkge1xuICAgICAgICAgIHlpZWxkIFtuYW1lLCB2YWx1ZV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHlpZWxkIFtuYW1lLCB0aGlzLmdldChuYW1lKV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgYm9vbGVhbiBzdGF0aW5nIHdoZXRoZXIgYSBgSGVhZGVyc2Agb2JqZWN0IGNvbnRhaW5zIGEgY2VydGFpbiBoZWFkZXIuXG4gICAqL1xuICBoYXMobmFtZSkge1xuICAgIGlmICghaXNWYWxpZEhlYWRlck5hbWUobmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgaGVhZGVyIG5hbWUgXCIke25hbWV9XCJgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNbTk9STUFMSVpFRF9IRUFERVJTXS5oYXNPd25Qcm9wZXJ0eShub3JtYWxpemVIZWFkZXJOYW1lKG5hbWUpKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIGBCeXRlU3RyaW5nYCBzZXF1ZW5jZSBvZiBhbGwgdGhlIHZhbHVlcyBvZiBhIGhlYWRlciB3aXRoIGEgZ2l2ZW4gbmFtZS5cbiAgICovXG4gIGdldChuYW1lKSB7XG4gICAgaWYgKCFpc1ZhbGlkSGVhZGVyTmFtZShuYW1lKSkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKGBJbnZhbGlkIGhlYWRlciBuYW1lIFwiJHtuYW1lfVwiYCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzW05PUk1BTElaRURfSEVBREVSU11bbm9ybWFsaXplSGVhZGVyTmFtZShuYW1lKV0gPz8gbnVsbDtcbiAgfVxuICAvKipcbiAgICogU2V0cyBhIG5ldyB2YWx1ZSBmb3IgYW4gZXhpc3RpbmcgaGVhZGVyIGluc2lkZSBhIGBIZWFkZXJzYCBvYmplY3QsIG9yIGFkZHMgdGhlIGhlYWRlciBpZiBpdCBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0LlxuICAgKi9cbiAgc2V0KG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKCFpc1ZhbGlkSGVhZGVyTmFtZShuYW1lKSB8fCAhaXNWYWxpZEhlYWRlclZhbHVlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBub3JtYWxpemVkTmFtZSA9IG5vcm1hbGl6ZUhlYWRlck5hbWUobmFtZSk7XG4gICAgY29uc3Qgbm9ybWFsaXplZFZhbHVlID0gbm9ybWFsaXplSGVhZGVyVmFsdWUodmFsdWUpO1xuICAgIHRoaXNbTk9STUFMSVpFRF9IRUFERVJTXVtub3JtYWxpemVkTmFtZV0gPSBub3JtYWxpemVIZWFkZXJWYWx1ZShub3JtYWxpemVkVmFsdWUpO1xuICAgIHRoaXNbUkFXX0hFQURFUl9OQU1FU10uc2V0KG5vcm1hbGl6ZWROYW1lLCBuYW1lKTtcbiAgfVxuICAvKipcbiAgICogQXBwZW5kcyBhIG5ldyB2YWx1ZSBvbnRvIGFuIGV4aXN0aW5nIGhlYWRlciBpbnNpZGUgYSBgSGVhZGVyc2Agb2JqZWN0LCBvciBhZGRzIHRoZSBoZWFkZXIgaWYgaXQgZG9lcyBub3QgYWxyZWFkeSBleGlzdC5cbiAgICovXG4gIGFwcGVuZChuYW1lLCB2YWx1ZSkge1xuICAgIGlmICghaXNWYWxpZEhlYWRlck5hbWUobmFtZSkgfHwgIWlzVmFsaWRIZWFkZXJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgbm9ybWFsaXplZE5hbWUgPSBub3JtYWxpemVIZWFkZXJOYW1lKG5hbWUpO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRWYWx1ZSA9IG5vcm1hbGl6ZUhlYWRlclZhbHVlKHZhbHVlKTtcbiAgICBsZXQgcmVzb2x2ZWRWYWx1ZSA9IHRoaXMuaGFzKG5vcm1hbGl6ZWROYW1lKSA/IGAke3RoaXMuZ2V0KG5vcm1hbGl6ZWROYW1lKX0sICR7bm9ybWFsaXplZFZhbHVlfWAgOiBub3JtYWxpemVkVmFsdWU7XG4gICAgdGhpcy5zZXQobmFtZSwgcmVzb2x2ZWRWYWx1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZXMgYSBoZWFkZXIgZnJvbSB0aGUgYEhlYWRlcnNgIG9iamVjdC5cbiAgICovXG4gIGRlbGV0ZShuYW1lKSB7XG4gICAgaWYgKCFpc1ZhbGlkSGVhZGVyTmFtZShuYW1lKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaGFzKG5hbWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5vcm1hbGl6ZWROYW1lID0gbm9ybWFsaXplSGVhZGVyTmFtZShuYW1lKTtcbiAgICBkZWxldGUgdGhpc1tOT1JNQUxJWkVEX0hFQURFUlNdW25vcm1hbGl6ZWROYW1lXTtcbiAgICB0aGlzW1JBV19IRUFERVJfTkFNRVNdLmRlbGV0ZShub3JtYWxpemVkTmFtZSk7XG4gIH1cbiAgLyoqXG4gICAqIFRyYXZlcnNlcyB0aGUgYEhlYWRlcnNgIG9iamVjdCxcbiAgICogY2FsbGluZyB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGVhY2ggaGVhZGVyLlxuICAgKi9cbiAgZm9yRWFjaChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgIGZvciAoY29uc3QgW25hbWUsIHZhbHVlXSBvZiB0aGlzLmVudHJpZXMoKSkge1xuICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB2YWx1ZSwgbmFtZSwgdGhpcyk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIHZhbHVlc1xuICAgKiBvZiBhbGwgU2V0LUNvb2tpZSBoZWFkZXJzIGFzc29jaWF0ZWRcbiAgICogd2l0aCBhIHJlc3BvbnNlXG4gICAqL1xuICBnZXRTZXRDb29raWUoKSB7XG4gICAgY29uc3Qgc2V0Q29va2llSGVhZGVyID0gdGhpcy5nZXQoXCJzZXQtY29va2llXCIpO1xuICAgIGlmIChzZXRDb29raWVIZWFkZXIgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgaWYgKHNldENvb2tpZUhlYWRlciA9PT0gXCJcIikge1xuICAgICAgcmV0dXJuIFtcIlwiXTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBpbXBvcnRfc2V0X2Nvb2tpZV9wYXJzZXIuc3BsaXRDb29raWVzU3RyaW5nKShzZXRDb29raWVIZWFkZXIpO1xuICB9XG59O1xuXG4vLyBzcmMvZ2V0UmF3SGVhZGVycy50c1xuZnVuY3Rpb24gZ2V0UmF3SGVhZGVycyhoZWFkZXJzKSB7XG4gIGNvbnN0IHJhd0hlYWRlcnMgPSB7fTtcbiAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIGhlYWRlcnMuZW50cmllcygpKSB7XG4gICAgcmF3SGVhZGVyc1toZWFkZXJzW1JBV19IRUFERVJfTkFNRVNdLmdldChuYW1lKV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gcmF3SGVhZGVycztcbn1cblxuLy8gc3JjL3RyYW5zZm9ybWVycy9oZWFkZXJzVG9MaXN0LnRzXG5mdW5jdGlvbiBoZWFkZXJzVG9MaXN0KGhlYWRlcnMpIHtcbiAgY29uc3QgaGVhZGVyc0xpc3QgPSBbXTtcbiAgaGVhZGVycy5mb3JFYWNoKCh2YWx1ZSwgbmFtZSkgPT4ge1xuICAgIGNvbnN0IHJlc29sdmVkVmFsdWUgPSB2YWx1ZS5pbmNsdWRlcyhcIixcIikgPyB2YWx1ZS5zcGxpdChcIixcIikubWFwKCh2YWx1ZTIpID0+IHZhbHVlMi50cmltKCkpIDogdmFsdWU7XG4gICAgaGVhZGVyc0xpc3QucHVzaChbbmFtZSwgcmVzb2x2ZWRWYWx1ZV0pO1xuICB9KTtcbiAgcmV0dXJuIGhlYWRlcnNMaXN0O1xufVxuXG4vLyBzcmMvdHJhbnNmb3JtZXJzL2hlYWRlcnNUb1N0cmluZy50c1xuZnVuY3Rpb24gaGVhZGVyc1RvU3RyaW5nKGhlYWRlcnMpIHtcbiAgY29uc3QgbGlzdCA9IGhlYWRlcnNUb0xpc3QoaGVhZGVycyk7XG4gIGNvbnN0IGxpbmVzID0gbGlzdC5tYXAoKFtuYW1lLCB2YWx1ZV0pID0+IHtcbiAgICBjb25zdCB2YWx1ZXMgPSBbXS5jb25jYXQodmFsdWUpO1xuICAgIHJldHVybiBgJHtuYW1lfTogJHt2YWx1ZXMuam9pbihcIiwgXCIpfWA7XG4gIH0pO1xuICByZXR1cm4gbGluZXMuam9pbihcIlxcclxcblwiKTtcbn1cblxuLy8gc3JjL3RyYW5zZm9ybWVycy9oZWFkZXJzVG9PYmplY3QudHNcbnZhciBzaW5nbGVWYWx1ZUhlYWRlcnMgPSBbXCJ1c2VyLWFnZW50XCJdO1xuZnVuY3Rpb24gaGVhZGVyc1RvT2JqZWN0KGhlYWRlcnMpIHtcbiAgY29uc3QgaGVhZGVyc09iamVjdCA9IHt9O1xuICBoZWFkZXJzLmZvckVhY2goKHZhbHVlLCBuYW1lKSA9PiB7XG4gICAgY29uc3QgaXNNdWx0aVZhbHVlID0gIXNpbmdsZVZhbHVlSGVhZGVycy5pbmNsdWRlcyhuYW1lLnRvTG93ZXJDYXNlKCkpICYmIHZhbHVlLmluY2x1ZGVzKFwiLFwiKTtcbiAgICBoZWFkZXJzT2JqZWN0W25hbWVdID0gaXNNdWx0aVZhbHVlID8gdmFsdWUuc3BsaXQoXCIsXCIpLm1hcCgocykgPT4gcy50cmltKCkpIDogdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gaGVhZGVyc09iamVjdDtcbn1cblxuLy8gc3JjL3RyYW5zZm9ybWVycy9zdHJpbmdUb0hlYWRlcnMudHNcbmZ1bmN0aW9uIHN0cmluZ1RvSGVhZGVycyhzdHIpIHtcbiAgY29uc3QgbGluZXMgPSBzdHIudHJpbSgpLnNwbGl0KC9bXFxyXFxuXSsvKTtcbiAgcmV0dXJuIGxpbmVzLnJlZHVjZSgoaGVhZGVycywgbGluZSkgPT4ge1xuICAgIGlmIChsaW5lLnRyaW0oKSA9PT0gXCJcIikge1xuICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxuICAgIGNvbnN0IHBhcnRzID0gbGluZS5zcGxpdChcIjogXCIpO1xuICAgIGNvbnN0IG5hbWUgPSBwYXJ0cy5zaGlmdCgpO1xuICAgIGNvbnN0IHZhbHVlID0gcGFydHMuam9pbihcIjogXCIpO1xuICAgIGhlYWRlcnMuYXBwZW5kKG5hbWUsIHZhbHVlKTtcbiAgICByZXR1cm4gaGVhZGVycztcbiAgfSwgbmV3IEhlYWRlcnMoKSk7XG59XG5cbi8vIHNyYy90cmFuc2Zvcm1lcnMvbGlzdFRvSGVhZGVycy50c1xuZnVuY3Rpb24gbGlzdFRvSGVhZGVycyhsaXN0KSB7XG4gIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuICBsaXN0LmZvckVhY2goKFtuYW1lLCB2YWx1ZV0pID0+IHtcbiAgICBjb25zdCB2YWx1ZXMgPSBbXS5jb25jYXQodmFsdWUpO1xuICAgIHZhbHVlcy5mb3JFYWNoKCh2YWx1ZTIpID0+IHtcbiAgICAgIGhlYWRlcnMuYXBwZW5kKG5hbWUsIHZhbHVlMik7XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gaGVhZGVycztcbn1cblxuLy8gc3JjL3RyYW5zZm9ybWVycy9yZWR1Y2VIZWFkZXJzT2JqZWN0LnRzXG5mdW5jdGlvbiByZWR1Y2VIZWFkZXJzT2JqZWN0KGhlYWRlcnMsIHJlZHVjZXIsIGluaXRpYWxTdGF0ZSkge1xuICByZXR1cm4gT2JqZWN0LmtleXMoaGVhZGVycykucmVkdWNlKChuZXh0SGVhZGVycywgbmFtZSkgPT4ge1xuICAgIHJldHVybiByZWR1Y2VyKG5leHRIZWFkZXJzLCBuYW1lLCBoZWFkZXJzW25hbWVdKTtcbiAgfSwgaW5pdGlhbFN0YXRlKTtcbn1cblxuLy8gc3JjL3RyYW5zZm9ybWVycy9vYmplY3RUb0hlYWRlcnMudHNcbmZ1bmN0aW9uIG9iamVjdFRvSGVhZGVycyhoZWFkZXJzT2JqZWN0KSB7XG4gIHJldHVybiByZWR1Y2VIZWFkZXJzT2JqZWN0KFxuICAgIGhlYWRlcnNPYmplY3QsXG4gICAgKGhlYWRlcnMsIG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZXMgPSBbXS5jb25jYXQodmFsdWUpLmZpbHRlcihCb29sZWFuKTtcbiAgICAgIHZhbHVlcy5mb3JFYWNoKCh2YWx1ZTIpID0+IHtcbiAgICAgICAgaGVhZGVycy5hcHBlbmQobmFtZSwgdmFsdWUyKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfSxcbiAgICBuZXcgSGVhZGVycygpXG4gICk7XG59XG5cbi8vIHNyYy90cmFuc2Zvcm1lcnMvZmxhdHRlbkhlYWRlcnNMaXN0LnRzXG5mdW5jdGlvbiBmbGF0dGVuSGVhZGVyc0xpc3QobGlzdCkge1xuICByZXR1cm4gbGlzdC5tYXAoKFtuYW1lLCB2YWx1ZXNdKSA9PiB7XG4gICAgcmV0dXJuIFtuYW1lLCBbXS5jb25jYXQodmFsdWVzKS5qb2luKFwiLCBcIildO1xuICB9KTtcbn1cblxuLy8gc3JjL3RyYW5zZm9ybWVycy9mbGF0dGVuSGVhZGVyc09iamVjdC50c1xuZnVuY3Rpb24gZmxhdHRlbkhlYWRlcnNPYmplY3QoaGVhZGVyc09iamVjdCkge1xuICByZXR1cm4gcmVkdWNlSGVhZGVyc09iamVjdChcbiAgICBoZWFkZXJzT2JqZWN0LFxuICAgIChoZWFkZXJzLCBuYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgaGVhZGVyc1tuYW1lXSA9IFtdLmNvbmNhdCh2YWx1ZSkuam9pbihcIiwgXCIpO1xuICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfSxcbiAgICB7fVxuICApO1xufVxuZXhwb3J0IHtcbiAgSGVhZGVycyxcbiAgZmxhdHRlbkhlYWRlcnNMaXN0LFxuICBmbGF0dGVuSGVhZGVyc09iamVjdCxcbiAgZ2V0UmF3SGVhZGVycyxcbiAgaGVhZGVyc1RvTGlzdCxcbiAgaGVhZGVyc1RvT2JqZWN0LFxuICBoZWFkZXJzVG9TdHJpbmcsXG4gIGxpc3RUb0hlYWRlcnMsXG4gIG9iamVjdFRvSGVhZGVycyxcbiAgcmVkdWNlSGVhZGVyc09iamVjdCxcbiAgc3RyaW5nVG9IZWFkZXJzXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCIsImltcG9ydCAqIGFzIF9zeXNjYWxsczFfMCBmcm9tICdzcGFjZXRpbWU6c3lzQDEuMCc7XG5pbXBvcnQgeyByZWdpc3Rlcl9ob29rcyB9IGZyb20gJ3NwYWNldGltZTpzeXNAMS4wJztcbmltcG9ydCB7IHJlZ2lzdGVyX2hvb2tzIGFzIHJlZ2lzdGVyX2hvb2tzJDEgfSBmcm9tICdzcGFjZXRpbWU6c3lzQDEuMSc7XG5pbXBvcnQgKiBhcyBfc3lzY2FsbHMxXzIgZnJvbSAnc3BhY2V0aW1lOnN5c0AxLjInO1xuaW1wb3J0IHsgcmVnaXN0ZXJfaG9va3MgYXMgcmVnaXN0ZXJfaG9va3MkMiB9IGZyb20gJ3NwYWNldGltZTpzeXNAMS4yJztcbmltcG9ydCB7IGhlYWRlcnNUb0xpc3QsIEhlYWRlcnMgfSBmcm9tICdoZWFkZXJzLXBvbHlmaWxsJztcblxudHlwZW9mIGdsb2JhbFRoaXMhPT1cInVuZGVmaW5lZFwiJiYoKGdsb2JhbFRoaXMuZ2xvYmFsPWdsb2JhbFRoaXMuZ2xvYmFsfHxnbG9iYWxUaGlzKSwoZ2xvYmFsVGhpcy53aW5kb3c9Z2xvYmFsVGhpcy53aW5kb3d8fGdsb2JhbFRoaXMpKTtcbnZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19rbm93blN5bWJvbCA9IChuYW1lLCBzeW1ib2wpID0+IChzeW1ib2wgPSBTeW1ib2xbbmFtZV0pID8gc3ltYm9sIDogU3ltYm9sLmZvcihcIlN5bWJvbC5cIiArIG5hbWUpO1xudmFyIF9fdHlwZUVycm9yID0gKG1zZykgPT4ge1xuICB0aHJvdyBUeXBlRXJyb3IobXNnKTtcbn07XG52YXIgX19jb21tb25KUyA9IChjYiwgbW9kKSA9PiBmdW5jdGlvbiBfX3JlcXVpcmUoKSB7XG4gIHJldHVybiBtb2QgfHwgKDAsIGNiW19fZ2V0T3duUHJvcE5hbWVzKGNiKVswXV0pKChtb2QgPSB7IGV4cG9ydHM6IHt9IH0pLmV4cG9ydHMsIG1vZCksIG1vZC5leHBvcnRzO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvRVNNID0gKG1vZCwgaXNOb2RlTW9kZSwgdGFyZ2V0KSA9PiAodGFyZ2V0ID0gbW9kICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kKSkgOiB7fSwgX19jb3B5UHJvcHMoXG4gIC8vIElmIHRoZSBpbXBvcnRlciBpcyBpbiBub2RlIGNvbXBhdGliaWxpdHkgbW9kZSBvciB0aGlzIGlzIG5vdCBhbiBFU01cbiAgLy8gZmlsZSB0aGF0IGhhcyBiZWVuIGNvbnZlcnRlZCB0byBhIENvbW1vbkpTIGZpbGUgdXNpbmcgYSBCYWJlbC1cbiAgLy8gY29tcGF0aWJsZSB0cmFuc2Zvcm0gKGkuZS4gXCJfX2VzTW9kdWxlXCIgaGFzIG5vdCBiZWVuIHNldCksIHRoZW4gc2V0XG4gIC8vIFwiZGVmYXVsdFwiIHRvIHRoZSBDb21tb25KUyBcIm1vZHVsZS5leHBvcnRzXCIgZm9yIG5vZGUgY29tcGF0aWJpbGl0eS5cbiAgX19kZWZQcm9wKHRhcmdldCwgXCJkZWZhdWx0XCIsIHsgdmFsdWU6IG1vZCwgZW51bWVyYWJsZTogdHJ1ZSB9KSAsXG4gIG1vZFxuKSk7XG52YXIgX191c2luZyA9IChzdGFjaywgdmFsdWUsIGFzeW5jKSA9PiB7XG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgX190eXBlRXJyb3IoXCJPYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgdmFyIGRpc3Bvc2UsIGlubmVyO1xuICAgIGlmIChkaXNwb3NlID09PSB2b2lkIDApIHtcbiAgICAgIGRpc3Bvc2UgPSB2YWx1ZVtfX2tub3duU3ltYm9sKFwiZGlzcG9zZVwiKV07XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZGlzcG9zZSAhPT0gXCJmdW5jdGlvblwiKSBfX3R5cGVFcnJvcihcIk9iamVjdCBub3QgZGlzcG9zYWJsZVwiKTtcbiAgICBpZiAoaW5uZXIpIGRpc3Bvc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlubmVyLmNhbGwodGhpcyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHN0YWNrLnB1c2goW2FzeW5jLCBkaXNwb3NlLCB2YWx1ZV0pO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn07XG52YXIgX19jYWxsRGlzcG9zZSA9IChzdGFjaywgZXJyb3IsIGhhc0Vycm9yKSA9PiB7XG4gIHZhciBFID0gdHlwZW9mIFN1cHByZXNzZWRFcnJvciA9PT0gXCJmdW5jdGlvblwiID8gU3VwcHJlc3NlZEVycm9yIDogZnVuY3Rpb24oZSwgcywgbSwgXykge1xuICAgIHJldHVybiBfID0gRXJyb3IobSksIF8ubmFtZSA9IFwiU3VwcHJlc3NlZEVycm9yXCIsIF8uZXJyb3IgPSBlLCBfLnN1cHByZXNzZWQgPSBzLCBfO1xuICB9O1xuICB2YXIgZmFpbCA9IChlKSA9PiBlcnJvciA9IGhhc0Vycm9yID8gbmV3IEUoZSwgZXJyb3IsIFwiQW4gZXJyb3Igd2FzIHN1cHByZXNzZWQgZHVyaW5nIGRpc3Bvc2FsXCIpIDogKGhhc0Vycm9yID0gdHJ1ZSwgZSk7XG4gIHZhciBuZXh0ID0gKGl0KSA9PiB7XG4gICAgd2hpbGUgKGl0ID0gc3RhY2sucG9wKCkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBpdFsxXSAmJiBpdFsxXS5jYWxsKGl0WzJdKTtcbiAgICAgICAgaWYgKGl0WzBdKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCkudGhlbihuZXh0LCAoZSkgPT4gKGZhaWwoZSksIG5leHQoKSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBmYWlsKGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaGFzRXJyb3IpIHRocm93IGVycm9yO1xuICB9O1xuICByZXR1cm4gbmV4dCgpO1xufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Jhc2U2NC1qc0AxLjUuMS9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzXG52YXIgcmVxdWlyZV9iYXNlNjRfanMgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYmFzZTY0LWpzQDEuNS4xL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanNcIihleHBvcnRzKSB7XG4gICAgZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aDtcbiAgICBleHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXk7XG4gICAgZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheTI7XG4gICAgdmFyIGxvb2t1cCA9IFtdO1xuICAgIHZhciByZXZMb29rdXAgPSBbXTtcbiAgICB2YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09IFwidW5kZWZpbmVkXCIgPyBVaW50OEFycmF5IDogQXJyYXk7XG4gICAgdmFyIGNvZGUgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIjtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBsb29rdXBbaV0gPSBjb2RlW2ldO1xuICAgICAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpO1xuICAgIH1cbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuO1xuICAgIHJldkxvb2t1cFtcIi1cIi5jaGFyQ29kZUF0KDApXSA9IDYyO1xuICAgIHJldkxvb2t1cFtcIl9cIi5jaGFyQ29kZUF0KDApXSA9IDYzO1xuICAgIGZ1bmN0aW9uIGdldExlbnMoYjY0KSB7XG4gICAgICB2YXIgbGVuMiA9IGI2NC5sZW5ndGg7XG4gICAgICBpZiAobGVuMiAlIDQgPiAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDRcIik7XG4gICAgICB9XG4gICAgICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZihcIj1cIik7XG4gICAgICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlbjI7XG4gICAgICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlbjIgPyAwIDogNCAtIHZhbGlkTGVuICUgNDtcbiAgICAgIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJ5dGVMZW5ndGgoYjY0KSB7XG4gICAgICB2YXIgbGVucyA9IGdldExlbnMoYjY0KTtcbiAgICAgIHZhciB2YWxpZExlbiA9IGxlbnNbMF07XG4gICAgICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXTtcbiAgICAgIHJldHVybiAodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQgLSBwbGFjZUhvbGRlcnNMZW47XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICAgICAgcmV0dXJuICh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCAtIHBsYWNlSG9sZGVyc0xlbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gdG9CeXRlQXJyYXkoYjY0KSB7XG4gICAgICB2YXIgdG1wO1xuICAgICAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NCk7XG4gICAgICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdO1xuICAgICAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV07XG4gICAgICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKTtcbiAgICAgIHZhciBjdXJCeXRlID0gMDtcbiAgICAgIHZhciBsZW4yID0gcGxhY2VIb2xkZXJzTGVuID4gMCA/IHZhbGlkTGVuIC0gNCA6IHZhbGlkTGVuO1xuICAgICAgdmFyIGkyO1xuICAgICAgZm9yIChpMiA9IDA7IGkyIDwgbGVuMjsgaTIgKz0gNCkge1xuICAgICAgICB0bXAgPSByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaTIpXSA8PCAxOCB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpMiArIDEpXSA8PCAxMiB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpMiArIDIpXSA8PCA2IHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkyICsgMyldO1xuICAgICAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCA+PiAxNiAmIDI1NTtcbiAgICAgICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgPj4gOCAmIDI1NTtcbiAgICAgICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAyNTU7XG4gICAgICB9XG4gICAgICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgICAgIHRtcCA9IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpMildIDw8IDIgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaTIgKyAxKV0gPj4gNDtcbiAgICAgICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAyNTU7XG4gICAgICB9XG4gICAgICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgICAgIHRtcCA9IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpMildIDw8IDEwIHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkyICsgMSldIDw8IDQgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaTIgKyAyKV0gPj4gMjtcbiAgICAgICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgPj4gOCAmIDI1NTtcbiAgICAgICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAyNTU7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQobnVtKSB7XG4gICAgICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDYzXSArIGxvb2t1cFtudW0gPj4gMTIgJiA2M10gKyBsb29rdXBbbnVtID4+IDYgJiA2M10gKyBsb29rdXBbbnVtICYgNjNdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbmNvZGVDaHVuayh1aW50OCwgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIHRtcDtcbiAgICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkyID0gc3RhcnQ7IGkyIDwgZW5kOyBpMiArPSAzKSB7XG4gICAgICAgIHRtcCA9ICh1aW50OFtpMl0gPDwgMTYgJiAxNjcxMTY4MCkgKyAodWludDhbaTIgKyAxXSA8PCA4ICYgNjUyODApICsgKHVpbnQ4W2kyICsgMl0gJiAyNTUpO1xuICAgICAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0cHV0LmpvaW4oXCJcIik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZyb21CeXRlQXJyYXkyKHVpbnQ4KSB7XG4gICAgICB2YXIgdG1wO1xuICAgICAgdmFyIGxlbjIgPSB1aW50OC5sZW5ndGg7XG4gICAgICB2YXIgZXh0cmFCeXRlcyA9IGxlbjIgJSAzO1xuICAgICAgdmFyIHBhcnRzID0gW107XG4gICAgICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MztcbiAgICAgIGZvciAodmFyIGkyID0gMCwgbGVuMjIgPSBsZW4yIC0gZXh0cmFCeXRlczsgaTIgPCBsZW4yMjsgaTIgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICAgICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaTIsIGkyICsgbWF4Q2h1bmtMZW5ndGggPiBsZW4yMiA/IGxlbjIyIDogaTIgKyBtYXhDaHVua0xlbmd0aCkpO1xuICAgICAgfVxuICAgICAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICAgICAgdG1wID0gdWludDhbbGVuMiAtIDFdO1xuICAgICAgICBwYXJ0cy5wdXNoKFxuICAgICAgICAgIGxvb2t1cFt0bXAgPj4gMl0gKyBsb29rdXBbdG1wIDw8IDQgJiA2M10gKyBcIj09XCJcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgICAgICB0bXAgPSAodWludDhbbGVuMiAtIDJdIDw8IDgpICsgdWludDhbbGVuMiAtIDFdO1xuICAgICAgICBwYXJ0cy5wdXNoKFxuICAgICAgICAgIGxvb2t1cFt0bXAgPj4gMTBdICsgbG9va3VwW3RtcCA+PiA0ICYgNjNdICsgbG9va3VwW3RtcCA8PCAyICYgNjNdICsgXCI9XCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJ0cy5qb2luKFwiXCIpO1xuICAgIH1cbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9mYXN0LXRleHQtZW5jb2RpbmdAMS4wLjYvbm9kZV9tb2R1bGVzL2Zhc3QtdGV4dC1lbmNvZGluZy90ZXh0Lm1pbi5qc1xudmFyIHJlcXVpcmVfdGV4dF9taW4gPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZmFzdC10ZXh0LWVuY29kaW5nQDEuMC42L25vZGVfbW9kdWxlcy9mYXN0LXRleHQtZW5jb2RpbmcvdGV4dC5taW4uanNcIihleHBvcnRzKSB7XG4gICAgKGZ1bmN0aW9uKHNjb3BlKSB7XG4gICAgICBmdW5jdGlvbiBCKHIsIGUpIHtcbiAgICAgICAgdmFyIGY7XG4gICAgICAgIHJldHVybiByIGluc3RhbmNlb2YgQnVmZmVyID8gZiA9IHIgOiBmID0gQnVmZmVyLmZyb20oci5idWZmZXIsIHIuYnl0ZU9mZnNldCwgci5ieXRlTGVuZ3RoKSwgZi50b1N0cmluZyhlKTtcbiAgICAgIH1cbiAgICAgIHZhciB3ID0gZnVuY3Rpb24ocikge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20ocik7XG4gICAgICB9O1xuICAgICAgZnVuY3Rpb24gaChyKSB7XG4gICAgICAgIGZvciAodmFyIGUgPSAwLCBmID0gTWF0aC5taW4oMjU2ICogMjU2LCByLmxlbmd0aCArIDEpLCBuID0gbmV3IFVpbnQxNkFycmF5KGYpLCBpID0gW10sIG8gPSAwOyA7ICkge1xuICAgICAgICAgIHZhciB0MiA9IGUgPCByLmxlbmd0aDtcbiAgICAgICAgICBpZiAoIXQyIHx8IG8gPj0gZiAtIDEpIHtcbiAgICAgICAgICAgIHZhciBzID0gbi5zdWJhcnJheSgwLCBvKSwgbSA9IHM7XG4gICAgICAgICAgICBpZiAoaS5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbSkpLCAhdDIpIHJldHVybiBpLmpvaW4oXCJcIik7XG4gICAgICAgICAgICByID0gci5zdWJhcnJheShlKSwgZSA9IDAsIG8gPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgYSA9IHJbZSsrXTtcbiAgICAgICAgICBpZiAoKGEgJiAxMjgpID09PSAwKSBuW28rK10gPSBhO1xuICAgICAgICAgIGVsc2UgaWYgKChhICYgMjI0KSA9PT0gMTkyKSB7XG4gICAgICAgICAgICB2YXIgZCA9IHJbZSsrXSAmIDYzO1xuICAgICAgICAgICAgbltvKytdID0gKGEgJiAzMSkgPDwgNiB8IGQ7XG4gICAgICAgICAgfSBlbHNlIGlmICgoYSAmIDI0MCkgPT09IDIyNCkge1xuICAgICAgICAgICAgdmFyIGQgPSByW2UrK10gJiA2MywgbCA9IHJbZSsrXSAmIDYzO1xuICAgICAgICAgICAgbltvKytdID0gKGEgJiAzMSkgPDwgMTIgfCBkIDw8IDYgfCBsO1xuICAgICAgICAgIH0gZWxzZSBpZiAoKGEgJiAyNDgpID09PSAyNDApIHtcbiAgICAgICAgICAgIHZhciBkID0gcltlKytdICYgNjMsIGwgPSByW2UrK10gJiA2MywgUiA9IHJbZSsrXSAmIDYzLCBjID0gKGEgJiA3KSA8PCAxOCB8IGQgPDwgMTIgfCBsIDw8IDYgfCBSO1xuICAgICAgICAgICAgYyA+IDY1NTM1ICYmIChjIC09IDY1NTM2LCBuW28rK10gPSBjID4+PiAxMCAmIDEwMjMgfCA1NTI5NiwgYyA9IDU2MzIwIHwgYyAmIDEwMjMpLCBuW28rK10gPSBjO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gRihyKSB7XG4gICAgICAgIGZvciAodmFyIGUgPSAwLCBmID0gci5sZW5ndGgsIG4gPSAwLCBpID0gTWF0aC5tYXgoMzIsIGYgKyAoZiA+Pj4gMSkgKyA3KSwgbyA9IG5ldyBVaW50OEFycmF5KGkgPj4+IDMgPDwgMyk7IGUgPCBmOyApIHtcbiAgICAgICAgICB2YXIgdDIgPSByLmNoYXJDb2RlQXQoZSsrKTtcbiAgICAgICAgICBpZiAodDIgPj0gNTUyOTYgJiYgdDIgPD0gNTYzMTkpIHtcbiAgICAgICAgICAgIGlmIChlIDwgZikge1xuICAgICAgICAgICAgICB2YXIgcyA9IHIuY2hhckNvZGVBdChlKTtcbiAgICAgICAgICAgICAgKHMgJiA2NDUxMikgPT09IDU2MzIwICYmICgrK2UsIHQyID0gKCh0MiAmIDEwMjMpIDw8IDEwKSArIChzICYgMTAyMykgKyA2NTUzNik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodDIgPj0gNTUyOTYgJiYgdDIgPD0gNTYzMTkpIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobiArIDQgPiBvLmxlbmd0aCkge1xuICAgICAgICAgICAgaSArPSA4LCBpICo9IDEgKyBlIC8gci5sZW5ndGggKiAyLCBpID0gaSA+Pj4gMyA8PCAzO1xuICAgICAgICAgICAgdmFyIG0gPSBuZXcgVWludDhBcnJheShpKTtcbiAgICAgICAgICAgIG0uc2V0KG8pLCBvID0gbTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCh0MiAmIDQyOTQ5NjcxNjgpID09PSAwKSB7XG4gICAgICAgICAgICBvW24rK10gPSB0MjtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoKHQyICYgNDI5NDk2NTI0OCkgPT09IDApIG9bbisrXSA9IHQyID4+PiA2ICYgMzEgfCAxOTI7XG4gICAgICAgICAgZWxzZSBpZiAoKHQyICYgNDI5NDkwMTc2MCkgPT09IDApIG9bbisrXSA9IHQyID4+PiAxMiAmIDE1IHwgMjI0LCBvW24rK10gPSB0MiA+Pj4gNiAmIDYzIHwgMTI4O1xuICAgICAgICAgIGVsc2UgaWYgKCh0MiAmIDQyOTI4NzAxNDQpID09PSAwKSBvW24rK10gPSB0MiA+Pj4gMTggJiA3IHwgMjQwLCBvW24rK10gPSB0MiA+Pj4gMTIgJiA2MyB8IDEyOCwgb1tuKytdID0gdDIgPj4+IDYgJiA2MyB8IDEyODtcbiAgICAgICAgICBlbHNlIGNvbnRpbnVlO1xuICAgICAgICAgIG9bbisrXSA9IHQyICYgNjMgfCAxMjg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG8uc2xpY2UgPyBvLnNsaWNlKDAsIG4pIDogby5zdWJhcnJheSgwLCBuKTtcbiAgICAgIH1cbiAgICAgIHZhciB1ID0gXCJGYWlsZWQgdG8gXCIsIHAgPSBmdW5jdGlvbihyLCBlLCBmKSB7XG4gICAgICAgIGlmIChyKSB0aHJvdyBuZXcgRXJyb3IoXCJcIi5jb25jYXQodSkuY29uY2F0KGUsIFwiOiB0aGUgJ1wiKS5jb25jYXQoZiwgXCInIG9wdGlvbiBpcyB1bnN1cHBvcnRlZC5cIikpO1xuICAgICAgfTtcbiAgICAgIHZhciB4ID0gdHlwZW9mIEJ1ZmZlciA9PSBcImZ1bmN0aW9uXCIgJiYgQnVmZmVyLmZyb207XG4gICAgICB2YXIgQSA9IHggPyB3IDogRjtcbiAgICAgIGZ1bmN0aW9uIHYoKSB7XG4gICAgICAgIHRoaXMuZW5jb2RpbmcgPSBcInV0Zi04XCI7XG4gICAgICB9XG4gICAgICB2LnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbihyLCBlKSB7XG4gICAgICAgIHJldHVybiBwKGUgJiYgZS5zdHJlYW0sIFwiZW5jb2RlXCIsIFwic3RyZWFtXCIpLCBBKHIpO1xuICAgICAgfTtcbiAgICAgIGZ1bmN0aW9uIFUocikge1xuICAgICAgICB2YXIgZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgZiA9IG5ldyBCbG9iKFtyXSwgeyB0eXBlOiBcInRleHQvcGxhaW47Y2hhcnNldD1VVEYtOFwiIH0pO1xuICAgICAgICAgIGUgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGYpO1xuICAgICAgICAgIHZhciBuID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgcmV0dXJuIG4ub3BlbihcIkdFVFwiLCBlLCBmYWxzZSksIG4uc2VuZCgpLCBuLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBlICYmIFVSTC5yZXZva2VPYmplY3RVUkwoZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBPID0gIXggJiYgdHlwZW9mIEJsb2IgPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBVUkwgPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09IFwiZnVuY3Rpb25cIiwgUyA9IFtcInV0Zi04XCIsIFwidXRmOFwiLCBcInVuaWNvZGUtMS0xLXV0Zi04XCJdLCBUID0gaDtcbiAgICAgIHggPyBUID0gQiA6IE8gJiYgKFQgPSBmdW5jdGlvbihyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIFUocik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXR1cm4gaChyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB2YXIgeSA9IFwiY29uc3RydWN0ICdUZXh0RGVjb2RlcidcIiwgRSA9IFwiXCIuY29uY2F0KHUsIFwiIFwiKS5jb25jYXQoeSwgXCI6IHRoZSBcIik7XG4gICAgICBmdW5jdGlvbiBnKHIsIGUpIHtcbiAgICAgICAgcChlICYmIGUuZmF0YWwsIHksIFwiZmF0YWxcIiksIHIgPSByIHx8IFwidXRmLThcIjtcbiAgICAgICAgdmFyIGY7XG4gICAgICAgIGlmICh4ID8gZiA9IEJ1ZmZlci5pc0VuY29kaW5nKHIpIDogZiA9IFMuaW5kZXhPZihyLnRvTG93ZXJDYXNlKCkpICE9PSAtMSwgIWYpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiXCIuY29uY2F0KEUsIFwiIGVuY29kaW5nIGxhYmVsIHByb3ZpZGVkICgnXCIpLmNvbmNhdChyLCBcIicpIGlzIGludmFsaWQuXCIpKTtcbiAgICAgICAgdGhpcy5lbmNvZGluZyA9IHIsIHRoaXMuZmF0YWwgPSBmYWxzZSwgdGhpcy5pZ25vcmVCT00gPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGcucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uKHIsIGUpIHtcbiAgICAgICAgcChlICYmIGUuc3RyZWFtLCBcImRlY29kZVwiLCBcInN0cmVhbVwiKTtcbiAgICAgICAgdmFyIGY7XG4gICAgICAgIHJldHVybiByIGluc3RhbmNlb2YgVWludDhBcnJheSA/IGYgPSByIDogci5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciA/IGYgPSBuZXcgVWludDhBcnJheShyLmJ1ZmZlcikgOiBmID0gbmV3IFVpbnQ4QXJyYXkociksIFQoZiwgdGhpcy5lbmNvZGluZyk7XG4gICAgICB9O1xuICAgICAgc2NvcGUuVGV4dEVuY29kZXIgPSBzY29wZS5UZXh0RW5jb2RlciB8fCB2O1xuICAgICAgc2NvcGUuVGV4dERlY29kZXIgPSBzY29wZS5UZXh0RGVjb2RlciB8fCBnO1xuICAgIH0pKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogZXhwb3J0cyk7XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vc3RhdHVzZXNAMi4wLjIvbm9kZV9tb2R1bGVzL3N0YXR1c2VzL2NvZGVzLmpzb25cbnZhciByZXF1aXJlX2NvZGVzID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3N0YXR1c2VzQDIuMC4yL25vZGVfbW9kdWxlcy9zdGF0dXNlcy9jb2Rlcy5qc29uXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICBcIjEwMFwiOiBcIkNvbnRpbnVlXCIsXG4gICAgICBcIjEwMVwiOiBcIlN3aXRjaGluZyBQcm90b2NvbHNcIixcbiAgICAgIFwiMTAyXCI6IFwiUHJvY2Vzc2luZ1wiLFxuICAgICAgXCIxMDNcIjogXCJFYXJseSBIaW50c1wiLFxuICAgICAgXCIyMDBcIjogXCJPS1wiLFxuICAgICAgXCIyMDFcIjogXCJDcmVhdGVkXCIsXG4gICAgICBcIjIwMlwiOiBcIkFjY2VwdGVkXCIsXG4gICAgICBcIjIwM1wiOiBcIk5vbi1BdXRob3JpdGF0aXZlIEluZm9ybWF0aW9uXCIsXG4gICAgICBcIjIwNFwiOiBcIk5vIENvbnRlbnRcIixcbiAgICAgIFwiMjA1XCI6IFwiUmVzZXQgQ29udGVudFwiLFxuICAgICAgXCIyMDZcIjogXCJQYXJ0aWFsIENvbnRlbnRcIixcbiAgICAgIFwiMjA3XCI6IFwiTXVsdGktU3RhdHVzXCIsXG4gICAgICBcIjIwOFwiOiBcIkFscmVhZHkgUmVwb3J0ZWRcIixcbiAgICAgIFwiMjI2XCI6IFwiSU0gVXNlZFwiLFxuICAgICAgXCIzMDBcIjogXCJNdWx0aXBsZSBDaG9pY2VzXCIsXG4gICAgICBcIjMwMVwiOiBcIk1vdmVkIFBlcm1hbmVudGx5XCIsXG4gICAgICBcIjMwMlwiOiBcIkZvdW5kXCIsXG4gICAgICBcIjMwM1wiOiBcIlNlZSBPdGhlclwiLFxuICAgICAgXCIzMDRcIjogXCJOb3QgTW9kaWZpZWRcIixcbiAgICAgIFwiMzA1XCI6IFwiVXNlIFByb3h5XCIsXG4gICAgICBcIjMwN1wiOiBcIlRlbXBvcmFyeSBSZWRpcmVjdFwiLFxuICAgICAgXCIzMDhcIjogXCJQZXJtYW5lbnQgUmVkaXJlY3RcIixcbiAgICAgIFwiNDAwXCI6IFwiQmFkIFJlcXVlc3RcIixcbiAgICAgIFwiNDAxXCI6IFwiVW5hdXRob3JpemVkXCIsXG4gICAgICBcIjQwMlwiOiBcIlBheW1lbnQgUmVxdWlyZWRcIixcbiAgICAgIFwiNDAzXCI6IFwiRm9yYmlkZGVuXCIsXG4gICAgICBcIjQwNFwiOiBcIk5vdCBGb3VuZFwiLFxuICAgICAgXCI0MDVcIjogXCJNZXRob2QgTm90IEFsbG93ZWRcIixcbiAgICAgIFwiNDA2XCI6IFwiTm90IEFjY2VwdGFibGVcIixcbiAgICAgIFwiNDA3XCI6IFwiUHJveHkgQXV0aGVudGljYXRpb24gUmVxdWlyZWRcIixcbiAgICAgIFwiNDA4XCI6IFwiUmVxdWVzdCBUaW1lb3V0XCIsXG4gICAgICBcIjQwOVwiOiBcIkNvbmZsaWN0XCIsXG4gICAgICBcIjQxMFwiOiBcIkdvbmVcIixcbiAgICAgIFwiNDExXCI6IFwiTGVuZ3RoIFJlcXVpcmVkXCIsXG4gICAgICBcIjQxMlwiOiBcIlByZWNvbmRpdGlvbiBGYWlsZWRcIixcbiAgICAgIFwiNDEzXCI6IFwiUGF5bG9hZCBUb28gTGFyZ2VcIixcbiAgICAgIFwiNDE0XCI6IFwiVVJJIFRvbyBMb25nXCIsXG4gICAgICBcIjQxNVwiOiBcIlVuc3VwcG9ydGVkIE1lZGlhIFR5cGVcIixcbiAgICAgIFwiNDE2XCI6IFwiUmFuZ2UgTm90IFNhdGlzZmlhYmxlXCIsXG4gICAgICBcIjQxN1wiOiBcIkV4cGVjdGF0aW9uIEZhaWxlZFwiLFxuICAgICAgXCI0MThcIjogXCJJJ20gYSBUZWFwb3RcIixcbiAgICAgIFwiNDIxXCI6IFwiTWlzZGlyZWN0ZWQgUmVxdWVzdFwiLFxuICAgICAgXCI0MjJcIjogXCJVbnByb2Nlc3NhYmxlIEVudGl0eVwiLFxuICAgICAgXCI0MjNcIjogXCJMb2NrZWRcIixcbiAgICAgIFwiNDI0XCI6IFwiRmFpbGVkIERlcGVuZGVuY3lcIixcbiAgICAgIFwiNDI1XCI6IFwiVG9vIEVhcmx5XCIsXG4gICAgICBcIjQyNlwiOiBcIlVwZ3JhZGUgUmVxdWlyZWRcIixcbiAgICAgIFwiNDI4XCI6IFwiUHJlY29uZGl0aW9uIFJlcXVpcmVkXCIsXG4gICAgICBcIjQyOVwiOiBcIlRvbyBNYW55IFJlcXVlc3RzXCIsXG4gICAgICBcIjQzMVwiOiBcIlJlcXVlc3QgSGVhZGVyIEZpZWxkcyBUb28gTGFyZ2VcIixcbiAgICAgIFwiNDUxXCI6IFwiVW5hdmFpbGFibGUgRm9yIExlZ2FsIFJlYXNvbnNcIixcbiAgICAgIFwiNTAwXCI6IFwiSW50ZXJuYWwgU2VydmVyIEVycm9yXCIsXG4gICAgICBcIjUwMVwiOiBcIk5vdCBJbXBsZW1lbnRlZFwiLFxuICAgICAgXCI1MDJcIjogXCJCYWQgR2F0ZXdheVwiLFxuICAgICAgXCI1MDNcIjogXCJTZXJ2aWNlIFVuYXZhaWxhYmxlXCIsXG4gICAgICBcIjUwNFwiOiBcIkdhdGV3YXkgVGltZW91dFwiLFxuICAgICAgXCI1MDVcIjogXCJIVFRQIFZlcnNpb24gTm90IFN1cHBvcnRlZFwiLFxuICAgICAgXCI1MDZcIjogXCJWYXJpYW50IEFsc28gTmVnb3RpYXRlc1wiLFxuICAgICAgXCI1MDdcIjogXCJJbnN1ZmZpY2llbnQgU3RvcmFnZVwiLFxuICAgICAgXCI1MDhcIjogXCJMb29wIERldGVjdGVkXCIsXG4gICAgICBcIjUwOVwiOiBcIkJhbmR3aWR0aCBMaW1pdCBFeGNlZWRlZFwiLFxuICAgICAgXCI1MTBcIjogXCJOb3QgRXh0ZW5kZWRcIixcbiAgICAgIFwiNTExXCI6IFwiTmV0d29yayBBdXRoZW50aWNhdGlvbiBSZXF1aXJlZFwiXG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9zdGF0dXNlc0AyLjAuMi9ub2RlX21vZHVsZXMvc3RhdHVzZXMvaW5kZXguanNcbnZhciByZXF1aXJlX3N0YXR1c2VzID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3N0YXR1c2VzQDIuMC4yL25vZGVfbW9kdWxlcy9zdGF0dXNlcy9pbmRleC5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIHZhciBjb2RlcyA9IHJlcXVpcmVfY29kZXMoKTtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHN0YXR1czI7XG4gICAgc3RhdHVzMi5tZXNzYWdlID0gY29kZXM7XG4gICAgc3RhdHVzMi5jb2RlID0gY3JlYXRlTWVzc2FnZVRvU3RhdHVzQ29kZU1hcChjb2Rlcyk7XG4gICAgc3RhdHVzMi5jb2RlcyA9IGNyZWF0ZVN0YXR1c0NvZGVMaXN0KGNvZGVzKTtcbiAgICBzdGF0dXMyLnJlZGlyZWN0ID0ge1xuICAgICAgMzAwOiB0cnVlLFxuICAgICAgMzAxOiB0cnVlLFxuICAgICAgMzAyOiB0cnVlLFxuICAgICAgMzAzOiB0cnVlLFxuICAgICAgMzA1OiB0cnVlLFxuICAgICAgMzA3OiB0cnVlLFxuICAgICAgMzA4OiB0cnVlXG4gICAgfTtcbiAgICBzdGF0dXMyLmVtcHR5ID0ge1xuICAgICAgMjA0OiB0cnVlLFxuICAgICAgMjA1OiB0cnVlLFxuICAgICAgMzA0OiB0cnVlXG4gICAgfTtcbiAgICBzdGF0dXMyLnJldHJ5ID0ge1xuICAgICAgNTAyOiB0cnVlLFxuICAgICAgNTAzOiB0cnVlLFxuICAgICAgNTA0OiB0cnVlXG4gICAgfTtcbiAgICBmdW5jdGlvbiBjcmVhdGVNZXNzYWdlVG9TdGF0dXNDb2RlTWFwKGNvZGVzMikge1xuICAgICAgdmFyIG1hcCA9IHt9O1xuICAgICAgT2JqZWN0LmtleXMoY29kZXMyKS5mb3JFYWNoKGZ1bmN0aW9uIGZvckVhY2hDb2RlKGNvZGUpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBjb2RlczJbY29kZV07XG4gICAgICAgIHZhciBzdGF0dXMzID0gTnVtYmVyKGNvZGUpO1xuICAgICAgICBtYXBbbWVzc2FnZS50b0xvd2VyQ2FzZSgpXSA9IHN0YXR1czM7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBtYXA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVN0YXR1c0NvZGVMaXN0KGNvZGVzMikge1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGNvZGVzMikubWFwKGZ1bmN0aW9uIG1hcENvZGUoY29kZSkge1xuICAgICAgICByZXR1cm4gTnVtYmVyKGNvZGUpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFN0YXR1c0NvZGUobWVzc2FnZSkge1xuICAgICAgdmFyIG1zZyA9IG1lc3NhZ2UudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHN0YXR1czIuY29kZSwgbXNnKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc3RhdHVzIG1lc3NhZ2U6IFwiJyArIG1lc3NhZ2UgKyAnXCInKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdGF0dXMyLmNvZGVbbXNnXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0U3RhdHVzTWVzc2FnZShjb2RlKSB7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzdGF0dXMyLm1lc3NhZ2UsIGNvZGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgc3RhdHVzIGNvZGU6IFwiICsgY29kZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RhdHVzMi5tZXNzYWdlW2NvZGVdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdGF0dXMyKGNvZGUpIHtcbiAgICAgIGlmICh0eXBlb2YgY29kZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gZ2V0U3RhdHVzTWVzc2FnZShjb2RlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgY29kZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY29kZSBtdXN0IGJlIGEgbnVtYmVyIG9yIHN0cmluZ1wiKTtcbiAgICAgIH1cbiAgICAgIHZhciBuID0gcGFyc2VJbnQoY29kZSwgMTApO1xuICAgICAgaWYgKCFpc05hTihuKSkge1xuICAgICAgICByZXR1cm4gZ2V0U3RhdHVzTWVzc2FnZShuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRTdGF0dXNDb2RlKGNvZGUpO1xuICAgIH1cbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvdGltZV9kdXJhdGlvbi50c1xudmFyIFRpbWVEdXJhdGlvbiA9IGNsYXNzIF9UaW1lRHVyYXRpb24ge1xuICBfX3RpbWVfZHVyYXRpb25fbWljcm9zX187XG4gIHN0YXRpYyBNSUNST1NfUEVSX01JTExJUyA9IDEwMDBuO1xuICAvKipcbiAgICogR2V0IHRoZSBhbGdlYnJhaWMgdHlwZSByZXByZXNlbnRhdGlvbiBvZiB0aGUge0BsaW5rIFRpbWVEdXJhdGlvbn0gdHlwZS5cbiAgICogQHJldHVybnMgVGhlIGFsZ2VicmFpYyB0eXBlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0eXBlLlxuICAgKi9cbiAgc3RhdGljIGdldEFsZ2VicmFpY1R5cGUoKSB7XG4gICAgcmV0dXJuIEFsZ2VicmFpY1R5cGUuUHJvZHVjdCh7XG4gICAgICBlbGVtZW50czogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJfX3RpbWVfZHVyYXRpb25fbWljcm9zX19cIixcbiAgICAgICAgICBhbGdlYnJhaWNUeXBlOiBBbGdlYnJhaWNUeXBlLkk2NFxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGlzVGltZUR1cmF0aW9uKGFsZ2VicmFpY1R5cGUpIHtcbiAgICBpZiAoYWxnZWJyYWljVHlwZS50YWcgIT09IFwiUHJvZHVjdFwiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGVsZW1lbnRzID0gYWxnZWJyYWljVHlwZS52YWx1ZS5lbGVtZW50cztcbiAgICBpZiAoZWxlbWVudHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IG1pY3Jvc0VsZW1lbnQgPSBlbGVtZW50c1swXTtcbiAgICByZXR1cm4gbWljcm9zRWxlbWVudC5uYW1lID09PSBcIl9fdGltZV9kdXJhdGlvbl9taWNyb3NfX1wiICYmIG1pY3Jvc0VsZW1lbnQuYWxnZWJyYWljVHlwZS50YWcgPT09IFwiSTY0XCI7XG4gIH1cbiAgZ2V0IG1pY3JvcygpIHtcbiAgICByZXR1cm4gdGhpcy5fX3RpbWVfZHVyYXRpb25fbWljcm9zX187XG4gIH1cbiAgZ2V0IG1pbGxpcygpIHtcbiAgICByZXR1cm4gTnVtYmVyKHRoaXMubWljcm9zIC8gX1RpbWVEdXJhdGlvbi5NSUNST1NfUEVSX01JTExJUyk7XG4gIH1cbiAgY29uc3RydWN0b3IobWljcm9zKSB7XG4gICAgdGhpcy5fX3RpbWVfZHVyYXRpb25fbWljcm9zX18gPSBtaWNyb3M7XG4gIH1cbiAgc3RhdGljIGZyb21NaWxsaXMobWlsbGlzKSB7XG4gICAgcmV0dXJuIG5ldyBfVGltZUR1cmF0aW9uKEJpZ0ludChtaWxsaXMpICogX1RpbWVEdXJhdGlvbi5NSUNST1NfUEVSX01JTExJUyk7XG4gIH1cbiAgLyoqIFRoaXMgb3V0cHV0cyB0aGUgc2FtZSBzdHJpbmcgZm9ybWF0IHRoYXQgd2UgdXNlIGluIHRoZSBob3N0IGFuZCBpbiBSdXN0IG1vZHVsZXMgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgY29uc3QgbWljcm9zID0gdGhpcy5taWNyb3M7XG4gICAgY29uc3Qgc2lnbiA9IG1pY3JvcyA8IDAgPyBcIi1cIiA6IFwiK1wiO1xuICAgIGNvbnN0IHBvcyA9IG1pY3JvcyA8IDAgPyAtbWljcm9zIDogbWljcm9zO1xuICAgIGNvbnN0IHNlY3MgPSBwb3MgLyAxMDAwMDAwbjtcbiAgICBjb25zdCBtaWNyb3NfcmVtYWluaW5nID0gcG9zICUgMTAwMDAwMG47XG4gICAgcmV0dXJuIGAke3NpZ259JHtzZWNzfS4ke1N0cmluZyhtaWNyb3NfcmVtYWluaW5nKS5wYWRTdGFydCg2LCBcIjBcIil9YDtcbiAgfVxufTtcblxuLy8gc3JjL2xpYi90aW1lc3RhbXAudHNcbnZhciBUaW1lc3RhbXAgPSBjbGFzcyBfVGltZXN0YW1wIHtcbiAgX190aW1lc3RhbXBfbWljcm9zX3NpbmNlX3VuaXhfZXBvY2hfXztcbiAgc3RhdGljIE1JQ1JPU19QRVJfTUlMTElTID0gMTAwMG47XG4gIGdldCBtaWNyb3NTaW5jZVVuaXhFcG9jaCgpIHtcbiAgICByZXR1cm4gdGhpcy5fX3RpbWVzdGFtcF9taWNyb3Nfc2luY2VfdW5peF9lcG9jaF9fO1xuICB9XG4gIGNvbnN0cnVjdG9yKG1pY3Jvcykge1xuICAgIHRoaXMuX190aW1lc3RhbXBfbWljcm9zX3NpbmNlX3VuaXhfZXBvY2hfXyA9IG1pY3JvcztcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBhbGdlYnJhaWMgdHlwZSByZXByZXNlbnRhdGlvbiBvZiB0aGUge0BsaW5rIFRpbWVzdGFtcH0gdHlwZS5cbiAgICogQHJldHVybnMgVGhlIGFsZ2VicmFpYyB0eXBlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0eXBlLlxuICAgKi9cbiAgc3RhdGljIGdldEFsZ2VicmFpY1R5cGUoKSB7XG4gICAgcmV0dXJuIEFsZ2VicmFpY1R5cGUuUHJvZHVjdCh7XG4gICAgICBlbGVtZW50czogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJfX3RpbWVzdGFtcF9taWNyb3Nfc2luY2VfdW5peF9lcG9jaF9fXCIsXG4gICAgICAgICAgYWxnZWJyYWljVHlwZTogQWxnZWJyYWljVHlwZS5JNjRcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBpc1RpbWVzdGFtcChhbGdlYnJhaWNUeXBlKSB7XG4gICAgaWYgKGFsZ2VicmFpY1R5cGUudGFnICE9PSBcIlByb2R1Y3RcIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBlbGVtZW50cyA9IGFsZ2VicmFpY1R5cGUudmFsdWUuZWxlbWVudHM7XG4gICAgaWYgKGVsZW1lbnRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBtaWNyb3NFbGVtZW50ID0gZWxlbWVudHNbMF07XG4gICAgcmV0dXJuIG1pY3Jvc0VsZW1lbnQubmFtZSA9PT0gXCJfX3RpbWVzdGFtcF9taWNyb3Nfc2luY2VfdW5peF9lcG9jaF9fXCIgJiYgbWljcm9zRWxlbWVudC5hbGdlYnJhaWNUeXBlLnRhZyA9PT0gXCJJNjRcIjtcbiAgfVxuICAvKipcbiAgICogVGhlIFVuaXggZXBvY2gsIHRoZSBtaWRuaWdodCBhdCB0aGUgYmVnaW5uaW5nIG9mIEphbnVhcnkgMSwgMTk3MCwgVVRDLlxuICAgKi9cbiAgc3RhdGljIFVOSVhfRVBPQ0ggPSBuZXcgX1RpbWVzdGFtcCgwbik7XG4gIC8qKlxuICAgKiBHZXQgYSBgVGltZXN0YW1wYCByZXByZXNlbnRpbmcgdGhlIGV4ZWN1dGlvbiBlbnZpcm9ubWVudCdzIGJlbGllZiBvZiB0aGUgY3VycmVudCBtb21lbnQgaW4gdGltZS5cbiAgICovXG4gIHN0YXRpYyBub3coKSB7XG4gICAgcmV0dXJuIF9UaW1lc3RhbXAuZnJvbURhdGUoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpO1xuICB9XG4gIC8qKiBDb252ZXJ0IHRvIG1pbGxpc2Vjb25kcyBzaW5jZSBVbml4IGVwb2NoLiAqL1xuICB0b01pbGxpcygpIHtcbiAgICByZXR1cm4gdGhpcy5taWNyb3NTaW5jZVVuaXhFcG9jaCAvIDEwMDBuO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSBgVGltZXN0YW1wYCByZXByZXNlbnRpbmcgdGhlIHNhbWUgcG9pbnQgaW4gdGltZSBhcyBgZGF0ZWAuXG4gICAqL1xuICBzdGF0aWMgZnJvbURhdGUoZGF0ZSkge1xuICAgIGNvbnN0IG1pbGxpcyA9IGRhdGUuZ2V0VGltZSgpO1xuICAgIGNvbnN0IG1pY3JvcyA9IEJpZ0ludChtaWxsaXMpICogX1RpbWVzdGFtcC5NSUNST1NfUEVSX01JTExJUztcbiAgICByZXR1cm4gbmV3IF9UaW1lc3RhbXAobWljcm9zKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGEgYERhdGVgIHJlcHJlc2VudGluZyBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIHBvaW50IGluIHRpbWUgYXMgYHRoaXNgLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCB0cnVuY2F0ZXMgdG8gbWlsbGlzZWNvbmQgcHJlY2lzaW9uLFxuICAgKiBhbmQgdGhyb3dzIGBSYW5nZUVycm9yYCBpZiB0aGUgYFRpbWVzdGFtcGAgaXMgb3V0c2lkZSB0aGUgcmFuZ2UgcmVwcmVzZW50YWJsZSBhcyBhIGBEYXRlYC5cbiAgICovXG4gIHRvRGF0ZSgpIHtcbiAgICBjb25zdCBtaWNyb3MgPSB0aGlzLl9fdGltZXN0YW1wX21pY3Jvc19zaW5jZV91bml4X2Vwb2NoX187XG4gICAgY29uc3QgbWlsbGlzID0gbWljcm9zIC8gX1RpbWVzdGFtcC5NSUNST1NfUEVSX01JTExJUztcbiAgICBpZiAobWlsbGlzID4gQmlnSW50KE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSB8fCBtaWxsaXMgPCBCaWdJbnQoTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIpKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcbiAgICAgICAgXCJUaW1lc3RhbXAgaXMgb3V0c2lkZSBvZiB0aGUgcmVwcmVzZW50YWJsZSByYW5nZSBvZiBKUydzIERhdGVcIlxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEYXRlKE51bWJlcihtaWxsaXMpKTtcbiAgfVxuICBzaW5jZShvdGhlcikge1xuICAgIHJldHVybiBuZXcgVGltZUR1cmF0aW9uKFxuICAgICAgdGhpcy5fX3RpbWVzdGFtcF9taWNyb3Nfc2luY2VfdW5peF9lcG9jaF9fIC0gb3RoZXIuX190aW1lc3RhbXBfbWljcm9zX3NpbmNlX3VuaXhfZXBvY2hfX1xuICAgICk7XG4gIH1cbn07XG5cbi8vIHNyYy9saWIvdXVpZC50c1xudmFyIFV1aWQgPSBjbGFzcyBfVXVpZCB7XG4gIF9fdXVpZF9fO1xuICAvKipcbiAgICogVGhlIG5pbCBVVUlEIChhbGwgemVyb3MpLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiBjb25zdCB1dWlkID0gVXVpZC5OSUw7XG4gICAqIGNvbnNvbGUuYXNzZXJ0KFxuICAgKiAgIHV1aWQudG9TdHJpbmcoKSA9PT0gXCIwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDBcIlxuICAgKiApO1xuICAgKiBgYGBcbiAgICovXG4gIHN0YXRpYyBOSUwgPSBuZXcgX1V1aWQoMG4pO1xuICBzdGF0aWMgTUFYX1VVSURfQklHSU5UID0gMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZm47XG4gIC8qKlxuICAgKiBUaGUgbWF4IFVVSUQgKGFsbCBvbmVzKS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogY29uc3QgdXVpZCA9IFV1aWQuTUFYO1xuICAgKiBjb25zb2xlLmFzc2VydChcbiAgICogICB1dWlkLnRvU3RyaW5nKCkgPT09IFwiZmZmZmZmZmYtZmZmZi1mZmZmLWZmZmYtZmZmZmZmZmZmZmZmXCJcbiAgICogKTtcbiAgICogYGBgXG4gICAqL1xuICBzdGF0aWMgTUFYID0gbmV3IF9VdWlkKF9VdWlkLk1BWF9VVUlEX0JJR0lOVCk7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBVVUlEIGZyb20gYSByYXcgMTI4LWJpdCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHUgLSBVbnNpZ25lZCAxMjgtYml0IGludGVnZXJcbiAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSB2YWx1ZSBpcyBvdXRzaWRlIHRoZSB2YWxpZCBVVUlEIHJhbmdlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih1KSB7XG4gICAgaWYgKHUgPCAwbiB8fCB1ID4gX1V1aWQuTUFYX1VVSURfQklHSU5UKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFVVSUQ6IG11c3QgYmUgYmV0d2VlbiAwIGFuZCBgTUFYX1VVSURfQklHSU5UYFwiKTtcbiAgICB9XG4gICAgdGhpcy5fX3V1aWRfXyA9IHU7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIFVVSUQgYHY0YCBmcm9tIGV4cGxpY2l0IHJhbmRvbSBieXRlcy5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgYXNzdW1lcyB0aGUgYnl0ZXMgYXJlIGFscmVhZHkgc3VmZmljaWVudGx5IHJhbmRvbS5cbiAgICogSXQgb25seSBzZXRzIHRoZSBhcHByb3ByaWF0ZSBiaXRzIGZvciB0aGUgVVVJRCB2ZXJzaW9uIGFuZCB2YXJpYW50LlxuICAgKlxuICAgKiBAcGFyYW0gYnl0ZXMgLSBFeGFjdGx5IDE2IHJhbmRvbSBieXRlc1xuICAgKiBAcmV0dXJucyBBIFVVSUQgYHY0YFxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgYGJ5dGVzLmxlbmd0aCAhPT0gMTZgXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIGNvbnN0IHJhbmRvbUJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICAgKiBjb25zdCB1dWlkID0gVXVpZC5mcm9tUmFuZG9tQnl0ZXNWNChyYW5kb21CeXRlcyk7XG4gICAqXG4gICAqIGNvbnNvbGUuYXNzZXJ0KFxuICAgKiAgIHV1aWQudG9TdHJpbmcoKSA9PT0gXCIwMDAwMDAwMC0wMDAwLTQwMDAtODAwMC0wMDAwMDAwMDAwMDBcIlxuICAgKiApO1xuICAgKiBgYGBcbiAgICovXG4gIHN0YXRpYyBmcm9tUmFuZG9tQnl0ZXNWNChieXRlcykge1xuICAgIGlmIChieXRlcy5sZW5ndGggIT09IDE2KSB0aHJvdyBuZXcgRXJyb3IoXCJVVUlEIHY0IHJlcXVpcmVzIDE2IGJ5dGVzXCIpO1xuICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KGJ5dGVzKTtcbiAgICBhcnJbNl0gPSBhcnJbNl0gJiAxNSB8IDY0O1xuICAgIGFycls4XSA9IGFycls4XSAmIDYzIHwgMTI4O1xuICAgIHJldHVybiBuZXcgX1V1aWQoX1V1aWQuYnl0ZXNUb0JpZ0ludChhcnIpKTtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGUgYSBVVUlEIGB2N2AgdXNpbmcgYSBtb25vdG9uaWMgY291bnRlciBmcm9tIGAwYCB0byBgMl4zMSAtIDFgLFxuICAgKiBhIHRpbWVzdGFtcCwgYW5kIDQgcmFuZG9tIGJ5dGVzLlxuICAgKlxuICAgKiBUaGUgY291bnRlciB3cmFwcyBhcm91bmQgb24gb3ZlcmZsb3cuXG4gICAqXG4gICAqIFRoZSBVVUlEIGB2N2AgaXMgc3RydWN0dXJlZCBhcyBmb2xsb3dzOlxuICAgKlxuICAgKiBgYGBhc2NpaVxuICAgKiDilIzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJBcbiAgICogfCBCMCAgfCBCMSAgfCBCMiAgfCBCMyAgfCBCNCAgfCBCNSAgICAgICAgICAgICAgfCAgICAgICAgIEI2ICAgICAgICB8XG4gICAqIOKUnOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUpFxuICAgKiB8ICAgICAgICAgICAgICAgICB1bml4X3RzX21zICAgICAgICAgICAgICAgICAgICB8ICAgICAgdmVyc2lvbiA3ICAgIHxcbiAgICog4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS04pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYXG4gICAqIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUrOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUrOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUrOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxuICAgKiB8IEI3ICAgICAgICAgICB8IEI4ICAgICAgfCBCOSAgfCBCMTAgfCBCMTEgIHwgQjEyIHwgQjEzIHwgQjE0IHwgQjE1IHxcbiAgICog4pSc4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkXG4gICAqIHwgY291bnRlcl9oaWdoIHwgdmFyaWFudCB8ICAgIGNvdW50ZXJfbG93ICAgfCAgICAgICAgcmFuZG9tICAgICAgICAgfFxuICAgKiDilJTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLTilIDilIDilIDilIDilIDilIDilIDilIDilIDilLTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJhcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSBjb3VudGVyIC0gTXV0YWJsZSBtb25vdG9uaWMgY291bnRlciAoMzEtYml0KVxuICAgKiBAcGFyYW0gbm93IC0gVGltZXN0YW1wIHNpbmNlIHRoZSBVbml4IGVwb2NoXG4gICAqIEBwYXJhbSByYW5kb21CeXRlcyAtIEV4YWN0bHkgNCByYW5kb20gYnl0ZXNcbiAgICogQHJldHVybnMgQSBVVUlEIGB2N2BcbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBgY291bnRlcmAgaXMgbmVnYXRpdmVcbiAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBgdGltZXN0YW1wYCBpcyBiZWZvcmUgdGhlIFVuaXggZXBvY2hcbiAgICogQHRocm93cyB7RXJyb3J9IElmIGByYW5kb21CeXRlcy5sZW5ndGggIT09IDRgXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIGNvbnN0IG5vdyA9IFRpbWVzdGFtcC5mcm9tTWlsbGlzKDFfNjg2XzAwMF8wMDBfMDAwbik7XG4gICAqIGNvbnN0IGNvdW50ZXIgPSB7IHZhbHVlOiAxIH07XG4gICAqIGNvbnN0IHJhbmRvbUJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAqXG4gICAqIGNvbnN0IHV1aWQgPSBVdWlkLmZyb21Db3VudGVyVjcoY291bnRlciwgbm93LCByYW5kb21CeXRlcyk7XG4gICAqXG4gICAqIGNvbnNvbGUuYXNzZXJ0KFxuICAgKiAgIHV1aWQudG9TdHJpbmcoKSA9PT0gXCIwMDAwNjQ3ZS01MTgwLTcwMDAtODAwMC0wMDAyMDAwMDAwMDBcIlxuICAgKiApO1xuICAgKiBgYGBcbiAgICovXG4gIHN0YXRpYyBmcm9tQ291bnRlclY3KGNvdW50ZXIsIG5vdywgcmFuZG9tQnl0ZXMpIHtcbiAgICBpZiAocmFuZG9tQnl0ZXMubGVuZ3RoICE9PSA0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgZnJvbUNvdW50ZXJWN2AgcmVxdWlyZXMgYHJhbmRvbUJ5dGVzLmxlbmd0aCA9PSA0YFwiKTtcbiAgICB9XG4gICAgaWYgKGNvdW50ZXIudmFsdWUgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgZnJvbUNvdW50ZXJWN2AgdXVpZCBgY291bnRlcmAgbXVzdCBiZSBub24tbmVnYXRpdmVcIik7XG4gICAgfVxuICAgIGlmIChub3cuX190aW1lc3RhbXBfbWljcm9zX3NpbmNlX3VuaXhfZXBvY2hfXyA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImBmcm9tQ291bnRlclY3YCBgdGltZXN0YW1wYCBiZWZvcmUgdW5peCBlcG9jaFwiKTtcbiAgICB9XG4gICAgY29uc3QgY291bnRlclZhbCA9IGNvdW50ZXIudmFsdWU7XG4gICAgY291bnRlci52YWx1ZSA9IGNvdW50ZXJWYWwgKyAxICYgMjE0NzQ4MzY0NztcbiAgICBjb25zdCB0c01zID0gbm93LnRvTWlsbGlzKCkgJiAweGZmZmZmZmZmZmZmZm47XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheSgxNik7XG4gICAgYnl0ZXNbMF0gPSBOdW1iZXIodHNNcyA+PiA0MG4gJiAweGZmbik7XG4gICAgYnl0ZXNbMV0gPSBOdW1iZXIodHNNcyA+PiAzMm4gJiAweGZmbik7XG4gICAgYnl0ZXNbMl0gPSBOdW1iZXIodHNNcyA+PiAyNG4gJiAweGZmbik7XG4gICAgYnl0ZXNbM10gPSBOdW1iZXIodHNNcyA+PiAxNm4gJiAweGZmbik7XG4gICAgYnl0ZXNbNF0gPSBOdW1iZXIodHNNcyA+PiA4biAmIDB4ZmZuKTtcbiAgICBieXRlc1s1XSA9IE51bWJlcih0c01zICYgMHhmZm4pO1xuICAgIGJ5dGVzWzddID0gY291bnRlclZhbCA+Pj4gMjMgJiAyNTU7XG4gICAgYnl0ZXNbOV0gPSBjb3VudGVyVmFsID4+PiAxNSAmIDI1NTtcbiAgICBieXRlc1sxMF0gPSBjb3VudGVyVmFsID4+PiA3ICYgMjU1O1xuICAgIGJ5dGVzWzExXSA9IChjb3VudGVyVmFsICYgMTI3KSA8PCAxICYgMjU1O1xuICAgIGJ5dGVzWzEyXSB8PSByYW5kb21CeXRlc1swXSAmIDEyNztcbiAgICBieXRlc1sxM10gPSByYW5kb21CeXRlc1sxXTtcbiAgICBieXRlc1sxNF0gPSByYW5kb21CeXRlc1syXTtcbiAgICBieXRlc1sxNV0gPSByYW5kb21CeXRlc1szXTtcbiAgICBieXRlc1s2XSA9IGJ5dGVzWzZdICYgMTUgfCAxMTI7XG4gICAgYnl0ZXNbOF0gPSBieXRlc1s4XSAmIDYzIHwgMTI4O1xuICAgIHJldHVybiBuZXcgX1V1aWQoX1V1aWQuYnl0ZXNUb0JpZ0ludChieXRlcykpO1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZSBhIFVVSUQgZnJvbSBhIHN0cmluZyByZXByZXNlbnRhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHMgLSBVVUlEIHN0cmluZ1xuICAgKiBAcmV0dXJucyBQYXJzZWQgVVVJRFxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHN0cmluZyBpcyBub3QgYSB2YWxpZCBVVUlEXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIGNvbnN0IHMgPSBcIjAxODg4ZDZlLTVjMDAtNzAwMC04MDAwLTAwMDAwMDAwMDAwMFwiO1xuICAgKiBjb25zdCB1dWlkID0gVXVpZC5wYXJzZShzKTtcbiAgICpcbiAgICogY29uc29sZS5hc3NlcnQodXVpZC50b1N0cmluZygpID09PSBzKTtcbiAgICogYGBgXG4gICAqL1xuICBzdGF0aWMgcGFyc2Uocykge1xuICAgIGNvbnN0IGhleCA9IHMucmVwbGFjZSgvLS9nLCBcIlwiKTtcbiAgICBpZiAoaGV4Lmxlbmd0aCAhPT0gMzIpIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaGV4IFVVSURcIik7XG4gICAgbGV0IHYgPSAwbjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDMyOyBpICs9IDIpIHtcbiAgICAgIHYgPSB2IDw8IDhuIHwgQmlnSW50KHBhcnNlSW50KGhleC5zbGljZShpLCBpICsgMiksIDE2KSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgX1V1aWQodik7XG4gIH1cbiAgLyoqIENvbnZlcnQgdG8gc3RyaW5nIChoeXBoZW5hdGVkIGZvcm0pLiAqL1xuICB0b1N0cmluZygpIHtcbiAgICBjb25zdCBieXRlcyA9IF9VdWlkLmJpZ0ludFRvQnl0ZXModGhpcy5fX3V1aWRfXyk7XG4gICAgY29uc3QgaGV4ID0gWy4uLmJ5dGVzXS5tYXAoKGIpID0+IGIudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKSkuam9pbihcIlwiKTtcbiAgICByZXR1cm4gaGV4LnNsaWNlKDAsIDgpICsgXCItXCIgKyBoZXguc2xpY2UoOCwgMTIpICsgXCItXCIgKyBoZXguc2xpY2UoMTIsIDE2KSArIFwiLVwiICsgaGV4LnNsaWNlKDE2LCAyMCkgKyBcIi1cIiArIGhleC5zbGljZSgyMCk7XG4gIH1cbiAgLyoqIENvbnZlcnQgdG8gYmlnaW50ICh1MTI4KS4gKi9cbiAgYXNCaWdJbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX191dWlkX187XG4gIH1cbiAgLyoqIFJldHVybiBhIGBVaW50OEFycmF5YCBvZiAxNiBieXRlcy4gKi9cbiAgdG9CeXRlcygpIHtcbiAgICByZXR1cm4gX1V1aWQuYmlnSW50VG9CeXRlcyh0aGlzLl9fdXVpZF9fKTtcbiAgfVxuICBzdGF0aWMgYnl0ZXNUb0JpZ0ludChieXRlcykge1xuICAgIGxldCByZXN1bHQgPSAwbjtcbiAgICBmb3IgKGNvbnN0IGIgb2YgYnl0ZXMpIHJlc3VsdCA9IHJlc3VsdCA8PCA4biB8IEJpZ0ludChiKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHN0YXRpYyBiaWdJbnRUb0J5dGVzKHZhbHVlKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheSgxNik7XG4gICAgZm9yIChsZXQgaSA9IDE1OyBpID49IDA7IGktLSkge1xuICAgICAgYnl0ZXNbaV0gPSBOdW1iZXIodmFsdWUgJiAweGZmbik7XG4gICAgICB2YWx1ZSA+Pj0gOG47XG4gICAgfVxuICAgIHJldHVybiBieXRlcztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdmVyc2lvbiBvZiB0aGlzIFVVSUQuXG4gICAqXG4gICAqIFRoaXMgcmVwcmVzZW50cyB0aGUgYWxnb3JpdGhtIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIHZhbHVlLlxuICAgKlxuICAgKiBAcmV0dXJucyBBIGBVdWlkVmVyc2lvbmBcbiAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSB2ZXJzaW9uIGZpZWxkIGlzIG5vdCByZWNvZ25pemVkXG4gICAqL1xuICBnZXRWZXJzaW9uKCkge1xuICAgIGNvbnN0IHZlcnNpb24gPSB0aGlzLnRvQnl0ZXMoKVs2XSA+PiA0ICYgMTU7XG4gICAgc3dpdGNoICh2ZXJzaW9uKSB7XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIHJldHVybiBcIlY0XCI7XG4gICAgICBjYXNlIDc6XG4gICAgICAgIHJldHVybiBcIlY3XCI7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAodGhpcyA9PSBfVXVpZC5OSUwpIHtcbiAgICAgICAgICByZXR1cm4gXCJOaWxcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcyA9PSBfVXVpZC5NQVgpIHtcbiAgICAgICAgICByZXR1cm4gXCJNYXhcIjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIFVVSUQgdmVyc2lvbjogJHt2ZXJzaW9ufWApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRXh0cmFjdCB0aGUgbW9ub3RvbmljIGNvdW50ZXIgZnJvbSBhIFVVSUR2Ny5cbiAgICpcbiAgICogSW50ZW5kZWQgZm9yIHRlc3RpbmcgYW5kIGRpYWdub3N0aWNzLlxuICAgKiBCZWhhdmlvciBpcyB1bmRlZmluZWQgaWYgY2FsbGVkIG9uIGEgbm9uLVY3IFVVSUQuXG4gICAqXG4gICAqIEByZXR1cm5zIDMxLWJpdCBjb3VudGVyIHZhbHVlXG4gICAqL1xuICBnZXRDb3VudGVyKCkge1xuICAgIGNvbnN0IGJ5dGVzID0gdGhpcy50b0J5dGVzKCk7XG4gICAgY29uc3QgaGlnaCA9IGJ5dGVzWzddO1xuICAgIGNvbnN0IG1pZDEgPSBieXRlc1s5XTtcbiAgICBjb25zdCBtaWQyID0gYnl0ZXNbMTBdO1xuICAgIGNvbnN0IGxvdyA9IGJ5dGVzWzExXSA+Pj4gMTtcbiAgICByZXR1cm4gaGlnaCA8PCAyMyB8IG1pZDEgPDwgMTUgfCBtaWQyIDw8IDcgfCBsb3cgfCAwO1xuICB9XG4gIGNvbXBhcmVUbyhvdGhlcikge1xuICAgIGlmICh0aGlzLl9fdXVpZF9fIDwgb3RoZXIuX191dWlkX18pIHJldHVybiAtMTtcbiAgICBpZiAodGhpcy5fX3V1aWRfXyA+IG90aGVyLl9fdXVpZF9fKSByZXR1cm4gMTtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBzdGF0aWMgZ2V0QWxnZWJyYWljVHlwZSgpIHtcbiAgICByZXR1cm4gQWxnZWJyYWljVHlwZS5Qcm9kdWN0KHtcbiAgICAgIGVsZW1lbnRzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcIl9fdXVpZF9fXCIsXG4gICAgICAgICAgYWxnZWJyYWljVHlwZTogQWxnZWJyYWljVHlwZS5VMTI4XG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9KTtcbiAgfVxufTtcblxuLy8gc3JjL2xpYi9iaW5hcnlfcmVhZGVyLnRzXG52YXIgQmluYXJ5UmVhZGVyID0gY2xhc3Mge1xuICAvKipcbiAgICogVGhlIERhdGFWaWV3IHVzZWQgdG8gcmVhZCB2YWx1ZXMgZnJvbSB0aGUgYmluYXJ5IGRhdGEuXG4gICAqXG4gICAqIE5vdGU6IFRoZSBEYXRhVmlldydzIGBieXRlT2Zmc2V0YCBpcyByZWxhdGl2ZSB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZVxuICAgKiB1bmRlcmx5aW5nIEFycmF5QnVmZmVyLCBub3QgdGhlIHN0YXJ0IG9mIHRoZSBwcm92aWRlZCBVaW50OEFycmF5IGlucHV0LlxuICAgKiBUaGlzIGBCaW5hcnlSZWFkZXJgJ3MgYCNvZmZzZXRgIGZpZWxkIGlzIHVzZWQgdG8gdHJhY2sgdGhlIGN1cnJlbnQgcmVhZCBwb3NpdGlvblxuICAgKiByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIHByb3ZpZGVkIFVpbnQ4QXJyYXkgaW5wdXQuXG4gICAqL1xuICAjdmlldztcbiAgLyoqXG4gICAqIFJlcHJlc2VudHMgdGhlIG9mZnNldCAoaW4gYnl0ZXMpIHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGUgRGF0YVZpZXdcbiAgICogYW5kIHByb3ZpZGVkIFVpbnQ4QXJyYXkgaW5wdXQuXG4gICAqXG4gICAqIE5vdGU6IFRoaXMgaXMgKm5vdCogdGhlIGFic29sdXRlIGJ5dGUgb2Zmc2V0IHdpdGhpbiB0aGUgdW5kZXJseWluZyBBcnJheUJ1ZmZlci5cbiAgICovXG4gICNvZmZzZXQgPSAwO1xuICBjb25zdHJ1Y3RvcihpbnB1dCkge1xuICAgIHRoaXMuI3ZpZXcgPSBuZXcgRGF0YVZpZXcoaW5wdXQuYnVmZmVyLCBpbnB1dC5ieXRlT2Zmc2V0LCBpbnB1dC5ieXRlTGVuZ3RoKTtcbiAgICB0aGlzLiNvZmZzZXQgPSAwO1xuICB9XG4gIGdldCBvZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI29mZnNldDtcbiAgfVxuICBnZXQgcmVtYWluaW5nKCkge1xuICAgIHJldHVybiB0aGlzLiN2aWV3LmJ5dGVMZW5ndGggLSB0aGlzLiNvZmZzZXQ7XG4gIH1cbiAgLyoqIEVuc3VyZSB3ZSBoYXZlIGF0IGxlYXN0IGBuYCBieXRlcyBsZWZ0IHRvIHJlYWQgKi9cbiAgI2Vuc3VyZShuKSB7XG4gICAgaWYgKHRoaXMuI29mZnNldCArIG4gPiB0aGlzLiN2aWV3LmJ5dGVMZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFxuICAgICAgICBgVHJpZWQgdG8gcmVhZCAke259IGJ5dGUocykgYXQgcmVsYXRpdmUgb2Zmc2V0ICR7dGhpcy4jb2Zmc2V0fSwgYnV0IG9ubHkgJHt0aGlzLnJlbWFpbmluZ30gYnl0ZShzKSByZW1haW5gXG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZWFkVUludDhBcnJheSgpIHtcbiAgICBjb25zdCBsZW5ndGggPSB0aGlzLnJlYWRVMzIoKTtcbiAgICB0aGlzLiNlbnN1cmUobGVuZ3RoKTtcbiAgICByZXR1cm4gdGhpcy5yZWFkQnl0ZXMobGVuZ3RoKTtcbiAgfVxuICByZWFkQm9vbCgpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI3ZpZXcuZ2V0VWludDgodGhpcy4jb2Zmc2V0KTtcbiAgICB0aGlzLiNvZmZzZXQgKz0gMTtcbiAgICByZXR1cm4gdmFsdWUgIT09IDA7XG4gIH1cbiAgcmVhZEJ5dGUoKSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLiN2aWV3LmdldFVpbnQ4KHRoaXMuI29mZnNldCk7XG4gICAgdGhpcy4jb2Zmc2V0ICs9IDE7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJlYWRCeXRlcyhsZW5ndGgpIHtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KFxuICAgICAgdGhpcy4jdmlldy5idWZmZXIsXG4gICAgICB0aGlzLiN2aWV3LmJ5dGVPZmZzZXQgKyB0aGlzLiNvZmZzZXQsXG4gICAgICBsZW5ndGhcbiAgICApO1xuICAgIHRoaXMuI29mZnNldCArPSBsZW5ndGg7XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG4gIHJlYWRJOCgpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI3ZpZXcuZ2V0SW50OCh0aGlzLiNvZmZzZXQpO1xuICAgIHRoaXMuI29mZnNldCArPSAxO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZWFkVTgoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhZEJ5dGUoKTtcbiAgfVxuICByZWFkSTE2KCkge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jdmlldy5nZXRJbnQxNih0aGlzLiNvZmZzZXQsIHRydWUpO1xuICAgIHRoaXMuI29mZnNldCArPSAyO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZWFkVTE2KCkge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jdmlldy5nZXRVaW50MTYodGhpcy4jb2Zmc2V0LCB0cnVlKTtcbiAgICB0aGlzLiNvZmZzZXQgKz0gMjtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmVhZEkzMigpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI3ZpZXcuZ2V0SW50MzIodGhpcy4jb2Zmc2V0LCB0cnVlKTtcbiAgICB0aGlzLiNvZmZzZXQgKz0gNDtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmVhZFUzMigpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI3ZpZXcuZ2V0VWludDMyKHRoaXMuI29mZnNldCwgdHJ1ZSk7XG4gICAgdGhpcy4jb2Zmc2V0ICs9IDQ7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJlYWRJNjQoKSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLiN2aWV3LmdldEJpZ0ludDY0KHRoaXMuI29mZnNldCwgdHJ1ZSk7XG4gICAgdGhpcy4jb2Zmc2V0ICs9IDg7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJlYWRVNjQoKSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLiN2aWV3LmdldEJpZ1VpbnQ2NCh0aGlzLiNvZmZzZXQsIHRydWUpO1xuICAgIHRoaXMuI29mZnNldCArPSA4O1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZWFkVTEyOCgpIHtcbiAgICBjb25zdCBsb3dlclBhcnQgPSB0aGlzLiN2aWV3LmdldEJpZ1VpbnQ2NCh0aGlzLiNvZmZzZXQsIHRydWUpO1xuICAgIGNvbnN0IHVwcGVyUGFydCA9IHRoaXMuI3ZpZXcuZ2V0QmlnVWludDY0KHRoaXMuI29mZnNldCArIDgsIHRydWUpO1xuICAgIHRoaXMuI29mZnNldCArPSAxNjtcbiAgICByZXR1cm4gKHVwcGVyUGFydCA8PCBCaWdJbnQoNjQpKSArIGxvd2VyUGFydDtcbiAgfVxuICByZWFkSTEyOCgpIHtcbiAgICBjb25zdCBsb3dlclBhcnQgPSB0aGlzLiN2aWV3LmdldEJpZ1VpbnQ2NCh0aGlzLiNvZmZzZXQsIHRydWUpO1xuICAgIGNvbnN0IHVwcGVyUGFydCA9IHRoaXMuI3ZpZXcuZ2V0QmlnSW50NjQodGhpcy4jb2Zmc2V0ICsgOCwgdHJ1ZSk7XG4gICAgdGhpcy4jb2Zmc2V0ICs9IDE2O1xuICAgIHJldHVybiAodXBwZXJQYXJ0IDw8IEJpZ0ludCg2NCkpICsgbG93ZXJQYXJ0O1xuICB9XG4gIHJlYWRVMjU2KCkge1xuICAgIGNvbnN0IHAwID0gdGhpcy4jdmlldy5nZXRCaWdVaW50NjQodGhpcy4jb2Zmc2V0LCB0cnVlKTtcbiAgICBjb25zdCBwMSA9IHRoaXMuI3ZpZXcuZ2V0QmlnVWludDY0KHRoaXMuI29mZnNldCArIDgsIHRydWUpO1xuICAgIGNvbnN0IHAyID0gdGhpcy4jdmlldy5nZXRCaWdVaW50NjQodGhpcy4jb2Zmc2V0ICsgMTYsIHRydWUpO1xuICAgIGNvbnN0IHAzID0gdGhpcy4jdmlldy5nZXRCaWdVaW50NjQodGhpcy4jb2Zmc2V0ICsgMjQsIHRydWUpO1xuICAgIHRoaXMuI29mZnNldCArPSAzMjtcbiAgICByZXR1cm4gKHAzIDw8IEJpZ0ludCgzICogNjQpKSArIChwMiA8PCBCaWdJbnQoMiAqIDY0KSkgKyAocDEgPDwgQmlnSW50KDEgKiA2NCkpICsgcDA7XG4gIH1cbiAgcmVhZEkyNTYoKSB7XG4gICAgY29uc3QgcDAgPSB0aGlzLiN2aWV3LmdldEJpZ1VpbnQ2NCh0aGlzLiNvZmZzZXQsIHRydWUpO1xuICAgIGNvbnN0IHAxID0gdGhpcy4jdmlldy5nZXRCaWdVaW50NjQodGhpcy4jb2Zmc2V0ICsgOCwgdHJ1ZSk7XG4gICAgY29uc3QgcDIgPSB0aGlzLiN2aWV3LmdldEJpZ1VpbnQ2NCh0aGlzLiNvZmZzZXQgKyAxNiwgdHJ1ZSk7XG4gICAgY29uc3QgcDMgPSB0aGlzLiN2aWV3LmdldEJpZ0ludDY0KHRoaXMuI29mZnNldCArIDI0LCB0cnVlKTtcbiAgICB0aGlzLiNvZmZzZXQgKz0gMzI7XG4gICAgcmV0dXJuIChwMyA8PCBCaWdJbnQoMyAqIDY0KSkgKyAocDIgPDwgQmlnSW50KDIgKiA2NCkpICsgKHAxIDw8IEJpZ0ludCgxICogNjQpKSArIHAwO1xuICB9XG4gIHJlYWRGMzIoKSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLiN2aWV3LmdldEZsb2F0MzIodGhpcy4jb2Zmc2V0LCB0cnVlKTtcbiAgICB0aGlzLiNvZmZzZXQgKz0gNDtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmVhZEY2NCgpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI3ZpZXcuZ2V0RmxvYXQ2NCh0aGlzLiNvZmZzZXQsIHRydWUpO1xuICAgIHRoaXMuI29mZnNldCArPSA4O1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZWFkU3RyaW5nKCkge1xuICAgIGNvbnN0IHVpbnQ4QXJyYXkgPSB0aGlzLnJlYWRVSW50OEFycmF5KCk7XG4gICAgcmV0dXJuIG5ldyBUZXh0RGVjb2RlcihcInV0Zi04XCIpLmRlY29kZSh1aW50OEFycmF5KTtcbiAgfVxufTtcblxuLy8gc3JjL2xpYi9iaW5hcnlfd3JpdGVyLnRzXG52YXIgaW1wb3J0X2Jhc2U2NF9qcyA9IF9fdG9FU00ocmVxdWlyZV9iYXNlNjRfanMoKSk7XG52YXIgQmluYXJ5V3JpdGVyID0gY2xhc3Mge1xuICAjYnVmZmVyO1xuICAjdmlldztcbiAgI29mZnNldCA9IDA7XG4gIGNvbnN0cnVjdG9yKHNpemUpIHtcbiAgICB0aGlzLiNidWZmZXIgPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgICB0aGlzLiN2aWV3ID0gbmV3IERhdGFWaWV3KHRoaXMuI2J1ZmZlci5idWZmZXIpO1xuICB9XG4gICNleHBhbmRCdWZmZXIoYWRkaXRpb25hbENhcGFjaXR5KSB7XG4gICAgY29uc3QgbWluQ2FwYWNpdHkgPSB0aGlzLiNvZmZzZXQgKyBhZGRpdGlvbmFsQ2FwYWNpdHkgKyAxO1xuICAgIGlmIChtaW5DYXBhY2l0eSA8PSB0aGlzLiNidWZmZXIubGVuZ3RoKSByZXR1cm47XG4gICAgbGV0IG5ld0NhcGFjaXR5ID0gdGhpcy4jYnVmZmVyLmxlbmd0aCAqIDI7XG4gICAgaWYgKG5ld0NhcGFjaXR5IDwgbWluQ2FwYWNpdHkpIG5ld0NhcGFjaXR5ID0gbWluQ2FwYWNpdHk7XG4gICAgY29uc3QgbmV3QnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkobmV3Q2FwYWNpdHkpO1xuICAgIG5ld0J1ZmZlci5zZXQodGhpcy4jYnVmZmVyKTtcbiAgICB0aGlzLiNidWZmZXIgPSBuZXdCdWZmZXI7XG4gICAgdGhpcy4jdmlldyA9IG5ldyBEYXRhVmlldyh0aGlzLiNidWZmZXIuYnVmZmVyKTtcbiAgfVxuICB0b0Jhc2U2NCgpIHtcbiAgICByZXR1cm4gKDAsIGltcG9ydF9iYXNlNjRfanMuZnJvbUJ5dGVBcnJheSkodGhpcy4jYnVmZmVyLnN1YmFycmF5KDAsIHRoaXMuI29mZnNldCkpO1xuICB9XG4gIGdldEJ1ZmZlcigpIHtcbiAgICByZXR1cm4gdGhpcy4jYnVmZmVyLnNsaWNlKDAsIHRoaXMuI29mZnNldCk7XG4gIH1cbiAgZ2V0IG9mZnNldCgpIHtcbiAgICByZXR1cm4gdGhpcy4jb2Zmc2V0O1xuICB9XG4gIHdyaXRlVUludDhBcnJheSh2YWx1ZSkge1xuICAgIGNvbnN0IGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICB0aGlzLiNleHBhbmRCdWZmZXIoNCArIGxlbmd0aCk7XG4gICAgdGhpcy53cml0ZVUzMihsZW5ndGgpO1xuICAgIHRoaXMuI2J1ZmZlci5zZXQodmFsdWUsIHRoaXMuI29mZnNldCk7XG4gICAgdGhpcy4jb2Zmc2V0ICs9IHZhbHVlLmxlbmd0aDtcbiAgfVxuICB3cml0ZUJvb2wodmFsdWUpIHtcbiAgICB0aGlzLiNleHBhbmRCdWZmZXIoMSk7XG4gICAgdGhpcy4jdmlldy5zZXRVaW50OCh0aGlzLiNvZmZzZXQsIHZhbHVlID8gMSA6IDApO1xuICAgIHRoaXMuI29mZnNldCArPSAxO1xuICB9XG4gIHdyaXRlQnl0ZSh2YWx1ZSkge1xuICAgIHRoaXMuI2V4cGFuZEJ1ZmZlcigxKTtcbiAgICB0aGlzLiN2aWV3LnNldFVpbnQ4KHRoaXMuI29mZnNldCwgdmFsdWUpO1xuICAgIHRoaXMuI29mZnNldCArPSAxO1xuICB9XG4gIHdyaXRlSTgodmFsdWUpIHtcbiAgICB0aGlzLiNleHBhbmRCdWZmZXIoMSk7XG4gICAgdGhpcy4jdmlldy5zZXRJbnQ4KHRoaXMuI29mZnNldCwgdmFsdWUpO1xuICAgIHRoaXMuI29mZnNldCArPSAxO1xuICB9XG4gIHdyaXRlVTgodmFsdWUpIHtcbiAgICB0aGlzLiNleHBhbmRCdWZmZXIoMSk7XG4gICAgdGhpcy4jdmlldy5zZXRVaW50OCh0aGlzLiNvZmZzZXQsIHZhbHVlKTtcbiAgICB0aGlzLiNvZmZzZXQgKz0gMTtcbiAgfVxuICB3cml0ZUkxNih2YWx1ZSkge1xuICAgIHRoaXMuI2V4cGFuZEJ1ZmZlcigyKTtcbiAgICB0aGlzLiN2aWV3LnNldEludDE2KHRoaXMuI29mZnNldCwgdmFsdWUsIHRydWUpO1xuICAgIHRoaXMuI29mZnNldCArPSAyO1xuICB9XG4gIHdyaXRlVTE2KHZhbHVlKSB7XG4gICAgdGhpcy4jZXhwYW5kQnVmZmVyKDIpO1xuICAgIHRoaXMuI3ZpZXcuc2V0VWludDE2KHRoaXMuI29mZnNldCwgdmFsdWUsIHRydWUpO1xuICAgIHRoaXMuI29mZnNldCArPSAyO1xuICB9XG4gIHdyaXRlSTMyKHZhbHVlKSB7XG4gICAgdGhpcy4jZXhwYW5kQnVmZmVyKDQpO1xuICAgIHRoaXMuI3ZpZXcuc2V0SW50MzIodGhpcy4jb2Zmc2V0LCB2YWx1ZSwgdHJ1ZSk7XG4gICAgdGhpcy4jb2Zmc2V0ICs9IDQ7XG4gIH1cbiAgd3JpdGVVMzIodmFsdWUpIHtcbiAgICB0aGlzLiNleHBhbmRCdWZmZXIoNCk7XG4gICAgdGhpcy4jdmlldy5zZXRVaW50MzIodGhpcy4jb2Zmc2V0LCB2YWx1ZSwgdHJ1ZSk7XG4gICAgdGhpcy4jb2Zmc2V0ICs9IDQ7XG4gIH1cbiAgd3JpdGVJNjQodmFsdWUpIHtcbiAgICB0aGlzLiNleHBhbmRCdWZmZXIoOCk7XG4gICAgdGhpcy4jdmlldy5zZXRCaWdJbnQ2NCh0aGlzLiNvZmZzZXQsIHZhbHVlLCB0cnVlKTtcbiAgICB0aGlzLiNvZmZzZXQgKz0gODtcbiAgfVxuICB3cml0ZVU2NCh2YWx1ZSkge1xuICAgIHRoaXMuI2V4cGFuZEJ1ZmZlcig4KTtcbiAgICB0aGlzLiN2aWV3LnNldEJpZ1VpbnQ2NCh0aGlzLiNvZmZzZXQsIHZhbHVlLCB0cnVlKTtcbiAgICB0aGlzLiNvZmZzZXQgKz0gODtcbiAgfVxuICB3cml0ZVUxMjgodmFsdWUpIHtcbiAgICB0aGlzLiNleHBhbmRCdWZmZXIoMTYpO1xuICAgIGNvbnN0IGxvd2VyUGFydCA9IHZhbHVlICYgQmlnSW50KFwiMHhGRkZGRkZGRkZGRkZGRkZGXCIpO1xuICAgIGNvbnN0IHVwcGVyUGFydCA9IHZhbHVlID4+IEJpZ0ludCg2NCk7XG4gICAgdGhpcy4jdmlldy5zZXRCaWdVaW50NjQodGhpcy4jb2Zmc2V0LCBsb3dlclBhcnQsIHRydWUpO1xuICAgIHRoaXMuI3ZpZXcuc2V0QmlnVWludDY0KHRoaXMuI29mZnNldCArIDgsIHVwcGVyUGFydCwgdHJ1ZSk7XG4gICAgdGhpcy4jb2Zmc2V0ICs9IDE2O1xuICB9XG4gIHdyaXRlSTEyOCh2YWx1ZSkge1xuICAgIHRoaXMuI2V4cGFuZEJ1ZmZlcigxNik7XG4gICAgY29uc3QgbG93ZXJQYXJ0ID0gdmFsdWUgJiBCaWdJbnQoXCIweEZGRkZGRkZGRkZGRkZGRkZcIik7XG4gICAgY29uc3QgdXBwZXJQYXJ0ID0gdmFsdWUgPj4gQmlnSW50KDY0KTtcbiAgICB0aGlzLiN2aWV3LnNldEJpZ0ludDY0KHRoaXMuI29mZnNldCwgbG93ZXJQYXJ0LCB0cnVlKTtcbiAgICB0aGlzLiN2aWV3LnNldEJpZ0ludDY0KHRoaXMuI29mZnNldCArIDgsIHVwcGVyUGFydCwgdHJ1ZSk7XG4gICAgdGhpcy4jb2Zmc2V0ICs9IDE2O1xuICB9XG4gIHdyaXRlVTI1Nih2YWx1ZSkge1xuICAgIHRoaXMuI2V4cGFuZEJ1ZmZlcigzMik7XG4gICAgY29uc3QgbG93XzY0X21hc2sgPSBCaWdJbnQoXCIweEZGRkZGRkZGRkZGRkZGRkZcIik7XG4gICAgY29uc3QgcDAgPSB2YWx1ZSAmIGxvd182NF9tYXNrO1xuICAgIGNvbnN0IHAxID0gdmFsdWUgPj4gQmlnSW50KDY0ICogMSkgJiBsb3dfNjRfbWFzaztcbiAgICBjb25zdCBwMiA9IHZhbHVlID4+IEJpZ0ludCg2NCAqIDIpICYgbG93XzY0X21hc2s7XG4gICAgY29uc3QgcDMgPSB2YWx1ZSA+PiBCaWdJbnQoNjQgKiAzKTtcbiAgICB0aGlzLiN2aWV3LnNldEJpZ1VpbnQ2NCh0aGlzLiNvZmZzZXQgKyA4ICogMCwgcDAsIHRydWUpO1xuICAgIHRoaXMuI3ZpZXcuc2V0QmlnVWludDY0KHRoaXMuI29mZnNldCArIDggKiAxLCBwMSwgdHJ1ZSk7XG4gICAgdGhpcy4jdmlldy5zZXRCaWdVaW50NjQodGhpcy4jb2Zmc2V0ICsgOCAqIDIsIHAyLCB0cnVlKTtcbiAgICB0aGlzLiN2aWV3LnNldEJpZ1VpbnQ2NCh0aGlzLiNvZmZzZXQgKyA4ICogMywgcDMsIHRydWUpO1xuICAgIHRoaXMuI29mZnNldCArPSAzMjtcbiAgfVxuICB3cml0ZUkyNTYodmFsdWUpIHtcbiAgICB0aGlzLiNleHBhbmRCdWZmZXIoMzIpO1xuICAgIGNvbnN0IGxvd182NF9tYXNrID0gQmlnSW50KFwiMHhGRkZGRkZGRkZGRkZGRkZGXCIpO1xuICAgIGNvbnN0IHAwID0gdmFsdWUgJiBsb3dfNjRfbWFzaztcbiAgICBjb25zdCBwMSA9IHZhbHVlID4+IEJpZ0ludCg2NCAqIDEpICYgbG93XzY0X21hc2s7XG4gICAgY29uc3QgcDIgPSB2YWx1ZSA+PiBCaWdJbnQoNjQgKiAyKSAmIGxvd182NF9tYXNrO1xuICAgIGNvbnN0IHAzID0gdmFsdWUgPj4gQmlnSW50KDY0ICogMyk7XG4gICAgdGhpcy4jdmlldy5zZXRCaWdVaW50NjQodGhpcy4jb2Zmc2V0ICsgOCAqIDAsIHAwLCB0cnVlKTtcbiAgICB0aGlzLiN2aWV3LnNldEJpZ1VpbnQ2NCh0aGlzLiNvZmZzZXQgKyA4ICogMSwgcDEsIHRydWUpO1xuICAgIHRoaXMuI3ZpZXcuc2V0QmlnVWludDY0KHRoaXMuI29mZnNldCArIDggKiAyLCBwMiwgdHJ1ZSk7XG4gICAgdGhpcy4jdmlldy5zZXRCaWdJbnQ2NCh0aGlzLiNvZmZzZXQgKyA4ICogMywgcDMsIHRydWUpO1xuICAgIHRoaXMuI29mZnNldCArPSAzMjtcbiAgfVxuICB3cml0ZUYzMih2YWx1ZSkge1xuICAgIHRoaXMuI2V4cGFuZEJ1ZmZlcig0KTtcbiAgICB0aGlzLiN2aWV3LnNldEZsb2F0MzIodGhpcy4jb2Zmc2V0LCB2YWx1ZSwgdHJ1ZSk7XG4gICAgdGhpcy4jb2Zmc2V0ICs9IDQ7XG4gIH1cbiAgd3JpdGVGNjQodmFsdWUpIHtcbiAgICB0aGlzLiNleHBhbmRCdWZmZXIoOCk7XG4gICAgdGhpcy4jdmlldy5zZXRGbG9hdDY0KHRoaXMuI29mZnNldCwgdmFsdWUsIHRydWUpO1xuICAgIHRoaXMuI29mZnNldCArPSA4O1xuICB9XG4gIHdyaXRlU3RyaW5nKHZhbHVlKSB7XG4gICAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgIGNvbnN0IGVuY29kZWRTdHJpbmcgPSBlbmNvZGVyLmVuY29kZSh2YWx1ZSk7XG4gICAgdGhpcy53cml0ZVUzMihlbmNvZGVkU3RyaW5nLmxlbmd0aCk7XG4gICAgdGhpcy4jZXhwYW5kQnVmZmVyKGVuY29kZWRTdHJpbmcubGVuZ3RoKTtcbiAgICB0aGlzLiNidWZmZXIuc2V0KGVuY29kZWRTdHJpbmcsIHRoaXMuI29mZnNldCk7XG4gICAgdGhpcy4jb2Zmc2V0ICs9IGVuY29kZWRTdHJpbmcubGVuZ3RoO1xuICB9XG59O1xuXG4vLyBzcmMvbGliL3V0aWwudHNcbmZ1bmN0aW9uIHRvUGFzY2FsQ2FzZShzKSB7XG4gIGNvbnN0IHN0ciA9IHMucmVwbGFjZSgvKFstX11bYS16XSkvZ2ksICgkMSkgPT4ge1xuICAgIHJldHVybiAkMS50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoXCItXCIsIFwiXCIpLnJlcGxhY2UoXCJfXCIsIFwiXCIpO1xuICB9KTtcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbn1cbmZ1bmN0aW9uIHVpbnQ4QXJyYXlUb0hleFN0cmluZyhhcnJheSkge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKGFycmF5LnJldmVyc2UoKSwgKHgpID0+IChcIjAwXCIgKyB4LnRvU3RyaW5nKDE2KSkuc2xpY2UoLTIpKS5qb2luKFwiXCIpO1xufVxuZnVuY3Rpb24gdWludDhBcnJheVRvVTEyOChhcnJheSkge1xuICBpZiAoYXJyYXkubGVuZ3RoICE9IDE2KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVaW50OEFycmF5IGlzIG5vdCAxNiBieXRlcyBsb25nOiAke2FycmF5fWApO1xuICB9XG4gIHJldHVybiBuZXcgQmluYXJ5UmVhZGVyKGFycmF5KS5yZWFkVTEyOCgpO1xufVxuZnVuY3Rpb24gdWludDhBcnJheVRvVTI1NihhcnJheSkge1xuICBpZiAoYXJyYXkubGVuZ3RoICE9IDMyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVaW50OEFycmF5IGlzIG5vdCAzMiBieXRlcyBsb25nOiBbJHthcnJheX1dYCk7XG4gIH1cbiAgcmV0dXJuIG5ldyBCaW5hcnlSZWFkZXIoYXJyYXkpLnJlYWRVMjU2KCk7XG59XG5mdW5jdGlvbiBoZXhTdHJpbmdUb1VpbnQ4QXJyYXkoc3RyKSB7XG4gIGlmIChzdHIuc3RhcnRzV2l0aChcIjB4XCIpKSB7XG4gICAgc3RyID0gc3RyLnNsaWNlKDIpO1xuICB9XG4gIGNvbnN0IG1hdGNoZXMgPSBzdHIubWF0Y2goLy57MSwyfS9nKSB8fCBbXTtcbiAgY29uc3QgZGF0YSA9IFVpbnQ4QXJyYXkuZnJvbShcbiAgICBtYXRjaGVzLm1hcCgoYnl0ZSkgPT4gcGFyc2VJbnQoYnl0ZSwgMTYpKVxuICApO1xuICByZXR1cm4gZGF0YS5yZXZlcnNlKCk7XG59XG5mdW5jdGlvbiBoZXhTdHJpbmdUb1UxMjgoc3RyKSB7XG4gIHJldHVybiB1aW50OEFycmF5VG9VMTI4KGhleFN0cmluZ1RvVWludDhBcnJheShzdHIpKTtcbn1cbmZ1bmN0aW9uIGhleFN0cmluZ1RvVTI1NihzdHIpIHtcbiAgcmV0dXJuIHVpbnQ4QXJyYXlUb1UyNTYoaGV4U3RyaW5nVG9VaW50OEFycmF5KHN0cikpO1xufVxuZnVuY3Rpb24gdTEyOFRvVWludDhBcnJheShkYXRhKSB7XG4gIGNvbnN0IHdyaXRlciA9IG5ldyBCaW5hcnlXcml0ZXIoMTYpO1xuICB3cml0ZXIud3JpdGVVMTI4KGRhdGEpO1xuICByZXR1cm4gd3JpdGVyLmdldEJ1ZmZlcigpO1xufVxuZnVuY3Rpb24gdTEyOFRvSGV4U3RyaW5nKGRhdGEpIHtcbiAgcmV0dXJuIHVpbnQ4QXJyYXlUb0hleFN0cmluZyh1MTI4VG9VaW50OEFycmF5KGRhdGEpKTtcbn1cbmZ1bmN0aW9uIHUyNTZUb1VpbnQ4QXJyYXkoZGF0YSkge1xuICBjb25zdCB3cml0ZXIgPSBuZXcgQmluYXJ5V3JpdGVyKDMyKTtcbiAgd3JpdGVyLndyaXRlVTI1NihkYXRhKTtcbiAgcmV0dXJuIHdyaXRlci5nZXRCdWZmZXIoKTtcbn1cbmZ1bmN0aW9uIHUyNTZUb0hleFN0cmluZyhkYXRhKSB7XG4gIHJldHVybiB1aW50OEFycmF5VG9IZXhTdHJpbmcodTI1NlRvVWludDhBcnJheShkYXRhKSk7XG59XG5mdW5jdGlvbiB0b0NhbWVsQ2FzZShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bLV9dKy9nLCBcIl9cIikucmVwbGFjZSgvXyhbYS16QS1aMC05XSkvZywgKF8sIGMpID0+IGMudG9VcHBlckNhc2UoKSk7XG59XG5mdW5jdGlvbiBic2F0bkJhc2VTaXplKHR5cGVzcGFjZSwgdHkpIHtcbiAgY29uc3QgYXNzdW1lZEFycmF5TGVuZ3RoID0gNDtcbiAgd2hpbGUgKHR5LnRhZyA9PT0gXCJSZWZcIikgdHkgPSB0eXBlc3BhY2UudHlwZXNbdHkudmFsdWVdO1xuICBpZiAodHkudGFnID09PSBcIlByb2R1Y3RcIikge1xuICAgIGxldCBzdW0gPSAwO1xuICAgIGZvciAoY29uc3QgeyBhbGdlYnJhaWNUeXBlOiBlbGVtIH0gb2YgdHkudmFsdWUuZWxlbWVudHMpIHtcbiAgICAgIHN1bSArPSBic2F0bkJhc2VTaXplKHR5cGVzcGFjZSwgZWxlbSk7XG4gICAgfVxuICAgIHJldHVybiBzdW07XG4gIH0gZWxzZSBpZiAodHkudGFnID09PSBcIlN1bVwiKSB7XG4gICAgbGV0IG1pbiA9IEluZmluaXR5O1xuICAgIGZvciAoY29uc3QgeyBhbGdlYnJhaWNUeXBlOiB2YXJpIH0gb2YgdHkudmFsdWUudmFyaWFudHMpIHtcbiAgICAgIGNvbnN0IHZTaXplID0gYnNhdG5CYXNlU2l6ZSh0eXBlc3BhY2UsIHZhcmkpO1xuICAgICAgaWYgKHZTaXplIDwgbWluKSBtaW4gPSB2U2l6ZTtcbiAgICB9XG4gICAgaWYgKG1pbiA9PT0gSW5maW5pdHkpIG1pbiA9IDA7XG4gICAgcmV0dXJuIDQgKyBtaW47XG4gIH0gZWxzZSBpZiAodHkudGFnID09IFwiQXJyYXlcIikge1xuICAgIHJldHVybiA0ICsgYXNzdW1lZEFycmF5TGVuZ3RoICogYnNhdG5CYXNlU2l6ZSh0eXBlc3BhY2UsIHR5LnZhbHVlKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIFN0cmluZzogNCArIGFzc3VtZWRBcnJheUxlbmd0aCxcbiAgICBTdW06IDEsXG4gICAgQm9vbDogMSxcbiAgICBJODogMSxcbiAgICBVODogMSxcbiAgICBJMTY6IDIsXG4gICAgVTE2OiAyLFxuICAgIEkzMjogNCxcbiAgICBVMzI6IDQsXG4gICAgRjMyOiA0LFxuICAgIEk2NDogOCxcbiAgICBVNjQ6IDgsXG4gICAgRjY0OiA4LFxuICAgIEkxMjg6IDE2LFxuICAgIFUxMjg6IDE2LFxuICAgIEkyNTY6IDMyLFxuICAgIFUyNTY6IDMyXG4gIH1bdHkudGFnXTtcbn1cblxuLy8gc3JjL2xpYi9jb25uZWN0aW9uX2lkLnRzXG52YXIgQ29ubmVjdGlvbklkID0gY2xhc3MgX0Nvbm5lY3Rpb25JZCB7XG4gIF9fY29ubmVjdGlvbl9pZF9fO1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBgQ29ubmVjdGlvbklkYC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICB0aGlzLl9fY29ubmVjdGlvbl9pZF9fID0gZGF0YTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBhbGdlYnJhaWMgdHlwZSByZXByZXNlbnRhdGlvbiBvZiB0aGUge0BsaW5rIENvbm5lY3Rpb25JZH0gdHlwZS5cbiAgICogQHJldHVybnMgVGhlIGFsZ2VicmFpYyB0eXBlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0eXBlLlxuICAgKi9cbiAgc3RhdGljIGdldEFsZ2VicmFpY1R5cGUoKSB7XG4gICAgcmV0dXJuIEFsZ2VicmFpY1R5cGUuUHJvZHVjdCh7XG4gICAgICBlbGVtZW50czogW1xuICAgICAgICB7IG5hbWU6IFwiX19jb25uZWN0aW9uX2lkX19cIiwgYWxnZWJyYWljVHlwZTogQWxnZWJyYWljVHlwZS5VMTI4IH1cbiAgICAgIF1cbiAgICB9KTtcbiAgfVxuICBpc1plcm8oKSB7XG4gICAgcmV0dXJuIHRoaXMuX19jb25uZWN0aW9uX2lkX18gPT09IEJpZ0ludCgwKTtcbiAgfVxuICBzdGF0aWMgbnVsbElmWmVybyhhZGRyKSB7XG4gICAgaWYgKGFkZHIuaXNaZXJvKCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYWRkcjtcbiAgICB9XG4gIH1cbiAgc3RhdGljIHJhbmRvbSgpIHtcbiAgICBmdW5jdGlvbiByYW5kb21VOCgpIHtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyNTUpO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0ID0gQmlnSW50KDApO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgICAgcmVzdWx0ID0gcmVzdWx0IDw8IEJpZ0ludCg4KSB8IEJpZ0ludChyYW5kb21VOCgpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBfQ29ubmVjdGlvbklkKHJlc3VsdCk7XG4gIH1cbiAgLyoqXG4gICAqIENvbXBhcmUgdHdvIGNvbm5lY3Rpb24gSURzIGZvciBlcXVhbGl0eS5cbiAgICovXG4gIGlzRXF1YWwob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fX2Nvbm5lY3Rpb25faWRfXyA9PSBvdGhlci5fX2Nvbm5lY3Rpb25faWRfXztcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgdHdvIGNvbm5lY3Rpb24gSURzIGFyZSBlcXVhbC5cbiAgICovXG4gIGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmlzRXF1YWwob3RoZXIpO1xuICB9XG4gIC8qKlxuICAgKiBQcmludCB0aGUgY29ubmVjdGlvbiBJRCBhcyBhIGhleGFkZWNpbWFsIHN0cmluZy5cbiAgICovXG4gIHRvSGV4U3RyaW5nKCkge1xuICAgIHJldHVybiB1MTI4VG9IZXhTdHJpbmcodGhpcy5fX2Nvbm5lY3Rpb25faWRfXyk7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnQgdGhlIGNvbm5lY3Rpb24gSUQgdG8gYSBVaW50OEFycmF5LlxuICAgKi9cbiAgdG9VaW50OEFycmF5KCkge1xuICAgIHJldHVybiB1MTI4VG9VaW50OEFycmF5KHRoaXMuX19jb25uZWN0aW9uX2lkX18pO1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZSBhIGNvbm5lY3Rpb24gSUQgZnJvbSBhIGhleGFkZWNpbWFsIHN0cmluZy5cbiAgICovXG4gIHN0YXRpYyBmcm9tU3RyaW5nKHN0cikge1xuICAgIHJldHVybiBuZXcgX0Nvbm5lY3Rpb25JZChoZXhTdHJpbmdUb1UxMjgoc3RyKSk7XG4gIH1cbiAgc3RhdGljIGZyb21TdHJpbmdPck51bGwoc3RyKSB7XG4gICAgY29uc3QgYWRkciA9IF9Db25uZWN0aW9uSWQuZnJvbVN0cmluZyhzdHIpO1xuICAgIGlmIChhZGRyLmlzWmVybygpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFkZHI7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvbGliL2lkZW50aXR5LnRzXG52YXIgSWRlbnRpdHkgPSBjbGFzcyBfSWRlbnRpdHkge1xuICBfX2lkZW50aXR5X187XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGBJZGVudGl0eWAuXG4gICAqXG4gICAqIGBkYXRhYCBjYW4gYmUgYSBoZXhhZGVjaW1hbCBzdHJpbmcgb3IgYSBgYmlnaW50YC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICB0aGlzLl9faWRlbnRpdHlfXyA9IHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiID8gaGV4U3RyaW5nVG9VMjU2KGRhdGEpIDogZGF0YTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBhbGdlYnJhaWMgdHlwZSByZXByZXNlbnRhdGlvbiBvZiB0aGUge0BsaW5rIElkZW50aXR5fSB0eXBlLlxuICAgKiBAcmV0dXJucyBUaGUgYWxnZWJyYWljIHR5cGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIHR5cGUuXG4gICAqL1xuICBzdGF0aWMgZ2V0QWxnZWJyYWljVHlwZSgpIHtcbiAgICByZXR1cm4gQWxnZWJyYWljVHlwZS5Qcm9kdWN0KHtcbiAgICAgIGVsZW1lbnRzOiBbeyBuYW1lOiBcIl9faWRlbnRpdHlfX1wiLCBhbGdlYnJhaWNUeXBlOiBBbGdlYnJhaWNUeXBlLlUyNTYgfV1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgdHdvIGlkZW50aXRpZXMgYXJlIGVxdWFsLlxuICAgKi9cbiAgaXNFcXVhbChvdGhlcikge1xuICAgIHJldHVybiB0aGlzLnRvSGV4U3RyaW5nKCkgPT09IG90aGVyLnRvSGV4U3RyaW5nKCk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIHR3byBpZGVudGl0aWVzIGFyZSBlcXVhbC5cbiAgICovXG4gIGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmlzRXF1YWwob3RoZXIpO1xuICB9XG4gIC8qKlxuICAgKiBQcmludCB0aGUgaWRlbnRpdHkgYXMgYSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gICAqL1xuICB0b0hleFN0cmluZygpIHtcbiAgICByZXR1cm4gdTI1NlRvSGV4U3RyaW5nKHRoaXMuX19pZGVudGl0eV9fKTtcbiAgfVxuICAvKipcbiAgICogQ29udmVydCB0aGUgYWRkcmVzcyB0byBhIFVpbnQ4QXJyYXkuXG4gICAqL1xuICB0b1VpbnQ4QXJyYXkoKSB7XG4gICAgcmV0dXJuIHUyNTZUb1VpbnQ4QXJyYXkodGhpcy5fX2lkZW50aXR5X18pO1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZSBhbiBJZGVudGl0eSBmcm9tIGEgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICAgKi9cbiAgc3RhdGljIGZyb21TdHJpbmcoc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBfSWRlbnRpdHkoc3RyKTtcbiAgfVxuICAvKipcbiAgICogWmVybyBpZGVudGl0eSAoMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwKVxuICAgKi9cbiAgc3RhdGljIHplcm8oKSB7XG4gICAgcmV0dXJuIG5ldyBfSWRlbnRpdHkoMG4pO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnRvSGV4U3RyaW5nKCk7XG4gIH1cbn07XG5cbi8vIHNyYy9saWIvYWxnZWJyYWljX3R5cGUudHNcbnZhciBBbGdlYnJhaWNUeXBlID0ge1xuICBSZWY6ICh2YWx1ZSkgPT4gKHsgdGFnOiBcIlJlZlwiLCB2YWx1ZSB9KSxcbiAgU3VtOiAodmFsdWUpID0+ICh7XG4gICAgdGFnOiBcIlN1bVwiLFxuICAgIHZhbHVlXG4gIH0pLFxuICBQcm9kdWN0OiAodmFsdWUpID0+ICh7XG4gICAgdGFnOiBcIlByb2R1Y3RcIixcbiAgICB2YWx1ZVxuICB9KSxcbiAgQXJyYXk6ICh2YWx1ZSkgPT4gKHtcbiAgICB0YWc6IFwiQXJyYXlcIixcbiAgICB2YWx1ZVxuICB9KSxcbiAgU3RyaW5nOiB7IHRhZzogXCJTdHJpbmdcIiB9LFxuICBCb29sOiB7IHRhZzogXCJCb29sXCIgfSxcbiAgSTg6IHsgdGFnOiBcIkk4XCIgfSxcbiAgVTg6IHsgdGFnOiBcIlU4XCIgfSxcbiAgSTE2OiB7IHRhZzogXCJJMTZcIiB9LFxuICBVMTY6IHsgdGFnOiBcIlUxNlwiIH0sXG4gIEkzMjogeyB0YWc6IFwiSTMyXCIgfSxcbiAgVTMyOiB7IHRhZzogXCJVMzJcIiB9LFxuICBJNjQ6IHsgdGFnOiBcIkk2NFwiIH0sXG4gIFU2NDogeyB0YWc6IFwiVTY0XCIgfSxcbiAgSTEyODogeyB0YWc6IFwiSTEyOFwiIH0sXG4gIFUxMjg6IHsgdGFnOiBcIlUxMjhcIiB9LFxuICBJMjU2OiB7IHRhZzogXCJJMjU2XCIgfSxcbiAgVTI1NjogeyB0YWc6IFwiVTI1NlwiIH0sXG4gIEYzMjogeyB0YWc6IFwiRjMyXCIgfSxcbiAgRjY0OiB7IHRhZzogXCJGNjRcIiB9LFxuICBzZXJpYWxpemVWYWx1ZSh3cml0ZXIsIHR5LCB2YWx1ZSwgdHlwZXNwYWNlKSB7XG4gICAgaWYgKHR5LnRhZyA9PT0gXCJSZWZcIikge1xuICAgICAgaWYgKCF0eXBlc3BhY2UpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBzZXJpYWxpemUgcmVmcyB3aXRob3V0IGEgdHlwZXNwYWNlXCIpO1xuICAgICAgd2hpbGUgKHR5LnRhZyA9PT0gXCJSZWZcIikgdHkgPSB0eXBlc3BhY2UudHlwZXNbdHkudmFsdWVdO1xuICAgIH1cbiAgICBzd2l0Y2ggKHR5LnRhZykge1xuICAgICAgY2FzZSBcIlByb2R1Y3RcIjpcbiAgICAgICAgUHJvZHVjdFR5cGUuc2VyaWFsaXplVmFsdWUod3JpdGVyLCB0eS52YWx1ZSwgdmFsdWUsIHR5cGVzcGFjZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIlN1bVwiOlxuICAgICAgICBTdW1UeXBlLnNlcmlhbGl6ZVZhbHVlKHdyaXRlciwgdHkudmFsdWUsIHZhbHVlLCB0eXBlc3BhY2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJBcnJheVwiOlxuICAgICAgICBpZiAodHkudmFsdWUudGFnID09PSBcIlU4XCIpIHtcbiAgICAgICAgICB3cml0ZXIud3JpdGVVSW50OEFycmF5KHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBlbGVtVHlwZSA9IHR5LnZhbHVlO1xuICAgICAgICAgIHdyaXRlci53cml0ZVUzMih2YWx1ZS5sZW5ndGgpO1xuICAgICAgICAgIGZvciAoY29uc3QgZWxlbSBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgQWxnZWJyYWljVHlwZS5zZXJpYWxpemVWYWx1ZSh3cml0ZXIsIGVsZW1UeXBlLCBlbGVtLCB0eXBlc3BhY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJCb29sXCI6XG4gICAgICAgIHdyaXRlci53cml0ZUJvb2wodmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJJOFwiOlxuICAgICAgICB3cml0ZXIud3JpdGVJOCh2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIlU4XCI6XG4gICAgICAgIHdyaXRlci53cml0ZVU4KHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiSTE2XCI6XG4gICAgICAgIHdyaXRlci53cml0ZUkxNih2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIlUxNlwiOlxuICAgICAgICB3cml0ZXIud3JpdGVVMTYodmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJJMzJcIjpcbiAgICAgICAgd3JpdGVyLndyaXRlSTMyKHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiVTMyXCI6XG4gICAgICAgIHdyaXRlci53cml0ZVUzMih2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkk2NFwiOlxuICAgICAgICB3cml0ZXIud3JpdGVJNjQodmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJVNjRcIjpcbiAgICAgICAgd3JpdGVyLndyaXRlVTY0KHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiSTEyOFwiOlxuICAgICAgICB3cml0ZXIud3JpdGVJMTI4KHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiVTEyOFwiOlxuICAgICAgICB3cml0ZXIud3JpdGVVMTI4KHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiSTI1NlwiOlxuICAgICAgICB3cml0ZXIud3JpdGVJMjU2KHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiVTI1NlwiOlxuICAgICAgICB3cml0ZXIud3JpdGVVMjU2KHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiRjMyXCI6XG4gICAgICAgIHdyaXRlci53cml0ZUYzMih2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkY2NFwiOlxuICAgICAgICB3cml0ZXIud3JpdGVGNjQodmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJTdHJpbmdcIjpcbiAgICAgICAgd3JpdGVyLndyaXRlU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9LFxuICBkZXNlcmlhbGl6ZVZhbHVlOiBmdW5jdGlvbihyZWFkZXIsIHR5LCB0eXBlc3BhY2UpIHtcbiAgICBpZiAodHkudGFnID09PSBcIlJlZlwiKSB7XG4gICAgICBpZiAoIXR5cGVzcGFjZSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGRlc2VyaWFsaXplIHJlZnMgd2l0aG91dCBhIHR5cGVzcGFjZVwiKTtcbiAgICAgIHdoaWxlICh0eS50YWcgPT09IFwiUmVmXCIpIHR5ID0gdHlwZXNwYWNlLnR5cGVzW3R5LnZhbHVlXTtcbiAgICB9XG4gICAgc3dpdGNoICh0eS50YWcpIHtcbiAgICAgIGNhc2UgXCJQcm9kdWN0XCI6XG4gICAgICAgIHJldHVybiBQcm9kdWN0VHlwZS5kZXNlcmlhbGl6ZVZhbHVlKHJlYWRlciwgdHkudmFsdWUsIHR5cGVzcGFjZSk7XG4gICAgICBjYXNlIFwiU3VtXCI6XG4gICAgICAgIHJldHVybiBTdW1UeXBlLmRlc2VyaWFsaXplVmFsdWUocmVhZGVyLCB0eS52YWx1ZSwgdHlwZXNwYWNlKTtcbiAgICAgIGNhc2UgXCJBcnJheVwiOlxuICAgICAgICBpZiAodHkudmFsdWUudGFnID09PSBcIlU4XCIpIHtcbiAgICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWRVSW50OEFycmF5KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgZWxlbVR5cGUgPSB0eS52YWx1ZTtcbiAgICAgICAgICBjb25zdCBsZW5ndGggPSByZWFkZXIucmVhZFUzMigpO1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgICAgICBBbGdlYnJhaWNUeXBlLmRlc2VyaWFsaXplVmFsdWUocmVhZGVyLCBlbGVtVHlwZSwgdHlwZXNwYWNlKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgY2FzZSBcIkJvb2xcIjpcbiAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkQm9vbCgpO1xuICAgICAgY2FzZSBcIkk4XCI6XG4gICAgICAgIHJldHVybiByZWFkZXIucmVhZEk4KCk7XG4gICAgICBjYXNlIFwiVThcIjpcbiAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkVTgoKTtcbiAgICAgIGNhc2UgXCJJMTZcIjpcbiAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkSTE2KCk7XG4gICAgICBjYXNlIFwiVTE2XCI6XG4gICAgICAgIHJldHVybiByZWFkZXIucmVhZFUxNigpO1xuICAgICAgY2FzZSBcIkkzMlwiOlxuICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWRJMzIoKTtcbiAgICAgIGNhc2UgXCJVMzJcIjpcbiAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkVTMyKCk7XG4gICAgICBjYXNlIFwiSTY0XCI6XG4gICAgICAgIHJldHVybiByZWFkZXIucmVhZEk2NCgpO1xuICAgICAgY2FzZSBcIlU2NFwiOlxuICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWRVNjQoKTtcbiAgICAgIGNhc2UgXCJJMTI4XCI6XG4gICAgICAgIHJldHVybiByZWFkZXIucmVhZEkxMjgoKTtcbiAgICAgIGNhc2UgXCJVMTI4XCI6XG4gICAgICAgIHJldHVybiByZWFkZXIucmVhZFUxMjgoKTtcbiAgICAgIGNhc2UgXCJJMjU2XCI6XG4gICAgICAgIHJldHVybiByZWFkZXIucmVhZEkyNTYoKTtcbiAgICAgIGNhc2UgXCJVMjU2XCI6XG4gICAgICAgIHJldHVybiByZWFkZXIucmVhZFUyNTYoKTtcbiAgICAgIGNhc2UgXCJGMzJcIjpcbiAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkRjMyKCk7XG4gICAgICBjYXNlIFwiRjY0XCI6XG4gICAgICAgIHJldHVybiByZWFkZXIucmVhZEY2NCgpO1xuICAgICAgY2FzZSBcIlN0cmluZ1wiOlxuICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWRTdHJpbmcoKTtcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgdmFsdWUgb2YgdGhlIGFsZ2VicmFpYyB0eXBlIGludG8gc29tZXRoaW5nIHRoYXQgY2FuIGJlIHVzZWQgYXMgYSBrZXkgaW4gYSBtYXAuXG4gICAqIFRoZXJlIGFyZSBubyBndWFyYW50ZWVzIGFib3V0IGJlaW5nIGFibGUgdG8gb3JkZXIgaXQuXG4gICAqIFRoaXMgaXMgb25seSBndWFyYW50ZWVkIHRvIGJlIGNvbXBhcmFibGUgdG8gb3RoZXIgdmFsdWVzIG9mIHRoZSBzYW1lIHR5cGUuXG4gICAqIEBwYXJhbSB2YWx1ZSBBIHZhbHVlIG9mIHRoZSBhbGdlYnJhaWMgdHlwZVxuICAgKiBAcmV0dXJucyBTb21ldGhpbmcgdGhhdCBjYW4gYmUgdXNlZCBhcyBhIGtleSBpbiBhIG1hcC5cbiAgICovXG4gIGludG9NYXBLZXk6IGZ1bmN0aW9uKHR5LCB2YWx1ZSkge1xuICAgIHN3aXRjaCAodHkudGFnKSB7XG4gICAgICBjYXNlIFwiVThcIjpcbiAgICAgIGNhc2UgXCJVMTZcIjpcbiAgICAgIGNhc2UgXCJVMzJcIjpcbiAgICAgIGNhc2UgXCJVNjRcIjpcbiAgICAgIGNhc2UgXCJVMTI4XCI6XG4gICAgICBjYXNlIFwiVTI1NlwiOlxuICAgICAgY2FzZSBcIkk4XCI6XG4gICAgICBjYXNlIFwiSTE2XCI6XG4gICAgICBjYXNlIFwiSTMyXCI6XG4gICAgICBjYXNlIFwiSTY0XCI6XG4gICAgICBjYXNlIFwiSTEyOFwiOlxuICAgICAgY2FzZSBcIkkyNTZcIjpcbiAgICAgIGNhc2UgXCJGMzJcIjpcbiAgICAgIGNhc2UgXCJGNjRcIjpcbiAgICAgIGNhc2UgXCJTdHJpbmdcIjpcbiAgICAgIGNhc2UgXCJCb29sXCI6XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIGNhc2UgXCJQcm9kdWN0XCI6XG4gICAgICAgIHJldHVybiBQcm9kdWN0VHlwZS5pbnRvTWFwS2V5KHR5LnZhbHVlLCB2YWx1ZSk7XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIGNvbnN0IHdyaXRlciA9IG5ldyBCaW5hcnlXcml0ZXIoMTApO1xuICAgICAgICBBbGdlYnJhaWNUeXBlLnNlcmlhbGl6ZVZhbHVlKHdyaXRlciwgdHksIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlci50b0Jhc2U2NCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbnZhciBQcm9kdWN0VHlwZSA9IHtcbiAgc2VyaWFsaXplVmFsdWUod3JpdGVyLCB0eSwgdmFsdWUsIHR5cGVzcGFjZSkge1xuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiB0eS5lbGVtZW50cykge1xuICAgICAgQWxnZWJyYWljVHlwZS5zZXJpYWxpemVWYWx1ZShcbiAgICAgICAgd3JpdGVyLFxuICAgICAgICBlbGVtZW50LmFsZ2VicmFpY1R5cGUsXG4gICAgICAgIHZhbHVlW2VsZW1lbnQubmFtZV0sXG4gICAgICAgIHR5cGVzcGFjZVxuICAgICAgKTtcbiAgICB9XG4gIH0sXG4gIGRlc2VyaWFsaXplVmFsdWUocmVhZGVyLCB0eSwgdHlwZXNwYWNlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgaWYgKHR5LmVsZW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgaWYgKHR5LmVsZW1lbnRzWzBdLm5hbWUgPT09IFwiX190aW1lX2R1cmF0aW9uX21pY3Jvc19fXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUaW1lRHVyYXRpb24ocmVhZGVyLnJlYWRJNjQoKSk7XG4gICAgICB9XG4gICAgICBpZiAodHkuZWxlbWVudHNbMF0ubmFtZSA9PT0gXCJfX3RpbWVzdGFtcF9taWNyb3Nfc2luY2VfdW5peF9lcG9jaF9fXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUaW1lc3RhbXAocmVhZGVyLnJlYWRJNjQoKSk7XG4gICAgICB9XG4gICAgICBpZiAodHkuZWxlbWVudHNbMF0ubmFtZSA9PT0gXCJfX2lkZW50aXR5X19cIikge1xuICAgICAgICByZXR1cm4gbmV3IElkZW50aXR5KHJlYWRlci5yZWFkVTI1NigpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eS5lbGVtZW50c1swXS5uYW1lID09PSBcIl9fY29ubmVjdGlvbl9pZF9fXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb25uZWN0aW9uSWQocmVhZGVyLnJlYWRVMTI4KCkpO1xuICAgICAgfVxuICAgICAgaWYgKHR5LmVsZW1lbnRzWzBdLm5hbWUgPT09IFwiX191dWlkX19cIikge1xuICAgICAgICByZXR1cm4gbmV3IFV1aWQocmVhZGVyLnJlYWRVMTI4KCkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdHkuZWxlbWVudHMpIHtcbiAgICAgIHJlc3VsdFtlbGVtZW50Lm5hbWVdID0gQWxnZWJyYWljVHlwZS5kZXNlcmlhbGl6ZVZhbHVlKFxuICAgICAgICByZWFkZXIsXG4gICAgICAgIGVsZW1lbnQuYWxnZWJyYWljVHlwZSxcbiAgICAgICAgdHlwZXNwYWNlXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuICBpbnRvTWFwS2V5KHR5LCB2YWx1ZSkge1xuICAgIGlmICh0eS5lbGVtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGlmICh0eS5lbGVtZW50c1swXS5uYW1lID09PSBcIl9fdGltZV9kdXJhdGlvbl9taWNyb3NfX1wiKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5fX3RpbWVfZHVyYXRpb25fbWljcm9zX187XG4gICAgICB9XG4gICAgICBpZiAodHkuZWxlbWVudHNbMF0ubmFtZSA9PT0gXCJfX3RpbWVzdGFtcF9taWNyb3Nfc2luY2VfdW5peF9lcG9jaF9fXCIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLl9fdGltZXN0YW1wX21pY3Jvc19zaW5jZV91bml4X2Vwb2NoX187XG4gICAgICB9XG4gICAgICBpZiAodHkuZWxlbWVudHNbMF0ubmFtZSA9PT0gXCJfX2lkZW50aXR5X19cIikge1xuICAgICAgICByZXR1cm4gdmFsdWUuX19pZGVudGl0eV9fO1xuICAgICAgfVxuICAgICAgaWYgKHR5LmVsZW1lbnRzWzBdLm5hbWUgPT09IFwiX19jb25uZWN0aW9uX2lkX19cIikge1xuICAgICAgICByZXR1cm4gdmFsdWUuX19jb25uZWN0aW9uX2lkX187XG4gICAgICB9XG4gICAgICBpZiAodHkuZWxlbWVudHNbMF0ubmFtZSA9PT0gXCJfX3V1aWRfX1wiKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5fX3V1aWRfXztcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgd3JpdGVyID0gbmV3IEJpbmFyeVdyaXRlcigxMCk7XG4gICAgQWxnZWJyYWljVHlwZS5zZXJpYWxpemVWYWx1ZSh3cml0ZXIsIEFsZ2VicmFpY1R5cGUuUHJvZHVjdCh0eSksIHZhbHVlKTtcbiAgICByZXR1cm4gd3JpdGVyLnRvQmFzZTY0KCk7XG4gIH1cbn07XG52YXIgU3VtVHlwZSA9IHtcbiAgc2VyaWFsaXplVmFsdWU6IGZ1bmN0aW9uKHdyaXRlciwgdHksIHZhbHVlLCB0eXBlc3BhY2UpIHtcbiAgICBpZiAodHkudmFyaWFudHMubGVuZ3RoID09IDIgJiYgdHkudmFyaWFudHNbMF0ubmFtZSA9PT0gXCJzb21lXCIgJiYgdHkudmFyaWFudHNbMV0ubmFtZSA9PT0gXCJub25lXCIpIHtcbiAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHdyaXRlci53cml0ZUJ5dGUoMCk7XG4gICAgICAgIEFsZ2VicmFpY1R5cGUuc2VyaWFsaXplVmFsdWUoXG4gICAgICAgICAgd3JpdGVyLFxuICAgICAgICAgIHR5LnZhcmlhbnRzWzBdLmFsZ2VicmFpY1R5cGUsXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgdHlwZXNwYWNlXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3cml0ZXIud3JpdGVCeXRlKDEpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHkudmFyaWFudHMubGVuZ3RoID09IDIgJiYgdHkudmFyaWFudHNbMF0ubmFtZSA9PT0gXCJva1wiICYmIHR5LnZhcmlhbnRzWzFdLm5hbWUgPT09IFwiZXJyXCIpIHtcbiAgICAgIGxldCB2YXJpYW50TmFtZTtcbiAgICAgIGxldCBpbm5lclZhbHVlO1xuICAgICAgbGV0IGluZGV4O1xuICAgICAgaWYgKFwib2tcIiBpbiB2YWx1ZSkge1xuICAgICAgICB2YXJpYW50TmFtZSA9IFwib2tcIjtcbiAgICAgICAgaW5uZXJWYWx1ZSA9IHZhbHVlLm9rO1xuICAgICAgICBpbmRleCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXJpYW50TmFtZSA9IFwiZXJyXCI7XG4gICAgICAgIGlubmVyVmFsdWUgPSB2YWx1ZS5lcnI7XG4gICAgICAgIGluZGV4ID0gMTtcbiAgICAgIH1cbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgdGhyb3cgYFJlc3VsdCBzZXJpYWxpemF0aW9uIGVycm9yOiB2YXJpYW50ICcke3ZhcmlhbnROYW1lfScgbm90IGZvdW5kIGluICR7SlNPTi5zdHJpbmdpZnkodHkpfWA7XG4gICAgICB9XG4gICAgICB3cml0ZXIud3JpdGVVOChpbmRleCk7XG4gICAgICBBbGdlYnJhaWNUeXBlLnNlcmlhbGl6ZVZhbHVlKFxuICAgICAgICB3cml0ZXIsXG4gICAgICAgIHR5LnZhcmlhbnRzW2luZGV4XS5hbGdlYnJhaWNUeXBlLFxuICAgICAgICBpbm5lclZhbHVlLFxuICAgICAgICB0eXBlc3BhY2VcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHZhcmlhbnQgPSB2YWx1ZVtcInRhZ1wiXTtcbiAgICAgIGNvbnN0IGluZGV4ID0gdHkudmFyaWFudHMuZmluZEluZGV4KCh2KSA9PiB2Lm5hbWUgPT09IHZhcmlhbnQpO1xuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICB0aHJvdyBgQ2FuJ3Qgc2VyaWFsaXplIGEgc3VtIHR5cGUsIGNvdWxkbid0IGZpbmQgJHt2YWx1ZS50YWd9IHRhZyAke0pTT04uc3RyaW5naWZ5KHZhbHVlKX0gaW4gdmFyaWFudHMgJHtKU09OLnN0cmluZ2lmeSh0eSl9YDtcbiAgICAgIH1cbiAgICAgIHdyaXRlci53cml0ZVU4KGluZGV4KTtcbiAgICAgIEFsZ2VicmFpY1R5cGUuc2VyaWFsaXplVmFsdWUoXG4gICAgICAgIHdyaXRlcixcbiAgICAgICAgdHkudmFyaWFudHNbaW5kZXhdLmFsZ2VicmFpY1R5cGUsXG4gICAgICAgIHZhbHVlW1widmFsdWVcIl0sXG4gICAgICAgIHR5cGVzcGFjZVxuICAgICAgKTtcbiAgICB9XG4gIH0sXG4gIGRlc2VyaWFsaXplVmFsdWU6IGZ1bmN0aW9uKHJlYWRlciwgdHksIHR5cGVzcGFjZSkge1xuICAgIGNvbnN0IHRhZyA9IHJlYWRlci5yZWFkVTgoKTtcbiAgICBpZiAodHkudmFyaWFudHMubGVuZ3RoID09IDIgJiYgdHkudmFyaWFudHNbMF0ubmFtZSA9PT0gXCJzb21lXCIgJiYgdHkudmFyaWFudHNbMV0ubmFtZSA9PT0gXCJub25lXCIpIHtcbiAgICAgIGlmICh0YWcgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEFsZ2VicmFpY1R5cGUuZGVzZXJpYWxpemVWYWx1ZShcbiAgICAgICAgICByZWFkZXIsXG4gICAgICAgICAgdHkudmFyaWFudHNbMF0uYWxnZWJyYWljVHlwZSxcbiAgICAgICAgICB0eXBlc3BhY2VcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAodGFnID09PSAxKSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBgQ2FuJ3QgZGVzZXJpYWxpemUgYW4gb3B0aW9uIHR5cGUsIGNvdWxkbid0IGZpbmQgJHt0YWd9IHRhZ2A7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eS52YXJpYW50cy5sZW5ndGggPT0gMiAmJiB0eS52YXJpYW50c1swXS5uYW1lID09PSBcIm9rXCIgJiYgdHkudmFyaWFudHNbMV0ubmFtZSA9PT0gXCJlcnJcIikge1xuICAgICAgaWYgKHRhZyA9PT0gMCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IEFsZ2VicmFpY1R5cGUuZGVzZXJpYWxpemVWYWx1ZShcbiAgICAgICAgICByZWFkZXIsXG4gICAgICAgICAgdHkudmFyaWFudHNbMF0uYWxnZWJyYWljVHlwZSxcbiAgICAgICAgICB0eXBlc3BhY2VcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHsgb2s6IHZhbHVlIH07XG4gICAgICB9IGVsc2UgaWYgKHRhZyA9PT0gMSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IEFsZ2VicmFpY1R5cGUuZGVzZXJpYWxpemVWYWx1ZShcbiAgICAgICAgICByZWFkZXIsXG4gICAgICAgICAgdHkudmFyaWFudHNbMV0uYWxnZWJyYWljVHlwZSxcbiAgICAgICAgICB0eXBlc3BhY2VcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHsgZXJyOiB2YWx1ZSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgYENhbid0IGRlc2VyaWFsaXplIGEgcmVzdWx0IHR5cGUsIGNvdWxkbid0IGZpbmQgJHt0YWd9IHRhZ2A7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHZhcmlhbnQgPSB0eS52YXJpYW50c1t0YWddO1xuICAgICAgY29uc3QgdmFsdWUgPSBBbGdlYnJhaWNUeXBlLmRlc2VyaWFsaXplVmFsdWUoXG4gICAgICAgIHJlYWRlcixcbiAgICAgICAgdmFyaWFudC5hbGdlYnJhaWNUeXBlLFxuICAgICAgICB0eXBlc3BhY2VcbiAgICAgICk7XG4gICAgICByZXR1cm4geyB0YWc6IHZhcmlhbnQubmFtZSwgdmFsdWUgfTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9saWIvb3B0aW9uLnRzXG52YXIgT3B0aW9uID0ge1xuICBnZXRBbGdlYnJhaWNUeXBlKGlubmVyVHlwZSkge1xuICAgIHJldHVybiBBbGdlYnJhaWNUeXBlLlN1bSh7XG4gICAgICB2YXJpYW50czogW1xuICAgICAgICB7IG5hbWU6IFwic29tZVwiLCBhbGdlYnJhaWNUeXBlOiBpbm5lclR5cGUgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwibm9uZVwiLFxuICAgICAgICAgIGFsZ2VicmFpY1R5cGU6IEFsZ2VicmFpY1R5cGUuUHJvZHVjdCh7IGVsZW1lbnRzOiBbXSB9KVxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIHNyYy9saWIvcmVzdWx0LnRzXG52YXIgUmVzdWx0ID0ge1xuICBnZXRBbGdlYnJhaWNUeXBlKG9rVHlwZSwgZXJyVHlwZSkge1xuICAgIHJldHVybiBBbGdlYnJhaWNUeXBlLlN1bSh7XG4gICAgICB2YXJpYW50czogW1xuICAgICAgICB7IG5hbWU6IFwib2tcIiwgYWxnZWJyYWljVHlwZTogb2tUeXBlIH0sXG4gICAgICAgIHsgbmFtZTogXCJlcnJcIiwgYWxnZWJyYWljVHlwZTogZXJyVHlwZSB9XG4gICAgICBdXG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIHNyYy9saWIvc2NoZWR1bGVfYXQudHNcbnZhciBTY2hlZHVsZUF0ID0ge1xuICBpbnRlcnZhbCh2YWx1ZSkge1xuICAgIHJldHVybiBJbnRlcnZhbCh2YWx1ZSk7XG4gIH0sXG4gIHRpbWUodmFsdWUpIHtcbiAgICByZXR1cm4gVGltZSh2YWx1ZSk7XG4gIH0sXG4gIGdldEFsZ2VicmFpY1R5cGUoKSB7XG4gICAgcmV0dXJuIEFsZ2VicmFpY1R5cGUuU3VtKHtcbiAgICAgIHZhcmlhbnRzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcIkludGVydmFsXCIsXG4gICAgICAgICAgYWxnZWJyYWljVHlwZTogVGltZUR1cmF0aW9uLmdldEFsZ2VicmFpY1R5cGUoKVxuICAgICAgICB9LFxuICAgICAgICB7IG5hbWU6IFwiVGltZVwiLCBhbGdlYnJhaWNUeXBlOiBUaW1lc3RhbXAuZ2V0QWxnZWJyYWljVHlwZSgpIH1cbiAgICAgIF1cbiAgICB9KTtcbiAgfSxcbiAgaXNTY2hlZHVsZUF0KGFsZ2VicmFpY1R5cGUpIHtcbiAgICBpZiAoYWxnZWJyYWljVHlwZS50YWcgIT09IFwiU3VtXCIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgdmFyaWFudHMgPSBhbGdlYnJhaWNUeXBlLnZhbHVlLnZhcmlhbnRzO1xuICAgIGlmICh2YXJpYW50cy5sZW5ndGggIT09IDIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgaW50ZXJ2YWxWYXJpYW50ID0gdmFyaWFudHMuZmluZCgodikgPT4gdi5uYW1lID09PSBcIkludGVydmFsXCIpO1xuICAgIGNvbnN0IHRpbWVWYXJpYW50ID0gdmFyaWFudHMuZmluZCgodikgPT4gdi5uYW1lID09PSBcIlRpbWVcIik7XG4gICAgaWYgKCFpbnRlcnZhbFZhcmlhbnQgfHwgIXRpbWVWYXJpYW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBUaW1lRHVyYXRpb24uaXNUaW1lRHVyYXRpb24oaW50ZXJ2YWxWYXJpYW50LmFsZ2VicmFpY1R5cGUpICYmIFRpbWVzdGFtcC5pc1RpbWVzdGFtcCh0aW1lVmFyaWFudC5hbGdlYnJhaWNUeXBlKTtcbiAgfVxufTtcbnZhciBJbnRlcnZhbCA9IChtaWNyb3MpID0+ICh7XG4gIHRhZzogXCJJbnRlcnZhbFwiLFxuICB2YWx1ZTogbmV3IFRpbWVEdXJhdGlvbihtaWNyb3MpXG59KTtcbnZhciBUaW1lID0gKG1pY3Jvc1NpbmNlVW5peEVwb2NoKSA9PiAoe1xuICB0YWc6IFwiVGltZVwiLFxuICB2YWx1ZTogbmV3IFRpbWVzdGFtcChtaWNyb3NTaW5jZVVuaXhFcG9jaClcbn0pO1xudmFyIHNjaGVkdWxlX2F0X2RlZmF1bHQgPSBTY2hlZHVsZUF0O1xuXG4vLyBzcmMvbGliL3R5cGVfdXRpbC50c1xuZnVuY3Rpb24gc2V0KHgsIHQyKSB7XG4gIHJldHVybiB7IC4uLngsIC4uLnQyIH07XG59XG5cbi8vIHNyYy9saWIvdHlwZV9idWlsZGVycy50c1xudmFyIFR5cGVCdWlsZGVyID0gY2xhc3Mge1xuICAvKipcbiAgICogVGhlIFR5cGVTY3JpcHQgcGhhbnRvbSB0eXBlLiBUaGlzIGlzIG5vdCBzdG9yZWQgYXQgcnVudGltZSxcbiAgICogYnV0IGlzIHZpc2libGUgdG8gdGhlIGNvbXBpbGVyXG4gICAqL1xuICB0eXBlO1xuICAvKipcbiAgICogVGhlIFNwYWNldGltZURCIGFsZ2VicmFpYyB0eXBlIChydW7igJF0aW1lIHZhbHVlKS4gSW4gYWRkaXRpb24gdG8gc3RvcmluZ1xuICAgKiB0aGUgcnVudGltZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgYEFsZ2VicmFpY1R5cGVgLCBpdCBhbHNvIGNhcHR1cmVzXG4gICAqIHRoZSBUeXBlU2NyaXB0IHR5cGUgaW5mb3JtYXRpb24gb2YgdGhlIGBBbGdlYnJhaWNUeXBlYC4gVGhhdCBpcyB0byBzYXlcbiAgICogdGhlIHZhbHVlIGlzIG5vdCBtZXJlbHkgYW4gYEFsZ2VicmFpY1R5cGVgLCBidXQgaXMgY29uc3RydWN0ZWQgdG8gYmVcbiAgICogdGhlIGNvcnJlc3BvbmRpbmcgY29uY3JldGUgYEFsZ2VicmFpY1R5cGVgIGZvciB0aGUgVHlwZVNjcmlwdCB0eXBlIGBUeXBlYC5cbiAgICpcbiAgICogZS5nLiBgc3RyaW5nYCBjb3JyZXNwb25kcyB0byBgQWxnZWJyYWljVHlwZS5TdHJpbmdgXG4gICAqL1xuICBhbGdlYnJhaWNUeXBlO1xuICBjb25zdHJ1Y3RvcihhbGdlYnJhaWNUeXBlKSB7XG4gICAgdGhpcy5hbGdlYnJhaWNUeXBlID0gYWxnZWJyYWljVHlwZTtcbiAgfVxuICBvcHRpb25hbCgpIHtcbiAgICByZXR1cm4gbmV3IE9wdGlvbkJ1aWxkZXIodGhpcyk7XG4gIH1cbiAgc2VyaWFsaXplKHdyaXRlciwgdmFsdWUpIHtcbiAgICBBbGdlYnJhaWNUeXBlLnNlcmlhbGl6ZVZhbHVlKHdyaXRlciwgdGhpcy5hbGdlYnJhaWNUeXBlLCB2YWx1ZSk7XG4gIH1cbiAgZGVzZXJpYWxpemUocmVhZGVyKSB7XG4gICAgcmV0dXJuIEFsZ2VicmFpY1R5cGUuZGVzZXJpYWxpemVWYWx1ZShyZWFkZXIsIHRoaXMuYWxnZWJyYWljVHlwZSk7XG4gIH1cbn07XG52YXIgVThCdWlsZGVyID0gY2xhc3MgZXh0ZW5kcyBUeXBlQnVpbGRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKEFsZ2VicmFpY1R5cGUuVTgpO1xuICB9XG4gIGluZGV4KGFsZ29yaXRobSA9IFwiYnRyZWVcIikge1xuICAgIHJldHVybiBuZXcgVThDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaW5kZXhUeXBlOiBhbGdvcml0aG0gfSlcbiAgICApO1xuICB9XG4gIHVuaXF1ZSgpIHtcbiAgICByZXR1cm4gbmV3IFU4Q29sdW1uQnVpbGRlcih0aGlzLCBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzVW5pcXVlOiB0cnVlIH0pKTtcbiAgfVxuICBwcmltYXJ5S2V5KCkge1xuICAgIHJldHVybiBuZXcgVThDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNQcmltYXJ5S2V5OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBhdXRvSW5jKCkge1xuICAgIHJldHVybiBuZXcgVThDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNBdXRvSW5jcmVtZW50OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBVOENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBkZWZhdWx0VmFsdWU6IHZhbHVlIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IFU4Q29sdW1uQnVpbGRlcih0aGlzLCBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IG5hbWUgfSkpO1xuICB9XG59O1xudmFyIFUxNkJ1aWxkZXIgPSBjbGFzcyBleHRlbmRzIFR5cGVCdWlsZGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoQWxnZWJyYWljVHlwZS5VMTYpO1xuICB9XG4gIGluZGV4KGFsZ29yaXRobSA9IFwiYnRyZWVcIikge1xuICAgIHJldHVybiBuZXcgVTE2Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGluZGV4VHlwZTogYWxnb3JpdGhtIH0pXG4gICAgKTtcbiAgfVxuICB1bmlxdWUoKSB7XG4gICAgcmV0dXJuIG5ldyBVMTZDb2x1bW5CdWlsZGVyKHRoaXMsIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNVbmlxdWU6IHRydWUgfSkpO1xuICB9XG4gIHByaW1hcnlLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBVMTZDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNQcmltYXJ5S2V5OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBhdXRvSW5jKCkge1xuICAgIHJldHVybiBuZXcgVTE2Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzQXV0b0luY3JlbWVudDogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgVTE2Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGRlZmF1bHRWYWx1ZTogdmFsdWUgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgVTE2Q29sdW1uQnVpbGRlcih0aGlzLCBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IG5hbWUgfSkpO1xuICB9XG59O1xudmFyIFUzMkJ1aWxkZXIgPSBjbGFzcyBleHRlbmRzIFR5cGVCdWlsZGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoQWxnZWJyYWljVHlwZS5VMzIpO1xuICB9XG4gIGluZGV4KGFsZ29yaXRobSA9IFwiYnRyZWVcIikge1xuICAgIHJldHVybiBuZXcgVTMyQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGluZGV4VHlwZTogYWxnb3JpdGhtIH0pXG4gICAgKTtcbiAgfVxuICB1bmlxdWUoKSB7XG4gICAgcmV0dXJuIG5ldyBVMzJDb2x1bW5CdWlsZGVyKHRoaXMsIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNVbmlxdWU6IHRydWUgfSkpO1xuICB9XG4gIHByaW1hcnlLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBVMzJDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNQcmltYXJ5S2V5OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBhdXRvSW5jKCkge1xuICAgIHJldHVybiBuZXcgVTMyQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzQXV0b0luY3JlbWVudDogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgVTMyQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGRlZmF1bHRWYWx1ZTogdmFsdWUgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgVTMyQ29sdW1uQnVpbGRlcih0aGlzLCBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IG5hbWUgfSkpO1xuICB9XG59O1xudmFyIFU2NEJ1aWxkZXIgPSBjbGFzcyBleHRlbmRzIFR5cGVCdWlsZGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoQWxnZWJyYWljVHlwZS5VNjQpO1xuICB9XG4gIGluZGV4KGFsZ29yaXRobSA9IFwiYnRyZWVcIikge1xuICAgIHJldHVybiBuZXcgVTY0Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGluZGV4VHlwZTogYWxnb3JpdGhtIH0pXG4gICAgKTtcbiAgfVxuICB1bmlxdWUoKSB7XG4gICAgcmV0dXJuIG5ldyBVNjRDb2x1bW5CdWlsZGVyKHRoaXMsIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNVbmlxdWU6IHRydWUgfSkpO1xuICB9XG4gIHByaW1hcnlLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBVNjRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNQcmltYXJ5S2V5OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBhdXRvSW5jKCkge1xuICAgIHJldHVybiBuZXcgVTY0Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzQXV0b0luY3JlbWVudDogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgVTY0Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGRlZmF1bHRWYWx1ZTogdmFsdWUgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgVTY0Q29sdW1uQnVpbGRlcih0aGlzLCBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IG5hbWUgfSkpO1xuICB9XG59O1xudmFyIFUxMjhCdWlsZGVyID0gY2xhc3MgZXh0ZW5kcyBUeXBlQnVpbGRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKEFsZ2VicmFpY1R5cGUuVTEyOCk7XG4gIH1cbiAgaW5kZXgoYWxnb3JpdGhtID0gXCJidHJlZVwiKSB7XG4gICAgcmV0dXJuIG5ldyBVMTI4Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGluZGV4VHlwZTogYWxnb3JpdGhtIH0pXG4gICAgKTtcbiAgfVxuICB1bmlxdWUoKSB7XG4gICAgcmV0dXJuIG5ldyBVMTI4Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzVW5pcXVlOiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBwcmltYXJ5S2V5KCkge1xuICAgIHJldHVybiBuZXcgVTEyOENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc1ByaW1hcnlLZXk6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGF1dG9JbmMoKSB7XG4gICAgcmV0dXJuIG5ldyBVMTI4Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzQXV0b0luY3JlbWVudDogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgVTEyOENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBkZWZhdWx0VmFsdWU6IHZhbHVlIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IFUxMjhDb2x1bW5CdWlsZGVyKHRoaXMsIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgbmFtZSB9KSk7XG4gIH1cbn07XG52YXIgVTI1NkJ1aWxkZXIgPSBjbGFzcyBleHRlbmRzIFR5cGVCdWlsZGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoQWxnZWJyYWljVHlwZS5VMjU2KTtcbiAgfVxuICBpbmRleChhbGdvcml0aG0gPSBcImJ0cmVlXCIpIHtcbiAgICByZXR1cm4gbmV3IFUyNTZDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaW5kZXhUeXBlOiBhbGdvcml0aG0gfSlcbiAgICApO1xuICB9XG4gIHVuaXF1ZSgpIHtcbiAgICByZXR1cm4gbmV3IFUyNTZDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNVbmlxdWU6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIHByaW1hcnlLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBVMjU2Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzUHJpbWFyeUtleTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgYXV0b0luYygpIHtcbiAgICByZXR1cm4gbmV3IFUyNTZDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNBdXRvSW5jcmVtZW50OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBVMjU2Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGRlZmF1bHRWYWx1ZTogdmFsdWUgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgVTI1NkNvbHVtbkJ1aWxkZXIodGhpcywgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBuYW1lIH0pKTtcbiAgfVxufTtcbnZhciBJOEJ1aWxkZXIgPSBjbGFzcyBleHRlbmRzIFR5cGVCdWlsZGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoQWxnZWJyYWljVHlwZS5JOCk7XG4gIH1cbiAgaW5kZXgoYWxnb3JpdGhtID0gXCJidHJlZVwiKSB7XG4gICAgcmV0dXJuIG5ldyBJOENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpbmRleFR5cGU6IGFsZ29yaXRobSB9KVxuICAgICk7XG4gIH1cbiAgdW5pcXVlKCkge1xuICAgIHJldHVybiBuZXcgSThDb2x1bW5CdWlsZGVyKHRoaXMsIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNVbmlxdWU6IHRydWUgfSkpO1xuICB9XG4gIHByaW1hcnlLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBJOENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc1ByaW1hcnlLZXk6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGF1dG9JbmMoKSB7XG4gICAgcmV0dXJuIG5ldyBJOENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc0F1dG9JbmNyZW1lbnQ6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IEk4Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGRlZmF1bHRWYWx1ZTogdmFsdWUgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgSThDb2x1bW5CdWlsZGVyKHRoaXMsIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgbmFtZSB9KSk7XG4gIH1cbn07XG52YXIgSTE2QnVpbGRlciA9IGNsYXNzIGV4dGVuZHMgVHlwZUJ1aWxkZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihBbGdlYnJhaWNUeXBlLkkxNik7XG4gIH1cbiAgaW5kZXgoYWxnb3JpdGhtID0gXCJidHJlZVwiKSB7XG4gICAgcmV0dXJuIG5ldyBJMTZDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaW5kZXhUeXBlOiBhbGdvcml0aG0gfSlcbiAgICApO1xuICB9XG4gIHVuaXF1ZSgpIHtcbiAgICByZXR1cm4gbmV3IEkxNkNvbHVtbkJ1aWxkZXIodGhpcywgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc1VuaXF1ZTogdHJ1ZSB9KSk7XG4gIH1cbiAgcHJpbWFyeUtleSgpIHtcbiAgICByZXR1cm4gbmV3IEkxNkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc1ByaW1hcnlLZXk6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGF1dG9JbmMoKSB7XG4gICAgcmV0dXJuIG5ldyBJMTZDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNBdXRvSW5jcmVtZW50OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBJMTZDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgZGVmYXVsdFZhbHVlOiB2YWx1ZSB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBJMTZDb2x1bW5CdWlsZGVyKHRoaXMsIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgbmFtZSB9KSk7XG4gIH1cbn07XG52YXIgSTMyQnVpbGRlciA9IGNsYXNzIGV4dGVuZHMgVHlwZUJ1aWxkZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihBbGdlYnJhaWNUeXBlLkkzMik7XG4gIH1cbiAgaW5kZXgoYWxnb3JpdGhtID0gXCJidHJlZVwiKSB7XG4gICAgcmV0dXJuIG5ldyBJMzJDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaW5kZXhUeXBlOiBhbGdvcml0aG0gfSlcbiAgICApO1xuICB9XG4gIHVuaXF1ZSgpIHtcbiAgICByZXR1cm4gbmV3IEkzMkNvbHVtbkJ1aWxkZXIodGhpcywgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc1VuaXF1ZTogdHJ1ZSB9KSk7XG4gIH1cbiAgcHJpbWFyeUtleSgpIHtcbiAgICByZXR1cm4gbmV3IEkzMkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc1ByaW1hcnlLZXk6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGF1dG9JbmMoKSB7XG4gICAgcmV0dXJuIG5ldyBJMzJDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNBdXRvSW5jcmVtZW50OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBJMzJDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgZGVmYXVsdFZhbHVlOiB2YWx1ZSB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBJMzJDb2x1bW5CdWlsZGVyKHRoaXMsIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgbmFtZSB9KSk7XG4gIH1cbn07XG52YXIgSTY0QnVpbGRlciA9IGNsYXNzIGV4dGVuZHMgVHlwZUJ1aWxkZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihBbGdlYnJhaWNUeXBlLkk2NCk7XG4gIH1cbiAgaW5kZXgoYWxnb3JpdGhtID0gXCJidHJlZVwiKSB7XG4gICAgcmV0dXJuIG5ldyBJNjRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaW5kZXhUeXBlOiBhbGdvcml0aG0gfSlcbiAgICApO1xuICB9XG4gIHVuaXF1ZSgpIHtcbiAgICByZXR1cm4gbmV3IEk2NENvbHVtbkJ1aWxkZXIodGhpcywgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc1VuaXF1ZTogdHJ1ZSB9KSk7XG4gIH1cbiAgcHJpbWFyeUtleSgpIHtcbiAgICByZXR1cm4gbmV3IEk2NENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc1ByaW1hcnlLZXk6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGF1dG9JbmMoKSB7XG4gICAgcmV0dXJuIG5ldyBJNjRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNBdXRvSW5jcmVtZW50OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBJNjRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgZGVmYXVsdFZhbHVlOiB2YWx1ZSB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBJNjRDb2x1bW5CdWlsZGVyKHRoaXMsIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgbmFtZSB9KSk7XG4gIH1cbn07XG52YXIgSTEyOEJ1aWxkZXIgPSBjbGFzcyBleHRlbmRzIFR5cGVCdWlsZGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoQWxnZWJyYWljVHlwZS5JMTI4KTtcbiAgfVxuICBpbmRleChhbGdvcml0aG0gPSBcImJ0cmVlXCIpIHtcbiAgICByZXR1cm4gbmV3IEkxMjhDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaW5kZXhUeXBlOiBhbGdvcml0aG0gfSlcbiAgICApO1xuICB9XG4gIHVuaXF1ZSgpIHtcbiAgICByZXR1cm4gbmV3IEkxMjhDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNVbmlxdWU6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIHByaW1hcnlLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBJMTI4Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzUHJpbWFyeUtleTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgYXV0b0luYygpIHtcbiAgICByZXR1cm4gbmV3IEkxMjhDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNBdXRvSW5jcmVtZW50OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBJMTI4Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGRlZmF1bHRWYWx1ZTogdmFsdWUgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgSTEyOENvbHVtbkJ1aWxkZXIodGhpcywgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBuYW1lIH0pKTtcbiAgfVxufTtcbnZhciBJMjU2QnVpbGRlciA9IGNsYXNzIGV4dGVuZHMgVHlwZUJ1aWxkZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihBbGdlYnJhaWNUeXBlLkkyNTYpO1xuICB9XG4gIGluZGV4KGFsZ29yaXRobSA9IFwiYnRyZWVcIikge1xuICAgIHJldHVybiBuZXcgSTI1NkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpbmRleFR5cGU6IGFsZ29yaXRobSB9KVxuICAgICk7XG4gIH1cbiAgdW5pcXVlKCkge1xuICAgIHJldHVybiBuZXcgSTI1NkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc1VuaXF1ZTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgcHJpbWFyeUtleSgpIHtcbiAgICByZXR1cm4gbmV3IEkyNTZDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNQcmltYXJ5S2V5OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBhdXRvSW5jKCkge1xuICAgIHJldHVybiBuZXcgSTI1NkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc0F1dG9JbmNyZW1lbnQ6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IEkyNTZDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgZGVmYXVsdFZhbHVlOiB2YWx1ZSB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBJMjU2Q29sdW1uQnVpbGRlcih0aGlzLCBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IG5hbWUgfSkpO1xuICB9XG59O1xudmFyIEYzMkJ1aWxkZXIgPSBjbGFzcyBleHRlbmRzIFR5cGVCdWlsZGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoQWxnZWJyYWljVHlwZS5GMzIpO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IEYzMkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBkZWZhdWx0VmFsdWU6IHZhbHVlIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IEYzMkNvbHVtbkJ1aWxkZXIodGhpcywgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBuYW1lIH0pKTtcbiAgfVxufTtcbnZhciBGNjRCdWlsZGVyID0gY2xhc3MgZXh0ZW5kcyBUeXBlQnVpbGRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKEFsZ2VicmFpY1R5cGUuRjY0KTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBGNjRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgZGVmYXVsdFZhbHVlOiB2YWx1ZSB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBGNjRDb2x1bW5CdWlsZGVyKHRoaXMsIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgbmFtZSB9KSk7XG4gIH1cbn07XG52YXIgQm9vbEJ1aWxkZXIgPSBjbGFzcyBleHRlbmRzIFR5cGVCdWlsZGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoQWxnZWJyYWljVHlwZS5Cb29sKTtcbiAgfVxuICBpbmRleChhbGdvcml0aG0gPSBcImJ0cmVlXCIpIHtcbiAgICByZXR1cm4gbmV3IEJvb2xDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaW5kZXhUeXBlOiBhbGdvcml0aG0gfSlcbiAgICApO1xuICB9XG4gIHVuaXF1ZSgpIHtcbiAgICByZXR1cm4gbmV3IEJvb2xDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNVbmlxdWU6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIHByaW1hcnlLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBCb29sQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzUHJpbWFyeUtleTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgQm9vbENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBkZWZhdWx0VmFsdWU6IHZhbHVlIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IEJvb2xDb2x1bW5CdWlsZGVyKHRoaXMsIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgbmFtZSB9KSk7XG4gIH1cbn07XG52YXIgU3RyaW5nQnVpbGRlciA9IGNsYXNzIGV4dGVuZHMgVHlwZUJ1aWxkZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihBbGdlYnJhaWNUeXBlLlN0cmluZyk7XG4gIH1cbiAgaW5kZXgoYWxnb3JpdGhtID0gXCJidHJlZVwiKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJpbmdDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaW5kZXhUeXBlOiBhbGdvcml0aG0gfSlcbiAgICApO1xuICB9XG4gIHVuaXF1ZSgpIHtcbiAgICByZXR1cm4gbmV3IFN0cmluZ0NvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc1VuaXF1ZTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgcHJpbWFyeUtleSgpIHtcbiAgICByZXR1cm4gbmV3IFN0cmluZ0NvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc1ByaW1hcnlLZXk6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IFN0cmluZ0NvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBkZWZhdWx0VmFsdWU6IHZhbHVlIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IFN0cmluZ0NvbHVtbkJ1aWxkZXIodGhpcywgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBuYW1lIH0pKTtcbiAgfVxufTtcbnZhciBBcnJheUJ1aWxkZXIgPSBjbGFzcyBleHRlbmRzIFR5cGVCdWlsZGVyIHtcbiAgZWxlbWVudDtcbiAgY29uc3RydWN0b3IoZWxlbWVudCkge1xuICAgIHN1cGVyKEFsZ2VicmFpY1R5cGUuQXJyYXkoZWxlbWVudC5hbGdlYnJhaWNUeXBlKSk7XG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBBcnJheUNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLmVsZW1lbnQsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGRlZmF1bHRWYWx1ZTogdmFsdWUgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgQXJyYXlDb2x1bW5CdWlsZGVyKHRoaXMuZWxlbWVudCwgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBuYW1lIH0pKTtcbiAgfVxufTtcbnZhciBCeXRlQXJyYXlCdWlsZGVyID0gY2xhc3MgZXh0ZW5kcyBUeXBlQnVpbGRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKEFsZ2VicmFpY1R5cGUuQXJyYXkoQWxnZWJyYWljVHlwZS5VOCkpO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IEJ5dGVBcnJheUNvbHVtbkJ1aWxkZXIoXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGRlZmF1bHRWYWx1ZTogdmFsdWUgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgQnl0ZUFycmF5Q29sdW1uQnVpbGRlcihzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IG5hbWUgfSkpO1xuICB9XG59O1xudmFyIE9wdGlvbkJ1aWxkZXIgPSBjbGFzcyBleHRlbmRzIFR5cGVCdWlsZGVyIHtcbiAgdmFsdWU7XG4gIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgc3VwZXIoT3B0aW9uLmdldEFsZ2VicmFpY1R5cGUodmFsdWUuYWxnZWJyYWljVHlwZSkpO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBPcHRpb25Db2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgZGVmYXVsdFZhbHVlOiB2YWx1ZSB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBPcHRpb25Db2x1bW5CdWlsZGVyKHRoaXMsIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgbmFtZSB9KSk7XG4gIH1cbn07XG52YXIgUHJvZHVjdEJ1aWxkZXIgPSBjbGFzcyBleHRlbmRzIFR5cGVCdWlsZGVyIHtcbiAgdHlwZU5hbWU7XG4gIGVsZW1lbnRzO1xuICBjb25zdHJ1Y3RvcihlbGVtZW50cywgbmFtZSkge1xuICAgIGZ1bmN0aW9uIGVsZW1lbnRzQXJyYXlGcm9tRWxlbWVudHNPYmoob2JqKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5tYXAoKGtleSkgPT4gKHtcbiAgICAgICAgbmFtZToga2V5LFxuICAgICAgICAvLyBMYXppbHkgcmVzb2x2ZSB0aGUgdW5kZXJseWluZyBvYmplY3QncyBhbGdlYnJhaWNUeXBlLlxuICAgICAgICAvLyBUaGlzIHdpbGwgY2FsbCBvYmpba2V5XS5hbGdlYnJhaWNUeXBlIG9ubHkgd2hlbiBzb21lb25lXG4gICAgICAgIC8vIGFjdHVhbGx5IHJlYWRzIHRoaXMgcHJvcGVydHkuXG4gICAgICAgIGdldCBhbGdlYnJhaWNUeXBlKCkge1xuICAgICAgICAgIHJldHVybiBvYmpba2V5XS5hbGdlYnJhaWNUeXBlO1xuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgfVxuICAgIHN1cGVyKFxuICAgICAgQWxnZWJyYWljVHlwZS5Qcm9kdWN0KHtcbiAgICAgICAgZWxlbWVudHM6IGVsZW1lbnRzQXJyYXlGcm9tRWxlbWVudHNPYmooZWxlbWVudHMpXG4gICAgICB9KVxuICAgICk7XG4gICAgdGhpcy50eXBlTmFtZSA9IG5hbWU7XG4gICAgdGhpcy5lbGVtZW50cyA9IGVsZW1lbnRzO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IFByb2R1Y3RDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgZGVmYXVsdFZhbHVlOiB2YWx1ZSB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9kdWN0Q29sdW1uQnVpbGRlcih0aGlzLCBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IG5hbWUgfSkpO1xuICB9XG59O1xudmFyIFJlc3VsdEJ1aWxkZXIgPSBjbGFzcyBleHRlbmRzIFR5cGVCdWlsZGVyIHtcbiAgb2s7XG4gIGVycjtcbiAgY29uc3RydWN0b3Iob2ssIGVycikge1xuICAgIHN1cGVyKFJlc3VsdC5nZXRBbGdlYnJhaWNUeXBlKG9rLmFsZ2VicmFpY1R5cGUsIGVyci5hbGdlYnJhaWNUeXBlKSk7XG4gICAgdGhpcy5vayA9IG9rO1xuICAgIHRoaXMuZXJyID0gZXJyO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IFJlc3VsdENvbHVtbkJ1aWxkZXIodGhpcywgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBkZWZhdWx0VmFsdWU6IHZhbHVlIH0pKTtcbiAgfVxufTtcbnZhciBVbml0QnVpbGRlciA9IGNsYXNzIGV4dGVuZHMgVHlwZUJ1aWxkZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcih7IHRhZzogXCJQcm9kdWN0XCIsIHZhbHVlOiB7IGVsZW1lbnRzOiBbXSB9IH0pO1xuICB9XG59O1xudmFyIFJvd0J1aWxkZXIgPSBjbGFzcyBleHRlbmRzIFR5cGVCdWlsZGVyIHtcbiAgcm93O1xuICB0eXBlTmFtZTtcbiAgY29uc3RydWN0b3Iocm93LCBuYW1lKSB7XG4gICAgY29uc3QgbWFwcGVkUm93ID0gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgT2JqZWN0LmVudHJpZXMocm93KS5tYXAoKFtjb2xOYW1lLCBidWlsZGVyXSkgPT4gW1xuICAgICAgICBjb2xOYW1lLFxuICAgICAgICBidWlsZGVyIGluc3RhbmNlb2YgQ29sdW1uQnVpbGRlciA/IGJ1aWxkZXIgOiBuZXcgQ29sdW1uQnVpbGRlcihidWlsZGVyLCB7fSlcbiAgICAgIF0pXG4gICAgKTtcbiAgICBjb25zdCBlbGVtZW50cyA9IE9iamVjdC5rZXlzKG1hcHBlZFJvdykubWFwKChuYW1lMikgPT4gKHtcbiAgICAgIG5hbWU6IG5hbWUyLFxuICAgICAgZ2V0IGFsZ2VicmFpY1R5cGUoKSB7XG4gICAgICAgIHJldHVybiBtYXBwZWRSb3dbbmFtZTJdLnR5cGVCdWlsZGVyLmFsZ2VicmFpY1R5cGU7XG4gICAgICB9XG4gICAgfSkpO1xuICAgIHN1cGVyKEFsZ2VicmFpY1R5cGUuUHJvZHVjdCh7IGVsZW1lbnRzIH0pKTtcbiAgICB0aGlzLnJvdyA9IG1hcHBlZFJvdztcbiAgICB0aGlzLnR5cGVOYW1lID0gbmFtZTtcbiAgfVxufTtcbnZhciBTdW1CdWlsZGVySW1wbCA9IGNsYXNzIGV4dGVuZHMgVHlwZUJ1aWxkZXIge1xuICB2YXJpYW50cztcbiAgdHlwZU5hbWU7XG4gIGNvbnN0cnVjdG9yKHZhcmlhbnRzLCBuYW1lKSB7XG4gICAgZnVuY3Rpb24gdmFyaWFudHNBcnJheUZyb21WYXJpYW50c09iaih2YXJpYW50czIpIHtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyh2YXJpYW50czIpLm1hcCgoa2V5KSA9PiAoe1xuICAgICAgICBuYW1lOiBrZXksXG4gICAgICAgIC8vIExhemlseSByZXNvbHZlIHRoZSB1bmRlcmx5aW5nIG9iamVjdCdzIGFsZ2VicmFpY1R5cGUuXG4gICAgICAgIC8vIFRoaXMgd2lsbCBjYWxsIG9ialtrZXldLmFsZ2VicmFpY1R5cGUgb25seSB3aGVuIHNvbWVvbmVcbiAgICAgICAgLy8gYWN0dWFsbHkgcmVhZHMgdGhpcyBwcm9wZXJ0eS5cbiAgICAgICAgZ2V0IGFsZ2VicmFpY1R5cGUoKSB7XG4gICAgICAgICAgcmV0dXJuIHZhcmlhbnRzMltrZXldLmFsZ2VicmFpY1R5cGU7XG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICB9XG4gICAgc3VwZXIoXG4gICAgICBBbGdlYnJhaWNUeXBlLlN1bSh7XG4gICAgICAgIHZhcmlhbnRzOiB2YXJpYW50c0FycmF5RnJvbVZhcmlhbnRzT2JqKHZhcmlhbnRzKVxuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMudmFyaWFudHMgPSB2YXJpYW50cztcbiAgICB0aGlzLnR5cGVOYW1lID0gbmFtZTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh2YXJpYW50cykpIHtcbiAgICAgIGNvbnN0IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhcmlhbnRzLCBrZXkpO1xuICAgICAgY29uc3QgaXNBY2Nlc3NvciA9ICEhZGVzYyAmJiAodHlwZW9mIGRlc2MuZ2V0ID09PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIGRlc2Muc2V0ID09PSBcImZ1bmN0aW9uXCIpO1xuICAgICAgbGV0IGlzVW5pdDIgPSBmYWxzZTtcbiAgICAgIGlmICghaXNBY2Nlc3Nvcikge1xuICAgICAgICBjb25zdCB2YXJpYW50ID0gdmFyaWFudHNba2V5XTtcbiAgICAgICAgaXNVbml0MiA9IHZhcmlhbnQgaW5zdGFuY2VvZiBVbml0QnVpbGRlcjtcbiAgICAgIH1cbiAgICAgIGlmIChpc1VuaXQyKSB7XG4gICAgICAgIGNvbnN0IGNvbnN0YW50ID0gdGhpcy5jcmVhdGUoa2V5KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwge1xuICAgICAgICAgIHZhbHVlOiBjb25zdGFudCxcbiAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZm4gPSAoKHZhbHVlKSA9PiB0aGlzLmNyZWF0ZShrZXksIHZhbHVlKSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBrZXksIHtcbiAgICAgICAgICB2YWx1ZTogZm4sXG4gICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY3JlYXRlKHRhZywgdmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHZvaWQgMCA/IHsgdGFnIH0gOiB7IHRhZywgdmFsdWUgfTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBTdW1Db2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgZGVmYXVsdFZhbHVlOiB2YWx1ZSB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBTdW1Db2x1bW5CdWlsZGVyKHRoaXMsIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgbmFtZSB9KSk7XG4gIH1cbn07XG52YXIgU3VtQnVpbGRlciA9IFN1bUJ1aWxkZXJJbXBsO1xudmFyIFNpbXBsZVN1bUJ1aWxkZXJJbXBsID0gY2xhc3MgZXh0ZW5kcyBTdW1CdWlsZGVySW1wbCB7XG4gIGluZGV4KGFsZ29yaXRobSA9IFwiYnRyZWVcIikge1xuICAgIHJldHVybiBuZXcgU2ltcGxlU3VtQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGluZGV4VHlwZTogYWxnb3JpdGhtIH0pXG4gICAgKTtcbiAgfVxuICBwcmltYXJ5S2V5KCkge1xuICAgIHJldHVybiBuZXcgU2ltcGxlU3VtQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzUHJpbWFyeUtleTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbn07XG52YXIgU2ltcGxlU3VtQnVpbGRlciA9IFNpbXBsZVN1bUJ1aWxkZXJJbXBsO1xudmFyIFNjaGVkdWxlQXRCdWlsZGVyID0gY2xhc3MgZXh0ZW5kcyBUeXBlQnVpbGRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKHNjaGVkdWxlX2F0X2RlZmF1bHQuZ2V0QWxnZWJyYWljVHlwZSgpKTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBTY2hlZHVsZUF0Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGRlZmF1bHRWYWx1ZTogdmFsdWUgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgU2NoZWR1bGVBdENvbHVtbkJ1aWxkZXIodGhpcywgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBuYW1lIH0pKTtcbiAgfVxufTtcbnZhciBJZGVudGl0eUJ1aWxkZXIgPSBjbGFzcyBleHRlbmRzIFR5cGVCdWlsZGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoSWRlbnRpdHkuZ2V0QWxnZWJyYWljVHlwZSgpKTtcbiAgfVxuICBpbmRleChhbGdvcml0aG0gPSBcImJ0cmVlXCIpIHtcbiAgICByZXR1cm4gbmV3IElkZW50aXR5Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGluZGV4VHlwZTogYWxnb3JpdGhtIH0pXG4gICAgKTtcbiAgfVxuICB1bmlxdWUoKSB7XG4gICAgcmV0dXJuIG5ldyBJZGVudGl0eUNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc1VuaXF1ZTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgcHJpbWFyeUtleSgpIHtcbiAgICByZXR1cm4gbmV3IElkZW50aXR5Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzUHJpbWFyeUtleTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgYXV0b0luYygpIHtcbiAgICByZXR1cm4gbmV3IElkZW50aXR5Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzQXV0b0luY3JlbWVudDogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgSWRlbnRpdHlDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgZGVmYXVsdFZhbHVlOiB2YWx1ZSB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBJZGVudGl0eUNvbHVtbkJ1aWxkZXIodGhpcywgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBuYW1lIH0pKTtcbiAgfVxufTtcbnZhciBDb25uZWN0aW9uSWRCdWlsZGVyID0gY2xhc3MgZXh0ZW5kcyBUeXBlQnVpbGRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKENvbm5lY3Rpb25JZC5nZXRBbGdlYnJhaWNUeXBlKCkpO1xuICB9XG4gIGluZGV4KGFsZ29yaXRobSA9IFwiYnRyZWVcIikge1xuICAgIHJldHVybiBuZXcgQ29ubmVjdGlvbklkQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGluZGV4VHlwZTogYWxnb3JpdGhtIH0pXG4gICAgKTtcbiAgfVxuICB1bmlxdWUoKSB7XG4gICAgcmV0dXJuIG5ldyBDb25uZWN0aW9uSWRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNVbmlxdWU6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIHByaW1hcnlLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBDb25uZWN0aW9uSWRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNQcmltYXJ5S2V5OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBhdXRvSW5jKCkge1xuICAgIHJldHVybiBuZXcgQ29ubmVjdGlvbklkQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzQXV0b0luY3JlbWVudDogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgQ29ubmVjdGlvbklkQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGRlZmF1bHRWYWx1ZTogdmFsdWUgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgQ29ubmVjdGlvbklkQ29sdW1uQnVpbGRlcih0aGlzLCBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IG5hbWUgfSkpO1xuICB9XG59O1xudmFyIFRpbWVzdGFtcEJ1aWxkZXIgPSBjbGFzcyBleHRlbmRzIFR5cGVCdWlsZGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoVGltZXN0YW1wLmdldEFsZ2VicmFpY1R5cGUoKSk7XG4gIH1cbiAgaW5kZXgoYWxnb3JpdGhtID0gXCJidHJlZVwiKSB7XG4gICAgcmV0dXJuIG5ldyBUaW1lc3RhbXBDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaW5kZXhUeXBlOiBhbGdvcml0aG0gfSlcbiAgICApO1xuICB9XG4gIHVuaXF1ZSgpIHtcbiAgICByZXR1cm4gbmV3IFRpbWVzdGFtcENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc1VuaXF1ZTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgcHJpbWFyeUtleSgpIHtcbiAgICByZXR1cm4gbmV3IFRpbWVzdGFtcENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc1ByaW1hcnlLZXk6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGF1dG9JbmMoKSB7XG4gICAgcmV0dXJuIG5ldyBUaW1lc3RhbXBDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNBdXRvSW5jcmVtZW50OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBUaW1lc3RhbXBDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgZGVmYXVsdFZhbHVlOiB2YWx1ZSB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBUaW1lc3RhbXBDb2x1bW5CdWlsZGVyKHRoaXMsIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgbmFtZSB9KSk7XG4gIH1cbn07XG52YXIgVGltZUR1cmF0aW9uQnVpbGRlciA9IGNsYXNzIGV4dGVuZHMgVHlwZUJ1aWxkZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihUaW1lRHVyYXRpb24uZ2V0QWxnZWJyYWljVHlwZSgpKTtcbiAgfVxuICBpbmRleChhbGdvcml0aG0gPSBcImJ0cmVlXCIpIHtcbiAgICByZXR1cm4gbmV3IFRpbWVEdXJhdGlvbkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpbmRleFR5cGU6IGFsZ29yaXRobSB9KVxuICAgICk7XG4gIH1cbiAgdW5pcXVlKCkge1xuICAgIHJldHVybiBuZXcgVGltZUR1cmF0aW9uQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzVW5pcXVlOiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBwcmltYXJ5S2V5KCkge1xuICAgIHJldHVybiBuZXcgVGltZUR1cmF0aW9uQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzUHJpbWFyeUtleTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgYXV0b0luYygpIHtcbiAgICByZXR1cm4gbmV3IFRpbWVEdXJhdGlvbkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc0F1dG9JbmNyZW1lbnQ6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IFRpbWVEdXJhdGlvbkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBkZWZhdWx0VmFsdWU6IHZhbHVlIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IFRpbWVEdXJhdGlvbkNvbHVtbkJ1aWxkZXIodGhpcywgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBuYW1lIH0pKTtcbiAgfVxufTtcbnZhciBVdWlkQnVpbGRlciA9IGNsYXNzIGV4dGVuZHMgVHlwZUJ1aWxkZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihVdWlkLmdldEFsZ2VicmFpY1R5cGUoKSk7XG4gIH1cbiAgaW5kZXgoYWxnb3JpdGhtID0gXCJidHJlZVwiKSB7XG4gICAgcmV0dXJuIG5ldyBVdWlkQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGluZGV4VHlwZTogYWxnb3JpdGhtIH0pXG4gICAgKTtcbiAgfVxuICB1bmlxdWUoKSB7XG4gICAgcmV0dXJuIG5ldyBVdWlkQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzVW5pcXVlOiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBwcmltYXJ5S2V5KCkge1xuICAgIHJldHVybiBuZXcgVXVpZENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc1ByaW1hcnlLZXk6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGF1dG9JbmMoKSB7XG4gICAgcmV0dXJuIG5ldyBVdWlkQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzQXV0b0luY3JlbWVudDogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgVXVpZENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBkZWZhdWx0VmFsdWU6IHZhbHVlIH0pXG4gICAgKTtcbiAgfVxufTtcbnZhciBkZWZhdWx0TWV0YWRhdGEgPSB7fTtcbnZhciBDb2x1bW5CdWlsZGVyID0gY2xhc3Mge1xuICB0eXBlQnVpbGRlcjtcbiAgY29sdW1uTWV0YWRhdGE7XG4gIGNvbnN0cnVjdG9yKHR5cGVCdWlsZGVyLCBtZXRhZGF0YSkge1xuICAgIHRoaXMudHlwZUJ1aWxkZXIgPSB0eXBlQnVpbGRlcjtcbiAgICB0aGlzLmNvbHVtbk1ldGFkYXRhID0gbWV0YWRhdGE7XG4gIH1cbiAgc2VyaWFsaXplKHdyaXRlciwgdmFsdWUpIHtcbiAgICBBbGdlYnJhaWNUeXBlLnNlcmlhbGl6ZVZhbHVlKHdyaXRlciwgdGhpcy50eXBlQnVpbGRlci5hbGdlYnJhaWNUeXBlLCB2YWx1ZSk7XG4gIH1cbiAgZGVzZXJpYWxpemUocmVhZGVyKSB7XG4gICAgcmV0dXJuIEFsZ2VicmFpY1R5cGUuZGVzZXJpYWxpemVWYWx1ZShcbiAgICAgIHJlYWRlcixcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIuYWxnZWJyYWljVHlwZVxuICAgICk7XG4gIH1cbn07XG52YXIgVThDb2x1bW5CdWlsZGVyID0gY2xhc3MgX1U4Q29sdW1uQnVpbGRlciBleHRlbmRzIENvbHVtbkJ1aWxkZXIge1xuICBpbmRleChhbGdvcml0aG0gPSBcImJ0cmVlXCIpIHtcbiAgICByZXR1cm4gbmV3IF9VOENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaW5kZXhUeXBlOiBhbGdvcml0aG0gfSlcbiAgICApO1xuICB9XG4gIHVuaXF1ZSgpIHtcbiAgICByZXR1cm4gbmV3IF9VOENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNVbmlxdWU6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIHByaW1hcnlLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBfVThDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzUHJpbWFyeUtleTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgYXV0b0luYygpIHtcbiAgICByZXR1cm4gbmV3IF9VOENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNBdXRvSW5jcmVtZW50OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBfVThDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7XG4gICAgICAgIGRlZmF1bHRWYWx1ZTogdmFsdWVcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IF9VOENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgbmFtZSB9KVxuICAgICk7XG4gIH1cbn07XG52YXIgVTE2Q29sdW1uQnVpbGRlciA9IGNsYXNzIF9VMTZDb2x1bW5CdWlsZGVyIGV4dGVuZHMgQ29sdW1uQnVpbGRlciB7XG4gIGluZGV4KGFsZ29yaXRobSA9IFwiYnRyZWVcIikge1xuICAgIHJldHVybiBuZXcgX1UxNkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaW5kZXhUeXBlOiBhbGdvcml0aG0gfSlcbiAgICApO1xuICB9XG4gIHVuaXF1ZSgpIHtcbiAgICByZXR1cm4gbmV3IF9VMTZDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzVW5pcXVlOiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBwcmltYXJ5S2V5KCkge1xuICAgIHJldHVybiBuZXcgX1UxNkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNQcmltYXJ5S2V5OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBhdXRvSW5jKCkge1xuICAgIHJldHVybiBuZXcgX1UxNkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNBdXRvSW5jcmVtZW50OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBfVTE2Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwge1xuICAgICAgICBkZWZhdWx0VmFsdWU6IHZhbHVlXG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBfVTE2Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBuYW1lIH0pXG4gICAgKTtcbiAgfVxufTtcbnZhciBVMzJDb2x1bW5CdWlsZGVyID0gY2xhc3MgX1UzMkNvbHVtbkJ1aWxkZXIgZXh0ZW5kcyBDb2x1bW5CdWlsZGVyIHtcbiAgaW5kZXgoYWxnb3JpdGhtID0gXCJidHJlZVwiKSB7XG4gICAgcmV0dXJuIG5ldyBfVTMyQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpbmRleFR5cGU6IGFsZ29yaXRobSB9KVxuICAgICk7XG4gIH1cbiAgdW5pcXVlKCkge1xuICAgIHJldHVybiBuZXcgX1UzMkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNVbmlxdWU6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIHByaW1hcnlLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBfVTMyQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc1ByaW1hcnlLZXk6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGF1dG9JbmMoKSB7XG4gICAgcmV0dXJuIG5ldyBfVTMyQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc0F1dG9JbmNyZW1lbnQ6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IF9VMzJDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7XG4gICAgICAgIGRlZmF1bHRWYWx1ZTogdmFsdWVcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IF9VMzJDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IG5hbWUgfSlcbiAgICApO1xuICB9XG59O1xudmFyIFU2NENvbHVtbkJ1aWxkZXIgPSBjbGFzcyBfVTY0Q29sdW1uQnVpbGRlciBleHRlbmRzIENvbHVtbkJ1aWxkZXIge1xuICBpbmRleChhbGdvcml0aG0gPSBcImJ0cmVlXCIpIHtcbiAgICByZXR1cm4gbmV3IF9VNjRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGluZGV4VHlwZTogYWxnb3JpdGhtIH0pXG4gICAgKTtcbiAgfVxuICB1bmlxdWUoKSB7XG4gICAgcmV0dXJuIG5ldyBfVTY0Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc1VuaXF1ZTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgcHJpbWFyeUtleSgpIHtcbiAgICByZXR1cm4gbmV3IF9VNjRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzUHJpbWFyeUtleTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgYXV0b0luYygpIHtcbiAgICByZXR1cm4gbmV3IF9VNjRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzQXV0b0luY3JlbWVudDogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgX1U2NENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHtcbiAgICAgICAgZGVmYXVsdFZhbHVlOiB2YWx1ZVxuICAgICAgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgX1U2NENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgbmFtZSB9KVxuICAgICk7XG4gIH1cbn07XG52YXIgVTEyOENvbHVtbkJ1aWxkZXIgPSBjbGFzcyBfVTEyOENvbHVtbkJ1aWxkZXIgZXh0ZW5kcyBDb2x1bW5CdWlsZGVyIHtcbiAgaW5kZXgoYWxnb3JpdGhtID0gXCJidHJlZVwiKSB7XG4gICAgcmV0dXJuIG5ldyBfVTEyOENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaW5kZXhUeXBlOiBhbGdvcml0aG0gfSlcbiAgICApO1xuICB9XG4gIHVuaXF1ZSgpIHtcbiAgICByZXR1cm4gbmV3IF9VMTI4Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc1VuaXF1ZTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgcHJpbWFyeUtleSgpIHtcbiAgICByZXR1cm4gbmV3IF9VMTI4Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc1ByaW1hcnlLZXk6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGF1dG9JbmMoKSB7XG4gICAgcmV0dXJuIG5ldyBfVTEyOENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNBdXRvSW5jcmVtZW50OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBfVTEyOENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHtcbiAgICAgICAgZGVmYXVsdFZhbHVlOiB2YWx1ZVxuICAgICAgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgX1UxMjhDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IG5hbWUgfSlcbiAgICApO1xuICB9XG59O1xudmFyIFUyNTZDb2x1bW5CdWlsZGVyID0gY2xhc3MgX1UyNTZDb2x1bW5CdWlsZGVyIGV4dGVuZHMgQ29sdW1uQnVpbGRlciB7XG4gIGluZGV4KGFsZ29yaXRobSA9IFwiYnRyZWVcIikge1xuICAgIHJldHVybiBuZXcgX1UyNTZDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGluZGV4VHlwZTogYWxnb3JpdGhtIH0pXG4gICAgKTtcbiAgfVxuICB1bmlxdWUoKSB7XG4gICAgcmV0dXJuIG5ldyBfVTI1NkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNVbmlxdWU6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIHByaW1hcnlLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBfVTI1NkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNQcmltYXJ5S2V5OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBhdXRvSW5jKCkge1xuICAgIHJldHVybiBuZXcgX1UyNTZDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzQXV0b0luY3JlbWVudDogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgX1UyNTZDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7XG4gICAgICAgIGRlZmF1bHRWYWx1ZTogdmFsdWVcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IF9VMjU2Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBuYW1lIH0pXG4gICAgKTtcbiAgfVxufTtcbnZhciBJOENvbHVtbkJ1aWxkZXIgPSBjbGFzcyBfSThDb2x1bW5CdWlsZGVyIGV4dGVuZHMgQ29sdW1uQnVpbGRlciB7XG4gIGluZGV4KGFsZ29yaXRobSA9IFwiYnRyZWVcIikge1xuICAgIHJldHVybiBuZXcgX0k4Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpbmRleFR5cGU6IGFsZ29yaXRobSB9KVxuICAgICk7XG4gIH1cbiAgdW5pcXVlKCkge1xuICAgIHJldHVybiBuZXcgX0k4Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc1VuaXF1ZTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgcHJpbWFyeUtleSgpIHtcbiAgICByZXR1cm4gbmV3IF9JOENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNQcmltYXJ5S2V5OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBhdXRvSW5jKCkge1xuICAgIHJldHVybiBuZXcgX0k4Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc0F1dG9JbmNyZW1lbnQ6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IF9JOENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHtcbiAgICAgICAgZGVmYXVsdFZhbHVlOiB2YWx1ZVxuICAgICAgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgX0k4Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBuYW1lIH0pXG4gICAgKTtcbiAgfVxufTtcbnZhciBJMTZDb2x1bW5CdWlsZGVyID0gY2xhc3MgX0kxNkNvbHVtbkJ1aWxkZXIgZXh0ZW5kcyBDb2x1bW5CdWlsZGVyIHtcbiAgaW5kZXgoYWxnb3JpdGhtID0gXCJidHJlZVwiKSB7XG4gICAgcmV0dXJuIG5ldyBfSTE2Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpbmRleFR5cGU6IGFsZ29yaXRobSB9KVxuICAgICk7XG4gIH1cbiAgdW5pcXVlKCkge1xuICAgIHJldHVybiBuZXcgX0kxNkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNVbmlxdWU6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIHByaW1hcnlLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBfSTE2Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc1ByaW1hcnlLZXk6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGF1dG9JbmMoKSB7XG4gICAgcmV0dXJuIG5ldyBfSTE2Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc0F1dG9JbmNyZW1lbnQ6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IF9JMTZDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7XG4gICAgICAgIGRlZmF1bHRWYWx1ZTogdmFsdWVcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IF9JMTZDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IG5hbWUgfSlcbiAgICApO1xuICB9XG59O1xudmFyIEkzMkNvbHVtbkJ1aWxkZXIgPSBjbGFzcyBfSTMyQ29sdW1uQnVpbGRlciBleHRlbmRzIENvbHVtbkJ1aWxkZXIge1xuICBpbmRleChhbGdvcml0aG0gPSBcImJ0cmVlXCIpIHtcbiAgICByZXR1cm4gbmV3IF9JMzJDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGluZGV4VHlwZTogYWxnb3JpdGhtIH0pXG4gICAgKTtcbiAgfVxuICB1bmlxdWUoKSB7XG4gICAgcmV0dXJuIG5ldyBfSTMyQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc1VuaXF1ZTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgcHJpbWFyeUtleSgpIHtcbiAgICByZXR1cm4gbmV3IF9JMzJDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzUHJpbWFyeUtleTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgYXV0b0luYygpIHtcbiAgICByZXR1cm4gbmV3IF9JMzJDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzQXV0b0luY3JlbWVudDogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgX0kzMkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHtcbiAgICAgICAgZGVmYXVsdFZhbHVlOiB2YWx1ZVxuICAgICAgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgX0kzMkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgbmFtZSB9KVxuICAgICk7XG4gIH1cbn07XG52YXIgSTY0Q29sdW1uQnVpbGRlciA9IGNsYXNzIF9JNjRDb2x1bW5CdWlsZGVyIGV4dGVuZHMgQ29sdW1uQnVpbGRlciB7XG4gIGluZGV4KGFsZ29yaXRobSA9IFwiYnRyZWVcIikge1xuICAgIHJldHVybiBuZXcgX0k2NENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaW5kZXhUeXBlOiBhbGdvcml0aG0gfSlcbiAgICApO1xuICB9XG4gIHVuaXF1ZSgpIHtcbiAgICByZXR1cm4gbmV3IF9JNjRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzVW5pcXVlOiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBwcmltYXJ5S2V5KCkge1xuICAgIHJldHVybiBuZXcgX0k2NENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNQcmltYXJ5S2V5OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBhdXRvSW5jKCkge1xuICAgIHJldHVybiBuZXcgX0k2NENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNBdXRvSW5jcmVtZW50OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBfSTY0Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwge1xuICAgICAgICBkZWZhdWx0VmFsdWU6IHZhbHVlXG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBfSTY0Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBuYW1lIH0pXG4gICAgKTtcbiAgfVxufTtcbnZhciBJMTI4Q29sdW1uQnVpbGRlciA9IGNsYXNzIF9JMTI4Q29sdW1uQnVpbGRlciBleHRlbmRzIENvbHVtbkJ1aWxkZXIge1xuICBpbmRleChhbGdvcml0aG0gPSBcImJ0cmVlXCIpIHtcbiAgICByZXR1cm4gbmV3IF9JMTI4Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpbmRleFR5cGU6IGFsZ29yaXRobSB9KVxuICAgICk7XG4gIH1cbiAgdW5pcXVlKCkge1xuICAgIHJldHVybiBuZXcgX0kxMjhDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzVW5pcXVlOiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBwcmltYXJ5S2V5KCkge1xuICAgIHJldHVybiBuZXcgX0kxMjhDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzUHJpbWFyeUtleTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgYXV0b0luYygpIHtcbiAgICByZXR1cm4gbmV3IF9JMTI4Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc0F1dG9JbmNyZW1lbnQ6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IF9JMTI4Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwge1xuICAgICAgICBkZWZhdWx0VmFsdWU6IHZhbHVlXG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBfSTEyOENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgbmFtZSB9KVxuICAgICk7XG4gIH1cbn07XG52YXIgSTI1NkNvbHVtbkJ1aWxkZXIgPSBjbGFzcyBfSTI1NkNvbHVtbkJ1aWxkZXIgZXh0ZW5kcyBDb2x1bW5CdWlsZGVyIHtcbiAgaW5kZXgoYWxnb3JpdGhtID0gXCJidHJlZVwiKSB7XG4gICAgcmV0dXJuIG5ldyBfSTI1NkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaW5kZXhUeXBlOiBhbGdvcml0aG0gfSlcbiAgICApO1xuICB9XG4gIHVuaXF1ZSgpIHtcbiAgICByZXR1cm4gbmV3IF9JMjU2Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc1VuaXF1ZTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgcHJpbWFyeUtleSgpIHtcbiAgICByZXR1cm4gbmV3IF9JMjU2Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc1ByaW1hcnlLZXk6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGF1dG9JbmMoKSB7XG4gICAgcmV0dXJuIG5ldyBfSTI1NkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNBdXRvSW5jcmVtZW50OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBfSTI1NkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHtcbiAgICAgICAgZGVmYXVsdFZhbHVlOiB2YWx1ZVxuICAgICAgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgX0kyNTZDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IG5hbWUgfSlcbiAgICApO1xuICB9XG59O1xudmFyIEYzMkNvbHVtbkJ1aWxkZXIgPSBjbGFzcyBfRjMyQ29sdW1uQnVpbGRlciBleHRlbmRzIENvbHVtbkJ1aWxkZXIge1xuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBfRjMyQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwge1xuICAgICAgICBkZWZhdWx0VmFsdWU6IHZhbHVlXG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBfRjMyQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBuYW1lIH0pXG4gICAgKTtcbiAgfVxufTtcbnZhciBGNjRDb2x1bW5CdWlsZGVyID0gY2xhc3MgX0Y2NENvbHVtbkJ1aWxkZXIgZXh0ZW5kcyBDb2x1bW5CdWlsZGVyIHtcbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgX0Y2NENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHtcbiAgICAgICAgZGVmYXVsdFZhbHVlOiB2YWx1ZVxuICAgICAgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgX0Y2NENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgbmFtZSB9KVxuICAgICk7XG4gIH1cbn07XG52YXIgQm9vbENvbHVtbkJ1aWxkZXIgPSBjbGFzcyBfQm9vbENvbHVtbkJ1aWxkZXIgZXh0ZW5kcyBDb2x1bW5CdWlsZGVyIHtcbiAgaW5kZXgoYWxnb3JpdGhtID0gXCJidHJlZVwiKSB7XG4gICAgcmV0dXJuIG5ldyBfQm9vbENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaW5kZXhUeXBlOiBhbGdvcml0aG0gfSlcbiAgICApO1xuICB9XG4gIHVuaXF1ZSgpIHtcbiAgICByZXR1cm4gbmV3IF9Cb29sQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc1VuaXF1ZTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgcHJpbWFyeUtleSgpIHtcbiAgICByZXR1cm4gbmV3IF9Cb29sQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc1ByaW1hcnlLZXk6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IF9Cb29sQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwge1xuICAgICAgICBkZWZhdWx0VmFsdWU6IHZhbHVlXG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBfQm9vbENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgbmFtZSB9KVxuICAgICk7XG4gIH1cbn07XG52YXIgU3RyaW5nQ29sdW1uQnVpbGRlciA9IGNsYXNzIF9TdHJpbmdDb2x1bW5CdWlsZGVyIGV4dGVuZHMgQ29sdW1uQnVpbGRlciB7XG4gIGluZGV4KGFsZ29yaXRobSA9IFwiYnRyZWVcIikge1xuICAgIHJldHVybiBuZXcgX1N0cmluZ0NvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaW5kZXhUeXBlOiBhbGdvcml0aG0gfSlcbiAgICApO1xuICB9XG4gIHVuaXF1ZSgpIHtcbiAgICByZXR1cm4gbmV3IF9TdHJpbmdDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzVW5pcXVlOiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBwcmltYXJ5S2V5KCkge1xuICAgIHJldHVybiBuZXcgX1N0cmluZ0NvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNQcmltYXJ5S2V5OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBfU3RyaW5nQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwge1xuICAgICAgICBkZWZhdWx0VmFsdWU6IHZhbHVlXG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBfU3RyaW5nQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBuYW1lIH0pXG4gICAgKTtcbiAgfVxufTtcbnZhciBBcnJheUNvbHVtbkJ1aWxkZXIgPSBjbGFzcyBfQXJyYXlDb2x1bW5CdWlsZGVyIGV4dGVuZHMgQ29sdW1uQnVpbGRlciB7XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IF9BcnJheUNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHtcbiAgICAgICAgZGVmYXVsdFZhbHVlOiB2YWx1ZVxuICAgICAgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgX0FycmF5Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBuYW1lIH0pXG4gICAgKTtcbiAgfVxufTtcbnZhciBCeXRlQXJyYXlDb2x1bW5CdWlsZGVyID0gY2xhc3MgX0J5dGVBcnJheUNvbHVtbkJ1aWxkZXIgZXh0ZW5kcyBDb2x1bW5CdWlsZGVyIHtcbiAgY29uc3RydWN0b3IobWV0YWRhdGEpIHtcbiAgICBzdXBlcihuZXcgVHlwZUJ1aWxkZXIoQWxnZWJyYWljVHlwZS5BcnJheShBbGdlYnJhaWNUeXBlLlU4KSksIG1ldGFkYXRhKTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBfQnl0ZUFycmF5Q29sdW1uQnVpbGRlcihcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGRlZmF1bHRWYWx1ZTogdmFsdWUgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgX0J5dGVBcnJheUNvbHVtbkJ1aWxkZXIoc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgbmFtZSB9KSk7XG4gIH1cbn07XG52YXIgT3B0aW9uQ29sdW1uQnVpbGRlciA9IGNsYXNzIF9PcHRpb25Db2x1bW5CdWlsZGVyIGV4dGVuZHMgQ29sdW1uQnVpbGRlciB7XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IF9PcHRpb25Db2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7XG4gICAgICAgIGRlZmF1bHRWYWx1ZTogdmFsdWVcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IF9PcHRpb25Db2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IG5hbWUgfSlcbiAgICApO1xuICB9XG59O1xudmFyIFJlc3VsdENvbHVtbkJ1aWxkZXIgPSBjbGFzcyBfUmVzdWx0Q29sdW1uQnVpbGRlciBleHRlbmRzIENvbHVtbkJ1aWxkZXIge1xuICBjb25zdHJ1Y3Rvcih0eXBlQnVpbGRlciwgbWV0YWRhdGEpIHtcbiAgICBzdXBlcih0eXBlQnVpbGRlciwgbWV0YWRhdGEpO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IF9SZXN1bHRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7XG4gICAgICAgIGRlZmF1bHRWYWx1ZTogdmFsdWVcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxufTtcbnZhciBQcm9kdWN0Q29sdW1uQnVpbGRlciA9IGNsYXNzIF9Qcm9kdWN0Q29sdW1uQnVpbGRlciBleHRlbmRzIENvbHVtbkJ1aWxkZXIge1xuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBfUHJvZHVjdENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgZGVmYXVsdFZhbHVlOiB2YWx1ZSB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBfUHJvZHVjdENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgbmFtZSB9KVxuICAgICk7XG4gIH1cbn07XG52YXIgU3VtQ29sdW1uQnVpbGRlciA9IGNsYXNzIF9TdW1Db2x1bW5CdWlsZGVyIGV4dGVuZHMgQ29sdW1uQnVpbGRlciB7XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IF9TdW1Db2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGRlZmF1bHRWYWx1ZTogdmFsdWUgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgX1N1bUNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgbmFtZSB9KVxuICAgICk7XG4gIH1cbn07XG52YXIgU2ltcGxlU3VtQ29sdW1uQnVpbGRlciA9IGNsYXNzIF9TaW1wbGVTdW1Db2x1bW5CdWlsZGVyIGV4dGVuZHMgU3VtQ29sdW1uQnVpbGRlciB7XG4gIGluZGV4KGFsZ29yaXRobSA9IFwiYnRyZWVcIikge1xuICAgIHJldHVybiBuZXcgX1NpbXBsZVN1bUNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaW5kZXhUeXBlOiBhbGdvcml0aG0gfSlcbiAgICApO1xuICB9XG4gIHByaW1hcnlLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBfU2ltcGxlU3VtQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc1ByaW1hcnlLZXk6IHRydWUgfSlcbiAgICApO1xuICB9XG59O1xudmFyIFNjaGVkdWxlQXRDb2x1bW5CdWlsZGVyID0gY2xhc3MgX1NjaGVkdWxlQXRDb2x1bW5CdWlsZGVyIGV4dGVuZHMgQ29sdW1uQnVpbGRlciB7XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IF9TY2hlZHVsZUF0Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBkZWZhdWx0VmFsdWU6IHZhbHVlIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IF9TY2hlZHVsZUF0Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBuYW1lIH0pXG4gICAgKTtcbiAgfVxufTtcbnZhciBJZGVudGl0eUNvbHVtbkJ1aWxkZXIgPSBjbGFzcyBfSWRlbnRpdHlDb2x1bW5CdWlsZGVyIGV4dGVuZHMgQ29sdW1uQnVpbGRlciB7XG4gIGluZGV4KGFsZ29yaXRobSA9IFwiYnRyZWVcIikge1xuICAgIHJldHVybiBuZXcgX0lkZW50aXR5Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpbmRleFR5cGU6IGFsZ29yaXRobSB9KVxuICAgICk7XG4gIH1cbiAgdW5pcXVlKCkge1xuICAgIHJldHVybiBuZXcgX0lkZW50aXR5Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc1VuaXF1ZTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgcHJpbWFyeUtleSgpIHtcbiAgICByZXR1cm4gbmV3IF9JZGVudGl0eUNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNQcmltYXJ5S2V5OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBfSWRlbnRpdHlDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGRlZmF1bHRWYWx1ZTogdmFsdWUgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgX0lkZW50aXR5Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBuYW1lIH0pXG4gICAgKTtcbiAgfVxufTtcbnZhciBDb25uZWN0aW9uSWRDb2x1bW5CdWlsZGVyID0gY2xhc3MgX0Nvbm5lY3Rpb25JZENvbHVtbkJ1aWxkZXIgZXh0ZW5kcyBDb2x1bW5CdWlsZGVyIHtcbiAgaW5kZXgoYWxnb3JpdGhtID0gXCJidHJlZVwiKSB7XG4gICAgcmV0dXJuIG5ldyBfQ29ubmVjdGlvbklkQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpbmRleFR5cGU6IGFsZ29yaXRobSB9KVxuICAgICk7XG4gIH1cbiAgdW5pcXVlKCkge1xuICAgIHJldHVybiBuZXcgX0Nvbm5lY3Rpb25JZENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNVbmlxdWU6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIHByaW1hcnlLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBfQ29ubmVjdGlvbklkQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc1ByaW1hcnlLZXk6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IF9Db25uZWN0aW9uSWRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGRlZmF1bHRWYWx1ZTogdmFsdWUgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgX0Nvbm5lY3Rpb25JZENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgbmFtZSB9KVxuICAgICk7XG4gIH1cbn07XG52YXIgVGltZXN0YW1wQ29sdW1uQnVpbGRlciA9IGNsYXNzIF9UaW1lc3RhbXBDb2x1bW5CdWlsZGVyIGV4dGVuZHMgQ29sdW1uQnVpbGRlciB7XG4gIGluZGV4KGFsZ29yaXRobSA9IFwiYnRyZWVcIikge1xuICAgIHJldHVybiBuZXcgX1RpbWVzdGFtcENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaW5kZXhUeXBlOiBhbGdvcml0aG0gfSlcbiAgICApO1xuICB9XG4gIHVuaXF1ZSgpIHtcbiAgICByZXR1cm4gbmV3IF9UaW1lc3RhbXBDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzVW5pcXVlOiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBwcmltYXJ5S2V5KCkge1xuICAgIHJldHVybiBuZXcgX1RpbWVzdGFtcENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNQcmltYXJ5S2V5OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBfVGltZXN0YW1wQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBkZWZhdWx0VmFsdWU6IHZhbHVlIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IF9UaW1lc3RhbXBDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IG5hbWUgfSlcbiAgICApO1xuICB9XG59O1xudmFyIFRpbWVEdXJhdGlvbkNvbHVtbkJ1aWxkZXIgPSBjbGFzcyBfVGltZUR1cmF0aW9uQ29sdW1uQnVpbGRlciBleHRlbmRzIENvbHVtbkJ1aWxkZXIge1xuICBpbmRleChhbGdvcml0aG0gPSBcImJ0cmVlXCIpIHtcbiAgICByZXR1cm4gbmV3IF9UaW1lRHVyYXRpb25Db2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGluZGV4VHlwZTogYWxnb3JpdGhtIH0pXG4gICAgKTtcbiAgfVxuICB1bmlxdWUoKSB7XG4gICAgcmV0dXJuIG5ldyBfVGltZUR1cmF0aW9uQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc1VuaXF1ZTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgcHJpbWFyeUtleSgpIHtcbiAgICByZXR1cm4gbmV3IF9UaW1lRHVyYXRpb25Db2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzUHJpbWFyeUtleTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgX1RpbWVEdXJhdGlvbkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgZGVmYXVsdFZhbHVlOiB2YWx1ZSB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBfVGltZUR1cmF0aW9uQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBuYW1lIH0pXG4gICAgKTtcbiAgfVxufTtcbnZhciBVdWlkQ29sdW1uQnVpbGRlciA9IGNsYXNzIF9VdWlkQ29sdW1uQnVpbGRlciBleHRlbmRzIENvbHVtbkJ1aWxkZXIge1xuICBpbmRleChhbGdvcml0aG0gPSBcImJ0cmVlXCIpIHtcbiAgICByZXR1cm4gbmV3IF9VdWlkQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpbmRleFR5cGU6IGFsZ29yaXRobSB9KVxuICAgICk7XG4gIH1cbiAgdW5pcXVlKCkge1xuICAgIHJldHVybiBuZXcgX1V1aWRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzVW5pcXVlOiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBwcmltYXJ5S2V5KCkge1xuICAgIHJldHVybiBuZXcgX1V1aWRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzUHJpbWFyeUtleTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgX1V1aWRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGRlZmF1bHRWYWx1ZTogdmFsdWUgfSlcbiAgICApO1xuICB9XG59O1xudmFyIFJlZkJ1aWxkZXIgPSBjbGFzcyBleHRlbmRzIFR5cGVCdWlsZGVyIHtcbiAgcmVmO1xuICAvKiogVGhlIHBoYW50b20gdHlwZSBvZiB0aGUgcG9pbnRlZSBvZiB0aGlzIHJlZi4gKi9cbiAgX19zcGFjZXRpbWVUeXBlO1xuICBjb25zdHJ1Y3RvcihyZWYpIHtcbiAgICBzdXBlcihBbGdlYnJhaWNUeXBlLlJlZihyZWYpKTtcbiAgICB0aGlzLnJlZiA9IHJlZjtcbiAgfVxufTtcbnZhciBlbnVtSW1wbCA9ICgobmFtZU9yT2JqLCBtYXliZU9iaikgPT4ge1xuICBsZXQgb2JqID0gbmFtZU9yT2JqO1xuICBsZXQgbmFtZSA9IHZvaWQgMDtcbiAgaWYgKHR5cGVvZiBuYW1lT3JPYmogPT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAoIW1heWJlT2JqKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBcIldoZW4gcHJvdmlkaW5nIGEgbmFtZSwgeW91IG11c3QgYWxzbyBwcm92aWRlIHRoZSB2YXJpYW50cyBvYmplY3Qgb3IgYXJyYXkuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIG9iaiA9IG1heWJlT2JqO1xuICAgIG5hbWUgPSBuYW1lT3JPYmo7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgIGNvbnN0IHNpbXBsZVZhcmlhbnRzT2JqID0ge307XG4gICAgZm9yIChjb25zdCB2YXJpYW50IG9mIG9iaikge1xuICAgICAgc2ltcGxlVmFyaWFudHNPYmpbdmFyaWFudF0gPSBuZXcgVW5pdEJ1aWxkZXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTaW1wbGVTdW1CdWlsZGVySW1wbChzaW1wbGVWYXJpYW50c09iaiwgbmFtZSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBTdW1CdWlsZGVyKG9iaiwgbmFtZSk7XG59KTtcbnZhciB0ID0ge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBgQm9vbGAge0BsaW5rIEFsZ2VicmFpY1R5cGV9IHRvIGJlIHVzZWQgaW4gdGFibGUgZGVmaW5pdGlvbnNcbiAgICogUmVwcmVzZW50ZWQgYXMgYGJvb2xlYW5gIGluIFR5cGVTY3JpcHQuXG4gICAqIEByZXR1cm5zIEEgbmV3IHtAbGluayBCb29sQnVpbGRlcn0gaW5zdGFuY2VcbiAgICovXG4gIGJvb2w6ICgpID0+IG5ldyBCb29sQnVpbGRlcigpLFxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBgU3RyaW5nYCB7QGxpbmsgQWxnZWJyYWljVHlwZX0gdG8gYmUgdXNlZCBpbiB0YWJsZSBkZWZpbml0aW9uc1xuICAgKiBSZXByZXNlbnRlZCBhcyBgc3RyaW5nYCBpbiBUeXBlU2NyaXB0LlxuICAgKiBAcmV0dXJucyBBIG5ldyB7QGxpbmsgU3RyaW5nQnVpbGRlcn0gaW5zdGFuY2VcbiAgICovXG4gIHN0cmluZzogKCkgPT4gbmV3IFN0cmluZ0J1aWxkZXIoKSxcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYEY2NGAge0BsaW5rIEFsZ2VicmFpY1R5cGV9IHRvIGJlIHVzZWQgaW4gdGFibGUgZGVmaW5pdGlvbnNcbiAgICogUmVwcmVzZW50ZWQgYXMgYG51bWJlcmAgaW4gVHlwZVNjcmlwdC5cbiAgICogQHJldHVybnMgQSBuZXcge0BsaW5rIEY2NEJ1aWxkZXJ9IGluc3RhbmNlXG4gICAqL1xuICBudW1iZXI6ICgpID0+IG5ldyBGNjRCdWlsZGVyKCksXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGBJOGAge0BsaW5rIEFsZ2VicmFpY1R5cGV9IHRvIGJlIHVzZWQgaW4gdGFibGUgZGVmaW5pdGlvbnNcbiAgICogUmVwcmVzZW50ZWQgYXMgYG51bWJlcmAgaW4gVHlwZVNjcmlwdC5cbiAgICogQHJldHVybnMgQSBuZXcge0BsaW5rIEk4QnVpbGRlcn0gaW5zdGFuY2VcbiAgICovXG4gIGk4OiAoKSA9PiBuZXcgSThCdWlsZGVyKCksXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGBVOGAge0BsaW5rIEFsZ2VicmFpY1R5cGV9IHRvIGJlIHVzZWQgaW4gdGFibGUgZGVmaW5pdGlvbnNcbiAgICogUmVwcmVzZW50ZWQgYXMgYG51bWJlcmAgaW4gVHlwZVNjcmlwdC5cbiAgICogQHJldHVybnMgQSBuZXcge0BsaW5rIFU4QnVpbGRlcn0gaW5zdGFuY2VcbiAgICovXG4gIHU4OiAoKSA9PiBuZXcgVThCdWlsZGVyKCksXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGBJMTZgIHtAbGluayBBbGdlYnJhaWNUeXBlfSB0byBiZSB1c2VkIGluIHRhYmxlIGRlZmluaXRpb25zXG4gICAqIFJlcHJlc2VudGVkIGFzIGBudW1iZXJgIGluIFR5cGVTY3JpcHQuXG4gICAqIEByZXR1cm5zIEEgbmV3IHtAbGluayBJMTZCdWlsZGVyfSBpbnN0YW5jZVxuICAgKi9cbiAgaTE2OiAoKSA9PiBuZXcgSTE2QnVpbGRlcigpLFxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBgVTE2YCB7QGxpbmsgQWxnZWJyYWljVHlwZX0gdG8gYmUgdXNlZCBpbiB0YWJsZSBkZWZpbml0aW9uc1xuICAgKiBSZXByZXNlbnRlZCBhcyBgbnVtYmVyYCBpbiBUeXBlU2NyaXB0LlxuICAgKiBAcmV0dXJucyBBIG5ldyB7QGxpbmsgVTE2QnVpbGRlcn0gaW5zdGFuY2VcbiAgICovXG4gIHUxNjogKCkgPT4gbmV3IFUxNkJ1aWxkZXIoKSxcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYEkzMmAge0BsaW5rIEFsZ2VicmFpY1R5cGV9IHRvIGJlIHVzZWQgaW4gdGFibGUgZGVmaW5pdGlvbnNcbiAgICogUmVwcmVzZW50ZWQgYXMgYG51bWJlcmAgaW4gVHlwZVNjcmlwdC5cbiAgICogQHJldHVybnMgQSBuZXcge0BsaW5rIEkzMkJ1aWxkZXJ9IGluc3RhbmNlXG4gICAqL1xuICBpMzI6ICgpID0+IG5ldyBJMzJCdWlsZGVyKCksXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGBVMzJgIHtAbGluayBBbGdlYnJhaWNUeXBlfSB0byBiZSB1c2VkIGluIHRhYmxlIGRlZmluaXRpb25zXG4gICAqIFJlcHJlc2VudGVkIGFzIGBudW1iZXJgIGluIFR5cGVTY3JpcHQuXG4gICAqIEByZXR1cm5zIEEgbmV3IHtAbGluayBVMzJCdWlsZGVyfSBpbnN0YW5jZVxuICAgKi9cbiAgdTMyOiAoKSA9PiBuZXcgVTMyQnVpbGRlcigpLFxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBgSTY0YCB7QGxpbmsgQWxnZWJyYWljVHlwZX0gdG8gYmUgdXNlZCBpbiB0YWJsZSBkZWZpbml0aW9uc1xuICAgKiBSZXByZXNlbnRlZCBhcyBgYmlnaW50YCBpbiBUeXBlU2NyaXB0LlxuICAgKiBAcmV0dXJucyBBIG5ldyB7QGxpbmsgSTY0QnVpbGRlcn0gaW5zdGFuY2VcbiAgICovXG4gIGk2NDogKCkgPT4gbmV3IEk2NEJ1aWxkZXIoKSxcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYFU2NGAge0BsaW5rIEFsZ2VicmFpY1R5cGV9IHRvIGJlIHVzZWQgaW4gdGFibGUgZGVmaW5pdGlvbnNcbiAgICogUmVwcmVzZW50ZWQgYXMgYGJpZ2ludGAgaW4gVHlwZVNjcmlwdC5cbiAgICogQHJldHVybnMgQSBuZXcge0BsaW5rIFU2NEJ1aWxkZXJ9IGluc3RhbmNlXG4gICAqL1xuICB1NjQ6ICgpID0+IG5ldyBVNjRCdWlsZGVyKCksXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGBJMTI4YCB7QGxpbmsgQWxnZWJyYWljVHlwZX0gdG8gYmUgdXNlZCBpbiB0YWJsZSBkZWZpbml0aW9uc1xuICAgKiBSZXByZXNlbnRlZCBhcyBgYmlnaW50YCBpbiBUeXBlU2NyaXB0LlxuICAgKiBAcmV0dXJucyBBIG5ldyB7QGxpbmsgSTEyOEJ1aWxkZXJ9IGluc3RhbmNlXG4gICAqL1xuICBpMTI4OiAoKSA9PiBuZXcgSTEyOEJ1aWxkZXIoKSxcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYFUxMjhgIHtAbGluayBBbGdlYnJhaWNUeXBlfSB0byBiZSB1c2VkIGluIHRhYmxlIGRlZmluaXRpb25zXG4gICAqIFJlcHJlc2VudGVkIGFzIGBiaWdpbnRgIGluIFR5cGVTY3JpcHQuXG4gICAqIEByZXR1cm5zIEEgbmV3IHtAbGluayBVMTI4QnVpbGRlcn0gaW5zdGFuY2VcbiAgICovXG4gIHUxMjg6ICgpID0+IG5ldyBVMTI4QnVpbGRlcigpLFxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBgSTI1NmAge0BsaW5rIEFsZ2VicmFpY1R5cGV9IHRvIGJlIHVzZWQgaW4gdGFibGUgZGVmaW5pdGlvbnNcbiAgICogUmVwcmVzZW50ZWQgYXMgYGJpZ2ludGAgaW4gVHlwZVNjcmlwdC5cbiAgICogQHJldHVybnMgQSBuZXcge0BsaW5rIEkyNTZCdWlsZGVyfSBpbnN0YW5jZVxuICAgKi9cbiAgaTI1NjogKCkgPT4gbmV3IEkyNTZCdWlsZGVyKCksXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGBVMjU2YCB7QGxpbmsgQWxnZWJyYWljVHlwZX0gdG8gYmUgdXNlZCBpbiB0YWJsZSBkZWZpbml0aW9uc1xuICAgKiBSZXByZXNlbnRlZCBhcyBgYmlnaW50YCBpbiBUeXBlU2NyaXB0LlxuICAgKiBAcmV0dXJucyBBIG5ldyB7QGxpbmsgVTI1NkJ1aWxkZXJ9IGluc3RhbmNlXG4gICAqL1xuICB1MjU2OiAoKSA9PiBuZXcgVTI1NkJ1aWxkZXIoKSxcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYEYzMmAge0BsaW5rIEFsZ2VicmFpY1R5cGV9IHRvIGJlIHVzZWQgaW4gdGFibGUgZGVmaW5pdGlvbnNcbiAgICogUmVwcmVzZW50ZWQgYXMgYG51bWJlcmAgaW4gVHlwZVNjcmlwdC5cbiAgICogQHJldHVybnMgQSBuZXcge0BsaW5rIEYzMkJ1aWxkZXJ9IGluc3RhbmNlXG4gICAqL1xuICBmMzI6ICgpID0+IG5ldyBGMzJCdWlsZGVyKCksXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGBGNjRgIHtAbGluayBBbGdlYnJhaWNUeXBlfSB0byBiZSB1c2VkIGluIHRhYmxlIGRlZmluaXRpb25zXG4gICAqIFJlcHJlc2VudGVkIGFzIGBudW1iZXJgIGluIFR5cGVTY3JpcHQuXG4gICAqIEByZXR1cm5zIEEgbmV3IHtAbGluayBGNjRCdWlsZGVyfSBpbnN0YW5jZVxuICAgKi9cbiAgZjY0OiAoKSA9PiBuZXcgRjY0QnVpbGRlcigpLFxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBgUHJvZHVjdGAge0BsaW5rIEFsZ2VicmFpY1R5cGV9IHRvIGJlIHVzZWQgaW4gdGFibGUgZGVmaW5pdGlvbnMuIFByb2R1Y3QgdHlwZXMgaW4gU3BhY2V0aW1lREJcbiAgICogYXJlIGVzc2VudGlhbGx5IHRoZSBzYW1lIGFzIG9iamVjdHMgaW4gSmF2YVNjcmlwdC9UeXBlU2NyaXB0LlxuICAgKiBQcm9wZXJ0aWVzIG9mIHRoZSBvYmplY3QgbXVzdCBhbHNvIGJlIHtAbGluayBUeXBlQnVpbGRlcn1zLlxuICAgKiBSZXByZXNlbnRlZCBhcyBhbiBvYmplY3Qgd2l0aCBzcGVjaWZpYyBwcm9wZXJ0aWVzIGluIFR5cGVTY3JpcHQuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIChvcHRpb25hbCkgQSBkaXNwbGF5IG5hbWUgZm9yIHRoZSBwcm9kdWN0IHR5cGUuIElmIG9taXR0ZWQsIGFuIGFub255bW91cyBwcm9kdWN0IHR5cGUgaXMgY3JlYXRlZC5cbiAgICogQHBhcmFtIG9iaiBUaGUgb2JqZWN0IGRlZmluaW5nIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSB0eXBlLCB3aG9zZSBwcm9wZXJ0eVxuICAgKiB2YWx1ZXMgbXVzdCBiZSB7QGxpbmsgVHlwZUJ1aWxkZXJ9cy5cbiAgICogQHJldHVybnMgQSBuZXcge0BsaW5rIFByb2R1Y3RCdWlsZGVyfSBpbnN0YW5jZS5cbiAgICovXG4gIG9iamVjdDogKChuYW1lT3JPYmosIG1heWJlT2JqKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBuYW1lT3JPYmogPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGlmICghbWF5YmVPYmopIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIldoZW4gcHJvdmlkaW5nIGEgbmFtZSwgeW91IG11c3QgYWxzbyBwcm92aWRlIHRoZSBvYmplY3QuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgUHJvZHVjdEJ1aWxkZXIobWF5YmVPYmosIG5hbWVPck9iaik7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvZHVjdEJ1aWxkZXIobmFtZU9yT2JqLCB2b2lkIDApO1xuICB9KSxcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYFJvd2Age0BsaW5rIEFsZ2VicmFpY1R5cGV9IHRvIGJlIHVzZWQgaW4gdGFibGUgZGVmaW5pdGlvbnMuIFJvdyB0eXBlcyBpbiBTcGFjZXRpbWVEQlxuICAgKiBhcmUgc2ltaWxhciB0byBgUHJvZHVjdGAgdHlwZXMsIGJ1dCBhcmUgc3BlY2lmaWNhbGx5IHVzZWQgdG8gZGVmaW5lIHRoZSBzY2hlbWEgb2YgYSB0YWJsZSByb3cuXG4gICAqIFByb3BlcnRpZXMgb2YgdGhlIG9iamVjdCBtdXN0IGFsc28gYmUge0BsaW5rIFR5cGVCdWlsZGVyfSBvciB7QGxpbmsgQ29sdW1uQnVpbGRlcn1zLlxuICAgKlxuICAgKiBZb3UgY2FuIHJlcHJlc2VudCBhIGBSb3dgIGFzIGVpdGhlciBhIHtAbGluayBSb3dPYmp9IG9yIGFuIHtAbGluayBSb3dCdWlsZGVyfSB0eXBlIHdoZW5cbiAgICogZGVmaW5pbmcgYSB0YWJsZSBzY2hlbWEuXG4gICAqXG4gICAqIFRoZSB7QGxpbmsgUm93QnVpbGRlcn0gdHlwZSBpcyB1c2VmdWwgd2hlbiB5b3Ugd2FudCB0byBjcmVhdGUgYSB0eXBlIHdoaWNoIGNhbiBiZSB1c2VkIGFueXdoZXJlXG4gICAqIGEge0BsaW5rIFR5cGVCdWlsZGVyfSBpcyBhY2NlcHRlZCwgc3VjaCBhcyBpbiBuZXN0ZWQgb2JqZWN0cyBvciBhcnJheXMsIG9yIGFzIHRoZSBhcmd1bWVudFxuICAgKiB0byBhIHNjaGVkdWxlZCBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIG9iaiBUaGUgb2JqZWN0IGRlZmluaW5nIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSByb3csIHdob3NlIHByb3BlcnR5XG4gICAqIHZhbHVlcyBtdXN0IGJlIHtAbGluayBUeXBlQnVpbGRlcn1zIG9yIHtAbGluayBDb2x1bW5CdWlsZGVyfXMuXG4gICAqIEByZXR1cm5zIEEgbmV3IHtAbGluayBSb3dCdWlsZGVyfSBpbnN0YW5jZVxuICAgKi9cbiAgcm93OiAoKG5hbWVPck9iaiwgbWF5YmVPYmopID0+IHtcbiAgICBjb25zdCBbb2JqLCBuYW1lXSA9IHR5cGVvZiBuYW1lT3JPYmogPT09IFwic3RyaW5nXCIgPyBbbWF5YmVPYmosIG5hbWVPck9ial0gOiBbbmFtZU9yT2JqLCB2b2lkIDBdO1xuICAgIHJldHVybiBuZXcgUm93QnVpbGRlcihvYmosIG5hbWUpO1xuICB9KSxcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYEFycmF5YCB7QGxpbmsgQWxnZWJyYWljVHlwZX0gdG8gYmUgdXNlZCBpbiB0YWJsZSBkZWZpbml0aW9ucy5cbiAgICogUmVwcmVzZW50ZWQgYXMgYW4gYXJyYXkgaW4gVHlwZVNjcmlwdC5cbiAgICogQHBhcmFtIGVsZW1lbnQgVGhlIGVsZW1lbnQgdHlwZSBvZiB0aGUgYXJyYXksIHdoaWNoIG11c3QgYmUgYSBgVHlwZUJ1aWxkZXJgLlxuICAgKiBAcmV0dXJucyBBIG5ldyB7QGxpbmsgQXJyYXlCdWlsZGVyfSBpbnN0YW5jZVxuICAgKi9cbiAgYXJyYXkoZSkge1xuICAgIHJldHVybiBuZXcgQXJyYXlCdWlsZGVyKGUpO1xuICB9LFxuICBlbnVtOiBlbnVtSW1wbCxcbiAgLyoqXG4gICAqIFRoaXMgaXMgYSBzcGVjaWFsIGhlbHBlciBmdW5jdGlvbiBmb3IgY29udmVuaWVudGx5IGNyZWF0aW5nIHtAbGluayBQcm9kdWN0fSB0eXBlIGNvbHVtbnMgd2l0aCBubyBmaWVsZHMuXG4gICAqXG4gICAqIEByZXR1cm5zIEEgbmV3IHtAbGluayBQcm9kdWN0QnVpbGRlcn0gaW5zdGFuY2Ugd2l0aCBubyBmaWVsZHMuXG4gICAqL1xuICB1bml0KCkge1xuICAgIHJldHVybiBuZXcgVW5pdEJ1aWxkZXIoKTtcbiAgfSxcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBsYXppbHktZXZhbHVhdGVkIHtAbGluayBUeXBlQnVpbGRlcn0uIFRoaXMgaXMgdXNlZnVsIGZvciBjcmVhdGluZ1xuICAgKiByZWN1cnNpdmUgdHlwZXMsIHN1Y2ggYXMgYSB0cmVlIG9yIGxpbmtlZCBsaXN0LlxuICAgKiBAcGFyYW0gdGh1bmsgQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSB7QGxpbmsgVHlwZUJ1aWxkZXJ9LlxuICAgKiBAcmV0dXJucyBBIHByb3h5IHtAbGluayBUeXBlQnVpbGRlcn0gdGhhdCBldmFsdWF0ZXMgdGhlIHRodW5rIG9uIGZpcnN0IGFjY2Vzcy5cbiAgICovXG4gIGxhenkodGh1bmspIHtcbiAgICBsZXQgY2FjaGVkID0gbnVsbDtcbiAgICBjb25zdCBnZXQgPSAoKSA9PiBjYWNoZWQgPz89IHRodW5rKCk7XG4gICAgY29uc3QgcHJveHkgPSBuZXcgUHJveHkoe30sIHtcbiAgICAgIGdldChfdCwgcHJvcCwgcmVjdikge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBnZXQoKTtcbiAgICAgICAgY29uc3QgdmFsID0gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWN2KTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09IFwiZnVuY3Rpb25cIiA/IHZhbC5iaW5kKHRhcmdldCkgOiB2YWw7XG4gICAgICB9LFxuICAgICAgc2V0KF90LCBwcm9wLCB2YWx1ZSwgcmVjdikge1xuICAgICAgICByZXR1cm4gUmVmbGVjdC5zZXQoZ2V0KCksIHByb3AsIHZhbHVlLCByZWN2KTtcbiAgICAgIH0sXG4gICAgICBoYXMoX3QsIHByb3ApIHtcbiAgICAgICAgcmV0dXJuIHByb3AgaW4gZ2V0KCk7XG4gICAgICB9LFxuICAgICAgb3duS2V5cygpIHtcbiAgICAgICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyhnZXQoKSk7XG4gICAgICB9LFxuICAgICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKF90LCBwcm9wKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGdldCgpLCBwcm9wKTtcbiAgICAgIH0sXG4gICAgICBnZXRQcm90b3R5cGVPZigpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihnZXQoKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb3h5O1xuICB9LFxuICAvKipcbiAgICogVGhpcyBpcyBhIHNwZWNpYWwgaGVscGVyIGZ1bmN0aW9uIGZvciBjb252ZW5pZW50bHkgY3JlYXRpbmcge0BsaW5rIFNjaGVkdWxlQXR9IHR5cGUgY29sdW1ucy5cbiAgICogQHJldHVybnMgQSBuZXcgQ29sdW1uQnVpbGRlciBpbnN0YW5jZSB3aXRoIHRoZSB7QGxpbmsgU2NoZWR1bGVBdH0gdHlwZS5cbiAgICovXG4gIHNjaGVkdWxlQXQ6ICgpID0+IHtcbiAgICByZXR1cm4gbmV3IFNjaGVkdWxlQXRCdWlsZGVyKCk7XG4gIH0sXG4gIC8qKlxuICAgKiBUaGlzIGlzIGEgY29udmVuaWVuY2UgbWV0aG9kIGZvciBjcmVhdGluZyBhIGNvbHVtbiB3aXRoIHRoZSB7QGxpbmsgT3B0aW9ufSB0eXBlLlxuICAgKiBZb3UgY2FuIGNyZWF0ZSBhIGNvbHVtbiBvZiB0aGUgc2FtZSB0eXBlIGJ5IGNvbnN0cnVjdGluZyBhbiBlbnVtIHdpdGggYSBgc29tZWAgYW5kIGBub25lYCB2YXJpYW50LlxuICAgKiBAcGFyYW0gdmFsdWUgVGhlIHR5cGUgb2YgdGhlIHZhbHVlIGNvbnRhaW5lZCBpbiB0aGUgYHNvbWVgIHZhcmlhbnQgb2YgdGhlIGBPcHRpb25gLlxuICAgKiBAcmV0dXJucyBBIG5ldyB7QGxpbmsgT3B0aW9uQnVpbGRlcn0gaW5zdGFuY2Ugd2l0aCB0aGUge0BsaW5rIE9wdGlvbn0gdHlwZS5cbiAgICovXG4gIG9wdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgT3B0aW9uQnVpbGRlcih2YWx1ZSk7XG4gIH0sXG4gIC8qKlxuICAgKiBUaGlzIGlzIGEgY29udmVuaWVuY2UgbWV0aG9kIGZvciBjcmVhdGluZyBhIGNvbHVtbiB3aXRoIHRoZSB7QGxpbmsgUmVzdWx0fSB0eXBlLlxuICAgKiBZb3UgY2FuIGNyZWF0ZSBhIGNvbHVtbiBvZiB0aGUgc2FtZSB0eXBlIGJ5IGNvbnN0cnVjdGluZyBhbiBlbnVtIHdpdGggYW4gYG9rYCBhbmQgYGVycmAgdmFyaWFudC5cbiAgICogQHBhcmFtIG9rIFRoZSB0eXBlIG9mIHRoZSB2YWx1ZSBjb250YWluZWQgaW4gdGhlIGBva2AgdmFyaWFudCBvZiB0aGUgYFJlc3VsdGAuXG4gICAqIEBwYXJhbSBlcnIgVGhlIHR5cGUgb2YgdGhlIHZhbHVlIGNvbnRhaW5lZCBpbiB0aGUgYGVycmAgdmFyaWFudCBvZiB0aGUgYFJlc3VsdGAuXG4gICAqIEByZXR1cm5zIEEgbmV3IHtAbGluayBSZXN1bHRCdWlsZGVyfSBpbnN0YW5jZSB3aXRoIHRoZSB7QGxpbmsgUmVzdWx0fSB0eXBlLlxuICAgKi9cbiAgcmVzdWx0KG9rLCBlcnIpIHtcbiAgICByZXR1cm4gbmV3IFJlc3VsdEJ1aWxkZXIob2ssIGVycik7XG4gIH0sXG4gIC8qKlxuICAgKiBUaGlzIGlzIGEgY29udmVuaWVuY2UgbWV0aG9kIGZvciBjcmVhdGluZyBhIGNvbHVtbiB3aXRoIHRoZSB7QGxpbmsgSWRlbnRpdHl9IHR5cGUuXG4gICAqIFlvdSBjYW4gY3JlYXRlIGEgY29sdW1uIG9mIHRoZSBzYW1lIHR5cGUgYnkgY29uc3RydWN0aW5nIGFuIGBvYmplY3RgIHdpdGggYSBzaW5nbGUgYF9faWRlbnRpdHlfX2AgZWxlbWVudC5cbiAgICogQHJldHVybnMgQSBuZXcge0BsaW5rIFR5cGVCdWlsZGVyfSBpbnN0YW5jZSB3aXRoIHRoZSB7QGxpbmsgSWRlbnRpdHl9IHR5cGUuXG4gICAqL1xuICBpZGVudGl0eTogKCkgPT4ge1xuICAgIHJldHVybiBuZXcgSWRlbnRpdHlCdWlsZGVyKCk7XG4gIH0sXG4gIC8qKlxuICAgKiBUaGlzIGlzIGEgY29udmVuaWVuY2UgbWV0aG9kIGZvciBjcmVhdGluZyBhIGNvbHVtbiB3aXRoIHRoZSB7QGxpbmsgQ29ubmVjdGlvbklkfSB0eXBlLlxuICAgKiBZb3UgY2FuIGNyZWF0ZSBhIGNvbHVtbiBvZiB0aGUgc2FtZSB0eXBlIGJ5IGNvbnN0cnVjdGluZyBhbiBgb2JqZWN0YCB3aXRoIGEgc2luZ2xlIGBfX2Nvbm5lY3Rpb25faWRfX2AgZWxlbWVudC5cbiAgICogQHJldHVybnMgQSBuZXcge0BsaW5rIFR5cGVCdWlsZGVyfSBpbnN0YW5jZSB3aXRoIHRoZSB7QGxpbmsgQ29ubmVjdGlvbklkfSB0eXBlLlxuICAgKi9cbiAgY29ubmVjdGlvbklkOiAoKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBDb25uZWN0aW9uSWRCdWlsZGVyKCk7XG4gIH0sXG4gIC8qKlxuICAgKiBUaGlzIGlzIGEgY29udmVuaWVuY2UgbWV0aG9kIGZvciBjcmVhdGluZyBhIGNvbHVtbiB3aXRoIHRoZSB7QGxpbmsgVGltZXN0YW1wfSB0eXBlLlxuICAgKiBZb3UgY2FuIGNyZWF0ZSBhIGNvbHVtbiBvZiB0aGUgc2FtZSB0eXBlIGJ5IGNvbnN0cnVjdGluZyBhbiBgb2JqZWN0YCB3aXRoIGEgc2luZ2xlIGBfX3RpbWVzdGFtcF9taWNyb3Nfc2luY2VfdW5peF9lcG9jaF9fYCBlbGVtZW50LlxuICAgKiBAcmV0dXJucyBBIG5ldyB7QGxpbmsgVHlwZUJ1aWxkZXJ9IGluc3RhbmNlIHdpdGggdGhlIHtAbGluayBUaW1lc3RhbXB9IHR5cGUuXG4gICAqL1xuICB0aW1lc3RhbXA6ICgpID0+IHtcbiAgICByZXR1cm4gbmV3IFRpbWVzdGFtcEJ1aWxkZXIoKTtcbiAgfSxcbiAgLyoqXG4gICAqIFRoaXMgaXMgYSBjb252ZW5pZW5jZSBtZXRob2QgZm9yIGNyZWF0aW5nIGEgY29sdW1uIHdpdGggdGhlIHtAbGluayBUaW1lRHVyYXRpb259IHR5cGUuXG4gICAqIFlvdSBjYW4gY3JlYXRlIGEgY29sdW1uIG9mIHRoZSBzYW1lIHR5cGUgYnkgY29uc3RydWN0aW5nIGFuIGBvYmplY3RgIHdpdGggYSBzaW5nbGUgYF9fdGltZV9kdXJhdGlvbl9taWNyb3NfX2AgZWxlbWVudC5cbiAgICogQHJldHVybnMgQSBuZXcge0BsaW5rIFR5cGVCdWlsZGVyfSBpbnN0YW5jZSB3aXRoIHRoZSB7QGxpbmsgVGltZUR1cmF0aW9ufSB0eXBlLlxuICAgKi9cbiAgdGltZUR1cmF0aW9uOiAoKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBUaW1lRHVyYXRpb25CdWlsZGVyKCk7XG4gIH0sXG4gIC8qKlxuICAgKiBUaGlzIGlzIGEgY29udmVuaWVuY2UgbWV0aG9kIGZvciBjcmVhdGluZyBhIGNvbHVtbiB3aXRoIHRoZSB7QGxpbmsgVXVpZH0gdHlwZS5cbiAgICogWW91IGNhbiBjcmVhdGUgYSBjb2x1bW4gb2YgdGhlIHNhbWUgdHlwZSBieSBjb25zdHJ1Y3RpbmcgYW4gYG9iamVjdGAgd2l0aCBhIHNpbmdsZSBgX191dWlkX19gIGVsZW1lbnQuXG4gICAqIEByZXR1cm5zIEEgbmV3IHtAbGluayBUeXBlQnVpbGRlcn0gaW5zdGFuY2Ugd2l0aCB0aGUge0BsaW5rIFV1aWR9IHR5cGUuXG4gICAqL1xuICB1dWlkOiAoKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBVdWlkQnVpbGRlcigpO1xuICB9LFxuICAvKipcbiAgICogVGhpcyBpcyBhIGNvbnZlbmllbmNlIG1ldGhvZCBmb3IgY3JlYXRpbmcgYSBjb2x1bW4gd2l0aCB0aGUge0BsaW5rIEJ5dGVBcnJheX0gdHlwZS5cbiAgICogWW91IGNhbiBjcmVhdGUgYSBjb2x1bW4gb2YgdGhlIHNhbWUgdHlwZSBieSBjb25zdHJ1Y3RpbmcgYW4gYGFycmF5YCBvZiBgdThgLlxuICAgKiBUaGUgVHlwZVNjcmlwdCByZXByZXNlbnRhdGlvbiBpcyB7QGxpbmsgVWludDhBcnJheX0uXG4gICAqIEByZXR1cm5zIEEgbmV3IHtAbGluayBCeXRlQXJyYXlCdWlsZGVyfSBpbnN0YW5jZSB3aXRoIHRoZSB7QGxpbmsgQnl0ZUFycmF5fSB0eXBlLlxuICAgKi9cbiAgYnl0ZUFycmF5OiAoKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBCeXRlQXJyYXlCdWlsZGVyKCk7XG4gIH1cbn07XG5cbi8vIHNyYy9saWIvYXV0b2dlbi9saWZlY3ljbGVfdHlwZS50c1xudmFyIExpZmVjeWNsZSA9IHQuZW51bShcIkxpZmVjeWNsZVwiLCB7XG4gIEluaXQ6IHQudW5pdCgpLFxuICBPbkNvbm5lY3Q6IHQudW5pdCgpLFxuICBPbkRpc2Nvbm5lY3Q6IHQudW5pdCgpXG59KTtcbnZhciBsaWZlY3ljbGVfdHlwZV9kZWZhdWx0ID0gTGlmZWN5Y2xlO1xuXG4vLyBzcmMvbGliL3JlZHVjZXJzLnRzXG5mdW5jdGlvbiBwdXNoUmVkdWNlcihuYW1lLCBwYXJhbXMsIGZuLCBsaWZlY3ljbGUpIHtcbiAgaWYgKGV4aXN0aW5nUmVkdWNlcnMuaGFzKG5hbWUpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlcmUgaXMgYWxyZWFkeSBhIHJlZHVjZXIgd2l0aCB0aGUgbmFtZSAnJHtuYW1lfSdgKTtcbiAgfVxuICBleGlzdGluZ1JlZHVjZXJzLmFkZChuYW1lKTtcbiAgaWYgKCEocGFyYW1zIGluc3RhbmNlb2YgUm93QnVpbGRlcikpIHtcbiAgICBwYXJhbXMgPSBuZXcgUm93QnVpbGRlcihwYXJhbXMpO1xuICB9XG4gIGlmIChwYXJhbXMudHlwZU5hbWUgPT09IHZvaWQgMCkge1xuICAgIHBhcmFtcy50eXBlTmFtZSA9IHRvUGFzY2FsQ2FzZShuYW1lKTtcbiAgfVxuICBjb25zdCByZWYgPSByZWdpc3RlclR5cGVzUmVjdXJzaXZlbHkocGFyYW1zKTtcbiAgY29uc3QgcGFyYW1zVHlwZSA9IHJlc29sdmVUeXBlKE1PRFVMRV9ERUYudHlwZXNwYWNlLCByZWYpLnZhbHVlO1xuICBNT0RVTEVfREVGLnJlZHVjZXJzLnB1c2goe1xuICAgIG5hbWUsXG4gICAgcGFyYW1zOiBwYXJhbXNUeXBlLFxuICAgIGxpZmVjeWNsZVxuICAgIC8vIDwtIGxpZmVjeWNsZSBmbGFnIGxhbmRzIGhlcmVcbiAgfSk7XG4gIGlmICghZm4ubmFtZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwgXCJuYW1lXCIsIHsgdmFsdWU6IG5hbWUsIHdyaXRhYmxlOiBmYWxzZSB9KTtcbiAgfVxuICBSRURVQ0VSUy5wdXNoKGZuKTtcbn1cbnZhciBleGlzdGluZ1JlZHVjZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbnZhciBSRURVQ0VSUyA9IFtdO1xuZnVuY3Rpb24gcmVkdWNlcihuYW1lLCBwYXJhbXMsIGZuKSB7XG4gIHB1c2hSZWR1Y2VyKG5hbWUsIHBhcmFtcywgZm4pO1xufVxuZnVuY3Rpb24gaW5pdChuYW1lLCBwYXJhbXMsIGZuKSB7XG4gIHB1c2hSZWR1Y2VyKG5hbWUsIHBhcmFtcywgZm4sIGxpZmVjeWNsZV90eXBlX2RlZmF1bHQuSW5pdCk7XG59XG5mdW5jdGlvbiBjbGllbnRDb25uZWN0ZWQobmFtZSwgcGFyYW1zLCBmbikge1xuICBwdXNoUmVkdWNlcihuYW1lLCBwYXJhbXMsIGZuLCBsaWZlY3ljbGVfdHlwZV9kZWZhdWx0Lk9uQ29ubmVjdCk7XG59XG5mdW5jdGlvbiBjbGllbnREaXNjb25uZWN0ZWQobmFtZSwgcGFyYW1zLCBmbikge1xuICBwdXNoUmVkdWNlcihuYW1lLCBwYXJhbXMsIGZuLCBsaWZlY3ljbGVfdHlwZV9kZWZhdWx0Lk9uRGlzY29ubmVjdCk7XG59XG52YXIgUmVkdWNlcnMgPSBjbGFzcyB7XG4gIHJlZHVjZXJzVHlwZTtcbiAgY29uc3RydWN0b3IoaGFuZGxlcykge1xuICAgIHRoaXMucmVkdWNlcnNUeXBlID0gcmVkdWNlcnNUb1NjaGVtYShoYW5kbGVzKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHJlZHVjZXJzVG9TY2hlbWEocmVkdWNlcnMyKSB7XG4gIGNvbnN0IG1hcHBlZCA9IHJlZHVjZXJzMi5tYXAoKHIpID0+IHtcbiAgICBjb25zdCBwYXJhbXNSb3cgPSByLnBhcmFtcy5yb3c7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHIucmVkdWNlck5hbWUsXG4gICAgICAvLyBQcmVmZXIgdGhlIHNjaGVtYSdzIG93biBhY2Nlc3Nvck5hbWUgaWYgcHJlc2VudCBhdCBydW50aW1lOyBvdGhlcndpc2UgZGVyaXZlIGl0LlxuICAgICAgYWNjZXNzb3JOYW1lOiByLmFjY2Vzc29yTmFtZSxcbiAgICAgIHBhcmFtczogcGFyYW1zUm93LFxuICAgICAgcGFyYW1zVHlwZTogci5wYXJhbXNTcGFjZXRpbWVUeXBlXG4gICAgfTtcbiAgfSk7XG4gIGNvbnN0IHJlc3VsdCA9IHsgcmVkdWNlcnM6IG1hcHBlZCB9O1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcmVkdWNlcnMoLi4uYXJncykge1xuICBjb25zdCBoYW5kbGVzID0gYXJncy5sZW5ndGggPT09IDEgJiYgQXJyYXkuaXNBcnJheShhcmdzWzBdKSA/IGFyZ3NbMF0gOiBhcmdzO1xuICByZXR1cm4gbmV3IFJlZHVjZXJzKGhhbmRsZXMpO1xufVxuXG4vLyBzcmMvc2VydmVyL3F1ZXJ5LnRzXG52YXIgUXVlcnlCcmFuZCA9IFN5bWJvbChcIlF1ZXJ5QnJhbmRcIik7XG52YXIgaXNSb3dUeXBlZFF1ZXJ5ID0gKHZhbCkgPT4gISF2YWwgJiYgdHlwZW9mIHZhbCA9PT0gXCJvYmplY3RcIiAmJiBRdWVyeUJyYW5kIGluIHZhbDtcbmZ1bmN0aW9uIHRvU3FsKHEpIHtcbiAgcmV0dXJuIHEudG9TcWwoKTtcbn1cbnZhciBTZW1pam9pbkltcGwgPSBjbGFzcyBfU2VtaWpvaW5JbXBsIHtcbiAgY29uc3RydWN0b3Ioc291cmNlUXVlcnksIGZpbHRlclF1ZXJ5LCBqb2luQ29uZGl0aW9uKSB7XG4gICAgdGhpcy5zb3VyY2VRdWVyeSA9IHNvdXJjZVF1ZXJ5O1xuICAgIHRoaXMuZmlsdGVyUXVlcnkgPSBmaWx0ZXJRdWVyeTtcbiAgICB0aGlzLmpvaW5Db25kaXRpb24gPSBqb2luQ29uZGl0aW9uO1xuICAgIGlmIChzb3VyY2VRdWVyeS50YWJsZS5uYW1lID09PSBmaWx0ZXJRdWVyeS50YWJsZS5uYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2VtaWpvaW4gYSB0YWJsZSB0byBpdHNlbGZcIik7XG4gICAgfVxuICB9XG4gIFtRdWVyeUJyYW5kXSA9IHRydWU7XG4gIHR5cGUgPSBcInNlbWlqb2luXCI7XG4gIGJ1aWxkKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHdoZXJlKHByZWRpY2F0ZSkge1xuICAgIGNvbnN0IG5leHRTb3VyY2VRdWVyeSA9IHRoaXMuc291cmNlUXVlcnkud2hlcmUocHJlZGljYXRlKTtcbiAgICByZXR1cm4gbmV3IF9TZW1pam9pbkltcGwoXG4gICAgICBuZXh0U291cmNlUXVlcnksXG4gICAgICB0aGlzLmZpbHRlclF1ZXJ5LFxuICAgICAgdGhpcy5qb2luQ29uZGl0aW9uXG4gICAgKTtcbiAgfVxuICB0b1NxbCgpIHtcbiAgICBjb25zdCBsZWZ0ID0gdGhpcy5maWx0ZXJRdWVyeTtcbiAgICBjb25zdCByaWdodCA9IHRoaXMuc291cmNlUXVlcnk7XG4gICAgY29uc3QgbGVmdFRhYmxlID0gcXVvdGVJZGVudGlmaWVyKGxlZnQudGFibGUubmFtZSk7XG4gICAgY29uc3QgcmlnaHRUYWJsZSA9IHF1b3RlSWRlbnRpZmllcihyaWdodC50YWJsZS5uYW1lKTtcbiAgICBsZXQgc3FsID0gYFNFTEVDVCAke3JpZ2h0VGFibGV9LiogRlJPTSAke2xlZnRUYWJsZX0gSk9JTiAke3JpZ2h0VGFibGV9IE9OICR7Ym9vbGVhbkV4cHJUb1NxbCh0aGlzLmpvaW5Db25kaXRpb24pfWA7XG4gICAgY29uc3QgY2xhdXNlcyA9IFtdO1xuICAgIGlmIChsZWZ0LndoZXJlQ2xhdXNlKSB7XG4gICAgICBjbGF1c2VzLnB1c2goYm9vbGVhbkV4cHJUb1NxbChsZWZ0LndoZXJlQ2xhdXNlKSk7XG4gICAgfVxuICAgIGlmIChyaWdodC53aGVyZUNsYXVzZSkge1xuICAgICAgY2xhdXNlcy5wdXNoKGJvb2xlYW5FeHByVG9TcWwocmlnaHQud2hlcmVDbGF1c2UpKTtcbiAgICB9XG4gICAgaWYgKGNsYXVzZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3Qgd2hlcmVTcWwgPSBjbGF1c2VzLmxlbmd0aCA9PT0gMSA/IGNsYXVzZXNbMF0gOiBjbGF1c2VzLm1hcCh3cmFwSW5QYXJlbnMpLmpvaW4oXCIgQU5EIFwiKTtcbiAgICAgIHNxbCArPSBgIFdIRVJFICR7d2hlcmVTcWx9YDtcbiAgICB9XG4gICAgcmV0dXJuIHNxbDtcbiAgfVxufTtcbnZhciBGcm9tQnVpbGRlciA9IGNsYXNzIF9Gcm9tQnVpbGRlciB7XG4gIGNvbnN0cnVjdG9yKHRhYmxlMiwgd2hlcmVDbGF1c2UpIHtcbiAgICB0aGlzLnRhYmxlID0gdGFibGUyO1xuICAgIHRoaXMud2hlcmVDbGF1c2UgPSB3aGVyZUNsYXVzZTtcbiAgfVxuICBbUXVlcnlCcmFuZF0gPSB0cnVlO1xuICB3aGVyZShwcmVkaWNhdGUpIHtcbiAgICBjb25zdCBuZXdDb25kaXRpb24gPSBwcmVkaWNhdGUodGhpcy50YWJsZS5jb2xzKTtcbiAgICBjb25zdCBuZXh0V2hlcmUgPSB0aGlzLndoZXJlQ2xhdXNlID8gYW5kKHRoaXMud2hlcmVDbGF1c2UsIG5ld0NvbmRpdGlvbikgOiBuZXdDb25kaXRpb247XG4gICAgcmV0dXJuIG5ldyBfRnJvbUJ1aWxkZXIodGhpcy50YWJsZSwgbmV4dFdoZXJlKTtcbiAgfVxuICByaWdodFNlbWlqb2luKHJpZ2h0LCBvbikge1xuICAgIGNvbnN0IHNvdXJjZVF1ZXJ5ID0gbmV3IF9Gcm9tQnVpbGRlcihyaWdodCk7XG4gICAgY29uc3Qgam9pbkNvbmRpdGlvbiA9IG9uKFxuICAgICAgdGhpcy50YWJsZS5pbmRleGVkQ29scyxcbiAgICAgIHJpZ2h0LmluZGV4ZWRDb2xzXG4gICAgKTtcbiAgICByZXR1cm4gbmV3IFNlbWlqb2luSW1wbChzb3VyY2VRdWVyeSwgdGhpcywgam9pbkNvbmRpdGlvbik7XG4gIH1cbiAgbGVmdFNlbWlqb2luKHJpZ2h0LCBvbikge1xuICAgIGNvbnN0IGZpbHRlclF1ZXJ5ID0gbmV3IF9Gcm9tQnVpbGRlcihyaWdodCk7XG4gICAgY29uc3Qgam9pbkNvbmRpdGlvbiA9IG9uKFxuICAgICAgdGhpcy50YWJsZS5pbmRleGVkQ29scyxcbiAgICAgIHJpZ2h0LmluZGV4ZWRDb2xzXG4gICAgKTtcbiAgICByZXR1cm4gbmV3IFNlbWlqb2luSW1wbCh0aGlzLCBmaWx0ZXJRdWVyeSwgam9pbkNvbmRpdGlvbik7XG4gIH1cbiAgdG9TcWwoKSB7XG4gICAgcmV0dXJuIHJlbmRlclNlbGVjdFNxbFdpdGhKb2lucyh0aGlzLnRhYmxlLCB0aGlzLndoZXJlQ2xhdXNlKTtcbiAgfVxuICBidWlsZCgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcbnZhciBUYWJsZVJlZkltcGwgPSBjbGFzcyB7XG4gIHR5cGUgPSBcInRhYmxlXCI7XG4gIG5hbWU7XG4gIGNvbHM7XG4gIGluZGV4ZWRDb2xzO1xuICB0YWJsZURlZjtcbiAgY29uc3RydWN0b3IodGFibGVEZWYpIHtcbiAgICB0aGlzLm5hbWUgPSB0YWJsZURlZi5uYW1lO1xuICAgIHRoaXMuY29scyA9IGNyZWF0ZVJvd0V4cHIodGFibGVEZWYpO1xuICAgIHRoaXMuaW5kZXhlZENvbHMgPSB0aGlzLmNvbHM7XG4gICAgdGhpcy50YWJsZURlZiA9IHRhYmxlRGVmO1xuICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gIH1cbiAgYXNGcm9tKCkge1xuICAgIHJldHVybiBuZXcgRnJvbUJ1aWxkZXIodGhpcyk7XG4gIH1cbiAgcmlnaHRTZW1pam9pbihvdGhlciwgb24pIHtcbiAgICByZXR1cm4gdGhpcy5hc0Zyb20oKS5yaWdodFNlbWlqb2luKG90aGVyLCBvbik7XG4gIH1cbiAgbGVmdFNlbWlqb2luKG90aGVyLCBvbikge1xuICAgIHJldHVybiB0aGlzLmFzRnJvbSgpLmxlZnRTZW1pam9pbihvdGhlciwgb24pO1xuICB9XG4gIGJ1aWxkKCkge1xuICAgIHJldHVybiB0aGlzLmFzRnJvbSgpLmJ1aWxkKCk7XG4gIH1cbiAgdG9TcWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXNGcm9tKCkudG9TcWwoKTtcbiAgfVxuICB3aGVyZShwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5hc0Zyb20oKS53aGVyZShwcmVkaWNhdGUpO1xuICB9XG59O1xuZnVuY3Rpb24gY3JlYXRlVGFibGVSZWZGcm9tRGVmKHRhYmxlRGVmKSB7XG4gIHJldHVybiBuZXcgVGFibGVSZWZJbXBsKHRhYmxlRGVmKTtcbn1cbmZ1bmN0aW9uIG1ha2VRdWVyeUJ1aWxkZXIoc2NoZW1hMikge1xuICBjb25zdCBxYiA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBmb3IgKGNvbnN0IHRhYmxlMiBvZiBzY2hlbWEyLnRhYmxlcykge1xuICAgIGNvbnN0IHJlZiA9IGNyZWF0ZVRhYmxlUmVmRnJvbURlZihcbiAgICAgIHRhYmxlMlxuICAgICk7XG4gICAgcWJbdGFibGUyLm5hbWVdID0gcmVmO1xuICB9XG4gIHJldHVybiBPYmplY3QuZnJlZXplKHFiKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJvd0V4cHIodGFibGVEZWYpIHtcbiAgY29uc3Qgcm93ID0ge307XG4gIGZvciAoY29uc3QgY29sdW1uTmFtZSBvZiBPYmplY3Qua2V5cyh0YWJsZURlZi5jb2x1bW5zKSkge1xuICAgIGNvbnN0IGNvbHVtbkJ1aWxkZXIgPSB0YWJsZURlZi5jb2x1bW5zW2NvbHVtbk5hbWVdO1xuICAgIGNvbnN0IGNvbHVtbiA9IG5ldyBDb2x1bW5FeHByZXNzaW9uKFxuICAgICAgdGFibGVEZWYubmFtZSxcbiAgICAgIGNvbHVtbk5hbWUsXG4gICAgICBjb2x1bW5CdWlsZGVyLnR5cGVCdWlsZGVyLmFsZ2VicmFpY1R5cGVcbiAgICApO1xuICAgIHJvd1tjb2x1bW5OYW1lXSA9IE9iamVjdC5mcmVlemUoY29sdW1uKTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShyb3cpO1xufVxuZnVuY3Rpb24gcmVuZGVyU2VsZWN0U3FsV2l0aEpvaW5zKHRhYmxlMiwgd2hlcmUsIGV4dHJhQ2xhdXNlcyA9IFtdKSB7XG4gIGNvbnN0IHF1b3RlZFRhYmxlID0gcXVvdGVJZGVudGlmaWVyKHRhYmxlMi5uYW1lKTtcbiAgY29uc3Qgc3FsID0gYFNFTEVDVCAqIEZST00gJHtxdW90ZWRUYWJsZX1gO1xuICBjb25zdCBjbGF1c2VzID0gW107XG4gIGlmICh3aGVyZSkgY2xhdXNlcy5wdXNoKGJvb2xlYW5FeHByVG9TcWwod2hlcmUpKTtcbiAgY2xhdXNlcy5wdXNoKC4uLmV4dHJhQ2xhdXNlcyk7XG4gIGlmIChjbGF1c2VzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHNxbDtcbiAgY29uc3Qgd2hlcmVTcWwgPSBjbGF1c2VzLmxlbmd0aCA9PT0gMSA/IGNsYXVzZXNbMF0gOiBjbGF1c2VzLm1hcCh3cmFwSW5QYXJlbnMpLmpvaW4oXCIgQU5EIFwiKTtcbiAgcmV0dXJuIGAke3NxbH0gV0hFUkUgJHt3aGVyZVNxbH1gO1xufVxudmFyIENvbHVtbkV4cHJlc3Npb24gPSBjbGFzcyB7XG4gIHR5cGUgPSBcImNvbHVtblwiO1xuICBjb2x1bW47XG4gIHRhYmxlO1xuICAvLyBwaGFudG9tOiBhY3R1YWwgcnVudGltZSB2YWx1ZSBpcyB1bmRlZmluZWRcbiAgdHNWYWx1ZVR5cGU7XG4gIHNwYWNldGltZVR5cGU7XG4gIGNvbnN0cnVjdG9yKHRhYmxlMiwgY29sdW1uLCBzcGFjZXRpbWVUeXBlKSB7XG4gICAgdGhpcy50YWJsZSA9IHRhYmxlMjtcbiAgICB0aGlzLmNvbHVtbiA9IGNvbHVtbjtcbiAgICB0aGlzLnNwYWNldGltZVR5cGUgPSBzcGFjZXRpbWVUeXBlO1xuICB9XG4gIC8vIFRoZXNlIHR5cGVzIGNvdWxkIGJlIHRpZ2h0ZWQsIGJ1dCBzaW5jZSB3ZSBkZWNsYXJlIHRoZSBvdmVybG9hZHMgYWJvdmUsIGl0IGRvZXNuJ3Qgd2Vha2VuIHRoZSBBUEkgc3VyZmFjZS5cbiAgZXEoeCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImVxXCIsXG4gICAgICBsZWZ0OiB0aGlzLFxuICAgICAgcmlnaHQ6IG5vcm1hbGl6ZVZhbHVlKHgpXG4gICAgfTtcbiAgfVxuICAvLyBUaGVzZSB0eXBlcyBjb3VsZCBiZSB0aWdodGVkLCBidXQgc2luY2Ugd2UgZGVjbGFyZSB0aGUgb3ZlcmxvYWRzIGFib3ZlLCBpdCBkb2Vzbid0IHdlYWtlbiB0aGUgQVBJIHN1cmZhY2UuXG4gIGx0KHgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJsdFwiLFxuICAgICAgbGVmdDogdGhpcyxcbiAgICAgIHJpZ2h0OiBub3JtYWxpemVWYWx1ZSh4KVxuICAgIH07XG4gIH1cbiAgLy8gVGhlc2UgdHlwZXMgY291bGQgYmUgdGlnaHRlZCwgYnV0IHNpbmNlIHdlIGRlY2xhcmUgdGhlIG92ZXJsb2FkcyBhYm92ZSwgaXQgZG9lc24ndCB3ZWFrZW4gdGhlIEFQSSBzdXJmYWNlLlxuICBsdGUoeCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImx0ZVwiLFxuICAgICAgbGVmdDogdGhpcyxcbiAgICAgIHJpZ2h0OiBub3JtYWxpemVWYWx1ZSh4KVxuICAgIH07XG4gIH1cbiAgLy8gVGhlc2UgdHlwZXMgY291bGQgYmUgdGlnaHRlZCwgYnV0IHNpbmNlIHdlIGRlY2xhcmUgdGhlIG92ZXJsb2FkcyBhYm92ZSwgaXQgZG9lc24ndCB3ZWFrZW4gdGhlIEFQSSBzdXJmYWNlLlxuICBndCh4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZ3RcIixcbiAgICAgIGxlZnQ6IHRoaXMsXG4gICAgICByaWdodDogbm9ybWFsaXplVmFsdWUoeClcbiAgICB9O1xuICB9XG4gIC8vIFRoZXNlIHR5cGVzIGNvdWxkIGJlIHRpZ2h0ZWQsIGJ1dCBzaW5jZSB3ZSBkZWNsYXJlIHRoZSBvdmVybG9hZHMgYWJvdmUsIGl0IGRvZXNuJ3Qgd2Vha2VuIHRoZSBBUEkgc3VyZmFjZS5cbiAgZ3RlKHgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJndGVcIixcbiAgICAgIGxlZnQ6IHRoaXMsXG4gICAgICByaWdodDogbm9ybWFsaXplVmFsdWUoeClcbiAgICB9O1xuICB9XG59O1xuZnVuY3Rpb24gbGl0ZXJhbCh2YWx1ZSkge1xuICByZXR1cm4geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWUgfTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVZhbHVlKHZhbCkge1xuICBpZiAodmFsLnR5cGUgPT09IFwibGl0ZXJhbFwiKVxuICAgIHJldHVybiB2YWw7XG4gIGlmICh0eXBlb2YgdmFsID09PSBcIm9iamVjdFwiICYmIHZhbCAhPSBudWxsICYmIFwidHlwZVwiIGluIHZhbCAmJiB2YWwudHlwZSA9PT0gXCJjb2x1bW5cIikge1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgcmV0dXJuIGxpdGVyYWwodmFsKTtcbn1cbmZ1bmN0aW9uIG5vdChjbGF1c2UpIHtcbiAgcmV0dXJuIHsgdHlwZTogXCJub3RcIiwgY2xhdXNlIH07XG59XG5mdW5jdGlvbiBhbmQoLi4uY2xhdXNlcykge1xuICByZXR1cm4geyB0eXBlOiBcImFuZFwiLCBjbGF1c2VzIH07XG59XG5mdW5jdGlvbiBvciguLi5jbGF1c2VzKSB7XG4gIHJldHVybiB7IHR5cGU6IFwib3JcIiwgY2xhdXNlcyB9O1xufVxuZnVuY3Rpb24gYm9vbGVhbkV4cHJUb1NxbChleHByLCB0YWJsZUFsaWFzKSB7XG4gIHN3aXRjaCAoZXhwci50eXBlKSB7XG4gICAgY2FzZSBcImVxXCI6XG4gICAgICByZXR1cm4gYCR7dmFsdWVFeHByVG9TcWwoZXhwci5sZWZ0KX0gPSAke3ZhbHVlRXhwclRvU3FsKGV4cHIucmlnaHQpfWA7XG4gICAgY2FzZSBcIm5lXCI6XG4gICAgICByZXR1cm4gYCR7dmFsdWVFeHByVG9TcWwoZXhwci5sZWZ0KX0gPD4gJHt2YWx1ZUV4cHJUb1NxbChleHByLnJpZ2h0KX1gO1xuICAgIGNhc2UgXCJndFwiOlxuICAgICAgcmV0dXJuIGAke3ZhbHVlRXhwclRvU3FsKGV4cHIubGVmdCl9ID4gJHt2YWx1ZUV4cHJUb1NxbChleHByLnJpZ2h0KX1gO1xuICAgIGNhc2UgXCJndGVcIjpcbiAgICAgIHJldHVybiBgJHt2YWx1ZUV4cHJUb1NxbChleHByLmxlZnQpfSA+PSAke3ZhbHVlRXhwclRvU3FsKGV4cHIucmlnaHQpfWA7XG4gICAgY2FzZSBcImx0XCI6XG4gICAgICByZXR1cm4gYCR7dmFsdWVFeHByVG9TcWwoZXhwci5sZWZ0KX0gPCAke3ZhbHVlRXhwclRvU3FsKGV4cHIucmlnaHQpfWA7XG4gICAgY2FzZSBcImx0ZVwiOlxuICAgICAgcmV0dXJuIGAke3ZhbHVlRXhwclRvU3FsKGV4cHIubGVmdCl9IDw9ICR7dmFsdWVFeHByVG9TcWwoZXhwci5yaWdodCl9YDtcbiAgICBjYXNlIFwiYW5kXCI6XG4gICAgICByZXR1cm4gZXhwci5jbGF1c2VzLm1hcCgoYykgPT4gYm9vbGVhbkV4cHJUb1NxbChjKSkubWFwKHdyYXBJblBhcmVucykuam9pbihcIiBBTkQgXCIpO1xuICAgIGNhc2UgXCJvclwiOlxuICAgICAgcmV0dXJuIGV4cHIuY2xhdXNlcy5tYXAoKGMpID0+IGJvb2xlYW5FeHByVG9TcWwoYykpLm1hcCh3cmFwSW5QYXJlbnMpLmpvaW4oXCIgT1IgXCIpO1xuICAgIGNhc2UgXCJub3RcIjpcbiAgICAgIHJldHVybiBgTk9UICR7d3JhcEluUGFyZW5zKGJvb2xlYW5FeHByVG9TcWwoZXhwci5jbGF1c2UpKX1gO1xuICB9XG59XG5mdW5jdGlvbiB3cmFwSW5QYXJlbnMoc3FsKSB7XG4gIHJldHVybiBgKCR7c3FsfSlgO1xufVxuZnVuY3Rpb24gdmFsdWVFeHByVG9TcWwoZXhwciwgdGFibGVBbGlhcykge1xuICBpZiAoaXNMaXRlcmFsRXhwcihleHByKSkge1xuICAgIHJldHVybiBsaXRlcmFsVmFsdWVUb1NxbChleHByLnZhbHVlKTtcbiAgfVxuICBjb25zdCB0YWJsZTIgPSBleHByLnRhYmxlO1xuICByZXR1cm4gYCR7cXVvdGVJZGVudGlmaWVyKHRhYmxlMil9LiR7cXVvdGVJZGVudGlmaWVyKGV4cHIuY29sdW1uKX1gO1xufVxuZnVuY3Rpb24gbGl0ZXJhbFZhbHVlVG9TcWwodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gXCJOVUxMXCI7XG4gIH1cbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgSWRlbnRpdHkgfHwgdmFsdWUgaW5zdGFuY2VvZiBDb25uZWN0aW9uSWQpIHtcbiAgICByZXR1cm4gYDB4JHt2YWx1ZS50b0hleFN0cmluZygpfWA7XG4gIH1cbiAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgY2FzZSBcImJpZ2ludFwiOlxuICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgIHJldHVybiB2YWx1ZSA/IFwiVFJVRVwiIDogXCJGQUxTRVwiO1xuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgIHJldHVybiBgJyR7dmFsdWUucmVwbGFjZSgvJy9nLCBcIicnXCIpfSdgO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gYCcke0pTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC8nL2csIFwiJydcIil9J2A7XG4gIH1cbn1cbmZ1bmN0aW9uIHF1b3RlSWRlbnRpZmllcihuYW1lKSB7XG4gIHJldHVybiBgXCIke25hbWUucmVwbGFjZSgvXCIvZywgJ1wiXCInKX1cImA7XG59XG5mdW5jdGlvbiBpc0xpdGVyYWxFeHByKGV4cHIpIHtcbiAgcmV0dXJuIGV4cHIudHlwZSA9PT0gXCJsaXRlcmFsXCI7XG59XG5cbi8vIHNyYy9saWIvdmlld3MudHNcbmZ1bmN0aW9uIGRlZmluZVZpZXcob3B0cywgYW5vbiwgcGFyYW1zLCByZXQsIGZuKSB7XG4gIGNvbnN0IHBhcmFtc0J1aWxkZXIgPSBuZXcgUm93QnVpbGRlcihwYXJhbXMsIHRvUGFzY2FsQ2FzZShvcHRzLm5hbWUpKTtcbiAgbGV0IHJldHVyblR5cGUgPSByZWdpc3RlclR5cGVzUmVjdXJzaXZlbHkocmV0KS5hbGdlYnJhaWNUeXBlO1xuICBjb25zdCB7IHZhbHVlOiBwYXJhbVR5cGUgfSA9IHJlc29sdmVUeXBlKFxuICAgIE1PRFVMRV9ERUYudHlwZXNwYWNlLFxuICAgIHJlZ2lzdGVyVHlwZXNSZWN1cnNpdmVseShwYXJhbXNCdWlsZGVyKVxuICApO1xuICBNT0RVTEVfREVGLm1pc2NFeHBvcnRzLnB1c2goe1xuICAgIHRhZzogXCJWaWV3XCIsXG4gICAgdmFsdWU6IHtcbiAgICAgIG5hbWU6IG9wdHMubmFtZSxcbiAgICAgIGluZGV4OiAoYW5vbiA/IEFOT05fVklFV1MgOiBWSUVXUykubGVuZ3RoLFxuICAgICAgaXNQdWJsaWM6IG9wdHMucHVibGljLFxuICAgICAgaXNBbm9ueW1vdXM6IGFub24sXG4gICAgICBwYXJhbXM6IHBhcmFtVHlwZSxcbiAgICAgIHJldHVyblR5cGVcbiAgICB9XG4gIH0pO1xuICBpZiAocmV0dXJuVHlwZS50YWcgPT0gXCJTdW1cIikge1xuICAgIGNvbnN0IG9yaWdpbmFsRm4gPSBmbjtcbiAgICBmbiA9ICgoY3R4LCBhcmdzKSA9PiB7XG4gICAgICBjb25zdCByZXQyID0gb3JpZ2luYWxGbihjdHgsIGFyZ3MpO1xuICAgICAgcmV0dXJuIHJldDIgPT0gbnVsbCA/IFtdIDogW3JldDJdO1xuICAgIH0pO1xuICAgIHJldHVyblR5cGUgPSBBbGdlYnJhaWNUeXBlLkFycmF5KFxuICAgICAgcmV0dXJuVHlwZS52YWx1ZS52YXJpYW50c1swXS5hbGdlYnJhaWNUeXBlXG4gICAgKTtcbiAgfVxuICAoYW5vbiA/IEFOT05fVklFV1MgOiBWSUVXUykucHVzaCh7XG4gICAgZm4sXG4gICAgcGFyYW1zOiBwYXJhbVR5cGUsXG4gICAgcmV0dXJuVHlwZSxcbiAgICByZXR1cm5UeXBlQmFzZVNpemU6IGJzYXRuQmFzZVNpemUoTU9EVUxFX0RFRi50eXBlc3BhY2UsIHJldHVyblR5cGUpXG4gIH0pO1xufVxudmFyIFZJRVdTID0gW107XG52YXIgQU5PTl9WSUVXUyA9IFtdO1xuXG4vLyBzcmMvbGliL3Byb2NlZHVyZXMudHNcbmZ1bmN0aW9uIHByb2NlZHVyZShuYW1lLCBwYXJhbXMsIHJldCwgZm4pIHtcbiAgY29uc3QgcGFyYW1zVHlwZSA9IHtcbiAgICBlbGVtZW50czogT2JqZWN0LmVudHJpZXMocGFyYW1zKS5tYXAoKFtuLCBjXSkgPT4gKHtcbiAgICAgIG5hbWU6IG4sXG4gICAgICBhbGdlYnJhaWNUeXBlOiByZWdpc3RlclR5cGVzUmVjdXJzaXZlbHkoXG4gICAgICAgIFwidHlwZUJ1aWxkZXJcIiBpbiBjID8gYy50eXBlQnVpbGRlciA6IGNcbiAgICAgICkuYWxnZWJyYWljVHlwZVxuICAgIH0pKVxuICB9O1xuICBjb25zdCByZXR1cm5UeXBlID0gcmVnaXN0ZXJUeXBlc1JlY3Vyc2l2ZWx5KHJldCkuYWxnZWJyYWljVHlwZTtcbiAgTU9EVUxFX0RFRi5taXNjRXhwb3J0cy5wdXNoKHtcbiAgICB0YWc6IFwiUHJvY2VkdXJlXCIsXG4gICAgdmFsdWU6IHtcbiAgICAgIG5hbWUsXG4gICAgICBwYXJhbXM6IHBhcmFtc1R5cGUsXG4gICAgICByZXR1cm5UeXBlXG4gICAgfVxuICB9KTtcbiAgUFJPQ0VEVVJFUy5wdXNoKHtcbiAgICBmbixcbiAgICBwYXJhbXNUeXBlLFxuICAgIHJldHVyblR5cGUsXG4gICAgcmV0dXJuVHlwZUJhc2VTaXplOiBic2F0bkJhc2VTaXplKE1PRFVMRV9ERUYudHlwZXNwYWNlLCByZXR1cm5UeXBlKVxuICB9KTtcbn1cbnZhciBQUk9DRURVUkVTID0gW107XG5cbi8vIHNyYy9saWIvc2NoZW1hLnRzXG52YXIgUkVHSVNURVJFRF9TQ0hFTUEgPSBudWxsO1xuZnVuY3Rpb24gZ2V0UmVnaXN0ZXJlZFNjaGVtYSgpIHtcbiAgaWYgKFJFR0lTVEVSRURfU0NIRU1BID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTY2hlbWEgaGFzIG5vdCBiZWVuIHJlZ2lzdGVyZWQgeWV0LiBDYWxsIHNjaGVtYSgpIGZpcnN0LlwiKTtcbiAgfVxuICByZXR1cm4gUkVHSVNURVJFRF9TQ0hFTUE7XG59XG5mdW5jdGlvbiB0YWJsZXNUb1NjaGVtYSh0YWJsZXMpIHtcbiAgcmV0dXJuIHsgdGFibGVzOiB0YWJsZXMubWFwKHRhYmxlVG9TY2hlbWEpIH07XG59XG5mdW5jdGlvbiB0YWJsZVRvU2NoZW1hKHNjaGVtYTIpIHtcbiAgY29uc3QgZ2V0Q29sTmFtZSA9IChpKSA9PiBzY2hlbWEyLnJvd1R5cGUuYWxnZWJyYWljVHlwZS52YWx1ZS5lbGVtZW50c1tpXS5uYW1lO1xuICByZXR1cm4ge1xuICAgIG5hbWU6IHNjaGVtYTIudGFibGVOYW1lLFxuICAgIGFjY2Vzc29yTmFtZTogdG9DYW1lbENhc2Uoc2NoZW1hMi50YWJsZU5hbWUpLFxuICAgIGNvbHVtbnM6IHNjaGVtYTIucm93VHlwZS5yb3csXG4gICAgLy8gdHlwZWQgYXMgVFtpXVsncm93VHlwZSddWydyb3cnXSB1bmRlciBUYWJsZXNUb1NjaGVtYTxUPlxuICAgIHJvd1R5cGU6IHNjaGVtYTIucm93U3BhY2V0aW1lVHlwZSxcbiAgICBjb25zdHJhaW50czogc2NoZW1hMi50YWJsZURlZi5jb25zdHJhaW50cy5tYXAoKGMpID0+ICh7XG4gICAgICBuYW1lOiBjLm5hbWUsXG4gICAgICBjb25zdHJhaW50OiBcInVuaXF1ZVwiLFxuICAgICAgY29sdW1uczogYy5kYXRhLnZhbHVlLmNvbHVtbnMubWFwKGdldENvbE5hbWUpXG4gICAgfSkpLFxuICAgIC8vIFRPRE86IGhvcnJpYmxlIGhvcnJpYmxlIGhvcnJpYmxlLiB3ZSBzbXVnZ2xlIHRoaXMgYEFycmF5PFVudHlwZWRJbmRleD5gXG4gICAgLy8gYnkgY2FzdGluZyBpdCB0byBhbiBgQXJyYXk8SW5kZXhPcHRzPmAgYXMgYFRhYmxlVG9TY2hlbWFgIGV4cGVjdHMuXG4gICAgLy8gVGhpcyBpcyB0aGVuIHVzZWQgaW4gYFRhYmxlQ2FjaGVJbXBsLmNvbnN0cnVjdG9yYCBhbmQgd2hvIGtub3dzIHdoZXJlIGVsc2UuXG4gICAgLy8gV2Ugc2hvdWxkIHN0b3AgbHlpbmcgYWJvdXQgb3VyIHR5cGVzLlxuICAgIGluZGV4ZXM6IHNjaGVtYTIudGFibGVEZWYuaW5kZXhlcy5tYXAoKGlkeCkgPT4ge1xuICAgICAgY29uc3QgY29sdW1uSWRzID0gaWR4LmFsZ29yaXRobS50YWcgPT09IFwiRGlyZWN0XCIgPyBbaWR4LmFsZ29yaXRobS52YWx1ZV0gOiBpZHguYWxnb3JpdGhtLnZhbHVlO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogaWR4LmFjY2Vzc29yTmFtZSxcbiAgICAgICAgdW5pcXVlOiBzY2hlbWEyLnRhYmxlRGVmLmNvbnN0cmFpbnRzLnNvbWUoXG4gICAgICAgICAgKGMpID0+IGMuZGF0YS52YWx1ZS5jb2x1bW5zLmV2ZXJ5KChjb2wpID0+IGNvbHVtbklkcy5pbmNsdWRlcyhjb2wpKVxuICAgICAgICApLFxuICAgICAgICBhbGdvcml0aG06IGlkeC5hbGdvcml0aG0udGFnLnRvTG93ZXJDYXNlKCksXG4gICAgICAgIGNvbHVtbnM6IGNvbHVtbklkcy5tYXAoZ2V0Q29sTmFtZSlcbiAgICAgIH07XG4gICAgfSlcbiAgfTtcbn1cbnZhciBNT0RVTEVfREVGID0ge1xuICB0eXBlc3BhY2U6IHsgdHlwZXM6IFtdIH0sXG4gIHRhYmxlczogW10sXG4gIHJlZHVjZXJzOiBbXSxcbiAgdHlwZXM6IFtdLFxuICBtaXNjRXhwb3J0czogW10sXG4gIHJvd0xldmVsU2VjdXJpdHk6IFtdXG59O1xudmFyIENPTVBPVU5EX1RZUEVTID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbmZ1bmN0aW9uIHJlc29sdmVUeXBlKHR5cGVzcGFjZSwgdHlwZUJ1aWxkZXIpIHtcbiAgbGV0IHR5ID0gdHlwZUJ1aWxkZXIuYWxnZWJyYWljVHlwZTtcbiAgd2hpbGUgKHR5LnRhZyA9PT0gXCJSZWZcIikge1xuICAgIHR5ID0gdHlwZXNwYWNlLnR5cGVzW3R5LnZhbHVlXTtcbiAgfVxuICByZXR1cm4gdHk7XG59XG5mdW5jdGlvbiByZWdpc3RlclR5cGVzUmVjdXJzaXZlbHkodHlwZUJ1aWxkZXIpIHtcbiAgaWYgKHR5cGVCdWlsZGVyIGluc3RhbmNlb2YgUHJvZHVjdEJ1aWxkZXIgJiYgIWlzVW5pdCh0eXBlQnVpbGRlcikgfHwgdHlwZUJ1aWxkZXIgaW5zdGFuY2VvZiBTdW1CdWlsZGVyIHx8IHR5cGVCdWlsZGVyIGluc3RhbmNlb2YgUm93QnVpbGRlcikge1xuICAgIHJldHVybiByZWdpc3RlckNvbXBvdW5kVHlwZVJlY3Vyc2l2ZWx5KHR5cGVCdWlsZGVyKTtcbiAgfSBlbHNlIGlmICh0eXBlQnVpbGRlciBpbnN0YW5jZW9mIE9wdGlvbkJ1aWxkZXIpIHtcbiAgICByZXR1cm4gbmV3IE9wdGlvbkJ1aWxkZXIoXG4gICAgICByZWdpc3RlclR5cGVzUmVjdXJzaXZlbHkodHlwZUJ1aWxkZXIudmFsdWUpXG4gICAgKTtcbiAgfSBlbHNlIGlmICh0eXBlQnVpbGRlciBpbnN0YW5jZW9mIFJlc3VsdEJ1aWxkZXIpIHtcbiAgICByZXR1cm4gbmV3IFJlc3VsdEJ1aWxkZXIoXG4gICAgICByZWdpc3RlclR5cGVzUmVjdXJzaXZlbHkodHlwZUJ1aWxkZXIub2spLFxuICAgICAgcmVnaXN0ZXJUeXBlc1JlY3Vyc2l2ZWx5KHR5cGVCdWlsZGVyLmVycilcbiAgICApO1xuICB9IGVsc2UgaWYgKHR5cGVCdWlsZGVyIGluc3RhbmNlb2YgQXJyYXlCdWlsZGVyKSB7XG4gICAgcmV0dXJuIG5ldyBBcnJheUJ1aWxkZXIoXG4gICAgICByZWdpc3RlclR5cGVzUmVjdXJzaXZlbHkodHlwZUJ1aWxkZXIuZWxlbWVudClcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0eXBlQnVpbGRlcjtcbiAgfVxufVxuZnVuY3Rpb24gcmVnaXN0ZXJDb21wb3VuZFR5cGVSZWN1cnNpdmVseSh0eXBlQnVpbGRlcikge1xuICBjb25zdCB0eSA9IHR5cGVCdWlsZGVyLmFsZ2VicmFpY1R5cGU7XG4gIGNvbnN0IG5hbWUgPSB0eXBlQnVpbGRlci50eXBlTmFtZTtcbiAgaWYgKG5hbWUgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBNaXNzaW5nIHR5cGUgbmFtZSBmb3IgJHt0eXBlQnVpbGRlci5jb25zdHJ1Y3Rvci5uYW1lID8/IFwiVHlwZUJ1aWxkZXJcIn0gJHtKU09OLnN0cmluZ2lmeSh0eXBlQnVpbGRlcil9YFxuICAgICk7XG4gIH1cbiAgbGV0IHIgPSBDT01QT1VORF9UWVBFUy5nZXQodHkpO1xuICBpZiAociAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgY29uc3QgbmV3VHkgPSB0eXBlQnVpbGRlciBpbnN0YW5jZW9mIFJvd0J1aWxkZXIgfHwgdHlwZUJ1aWxkZXIgaW5zdGFuY2VvZiBQcm9kdWN0QnVpbGRlciA/IHtcbiAgICB0YWc6IFwiUHJvZHVjdFwiLFxuICAgIHZhbHVlOiB7IGVsZW1lbnRzOiBbXSB9XG4gIH0gOiB7IHRhZzogXCJTdW1cIiwgdmFsdWU6IHsgdmFyaWFudHM6IFtdIH0gfTtcbiAgciA9IG5ldyBSZWZCdWlsZGVyKE1PRFVMRV9ERUYudHlwZXNwYWNlLnR5cGVzLmxlbmd0aCk7XG4gIE1PRFVMRV9ERUYudHlwZXNwYWNlLnR5cGVzLnB1c2gobmV3VHkpO1xuICBDT01QT1VORF9UWVBFUy5zZXQodHksIHIpO1xuICBpZiAodHlwZUJ1aWxkZXIgaW5zdGFuY2VvZiBSb3dCdWlsZGVyKSB7XG4gICAgZm9yIChjb25zdCBbbmFtZTIsIGVsZW1dIG9mIE9iamVjdC5lbnRyaWVzKHR5cGVCdWlsZGVyLnJvdykpIHtcbiAgICAgIG5ld1R5LnZhbHVlLmVsZW1lbnRzLnB1c2goe1xuICAgICAgICBuYW1lOiBuYW1lMixcbiAgICAgICAgYWxnZWJyYWljVHlwZTogcmVnaXN0ZXJUeXBlc1JlY3Vyc2l2ZWx5KGVsZW0udHlwZUJ1aWxkZXIpLmFsZ2VicmFpY1R5cGVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlQnVpbGRlciBpbnN0YW5jZW9mIFByb2R1Y3RCdWlsZGVyKSB7XG4gICAgZm9yIChjb25zdCBbbmFtZTIsIGVsZW1dIG9mIE9iamVjdC5lbnRyaWVzKHR5cGVCdWlsZGVyLmVsZW1lbnRzKSkge1xuICAgICAgbmV3VHkudmFsdWUuZWxlbWVudHMucHVzaCh7XG4gICAgICAgIG5hbWU6IG5hbWUyLFxuICAgICAgICBhbGdlYnJhaWNUeXBlOiByZWdpc3RlclR5cGVzUmVjdXJzaXZlbHkoZWxlbSkuYWxnZWJyYWljVHlwZVxuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVCdWlsZGVyIGluc3RhbmNlb2YgU3VtQnVpbGRlcikge1xuICAgIGZvciAoY29uc3QgW25hbWUyLCB2YXJpYW50XSBvZiBPYmplY3QuZW50cmllcyh0eXBlQnVpbGRlci52YXJpYW50cykpIHtcbiAgICAgIG5ld1R5LnZhbHVlLnZhcmlhbnRzLnB1c2goe1xuICAgICAgICBuYW1lOiBuYW1lMixcbiAgICAgICAgYWxnZWJyYWljVHlwZTogcmVnaXN0ZXJUeXBlc1JlY3Vyc2l2ZWx5KHZhcmlhbnQpLmFsZ2VicmFpY1R5cGVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBNT0RVTEVfREVGLnR5cGVzLnB1c2goe1xuICAgIG5hbWU6IHNwbGl0TmFtZShuYW1lKSxcbiAgICB0eTogci5yZWYsXG4gICAgY3VzdG9tT3JkZXJpbmc6IHRydWVcbiAgfSk7XG4gIHJldHVybiByO1xufVxuZnVuY3Rpb24gaXNVbml0KHR5cGVCdWlsZGVyKSB7XG4gIHJldHVybiB0eXBlQnVpbGRlci50eXBlTmFtZSA9PSBudWxsICYmIHR5cGVCdWlsZGVyLmFsZ2VicmFpY1R5cGUudmFsdWUuZWxlbWVudHMubGVuZ3RoID09PSAwO1xufVxuZnVuY3Rpb24gc3BsaXROYW1lKG5hbWUpIHtcbiAgY29uc3Qgc2NvcGUgPSBuYW1lLnNwbGl0KFwiLlwiKTtcbiAgcmV0dXJuIHsgbmFtZTogc2NvcGUucG9wKCksIHNjb3BlIH07XG59XG52YXIgU2NoZW1hID0gY2xhc3Mge1xuICB0YWJsZXNEZWY7XG4gIHR5cGVzcGFjZTtcbiAgc2NoZW1hVHlwZTtcbiAgY29uc3RydWN0b3IodGFibGVzLCB0eXBlc3BhY2UsIGhhbmRsZXMpIHtcbiAgICB0aGlzLnRhYmxlc0RlZiA9IHsgdGFibGVzIH07XG4gICAgdGhpcy50eXBlc3BhY2UgPSB0eXBlc3BhY2U7XG4gICAgdGhpcy5zY2hlbWFUeXBlID0gdGFibGVzVG9TY2hlbWEoaGFuZGxlcyk7XG4gIH1cbiAgcmVkdWNlcihuYW1lLCBwYXJhbXNPckZuLCBmbikge1xuICAgIGlmICh0eXBlb2YgcGFyYW1zT3JGbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZWR1Y2VyKG5hbWUsIHt9LCBwYXJhbXNPckZuKTtcbiAgICAgIHJldHVybiBwYXJhbXNPckZuO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWR1Y2VyKG5hbWUsIHBhcmFtc09yRm4sIGZuKTtcbiAgICAgIHJldHVybiBmbjtcbiAgICB9XG4gIH1cbiAgaW5pdChuYW1lT3JGbiwgbWF5YmVGbikge1xuICAgIGNvbnN0IFtuYW1lLCBmbl0gPSB0eXBlb2YgbmFtZU9yRm4gPT09IFwic3RyaW5nXCIgPyBbbmFtZU9yRm4sIG1heWJlRm5dIDogW1wiaW5pdFwiLCBuYW1lT3JGbl07XG4gICAgaW5pdChuYW1lLCB7fSwgZm4pO1xuICB9XG4gIGNsaWVudENvbm5lY3RlZChuYW1lT3JGbiwgbWF5YmVGbikge1xuICAgIGNvbnN0IFtuYW1lLCBmbl0gPSB0eXBlb2YgbmFtZU9yRm4gPT09IFwic3RyaW5nXCIgPyBbbmFtZU9yRm4sIG1heWJlRm5dIDogW1wib25fY29ubmVjdFwiLCBuYW1lT3JGbl07XG4gICAgY2xpZW50Q29ubmVjdGVkKG5hbWUsIHt9LCBmbik7XG4gIH1cbiAgY2xpZW50RGlzY29ubmVjdGVkKG5hbWVPckZuLCBtYXliZUZuKSB7XG4gICAgY29uc3QgW25hbWUsIGZuXSA9IHR5cGVvZiBuYW1lT3JGbiA9PT0gXCJzdHJpbmdcIiA/IFtuYW1lT3JGbiwgbWF5YmVGbl0gOiBbXCJvbl9kaXNjb25uZWN0XCIsIG5hbWVPckZuXTtcbiAgICBjbGllbnREaXNjb25uZWN0ZWQobmFtZSwge30sIGZuKTtcbiAgfVxuICB2aWV3KG9wdHMsIHJldCwgZm4pIHtcbiAgICBkZWZpbmVWaWV3KG9wdHMsIGZhbHNlLCB7fSwgcmV0LCBmbik7XG4gIH1cbiAgLy8gVE9ETzogcmUtZW5hYmxlIG9uY2UgcGFyYW1ldGVyaXplZCB2aWV3cyBhcmUgc3VwcG9ydGVkIGluIFNRTFxuICAvLyB2aWV3PFJldCBleHRlbmRzIFZpZXdSZXR1cm5UeXBlQnVpbGRlcj4oXG4gIC8vICAgb3B0czogVmlld09wdHMsXG4gIC8vICAgcmV0OiBSZXQsXG4gIC8vICAgZm46IFZpZXdGbjxTLCB7fSwgUmV0PlxuICAvLyApOiB2b2lkO1xuICAvLyB2aWV3PFBhcmFtcyBleHRlbmRzIFBhcmFtc09iaiwgUmV0IGV4dGVuZHMgVmlld1JldHVyblR5cGVCdWlsZGVyPihcbiAgLy8gICBvcHRzOiBWaWV3T3B0cyxcbiAgLy8gICBwYXJhbXM6IFBhcmFtcyxcbiAgLy8gICByZXQ6IFJldCxcbiAgLy8gICBmbjogVmlld0ZuPFMsIHt9LCBSZXQ+XG4gIC8vICk6IHZvaWQ7XG4gIC8vIHZpZXc8UGFyYW1zIGV4dGVuZHMgUGFyYW1zT2JqLCBSZXQgZXh0ZW5kcyBWaWV3UmV0dXJuVHlwZUJ1aWxkZXI+KFxuICAvLyAgIG9wdHM6IFZpZXdPcHRzLFxuICAvLyAgIHBhcmFtc09yUmV0OiBSZXQgfCBQYXJhbXMsXG4gIC8vICAgcmV0T3JGbjogVmlld0ZuPFMsIHt9LCBSZXQ+IHwgUmV0LFxuICAvLyAgIG1heWJlRm4/OiBWaWV3Rm48UywgUGFyYW1zLCBSZXQ+XG4gIC8vICk6IHZvaWQge1xuICAvLyAgIGlmICh0eXBlb2YgcmV0T3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyAgICAgZGVmaW5lVmlldyhuYW1lLCBmYWxzZSwge30sIHBhcmFtc09yUmV0IGFzIFJldCwgcmV0T3JGbik7XG4gIC8vICAgfSBlbHNlIHtcbiAgLy8gICAgIGRlZmluZVZpZXcobmFtZSwgZmFsc2UsIHBhcmFtc09yUmV0IGFzIFBhcmFtcywgcmV0T3JGbiwgbWF5YmVGbiEpO1xuICAvLyAgIH1cbiAgLy8gfVxuICBhbm9ueW1vdXNWaWV3KG9wdHMsIHJldCwgZm4pIHtcbiAgICBkZWZpbmVWaWV3KG9wdHMsIHRydWUsIHt9LCByZXQsIGZuKTtcbiAgfVxuICBwcm9jZWR1cmUobmFtZSwgcGFyYW1zT3JSZXQsIHJldE9yRm4sIG1heWJlRm4pIHtcbiAgICBpZiAodHlwZW9mIHJldE9yRm4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcHJvY2VkdXJlKG5hbWUsIHt9LCBwYXJhbXNPclJldCwgcmV0T3JGbik7XG4gICAgICByZXR1cm4gcmV0T3JGbjtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvY2VkdXJlKG5hbWUsIHBhcmFtc09yUmV0LCByZXRPckZuLCBtYXliZUZuKTtcbiAgICAgIHJldHVybiBtYXliZUZuO1xuICAgIH1cbiAgfVxuICBjbGllbnRWaXNpYmlsaXR5RmlsdGVyID0ge1xuICAgIHNxbChmaWx0ZXIpIHtcbiAgICAgIE1PRFVMRV9ERUYucm93TGV2ZWxTZWN1cml0eS5wdXNoKHsgc3FsOiBmaWx0ZXIgfSk7XG4gICAgfVxuICB9O1xufTtcbmZ1bmN0aW9uIHNjaGVtYSguLi5hcmdzKSB7XG4gIGNvbnN0IGhhbmRsZXMgPSBhcmdzLmxlbmd0aCA9PT0gMSAmJiBBcnJheS5pc0FycmF5KGFyZ3NbMF0pID8gYXJnc1swXSA6IGFyZ3M7XG4gIGNvbnN0IHRhYmxlRGVmcyA9IGhhbmRsZXMubWFwKChoKSA9PiBoLnRhYmxlRGVmKTtcbiAgTU9EVUxFX0RFRi50YWJsZXMucHVzaCguLi50YWJsZURlZnMpO1xuICBSRUdJU1RFUkVEX1NDSEVNQSA9IHtcbiAgICB0YWJsZXM6IGhhbmRsZXMubWFwKChoYW5kbGUpID0+ICh7XG4gICAgICBuYW1lOiBoYW5kbGUudGFibGVOYW1lLFxuICAgICAgYWNjZXNzb3JOYW1lOiBoYW5kbGUudGFibGVOYW1lLFxuICAgICAgY29sdW1uczogaGFuZGxlLnJvd1R5cGUucm93LFxuICAgICAgcm93VHlwZTogaGFuZGxlLnJvd1NwYWNldGltZVR5cGUsXG4gICAgICBpbmRleGVzOiBoYW5kbGUuaWR4cyxcbiAgICAgIGNvbnN0cmFpbnRzOiBoYW5kbGUuY29uc3RyYWludHNcbiAgICB9KSlcbiAgfTtcbiAgcmV0dXJuIG5ldyBTY2hlbWEodGFibGVEZWZzLCBNT0RVTEVfREVGLnR5cGVzcGFjZSwgaGFuZGxlcyk7XG59XG5cbi8vIHNyYy9saWIvYXV0b2dlbi9yYXdfaW5kZXhfYWxnb3JpdGhtX3R5cGUudHNcbnZhciBSYXdJbmRleEFsZ29yaXRobSA9IHQuZW51bShcIlJhd0luZGV4QWxnb3JpdGhtXCIsIHtcbiAgQlRyZWU6IHQuYXJyYXkodC51MTYoKSksXG4gIEhhc2g6IHQuYXJyYXkodC51MTYoKSksXG4gIERpcmVjdDogdC51MTYoKVxufSk7XG52YXIgcmF3X2luZGV4X2FsZ29yaXRobV90eXBlX2RlZmF1bHQgPSBSYXdJbmRleEFsZ29yaXRobTtcblxuLy8gc3JjL2xpYi90YWJsZS50c1xuZnVuY3Rpb24gdGFibGUob3B0cywgcm93KSB7XG4gIGNvbnN0IHtcbiAgICBuYW1lLFxuICAgIHB1YmxpYzogaXNQdWJsaWMgPSBmYWxzZSxcbiAgICBpbmRleGVzOiB1c2VySW5kZXhlcyA9IFtdLFxuICAgIHNjaGVkdWxlZFxuICB9ID0gb3B0cztcbiAgY29uc3QgY29sSWRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgY29sTmFtZUxpc3QgPSBbXTtcbiAgaWYgKCEocm93IGluc3RhbmNlb2YgUm93QnVpbGRlcikpIHtcbiAgICByb3cgPSBuZXcgUm93QnVpbGRlcihyb3cpO1xuICB9XG4gIGlmIChyb3cudHlwZU5hbWUgPT09IHZvaWQgMCkge1xuICAgIHJvdy50eXBlTmFtZSA9IHRvUGFzY2FsQ2FzZShuYW1lKTtcbiAgfVxuICBjb25zdCByb3dUeXBlUmVmID0gcmVnaXN0ZXJUeXBlc1JlY3Vyc2l2ZWx5KHJvdyk7XG4gIHJvdy5hbGdlYnJhaWNUeXBlLnZhbHVlLmVsZW1lbnRzLmZvckVhY2goKGVsZW0sIGkpID0+IHtcbiAgICBjb2xJZHMuc2V0KGVsZW0ubmFtZSwgaSk7XG4gICAgY29sTmFtZUxpc3QucHVzaChlbGVtLm5hbWUpO1xuICB9KTtcbiAgY29uc3QgcGsgPSBbXTtcbiAgY29uc3QgaW5kZXhlcyA9IFtdO1xuICBjb25zdCBjb25zdHJhaW50cyA9IFtdO1xuICBjb25zdCBzZXF1ZW5jZXMgPSBbXTtcbiAgbGV0IHNjaGVkdWxlQXRDb2w7XG4gIGZvciAoY29uc3QgW25hbWUyLCBidWlsZGVyXSBvZiBPYmplY3QuZW50cmllcyhyb3cucm93KSkge1xuICAgIGNvbnN0IG1ldGEgPSBidWlsZGVyLmNvbHVtbk1ldGFkYXRhO1xuICAgIGlmIChtZXRhLmlzUHJpbWFyeUtleSkge1xuICAgICAgcGsucHVzaChjb2xJZHMuZ2V0KG5hbWUyKSk7XG4gICAgfVxuICAgIGNvbnN0IGlzVW5pcXVlID0gbWV0YS5pc1VuaXF1ZSB8fCBtZXRhLmlzUHJpbWFyeUtleTtcbiAgICBpZiAobWV0YS5pbmRleFR5cGUgfHwgaXNVbmlxdWUpIHtcbiAgICAgIGNvbnN0IGFsZ28gPSBtZXRhLmluZGV4VHlwZSA/PyBcImJ0cmVlXCI7XG4gICAgICBjb25zdCBpZCA9IGNvbElkcy5nZXQobmFtZTIpO1xuICAgICAgbGV0IGFsZ29yaXRobTtcbiAgICAgIHN3aXRjaCAoYWxnbykge1xuICAgICAgICBjYXNlIFwiYnRyZWVcIjpcbiAgICAgICAgICBhbGdvcml0aG0gPSByYXdfaW5kZXhfYWxnb3JpdGhtX3R5cGVfZGVmYXVsdC5CVHJlZShbaWRdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRpcmVjdFwiOlxuICAgICAgICAgIGFsZ29yaXRobSA9IHJhd19pbmRleF9hbGdvcml0aG1fdHlwZV9kZWZhdWx0LkRpcmVjdChpZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpbmRleGVzLnB1c2goe1xuICAgICAgICBuYW1lOiB2b2lkIDAsXG4gICAgICAgIC8vIFVubmFtZWQgaW5kZXhlcyB3aWxsIGJlIGFzc2lnbmVkIGEgZ2xvYmFsbHkgdW5pcXVlIG5hbWVcbiAgICAgICAgYWNjZXNzb3JOYW1lOiBuYW1lMixcbiAgICAgICAgLy8gVGhlIG5hbWUgb2YgdGhpcyBjb2x1bW4gd2lsbCBiZSB1c2VkIGFzIHRoZSBhY2Nlc3NvciBuYW1lXG4gICAgICAgIGFsZ29yaXRobVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChpc1VuaXF1ZSkge1xuICAgICAgY29uc3RyYWludHMucHVzaCh7XG4gICAgICAgIG5hbWU6IHZvaWQgMCxcbiAgICAgICAgZGF0YTogeyB0YWc6IFwiVW5pcXVlXCIsIHZhbHVlOiB7IGNvbHVtbnM6IFtjb2xJZHMuZ2V0KG5hbWUyKV0gfSB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKG1ldGEuaXNBdXRvSW5jcmVtZW50KSB7XG4gICAgICBzZXF1ZW5jZXMucHVzaCh7XG4gICAgICAgIG5hbWU6IHZvaWQgMCxcbiAgICAgICAgc3RhcnQ6IHZvaWQgMCxcbiAgICAgICAgbWluVmFsdWU6IHZvaWQgMCxcbiAgICAgICAgbWF4VmFsdWU6IHZvaWQgMCxcbiAgICAgICAgY29sdW1uOiBjb2xJZHMuZ2V0KG5hbWUyKSxcbiAgICAgICAgaW5jcmVtZW50OiAxblxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzY2hlZHVsZWQpIHtcbiAgICAgIGNvbnN0IGFsZ2VicmFpY1R5cGUgPSBidWlsZGVyLnR5cGVCdWlsZGVyLmFsZ2VicmFpY1R5cGU7XG4gICAgICBpZiAoc2NoZWR1bGVfYXRfZGVmYXVsdC5pc1NjaGVkdWxlQXQoYWxnZWJyYWljVHlwZSkpIHtcbiAgICAgICAgc2NoZWR1bGVBdENvbCA9IGNvbElkcy5nZXQobmFtZTIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IGluZGV4T3B0cyBvZiB1c2VySW5kZXhlcyA/PyBbXSkge1xuICAgIGxldCBhbGdvcml0aG07XG4gICAgc3dpdGNoIChpbmRleE9wdHMuYWxnb3JpdGhtKSB7XG4gICAgICBjYXNlIFwiYnRyZWVcIjpcbiAgICAgICAgYWxnb3JpdGhtID0ge1xuICAgICAgICAgIHRhZzogXCJCVHJlZVwiLFxuICAgICAgICAgIHZhbHVlOiBpbmRleE9wdHMuY29sdW1ucy5tYXAoKGMpID0+IGNvbElkcy5nZXQoYykpXG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImRpcmVjdFwiOlxuICAgICAgICBhbGdvcml0aG0gPSB7IHRhZzogXCJEaXJlY3RcIiwgdmFsdWU6IGNvbElkcy5nZXQoaW5kZXhPcHRzLmNvbHVtbikgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGluZGV4ZXMucHVzaCh7IG5hbWU6IHZvaWQgMCwgYWNjZXNzb3JOYW1lOiBpbmRleE9wdHMubmFtZSwgYWxnb3JpdGhtIH0pO1xuICB9XG4gIGZvciAoY29uc3QgY29uc3RyYWludE9wdHMgb2Ygb3B0cy5jb25zdHJhaW50cyA/PyBbXSkge1xuICAgIGlmIChjb25zdHJhaW50T3B0cy5jb25zdHJhaW50ID09PSBcInVuaXF1ZVwiKSB7XG4gICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICB0YWc6IFwiVW5pcXVlXCIsXG4gICAgICAgIHZhbHVlOiB7IGNvbHVtbnM6IGNvbnN0cmFpbnRPcHRzLmNvbHVtbnMubWFwKChjKSA9PiBjb2xJZHMuZ2V0KGMpKSB9XG4gICAgICB9O1xuICAgICAgY29uc3RyYWludHMucHVzaCh7IG5hbWU6IGNvbnN0cmFpbnRPcHRzLm5hbWUsIGRhdGEgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBpbmRleCBvZiBpbmRleGVzKSB7XG4gICAgY29uc3QgY29scyA9IGluZGV4LmFsZ29yaXRobS50YWcgPT09IFwiRGlyZWN0XCIgPyBbaW5kZXguYWxnb3JpdGhtLnZhbHVlXSA6IGluZGV4LmFsZ29yaXRobS52YWx1ZTtcbiAgICBjb25zdCBjb2xTID0gY29scy5tYXAoKGkpID0+IGNvbE5hbWVMaXN0W2ldKS5qb2luKFwiX1wiKTtcbiAgICBpbmRleC5uYW1lID0gYCR7bmFtZX1fJHtjb2xTfV9pZHhfJHtpbmRleC5hbGdvcml0aG0udGFnLnRvTG93ZXJDYXNlKCl9YDtcbiAgfVxuICBjb25zdCB0YWJsZURlZiA9IHtcbiAgICBuYW1lLFxuICAgIHByb2R1Y3RUeXBlUmVmOiByb3dUeXBlUmVmLnJlZixcbiAgICBwcmltYXJ5S2V5OiBwayxcbiAgICBpbmRleGVzLFxuICAgIGNvbnN0cmFpbnRzLFxuICAgIHNlcXVlbmNlcyxcbiAgICBzY2hlZHVsZTogc2NoZWR1bGVkICYmIHNjaGVkdWxlQXRDb2wgIT09IHZvaWQgMCA/IHtcbiAgICAgIG5hbWU6IHZvaWQgMCxcbiAgICAgIHJlZHVjZXJOYW1lOiBzY2hlZHVsZWQsXG4gICAgICBzY2hlZHVsZWRBdENvbHVtbjogc2NoZWR1bGVBdENvbFxuICAgIH0gOiB2b2lkIDAsXG4gICAgdGFibGVUeXBlOiB7IHRhZzogXCJVc2VyXCIgfSxcbiAgICB0YWJsZUFjY2VzczogeyB0YWc6IGlzUHVibGljID8gXCJQdWJsaWNcIiA6IFwiUHJpdmF0ZVwiIH1cbiAgfTtcbiAgY29uc3QgcHJvZHVjdFR5cGUgPSByb3cuYWxnZWJyYWljVHlwZS52YWx1ZTtcbiAgcmV0dXJuIHtcbiAgICByb3dUeXBlOiByb3csXG4gICAgdGFibGVOYW1lOiBuYW1lLFxuICAgIHJvd1NwYWNldGltZVR5cGU6IHByb2R1Y3RUeXBlLFxuICAgIHRhYmxlRGVmLFxuICAgIGlkeHM6IHt9LFxuICAgIGNvbnN0cmFpbnRzXG4gIH07XG59XG5cbi8vIHNyYy9zZXJ2ZXIvZXJyb3JzLnRzXG52YXIgU3BhY2V0aW1lSG9zdEVycm9yID0gY2xhc3MgX1NwYWNldGltZUhvc3RFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29kZTtcbiAgbWVzc2FnZTtcbiAgY29uc3RydWN0b3IoY29kZSwgbWVzc2FnZSkge1xuICAgIHN1cGVyKCk7XG4gICAgY29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyk7XG4gICAgbGV0IGNscztcbiAgICBpZiAoZXJyb3JQcm90b3lwZXMuaGFzKHByb3RvKSkge1xuICAgICAgY2xzID0gcHJvdG8uY29uc3RydWN0b3I7XG4gICAgICBpZiAoY29kZSAhPT0gY2xzLkNPREUpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGludmFsaWQgZXJyb3IgY29kZSBmb3IgJHtjbHMubmFtZX1gKTtcbiAgICB9IGVsc2UgaWYgKHByb3RvID09PSBfU3BhY2V0aW1lSG9zdEVycm9yLnByb3RvdHlwZSkge1xuICAgICAgY2xzID0gZXJybm9Ub0NsYXNzLmdldChjb2RlKTtcbiAgICAgIGlmICghY2xzKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgdW5rbm93biBlcnJvciBjb2RlICR7Y29kZX1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbm5vdCBzdWJjbGFzcyBTcGFjZXRpbWVFcnJvclwiKTtcbiAgICB9XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIGNscy5wcm90b3R5cGUpO1xuICAgIHRoaXMuY29kZSA9IGNscy5DT0RFO1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgPz8gY2xzLk1FU1NBR0U7XG4gIH1cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIGVycm5vVG9DbGFzcy5nZXQodGhpcy5jb2RlKT8ubmFtZSA/PyBcIlNwYWNldGltZUhvc3RFcnJvclwiO1xuICB9XG59O1xudmFyIFNlbmRlckVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgfVxuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gXCJTZW5kZXJFcnJvclwiO1xuICB9XG59O1xudmFyIGVycm9yRGF0YSA9IHtcbiAgLyoqXG4gICAqIEEgZ2VuZXJpYyBlcnJvciBjbGFzcyBmb3IgdW5rbm93biBlcnJvciBjb2Rlcy5cbiAgICovXG4gIEhvc3RDYWxsRmFpbHVyZTogWzEsIFwiQUJJIGNhbGxlZCBieSBob3N0IHJldHVybmVkIGFuIGVycm9yXCJdLFxuICAvKipcbiAgICogRXJyb3IgaW5kaWNhdGluZyB0aGF0IGFuIEFCSSBjYWxsIHdhcyBtYWRlIG91dHNpZGUgb2YgYSB0cmFuc2FjdGlvbi5cbiAgICovXG4gIE5vdEluVHJhbnNhY3Rpb246IFsyLCBcIkFCSSBjYWxsIGNhbiBvbmx5IGJlIG1hZGUgd2hpbGUgaW4gYSB0cmFuc2FjdGlvblwiXSxcbiAgLyoqXG4gICAqIEVycm9yIGluZGljYXRpbmcgdGhhdCBCU0FUTiBkZWNvZGluZyBmYWlsZWQuXG4gICAqIFRoaXMgdHlwaWNhbGx5IG1lYW5zIHRoYXQgdGhlIGRhdGEgY291bGQgbm90IGJlIGRlY29kZWQgdG8gdGhlIGV4cGVjdGVkIHR5cGUuXG4gICAqL1xuICBCc2F0bkRlY29kZUVycm9yOiBbMywgXCJDb3VsZG4ndCBkZWNvZGUgdGhlIEJTQVROIHRvIHRoZSBleHBlY3RlZCB0eXBlXCJdLFxuICAvKipcbiAgICogRXJyb3IgaW5kaWNhdGluZyB0aGF0IGEgc3BlY2lmaWVkIHRhYmxlIGRvZXMgbm90IGV4aXN0LlxuICAgKi9cbiAgTm9TdWNoVGFibGU6IFs0LCBcIk5vIHN1Y2ggdGFibGVcIl0sXG4gIC8qKlxuICAgKiBFcnJvciBpbmRpY2F0aW5nIHRoYXQgYSBzcGVjaWZpZWQgaW5kZXggZG9lcyBub3QgZXhpc3QuXG4gICAqL1xuICBOb1N1Y2hJbmRleDogWzUsIFwiTm8gc3VjaCBpbmRleFwiXSxcbiAgLyoqXG4gICAqIEVycm9yIGluZGljYXRpbmcgdGhhdCBhIHNwZWNpZmllZCByb3cgaXRlcmF0b3IgaXMgbm90IHZhbGlkLlxuICAgKi9cbiAgTm9TdWNoSXRlcjogWzYsIFwiVGhlIHByb3ZpZGVkIHJvdyBpdGVyYXRvciBpcyBub3QgdmFsaWRcIl0sXG4gIC8qKlxuICAgKiBFcnJvciBpbmRpY2F0aW5nIHRoYXQgYSBzcGVjaWZpZWQgY29uc29sZSB0aW1lciBkb2VzIG5vdCBleGlzdC5cbiAgICovXG4gIE5vU3VjaENvbnNvbGVUaW1lcjogWzcsIFwiVGhlIHByb3ZpZGVkIGNvbnNvbGUgdGltZXIgZG9lcyBub3QgZXhpc3RcIl0sXG4gIC8qKlxuICAgKiBFcnJvciBpbmRpY2F0aW5nIHRoYXQgYSBzcGVjaWZpZWQgYnl0ZXMgc291cmNlIG9yIHNpbmsgaXMgbm90IHZhbGlkLlxuICAgKi9cbiAgTm9TdWNoQnl0ZXM6IFs4LCBcIlRoZSBwcm92aWRlZCBieXRlcyBzb3VyY2Ugb3Igc2luayBpcyBub3QgdmFsaWRcIl0sXG4gIC8qKlxuICAgKiBFcnJvciBpbmRpY2F0aW5nIHRoYXQgYSBwcm92aWRlZCBzaW5rIGhhcyBubyBtb3JlIHNwYWNlIGxlZnQuXG4gICAqL1xuICBOb1NwYWNlOiBbOSwgXCJUaGUgcHJvdmlkZWQgc2luayBoYXMgbm8gbW9yZSBzcGFjZSBsZWZ0XCJdLFxuICAvKipcbiAgICogRXJyb3IgaW5kaWNhdGluZyB0aGF0IHRoZXJlIGlzIG5vIG1vcmUgc3BhY2UgaW4gdGhlIGRhdGFiYXNlLlxuICAgKi9cbiAgQnVmZmVyVG9vU21hbGw6IFtcbiAgICAxMSxcbiAgICBcIlRoZSBwcm92aWRlZCBidWZmZXIgaXMgbm90IGxhcmdlIGVub3VnaCB0byBzdG9yZSB0aGUgZGF0YVwiXG4gIF0sXG4gIC8qKlxuICAgKiBFcnJvciBpbmRpY2F0aW5nIHRoYXQgYSB2YWx1ZSB3aXRoIGEgZ2l2ZW4gdW5pcXVlIGlkZW50aWZpZXIgYWxyZWFkeSBleGlzdHMuXG4gICAqL1xuICBVbmlxdWVBbHJlYWR5RXhpc3RzOiBbXG4gICAgMTIsXG4gICAgXCJWYWx1ZSB3aXRoIGdpdmVuIHVuaXF1ZSBpZGVudGlmaWVyIGFscmVhZHkgZXhpc3RzXCJcbiAgXSxcbiAgLyoqXG4gICAqIEVycm9yIGluZGljYXRpbmcgdGhhdCB0aGUgc3BlY2lmaWVkIGRlbGF5IGluIHNjaGVkdWxpbmcgYSByb3cgd2FzIHRvbyBsb25nLlxuICAgKi9cbiAgU2NoZWR1bGVBdERlbGF5VG9vTG9uZzogW1xuICAgIDEzLFxuICAgIFwiU3BlY2lmaWVkIGRlbGF5IGluIHNjaGVkdWxpbmcgcm93IHdhcyB0b28gbG9uZ1wiXG4gIF0sXG4gIC8qKlxuICAgKiBFcnJvciBpbmRpY2F0aW5nIHRoYXQgYW4gaW5kZXggd2FzIG5vdCB1bmlxdWUgd2hlbiBpdCB3YXMgZXhwZWN0ZWQgdG8gYmUuXG4gICAqL1xuICBJbmRleE5vdFVuaXF1ZTogWzE0LCBcIlRoZSBpbmRleCB3YXMgbm90IHVuaXF1ZVwiXSxcbiAgLyoqXG4gICAqIEVycm9yIGluZGljYXRpbmcgdGhhdCBhbiBpbmRleCB3YXMgbm90IHVuaXF1ZSB3aGVuIGl0IHdhcyBleHBlY3RlZCB0byBiZS5cbiAgICovXG4gIE5vU3VjaFJvdzogWzE1LCBcIlRoZSByb3cgd2FzIG5vdCBmb3VuZCwgZS5nLiwgaW4gYW4gdXBkYXRlIGNhbGxcIl0sXG4gIC8qKlxuICAgKiBFcnJvciBpbmRpY2F0aW5nIHRoYXQgYW4gYXV0by1pbmNyZW1lbnQgc2VxdWVuY2UgaGFzIG92ZXJmbG93ZWQuXG4gICAqL1xuICBBdXRvSW5jT3ZlcmZsb3c6IFsxNiwgXCJUaGUgYXV0by1pbmNyZW1lbnQgc2VxdWVuY2Ugb3ZlcmZsb3dlZFwiXSxcbiAgV291bGRCbG9ja1RyYW5zYWN0aW9uOiBbXG4gICAgMTcsXG4gICAgXCJBdHRlbXB0ZWQgYXN5bmMgb3IgYmxvY2tpbmcgb3Agd2hpbGUgaG9sZGluZyBvcGVuIGEgdHJhbnNhY3Rpb25cIlxuICBdLFxuICBUcmFuc2FjdGlvbk5vdEFub255bW91czogW1xuICAgIDE4LFxuICAgIFwiTm90IGluIGFuIGFub255bW91cyB0cmFuc2FjdGlvbi4gQ2FsbGVkIGJ5IGEgcmVkdWNlcj9cIlxuICBdLFxuICBUcmFuc2FjdGlvbklzUmVhZE9ubHk6IFtcbiAgICAxOSxcbiAgICBcIkFCSSBjYWxsIGNhbiBvbmx5IGJlIG1hZGUgd2hpbGUgd2l0aGluIGEgbXV0YWJsZSB0cmFuc2FjdGlvblwiXG4gIF0sXG4gIFRyYW5zYWN0aW9uSXNNdXQ6IFtcbiAgICAyMCxcbiAgICBcIkFCSSBjYWxsIGNhbiBvbmx5IGJlIG1hZGUgd2hpbGUgd2l0aGluIGEgcmVhZC1vbmx5IHRyYW5zYWN0aW9uXCJcbiAgXSxcbiAgSHR0cEVycm9yOiBbMjEsIFwiVGhlIEhUVFAgcmVxdWVzdCBmYWlsZWRcIl1cbn07XG5mdW5jdGlvbiBtYXBFbnRyaWVzKHgsIGYpIHtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBPYmplY3QuZW50cmllcyh4KS5tYXAoKFtrLCB2XSkgPT4gW2ssIGYoaywgdildKVxuICApO1xufVxudmFyIGVycm9ycyA9IE9iamVjdC5mcmVlemUoXG4gIG1hcEVudHJpZXMoXG4gICAgZXJyb3JEYXRhLFxuICAgIChuYW1lLCBbY29kZSwgbWVzc2FnZV0pID0+IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgIGNsYXNzIGV4dGVuZHMgU3BhY2V0aW1lSG9zdEVycm9yIHtcbiAgICAgICAgc3RhdGljIENPREUgPSBjb2RlO1xuICAgICAgICBzdGF0aWMgTUVTU0FHRSA9IG1lc3NhZ2U7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgIHN1cGVyKGNvZGUpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJuYW1lXCIsXG4gICAgICB7IHZhbHVlOiBuYW1lLCB3cml0YWJsZTogZmFsc2UgfVxuICAgIClcbiAgKVxuKTtcbnZhciBlcnJvclByb3RveXBlcyA9IG5ldyBTZXQoT2JqZWN0LnZhbHVlcyhlcnJvcnMpLm1hcCgoY2xzKSA9PiBjbHMucHJvdG90eXBlKSk7XG52YXIgZXJybm9Ub0NsYXNzID0gbmV3IE1hcChcbiAgT2JqZWN0LnZhbHVlcyhlcnJvcnMpLm1hcCgoY2xzKSA9PiBbY2xzLkNPREUsIGNsc10pXG4pO1xuXG4vLyBzcmMvc2VydmVyL3BvbHlmaWxscy50c1xuX190b0VTTShyZXF1aXJlX3RleHRfbWluKCkpO1xuXG4vLyBzcmMvbGliL2F1dG9nZW4vc3VtX3R5cGVfdmFyaWFudF90eXBlLnRzXG52YXIgc3VtX3R5cGVfdmFyaWFudF90eXBlX2RlZmF1bHQgPSB0Lm9iamVjdChcIlN1bVR5cGVWYXJpYW50XCIsIHtcbiAgbmFtZTogdC5vcHRpb24odC5zdHJpbmcoKSksXG4gIGdldCBhbGdlYnJhaWNUeXBlKCkge1xuICAgIHJldHVybiBhbGdlYnJhaWNfdHlwZV90eXBlX2RlZmF1bHQ7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL2F1dG9nZW4vc3VtX3R5cGVfdHlwZS50c1xudmFyIHN1bV90eXBlX3R5cGVfZGVmYXVsdCA9IHQub2JqZWN0KFwiU3VtVHlwZVwiLCB7XG4gIGdldCB2YXJpYW50cygpIHtcbiAgICByZXR1cm4gdC5hcnJheShzdW1fdHlwZV92YXJpYW50X3R5cGVfZGVmYXVsdCk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL2F1dG9nZW4vcHJvZHVjdF90eXBlX2VsZW1lbnRfdHlwZS50c1xudmFyIHByb2R1Y3RfdHlwZV9lbGVtZW50X3R5cGVfZGVmYXVsdCA9IHQub2JqZWN0KFwiUHJvZHVjdFR5cGVFbGVtZW50XCIsIHtcbiAgbmFtZTogdC5vcHRpb24odC5zdHJpbmcoKSksXG4gIGdldCBhbGdlYnJhaWNUeXBlKCkge1xuICAgIHJldHVybiBhbGdlYnJhaWNfdHlwZV90eXBlX2RlZmF1bHQ7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL2F1dG9nZW4vcHJvZHVjdF90eXBlX3R5cGUudHNcbnZhciBwcm9kdWN0X3R5cGVfdHlwZV9kZWZhdWx0ID0gdC5vYmplY3QoXCJQcm9kdWN0VHlwZVwiLCB7XG4gIGdldCBlbGVtZW50cygpIHtcbiAgICByZXR1cm4gdC5hcnJheShwcm9kdWN0X3R5cGVfZWxlbWVudF90eXBlX2RlZmF1bHQpO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9hdXRvZ2VuL2FsZ2VicmFpY190eXBlX3R5cGUudHNcbnZhciBBbGdlYnJhaWNUeXBlMiA9IHQuZW51bShcIkFsZ2VicmFpY1R5cGVcIiwge1xuICBSZWY6IHQudTMyKCksXG4gIGdldCBTdW0oKSB7XG4gICAgcmV0dXJuIHN1bV90eXBlX3R5cGVfZGVmYXVsdDtcbiAgfSxcbiAgZ2V0IFByb2R1Y3QoKSB7XG4gICAgcmV0dXJuIHByb2R1Y3RfdHlwZV90eXBlX2RlZmF1bHQ7XG4gIH0sXG4gIGdldCBBcnJheSgpIHtcbiAgICByZXR1cm4gQWxnZWJyYWljVHlwZTI7XG4gIH0sXG4gIFN0cmluZzogdC51bml0KCksXG4gIEJvb2w6IHQudW5pdCgpLFxuICBJODogdC51bml0KCksXG4gIFU4OiB0LnVuaXQoKSxcbiAgSTE2OiB0LnVuaXQoKSxcbiAgVTE2OiB0LnVuaXQoKSxcbiAgSTMyOiB0LnVuaXQoKSxcbiAgVTMyOiB0LnVuaXQoKSxcbiAgSTY0OiB0LnVuaXQoKSxcbiAgVTY0OiB0LnVuaXQoKSxcbiAgSTEyODogdC51bml0KCksXG4gIFUxMjg6IHQudW5pdCgpLFxuICBJMjU2OiB0LnVuaXQoKSxcbiAgVTI1NjogdC51bml0KCksXG4gIEYzMjogdC51bml0KCksXG4gIEY2NDogdC51bml0KClcbn0pO1xudmFyIGFsZ2VicmFpY190eXBlX3R5cGVfZGVmYXVsdCA9IEFsZ2VicmFpY1R5cGUyO1xuXG4vLyBzcmMvbGliL2F1dG9nZW4vdHlwZXNwYWNlX3R5cGUudHNcbnZhciB0eXBlc3BhY2VfdHlwZV9kZWZhdWx0ID0gdC5vYmplY3QoXCJUeXBlc3BhY2VcIiwge1xuICBnZXQgdHlwZXMoKSB7XG4gICAgcmV0dXJuIHQuYXJyYXkoYWxnZWJyYWljX3R5cGVfdHlwZV9kZWZhdWx0KTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvYXV0b2dlbi9yYXdfY29sdW1uX2RlZl92XzhfdHlwZS50c1xudmFyIHJhd19jb2x1bW5fZGVmX3ZfOF90eXBlX2RlZmF1bHQgPSB0Lm9iamVjdChcIlJhd0NvbHVtbkRlZlY4XCIsIHtcbiAgY29sTmFtZTogdC5zdHJpbmcoKSxcbiAgZ2V0IGNvbFR5cGUoKSB7XG4gICAgcmV0dXJuIGFsZ2VicmFpY190eXBlX3R5cGVfZGVmYXVsdDtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvYXV0b2dlbi9pbmRleF90eXBlX3R5cGUudHNcbnZhciBJbmRleFR5cGUgPSB0LmVudW0oXCJJbmRleFR5cGVcIiwge1xuICBCVHJlZTogdC51bml0KCksXG4gIEhhc2g6IHQudW5pdCgpXG59KTtcbnZhciBpbmRleF90eXBlX3R5cGVfZGVmYXVsdCA9IEluZGV4VHlwZTtcblxuLy8gc3JjL2xpYi9hdXRvZ2VuL3Jhd19pbmRleF9kZWZfdl84X3R5cGUudHNcbnZhciByYXdfaW5kZXhfZGVmX3ZfOF90eXBlX2RlZmF1bHQgPSB0Lm9iamVjdChcIlJhd0luZGV4RGVmVjhcIiwge1xuICBpbmRleE5hbWU6IHQuc3RyaW5nKCksXG4gIGlzVW5pcXVlOiB0LmJvb2woKSxcbiAgZ2V0IGluZGV4VHlwZSgpIHtcbiAgICByZXR1cm4gaW5kZXhfdHlwZV90eXBlX2RlZmF1bHQ7XG4gIH0sXG4gIGNvbHVtbnM6IHQuYXJyYXkodC51MTYoKSlcbn0pO1xuXG4vLyBzcmMvbGliL2F1dG9nZW4vcmF3X2NvbnN0cmFpbnRfZGVmX3ZfOF90eXBlLnRzXG52YXIgcmF3X2NvbnN0cmFpbnRfZGVmX3ZfOF90eXBlX2RlZmF1bHQgPSB0Lm9iamVjdChcIlJhd0NvbnN0cmFpbnREZWZWOFwiLCB7XG4gIGNvbnN0cmFpbnROYW1lOiB0LnN0cmluZygpLFxuICBjb25zdHJhaW50czogdC51OCgpLFxuICBjb2x1bW5zOiB0LmFycmF5KHQudTE2KCkpXG59KTtcblxuLy8gc3JjL2xpYi9hdXRvZ2VuL3Jhd19zZXF1ZW5jZV9kZWZfdl84X3R5cGUudHNcbnZhciByYXdfc2VxdWVuY2VfZGVmX3ZfOF90eXBlX2RlZmF1bHQgPSB0Lm9iamVjdChcIlJhd1NlcXVlbmNlRGVmVjhcIiwge1xuICBzZXF1ZW5jZU5hbWU6IHQuc3RyaW5nKCksXG4gIGNvbFBvczogdC51MTYoKSxcbiAgaW5jcmVtZW50OiB0LmkxMjgoKSxcbiAgc3RhcnQ6IHQub3B0aW9uKHQuaTEyOCgpKSxcbiAgbWluVmFsdWU6IHQub3B0aW9uKHQuaTEyOCgpKSxcbiAgbWF4VmFsdWU6IHQub3B0aW9uKHQuaTEyOCgpKSxcbiAgYWxsb2NhdGVkOiB0LmkxMjgoKVxufSk7XG5cbi8vIHNyYy9saWIvYXV0b2dlbi9yYXdfdGFibGVfZGVmX3ZfOF90eXBlLnRzXG52YXIgcmF3X3RhYmxlX2RlZl92XzhfdHlwZV9kZWZhdWx0ID0gdC5vYmplY3QoXCJSYXdUYWJsZURlZlY4XCIsIHtcbiAgdGFibGVOYW1lOiB0LnN0cmluZygpLFxuICBnZXQgY29sdW1ucygpIHtcbiAgICByZXR1cm4gdC5hcnJheShyYXdfY29sdW1uX2RlZl92XzhfdHlwZV9kZWZhdWx0KTtcbiAgfSxcbiAgZ2V0IGluZGV4ZXMoKSB7XG4gICAgcmV0dXJuIHQuYXJyYXkocmF3X2luZGV4X2RlZl92XzhfdHlwZV9kZWZhdWx0KTtcbiAgfSxcbiAgZ2V0IGNvbnN0cmFpbnRzKCkge1xuICAgIHJldHVybiB0LmFycmF5KHJhd19jb25zdHJhaW50X2RlZl92XzhfdHlwZV9kZWZhdWx0KTtcbiAgfSxcbiAgZ2V0IHNlcXVlbmNlcygpIHtcbiAgICByZXR1cm4gdC5hcnJheShyYXdfc2VxdWVuY2VfZGVmX3ZfOF90eXBlX2RlZmF1bHQpO1xuICB9LFxuICB0YWJsZVR5cGU6IHQuc3RyaW5nKCksXG4gIHRhYmxlQWNjZXNzOiB0LnN0cmluZygpLFxuICBzY2hlZHVsZWQ6IHQub3B0aW9uKHQuc3RyaW5nKCkpXG59KTtcblxuLy8gc3JjL2xpYi9hdXRvZ2VuL3RhYmxlX2Rlc2NfdHlwZS50c1xudmFyIHRhYmxlX2Rlc2NfdHlwZV9kZWZhdWx0ID0gdC5vYmplY3QoXCJUYWJsZURlc2NcIiwge1xuICBnZXQgc2NoZW1hKCkge1xuICAgIHJldHVybiByYXdfdGFibGVfZGVmX3ZfOF90eXBlX2RlZmF1bHQ7XG4gIH0sXG4gIGRhdGE6IHQudTMyKClcbn0pO1xuXG4vLyBzcmMvbGliL2F1dG9nZW4vcmVkdWNlcl9kZWZfdHlwZS50c1xudmFyIHJlZHVjZXJfZGVmX3R5cGVfZGVmYXVsdCA9IHQub2JqZWN0KFwiUmVkdWNlckRlZlwiLCB7XG4gIG5hbWU6IHQuc3RyaW5nKCksXG4gIGdldCBhcmdzKCkge1xuICAgIHJldHVybiB0LmFycmF5KHByb2R1Y3RfdHlwZV9lbGVtZW50X3R5cGVfZGVmYXVsdCk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL2F1dG9nZW4vdHlwZV9hbGlhc190eXBlLnRzXG52YXIgdHlwZV9hbGlhc190eXBlX2RlZmF1bHQgPSB0Lm9iamVjdChcIlR5cGVBbGlhc1wiLCB7XG4gIG5hbWU6IHQuc3RyaW5nKCksXG4gIHR5OiB0LnUzMigpXG59KTtcblxuLy8gc3JjL2xpYi9hdXRvZ2VuL21pc2NfbW9kdWxlX2V4cG9ydF90eXBlLnRzXG52YXIgTWlzY01vZHVsZUV4cG9ydCA9IHQuZW51bShcIk1pc2NNb2R1bGVFeHBvcnRcIiwge1xuICBnZXQgVHlwZUFsaWFzKCkge1xuICAgIHJldHVybiB0eXBlX2FsaWFzX3R5cGVfZGVmYXVsdDtcbiAgfVxufSk7XG52YXIgbWlzY19tb2R1bGVfZXhwb3J0X3R5cGVfZGVmYXVsdCA9IE1pc2NNb2R1bGVFeHBvcnQ7XG5cbi8vIHNyYy9saWIvYXV0b2dlbi9yYXdfbW9kdWxlX2RlZl92XzhfdHlwZS50c1xudmFyIHJhd19tb2R1bGVfZGVmX3ZfOF90eXBlX2RlZmF1bHQgPSB0Lm9iamVjdChcIlJhd01vZHVsZURlZlY4XCIsIHtcbiAgZ2V0IHR5cGVzcGFjZSgpIHtcbiAgICByZXR1cm4gdHlwZXNwYWNlX3R5cGVfZGVmYXVsdDtcbiAgfSxcbiAgZ2V0IHRhYmxlcygpIHtcbiAgICByZXR1cm4gdC5hcnJheSh0YWJsZV9kZXNjX3R5cGVfZGVmYXVsdCk7XG4gIH0sXG4gIGdldCByZWR1Y2VycygpIHtcbiAgICByZXR1cm4gdC5hcnJheShyZWR1Y2VyX2RlZl90eXBlX2RlZmF1bHQpO1xuICB9LFxuICBnZXQgbWlzY0V4cG9ydHMoKSB7XG4gICAgcmV0dXJuIHQuYXJyYXkobWlzY19tb2R1bGVfZXhwb3J0X3R5cGVfZGVmYXVsdCk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL2F1dG9nZW4vcmF3X2luZGV4X2RlZl92XzlfdHlwZS50c1xudmFyIHJhd19pbmRleF9kZWZfdl85X3R5cGVfZGVmYXVsdCA9IHQub2JqZWN0KFwiUmF3SW5kZXhEZWZWOVwiLCB7XG4gIG5hbWU6IHQub3B0aW9uKHQuc3RyaW5nKCkpLFxuICBhY2Nlc3Nvck5hbWU6IHQub3B0aW9uKHQuc3RyaW5nKCkpLFxuICBnZXQgYWxnb3JpdGhtKCkge1xuICAgIHJldHVybiByYXdfaW5kZXhfYWxnb3JpdGhtX3R5cGVfZGVmYXVsdDtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvYXV0b2dlbi9yYXdfdW5pcXVlX2NvbnN0cmFpbnRfZGF0YV92XzlfdHlwZS50c1xudmFyIHJhd191bmlxdWVfY29uc3RyYWludF9kYXRhX3ZfOV90eXBlX2RlZmF1bHQgPSB0Lm9iamVjdChcIlJhd1VuaXF1ZUNvbnN0cmFpbnREYXRhVjlcIiwge1xuICBjb2x1bW5zOiB0LmFycmF5KHQudTE2KCkpXG59KTtcblxuLy8gc3JjL2xpYi9hdXRvZ2VuL3Jhd19jb25zdHJhaW50X2RhdGFfdl85X3R5cGUudHNcbnZhciBSYXdDb25zdHJhaW50RGF0YVY5ID0gdC5lbnVtKFwiUmF3Q29uc3RyYWludERhdGFWOVwiLCB7XG4gIGdldCBVbmlxdWUoKSB7XG4gICAgcmV0dXJuIHJhd191bmlxdWVfY29uc3RyYWludF9kYXRhX3ZfOV90eXBlX2RlZmF1bHQ7XG4gIH1cbn0pO1xudmFyIHJhd19jb25zdHJhaW50X2RhdGFfdl85X3R5cGVfZGVmYXVsdCA9IFJhd0NvbnN0cmFpbnREYXRhVjk7XG5cbi8vIHNyYy9saWIvYXV0b2dlbi9yYXdfY29uc3RyYWludF9kZWZfdl85X3R5cGUudHNcbnZhciByYXdfY29uc3RyYWludF9kZWZfdl85X3R5cGVfZGVmYXVsdCA9IHQub2JqZWN0KFwiUmF3Q29uc3RyYWludERlZlY5XCIsIHtcbiAgbmFtZTogdC5vcHRpb24odC5zdHJpbmcoKSksXG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiByYXdfY29uc3RyYWludF9kYXRhX3ZfOV90eXBlX2RlZmF1bHQ7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL2F1dG9nZW4vcmF3X3NlcXVlbmNlX2RlZl92XzlfdHlwZS50c1xudmFyIHJhd19zZXF1ZW5jZV9kZWZfdl85X3R5cGVfZGVmYXVsdCA9IHQub2JqZWN0KFwiUmF3U2VxdWVuY2VEZWZWOVwiLCB7XG4gIG5hbWU6IHQub3B0aW9uKHQuc3RyaW5nKCkpLFxuICBjb2x1bW46IHQudTE2KCksXG4gIHN0YXJ0OiB0Lm9wdGlvbih0LmkxMjgoKSksXG4gIG1pblZhbHVlOiB0Lm9wdGlvbih0LmkxMjgoKSksXG4gIG1heFZhbHVlOiB0Lm9wdGlvbih0LmkxMjgoKSksXG4gIGluY3JlbWVudDogdC5pMTI4KClcbn0pO1xuXG4vLyBzcmMvbGliL2F1dG9nZW4vcmF3X3NjaGVkdWxlX2RlZl92XzlfdHlwZS50c1xudmFyIHJhd19zY2hlZHVsZV9kZWZfdl85X3R5cGVfZGVmYXVsdCA9IHQub2JqZWN0KFwiUmF3U2NoZWR1bGVEZWZWOVwiLCB7XG4gIG5hbWU6IHQub3B0aW9uKHQuc3RyaW5nKCkpLFxuICByZWR1Y2VyTmFtZTogdC5zdHJpbmcoKSxcbiAgc2NoZWR1bGVkQXRDb2x1bW46IHQudTE2KClcbn0pO1xuXG4vLyBzcmMvbGliL2F1dG9nZW4vdGFibGVfdHlwZV90eXBlLnRzXG52YXIgVGFibGVUeXBlID0gdC5lbnVtKFwiVGFibGVUeXBlXCIsIHtcbiAgU3lzdGVtOiB0LnVuaXQoKSxcbiAgVXNlcjogdC51bml0KClcbn0pO1xudmFyIHRhYmxlX3R5cGVfdHlwZV9kZWZhdWx0ID0gVGFibGVUeXBlO1xuXG4vLyBzcmMvbGliL2F1dG9nZW4vdGFibGVfYWNjZXNzX3R5cGUudHNcbnZhciBUYWJsZUFjY2VzcyA9IHQuZW51bShcIlRhYmxlQWNjZXNzXCIsIHtcbiAgUHVibGljOiB0LnVuaXQoKSxcbiAgUHJpdmF0ZTogdC51bml0KClcbn0pO1xudmFyIHRhYmxlX2FjY2Vzc190eXBlX2RlZmF1bHQgPSBUYWJsZUFjY2VzcztcblxuLy8gc3JjL2xpYi9hdXRvZ2VuL3Jhd190YWJsZV9kZWZfdl85X3R5cGUudHNcbnZhciByYXdfdGFibGVfZGVmX3ZfOV90eXBlX2RlZmF1bHQgPSB0Lm9iamVjdChcIlJhd1RhYmxlRGVmVjlcIiwge1xuICBuYW1lOiB0LnN0cmluZygpLFxuICBwcm9kdWN0VHlwZVJlZjogdC51MzIoKSxcbiAgcHJpbWFyeUtleTogdC5hcnJheSh0LnUxNigpKSxcbiAgZ2V0IGluZGV4ZXMoKSB7XG4gICAgcmV0dXJuIHQuYXJyYXkocmF3X2luZGV4X2RlZl92XzlfdHlwZV9kZWZhdWx0KTtcbiAgfSxcbiAgZ2V0IGNvbnN0cmFpbnRzKCkge1xuICAgIHJldHVybiB0LmFycmF5KHJhd19jb25zdHJhaW50X2RlZl92XzlfdHlwZV9kZWZhdWx0KTtcbiAgfSxcbiAgZ2V0IHNlcXVlbmNlcygpIHtcbiAgICByZXR1cm4gdC5hcnJheShyYXdfc2VxdWVuY2VfZGVmX3ZfOV90eXBlX2RlZmF1bHQpO1xuICB9LFxuICBnZXQgc2NoZWR1bGUoKSB7XG4gICAgcmV0dXJuIHQub3B0aW9uKHJhd19zY2hlZHVsZV9kZWZfdl85X3R5cGVfZGVmYXVsdCk7XG4gIH0sXG4gIGdldCB0YWJsZVR5cGUoKSB7XG4gICAgcmV0dXJuIHRhYmxlX3R5cGVfdHlwZV9kZWZhdWx0O1xuICB9LFxuICBnZXQgdGFibGVBY2Nlc3MoKSB7XG4gICAgcmV0dXJuIHRhYmxlX2FjY2Vzc190eXBlX2RlZmF1bHQ7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL2F1dG9nZW4vcmF3X3JlZHVjZXJfZGVmX3ZfOV90eXBlLnRzXG52YXIgcmF3X3JlZHVjZXJfZGVmX3ZfOV90eXBlX2RlZmF1bHQgPSB0Lm9iamVjdChcIlJhd1JlZHVjZXJEZWZWOVwiLCB7XG4gIG5hbWU6IHQuc3RyaW5nKCksXG4gIGdldCBwYXJhbXMoKSB7XG4gICAgcmV0dXJuIHByb2R1Y3RfdHlwZV90eXBlX2RlZmF1bHQ7XG4gIH0sXG4gIGdldCBsaWZlY3ljbGUoKSB7XG4gICAgcmV0dXJuIHQub3B0aW9uKGxpZmVjeWNsZV90eXBlX2RlZmF1bHQpO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9hdXRvZ2VuL3Jhd19zY29wZWRfdHlwZV9uYW1lX3ZfOV90eXBlLnRzXG52YXIgcmF3X3Njb3BlZF90eXBlX25hbWVfdl85X3R5cGVfZGVmYXVsdCA9IHQub2JqZWN0KFwiUmF3U2NvcGVkVHlwZU5hbWVWOVwiLCB7XG4gIHNjb3BlOiB0LmFycmF5KHQuc3RyaW5nKCkpLFxuICBuYW1lOiB0LnN0cmluZygpXG59KTtcblxuLy8gc3JjL2xpYi9hdXRvZ2VuL3Jhd190eXBlX2RlZl92XzlfdHlwZS50c1xudmFyIHJhd190eXBlX2RlZl92XzlfdHlwZV9kZWZhdWx0ID0gdC5vYmplY3QoXCJSYXdUeXBlRGVmVjlcIiwge1xuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gcmF3X3Njb3BlZF90eXBlX25hbWVfdl85X3R5cGVfZGVmYXVsdDtcbiAgfSxcbiAgdHk6IHQudTMyKCksXG4gIGN1c3RvbU9yZGVyaW5nOiB0LmJvb2woKVxufSk7XG5cbi8vIHNyYy9saWIvYXV0b2dlbi9yYXdfY29sdW1uX2RlZmF1bHRfdmFsdWVfdl85X3R5cGUudHNcbnZhciByYXdfY29sdW1uX2RlZmF1bHRfdmFsdWVfdl85X3R5cGVfZGVmYXVsdCA9IHQub2JqZWN0KFwiUmF3Q29sdW1uRGVmYXVsdFZhbHVlVjlcIiwge1xuICB0YWJsZTogdC5zdHJpbmcoKSxcbiAgY29sSWQ6IHQudTE2KCksXG4gIHZhbHVlOiB0LmJ5dGVBcnJheSgpXG59KTtcblxuLy8gc3JjL2xpYi9hdXRvZ2VuL3Jhd19wcm9jZWR1cmVfZGVmX3ZfOV90eXBlLnRzXG52YXIgcmF3X3Byb2NlZHVyZV9kZWZfdl85X3R5cGVfZGVmYXVsdCA9IHQub2JqZWN0KFwiUmF3UHJvY2VkdXJlRGVmVjlcIiwge1xuICBuYW1lOiB0LnN0cmluZygpLFxuICBnZXQgcGFyYW1zKCkge1xuICAgIHJldHVybiBwcm9kdWN0X3R5cGVfdHlwZV9kZWZhdWx0O1xuICB9LFxuICBnZXQgcmV0dXJuVHlwZSgpIHtcbiAgICByZXR1cm4gYWxnZWJyYWljX3R5cGVfdHlwZV9kZWZhdWx0O1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9hdXRvZ2VuL3Jhd192aWV3X2RlZl92XzlfdHlwZS50c1xudmFyIHJhd192aWV3X2RlZl92XzlfdHlwZV9kZWZhdWx0ID0gdC5vYmplY3QoXCJSYXdWaWV3RGVmVjlcIiwge1xuICBuYW1lOiB0LnN0cmluZygpLFxuICBpbmRleDogdC51MzIoKSxcbiAgaXNQdWJsaWM6IHQuYm9vbCgpLFxuICBpc0Fub255bW91czogdC5ib29sKCksXG4gIGdldCBwYXJhbXMoKSB7XG4gICAgcmV0dXJuIHByb2R1Y3RfdHlwZV90eXBlX2RlZmF1bHQ7XG4gIH0sXG4gIGdldCByZXR1cm5UeXBlKCkge1xuICAgIHJldHVybiBhbGdlYnJhaWNfdHlwZV90eXBlX2RlZmF1bHQ7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL2F1dG9nZW4vcmF3X21pc2NfbW9kdWxlX2V4cG9ydF92XzlfdHlwZS50c1xudmFyIFJhd01pc2NNb2R1bGVFeHBvcnRWOSA9IHQuZW51bShcIlJhd01pc2NNb2R1bGVFeHBvcnRWOVwiLCB7XG4gIGdldCBDb2x1bW5EZWZhdWx0VmFsdWUoKSB7XG4gICAgcmV0dXJuIHJhd19jb2x1bW5fZGVmYXVsdF92YWx1ZV92XzlfdHlwZV9kZWZhdWx0O1xuICB9LFxuICBnZXQgUHJvY2VkdXJlKCkge1xuICAgIHJldHVybiByYXdfcHJvY2VkdXJlX2RlZl92XzlfdHlwZV9kZWZhdWx0O1xuICB9LFxuICBnZXQgVmlldygpIHtcbiAgICByZXR1cm4gcmF3X3ZpZXdfZGVmX3ZfOV90eXBlX2RlZmF1bHQ7XG4gIH1cbn0pO1xudmFyIHJhd19taXNjX21vZHVsZV9leHBvcnRfdl85X3R5cGVfZGVmYXVsdCA9IFJhd01pc2NNb2R1bGVFeHBvcnRWOTtcblxuLy8gc3JjL2xpYi9hdXRvZ2VuL3Jhd19yb3dfbGV2ZWxfc2VjdXJpdHlfZGVmX3ZfOV90eXBlLnRzXG52YXIgcmF3X3Jvd19sZXZlbF9zZWN1cml0eV9kZWZfdl85X3R5cGVfZGVmYXVsdCA9IHQub2JqZWN0KFwiUmF3Um93TGV2ZWxTZWN1cml0eURlZlY5XCIsIHtcbiAgc3FsOiB0LnN0cmluZygpXG59KTtcblxuLy8gc3JjL2xpYi9hdXRvZ2VuL3Jhd19tb2R1bGVfZGVmX3ZfOV90eXBlLnRzXG52YXIgcmF3X21vZHVsZV9kZWZfdl85X3R5cGVfZGVmYXVsdCA9IHQub2JqZWN0KFwiUmF3TW9kdWxlRGVmVjlcIiwge1xuICBnZXQgdHlwZXNwYWNlKCkge1xuICAgIHJldHVybiB0eXBlc3BhY2VfdHlwZV9kZWZhdWx0O1xuICB9LFxuICBnZXQgdGFibGVzKCkge1xuICAgIHJldHVybiB0LmFycmF5KHJhd190YWJsZV9kZWZfdl85X3R5cGVfZGVmYXVsdCk7XG4gIH0sXG4gIGdldCByZWR1Y2VycygpIHtcbiAgICByZXR1cm4gdC5hcnJheShyYXdfcmVkdWNlcl9kZWZfdl85X3R5cGVfZGVmYXVsdCk7XG4gIH0sXG4gIGdldCB0eXBlcygpIHtcbiAgICByZXR1cm4gdC5hcnJheShyYXdfdHlwZV9kZWZfdl85X3R5cGVfZGVmYXVsdCk7XG4gIH0sXG4gIGdldCBtaXNjRXhwb3J0cygpIHtcbiAgICByZXR1cm4gdC5hcnJheShyYXdfbWlzY19tb2R1bGVfZXhwb3J0X3ZfOV90eXBlX2RlZmF1bHQpO1xuICB9LFxuICBnZXQgcm93TGV2ZWxTZWN1cml0eSgpIHtcbiAgICByZXR1cm4gdC5hcnJheShyYXdfcm93X2xldmVsX3NlY3VyaXR5X2RlZl92XzlfdHlwZV9kZWZhdWx0KTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvYXV0b2dlbi9yYXdfbW9kdWxlX2RlZl90eXBlLnRzXG52YXIgUmF3TW9kdWxlRGVmID0gdC5lbnVtKFwiUmF3TW9kdWxlRGVmXCIsIHtcbiAgZ2V0IFY4QmFja0NvbXBhdCgpIHtcbiAgICByZXR1cm4gcmF3X21vZHVsZV9kZWZfdl84X3R5cGVfZGVmYXVsdDtcbiAgfSxcbiAgZ2V0IFY5KCkge1xuICAgIHJldHVybiByYXdfbW9kdWxlX2RlZl92XzlfdHlwZV9kZWZhdWx0O1xuICB9XG59KTtcbnZhciByYXdfbW9kdWxlX2RlZl90eXBlX2RlZmF1bHQgPSBSYXdNb2R1bGVEZWY7XG5cbi8vIHNyYy9zZXJ2ZXIvcmFuZ2UudHNcbnZhciBSYW5nZSA9IGNsYXNzIHtcbiAgI2Zyb207XG4gICN0bztcbiAgY29uc3RydWN0b3IoZnJvbSwgdG8pIHtcbiAgICB0aGlzLiNmcm9tID0gZnJvbSA/PyB7IHRhZzogXCJ1bmJvdW5kZWRcIiB9O1xuICAgIHRoaXMuI3RvID0gdG8gPz8geyB0YWc6IFwidW5ib3VuZGVkXCIgfTtcbiAgfVxuICBnZXQgZnJvbSgpIHtcbiAgICByZXR1cm4gdGhpcy4jZnJvbTtcbiAgfVxuICBnZXQgdG8oKSB7XG4gICAgcmV0dXJuIHRoaXMuI3RvO1xuICB9XG59O1xuXG4vLyBzcmMvc2VydmVyL2h0dHBfaW50ZXJuYWwudHNcbnZhciBpbXBvcnRfc3RhdHVzZXMgPSBfX3RvRVNNKHJlcXVpcmVfc3RhdHVzZXMoKSk7XG5cbi8vIHNyYy9saWIvYXV0b2dlbi9odHRwX2hlYWRlcl9wYWlyX3R5cGUudHNcbnZhciBodHRwX2hlYWRlcl9wYWlyX3R5cGVfZGVmYXVsdCA9IHQub2JqZWN0KFwiSHR0cEhlYWRlclBhaXJcIiwge1xuICBuYW1lOiB0LnN0cmluZygpLFxuICB2YWx1ZTogdC5ieXRlQXJyYXkoKVxufSk7XG5cbi8vIHNyYy9saWIvYXV0b2dlbi9odHRwX2hlYWRlcnNfdHlwZS50c1xudmFyIGh0dHBfaGVhZGVyc190eXBlX2RlZmF1bHQgPSB0Lm9iamVjdChcIkh0dHBIZWFkZXJzXCIsIHtcbiAgZ2V0IGVudHJpZXMoKSB7XG4gICAgcmV0dXJuIHQuYXJyYXkoaHR0cF9oZWFkZXJfcGFpcl90eXBlX2RlZmF1bHQpO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9hdXRvZ2VuL2h0dHBfbWV0aG9kX3R5cGUudHNcbnZhciBIdHRwTWV0aG9kID0gdC5lbnVtKFwiSHR0cE1ldGhvZFwiLCB7XG4gIEdldDogdC51bml0KCksXG4gIEhlYWQ6IHQudW5pdCgpLFxuICBQb3N0OiB0LnVuaXQoKSxcbiAgUHV0OiB0LnVuaXQoKSxcbiAgRGVsZXRlOiB0LnVuaXQoKSxcbiAgQ29ubmVjdDogdC51bml0KCksXG4gIE9wdGlvbnM6IHQudW5pdCgpLFxuICBUcmFjZTogdC51bml0KCksXG4gIFBhdGNoOiB0LnVuaXQoKSxcbiAgRXh0ZW5zaW9uOiB0LnN0cmluZygpXG59KTtcbnZhciBodHRwX21ldGhvZF90eXBlX2RlZmF1bHQgPSBIdHRwTWV0aG9kO1xuXG4vLyBzcmMvbGliL2F1dG9nZW4vaHR0cF92ZXJzaW9uX3R5cGUudHNcbnZhciBIdHRwVmVyc2lvbiA9IHQuZW51bShcIkh0dHBWZXJzaW9uXCIsIHtcbiAgSHR0cDA5OiB0LnVuaXQoKSxcbiAgSHR0cDEwOiB0LnVuaXQoKSxcbiAgSHR0cDExOiB0LnVuaXQoKSxcbiAgSHR0cDI6IHQudW5pdCgpLFxuICBIdHRwMzogdC51bml0KClcbn0pO1xudmFyIGh0dHBfdmVyc2lvbl90eXBlX2RlZmF1bHQgPSBIdHRwVmVyc2lvbjtcblxuLy8gc3JjL2xpYi9hdXRvZ2VuL2h0dHBfcmVxdWVzdF90eXBlLnRzXG52YXIgaHR0cF9yZXF1ZXN0X3R5cGVfZGVmYXVsdCA9IHQub2JqZWN0KFwiSHR0cFJlcXVlc3RcIiwge1xuICBnZXQgbWV0aG9kKCkge1xuICAgIHJldHVybiBodHRwX21ldGhvZF90eXBlX2RlZmF1bHQ7XG4gIH0sXG4gIGdldCBoZWFkZXJzKCkge1xuICAgIHJldHVybiBodHRwX2hlYWRlcnNfdHlwZV9kZWZhdWx0O1xuICB9LFxuICB0aW1lb3V0OiB0Lm9wdGlvbih0LnRpbWVEdXJhdGlvbigpKSxcbiAgdXJpOiB0LnN0cmluZygpLFxuICBnZXQgdmVyc2lvbigpIHtcbiAgICByZXR1cm4gaHR0cF92ZXJzaW9uX3R5cGVfZGVmYXVsdDtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvYXV0b2dlbi9odHRwX3Jlc3BvbnNlX3R5cGUudHNcbnZhciBodHRwX3Jlc3BvbnNlX3R5cGVfZGVmYXVsdCA9IHQub2JqZWN0KFwiSHR0cFJlc3BvbnNlXCIsIHtcbiAgZ2V0IGhlYWRlcnMoKSB7XG4gICAgcmV0dXJuIGh0dHBfaGVhZGVyc190eXBlX2RlZmF1bHQ7XG4gIH0sXG4gIGdldCB2ZXJzaW9uKCkge1xuICAgIHJldHVybiBodHRwX3ZlcnNpb25fdHlwZV9kZWZhdWx0O1xuICB9LFxuICBjb2RlOiB0LnUxNigpXG59KTtcblxuLy8gc3JjL3NlcnZlci9odHRwX2ludGVybmFsLnRzXG52YXIgeyBmcmVlemUgfSA9IE9iamVjdDtcbnZhciB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xudmFyIHRleHREZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKFxuICBcInV0Zi04XCJcbiAgLyogeyBmYXRhbDogdHJ1ZSB9ICovXG4pO1xudmFyIG1ha2VSZXNwb25zZSA9IFN5bWJvbChcIm1ha2VSZXNwb25zZVwiKTtcbnZhciBTeW5jUmVzcG9uc2UgPSBjbGFzcyBfU3luY1Jlc3BvbnNlIHtcbiAgI2JvZHk7XG4gICNpbm5lcjtcbiAgY29uc3RydWN0b3IoYm9keSwgaW5pdDIpIHtcbiAgICBpZiAoYm9keSA9PSBudWxsKSB7XG4gICAgICB0aGlzLiNib2R5ID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBib2R5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aGlzLiNib2R5ID0gYm9keTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jYm9keSA9IG5ldyBVaW50OEFycmF5KGJvZHkpLmJ1ZmZlcjtcbiAgICB9XG4gICAgdGhpcy4jaW5uZXIgPSB7XG4gICAgICBoZWFkZXJzOiBuZXcgSGVhZGVycyhpbml0Mj8uaGVhZGVycyksXG4gICAgICBzdGF0dXM6IGluaXQyPy5zdGF0dXMgPz8gMjAwLFxuICAgICAgc3RhdHVzVGV4dDogaW5pdDI/LnN0YXR1c1RleHQgPz8gXCJcIixcbiAgICAgIHR5cGU6IFwiZGVmYXVsdFwiLFxuICAgICAgdXJsOiBudWxsLFxuICAgICAgYWJvcnRlZDogZmFsc2VcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBbbWFrZVJlc3BvbnNlXShib2R5LCBpbm5lcikge1xuICAgIGNvbnN0IG1lID0gbmV3IF9TeW5jUmVzcG9uc2UoYm9keSk7XG4gICAgbWUuI2lubmVyID0gaW5uZXI7XG4gICAgcmV0dXJuIG1lO1xuICB9XG4gIGdldCBoZWFkZXJzKCkge1xuICAgIHJldHVybiB0aGlzLiNpbm5lci5oZWFkZXJzO1xuICB9XG4gIGdldCBzdGF0dXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2lubmVyLnN0YXR1cztcbiAgfVxuICBnZXQgc3RhdHVzVGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy4jaW5uZXIuc3RhdHVzVGV4dDtcbiAgfVxuICBnZXQgb2soKSB7XG4gICAgcmV0dXJuIDIwMCA8PSB0aGlzLiNpbm5lci5zdGF0dXMgJiYgdGhpcy4jaW5uZXIuc3RhdHVzIDw9IDI5OTtcbiAgfVxuICBnZXQgdXJsKCkge1xuICAgIHJldHVybiB0aGlzLiNpbm5lci51cmwgPz8gXCJcIjtcbiAgfVxuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jaW5uZXIudHlwZTtcbiAgfVxuICBhcnJheUJ1ZmZlcigpIHtcbiAgICByZXR1cm4gdGhpcy5ieXRlcygpLmJ1ZmZlcjtcbiAgfVxuICBieXRlcygpIHtcbiAgICBpZiAodGhpcy4jYm9keSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLiNib2R5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gdGV4dEVuY29kZXIuZW5jb2RlKHRoaXMuI2JvZHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodGhpcy4jYm9keSk7XG4gICAgfVxuICB9XG4gIGpzb24oKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UodGhpcy50ZXh0KCkpO1xuICB9XG4gIHRleHQoKSB7XG4gICAgaWYgKHRoaXMuI2JvZHkgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy4jYm9keSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIHRoaXMuI2JvZHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0ZXh0RGVjb2Rlci5kZWNvZGUodGhpcy4jYm9keSk7XG4gICAgfVxuICB9XG59O1xudmFyIHJlcXVlc3RCYXNlU2l6ZSA9IGJzYXRuQmFzZVNpemUoeyB0eXBlczogW10gfSwgaHR0cF9yZXF1ZXN0X3R5cGVfZGVmYXVsdC5hbGdlYnJhaWNUeXBlKTtcbnZhciBtZXRob2RzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICBbXCJHRVRcIiwgeyB0YWc6IFwiR2V0XCIgfV0sXG4gIFtcIkhFQURcIiwgeyB0YWc6IFwiSGVhZFwiIH1dLFxuICBbXCJQT1NUXCIsIHsgdGFnOiBcIlBvc3RcIiB9XSxcbiAgW1wiUFVUXCIsIHsgdGFnOiBcIlB1dFwiIH1dLFxuICBbXCJERUxFVEVcIiwgeyB0YWc6IFwiRGVsZXRlXCIgfV0sXG4gIFtcIkNPTk5FQ1RcIiwgeyB0YWc6IFwiQ29ubmVjdFwiIH1dLFxuICBbXCJPUFRJT05TXCIsIHsgdGFnOiBcIk9wdGlvbnNcIiB9XSxcbiAgW1wiVFJBQ0VcIiwgeyB0YWc6IFwiVHJhY2VcIiB9XSxcbiAgW1wiUEFUQ0hcIiwgeyB0YWc6IFwiUGF0Y2hcIiB9XVxuXSk7XG5mdW5jdGlvbiBmZXRjaCh1cmwsIGluaXQyID0ge30pIHtcbiAgY29uc3QgbWV0aG9kID0gbWV0aG9kcy5nZXQoaW5pdDIubWV0aG9kPy50b1VwcGVyQ2FzZSgpID8/IFwiR0VUXCIpID8/IHtcbiAgICB0YWc6IFwiRXh0ZW5zaW9uXCIsXG4gICAgdmFsdWU6IGluaXQyLm1ldGhvZFxuICB9O1xuICBjb25zdCBoZWFkZXJzID0ge1xuICAgIC8vIGFueXMgYmVjYXVzZSB0aGUgdHlwaW5ncyBhcmUgd29ua3kgLSBzZWUgY29tbWVudCBpbiBTeW5jUmVzcG9uc2UuY29uc3RydWN0b3JcbiAgICBlbnRyaWVzOiBoZWFkZXJzVG9MaXN0KG5ldyBIZWFkZXJzKGluaXQyLmhlYWRlcnMpKS5mbGF0TWFwKChbaywgdl0pID0+IEFycmF5LmlzQXJyYXkodikgPyB2Lm1hcCgodjIpID0+IFtrLCB2Ml0pIDogW1trLCB2XV0pLm1hcCgoW25hbWUsIHZhbHVlXSkgPT4gKHsgbmFtZSwgdmFsdWU6IHRleHRFbmNvZGVyLmVuY29kZSh2YWx1ZSkgfSkpXG4gIH07XG4gIGNvbnN0IHVyaSA9IFwiXCIgKyB1cmw7XG4gIGNvbnN0IHJlcXVlc3QgPSBmcmVlemUoe1xuICAgIG1ldGhvZCxcbiAgICBoZWFkZXJzLFxuICAgIHRpbWVvdXQ6IGluaXQyLnRpbWVvdXQsXG4gICAgdXJpLFxuICAgIHZlcnNpb246IHsgdGFnOiBcIkh0dHAxMVwiIH1cbiAgfSk7XG4gIGNvbnN0IHJlcXVlc3RCdWYgPSBuZXcgQmluYXJ5V3JpdGVyKHJlcXVlc3RCYXNlU2l6ZSk7XG4gIGh0dHBfcmVxdWVzdF90eXBlX2RlZmF1bHQuc2VyaWFsaXplKHJlcXVlc3RCdWYsIHJlcXVlc3QpO1xuICBjb25zdCBib2R5ID0gaW5pdDIuYm9keSA9PSBudWxsID8gbmV3IFVpbnQ4QXJyYXkoKSA6IHR5cGVvZiBpbml0Mi5ib2R5ID09PSBcInN0cmluZ1wiID8gaW5pdDIuYm9keSA6IG5ldyBVaW50OEFycmF5KGluaXQyLmJvZHkpO1xuICBjb25zdCBbcmVzcG9uc2VCdWYsIHJlc3BvbnNlQm9keV0gPSBzeXMucHJvY2VkdXJlX2h0dHBfcmVxdWVzdChcbiAgICByZXF1ZXN0QnVmLmdldEJ1ZmZlcigpLFxuICAgIGJvZHlcbiAgKTtcbiAgY29uc3QgcmVzcG9uc2UgPSBodHRwX3Jlc3BvbnNlX3R5cGVfZGVmYXVsdC5kZXNlcmlhbGl6ZShuZXcgQmluYXJ5UmVhZGVyKHJlc3BvbnNlQnVmKSk7XG4gIHJldHVybiBTeW5jUmVzcG9uc2VbbWFrZVJlc3BvbnNlXShyZXNwb25zZUJvZHksIHtcbiAgICB0eXBlOiBcImJhc2ljXCIsXG4gICAgdXJsOiB1cmksXG4gICAgc3RhdHVzOiByZXNwb25zZS5jb2RlLFxuICAgIHN0YXR1c1RleHQ6ICgwLCBpbXBvcnRfc3RhdHVzZXMuZGVmYXVsdCkocmVzcG9uc2UuY29kZSksXG4gICAgaGVhZGVyczogbmV3IEhlYWRlcnMoKSxcbiAgICBhYm9ydGVkOiBmYWxzZVxuICB9KTtcbn1cbmZyZWV6ZShmZXRjaCk7XG52YXIgaHR0cENsaWVudCA9IGZyZWV6ZSh7IGZldGNoIH0pO1xuXG4vLyBzcmMvc2VydmVyL3Byb2NlZHVyZXMudHNcbnZhciB7IGZyZWV6ZTogZnJlZXplMiB9ID0gT2JqZWN0O1xuZnVuY3Rpb24gY2FsbFByb2NlZHVyZShpZCwgc2VuZGVyLCBjb25uZWN0aW9uSWQsIHRpbWVzdGFtcCwgYXJnc0J1Zikge1xuICBjb25zdCB7IGZuLCBwYXJhbXNUeXBlLCByZXR1cm5UeXBlLCByZXR1cm5UeXBlQmFzZVNpemUgfSA9IFBST0NFRFVSRVNbaWRdO1xuICBjb25zdCBhcmdzID0gUHJvZHVjdFR5cGUuZGVzZXJpYWxpemVWYWx1ZShcbiAgICBuZXcgQmluYXJ5UmVhZGVyKGFyZ3NCdWYpLFxuICAgIHBhcmFtc1R5cGUsXG4gICAgTU9EVUxFX0RFRi50eXBlc3BhY2VcbiAgKTtcbiAgY29uc3QgY3R4ID0ge1xuICAgIHNlbmRlcixcbiAgICB0aW1lc3RhbXAsXG4gICAgY29ubmVjdGlvbklkLFxuICAgIGh0dHA6IGh0dHBDbGllbnQsXG4gICAgLy8gKipOb3RlOioqIG11c3QgYmUgMC4uPXUzMjo6TUFYXG4gICAgY291bnRlcl91dWlkOiB7IHZhbHVlOiBOdW1iZXIoMCkgfSxcbiAgICBnZXQgaWRlbnRpdHkoKSB7XG4gICAgICByZXR1cm4gbmV3IElkZW50aXR5KHN5cy5pZGVudGl0eSgpLl9faWRlbnRpdHlfXyk7XG4gICAgfSxcbiAgICB3aXRoVHgoYm9keSkge1xuICAgICAgY29uc3QgcnVuID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB0aW1lc3RhbXAyID0gc3lzLnByb2NlZHVyZV9zdGFydF9tdXRfdHgoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBjdHgyID0gbmV3IFJlZHVjZXJDdHhJbXBsKFxuICAgICAgICAgICAgc2VuZGVyLFxuICAgICAgICAgICAgbmV3IFRpbWVzdGFtcCh0aW1lc3RhbXAyKSxcbiAgICAgICAgICAgIGNvbm5lY3Rpb25JZFxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIGJvZHkoY3R4Mik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBzeXMucHJvY2VkdXJlX2Fib3J0X211dF90eCgpO1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBsZXQgcmVzID0gcnVuKCk7XG4gICAgICB0cnkge1xuICAgICAgICBzeXMucHJvY2VkdXJlX2NvbW1pdF9tdXRfdHgoKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgfVxuICAgICAgY29uc29sZS53YXJuKFwiY29tbWl0dGluZyBhbm9ueW1vdXMgdHJhbnNhY3Rpb24gZmFpbGVkXCIpO1xuICAgICAgcmVzID0gcnVuKCk7XG4gICAgICB0cnkge1xuICAgICAgICBzeXMucHJvY2VkdXJlX2NvbW1pdF9tdXRfdHgoKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJhbnNhY3Rpb24gcmV0cnkgZmFpbGVkIGFnYWluXCIsIHsgY2F1c2U6IGUgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgcmFuZG9tIHtAbGluayBVdWlkfSBgdjRgIHVzaW5nIHRoZSB7QGxpbmsgY3J5cHRvfSBSTkcuXG4gICAgICpcbiAgICAgKiBXQVJOOiBVbnRpbCB3ZSB1c2UgYSBzcGFjZXRpbWUgUk5HIHRoaXMgbWFrZSBjYWxscyBub24tZGV0ZXJtaW5pc3RpYy5cbiAgICAgKi9cbiAgICBuZXdVdWlkVjQoKSB7XG4gICAgICBjb25zdCBieXRlcyA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoMTYpKTtcbiAgICAgIHJldHVybiBVdWlkLmZyb21SYW5kb21CeXRlc1Y0KGJ5dGVzKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBzb3J0YWJsZSB7QGxpbmsgVXVpZH0gYHY3YCB1c2luZyB0aGUge0BsaW5rIGNyeXB0b30gUk5HLCBjb3VudGVyLFxuICAgICAqIGFuZCB0aGUgdGltZXN0YW1wLlxuICAgICAqXG4gICAgICogV0FSTjogVW50aWwgd2UgdXNlIGEgc3BhY2V0aW1lIFJORyB0aGlzIG1ha2UgY2FsbHMgbm9uLWRldGVybWluaXN0aWMuXG4gICAgICovXG4gICAgbmV3VXVpZFY3KCkge1xuICAgICAgY29uc3QgYnl0ZXMgPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KDEwKSk7XG4gICAgICByZXR1cm4gVXVpZC5mcm9tQ291bnRlclY3KHRoaXMuY291bnRlcl91dWlkLCB0aGlzLnRpbWVzdGFtcCwgYnl0ZXMpO1xuICAgIH1cbiAgfTtcbiAgZnJlZXplMihjdHgpO1xuICBjb25zdCByZXQgPSBjYWxsVXNlckZ1bmN0aW9uKGZuLCBjdHgsIGFyZ3MpO1xuICBjb25zdCByZXRCdWYgPSBuZXcgQmluYXJ5V3JpdGVyKHJldHVyblR5cGVCYXNlU2l6ZSk7XG4gIEFsZ2VicmFpY1R5cGUuc2VyaWFsaXplVmFsdWUocmV0QnVmLCByZXR1cm5UeXBlLCByZXQsIE1PRFVMRV9ERUYudHlwZXNwYWNlKTtcbiAgcmV0dXJuIHJldEJ1Zi5nZXRCdWZmZXIoKTtcbn1cblxuLy8gc3JjL2xpYi9hdXRvZ2VuL3ZpZXdfcmVzdWx0X2hlYWRlcl90eXBlLnRzXG52YXIgVmlld1Jlc3VsdEhlYWRlciA9IHQuZW51bShcIlZpZXdSZXN1bHRIZWFkZXJcIiwge1xuICBSb3dEYXRhOiB0LnVuaXQoKSxcbiAgUmF3U3FsOiB0LnN0cmluZygpXG59KTtcbnZhciB2aWV3X3Jlc3VsdF9oZWFkZXJfdHlwZV9kZWZhdWx0ID0gVmlld1Jlc3VsdEhlYWRlcjtcblxuLy8gc3JjL3NlcnZlci9ydW50aW1lLnRzXG52YXIgeyBmcmVlemU6IGZyZWV6ZTMgfSA9IE9iamVjdDtcbnZhciBzeXMgPSBmcmVlemUzKHdyYXBTeXNjYWxscyhfc3lzY2FsbHMxXzAsIF9zeXNjYWxsczFfMikpO1xuZnVuY3Rpb24gcGFyc2VKc29uT2JqZWN0KGpzb24pIHtcbiAgbGV0IHZhbHVlO1xuICB0cnkge1xuICAgIHZhbHVlID0gSlNPTi5wYXJzZShqc29uKTtcbiAgfSBjYXRjaCB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBKU09OOiBmYWlsZWQgdG8gcGFyc2Ugc3RyaW5nXCIpO1xuICB9XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBhIEpTT04gb2JqZWN0IGF0IHRoZSB0b3AgbGV2ZWxcIik7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxudmFyIEp3dENsYWltc0ltcGwgPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IEp3dENsYWltcyBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHJhd1BheWxvYWQgVGhlIEpXVCBwYXlsb2FkIGFzIGEgcmF3IEpTT04gc3RyaW5nLlxuICAgKiBAcGFyYW0gaWRlbnRpdHkgVGhlIGlkZW50aXR5IGZvciB0aGlzIEpXVC4gV2UgYXJlIG9ubHkgdGFraW5nIHRoaXMgYmVjYXVzZSB3ZSBkb24ndCBoYXZlIGEgYmxha2UzIGltcGxlbWVudGF0aW9uICh3aGljaCB3ZSBuZWVkIHRvIGNvbXB1dGUgaXQpLlxuICAgKi9cbiAgY29uc3RydWN0b3IocmF3UGF5bG9hZCwgaWRlbnRpdHkpIHtcbiAgICB0aGlzLnJhd1BheWxvYWQgPSByYXdQYXlsb2FkO1xuICAgIHRoaXMuZnVsbFBheWxvYWQgPSBwYXJzZUpzb25PYmplY3QocmF3UGF5bG9hZCk7XG4gICAgdGhpcy5faWRlbnRpdHkgPSBpZGVudGl0eTtcbiAgfVxuICBmdWxsUGF5bG9hZDtcbiAgX2lkZW50aXR5O1xuICBnZXQgaWRlbnRpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lkZW50aXR5O1xuICB9XG4gIGdldCBzdWJqZWN0KCkge1xuICAgIHJldHVybiB0aGlzLmZ1bGxQYXlsb2FkW1wic3ViXCJdO1xuICB9XG4gIGdldCBpc3N1ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZnVsbFBheWxvYWRbXCJpc3NcIl07XG4gIH1cbiAgZ2V0IGF1ZGllbmNlKCkge1xuICAgIGNvbnN0IGF1ZCA9IHRoaXMuZnVsbFBheWxvYWRbXCJhdWRcIl07XG4gICAgaWYgKGF1ZCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiB0eXBlb2YgYXVkID09PSBcInN0cmluZ1wiID8gW2F1ZF0gOiBhdWQ7XG4gIH1cbn07XG52YXIgQXV0aEN0eEltcGwgPSBjbGFzcyBfQXV0aEN0eEltcGwge1xuICBpc0ludGVybmFsO1xuICAvLyBTb3VyY2Ugb2YgdGhlIEpXVCBwYXlsb2FkIHN0cmluZywgaWYgdGhlcmUgaXMgb25lLlxuICBfand0U291cmNlO1xuICAvLyBXaGV0aGVyIHdlIGhhdmUgaW5pdGlhbGl6ZWQgdGhlIEpXVCBjbGFpbXMuXG4gIF9pbml0aWFsaXplZEpXVCA9IGZhbHNlO1xuICBfand0Q2xhaW1zO1xuICBfc2VuZGVySWRlbnRpdHk7XG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICB0aGlzLmlzSW50ZXJuYWwgPSBvcHRzLmlzSW50ZXJuYWw7XG4gICAgdGhpcy5fand0U291cmNlID0gb3B0cy5qd3RTb3VyY2U7XG4gICAgdGhpcy5fc2VuZGVySWRlbnRpdHkgPSBvcHRzLnNlbmRlcklkZW50aXR5O1xuICB9XG4gIF9pbml0aWFsaXplSldUKCkge1xuICAgIGlmICh0aGlzLl9pbml0aWFsaXplZEpXVCkgcmV0dXJuO1xuICAgIHRoaXMuX2luaXRpYWxpemVkSldUID0gdHJ1ZTtcbiAgICBjb25zdCB0b2tlbiA9IHRoaXMuX2p3dFNvdXJjZSgpO1xuICAgIGlmICghdG9rZW4pIHtcbiAgICAgIHRoaXMuX2p3dENsYWltcyA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2p3dENsYWltcyA9IG5ldyBKd3RDbGFpbXNJbXBsKHRva2VuLCB0aGlzLl9zZW5kZXJJZGVudGl0eSk7XG4gICAgfVxuICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gIH1cbiAgLyoqIExhemlseSBjb21wdXRlIHdoZXRoZXIgYSBKV1QgZXhpc3RzIGFuZCBpcyBwYXJzZWFibGUuICovXG4gIGdldCBoYXNKV1QoKSB7XG4gICAgdGhpcy5faW5pdGlhbGl6ZUpXVCgpO1xuICAgIHJldHVybiB0aGlzLl9qd3RDbGFpbXMgIT09IG51bGw7XG4gIH1cbiAgLyoqIExhemlseSBwYXJzZSB0aGUgSnd0Q2xhaW1zIG9ubHkgd2hlbiBhY2Nlc3NlZC4gKi9cbiAgZ2V0IGp3dCgpIHtcbiAgICB0aGlzLl9pbml0aWFsaXplSldUKCk7XG4gICAgcmV0dXJuIHRoaXMuX2p3dENsYWltcztcbiAgfVxuICAvKiogQ3JlYXRlIGEgY29udGV4dCByZXByZXNlbnRpbmcgaW50ZXJuYWwgKG5vbi11c2VyKSByZXF1ZXN0cy4gKi9cbiAgc3RhdGljIGludGVybmFsKCkge1xuICAgIHJldHVybiBuZXcgX0F1dGhDdHhJbXBsKHtcbiAgICAgIGlzSW50ZXJuYWw6IHRydWUsXG4gICAgICBqd3RTb3VyY2U6ICgpID0+IG51bGwsXG4gICAgICBzZW5kZXJJZGVudGl0eTogSWRlbnRpdHkuemVybygpXG4gICAgfSk7XG4gIH1cbiAgLyoqIElmIHRoZXJlIGlzIGEgY29ubmVjdGlvbiBpZCwgbG9vayB1cCB0aGUgSldUIHBheWxvYWQgZnJvbSB0aGUgc3lzdGVtIHRhYmxlcy4gKi9cbiAgc3RhdGljIGZyb21TeXN0ZW1UYWJsZXMoY29ubmVjdGlvbklkLCBzZW5kZXIpIHtcbiAgICBpZiAoY29ubmVjdGlvbklkID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbmV3IF9BdXRoQ3R4SW1wbCh7XG4gICAgICAgIGlzSW50ZXJuYWw6IGZhbHNlLFxuICAgICAgICBqd3RTb3VyY2U6ICgpID0+IG51bGwsXG4gICAgICAgIHNlbmRlcklkZW50aXR5OiBzZW5kZXJcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IF9BdXRoQ3R4SW1wbCh7XG4gICAgICBpc0ludGVybmFsOiBmYWxzZSxcbiAgICAgIGp3dFNvdXJjZTogKCkgPT4ge1xuICAgICAgICBjb25zdCBwYXlsb2FkQnVmID0gc3lzLmdldF9qd3RfcGF5bG9hZChjb25uZWN0aW9uSWQuX19jb25uZWN0aW9uX2lkX18pO1xuICAgICAgICBpZiAocGF5bG9hZEJ1Zi5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuICAgICAgICBjb25zdCBwYXlsb2FkU3RyID0gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKHBheWxvYWRCdWYpO1xuICAgICAgICByZXR1cm4gcGF5bG9hZFN0cjtcbiAgICAgIH0sXG4gICAgICBzZW5kZXJJZGVudGl0eTogc2VuZGVyXG4gICAgfSk7XG4gIH1cbn07XG52YXIgUmVkdWNlckN0eEltcGwgPSBjbGFzcyBSZWR1Y2VyQ3R4IHtcbiAgI2lkZW50aXR5O1xuICAjc2VuZGVyQXV0aDtcbiAgI3V1aWRDb3VudGVyO1xuICBzZW5kZXI7XG4gIHRpbWVzdGFtcDtcbiAgY29ubmVjdGlvbklkO1xuICBkYjtcbiAgY29uc3RydWN0b3Ioc2VuZGVyLCB0aW1lc3RhbXAsIGNvbm5lY3Rpb25JZCkge1xuICAgIE9iamVjdC5zZWFsKHRoaXMpO1xuICAgIHRoaXMuc2VuZGVyID0gc2VuZGVyO1xuICAgIHRoaXMudGltZXN0YW1wID0gdGltZXN0YW1wO1xuICAgIHRoaXMuY29ubmVjdGlvbklkID0gY29ubmVjdGlvbklkO1xuICAgIHRoaXMuZGIgPSBnZXREYlZpZXcoKTtcbiAgfVxuICBnZXQgaWRlbnRpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2lkZW50aXR5ID8/PSBuZXcgSWRlbnRpdHkoc3lzLmlkZW50aXR5KCkuX19pZGVudGl0eV9fKTtcbiAgfVxuICBnZXQgc2VuZGVyQXV0aCgpIHtcbiAgICByZXR1cm4gdGhpcy4jc2VuZGVyQXV0aCA/Pz0gQXV0aEN0eEltcGwuZnJvbVN5c3RlbVRhYmxlcyhcbiAgICAgIHRoaXMuY29ubmVjdGlvbklkLFxuICAgICAgdGhpcy5zZW5kZXJcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgcmFuZG9tIHtAbGluayBVdWlkfSBgdjRgIHVzaW5nIHRoZSB7QGxpbmsgY3J5cHRvfSBSTkcuXG4gICAqXG4gICAqIFdBUk46IFVudGlsIHdlIHVzZSBhIHNwYWNldGltZSBSTkcgdGhpcyBtYWtlIGNhbGxzIG5vbi1kZXRlcm1pbmlzdGljLlxuICAgKi9cbiAgbmV3VXVpZFY0KCkge1xuICAgIGNvbnN0IGJ5dGVzID0gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheSgxNikpO1xuICAgIHJldHVybiBVdWlkLmZyb21SYW5kb21CeXRlc1Y0KGJ5dGVzKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHNvcnRhYmxlIHtAbGluayBVdWlkfSBgdjdgIHVzaW5nIHRoZSB7QGxpbmsgY3J5cHRvfSBSTkcsIGNvdW50ZXIsXG4gICAqIGFuZCB0aGUgdGltZXN0YW1wLlxuICAgKlxuICAgKiBXQVJOOiBVbnRpbCB3ZSB1c2UgYSBzcGFjZXRpbWUgUk5HIHRoaXMgbWFrZSBjYWxscyBub24tZGV0ZXJtaW5pc3RpYy5cbiAgICovXG4gIG5ld1V1aWRWNygpIHtcbiAgICBjb25zdCBieXRlcyA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoNCkpO1xuICAgIGNvbnN0IGNvdW50ZXIgPSB0aGlzLiN1dWlkQ291bnRlciA/Pz0geyB2YWx1ZTogMCB9O1xuICAgIHJldHVybiBVdWlkLmZyb21Db3VudGVyVjcoY291bnRlciwgdGhpcy50aW1lc3RhbXAsIGJ5dGVzKTtcbiAgfVxufTtcbnZhciBjYWxsVXNlckZ1bmN0aW9uID0gZnVuY3Rpb24gX19zcGFjZXRpbWVkYl9lbmRfc2hvcnRfYmFja3RyYWNlKGZuLCAuLi5hcmdzKSB7XG4gIHJldHVybiBmbiguLi5hcmdzKTtcbn07XG52YXIgaG9va3MgPSB7XG4gIF9fZGVzY3JpYmVfbW9kdWxlX18oKSB7XG4gICAgY29uc3Qgd3JpdGVyID0gbmV3IEJpbmFyeVdyaXRlcigxMjgpO1xuICAgIEFsZ2VicmFpY1R5cGUuc2VyaWFsaXplVmFsdWUoXG4gICAgICB3cml0ZXIsXG4gICAgICByYXdfbW9kdWxlX2RlZl90eXBlX2RlZmF1bHQuYWxnZWJyYWljVHlwZSxcbiAgICAgIHJhd19tb2R1bGVfZGVmX3R5cGVfZGVmYXVsdC5WOShNT0RVTEVfREVGKVxuICAgICk7XG4gICAgcmV0dXJuIHdyaXRlci5nZXRCdWZmZXIoKTtcbiAgfSxcbiAgX19jYWxsX3JlZHVjZXJfXyhyZWR1Y2VySWQsIHNlbmRlciwgY29ubklkLCB0aW1lc3RhbXAsIGFyZ3NCdWYpIHtcbiAgICBjb25zdCBhcmdzVHlwZSA9IEFsZ2VicmFpY1R5cGUuUHJvZHVjdChcbiAgICAgIE1PRFVMRV9ERUYucmVkdWNlcnNbcmVkdWNlcklkXS5wYXJhbXNcbiAgICApO1xuICAgIGNvbnN0IGFyZ3MgPSBBbGdlYnJhaWNUeXBlLmRlc2VyaWFsaXplVmFsdWUoXG4gICAgICBuZXcgQmluYXJ5UmVhZGVyKGFyZ3NCdWYpLFxuICAgICAgYXJnc1R5cGUsXG4gICAgICBNT0RVTEVfREVGLnR5cGVzcGFjZVxuICAgICk7XG4gICAgY29uc3Qgc2VuZGVySWRlbnRpdHkgPSBuZXcgSWRlbnRpdHkoc2VuZGVyKTtcbiAgICBjb25zdCBjdHggPSBuZXcgUmVkdWNlckN0eEltcGwoXG4gICAgICBzZW5kZXJJZGVudGl0eSxcbiAgICAgIG5ldyBUaW1lc3RhbXAodGltZXN0YW1wKSxcbiAgICAgIENvbm5lY3Rpb25JZC5udWxsSWZaZXJvKG5ldyBDb25uZWN0aW9uSWQoY29ubklkKSlcbiAgICApO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gY2FsbFVzZXJGdW5jdGlvbihSRURVQ0VSU1tyZWR1Y2VySWRdLCBjdHgsIGFyZ3MpID8/IHsgdGFnOiBcIm9rXCIgfTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIFNlbmRlckVycm9yKSB7XG4gICAgICAgIHJldHVybiB7IHRhZzogXCJlcnJcIiwgdmFsdWU6IGUubWVzc2FnZSB9O1xuICAgICAgfVxuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cbn07XG52YXIgaG9va3NfdjFfMSA9IHtcbiAgX19jYWxsX3ZpZXdfXyhpZCwgc2VuZGVyLCBhcmdzQnVmKSB7XG4gICAgY29uc3QgeyBmbiwgcGFyYW1zLCByZXR1cm5UeXBlLCByZXR1cm5UeXBlQmFzZVNpemUgfSA9IFZJRVdTW2lkXTtcbiAgICBjb25zdCBjdHggPSBmcmVlemUzKHtcbiAgICAgIHNlbmRlcjogbmV3IElkZW50aXR5KHNlbmRlciksXG4gICAgICAvLyB0aGlzIGlzIHRoZSBub24tcmVhZG9ubHkgRGJWaWV3LCBidXQgdGhlIHR5cGluZyBmb3IgdGhlIHVzZXIgd2lsbCBiZVxuICAgICAgLy8gdGhlIHJlYWRvbmx5IG9uZSwgYW5kIGlmIHRoZXkgZG8gY2FsbCBtdXRhdGluZyBmdW5jdGlvbnMgaXQgd2lsbCBmYWlsXG4gICAgICAvLyBhdCBydW50aW1lXG4gICAgICBkYjogZ2V0RGJWaWV3KCksXG4gICAgICBmcm9tOiBtYWtlUXVlcnlCdWlsZGVyKGdldFJlZ2lzdGVyZWRTY2hlbWEoKSlcbiAgICB9KTtcbiAgICBjb25zdCBhcmdzID0gUHJvZHVjdFR5cGUuZGVzZXJpYWxpemVWYWx1ZShcbiAgICAgIG5ldyBCaW5hcnlSZWFkZXIoYXJnc0J1ZiksXG4gICAgICBwYXJhbXMsXG4gICAgICBNT0RVTEVfREVGLnR5cGVzcGFjZVxuICAgICk7XG4gICAgY29uc3QgcmV0ID0gY2FsbFVzZXJGdW5jdGlvbihmbiwgY3R4LCBhcmdzKTtcbiAgICBjb25zdCByZXRCdWYgPSBuZXcgQmluYXJ5V3JpdGVyKHJldHVyblR5cGVCYXNlU2l6ZSk7XG4gICAgaWYgKGlzUm93VHlwZWRRdWVyeShyZXQpKSB7XG4gICAgICBjb25zdCBxdWVyeSA9IHRvU3FsKHJldCk7XG4gICAgICBjb25zdCB2ID0gdmlld19yZXN1bHRfaGVhZGVyX3R5cGVfZGVmYXVsdC5SYXdTcWwocXVlcnkpO1xuICAgICAgQWxnZWJyYWljVHlwZS5zZXJpYWxpemVWYWx1ZShcbiAgICAgICAgcmV0QnVmLFxuICAgICAgICB2aWV3X3Jlc3VsdF9oZWFkZXJfdHlwZV9kZWZhdWx0LmFsZ2VicmFpY1R5cGUsXG4gICAgICAgIHYsXG4gICAgICAgIE1PRFVMRV9ERUYudHlwZXNwYWNlXG4gICAgICApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YTogcmV0QnVmLmdldEJ1ZmZlcigpXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBBbGdlYnJhaWNUeXBlLnNlcmlhbGl6ZVZhbHVlKFxuICAgICAgICByZXRCdWYsXG4gICAgICAgIHZpZXdfcmVzdWx0X2hlYWRlcl90eXBlX2RlZmF1bHQuYWxnZWJyYWljVHlwZSxcbiAgICAgICAgdmlld19yZXN1bHRfaGVhZGVyX3R5cGVfZGVmYXVsdC5Sb3dEYXRhLFxuICAgICAgICBNT0RVTEVfREVGLnR5cGVzcGFjZVxuICAgICAgKTtcbiAgICAgIEFsZ2VicmFpY1R5cGUuc2VyaWFsaXplVmFsdWUoXG4gICAgICAgIHJldEJ1ZixcbiAgICAgICAgcmV0dXJuVHlwZSxcbiAgICAgICAgcmV0LFxuICAgICAgICBNT0RVTEVfREVGLnR5cGVzcGFjZVxuICAgICAgKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IHJldEJ1Zi5nZXRCdWZmZXIoKVxuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gIF9fY2FsbF92aWV3X2Fub25fXyhpZCwgYXJnc0J1Zikge1xuICAgIGNvbnN0IHsgZm4sIHBhcmFtcywgcmV0dXJuVHlwZSwgcmV0dXJuVHlwZUJhc2VTaXplIH0gPSBBTk9OX1ZJRVdTW2lkXTtcbiAgICBjb25zdCBjdHggPSBmcmVlemUzKHtcbiAgICAgIC8vIHRoaXMgaXMgdGhlIG5vbi1yZWFkb25seSBEYlZpZXcsIGJ1dCB0aGUgdHlwaW5nIGZvciB0aGUgdXNlciB3aWxsIGJlXG4gICAgICAvLyB0aGUgcmVhZG9ubHkgb25lLCBhbmQgaWYgdGhleSBkbyBjYWxsIG11dGF0aW5nIGZ1bmN0aW9ucyBpdCB3aWxsIGZhaWxcbiAgICAgIC8vIGF0IHJ1bnRpbWVcbiAgICAgIGRiOiBnZXREYlZpZXcoKSxcbiAgICAgIGZyb206IG1ha2VRdWVyeUJ1aWxkZXIoZ2V0UmVnaXN0ZXJlZFNjaGVtYSgpKVxuICAgIH0pO1xuICAgIGNvbnN0IGFyZ3MgPSBQcm9kdWN0VHlwZS5kZXNlcmlhbGl6ZVZhbHVlKFxuICAgICAgbmV3IEJpbmFyeVJlYWRlcihhcmdzQnVmKSxcbiAgICAgIHBhcmFtcyxcbiAgICAgIE1PRFVMRV9ERUYudHlwZXNwYWNlXG4gICAgKTtcbiAgICBjb25zdCByZXQgPSBjYWxsVXNlckZ1bmN0aW9uKGZuLCBjdHgsIGFyZ3MpO1xuICAgIGNvbnN0IHJldEJ1ZiA9IG5ldyBCaW5hcnlXcml0ZXIocmV0dXJuVHlwZUJhc2VTaXplKTtcbiAgICBpZiAoaXNSb3dUeXBlZFF1ZXJ5KHJldCkpIHtcbiAgICAgIGNvbnN0IHF1ZXJ5ID0gdG9TcWwocmV0KTtcbiAgICAgIGNvbnN0IHYgPSB2aWV3X3Jlc3VsdF9oZWFkZXJfdHlwZV9kZWZhdWx0LlJhd1NxbChxdWVyeSk7XG4gICAgICBBbGdlYnJhaWNUeXBlLnNlcmlhbGl6ZVZhbHVlKFxuICAgICAgICByZXRCdWYsXG4gICAgICAgIHZpZXdfcmVzdWx0X2hlYWRlcl90eXBlX2RlZmF1bHQuYWxnZWJyYWljVHlwZSxcbiAgICAgICAgdixcbiAgICAgICAgTU9EVUxFX0RFRi50eXBlc3BhY2VcbiAgICAgICk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiByZXRCdWYuZ2V0QnVmZmVyKClcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIEFsZ2VicmFpY1R5cGUuc2VyaWFsaXplVmFsdWUoXG4gICAgICAgIHJldEJ1ZixcbiAgICAgICAgdmlld19yZXN1bHRfaGVhZGVyX3R5cGVfZGVmYXVsdC5hbGdlYnJhaWNUeXBlLFxuICAgICAgICB2aWV3X3Jlc3VsdF9oZWFkZXJfdHlwZV9kZWZhdWx0LlJvd0RhdGEsXG4gICAgICAgIE1PRFVMRV9ERUYudHlwZXNwYWNlXG4gICAgICApO1xuICAgICAgQWxnZWJyYWljVHlwZS5zZXJpYWxpemVWYWx1ZShcbiAgICAgICAgcmV0QnVmLFxuICAgICAgICByZXR1cm5UeXBlLFxuICAgICAgICByZXQsXG4gICAgICAgIE1PRFVMRV9ERUYudHlwZXNwYWNlXG4gICAgICApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YTogcmV0QnVmLmdldEJ1ZmZlcigpXG4gICAgICB9O1xuICAgIH1cbiAgfVxufTtcbnZhciBob29rc192MV8yID0ge1xuICBfX2NhbGxfcHJvY2VkdXJlX18oaWQsIHNlbmRlciwgY29ubmVjdGlvbl9pZCwgdGltZXN0YW1wLCBhcmdzKSB7XG4gICAgcmV0dXJuIGNhbGxQcm9jZWR1cmUoXG4gICAgICBpZCxcbiAgICAgIG5ldyBJZGVudGl0eShzZW5kZXIpLFxuICAgICAgQ29ubmVjdGlvbklkLm51bGxJZlplcm8obmV3IENvbm5lY3Rpb25JZChjb25uZWN0aW9uX2lkKSksXG4gICAgICBuZXcgVGltZXN0YW1wKHRpbWVzdGFtcCksXG4gICAgICBhcmdzXG4gICAgKTtcbiAgfVxufTtcbnZhciBEQl9WSUVXID0gbnVsbDtcbmZ1bmN0aW9uIGdldERiVmlldygpIHtcbiAgREJfVklFVyA/Pz0gbWFrZURiVmlldyhNT0RVTEVfREVGKTtcbiAgcmV0dXJuIERCX1ZJRVc7XG59XG5mdW5jdGlvbiBtYWtlRGJWaWV3KG1vZHVsZURlZikge1xuICByZXR1cm4gZnJlZXplMyhcbiAgICBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICBtb2R1bGVEZWYudGFibGVzLm1hcCgodGFibGUyKSA9PiBbXG4gICAgICAgIHRvQ2FtZWxDYXNlKHRhYmxlMi5uYW1lKSxcbiAgICAgICAgbWFrZVRhYmxlVmlldyhtb2R1bGVEZWYudHlwZXNwYWNlLCB0YWJsZTIpXG4gICAgICBdKVxuICAgIClcbiAgKTtcbn1cbmZ1bmN0aW9uIG1ha2VUYWJsZVZpZXcodHlwZXNwYWNlLCB0YWJsZTIpIHtcbiAgY29uc3QgdGFibGVfaWQgPSBzeXMudGFibGVfaWRfZnJvbV9uYW1lKHRhYmxlMi5uYW1lKTtcbiAgY29uc3Qgcm93VHlwZSA9IHR5cGVzcGFjZS50eXBlc1t0YWJsZTIucHJvZHVjdFR5cGVSZWZdO1xuICBpZiAocm93VHlwZS50YWcgIT09IFwiUHJvZHVjdFwiKSB7XG4gICAgdGhyb3cgXCJpbXBvc3NpYmxlXCI7XG4gIH1cbiAgY29uc3QgYmFzZVNpemUgPSBic2F0bkJhc2VTaXplKHR5cGVzcGFjZSwgcm93VHlwZSk7XG4gIGNvbnN0IHNlcXVlbmNlcyA9IHRhYmxlMi5zZXF1ZW5jZXMubWFwKChzZXEpID0+IHtcbiAgICBjb25zdCBjb2wgPSByb3dUeXBlLnZhbHVlLmVsZW1lbnRzW3NlcS5jb2x1bW5dO1xuICAgIGNvbnN0IGNvbFR5cGUgPSBjb2wuYWxnZWJyYWljVHlwZTtcbiAgICBsZXQgc2VxdWVuY2VUcmlnZ2VyO1xuICAgIHN3aXRjaCAoY29sVHlwZS50YWcpIHtcbiAgICAgIGNhc2UgXCJVOFwiOlxuICAgICAgY2FzZSBcIkk4XCI6XG4gICAgICBjYXNlIFwiVTE2XCI6XG4gICAgICBjYXNlIFwiSTE2XCI6XG4gICAgICBjYXNlIFwiVTMyXCI6XG4gICAgICBjYXNlIFwiSTMyXCI6XG4gICAgICAgIHNlcXVlbmNlVHJpZ2dlciA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIlU2NFwiOlxuICAgICAgY2FzZSBcIkk2NFwiOlxuICAgICAgY2FzZSBcIlUxMjhcIjpcbiAgICAgIGNhc2UgXCJJMTI4XCI6XG4gICAgICBjYXNlIFwiVTI1NlwiOlxuICAgICAgY2FzZSBcIkkyNTZcIjpcbiAgICAgICAgc2VxdWVuY2VUcmlnZ2VyID0gMG47XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgc2VxdWVuY2UgdHlwZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbE5hbWU6IGNvbC5uYW1lLFxuICAgICAgc2VxdWVuY2VUcmlnZ2VyLFxuICAgICAgcmVhZDogKHJlYWRlcikgPT4gQWxnZWJyYWljVHlwZS5kZXNlcmlhbGl6ZVZhbHVlKHJlYWRlciwgY29sVHlwZSwgdHlwZXNwYWNlKVxuICAgIH07XG4gIH0pO1xuICBjb25zdCBoYXNBdXRvSW5jcmVtZW50ID0gc2VxdWVuY2VzLmxlbmd0aCA+IDA7XG4gIGNvbnN0IGl0ZXIgPSAoKSA9PiB0YWJsZUl0ZXJhdG9yKHN5cy5kYXRhc3RvcmVfdGFibGVfc2Nhbl9ic2F0bih0YWJsZV9pZCksIHJvd1R5cGUpO1xuICBjb25zdCBpbnRlZ3JhdGVHZW5lcmF0ZWRDb2x1bW5zID0gaGFzQXV0b0luY3JlbWVudCA/IChyb3csIHJldF9idWYpID0+IHtcbiAgICBjb25zdCByZWFkZXIgPSBuZXcgQmluYXJ5UmVhZGVyKHJldF9idWYpO1xuICAgIGZvciAoY29uc3QgeyBjb2xOYW1lLCByZWFkLCBzZXF1ZW5jZVRyaWdnZXIgfSBvZiBzZXF1ZW5jZXMpIHtcbiAgICAgIGlmIChyb3dbY29sTmFtZV0gPT09IHNlcXVlbmNlVHJpZ2dlcikge1xuICAgICAgICByb3dbY29sTmFtZV0gPSByZWFkKHJlYWRlcik7XG4gICAgICB9XG4gICAgfVxuICB9IDogbnVsbDtcbiAgY29uc3QgdGFibGVNZXRob2RzID0ge1xuICAgIGNvdW50OiAoKSA9PiBzeXMuZGF0YXN0b3JlX3RhYmxlX3Jvd19jb3VudCh0YWJsZV9pZCksXG4gICAgaXRlcixcbiAgICBbU3ltYm9sLml0ZXJhdG9yXTogKCkgPT4gaXRlcigpLFxuICAgIGluc2VydDogKHJvdykgPT4ge1xuICAgICAgY29uc3Qgd3JpdGVyID0gbmV3IEJpbmFyeVdyaXRlcihiYXNlU2l6ZSk7XG4gICAgICBBbGdlYnJhaWNUeXBlLnNlcmlhbGl6ZVZhbHVlKHdyaXRlciwgcm93VHlwZSwgcm93LCB0eXBlc3BhY2UpO1xuICAgICAgY29uc3QgcmV0X2J1ZiA9IHN5cy5kYXRhc3RvcmVfaW5zZXJ0X2JzYXRuKHRhYmxlX2lkLCB3cml0ZXIuZ2V0QnVmZmVyKCkpO1xuICAgICAgY29uc3QgcmV0ID0geyAuLi5yb3cgfTtcbiAgICAgIGludGVncmF0ZUdlbmVyYXRlZENvbHVtbnM/LihyZXQsIHJldF9idWYpO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9LFxuICAgIGRlbGV0ZTogKHJvdykgPT4ge1xuICAgICAgY29uc3Qgd3JpdGVyID0gbmV3IEJpbmFyeVdyaXRlcig0ICsgYmFzZVNpemUpO1xuICAgICAgd3JpdGVyLndyaXRlVTMyKDEpO1xuICAgICAgQWxnZWJyYWljVHlwZS5zZXJpYWxpemVWYWx1ZSh3cml0ZXIsIHJvd1R5cGUsIHJvdywgdHlwZXNwYWNlKTtcbiAgICAgIGNvbnN0IGNvdW50ID0gc3lzLmRhdGFzdG9yZV9kZWxldGVfYWxsX2J5X2VxX2JzYXRuKFxuICAgICAgICB0YWJsZV9pZCxcbiAgICAgICAgd3JpdGVyLmdldEJ1ZmZlcigpXG4gICAgICApO1xuICAgICAgcmV0dXJuIGNvdW50ID4gMDtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHRhYmxlVmlldyA9IE9iamVjdC5hc3NpZ24oXG4gICAgLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgdGFibGVNZXRob2RzXG4gICk7XG4gIGZvciAoY29uc3QgaW5kZXhEZWYgb2YgdGFibGUyLmluZGV4ZXMpIHtcbiAgICBjb25zdCBpbmRleF9pZCA9IHN5cy5pbmRleF9pZF9mcm9tX25hbWUoaW5kZXhEZWYubmFtZSk7XG4gICAgbGV0IGNvbHVtbl9pZHM7XG4gICAgc3dpdGNoIChpbmRleERlZi5hbGdvcml0aG0udGFnKSB7XG4gICAgICBjYXNlIFwiQlRyZWVcIjpcbiAgICAgICAgY29sdW1uX2lkcyA9IGluZGV4RGVmLmFsZ29yaXRobS52YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiSGFzaFwiOlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbXBvc3NpYmxlXCIpO1xuICAgICAgY2FzZSBcIkRpcmVjdFwiOlxuICAgICAgICBjb2x1bW5faWRzID0gW2luZGV4RGVmLmFsZ29yaXRobS52YWx1ZV07XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCBudW1Db2x1bW5zID0gY29sdW1uX2lkcy5sZW5ndGg7XG4gICAgY29uc3QgY29sdW1uU2V0ID0gbmV3IFNldChjb2x1bW5faWRzKTtcbiAgICBjb25zdCBpc1VuaXF1ZSA9IHRhYmxlMi5jb25zdHJhaW50cy5maWx0ZXIoKHgpID0+IHguZGF0YS50YWcgPT09IFwiVW5pcXVlXCIpLnNvbWUoKHgpID0+IGNvbHVtblNldC5pc1N1YnNldE9mKG5ldyBTZXQoeC5kYXRhLnZhbHVlLmNvbHVtbnMpKSk7XG4gICAgY29uc3QgaW5kZXhUeXBlID0gQWxnZWJyYWljVHlwZS5Qcm9kdWN0KHtcbiAgICAgIGVsZW1lbnRzOiBjb2x1bW5faWRzLm1hcCgoaWQpID0+IHJvd1R5cGUudmFsdWUuZWxlbWVudHNbaWRdKVxuICAgIH0pO1xuICAgIGNvbnN0IGJhc2VTaXplMiA9IGJzYXRuQmFzZVNpemUodHlwZXNwYWNlLCBpbmRleFR5cGUpO1xuICAgIGNvbnN0IHNlcmlhbGl6ZVByZWZpeCA9ICh3cml0ZXIsIHByZWZpeCwgcHJlZml4X2VsZW1zKSA9PiB7XG4gICAgICBpZiAocHJlZml4X2VsZW1zID4gbnVtQ29sdW1ucyAtIDEpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJ0b28gbWFueSBlbGVtZW50cyBpbiBwcmVmaXhcIik7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZWZpeF9lbGVtczsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGVsZW1UeXBlID0gaW5kZXhUeXBlLnZhbHVlLmVsZW1lbnRzW2ldLmFsZ2VicmFpY1R5cGU7XG4gICAgICAgIEFsZ2VicmFpY1R5cGUuc2VyaWFsaXplVmFsdWUod3JpdGVyLCBlbGVtVHlwZSwgcHJlZml4W2ldLCB0eXBlc3BhY2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9O1xuICAgIGxldCBpbmRleDtcbiAgICBpZiAoaXNVbmlxdWUpIHtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZUJvdW5kID0gKGNvbFZhbCkgPT4ge1xuICAgICAgICBpZiAoY29sVmFsLmxlbmd0aCAhPT0gbnVtQ29sdW1ucylcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwid3JvbmcgbnVtYmVyIG9mIGVsZW1lbnRzXCIpO1xuICAgICAgICBjb25zdCB3cml0ZXIgPSBuZXcgQmluYXJ5V3JpdGVyKGJhc2VTaXplMiArIDEpO1xuICAgICAgICBjb25zdCBwcmVmaXhfZWxlbXMgPSBudW1Db2x1bW5zIC0gMTtcbiAgICAgICAgc2VyaWFsaXplUHJlZml4KHdyaXRlciwgY29sVmFsLCBwcmVmaXhfZWxlbXMpO1xuICAgICAgICBjb25zdCByc3RhcnRPZmZzZXQgPSB3cml0ZXIub2Zmc2V0O1xuICAgICAgICB3cml0ZXIud3JpdGVVOCgwKTtcbiAgICAgICAgQWxnZWJyYWljVHlwZS5zZXJpYWxpemVWYWx1ZShcbiAgICAgICAgICB3cml0ZXIsXG4gICAgICAgICAgaW5kZXhUeXBlLnZhbHVlLmVsZW1lbnRzW251bUNvbHVtbnMgLSAxXS5hbGdlYnJhaWNUeXBlLFxuICAgICAgICAgIGNvbFZhbFtudW1Db2x1bW5zIC0gMV0sXG4gICAgICAgICAgdHlwZXNwYWNlXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHdyaXRlci5nZXRCdWZmZXIoKTtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gYnVmZmVyLnNsaWNlKDAsIHJzdGFydE9mZnNldCk7XG4gICAgICAgIGNvbnN0IHJzdGFydCA9IGJ1ZmZlci5zbGljZShyc3RhcnRPZmZzZXQpO1xuICAgICAgICByZXR1cm4gW3ByZWZpeCwgcHJlZml4X2VsZW1zLCByc3RhcnQsIHJzdGFydF07XG4gICAgICB9O1xuICAgICAgaW5kZXggPSB7XG4gICAgICAgIGZpbmQ6IChjb2xWYWwpID0+IHtcbiAgICAgICAgICBpZiAobnVtQ29sdW1ucyA9PT0gMSkgY29sVmFsID0gW2NvbFZhbF07XG4gICAgICAgICAgY29uc3QgYXJncyA9IHNlcmlhbGl6ZUJvdW5kKGNvbFZhbCk7XG4gICAgICAgICAgY29uc3QgaXRlcjIgPSB0YWJsZUl0ZXJhdG9yKFxuICAgICAgICAgICAgc3lzLmRhdGFzdG9yZV9pbmRleF9zY2FuX3JhbmdlX2JzYXRuKGluZGV4X2lkLCAuLi5hcmdzKSxcbiAgICAgICAgICAgIHJvd1R5cGVcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGl0ZXIyLm5leHQoKTtcbiAgICAgICAgICBpZiAoZG9uZSkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgaWYgKCFpdGVyMi5uZXh0KCkuZG9uZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgXCJgZGF0YXN0b3JlX2luZGV4X3NjYW5fcmFuZ2VfYnNhdG5gIG9uIHVuaXF1ZSBmaWVsZCBjYW5ub3QgcmV0dXJuID4xIHJvd3NcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGRlbGV0ZTogKGNvbFZhbCkgPT4ge1xuICAgICAgICAgIGlmIChudW1Db2x1bW5zID09PSAxKSBjb2xWYWwgPSBbY29sVmFsXTtcbiAgICAgICAgICBjb25zdCBhcmdzID0gc2VyaWFsaXplQm91bmQoY29sVmFsKTtcbiAgICAgICAgICBjb25zdCBudW0gPSBzeXMuZGF0YXN0b3JlX2RlbGV0ZV9ieV9pbmRleF9zY2FuX3JhbmdlX2JzYXRuKFxuICAgICAgICAgICAgaW5kZXhfaWQsXG4gICAgICAgICAgICAuLi5hcmdzXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gbnVtID4gMDtcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlOiAocm93KSA9PiB7XG4gICAgICAgICAgY29uc3Qgd3JpdGVyID0gbmV3IEJpbmFyeVdyaXRlcihiYXNlU2l6ZTIpO1xuICAgICAgICAgIEFsZ2VicmFpY1R5cGUuc2VyaWFsaXplVmFsdWUod3JpdGVyLCByb3dUeXBlLCByb3csIHR5cGVzcGFjZSk7XG4gICAgICAgICAgY29uc3QgcmV0X2J1ZiA9IHN5cy5kYXRhc3RvcmVfdXBkYXRlX2JzYXRuKFxuICAgICAgICAgICAgdGFibGVfaWQsXG4gICAgICAgICAgICBpbmRleF9pZCxcbiAgICAgICAgICAgIHdyaXRlci5nZXRCdWZmZXIoKVxuICAgICAgICAgICk7XG4gICAgICAgICAgaW50ZWdyYXRlR2VuZXJhdGVkQ29sdW1ucz8uKHJvdywgcmV0X2J1Zik7XG4gICAgICAgICAgcmV0dXJuIHJvdztcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc2VyaWFsaXplUmFuZ2UgPSAocmFuZ2UpID0+IHtcbiAgICAgICAgaWYgKHJhbmdlLmxlbmd0aCA+IG51bUNvbHVtbnMpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJ0b28gbWFueSBlbGVtZW50c1wiKTtcbiAgICAgICAgY29uc3Qgd3JpdGVyID0gbmV3IEJpbmFyeVdyaXRlcihiYXNlU2l6ZTIgKyAxKTtcbiAgICAgICAgY29uc3QgcHJlZml4X2VsZW1zID0gcmFuZ2UubGVuZ3RoIC0gMTtcbiAgICAgICAgc2VyaWFsaXplUHJlZml4KHdyaXRlciwgcmFuZ2UsIHByZWZpeF9lbGVtcyk7XG4gICAgICAgIGNvbnN0IHJzdGFydE9mZnNldCA9IHdyaXRlci5vZmZzZXQ7XG4gICAgICAgIGNvbnN0IHRlcm0gPSByYW5nZVtyYW5nZS5sZW5ndGggLSAxXTtcbiAgICAgICAgY29uc3QgdGVybVR5cGUgPSBpbmRleFR5cGUudmFsdWUuZWxlbWVudHNbcmFuZ2UubGVuZ3RoIC0gMV0uYWxnZWJyYWljVHlwZTtcbiAgICAgICAgbGV0IHJzdGFydCwgcmVuZDtcbiAgICAgICAgaWYgKHRlcm0gaW5zdGFuY2VvZiBSYW5nZSkge1xuICAgICAgICAgIGNvbnN0IHdyaXRlQm91bmQgPSAoYm91bmQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRhZ3MgPSB7IGluY2x1ZGVkOiAwLCBleGNsdWRlZDogMSwgdW5ib3VuZGVkOiAyIH07XG4gICAgICAgICAgICB3cml0ZXIud3JpdGVVOCh0YWdzW2JvdW5kLnRhZ10pO1xuICAgICAgICAgICAgaWYgKGJvdW5kLnRhZyAhPT0gXCJ1bmJvdW5kZWRcIilcbiAgICAgICAgICAgICAgQWxnZWJyYWljVHlwZS5zZXJpYWxpemVWYWx1ZShcbiAgICAgICAgICAgICAgICB3cml0ZXIsXG4gICAgICAgICAgICAgICAgdGVybVR5cGUsXG4gICAgICAgICAgICAgICAgYm91bmQudmFsdWUsXG4gICAgICAgICAgICAgICAgdHlwZXNwYWNlXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB3cml0ZUJvdW5kKHRlcm0uZnJvbSk7XG4gICAgICAgICAgY29uc3QgcmVuZE9mZnNldCA9IHdyaXRlci5vZmZzZXQ7XG4gICAgICAgICAgd3JpdGVCb3VuZCh0ZXJtLnRvKTtcbiAgICAgICAgICByc3RhcnQgPSB3cml0ZXIuZ2V0QnVmZmVyKCkuc2xpY2UocnN0YXJ0T2Zmc2V0LCByZW5kT2Zmc2V0KTtcbiAgICAgICAgICByZW5kID0gd3JpdGVyLmdldEJ1ZmZlcigpLnNsaWNlKHJlbmRPZmZzZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdyaXRlci53cml0ZVU4KDApO1xuICAgICAgICAgIEFsZ2VicmFpY1R5cGUuc2VyaWFsaXplVmFsdWUod3JpdGVyLCB0ZXJtVHlwZSwgdGVybSwgdHlwZXNwYWNlKTtcbiAgICAgICAgICByc3RhcnQgPSByZW5kID0gd3JpdGVyLmdldEJ1ZmZlcigpLnNsaWNlKHJzdGFydE9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnVmZmVyID0gd3JpdGVyLmdldEJ1ZmZlcigpO1xuICAgICAgICBjb25zdCBwcmVmaXggPSBidWZmZXIuc2xpY2UoMCwgcnN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIFtwcmVmaXgsIHByZWZpeF9lbGVtcywgcnN0YXJ0LCByZW5kXTtcbiAgICAgIH07XG4gICAgICBpbmRleCA9IHtcbiAgICAgICAgZmlsdGVyOiAocmFuZ2UpID0+IHtcbiAgICAgICAgICBpZiAobnVtQ29sdW1ucyA9PT0gMSkgcmFuZ2UgPSBbcmFuZ2VdO1xuICAgICAgICAgIGNvbnN0IGFyZ3MgPSBzZXJpYWxpemVSYW5nZShyYW5nZSk7XG4gICAgICAgICAgcmV0dXJuIHRhYmxlSXRlcmF0b3IoXG4gICAgICAgICAgICBzeXMuZGF0YXN0b3JlX2luZGV4X3NjYW5fcmFuZ2VfYnNhdG4oaW5kZXhfaWQsIC4uLmFyZ3MpLFxuICAgICAgICAgICAgcm93VHlwZVxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIGRlbGV0ZTogKHJhbmdlKSA9PiB7XG4gICAgICAgICAgaWYgKG51bUNvbHVtbnMgPT09IDEpIHJhbmdlID0gW3JhbmdlXTtcbiAgICAgICAgICBjb25zdCBhcmdzID0gc2VyaWFsaXplUmFuZ2UocmFuZ2UpO1xuICAgICAgICAgIHJldHVybiBzeXMuZGF0YXN0b3JlX2RlbGV0ZV9ieV9pbmRleF9zY2FuX3JhbmdlX2JzYXRuKFxuICAgICAgICAgICAgaW5kZXhfaWQsXG4gICAgICAgICAgICAuLi5hcmdzXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5oYXNPd24odGFibGVWaWV3LCBpbmRleERlZi5hY2Nlc3Nvck5hbWUpKSB7XG4gICAgICBmcmVlemUzKE9iamVjdC5hc3NpZ24odGFibGVWaWV3W2luZGV4RGVmLmFjY2Vzc29yTmFtZV0sIGluZGV4KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhYmxlVmlld1tpbmRleERlZi5hY2Nlc3Nvck5hbWVdID0gZnJlZXplMyhpbmRleCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBmcmVlemUzKHRhYmxlVmlldyk7XG59XG5mdW5jdGlvbiBoYXNPd24obywgaykge1xuICByZXR1cm4gT2JqZWN0Lmhhc093bihvLCBrKTtcbn1cbmZ1bmN0aW9uKiB0YWJsZUl0ZXJhdG9yKGlkLCB0eSkge1xuICB2YXIgX3N0YWNrID0gW107XG4gIHRyeSB7XG4gICAgY29uc3QgaXRlciA9IF9fdXNpbmcoX3N0YWNrLCBuZXcgSXRlcmF0b3JIYW5kbGUoaWQpKTtcbiAgICBjb25zdCB7IHR5cGVzcGFjZSB9ID0gTU9EVUxFX0RFRjtcbiAgICBsZXQgYnVmO1xuICAgIHdoaWxlICgoYnVmID0gYWR2YW5jZUl0ZXIoaXRlcikpICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBCaW5hcnlSZWFkZXIoYnVmKTtcbiAgICAgIHdoaWxlIChyZWFkZXIucmVtYWluaW5nID4gMCkge1xuICAgICAgICB5aWVsZCBBbGdlYnJhaWNUeXBlLmRlc2VyaWFsaXplVmFsdWUocmVhZGVyLCB0eSwgdHlwZXNwYWNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICB2YXIgX2Vycm9yID0gXywgX2hhc0Vycm9yID0gdHJ1ZTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfX2NhbGxEaXNwb3NlKF9zdGFjaywgX2Vycm9yLCBfaGFzRXJyb3IpO1xuICB9XG59XG5mdW5jdGlvbiBhZHZhbmNlSXRlcihpdGVyKSB7XG4gIGxldCBidWZfbWF4X2xlbiA9IDY1NTM2O1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gaXRlci5hZHZhbmNlKGJ1Zl9tYXhfbGVuKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZSAmJiB0eXBlb2YgZSA9PT0gXCJvYmplY3RcIiAmJiBoYXNPd24oZSwgXCJfX2J1ZmZlcl90b29fc21hbGxfX1wiKSkge1xuICAgICAgICBidWZfbWF4X2xlbiA9IGUuX19idWZmZXJfdG9vX3NtYWxsX187XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cbn1cbnZhciBJdGVyYXRvckhhbmRsZSA9IGNsYXNzIF9JdGVyYXRvckhhbmRsZSB7XG4gICNpZDtcbiAgc3RhdGljICNmaW5hbGl6YXRpb25SZWdpc3RyeSA9IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShcbiAgICBzeXMucm93X2l0ZXJfYnNhdG5fY2xvc2VcbiAgKTtcbiAgY29uc3RydWN0b3IoaWQpIHtcbiAgICB0aGlzLiNpZCA9IGlkO1xuICAgIF9JdGVyYXRvckhhbmRsZS4jZmluYWxpemF0aW9uUmVnaXN0cnkucmVnaXN0ZXIodGhpcywgaWQsIHRoaXMpO1xuICB9XG4gIC8qKiBVbnJlZ2lzdGVyIHRoaXMgb2JqZWN0IHdpdGggdGhlIGZpbmFsaXphdGlvbiByZWdpc3RyeSBhbmQgcmV0dXJuIHRoZSBpZCAqL1xuICAjZGV0YWNoKCkge1xuICAgIGNvbnN0IGlkID0gdGhpcy4jaWQ7XG4gICAgdGhpcy4jaWQgPSAtMTtcbiAgICBfSXRlcmF0b3JIYW5kbGUuI2ZpbmFsaXphdGlvblJlZ2lzdHJ5LnVucmVnaXN0ZXIodGhpcyk7XG4gICAgcmV0dXJuIGlkO1xuICB9XG4gIC8qKiBDYWxsIGByb3dfaXRlcl9ic2F0bl9hZHZhbmNlYCwgcmV0dXJuaW5nIG51bGwgaWYgdGhpcyBpdGVyYXRvciB3YXMgYWxyZWFkeSBleGhhdXN0ZWQuICovXG4gIGFkdmFuY2UoYnVmX21heF9sZW4pIHtcbiAgICBpZiAodGhpcy4jaWQgPT09IC0xKSByZXR1cm4gbnVsbDtcbiAgICBjb25zdCB7IDA6IGRvbmUsIDE6IGJ1ZiB9ID0gc3lzLnJvd19pdGVyX2JzYXRuX2FkdmFuY2UoXG4gICAgICB0aGlzLiNpZCxcbiAgICAgIGJ1Zl9tYXhfbGVuXG4gICAgKTtcbiAgICBpZiAoZG9uZSkgdGhpcy4jZGV0YWNoKCk7XG4gICAgcmV0dXJuIGJ1ZjtcbiAgfVxuICBbU3ltYm9sLmRpc3Bvc2VdKCkge1xuICAgIGlmICh0aGlzLiNpZCA+PSAwKSB7XG4gICAgICBjb25zdCBpZCA9IHRoaXMuI2RldGFjaCgpO1xuICAgICAgc3lzLnJvd19pdGVyX2JzYXRuX2Nsb3NlKGlkKTtcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiB3cmFwU3lzY2FsbHMoLi4ubW9kdWxlcykge1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIG1vZHVsZXMuZmxhdE1hcChPYmplY3QuZW50cmllcykubWFwKChbaywgdl0pID0+IFtrLCB3cmFwU3lzY2FsbCh2KV0pXG4gICk7XG59XG5mdW5jdGlvbiB3cmFwU3lzY2FsbChmdW5jKSB7XG4gIGNvbnN0IG5hbWUgPSBmdW5jLm5hbWU7XG4gIHJldHVybiB7XG4gICAgW25hbWVdKC4uLmFyZ3MpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBmdW5jKC4uLmFyZ3MpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZSAhPT0gbnVsbCAmJiB0eXBlb2YgZSA9PT0gXCJvYmplY3RcIiAmJiBoYXNPd24oZSwgXCJfX2NvZGVfZXJyb3JfX1wiKSAmJiB0eXBlb2YgZS5fX2NvZGVfZXJyb3JfXyA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGhhc093bihlLCBcIl9fZXJyb3JfbWVzc2FnZV9fXCIpICYmIHR5cGVvZiBlLl9fZXJyb3JfbWVzc2FnZV9fID09PSBcInN0cmluZ1wiID8gZS5fX2Vycm9yX21lc3NhZ2VfXyA6IHZvaWQgMDtcbiAgICAgICAgICB0aHJvdyBuZXcgU3BhY2V0aW1lSG9zdEVycm9yKGUuX19jb2RlX2Vycm9yX18sIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuICB9W25hbWVdO1xufVxuZnVuY3Rpb24gZm10TG9nKC4uLmRhdGEpIHtcbiAgcmV0dXJuIGRhdGEuam9pbihcIiBcIik7XG59XG52YXIgY29uc29sZV9sZXZlbF9lcnJvciA9IDA7XG52YXIgY29uc29sZV9sZXZlbF93YXJuID0gMTtcbnZhciBjb25zb2xlX2xldmVsX2luZm8gPSAyO1xudmFyIGNvbnNvbGVfbGV2ZWxfZGVidWcgPSAzO1xudmFyIGNvbnNvbGVfbGV2ZWxfdHJhY2UgPSA0O1xudmFyIHRpbWVyTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbnZhciBjb25zb2xlMiA9IHtcbiAgLy8gQHRzLWV4cGVjdC1lcnJvciB3ZSB3YW50IGEgYmxhbmsgcHJvdG90eXBlLCBidXQgdHlwZXNjcmlwdCBjb21wbGFpbnNcbiAgX19wcm90b19fOiB7fSxcbiAgW1N5bWJvbC50b1N0cmluZ1RhZ106IFwiY29uc29sZVwiLFxuICBhc3NlcnQ6IChjb25kaXRpb24gPSBmYWxzZSwgLi4uZGF0YSkgPT4ge1xuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICBzeXMuY29uc29sZV9sb2coY29uc29sZV9sZXZlbF9lcnJvciwgZm10TG9nKC4uLmRhdGEpKTtcbiAgICB9XG4gIH0sXG4gIGNsZWFyOiAoKSA9PiB7XG4gIH0sXG4gIGRlYnVnOiAoLi4uZGF0YSkgPT4ge1xuICAgIHN5cy5jb25zb2xlX2xvZyhjb25zb2xlX2xldmVsX2RlYnVnLCBmbXRMb2coLi4uZGF0YSkpO1xuICB9LFxuICBlcnJvcjogKC4uLmRhdGEpID0+IHtcbiAgICBzeXMuY29uc29sZV9sb2coY29uc29sZV9sZXZlbF9lcnJvciwgZm10TG9nKC4uLmRhdGEpKTtcbiAgfSxcbiAgaW5mbzogKC4uLmRhdGEpID0+IHtcbiAgICBzeXMuY29uc29sZV9sb2coY29uc29sZV9sZXZlbF9pbmZvLCBmbXRMb2coLi4uZGF0YSkpO1xuICB9LFxuICBsb2c6ICguLi5kYXRhKSA9PiB7XG4gICAgc3lzLmNvbnNvbGVfbG9nKGNvbnNvbGVfbGV2ZWxfaW5mbywgZm10TG9nKC4uLmRhdGEpKTtcbiAgfSxcbiAgdGFibGU6ICh0YWJ1bGFyRGF0YSwgX3Byb3BlcnRpZXMpID0+IHtcbiAgICBzeXMuY29uc29sZV9sb2coY29uc29sZV9sZXZlbF9pbmZvLCBmbXRMb2codGFidWxhckRhdGEpKTtcbiAgfSxcbiAgdHJhY2U6ICguLi5kYXRhKSA9PiB7XG4gICAgc3lzLmNvbnNvbGVfbG9nKGNvbnNvbGVfbGV2ZWxfdHJhY2UsIGZtdExvZyguLi5kYXRhKSk7XG4gIH0sXG4gIHdhcm46ICguLi5kYXRhKSA9PiB7XG4gICAgc3lzLmNvbnNvbGVfbG9nKGNvbnNvbGVfbGV2ZWxfd2FybiwgZm10TG9nKC4uLmRhdGEpKTtcbiAgfSxcbiAgZGlyOiAoX2l0ZW0sIF9vcHRpb25zKSA9PiB7XG4gIH0sXG4gIGRpcnhtbDogKC4uLl9kYXRhKSA9PiB7XG4gIH0sXG4gIC8vIENvdW50aW5nXG4gIGNvdW50OiAoX2xhYmVsID0gXCJkZWZhdWx0XCIpID0+IHtcbiAgfSxcbiAgY291bnRSZXNldDogKF9sYWJlbCA9IFwiZGVmYXVsdFwiKSA9PiB7XG4gIH0sXG4gIC8vIEdyb3VwaW5nXG4gIGdyb3VwOiAoLi4uX2RhdGEpID0+IHtcbiAgfSxcbiAgZ3JvdXBDb2xsYXBzZWQ6ICguLi5fZGF0YSkgPT4ge1xuICB9LFxuICBncm91cEVuZDogKCkgPT4ge1xuICB9LFxuICAvLyBUaW1pbmdcbiAgdGltZTogKGxhYmVsID0gXCJkZWZhdWx0XCIpID0+IHtcbiAgICBpZiAodGltZXJNYXAuaGFzKGxhYmVsKSkge1xuICAgICAgc3lzLmNvbnNvbGVfbG9nKGNvbnNvbGVfbGV2ZWxfd2FybiwgYFRpbWVyICcke2xhYmVsfScgYWxyZWFkeSBleGlzdHMuYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRpbWVyTWFwLnNldChsYWJlbCwgc3lzLmNvbnNvbGVfdGltZXJfc3RhcnQobGFiZWwpKTtcbiAgfSxcbiAgdGltZUxvZzogKGxhYmVsID0gXCJkZWZhdWx0XCIsIC4uLmRhdGEpID0+IHtcbiAgICBzeXMuY29uc29sZV9sb2coY29uc29sZV9sZXZlbF9pbmZvLCBmbXRMb2cobGFiZWwsIC4uLmRhdGEpKTtcbiAgfSxcbiAgdGltZUVuZDogKGxhYmVsID0gXCJkZWZhdWx0XCIpID0+IHtcbiAgICBjb25zdCBzcGFuSWQgPSB0aW1lck1hcC5nZXQobGFiZWwpO1xuICAgIGlmIChzcGFuSWQgPT09IHZvaWQgMCkge1xuICAgICAgc3lzLmNvbnNvbGVfbG9nKGNvbnNvbGVfbGV2ZWxfd2FybiwgYFRpbWVyICcke2xhYmVsfScgZG9lcyBub3QgZXhpc3QuYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN5cy5jb25zb2xlX3RpbWVyX2VuZChzcGFuSWQpO1xuICAgIHRpbWVyTWFwLmRlbGV0ZShsYWJlbCk7XG4gIH0sXG4gIC8vIEFkZGl0aW9uYWwgY29uc29sZSBtZXRob2RzIHRvIHNhdGlzZnkgdGhlIENvbnNvbGUgaW50ZXJmYWNlXG4gIHRpbWVTdGFtcDogKCkgPT4ge1xuICB9LFxuICBwcm9maWxlOiAoKSA9PiB7XG4gIH0sXG4gIHByb2ZpbGVFbmQ6ICgpID0+IHtcbiAgfVxufTtcbmNvbnNvbGUyLkNvbnNvbGUgPSBjb25zb2xlMjtcbmdsb2JhbFRoaXMuY29uc29sZSA9IGNvbnNvbGUyO1xuXG4vLyBzcmMvc2VydmVyL3JlZ2lzdGVyX2hvb2tzLnRzXG5yZWdpc3Rlcl9ob29rcyhob29rcyk7XG5yZWdpc3Rlcl9ob29rcyQxKGhvb2tzX3YxXzEpO1xucmVnaXN0ZXJfaG9va3MkMihob29rc192MV8yKTtcbi8qISBCdW5kbGVkIGxpY2Vuc2UgaW5mb3JtYXRpb246XG5cbnN0YXR1c2VzL2luZGV4LmpzOlxuICAoKiFcbiAgICogc3RhdHVzZXNcbiAgICogQ29weXJpZ2h0KGMpIDIwMTQgSm9uYXRoYW4gT25nXG4gICAqIENvcHlyaWdodChjKSAyMDE2IERvdWdsYXMgQ2hyaXN0b3BoZXIgV2lsc29uXG4gICAqIE1JVCBMaWNlbnNlZFxuICAgKilcbiovXG5cbmV4cG9ydCB7IEFycmF5QnVpbGRlciwgQXJyYXlDb2x1bW5CdWlsZGVyLCBCb29sQnVpbGRlciwgQm9vbENvbHVtbkJ1aWxkZXIsIEJ5dGVBcnJheUJ1aWxkZXIsIEJ5dGVBcnJheUNvbHVtbkJ1aWxkZXIsIENvbHVtbkJ1aWxkZXIsIENvbm5lY3Rpb25JZEJ1aWxkZXIsIENvbm5lY3Rpb25JZENvbHVtbkJ1aWxkZXIsIEYzMkJ1aWxkZXIsIEYzMkNvbHVtbkJ1aWxkZXIsIEY2NEJ1aWxkZXIsIEY2NENvbHVtbkJ1aWxkZXIsIEkxMjhCdWlsZGVyLCBJMTI4Q29sdW1uQnVpbGRlciwgSTE2QnVpbGRlciwgSTE2Q29sdW1uQnVpbGRlciwgSTI1NkJ1aWxkZXIsIEkyNTZDb2x1bW5CdWlsZGVyLCBJMzJCdWlsZGVyLCBJMzJDb2x1bW5CdWlsZGVyLCBJNjRCdWlsZGVyLCBJNjRDb2x1bW5CdWlsZGVyLCBJOEJ1aWxkZXIsIEk4Q29sdW1uQnVpbGRlciwgSWRlbnRpdHlCdWlsZGVyLCBJZGVudGl0eUNvbHVtbkJ1aWxkZXIsIE9wdGlvbkJ1aWxkZXIsIE9wdGlvbkNvbHVtbkJ1aWxkZXIsIFByb2R1Y3RCdWlsZGVyLCBQcm9kdWN0Q29sdW1uQnVpbGRlciwgUmVmQnVpbGRlciwgUmVzdWx0QnVpbGRlciwgUmVzdWx0Q29sdW1uQnVpbGRlciwgUm93QnVpbGRlciwgU2NoZWR1bGVBdEJ1aWxkZXIsIFNjaGVkdWxlQXRDb2x1bW5CdWlsZGVyLCBTZW5kZXJFcnJvciwgU2ltcGxlU3VtQnVpbGRlciwgU2ltcGxlU3VtQ29sdW1uQnVpbGRlciwgU3BhY2V0aW1lSG9zdEVycm9yLCBTdHJpbmdCdWlsZGVyLCBTdHJpbmdDb2x1bW5CdWlsZGVyLCBTdW1CdWlsZGVyLCBTdW1Db2x1bW5CdWlsZGVyLCBUaW1lRHVyYXRpb25CdWlsZGVyLCBUaW1lRHVyYXRpb25Db2x1bW5CdWlsZGVyLCBUaW1lc3RhbXBCdWlsZGVyLCBUaW1lc3RhbXBDb2x1bW5CdWlsZGVyLCBUeXBlQnVpbGRlciwgVTEyOEJ1aWxkZXIsIFUxMjhDb2x1bW5CdWlsZGVyLCBVMTZCdWlsZGVyLCBVMTZDb2x1bW5CdWlsZGVyLCBVMjU2QnVpbGRlciwgVTI1NkNvbHVtbkJ1aWxkZXIsIFUzMkJ1aWxkZXIsIFUzMkNvbHVtbkJ1aWxkZXIsIFU2NEJ1aWxkZXIsIFU2NENvbHVtbkJ1aWxkZXIsIFU4QnVpbGRlciwgVThDb2x1bW5CdWlsZGVyLCBVdWlkQnVpbGRlciwgVXVpZENvbHVtbkJ1aWxkZXIsIGFuZCwgZXJyb3JzLCBub3QsIG9yLCByZWR1Y2Vycywgc2NoZW1hLCB0LCB0YWJsZSwgdG9DYW1lbENhc2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVnZXhwQ29kZSA9IGV4cG9ydHMuZ2V0RXNtRXhwb3J0TmFtZSA9IGV4cG9ydHMuZ2V0UHJvcGVydHkgPSBleHBvcnRzLnNhZmVTdHJpbmdpZnkgPSBleHBvcnRzLnN0cmluZ2lmeSA9IGV4cG9ydHMuc3RyQ29uY2F0ID0gZXhwb3J0cy5hZGRDb2RlQXJnID0gZXhwb3J0cy5zdHIgPSBleHBvcnRzLl8gPSBleHBvcnRzLm5pbCA9IGV4cG9ydHMuX0NvZGUgPSBleHBvcnRzLk5hbWUgPSBleHBvcnRzLklERU5USUZJRVIgPSBleHBvcnRzLl9Db2RlT3JOYW1lID0gdm9pZCAwO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHRyYW5lb3VzLWNsYXNzXG5jbGFzcyBfQ29kZU9yTmFtZSB7XG59XG5leHBvcnRzLl9Db2RlT3JOYW1lID0gX0NvZGVPck5hbWU7XG5leHBvcnRzLklERU5USUZJRVIgPSAvXlthLXokX11bYS16JF8wLTldKiQvaTtcbmNsYXNzIE5hbWUgZXh0ZW5kcyBfQ29kZU9yTmFtZSB7XG4gICAgY29uc3RydWN0b3Iocykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBpZiAoIWV4cG9ydHMuSURFTlRJRklFUi50ZXN0KHMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29kZUdlbjogbmFtZSBtdXN0IGJlIGEgdmFsaWQgaWRlbnRpZmllclwiKTtcbiAgICAgICAgdGhpcy5zdHIgPSBzO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyO1xuICAgIH1cbiAgICBlbXB0eVN0cigpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIHJldHVybiB7IFt0aGlzLnN0cl06IDEgfTtcbiAgICB9XG59XG5leHBvcnRzLk5hbWUgPSBOYW1lO1xuY2xhc3MgX0NvZGUgZXh0ZW5kcyBfQ29kZU9yTmFtZSB7XG4gICAgY29uc3RydWN0b3IoY29kZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9pdGVtcyA9IHR5cGVvZiBjb2RlID09PSBcInN0cmluZ1wiID8gW2NvZGVdIDogY29kZTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cjtcbiAgICB9XG4gICAgZW1wdHlTdHIoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pdGVtcy5sZW5ndGggPiAxKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5faXRlbXNbMF07XG4gICAgICAgIHJldHVybiBpdGVtID09PSBcIlwiIHx8IGl0ZW0gPT09ICdcIlwiJztcbiAgICB9XG4gICAgZ2V0IHN0cigpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IHRoaXMuX3N0cikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKHRoaXMuX3N0ciA9IHRoaXMuX2l0ZW1zLnJlZHVjZSgocywgYykgPT4gYCR7c30ke2N9YCwgXCJcIikpKTtcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gdGhpcy5fbmFtZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICh0aGlzLl9uYW1lcyA9IHRoaXMuX2l0ZW1zLnJlZHVjZSgobmFtZXMsIGMpID0+IHtcbiAgICAgICAgICAgIGlmIChjIGluc3RhbmNlb2YgTmFtZSlcbiAgICAgICAgICAgICAgICBuYW1lc1tjLnN0cl0gPSAobmFtZXNbYy5zdHJdIHx8IDApICsgMTtcbiAgICAgICAgICAgIHJldHVybiBuYW1lcztcbiAgICAgICAgfSwge30pKSk7XG4gICAgfVxufVxuZXhwb3J0cy5fQ29kZSA9IF9Db2RlO1xuZXhwb3J0cy5uaWwgPSBuZXcgX0NvZGUoXCJcIik7XG5mdW5jdGlvbiBfKHN0cnMsIC4uLmFyZ3MpIHtcbiAgICBjb25zdCBjb2RlID0gW3N0cnNbMF1dO1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGFkZENvZGVBcmcoY29kZSwgYXJnc1tpXSk7XG4gICAgICAgIGNvZGUucHVzaChzdHJzWysraV0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IF9Db2RlKGNvZGUpO1xufVxuZXhwb3J0cy5fID0gXztcbmNvbnN0IHBsdXMgPSBuZXcgX0NvZGUoXCIrXCIpO1xuZnVuY3Rpb24gc3RyKHN0cnMsIC4uLmFyZ3MpIHtcbiAgICBjb25zdCBleHByID0gW3NhZmVTdHJpbmdpZnkoc3Ryc1swXSldO1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGV4cHIucHVzaChwbHVzKTtcbiAgICAgICAgYWRkQ29kZUFyZyhleHByLCBhcmdzW2ldKTtcbiAgICAgICAgZXhwci5wdXNoKHBsdXMsIHNhZmVTdHJpbmdpZnkoc3Ryc1srK2ldKSk7XG4gICAgfVxuICAgIG9wdGltaXplKGV4cHIpO1xuICAgIHJldHVybiBuZXcgX0NvZGUoZXhwcik7XG59XG5leHBvcnRzLnN0ciA9IHN0cjtcbmZ1bmN0aW9uIGFkZENvZGVBcmcoY29kZSwgYXJnKSB7XG4gICAgaWYgKGFyZyBpbnN0YW5jZW9mIF9Db2RlKVxuICAgICAgICBjb2RlLnB1c2goLi4uYXJnLl9pdGVtcyk7XG4gICAgZWxzZSBpZiAoYXJnIGluc3RhbmNlb2YgTmFtZSlcbiAgICAgICAgY29kZS5wdXNoKGFyZyk7XG4gICAgZWxzZVxuICAgICAgICBjb2RlLnB1c2goaW50ZXJwb2xhdGUoYXJnKSk7XG59XG5leHBvcnRzLmFkZENvZGVBcmcgPSBhZGRDb2RlQXJnO1xuZnVuY3Rpb24gb3B0aW1pemUoZXhwcikge1xuICAgIGxldCBpID0gMTtcbiAgICB3aGlsZSAoaSA8IGV4cHIubGVuZ3RoIC0gMSkge1xuICAgICAgICBpZiAoZXhwcltpXSA9PT0gcGx1cykge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gbWVyZ2VFeHBySXRlbXMoZXhwcltpIC0gMV0sIGV4cHJbaSArIDFdKTtcbiAgICAgICAgICAgIGlmIChyZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGV4cHIuc3BsaWNlKGkgLSAxLCAzLCByZXMpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhwcltpKytdID0gXCIrXCI7XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1lcmdlRXhwckl0ZW1zKGEsIGIpIHtcbiAgICBpZiAoYiA9PT0gJ1wiXCInKVxuICAgICAgICByZXR1cm4gYTtcbiAgICBpZiAoYSA9PT0gJ1wiXCInKVxuICAgICAgICByZXR1cm4gYjtcbiAgICBpZiAodHlwZW9mIGEgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoYiBpbnN0YW5jZW9mIE5hbWUgfHwgYVthLmxlbmd0aCAtIDFdICE9PSAnXCInKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodHlwZW9mIGIgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHJldHVybiBgJHthLnNsaWNlKDAsIC0xKX0ke2J9XCJgO1xuICAgICAgICBpZiAoYlswXSA9PT0gJ1wiJylcbiAgICAgICAgICAgIHJldHVybiBhLnNsaWNlKDAsIC0xKSArIGIuc2xpY2UoMSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBiID09IFwic3RyaW5nXCIgJiYgYlswXSA9PT0gJ1wiJyAmJiAhKGEgaW5zdGFuY2VvZiBOYW1lKSlcbiAgICAgICAgcmV0dXJuIGBcIiR7YX0ke2Iuc2xpY2UoMSl9YDtcbiAgICByZXR1cm47XG59XG5mdW5jdGlvbiBzdHJDb25jYXQoYzEsIGMyKSB7XG4gICAgcmV0dXJuIGMyLmVtcHR5U3RyKCkgPyBjMSA6IGMxLmVtcHR5U3RyKCkgPyBjMiA6IHN0ciBgJHtjMX0ke2MyfWA7XG59XG5leHBvcnRzLnN0ckNvbmNhdCA9IHN0ckNvbmNhdDtcbi8vIFRPRE8gZG8gbm90IGFsbG93IGFycmF5cyBoZXJlXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZSh4KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB4ID09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHggPT0gXCJib29sZWFuXCIgfHwgeCA9PT0gbnVsbFxuICAgICAgICA/IHhcbiAgICAgICAgOiBzYWZlU3RyaW5naWZ5KEFycmF5LmlzQXJyYXkoeCkgPyB4LmpvaW4oXCIsXCIpIDogeCk7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnkoeCkge1xuICAgIHJldHVybiBuZXcgX0NvZGUoc2FmZVN0cmluZ2lmeSh4KSk7XG59XG5leHBvcnRzLnN0cmluZ2lmeSA9IHN0cmluZ2lmeTtcbmZ1bmN0aW9uIHNhZmVTdHJpbmdpZnkoeCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh4KVxuICAgICAgICAucmVwbGFjZSgvXFx1MjAyOC9nLCBcIlxcXFx1MjAyOFwiKVxuICAgICAgICAucmVwbGFjZSgvXFx1MjAyOS9nLCBcIlxcXFx1MjAyOVwiKTtcbn1cbmV4cG9ydHMuc2FmZVN0cmluZ2lmeSA9IHNhZmVTdHJpbmdpZnk7XG5mdW5jdGlvbiBnZXRQcm9wZXJ0eShrZXkpIHtcbiAgICByZXR1cm4gdHlwZW9mIGtleSA9PSBcInN0cmluZ1wiICYmIGV4cG9ydHMuSURFTlRJRklFUi50ZXN0KGtleSkgPyBuZXcgX0NvZGUoYC4ke2tleX1gKSA6IF8gYFske2tleX1dYDtcbn1cbmV4cG9ydHMuZ2V0UHJvcGVydHkgPSBnZXRQcm9wZXJ0eTtcbi8vRG9lcyBiZXN0IGVmZm9ydCB0byBmb3JtYXQgdGhlIG5hbWUgcHJvcGVybHlcbmZ1bmN0aW9uIGdldEVzbUV4cG9ydE5hbWUoa2V5KSB7XG4gICAgaWYgKHR5cGVvZiBrZXkgPT0gXCJzdHJpbmdcIiAmJiBleHBvcnRzLklERU5USUZJRVIudGVzdChrZXkpKSB7XG4gICAgICAgIHJldHVybiBuZXcgX0NvZGUoYCR7a2V5fWApO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvZGVHZW46IGludmFsaWQgZXhwb3J0IG5hbWU6ICR7a2V5fSwgdXNlIGV4cGxpY2l0ICRpZCBuYW1lIG1hcHBpbmdgKTtcbn1cbmV4cG9ydHMuZ2V0RXNtRXhwb3J0TmFtZSA9IGdldEVzbUV4cG9ydE5hbWU7XG5mdW5jdGlvbiByZWdleHBDb2RlKHJ4KSB7XG4gICAgcmV0dXJuIG5ldyBfQ29kZShyeC50b1N0cmluZygpKTtcbn1cbmV4cG9ydHMucmVnZXhwQ29kZSA9IHJlZ2V4cENvZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2RlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5WYWx1ZVNjb3BlID0gZXhwb3J0cy5WYWx1ZVNjb3BlTmFtZSA9IGV4cG9ydHMuU2NvcGUgPSBleHBvcnRzLnZhcktpbmRzID0gZXhwb3J0cy5Vc2VkVmFsdWVTdGF0ZSA9IHZvaWQgMDtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuL2NvZGVcIik7XG5jbGFzcyBWYWx1ZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICAgICAgc3VwZXIoYENvZGVHZW46IFwiY29kZVwiIGZvciAke25hbWV9IG5vdCBkZWZpbmVkYCk7XG4gICAgICAgIHRoaXMudmFsdWUgPSBuYW1lLnZhbHVlO1xuICAgIH1cbn1cbnZhciBVc2VkVmFsdWVTdGF0ZTtcbihmdW5jdGlvbiAoVXNlZFZhbHVlU3RhdGUpIHtcbiAgICBVc2VkVmFsdWVTdGF0ZVtVc2VkVmFsdWVTdGF0ZVtcIlN0YXJ0ZWRcIl0gPSAwXSA9IFwiU3RhcnRlZFwiO1xuICAgIFVzZWRWYWx1ZVN0YXRlW1VzZWRWYWx1ZVN0YXRlW1wiQ29tcGxldGVkXCJdID0gMV0gPSBcIkNvbXBsZXRlZFwiO1xufSkoVXNlZFZhbHVlU3RhdGUgfHwgKGV4cG9ydHMuVXNlZFZhbHVlU3RhdGUgPSBVc2VkVmFsdWVTdGF0ZSA9IHt9KSk7XG5leHBvcnRzLnZhcktpbmRzID0ge1xuICAgIGNvbnN0OiBuZXcgY29kZV8xLk5hbWUoXCJjb25zdFwiKSxcbiAgICBsZXQ6IG5ldyBjb2RlXzEuTmFtZShcImxldFwiKSxcbiAgICB2YXI6IG5ldyBjb2RlXzEuTmFtZShcInZhclwiKSxcbn07XG5jbGFzcyBTY29wZSB7XG4gICAgY29uc3RydWN0b3IoeyBwcmVmaXhlcywgcGFyZW50IH0gPSB7fSkge1xuICAgICAgICB0aGlzLl9uYW1lcyA9IHt9O1xuICAgICAgICB0aGlzLl9wcmVmaXhlcyA9IHByZWZpeGVzO1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgfVxuICAgIHRvTmFtZShuYW1lT3JQcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIG5hbWVPclByZWZpeCBpbnN0YW5jZW9mIGNvZGVfMS5OYW1lID8gbmFtZU9yUHJlZml4IDogdGhpcy5uYW1lKG5hbWVPclByZWZpeCk7XG4gICAgfVxuICAgIG5hbWUocHJlZml4KSB7XG4gICAgICAgIHJldHVybiBuZXcgY29kZV8xLk5hbWUodGhpcy5fbmV3TmFtZShwcmVmaXgpKTtcbiAgICB9XG4gICAgX25ld05hbWUocHJlZml4KSB7XG4gICAgICAgIGNvbnN0IG5nID0gdGhpcy5fbmFtZXNbcHJlZml4XSB8fCB0aGlzLl9uYW1lR3JvdXAocHJlZml4KTtcbiAgICAgICAgcmV0dXJuIGAke3ByZWZpeH0ke25nLmluZGV4Kyt9YDtcbiAgICB9XG4gICAgX25hbWVHcm91cChwcmVmaXgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKCgoX2IgPSAoX2EgPSB0aGlzLl9wYXJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5fcHJlZml4ZXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5oYXMocHJlZml4KSkgfHwgKHRoaXMuX3ByZWZpeGVzICYmICF0aGlzLl9wcmVmaXhlcy5oYXMocHJlZml4KSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29kZUdlbjogcHJlZml4IFwiJHtwcmVmaXh9XCIgaXMgbm90IGFsbG93ZWQgaW4gdGhpcyBzY29wZWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodGhpcy5fbmFtZXNbcHJlZml4XSA9IHsgcHJlZml4LCBpbmRleDogMCB9KTtcbiAgICB9XG59XG5leHBvcnRzLlNjb3BlID0gU2NvcGU7XG5jbGFzcyBWYWx1ZVNjb3BlTmFtZSBleHRlbmRzIGNvZGVfMS5OYW1lIHtcbiAgICBjb25zdHJ1Y3RvcihwcmVmaXgsIG5hbWVTdHIpIHtcbiAgICAgICAgc3VwZXIobmFtZVN0cik7XG4gICAgICAgIHRoaXMucHJlZml4ID0gcHJlZml4O1xuICAgIH1cbiAgICBzZXRWYWx1ZSh2YWx1ZSwgeyBwcm9wZXJ0eSwgaXRlbUluZGV4IH0pIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnNjb3BlUGF0aCA9ICgwLCBjb2RlXzEuXykgYC4ke25ldyBjb2RlXzEuTmFtZShwcm9wZXJ0eSl9WyR7aXRlbUluZGV4fV1gO1xuICAgIH1cbn1cbmV4cG9ydHMuVmFsdWVTY29wZU5hbWUgPSBWYWx1ZVNjb3BlTmFtZTtcbmNvbnN0IGxpbmUgPSAoMCwgY29kZV8xLl8pIGBcXG5gO1xuY2xhc3MgVmFsdWVTY29wZSBleHRlbmRzIFNjb3BlIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHN1cGVyKG9wdHMpO1xuICAgICAgICB0aGlzLl92YWx1ZXMgPSB7fTtcbiAgICAgICAgdGhpcy5fc2NvcGUgPSBvcHRzLnNjb3BlO1xuICAgICAgICB0aGlzLm9wdHMgPSB7IC4uLm9wdHMsIF9uOiBvcHRzLmxpbmVzID8gbGluZSA6IGNvZGVfMS5uaWwgfTtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2NvcGU7XG4gICAgfVxuICAgIG5hbWUocHJlZml4KSB7XG4gICAgICAgIHJldHVybiBuZXcgVmFsdWVTY29wZU5hbWUocHJlZml4LCB0aGlzLl9uZXdOYW1lKHByZWZpeCkpO1xuICAgIH1cbiAgICB2YWx1ZShuYW1lT3JQcmVmaXgsIHZhbHVlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHZhbHVlLnJlZiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29kZUdlbjogcmVmIG11c3QgYmUgcGFzc2VkIGluIHZhbHVlXCIpO1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy50b05hbWUobmFtZU9yUHJlZml4KTtcbiAgICAgICAgY29uc3QgeyBwcmVmaXggfSA9IG5hbWU7XG4gICAgICAgIGNvbnN0IHZhbHVlS2V5ID0gKF9hID0gdmFsdWUua2V5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB2YWx1ZS5yZWY7XG4gICAgICAgIGxldCB2cyA9IHRoaXMuX3ZhbHVlc1twcmVmaXhdO1xuICAgICAgICBpZiAodnMpIHtcbiAgICAgICAgICAgIGNvbnN0IF9uYW1lID0gdnMuZ2V0KHZhbHVlS2V5KTtcbiAgICAgICAgICAgIGlmIChfbmFtZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gX25hbWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2cyA9IHRoaXMuX3ZhbHVlc1twcmVmaXhdID0gbmV3IE1hcCgpO1xuICAgICAgICB9XG4gICAgICAgIHZzLnNldCh2YWx1ZUtleSwgbmFtZSk7XG4gICAgICAgIGNvbnN0IHMgPSB0aGlzLl9zY29wZVtwcmVmaXhdIHx8ICh0aGlzLl9zY29wZVtwcmVmaXhdID0gW10pO1xuICAgICAgICBjb25zdCBpdGVtSW5kZXggPSBzLmxlbmd0aDtcbiAgICAgICAgc1tpdGVtSW5kZXhdID0gdmFsdWUucmVmO1xuICAgICAgICBuYW1lLnNldFZhbHVlKHZhbHVlLCB7IHByb3BlcnR5OiBwcmVmaXgsIGl0ZW1JbmRleCB9KTtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuICAgIGdldFZhbHVlKHByZWZpeCwga2V5T3JSZWYpIHtcbiAgICAgICAgY29uc3QgdnMgPSB0aGlzLl92YWx1ZXNbcHJlZml4XTtcbiAgICAgICAgaWYgKCF2cylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcmV0dXJuIHZzLmdldChrZXlPclJlZik7XG4gICAgfVxuICAgIHNjb3BlUmVmcyhzY29wZU5hbWUsIHZhbHVlcyA9IHRoaXMuX3ZhbHVlcykge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVkdWNlVmFsdWVzKHZhbHVlcywgKG5hbWUpID0+IHtcbiAgICAgICAgICAgIGlmIChuYW1lLnNjb3BlUGF0aCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29kZUdlbjogbmFtZSBcIiR7bmFtZX1cIiBoYXMgbm8gdmFsdWVgKTtcbiAgICAgICAgICAgIHJldHVybiAoMCwgY29kZV8xLl8pIGAke3Njb3BlTmFtZX0ke25hbWUuc2NvcGVQYXRofWA7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzY29wZUNvZGUodmFsdWVzID0gdGhpcy5fdmFsdWVzLCB1c2VkVmFsdWVzLCBnZXRDb2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWR1Y2VWYWx1ZXModmFsdWVzLCAobmFtZSkgPT4ge1xuICAgICAgICAgICAgaWYgKG5hbWUudmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvZGVHZW46IG5hbWUgXCIke25hbWV9XCIgaGFzIG5vIHZhbHVlYCk7XG4gICAgICAgICAgICByZXR1cm4gbmFtZS52YWx1ZS5jb2RlO1xuICAgICAgICB9LCB1c2VkVmFsdWVzLCBnZXRDb2RlKTtcbiAgICB9XG4gICAgX3JlZHVjZVZhbHVlcyh2YWx1ZXMsIHZhbHVlQ29kZSwgdXNlZFZhbHVlcyA9IHt9LCBnZXRDb2RlKSB7XG4gICAgICAgIGxldCBjb2RlID0gY29kZV8xLm5pbDtcbiAgICAgICAgZm9yIChjb25zdCBwcmVmaXggaW4gdmFsdWVzKSB7XG4gICAgICAgICAgICBjb25zdCB2cyA9IHZhbHVlc1twcmVmaXhdO1xuICAgICAgICAgICAgaWYgKCF2cylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNvbnN0IG5hbWVTZXQgPSAodXNlZFZhbHVlc1twcmVmaXhdID0gdXNlZFZhbHVlc1twcmVmaXhdIHx8IG5ldyBNYXAoKSk7XG4gICAgICAgICAgICB2cy5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWVTZXQuaGFzKG5hbWUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgbmFtZVNldC5zZXQobmFtZSwgVXNlZFZhbHVlU3RhdGUuU3RhcnRlZCk7XG4gICAgICAgICAgICAgICAgbGV0IGMgPSB2YWx1ZUNvZGUobmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVmID0gdGhpcy5vcHRzLmVzNSA/IGV4cG9ydHMudmFyS2luZHMudmFyIDogZXhwb3J0cy52YXJLaW5kcy5jb25zdDtcbiAgICAgICAgICAgICAgICAgICAgY29kZSA9ICgwLCBjb2RlXzEuXykgYCR7Y29kZX0ke2RlZn0gJHtuYW1lfSA9ICR7Y307JHt0aGlzLm9wdHMuX259YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKGMgPSBnZXRDb2RlID09PSBudWxsIHx8IGdldENvZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdldENvZGUobmFtZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGUgPSAoMCwgY29kZV8xLl8pIGAke2NvZGV9JHtjfSR7dGhpcy5vcHRzLl9ufWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmFtZVNldC5zZXQobmFtZSwgVXNlZFZhbHVlU3RhdGUuQ29tcGxldGVkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2RlO1xuICAgIH1cbn1cbmV4cG9ydHMuVmFsdWVTY29wZSA9IFZhbHVlU2NvcGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY29wZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMub3IgPSBleHBvcnRzLmFuZCA9IGV4cG9ydHMubm90ID0gZXhwb3J0cy5Db2RlR2VuID0gZXhwb3J0cy5vcGVyYXRvcnMgPSBleHBvcnRzLnZhcktpbmRzID0gZXhwb3J0cy5WYWx1ZVNjb3BlTmFtZSA9IGV4cG9ydHMuVmFsdWVTY29wZSA9IGV4cG9ydHMuU2NvcGUgPSBleHBvcnRzLk5hbWUgPSBleHBvcnRzLnJlZ2V4cENvZGUgPSBleHBvcnRzLnN0cmluZ2lmeSA9IGV4cG9ydHMuZ2V0UHJvcGVydHkgPSBleHBvcnRzLm5pbCA9IGV4cG9ydHMuc3RyQ29uY2F0ID0gZXhwb3J0cy5zdHIgPSBleHBvcnRzLl8gPSB2b2lkIDA7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi9jb2RlXCIpO1xuY29uc3Qgc2NvcGVfMSA9IHJlcXVpcmUoXCIuL3Njb3BlXCIpO1xudmFyIGNvZGVfMiA9IHJlcXVpcmUoXCIuL2NvZGVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlXzIuXzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0clwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZV8yLnN0cjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0ckNvbmNhdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZV8yLnN0ckNvbmNhdDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm5pbFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZV8yLm5pbDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldFByb3BlcnR5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlXzIuZ2V0UHJvcGVydHk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdHJpbmdpZnlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVfMi5zdHJpbmdpZnk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZWdleHBDb2RlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlXzIucmVnZXhwQ29kZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5hbWVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVfMi5OYW1lOyB9IH0pO1xudmFyIHNjb3BlXzIgPSByZXF1aXJlKFwiLi9zY29wZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNjb3BlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzY29wZV8yLlNjb3BlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVmFsdWVTY29wZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2NvcGVfMi5WYWx1ZVNjb3BlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVmFsdWVTY29wZU5hbWVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNjb3BlXzIuVmFsdWVTY29wZU5hbWU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2YXJLaW5kc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2NvcGVfMi52YXJLaW5kczsgfSB9KTtcbmV4cG9ydHMub3BlcmF0b3JzID0ge1xuICAgIEdUOiBuZXcgY29kZV8xLl9Db2RlKFwiPlwiKSxcbiAgICBHVEU6IG5ldyBjb2RlXzEuX0NvZGUoXCI+PVwiKSxcbiAgICBMVDogbmV3IGNvZGVfMS5fQ29kZShcIjxcIiksXG4gICAgTFRFOiBuZXcgY29kZV8xLl9Db2RlKFwiPD1cIiksXG4gICAgRVE6IG5ldyBjb2RlXzEuX0NvZGUoXCI9PT1cIiksXG4gICAgTkVROiBuZXcgY29kZV8xLl9Db2RlKFwiIT09XCIpLFxuICAgIE5PVDogbmV3IGNvZGVfMS5fQ29kZShcIiFcIiksXG4gICAgT1I6IG5ldyBjb2RlXzEuX0NvZGUoXCJ8fFwiKSxcbiAgICBBTkQ6IG5ldyBjb2RlXzEuX0NvZGUoXCImJlwiKSxcbiAgICBBREQ6IG5ldyBjb2RlXzEuX0NvZGUoXCIrXCIpLFxufTtcbmNsYXNzIE5vZGUge1xuICAgIG9wdGltaXplTm9kZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5hbWVzKF9uYW1lcywgX2NvbnN0YW50cykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5jbGFzcyBEZWYgZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3Rvcih2YXJLaW5kLCBuYW1lLCByaHMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy52YXJLaW5kID0gdmFyS2luZDtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5yaHMgPSByaHM7XG4gICAgfVxuICAgIHJlbmRlcih7IGVzNSwgX24gfSkge1xuICAgICAgICBjb25zdCB2YXJLaW5kID0gZXM1ID8gc2NvcGVfMS52YXJLaW5kcy52YXIgOiB0aGlzLnZhcktpbmQ7XG4gICAgICAgIGNvbnN0IHJocyA9IHRoaXMucmhzID09PSB1bmRlZmluZWQgPyBcIlwiIDogYCA9ICR7dGhpcy5yaHN9YDtcbiAgICAgICAgcmV0dXJuIGAke3ZhcktpbmR9ICR7dGhpcy5uYW1lfSR7cmhzfTtgICsgX247XG4gICAgfVxuICAgIG9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykge1xuICAgICAgICBpZiAoIW5hbWVzW3RoaXMubmFtZS5zdHJdKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5yaHMpXG4gICAgICAgICAgICB0aGlzLnJocyA9IG9wdGltaXplRXhwcih0aGlzLnJocywgbmFtZXMsIGNvbnN0YW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJocyBpbnN0YW5jZW9mIGNvZGVfMS5fQ29kZU9yTmFtZSA/IHRoaXMucmhzLm5hbWVzIDoge307XG4gICAgfVxufVxuY2xhc3MgQXNzaWduIGV4dGVuZHMgTm9kZSB7XG4gICAgY29uc3RydWN0b3IobGhzLCByaHMsIHNpZGVFZmZlY3RzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubGhzID0gbGhzO1xuICAgICAgICB0aGlzLnJocyA9IHJocztcbiAgICAgICAgdGhpcy5zaWRlRWZmZWN0cyA9IHNpZGVFZmZlY3RzO1xuICAgIH1cbiAgICByZW5kZXIoeyBfbiB9KSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmxoc30gPSAke3RoaXMucmhzfTtgICsgX247XG4gICAgfVxuICAgIG9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykge1xuICAgICAgICBpZiAodGhpcy5saHMgaW5zdGFuY2VvZiBjb2RlXzEuTmFtZSAmJiAhbmFtZXNbdGhpcy5saHMuc3RyXSAmJiAhdGhpcy5zaWRlRWZmZWN0cylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5yaHMgPSBvcHRpbWl6ZUV4cHIodGhpcy5yaHMsIG5hbWVzLCBjb25zdGFudHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICBjb25zdCBuYW1lcyA9IHRoaXMubGhzIGluc3RhbmNlb2YgY29kZV8xLk5hbWUgPyB7fSA6IHsgLi4udGhpcy5saHMubmFtZXMgfTtcbiAgICAgICAgcmV0dXJuIGFkZEV4cHJOYW1lcyhuYW1lcywgdGhpcy5yaHMpO1xuICAgIH1cbn1cbmNsYXNzIEFzc2lnbk9wIGV4dGVuZHMgQXNzaWduIHtcbiAgICBjb25zdHJ1Y3RvcihsaHMsIG9wLCByaHMsIHNpZGVFZmZlY3RzKSB7XG4gICAgICAgIHN1cGVyKGxocywgcmhzLCBzaWRlRWZmZWN0cyk7XG4gICAgICAgIHRoaXMub3AgPSBvcDtcbiAgICB9XG4gICAgcmVuZGVyKHsgX24gfSkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5saHN9ICR7dGhpcy5vcH09ICR7dGhpcy5yaHN9O2AgKyBfbjtcbiAgICB9XG59XG5jbGFzcyBMYWJlbCBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKGxhYmVsKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubGFiZWwgPSBsYWJlbDtcbiAgICAgICAgdGhpcy5uYW1lcyA9IHt9O1xuICAgIH1cbiAgICByZW5kZXIoeyBfbiB9KSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmxhYmVsfTpgICsgX247XG4gICAgfVxufVxuY2xhc3MgQnJlYWsgZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihsYWJlbCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmxhYmVsID0gbGFiZWw7XG4gICAgICAgIHRoaXMubmFtZXMgPSB7fTtcbiAgICB9XG4gICAgcmVuZGVyKHsgX24gfSkge1xuICAgICAgICBjb25zdCBsYWJlbCA9IHRoaXMubGFiZWwgPyBgICR7dGhpcy5sYWJlbH1gIDogXCJcIjtcbiAgICAgICAgcmV0dXJuIGBicmVhayR7bGFiZWx9O2AgKyBfbjtcbiAgICB9XG59XG5jbGFzcyBUaHJvdyBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKGVycm9yKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICB9XG4gICAgcmVuZGVyKHsgX24gfSkge1xuICAgICAgICByZXR1cm4gYHRocm93ICR7dGhpcy5lcnJvcn07YCArIF9uO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVycm9yLm5hbWVzO1xuICAgIH1cbn1cbmNsYXNzIEFueUNvZGUgZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb2RlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgfVxuICAgIHJlbmRlcih7IF9uIH0pIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuY29kZX07YCArIF9uO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5vZGVzKCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5jb2RlfWAgPyB0aGlzIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpIHtcbiAgICAgICAgdGhpcy5jb2RlID0gb3B0aW1pemVFeHByKHRoaXMuY29kZSwgbmFtZXMsIGNvbnN0YW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvZGUgaW5zdGFuY2VvZiBjb2RlXzEuX0NvZGVPck5hbWUgPyB0aGlzLmNvZGUubmFtZXMgOiB7fTtcbiAgICB9XG59XG5jbGFzcyBQYXJlbnROb2RlIGV4dGVuZHMgTm9kZSB7XG4gICAgY29uc3RydWN0b3Iobm9kZXMgPSBbXSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm5vZGVzID0gbm9kZXM7XG4gICAgfVxuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzLnJlZHVjZSgoY29kZSwgbikgPT4gY29kZSArIG4ucmVuZGVyKG9wdHMpLCBcIlwiKTtcbiAgICB9XG4gICAgb3B0aW1pemVOb2RlcygpIHtcbiAgICAgICAgY29uc3QgeyBub2RlcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGkgPSBub2Rlcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBub2Rlc1tpXS5vcHRpbWl6ZU5vZGVzKCk7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShuKSlcbiAgICAgICAgICAgICAgICBub2Rlcy5zcGxpY2UoaSwgMSwgLi4ubik7XG4gICAgICAgICAgICBlbHNlIGlmIChuKVxuICAgICAgICAgICAgICAgIG5vZGVzW2ldID0gbjtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBub2Rlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGVzLmxlbmd0aCA+IDAgPyB0aGlzIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpIHtcbiAgICAgICAgY29uc3QgeyBub2RlcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGkgPSBub2Rlcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIC8vIGl0ZXJhdGluZyBiYWNrd2FyZHMgaW1wcm92ZXMgMS1wYXNzIG9wdGltaXphdGlvblxuICAgICAgICAgICAgY29uc3QgbiA9IG5vZGVzW2ldO1xuICAgICAgICAgICAgaWYgKG4ub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHN1YnRyYWN0TmFtZXMobmFtZXMsIG4ubmFtZXMpO1xuICAgICAgICAgICAgbm9kZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2Rlcy5sZW5ndGggPiAwID8gdGhpcyA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2Rlcy5yZWR1Y2UoKG5hbWVzLCBuKSA9PiBhZGROYW1lcyhuYW1lcywgbi5uYW1lcyksIHt9KTtcbiAgICB9XG59XG5jbGFzcyBCbG9ja05vZGUgZXh0ZW5kcyBQYXJlbnROb2RlIHtcbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICByZXR1cm4gXCJ7XCIgKyBvcHRzLl9uICsgc3VwZXIucmVuZGVyKG9wdHMpICsgXCJ9XCIgKyBvcHRzLl9uO1xuICAgIH1cbn1cbmNsYXNzIFJvb3QgZXh0ZW5kcyBQYXJlbnROb2RlIHtcbn1cbmNsYXNzIEVsc2UgZXh0ZW5kcyBCbG9ja05vZGUge1xufVxuRWxzZS5raW5kID0gXCJlbHNlXCI7XG5jbGFzcyBJZiBleHRlbmRzIEJsb2NrTm9kZSB7XG4gICAgY29uc3RydWN0b3IoY29uZGl0aW9uLCBub2Rlcykge1xuICAgICAgICBzdXBlcihub2Rlcyk7XG4gICAgICAgIHRoaXMuY29uZGl0aW9uID0gY29uZGl0aW9uO1xuICAgIH1cbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICBsZXQgY29kZSA9IGBpZigke3RoaXMuY29uZGl0aW9ufSlgICsgc3VwZXIucmVuZGVyKG9wdHMpO1xuICAgICAgICBpZiAodGhpcy5lbHNlKVxuICAgICAgICAgICAgY29kZSArPSBcImVsc2UgXCIgKyB0aGlzLmVsc2UucmVuZGVyKG9wdHMpO1xuICAgICAgICByZXR1cm4gY29kZTtcbiAgICB9XG4gICAgb3B0aW1pemVOb2RlcygpIHtcbiAgICAgICAgc3VwZXIub3B0aW1pemVOb2RlcygpO1xuICAgICAgICBjb25zdCBjb25kID0gdGhpcy5jb25kaXRpb247XG4gICAgICAgIGlmIChjb25kID09PSB0cnVlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubm9kZXM7IC8vIGVsc2UgaXMgaWdub3JlZCBoZXJlXG4gICAgICAgIGxldCBlID0gdGhpcy5lbHNlO1xuICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgY29uc3QgbnMgPSBlLm9wdGltaXplTm9kZXMoKTtcbiAgICAgICAgICAgIGUgPSB0aGlzLmVsc2UgPSBBcnJheS5pc0FycmF5KG5zKSA/IG5ldyBFbHNlKG5zKSA6IG5zO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICBpZiAoY29uZCA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBJZiA/IGUgOiBlLm5vZGVzO1xuICAgICAgICAgICAgaWYgKHRoaXMubm9kZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJZihub3QoY29uZCksIGUgaW5zdGFuY2VvZiBJZiA/IFtlXSA6IGUubm9kZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25kID09PSBmYWxzZSB8fCAhdGhpcy5ub2Rlcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgb3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5lbHNlID0gKF9hID0gdGhpcy5lbHNlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKTtcbiAgICAgICAgaWYgKCEoc3VwZXIub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSB8fCB0aGlzLmVsc2UpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmNvbmRpdGlvbiA9IG9wdGltaXplRXhwcih0aGlzLmNvbmRpdGlvbiwgbmFtZXMsIGNvbnN0YW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIGNvbnN0IG5hbWVzID0gc3VwZXIubmFtZXM7XG4gICAgICAgIGFkZEV4cHJOYW1lcyhuYW1lcywgdGhpcy5jb25kaXRpb24pO1xuICAgICAgICBpZiAodGhpcy5lbHNlKVxuICAgICAgICAgICAgYWRkTmFtZXMobmFtZXMsIHRoaXMuZWxzZS5uYW1lcyk7XG4gICAgICAgIHJldHVybiBuYW1lcztcbiAgICB9XG59XG5JZi5raW5kID0gXCJpZlwiO1xuY2xhc3MgRm9yIGV4dGVuZHMgQmxvY2tOb2RlIHtcbn1cbkZvci5raW5kID0gXCJmb3JcIjtcbmNsYXNzIEZvckxvb3AgZXh0ZW5kcyBGb3Ige1xuICAgIGNvbnN0cnVjdG9yKGl0ZXJhdGlvbikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLml0ZXJhdGlvbiA9IGl0ZXJhdGlvbjtcbiAgICB9XG4gICAgcmVuZGVyKG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIGBmb3IoJHt0aGlzLml0ZXJhdGlvbn0pYCArIHN1cGVyLnJlbmRlcihvcHRzKTtcbiAgICB9XG4gICAgb3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSB7XG4gICAgICAgIGlmICghc3VwZXIub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5pdGVyYXRpb24gPSBvcHRpbWl6ZUV4cHIodGhpcy5pdGVyYXRpb24sIG5hbWVzLCBjb25zdGFudHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICByZXR1cm4gYWRkTmFtZXMoc3VwZXIubmFtZXMsIHRoaXMuaXRlcmF0aW9uLm5hbWVzKTtcbiAgICB9XG59XG5jbGFzcyBGb3JSYW5nZSBleHRlbmRzIEZvciB7XG4gICAgY29uc3RydWN0b3IodmFyS2luZCwgbmFtZSwgZnJvbSwgdG8pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy52YXJLaW5kID0gdmFyS2luZDtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgIH1cbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICBjb25zdCB2YXJLaW5kID0gb3B0cy5lczUgPyBzY29wZV8xLnZhcktpbmRzLnZhciA6IHRoaXMudmFyS2luZDtcbiAgICAgICAgY29uc3QgeyBuYW1lLCBmcm9tLCB0byB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGBmb3IoJHt2YXJLaW5kfSAke25hbWV9PSR7ZnJvbX07ICR7bmFtZX08JHt0b307ICR7bmFtZX0rKylgICsgc3VwZXIucmVuZGVyKG9wdHMpO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIGNvbnN0IG5hbWVzID0gYWRkRXhwck5hbWVzKHN1cGVyLm5hbWVzLCB0aGlzLmZyb20pO1xuICAgICAgICByZXR1cm4gYWRkRXhwck5hbWVzKG5hbWVzLCB0aGlzLnRvKTtcbiAgICB9XG59XG5jbGFzcyBGb3JJdGVyIGV4dGVuZHMgRm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihsb29wLCB2YXJLaW5kLCBuYW1lLCBpdGVyYWJsZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmxvb3AgPSBsb29wO1xuICAgICAgICB0aGlzLnZhcktpbmQgPSB2YXJLaW5kO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLml0ZXJhYmxlID0gaXRlcmFibGU7XG4gICAgfVxuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIHJldHVybiBgZm9yKCR7dGhpcy52YXJLaW5kfSAke3RoaXMubmFtZX0gJHt0aGlzLmxvb3B9ICR7dGhpcy5pdGVyYWJsZX0pYCArIHN1cGVyLnJlbmRlcihvcHRzKTtcbiAgICB9XG4gICAgb3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSB7XG4gICAgICAgIGlmICghc3VwZXIub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5pdGVyYWJsZSA9IG9wdGltaXplRXhwcih0aGlzLml0ZXJhYmxlLCBuYW1lcywgY29uc3RhbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIGFkZE5hbWVzKHN1cGVyLm5hbWVzLCB0aGlzLml0ZXJhYmxlLm5hbWVzKTtcbiAgICB9XG59XG5jbGFzcyBGdW5jIGV4dGVuZHMgQmxvY2tOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBhcmdzLCBhc3luYykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgICAgICB0aGlzLmFzeW5jID0gYXN5bmM7XG4gICAgfVxuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIGNvbnN0IF9hc3luYyA9IHRoaXMuYXN5bmMgPyBcImFzeW5jIFwiIDogXCJcIjtcbiAgICAgICAgcmV0dXJuIGAke19hc3luY31mdW5jdGlvbiAke3RoaXMubmFtZX0oJHt0aGlzLmFyZ3N9KWAgKyBzdXBlci5yZW5kZXIob3B0cyk7XG4gICAgfVxufVxuRnVuYy5raW5kID0gXCJmdW5jXCI7XG5jbGFzcyBSZXR1cm4gZXh0ZW5kcyBQYXJlbnROb2RlIHtcbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICByZXR1cm4gXCJyZXR1cm4gXCIgKyBzdXBlci5yZW5kZXIob3B0cyk7XG4gICAgfVxufVxuUmV0dXJuLmtpbmQgPSBcInJldHVyblwiO1xuY2xhc3MgVHJ5IGV4dGVuZHMgQmxvY2tOb2RlIHtcbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICBsZXQgY29kZSA9IFwidHJ5XCIgKyBzdXBlci5yZW5kZXIob3B0cyk7XG4gICAgICAgIGlmICh0aGlzLmNhdGNoKVxuICAgICAgICAgICAgY29kZSArPSB0aGlzLmNhdGNoLnJlbmRlcihvcHRzKTtcbiAgICAgICAgaWYgKHRoaXMuZmluYWxseSlcbiAgICAgICAgICAgIGNvZGUgKz0gdGhpcy5maW5hbGx5LnJlbmRlcihvcHRzKTtcbiAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgfVxuICAgIG9wdGltaXplTm9kZXMoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHN1cGVyLm9wdGltaXplTm9kZXMoKTtcbiAgICAgICAgKF9hID0gdGhpcy5jYXRjaCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9wdGltaXplTm9kZXMoKTtcbiAgICAgICAgKF9iID0gdGhpcy5maW5hbGx5KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iub3B0aW1pemVOb2RlcygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgb3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHN1cGVyLm9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cyk7XG4gICAgICAgIChfYSA9IHRoaXMuY2F0Y2gpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpO1xuICAgICAgICAoX2IgPSB0aGlzLmZpbmFsbHkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICBjb25zdCBuYW1lcyA9IHN1cGVyLm5hbWVzO1xuICAgICAgICBpZiAodGhpcy5jYXRjaClcbiAgICAgICAgICAgIGFkZE5hbWVzKG5hbWVzLCB0aGlzLmNhdGNoLm5hbWVzKTtcbiAgICAgICAgaWYgKHRoaXMuZmluYWxseSlcbiAgICAgICAgICAgIGFkZE5hbWVzKG5hbWVzLCB0aGlzLmZpbmFsbHkubmFtZXMpO1xuICAgICAgICByZXR1cm4gbmFtZXM7XG4gICAgfVxufVxuY2xhc3MgQ2F0Y2ggZXh0ZW5kcyBCbG9ja05vZGUge1xuICAgIGNvbnN0cnVjdG9yKGVycm9yKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICB9XG4gICAgcmVuZGVyKG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIGBjYXRjaCgke3RoaXMuZXJyb3J9KWAgKyBzdXBlci5yZW5kZXIob3B0cyk7XG4gICAgfVxufVxuQ2F0Y2gua2luZCA9IFwiY2F0Y2hcIjtcbmNsYXNzIEZpbmFsbHkgZXh0ZW5kcyBCbG9ja05vZGUge1xuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIHJldHVybiBcImZpbmFsbHlcIiArIHN1cGVyLnJlbmRlcihvcHRzKTtcbiAgICB9XG59XG5GaW5hbGx5LmtpbmQgPSBcImZpbmFsbHlcIjtcbmNsYXNzIENvZGVHZW4ge1xuICAgIGNvbnN0cnVjdG9yKGV4dFNjb3BlLCBvcHRzID0ge30pIHtcbiAgICAgICAgdGhpcy5fdmFsdWVzID0ge307XG4gICAgICAgIHRoaXMuX2Jsb2NrU3RhcnRzID0gW107XG4gICAgICAgIHRoaXMuX2NvbnN0YW50cyA9IHt9O1xuICAgICAgICB0aGlzLm9wdHMgPSB7IC4uLm9wdHMsIF9uOiBvcHRzLmxpbmVzID8gXCJcXG5cIiA6IFwiXCIgfTtcbiAgICAgICAgdGhpcy5fZXh0U2NvcGUgPSBleHRTY29wZTtcbiAgICAgICAgdGhpcy5fc2NvcGUgPSBuZXcgc2NvcGVfMS5TY29wZSh7IHBhcmVudDogZXh0U2NvcGUgfSk7XG4gICAgICAgIHRoaXMuX25vZGVzID0gW25ldyBSb290KCldO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3QucmVuZGVyKHRoaXMub3B0cyk7XG4gICAgfVxuICAgIC8vIHJldHVybnMgdW5pcXVlIG5hbWUgaW4gdGhlIGludGVybmFsIHNjb3BlXG4gICAgbmFtZShwcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Njb3BlLm5hbWUocHJlZml4KTtcbiAgICB9XG4gICAgLy8gcmVzZXJ2ZXMgdW5pcXVlIG5hbWUgaW4gdGhlIGV4dGVybmFsIHNjb3BlXG4gICAgc2NvcGVOYW1lKHByZWZpeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXh0U2NvcGUubmFtZShwcmVmaXgpO1xuICAgIH1cbiAgICAvLyByZXNlcnZlcyB1bmlxdWUgbmFtZSBpbiB0aGUgZXh0ZXJuYWwgc2NvcGUgYW5kIGFzc2lnbnMgdmFsdWUgdG8gaXRcbiAgICBzY29wZVZhbHVlKHByZWZpeE9yTmFtZSwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuX2V4dFNjb3BlLnZhbHVlKHByZWZpeE9yTmFtZSwgdmFsdWUpO1xuICAgICAgICBjb25zdCB2cyA9IHRoaXMuX3ZhbHVlc1tuYW1lLnByZWZpeF0gfHwgKHRoaXMuX3ZhbHVlc1tuYW1lLnByZWZpeF0gPSBuZXcgU2V0KCkpO1xuICAgICAgICB2cy5hZGQobmFtZSk7XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbiAgICBnZXRTY29wZVZhbHVlKHByZWZpeCwga2V5T3JSZWYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4dFNjb3BlLmdldFZhbHVlKHByZWZpeCwga2V5T3JSZWYpO1xuICAgIH1cbiAgICAvLyByZXR1cm4gY29kZSB0aGF0IGFzc2lnbnMgdmFsdWVzIGluIHRoZSBleHRlcm5hbCBzY29wZSB0byB0aGUgbmFtZXMgdGhhdCBhcmUgdXNlZCBpbnRlcm5hbGx5XG4gICAgLy8gKHNhbWUgbmFtZXMgdGhhdCB3ZXJlIHJldHVybmVkIGJ5IGdlbi5zY29wZU5hbWUgb3IgZ2VuLnNjb3BlVmFsdWUpXG4gICAgc2NvcGVSZWZzKHNjb3BlTmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXh0U2NvcGUuc2NvcGVSZWZzKHNjb3BlTmFtZSwgdGhpcy5fdmFsdWVzKTtcbiAgICB9XG4gICAgc2NvcGVDb2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXh0U2NvcGUuc2NvcGVDb2RlKHRoaXMuX3ZhbHVlcyk7XG4gICAgfVxuICAgIF9kZWYodmFyS2luZCwgbmFtZU9yUHJlZml4LCByaHMsIGNvbnN0YW50KSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLl9zY29wZS50b05hbWUobmFtZU9yUHJlZml4KTtcbiAgICAgICAgaWYgKHJocyAhPT0gdW5kZWZpbmVkICYmIGNvbnN0YW50KVxuICAgICAgICAgICAgdGhpcy5fY29uc3RhbnRzW25hbWUuc3RyXSA9IHJocztcbiAgICAgICAgdGhpcy5fbGVhZk5vZGUobmV3IERlZih2YXJLaW5kLCBuYW1lLCByaHMpKTtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuICAgIC8vIGBjb25zdGAgZGVjbGFyYXRpb24gKGB2YXJgIGluIGVzNSBtb2RlKVxuICAgIGNvbnN0KG5hbWVPclByZWZpeCwgcmhzLCBfY29uc3RhbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZihzY29wZV8xLnZhcktpbmRzLmNvbnN0LCBuYW1lT3JQcmVmaXgsIHJocywgX2NvbnN0YW50KTtcbiAgICB9XG4gICAgLy8gYGxldGAgZGVjbGFyYXRpb24gd2l0aCBvcHRpb25hbCBhc3NpZ25tZW50IChgdmFyYCBpbiBlczUgbW9kZSlcbiAgICBsZXQobmFtZU9yUHJlZml4LCByaHMsIF9jb25zdGFudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmKHNjb3BlXzEudmFyS2luZHMubGV0LCBuYW1lT3JQcmVmaXgsIHJocywgX2NvbnN0YW50KTtcbiAgICB9XG4gICAgLy8gYHZhcmAgZGVjbGFyYXRpb24gd2l0aCBvcHRpb25hbCBhc3NpZ25tZW50XG4gICAgdmFyKG5hbWVPclByZWZpeCwgcmhzLCBfY29uc3RhbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZihzY29wZV8xLnZhcktpbmRzLnZhciwgbmFtZU9yUHJlZml4LCByaHMsIF9jb25zdGFudCk7XG4gICAgfVxuICAgIC8vIGFzc2lnbm1lbnQgY29kZVxuICAgIGFzc2lnbihsaHMsIHJocywgc2lkZUVmZmVjdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlYWZOb2RlKG5ldyBBc3NpZ24obGhzLCByaHMsIHNpZGVFZmZlY3RzKSk7XG4gICAgfVxuICAgIC8vIGArPWAgY29kZVxuICAgIGFkZChsaHMsIHJocykge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVhZk5vZGUobmV3IEFzc2lnbk9wKGxocywgZXhwb3J0cy5vcGVyYXRvcnMuQURELCByaHMpKTtcbiAgICB9XG4gICAgLy8gYXBwZW5kcyBwYXNzZWQgU2FmZUV4cHIgdG8gY29kZSBvciBleGVjdXRlcyBCbG9ja1xuICAgIGNvZGUoYykge1xuICAgICAgICBpZiAodHlwZW9mIGMgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgYygpO1xuICAgICAgICBlbHNlIGlmIChjICE9PSBjb2RlXzEubmlsKVxuICAgICAgICAgICAgdGhpcy5fbGVhZk5vZGUobmV3IEFueUNvZGUoYykpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gcmV0dXJucyBjb2RlIGZvciBvYmplY3QgbGl0ZXJhbCBmb3IgdGhlIHBhc3NlZCBhcmd1bWVudCBsaXN0IG9mIGtleS12YWx1ZSBwYWlyc1xuICAgIG9iamVjdCguLi5rZXlWYWx1ZXMpIHtcbiAgICAgICAgY29uc3QgY29kZSA9IFtcIntcIl07XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGtleVZhbHVlcykge1xuICAgICAgICAgICAgaWYgKGNvZGUubGVuZ3RoID4gMSlcbiAgICAgICAgICAgICAgICBjb2RlLnB1c2goXCIsXCIpO1xuICAgICAgICAgICAgY29kZS5wdXNoKGtleSk7XG4gICAgICAgICAgICBpZiAoa2V5ICE9PSB2YWx1ZSB8fCB0aGlzLm9wdHMuZXM1KSB7XG4gICAgICAgICAgICAgICAgY29kZS5wdXNoKFwiOlwiKTtcbiAgICAgICAgICAgICAgICAoMCwgY29kZV8xLmFkZENvZGVBcmcpKGNvZGUsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb2RlLnB1c2goXCJ9XCIpO1xuICAgICAgICByZXR1cm4gbmV3IGNvZGVfMS5fQ29kZShjb2RlKTtcbiAgICB9XG4gICAgLy8gYGlmYCBjbGF1c2UgKG9yIHN0YXRlbWVudCBpZiBgdGhlbkJvZHlgIGFuZCwgb3B0aW9uYWxseSwgYGVsc2VCb2R5YCBhcmUgcGFzc2VkKVxuICAgIGlmKGNvbmRpdGlvbiwgdGhlbkJvZHksIGVsc2VCb2R5KSB7XG4gICAgICAgIHRoaXMuX2Jsb2NrTm9kZShuZXcgSWYoY29uZGl0aW9uKSk7XG4gICAgICAgIGlmICh0aGVuQm9keSAmJiBlbHNlQm9keSkge1xuICAgICAgICAgICAgdGhpcy5jb2RlKHRoZW5Cb2R5KS5lbHNlKCkuY29kZShlbHNlQm9keSkuZW5kSWYoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGVuQm9keSkge1xuICAgICAgICAgICAgdGhpcy5jb2RlKHRoZW5Cb2R5KS5lbmRJZigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsc2VCb2R5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvZGVHZW46IFwiZWxzZVwiIGJvZHkgd2l0aG91dCBcInRoZW5cIiBib2R5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIGBlbHNlIGlmYCBjbGF1c2UgLSBpbnZhbGlkIHdpdGhvdXQgYGlmYCBvciBhZnRlciBgZWxzZWAgY2xhdXNlc1xuICAgIGVsc2VJZihjb25kaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Vsc2VOb2RlKG5ldyBJZihjb25kaXRpb24pKTtcbiAgICB9XG4gICAgLy8gYGVsc2VgIGNsYXVzZSAtIG9ubHkgdmFsaWQgYWZ0ZXIgYGlmYCBvciBgZWxzZSBpZmAgY2xhdXNlc1xuICAgIGVsc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbHNlTm9kZShuZXcgRWxzZSgpKTtcbiAgICB9XG4gICAgLy8gZW5kIGBpZmAgc3RhdGVtZW50IChuZWVkZWQgaWYgZ2VuLmlmIHdhcyB1c2VkIG9ubHkgd2l0aCBjb25kaXRpb24pXG4gICAgZW5kSWYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmRCbG9ja05vZGUoSWYsIEVsc2UpO1xuICAgIH1cbiAgICBfZm9yKG5vZGUsIGZvckJvZHkpIHtcbiAgICAgICAgdGhpcy5fYmxvY2tOb2RlKG5vZGUpO1xuICAgICAgICBpZiAoZm9yQm9keSlcbiAgICAgICAgICAgIHRoaXMuY29kZShmb3JCb2R5KS5lbmRGb3IoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIGEgZ2VuZXJpYyBgZm9yYCBjbGF1c2UgKG9yIHN0YXRlbWVudCBpZiBgZm9yQm9keWAgaXMgcGFzc2VkKVxuICAgIGZvcihpdGVyYXRpb24sIGZvckJvZHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZvcihuZXcgRm9yTG9vcChpdGVyYXRpb24pLCBmb3JCb2R5KTtcbiAgICB9XG4gICAgLy8gYGZvcmAgc3RhdGVtZW50IGZvciBhIHJhbmdlIG9mIHZhbHVlc1xuICAgIGZvclJhbmdlKG5hbWVPclByZWZpeCwgZnJvbSwgdG8sIGZvckJvZHksIHZhcktpbmQgPSB0aGlzLm9wdHMuZXM1ID8gc2NvcGVfMS52YXJLaW5kcy52YXIgOiBzY29wZV8xLnZhcktpbmRzLmxldCkge1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5fc2NvcGUudG9OYW1lKG5hbWVPclByZWZpeCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9mb3IobmV3IEZvclJhbmdlKHZhcktpbmQsIG5hbWUsIGZyb20sIHRvKSwgKCkgPT4gZm9yQm9keShuYW1lKSk7XG4gICAgfVxuICAgIC8vIGBmb3Itb2ZgIHN0YXRlbWVudCAoaW4gZXM1IG1vZGUgcmVwbGFjZSB3aXRoIGEgbm9ybWFsIGZvciBsb29wKVxuICAgIGZvck9mKG5hbWVPclByZWZpeCwgaXRlcmFibGUsIGZvckJvZHksIHZhcktpbmQgPSBzY29wZV8xLnZhcktpbmRzLmNvbnN0KSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLl9zY29wZS50b05hbWUobmFtZU9yUHJlZml4KTtcbiAgICAgICAgaWYgKHRoaXMub3B0cy5lczUpIHtcbiAgICAgICAgICAgIGNvbnN0IGFyciA9IGl0ZXJhYmxlIGluc3RhbmNlb2YgY29kZV8xLk5hbWUgPyBpdGVyYWJsZSA6IHRoaXMudmFyKFwiX2FyclwiLCBpdGVyYWJsZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JSYW5nZShcIl9pXCIsIDAsICgwLCBjb2RlXzEuXykgYCR7YXJyfS5sZW5ndGhgLCAoaSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudmFyKG5hbWUsICgwLCBjb2RlXzEuXykgYCR7YXJyfVske2l9XWApO1xuICAgICAgICAgICAgICAgIGZvckJvZHkobmFtZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZm9yKG5ldyBGb3JJdGVyKFwib2ZcIiwgdmFyS2luZCwgbmFtZSwgaXRlcmFibGUpLCAoKSA9PiBmb3JCb2R5KG5hbWUpKTtcbiAgICB9XG4gICAgLy8gYGZvci1pbmAgc3RhdGVtZW50LlxuICAgIC8vIFdpdGggb3B0aW9uIGBvd25Qcm9wZXJ0aWVzYCByZXBsYWNlZCB3aXRoIGEgYGZvci1vZmAgbG9vcCBmb3Igb2JqZWN0IGtleXNcbiAgICBmb3JJbihuYW1lT3JQcmVmaXgsIG9iaiwgZm9yQm9keSwgdmFyS2luZCA9IHRoaXMub3B0cy5lczUgPyBzY29wZV8xLnZhcktpbmRzLnZhciA6IHNjb3BlXzEudmFyS2luZHMuY29uc3QpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0cy5vd25Qcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JPZihuYW1lT3JQcmVmaXgsICgwLCBjb2RlXzEuXykgYE9iamVjdC5rZXlzKCR7b2JqfSlgLCBmb3JCb2R5KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5fc2NvcGUudG9OYW1lKG5hbWVPclByZWZpeCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9mb3IobmV3IEZvckl0ZXIoXCJpblwiLCB2YXJLaW5kLCBuYW1lLCBvYmopLCAoKSA9PiBmb3JCb2R5KG5hbWUpKTtcbiAgICB9XG4gICAgLy8gZW5kIGBmb3JgIGxvb3BcbiAgICBlbmRGb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmRCbG9ja05vZGUoRm9yKTtcbiAgICB9XG4gICAgLy8gYGxhYmVsYCBzdGF0ZW1lbnRcbiAgICBsYWJlbChsYWJlbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVhZk5vZGUobmV3IExhYmVsKGxhYmVsKSk7XG4gICAgfVxuICAgIC8vIGBicmVha2Agc3RhdGVtZW50XG4gICAgYnJlYWsobGFiZWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlYWZOb2RlKG5ldyBCcmVhayhsYWJlbCkpO1xuICAgIH1cbiAgICAvLyBgcmV0dXJuYCBzdGF0ZW1lbnRcbiAgICByZXR1cm4odmFsdWUpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5ldyBSZXR1cm4oKTtcbiAgICAgICAgdGhpcy5fYmxvY2tOb2RlKG5vZGUpO1xuICAgICAgICB0aGlzLmNvZGUodmFsdWUpO1xuICAgICAgICBpZiAobm9kZS5ub2Rlcy5sZW5ndGggIT09IDEpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvZGVHZW46IFwicmV0dXJuXCIgc2hvdWxkIGhhdmUgb25lIG5vZGUnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuZEJsb2NrTm9kZShSZXR1cm4pO1xuICAgIH1cbiAgICAvLyBgdHJ5YCBzdGF0ZW1lbnRcbiAgICB0cnkodHJ5Qm9keSwgY2F0Y2hDb2RlLCBmaW5hbGx5Q29kZSkge1xuICAgICAgICBpZiAoIWNhdGNoQ29kZSAmJiAhZmluYWxseUNvZGUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvZGVHZW46IFwidHJ5XCIgd2l0aG91dCBcImNhdGNoXCIgYW5kIFwiZmluYWxseVwiJyk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBuZXcgVHJ5KCk7XG4gICAgICAgIHRoaXMuX2Jsb2NrTm9kZShub2RlKTtcbiAgICAgICAgdGhpcy5jb2RlKHRyeUJvZHkpO1xuICAgICAgICBpZiAoY2F0Y2hDb2RlKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMubmFtZShcImVcIik7XG4gICAgICAgICAgICB0aGlzLl9jdXJyTm9kZSA9IG5vZGUuY2F0Y2ggPSBuZXcgQ2F0Y2goZXJyb3IpO1xuICAgICAgICAgICAgY2F0Y2hDb2RlKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmluYWxseUNvZGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJOb2RlID0gbm9kZS5maW5hbGx5ID0gbmV3IEZpbmFsbHkoKTtcbiAgICAgICAgICAgIHRoaXMuY29kZShmaW5hbGx5Q29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuZEJsb2NrTm9kZShDYXRjaCwgRmluYWxseSk7XG4gICAgfVxuICAgIC8vIGB0aHJvd2Agc3RhdGVtZW50XG4gICAgdGhyb3coZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlYWZOb2RlKG5ldyBUaHJvdyhlcnJvcikpO1xuICAgIH1cbiAgICAvLyBzdGFydCBzZWxmLWJhbGFuY2luZyBibG9ja1xuICAgIGJsb2NrKGJvZHksIG5vZGVDb3VudCkge1xuICAgICAgICB0aGlzLl9ibG9ja1N0YXJ0cy5wdXNoKHRoaXMuX25vZGVzLmxlbmd0aCk7XG4gICAgICAgIGlmIChib2R5KVxuICAgICAgICAgICAgdGhpcy5jb2RlKGJvZHkpLmVuZEJsb2NrKG5vZGVDb3VudCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBlbmQgdGhlIGN1cnJlbnQgc2VsZi1iYWxhbmNpbmcgYmxvY2tcbiAgICBlbmRCbG9jayhub2RlQ291bnQpIHtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5fYmxvY2tTdGFydHMucG9wKCk7XG4gICAgICAgIGlmIChsZW4gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvZGVHZW46IG5vdCBpbiBzZWxmLWJhbGFuY2luZyBibG9ja1wiKTtcbiAgICAgICAgY29uc3QgdG9DbG9zZSA9IHRoaXMuX25vZGVzLmxlbmd0aCAtIGxlbjtcbiAgICAgICAgaWYgKHRvQ2xvc2UgPCAwIHx8IChub2RlQ291bnQgIT09IHVuZGVmaW5lZCAmJiB0b0Nsb3NlICE9PSBub2RlQ291bnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvZGVHZW46IHdyb25nIG51bWJlciBvZiBub2RlczogJHt0b0Nsb3NlfSB2cyAke25vZGVDb3VudH0gZXhwZWN0ZWRgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9ub2Rlcy5sZW5ndGggPSBsZW47XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBgZnVuY3Rpb25gIGhlYWRpbmcgKG9yIGRlZmluaXRpb24gaWYgZnVuY0JvZHkgaXMgcGFzc2VkKVxuICAgIGZ1bmMobmFtZSwgYXJncyA9IGNvZGVfMS5uaWwsIGFzeW5jLCBmdW5jQm9keSkge1xuICAgICAgICB0aGlzLl9ibG9ja05vZGUobmV3IEZ1bmMobmFtZSwgYXJncywgYXN5bmMpKTtcbiAgICAgICAgaWYgKGZ1bmNCb2R5KVxuICAgICAgICAgICAgdGhpcy5jb2RlKGZ1bmNCb2R5KS5lbmRGdW5jKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBlbmQgZnVuY3Rpb24gZGVmaW5pdGlvblxuICAgIGVuZEZ1bmMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmRCbG9ja05vZGUoRnVuYyk7XG4gICAgfVxuICAgIG9wdGltaXplKG4gPSAxKSB7XG4gICAgICAgIHdoaWxlIChuLS0gPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9yb290Lm9wdGltaXplTm9kZXMoKTtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3Qub3B0aW1pemVOYW1lcyh0aGlzLl9yb290Lm5hbWVzLCB0aGlzLl9jb25zdGFudHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9sZWFmTm9kZShub2RlKSB7XG4gICAgICAgIHRoaXMuX2N1cnJOb2RlLm5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBfYmxvY2tOb2RlKG5vZGUpIHtcbiAgICAgICAgdGhpcy5fY3Vyck5vZGUubm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgdGhpcy5fbm9kZXMucHVzaChub2RlKTtcbiAgICB9XG4gICAgX2VuZEJsb2NrTm9kZShOMSwgTjIpIHtcbiAgICAgICAgY29uc3QgbiA9IHRoaXMuX2N1cnJOb2RlO1xuICAgICAgICBpZiAobiBpbnN0YW5jZW9mIE4xIHx8IChOMiAmJiBuIGluc3RhbmNlb2YgTjIpKSB7XG4gICAgICAgICAgICB0aGlzLl9ub2Rlcy5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29kZUdlbjogbm90IGluIGJsb2NrIFwiJHtOMiA/IGAke04xLmtpbmR9LyR7TjIua2luZH1gIDogTjEua2luZH1cImApO1xuICAgIH1cbiAgICBfZWxzZU5vZGUobm9kZSkge1xuICAgICAgICBjb25zdCBuID0gdGhpcy5fY3Vyck5vZGU7XG4gICAgICAgIGlmICghKG4gaW5zdGFuY2VvZiBJZikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29kZUdlbjogXCJlbHNlXCIgd2l0aG91dCBcImlmXCInKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jdXJyTm9kZSA9IG4uZWxzZSA9IG5vZGU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgX3Jvb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ub2Rlc1swXTtcbiAgICB9XG4gICAgZ2V0IF9jdXJyTm9kZSgpIHtcbiAgICAgICAgY29uc3QgbnMgPSB0aGlzLl9ub2RlcztcbiAgICAgICAgcmV0dXJuIG5zW25zLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICBzZXQgX2N1cnJOb2RlKG5vZGUpIHtcbiAgICAgICAgY29uc3QgbnMgPSB0aGlzLl9ub2RlcztcbiAgICAgICAgbnNbbnMubGVuZ3RoIC0gMV0gPSBub2RlO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29kZUdlbiA9IENvZGVHZW47XG5mdW5jdGlvbiBhZGROYW1lcyhuYW1lcywgZnJvbSkge1xuICAgIGZvciAoY29uc3QgbiBpbiBmcm9tKVxuICAgICAgICBuYW1lc1tuXSA9IChuYW1lc1tuXSB8fCAwKSArIChmcm9tW25dIHx8IDApO1xuICAgIHJldHVybiBuYW1lcztcbn1cbmZ1bmN0aW9uIGFkZEV4cHJOYW1lcyhuYW1lcywgZnJvbSkge1xuICAgIHJldHVybiBmcm9tIGluc3RhbmNlb2YgY29kZV8xLl9Db2RlT3JOYW1lID8gYWRkTmFtZXMobmFtZXMsIGZyb20ubmFtZXMpIDogbmFtZXM7XG59XG5mdW5jdGlvbiBvcHRpbWl6ZUV4cHIoZXhwciwgbmFtZXMsIGNvbnN0YW50cykge1xuICAgIGlmIChleHByIGluc3RhbmNlb2YgY29kZV8xLk5hbWUpXG4gICAgICAgIHJldHVybiByZXBsYWNlTmFtZShleHByKTtcbiAgICBpZiAoIWNhbk9wdGltaXplKGV4cHIpKVxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICByZXR1cm4gbmV3IGNvZGVfMS5fQ29kZShleHByLl9pdGVtcy5yZWR1Y2UoKGl0ZW1zLCBjKSA9PiB7XG4gICAgICAgIGlmIChjIGluc3RhbmNlb2YgY29kZV8xLk5hbWUpXG4gICAgICAgICAgICBjID0gcmVwbGFjZU5hbWUoYyk7XG4gICAgICAgIGlmIChjIGluc3RhbmNlb2YgY29kZV8xLl9Db2RlKVxuICAgICAgICAgICAgaXRlbXMucHVzaCguLi5jLl9pdGVtcyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goYyk7XG4gICAgICAgIHJldHVybiBpdGVtcztcbiAgICB9LCBbXSkpO1xuICAgIGZ1bmN0aW9uIHJlcGxhY2VOYW1lKG4pIHtcbiAgICAgICAgY29uc3QgYyA9IGNvbnN0YW50c1tuLnN0cl07XG4gICAgICAgIGlmIChjID09PSB1bmRlZmluZWQgfHwgbmFtZXNbbi5zdHJdICE9PSAxKVxuICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIGRlbGV0ZSBuYW1lc1tuLnN0cl07XG4gICAgICAgIHJldHVybiBjO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjYW5PcHRpbWl6ZShlKSB7XG4gICAgICAgIHJldHVybiAoZSBpbnN0YW5jZW9mIGNvZGVfMS5fQ29kZSAmJlxuICAgICAgICAgICAgZS5faXRlbXMuc29tZSgoYykgPT4gYyBpbnN0YW5jZW9mIGNvZGVfMS5OYW1lICYmIG5hbWVzW2Muc3RyXSA9PT0gMSAmJiBjb25zdGFudHNbYy5zdHJdICE9PSB1bmRlZmluZWQpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzdWJ0cmFjdE5hbWVzKG5hbWVzLCBmcm9tKSB7XG4gICAgZm9yIChjb25zdCBuIGluIGZyb20pXG4gICAgICAgIG5hbWVzW25dID0gKG5hbWVzW25dIHx8IDApIC0gKGZyb21bbl0gfHwgMCk7XG59XG5mdW5jdGlvbiBub3QoeCkge1xuICAgIHJldHVybiB0eXBlb2YgeCA9PSBcImJvb2xlYW5cIiB8fCB0eXBlb2YgeCA9PSBcIm51bWJlclwiIHx8IHggPT09IG51bGwgPyAheCA6ICgwLCBjb2RlXzEuXykgYCEke3Bhcih4KX1gO1xufVxuZXhwb3J0cy5ub3QgPSBub3Q7XG5jb25zdCBhbmRDb2RlID0gbWFwcGVuZChleHBvcnRzLm9wZXJhdG9ycy5BTkQpO1xuLy8gYm9vbGVhbiBBTkQgKCYmKSBleHByZXNzaW9uIHdpdGggdGhlIHBhc3NlZCBhcmd1bWVudHNcbmZ1bmN0aW9uIGFuZCguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGFyZ3MucmVkdWNlKGFuZENvZGUpO1xufVxuZXhwb3J0cy5hbmQgPSBhbmQ7XG5jb25zdCBvckNvZGUgPSBtYXBwZW5kKGV4cG9ydHMub3BlcmF0b3JzLk9SKTtcbi8vIGJvb2xlYW4gT1IgKHx8KSBleHByZXNzaW9uIHdpdGggdGhlIHBhc3NlZCBhcmd1bWVudHNcbmZ1bmN0aW9uIG9yKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gYXJncy5yZWR1Y2Uob3JDb2RlKTtcbn1cbmV4cG9ydHMub3IgPSBvcjtcbmZ1bmN0aW9uIG1hcHBlbmQob3ApIHtcbiAgICByZXR1cm4gKHgsIHkpID0+ICh4ID09PSBjb2RlXzEubmlsID8geSA6IHkgPT09IGNvZGVfMS5uaWwgPyB4IDogKDAsIGNvZGVfMS5fKSBgJHtwYXIoeCl9ICR7b3B9ICR7cGFyKHkpfWApO1xufVxuZnVuY3Rpb24gcGFyKHgpIHtcbiAgICByZXR1cm4geCBpbnN0YW5jZW9mIGNvZGVfMS5OYW1lID8geCA6ICgwLCBjb2RlXzEuXykgYCgke3h9KWA7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY2hlY2tTdHJpY3RNb2RlID0gZXhwb3J0cy5nZXRFcnJvclBhdGggPSBleHBvcnRzLlR5cGUgPSBleHBvcnRzLnVzZUZ1bmMgPSBleHBvcnRzLnNldEV2YWx1YXRlZCA9IGV4cG9ydHMuZXZhbHVhdGVkUHJvcHNUb05hbWUgPSBleHBvcnRzLm1lcmdlRXZhbHVhdGVkID0gZXhwb3J0cy5lYWNoSXRlbSA9IGV4cG9ydHMudW5lc2NhcGVKc29uUG9pbnRlciA9IGV4cG9ydHMuZXNjYXBlSnNvblBvaW50ZXIgPSBleHBvcnRzLmVzY2FwZUZyYWdtZW50ID0gZXhwb3J0cy51bmVzY2FwZUZyYWdtZW50ID0gZXhwb3J0cy5zY2hlbWFSZWZPclZhbCA9IGV4cG9ydHMuc2NoZW1hSGFzUnVsZXNCdXRSZWYgPSBleHBvcnRzLnNjaGVtYUhhc1J1bGVzID0gZXhwb3J0cy5jaGVja1Vua25vd25SdWxlcyA9IGV4cG9ydHMuYWx3YXlzVmFsaWRTY2hlbWEgPSBleHBvcnRzLnRvSGFzaCA9IHZvaWQgMDtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuL2NvZGVnZW5cIik7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi9jb2RlZ2VuL2NvZGVcIik7XG4vLyBUT0RPIHJlZmFjdG9yIHRvIHVzZSBTZXRcbmZ1bmN0aW9uIHRvSGFzaChhcnIpIHtcbiAgICBjb25zdCBoYXNoID0ge307XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGFycilcbiAgICAgICAgaGFzaFtpdGVtXSA9IHRydWU7XG4gICAgcmV0dXJuIGhhc2g7XG59XG5leHBvcnRzLnRvSGFzaCA9IHRvSGFzaDtcbmZ1bmN0aW9uIGFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2hlbWEpIHtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIilcbiAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICBpZiAoT2JqZWN0LmtleXMoc2NoZW1hKS5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGNoZWNrVW5rbm93blJ1bGVzKGl0LCBzY2hlbWEpO1xuICAgIHJldHVybiAhc2NoZW1hSGFzUnVsZXMoc2NoZW1hLCBpdC5zZWxmLlJVTEVTLmFsbCk7XG59XG5leHBvcnRzLmFsd2F5c1ZhbGlkU2NoZW1hID0gYWx3YXlzVmFsaWRTY2hlbWE7XG5mdW5jdGlvbiBjaGVja1Vua25vd25SdWxlcyhpdCwgc2NoZW1hID0gaXQuc2NoZW1hKSB7XG4gICAgY29uc3QgeyBvcHRzLCBzZWxmIH0gPSBpdDtcbiAgICBpZiAoIW9wdHMuc3RyaWN0U2NoZW1hKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT09IFwiYm9vbGVhblwiKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgcnVsZXMgPSBzZWxmLlJVTEVTLmtleXdvcmRzO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSkge1xuICAgICAgICBpZiAoIXJ1bGVzW2tleV0pXG4gICAgICAgICAgICBjaGVja1N0cmljdE1vZGUoaXQsIGB1bmtub3duIGtleXdvcmQ6IFwiJHtrZXl9XCJgKTtcbiAgICB9XG59XG5leHBvcnRzLmNoZWNrVW5rbm93blJ1bGVzID0gY2hlY2tVbmtub3duUnVsZXM7XG5mdW5jdGlvbiBzY2hlbWFIYXNSdWxlcyhzY2hlbWEsIHJ1bGVzKSB7XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpXG4gICAgICAgIHJldHVybiAhc2NoZW1hO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSlcbiAgICAgICAgaWYgKHJ1bGVzW2tleV0pXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLnNjaGVtYUhhc1J1bGVzID0gc2NoZW1hSGFzUnVsZXM7XG5mdW5jdGlvbiBzY2hlbWFIYXNSdWxlc0J1dFJlZihzY2hlbWEsIFJVTEVTKSB7XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpXG4gICAgICAgIHJldHVybiAhc2NoZW1hO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSlcbiAgICAgICAgaWYgKGtleSAhPT0gXCIkcmVmXCIgJiYgUlVMRVMuYWxsW2tleV0pXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLnNjaGVtYUhhc1J1bGVzQnV0UmVmID0gc2NoZW1hSGFzUnVsZXNCdXRSZWY7XG5mdW5jdGlvbiBzY2hlbWFSZWZPclZhbCh7IHRvcFNjaGVtYVJlZiwgc2NoZW1hUGF0aCB9LCBzY2hlbWEsIGtleXdvcmQsICRkYXRhKSB7XG4gICAgaWYgKCEkZGF0YSkge1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcIm51bWJlclwiIHx8IHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpXG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuXykgYCR7c2NoZW1hfWA7XG4gICAgfVxuICAgIHJldHVybiAoMCwgY29kZWdlbl8xLl8pIGAke3RvcFNjaGVtYVJlZn0ke3NjaGVtYVBhdGh9JHsoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KShrZXl3b3JkKX1gO1xufVxuZXhwb3J0cy5zY2hlbWFSZWZPclZhbCA9IHNjaGVtYVJlZk9yVmFsO1xuZnVuY3Rpb24gdW5lc2NhcGVGcmFnbWVudChzdHIpIHtcbiAgICByZXR1cm4gdW5lc2NhcGVKc29uUG9pbnRlcihkZWNvZGVVUklDb21wb25lbnQoc3RyKSk7XG59XG5leHBvcnRzLnVuZXNjYXBlRnJhZ21lbnQgPSB1bmVzY2FwZUZyYWdtZW50O1xuZnVuY3Rpb24gZXNjYXBlRnJhZ21lbnQoc3RyKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChlc2NhcGVKc29uUG9pbnRlcihzdHIpKTtcbn1cbmV4cG9ydHMuZXNjYXBlRnJhZ21lbnQgPSBlc2NhcGVGcmFnbWVudDtcbmZ1bmN0aW9uIGVzY2FwZUpzb25Qb2ludGVyKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyID09IFwibnVtYmVyXCIpXG4gICAgICAgIHJldHVybiBgJHtzdHJ9YDtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL34vZywgXCJ+MFwiKS5yZXBsYWNlKC9cXC8vZywgXCJ+MVwiKTtcbn1cbmV4cG9ydHMuZXNjYXBlSnNvblBvaW50ZXIgPSBlc2NhcGVKc29uUG9pbnRlcjtcbmZ1bmN0aW9uIHVuZXNjYXBlSnNvblBvaW50ZXIoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9+MS9nLCBcIi9cIikucmVwbGFjZSgvfjAvZywgXCJ+XCIpO1xufVxuZXhwb3J0cy51bmVzY2FwZUpzb25Qb2ludGVyID0gdW5lc2NhcGVKc29uUG9pbnRlcjtcbmZ1bmN0aW9uIGVhY2hJdGVtKHhzLCBmKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoeHMpKSB7XG4gICAgICAgIGZvciAoY29uc3QgeCBvZiB4cylcbiAgICAgICAgICAgIGYoeCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmKHhzKTtcbiAgICB9XG59XG5leHBvcnRzLmVhY2hJdGVtID0gZWFjaEl0ZW07XG5mdW5jdGlvbiBtYWtlTWVyZ2VFdmFsdWF0ZWQoeyBtZXJnZU5hbWVzLCBtZXJnZVRvTmFtZSwgbWVyZ2VWYWx1ZXMsIHJlc3VsdFRvTmFtZSwgfSkge1xuICAgIHJldHVybiAoZ2VuLCBmcm9tLCB0bywgdG9OYW1lKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcyA9IHRvID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gZnJvbVxuICAgICAgICAgICAgOiB0byBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lXG4gICAgICAgICAgICAgICAgPyAoZnJvbSBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lID8gbWVyZ2VOYW1lcyhnZW4sIGZyb20sIHRvKSA6IG1lcmdlVG9OYW1lKGdlbiwgZnJvbSwgdG8pLCB0bylcbiAgICAgICAgICAgICAgICA6IGZyb20gaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZVxuICAgICAgICAgICAgICAgICAgICA/IChtZXJnZVRvTmFtZShnZW4sIHRvLCBmcm9tKSwgZnJvbSlcbiAgICAgICAgICAgICAgICAgICAgOiBtZXJnZVZhbHVlcyhmcm9tLCB0byk7XG4gICAgICAgIHJldHVybiB0b05hbWUgPT09IGNvZGVnZW5fMS5OYW1lICYmICEocmVzIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUpID8gcmVzdWx0VG9OYW1lKGdlbiwgcmVzKSA6IHJlcztcbiAgICB9O1xufVxuZXhwb3J0cy5tZXJnZUV2YWx1YXRlZCA9IHtcbiAgICBwcm9wczogbWFrZU1lcmdlRXZhbHVhdGVkKHtcbiAgICAgICAgbWVyZ2VOYW1lczogKGdlbiwgZnJvbSwgdG8pID0+IGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke3RvfSAhPT0gdHJ1ZSAmJiAke2Zyb219ICE9PSB1bmRlZmluZWRgLCAoKSA9PiB7XG4gICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtmcm9tfSA9PT0gdHJ1ZWAsICgpID0+IGdlbi5hc3NpZ24odG8sIHRydWUpLCAoKSA9PiBnZW4uYXNzaWduKHRvLCAoMCwgY29kZWdlbl8xLl8pIGAke3RvfSB8fCB7fWApLmNvZGUoKDAsIGNvZGVnZW5fMS5fKSBgT2JqZWN0LmFzc2lnbigke3RvfSwgJHtmcm9tfSlgKSk7XG4gICAgICAgIH0pLFxuICAgICAgICBtZXJnZVRvTmFtZTogKGdlbiwgZnJvbSwgdG8pID0+IGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke3RvfSAhPT0gdHJ1ZWAsICgpID0+IHtcbiAgICAgICAgICAgIGlmIChmcm9tID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih0bywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHRvLCAoMCwgY29kZWdlbl8xLl8pIGAke3RvfSB8fCB7fWApO1xuICAgICAgICAgICAgICAgIHNldEV2YWx1YXRlZChnZW4sIHRvLCBmcm9tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIG1lcmdlVmFsdWVzOiAoZnJvbSwgdG8pID0+IChmcm9tID09PSB0cnVlID8gdHJ1ZSA6IHsgLi4uZnJvbSwgLi4udG8gfSksXG4gICAgICAgIHJlc3VsdFRvTmFtZTogZXZhbHVhdGVkUHJvcHNUb05hbWUsXG4gICAgfSksXG4gICAgaXRlbXM6IG1ha2VNZXJnZUV2YWx1YXRlZCh7XG4gICAgICAgIG1lcmdlTmFtZXM6IChnZW4sIGZyb20sIHRvKSA9PiBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHt0b30gIT09IHRydWUgJiYgJHtmcm9tfSAhPT0gdW5kZWZpbmVkYCwgKCkgPT4gZ2VuLmFzc2lnbih0bywgKDAsIGNvZGVnZW5fMS5fKSBgJHtmcm9tfSA9PT0gdHJ1ZSA/IHRydWUgOiAke3RvfSA+ICR7ZnJvbX0gPyAke3RvfSA6ICR7ZnJvbX1gKSksXG4gICAgICAgIG1lcmdlVG9OYW1lOiAoZ2VuLCBmcm9tLCB0bykgPT4gZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7dG99ICE9PSB0cnVlYCwgKCkgPT4gZ2VuLmFzc2lnbih0bywgZnJvbSA9PT0gdHJ1ZSA/IHRydWUgOiAoMCwgY29kZWdlbl8xLl8pIGAke3RvfSA+ICR7ZnJvbX0gPyAke3RvfSA6ICR7ZnJvbX1gKSksXG4gICAgICAgIG1lcmdlVmFsdWVzOiAoZnJvbSwgdG8pID0+IChmcm9tID09PSB0cnVlID8gdHJ1ZSA6IE1hdGgubWF4KGZyb20sIHRvKSksXG4gICAgICAgIHJlc3VsdFRvTmFtZTogKGdlbiwgaXRlbXMpID0+IGdlbi52YXIoXCJpdGVtc1wiLCBpdGVtcyksXG4gICAgfSksXG59O1xuZnVuY3Rpb24gZXZhbHVhdGVkUHJvcHNUb05hbWUoZ2VuLCBwcykge1xuICAgIGlmIChwcyA9PT0gdHJ1ZSlcbiAgICAgICAgcmV0dXJuIGdlbi52YXIoXCJwcm9wc1wiLCB0cnVlKTtcbiAgICBjb25zdCBwcm9wcyA9IGdlbi52YXIoXCJwcm9wc1wiLCAoMCwgY29kZWdlbl8xLl8pIGB7fWApO1xuICAgIGlmIChwcyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICBzZXRFdmFsdWF0ZWQoZ2VuLCBwcm9wcywgcHMpO1xuICAgIHJldHVybiBwcm9wcztcbn1cbmV4cG9ydHMuZXZhbHVhdGVkUHJvcHNUb05hbWUgPSBldmFsdWF0ZWRQcm9wc1RvTmFtZTtcbmZ1bmN0aW9uIHNldEV2YWx1YXRlZChnZW4sIHByb3BzLCBwcykge1xuICAgIE9iamVjdC5rZXlzKHBzKS5mb3JFYWNoKChwKSA9PiBnZW4uYXNzaWduKCgwLCBjb2RlZ2VuXzEuXykgYCR7cHJvcHN9JHsoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KShwKX1gLCB0cnVlKSk7XG59XG5leHBvcnRzLnNldEV2YWx1YXRlZCA9IHNldEV2YWx1YXRlZDtcbmNvbnN0IHNuaXBwZXRzID0ge307XG5mdW5jdGlvbiB1c2VGdW5jKGdlbiwgZikge1xuICAgIHJldHVybiBnZW4uc2NvcGVWYWx1ZShcImZ1bmNcIiwge1xuICAgICAgICByZWY6IGYsXG4gICAgICAgIGNvZGU6IHNuaXBwZXRzW2YuY29kZV0gfHwgKHNuaXBwZXRzW2YuY29kZV0gPSBuZXcgY29kZV8xLl9Db2RlKGYuY29kZSkpLFxuICAgIH0pO1xufVxuZXhwb3J0cy51c2VGdW5jID0gdXNlRnVuYztcbnZhciBUeXBlO1xuKGZ1bmN0aW9uIChUeXBlKSB7XG4gICAgVHlwZVtUeXBlW1wiTnVtXCJdID0gMF0gPSBcIk51bVwiO1xuICAgIFR5cGVbVHlwZVtcIlN0clwiXSA9IDFdID0gXCJTdHJcIjtcbn0pKFR5cGUgfHwgKGV4cG9ydHMuVHlwZSA9IFR5cGUgPSB7fSkpO1xuZnVuY3Rpb24gZ2V0RXJyb3JQYXRoKGRhdGFQcm9wLCBkYXRhUHJvcFR5cGUsIGpzUHJvcGVydHlTeW50YXgpIHtcbiAgICAvLyBsZXQgcGF0aFxuICAgIGlmIChkYXRhUHJvcCBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lKSB7XG4gICAgICAgIGNvbnN0IGlzTnVtYmVyID0gZGF0YVByb3BUeXBlID09PSBUeXBlLk51bTtcbiAgICAgICAgcmV0dXJuIGpzUHJvcGVydHlTeW50YXhcbiAgICAgICAgICAgID8gaXNOdW1iZXJcbiAgICAgICAgICAgICAgICA/ICgwLCBjb2RlZ2VuXzEuXykgYFwiW1wiICsgJHtkYXRhUHJvcH0gKyBcIl1cImBcbiAgICAgICAgICAgICAgICA6ICgwLCBjb2RlZ2VuXzEuXykgYFwiWydcIiArICR7ZGF0YVByb3B9ICsgXCInXVwiYFxuICAgICAgICAgICAgOiBpc051bWJlclxuICAgICAgICAgICAgICAgID8gKDAsIGNvZGVnZW5fMS5fKSBgXCIvXCIgKyAke2RhdGFQcm9wfWBcbiAgICAgICAgICAgICAgICA6ICgwLCBjb2RlZ2VuXzEuXykgYFwiL1wiICsgJHtkYXRhUHJvcH0ucmVwbGFjZSgvfi9nLCBcIn4wXCIpLnJlcGxhY2UoL1xcXFwvL2csIFwifjFcIilgOyAvLyBUT0RPIG1heWJlIHVzZSBnbG9iYWwgZXNjYXBlUG9pbnRlclxuICAgIH1cbiAgICByZXR1cm4ganNQcm9wZXJ0eVN5bnRheCA/ICgwLCBjb2RlZ2VuXzEuZ2V0UHJvcGVydHkpKGRhdGFQcm9wKS50b1N0cmluZygpIDogXCIvXCIgKyBlc2NhcGVKc29uUG9pbnRlcihkYXRhUHJvcCk7XG59XG5leHBvcnRzLmdldEVycm9yUGF0aCA9IGdldEVycm9yUGF0aDtcbmZ1bmN0aW9uIGNoZWNrU3RyaWN0TW9kZShpdCwgbXNnLCBtb2RlID0gaXQub3B0cy5zdHJpY3RTY2hlbWEpIHtcbiAgICBpZiAoIW1vZGUpXG4gICAgICAgIHJldHVybjtcbiAgICBtc2cgPSBgc3RyaWN0IG1vZGU6ICR7bXNnfWA7XG4gICAgaWYgKG1vZGUgPT09IHRydWUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIGl0LnNlbGYubG9nZ2VyLndhcm4obXNnKTtcbn1cbmV4cG9ydHMuY2hlY2tTdHJpY3RNb2RlID0gY2hlY2tTdHJpY3RNb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuL2NvZGVnZW5cIik7XG5jb25zdCBuYW1lcyA9IHtcbiAgICAvLyB2YWxpZGF0aW9uIGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgIGRhdGE6IG5ldyBjb2RlZ2VuXzEuTmFtZShcImRhdGFcIiksIC8vIGRhdGEgcGFzc2VkIHRvIHZhbGlkYXRpb24gZnVuY3Rpb25cbiAgICAvLyBhcmdzIHBhc3NlZCBmcm9tIHJlZmVyZW5jaW5nIHNjaGVtYVxuICAgIHZhbEN4dDogbmV3IGNvZGVnZW5fMS5OYW1lKFwidmFsQ3h0XCIpLCAvLyB2YWxpZGF0aW9uL2RhdGEgY29udGV4dCAtIHNob3VsZCBub3QgYmUgdXNlZCBkaXJlY3RseSwgaXQgaXMgZGVzdHJ1Y3R1cmVkIHRvIHRoZSBuYW1lcyBiZWxvd1xuICAgIGluc3RhbmNlUGF0aDogbmV3IGNvZGVnZW5fMS5OYW1lKFwiaW5zdGFuY2VQYXRoXCIpLFxuICAgIHBhcmVudERhdGE6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInBhcmVudERhdGFcIiksXG4gICAgcGFyZW50RGF0YVByb3BlcnR5OiBuZXcgY29kZWdlbl8xLk5hbWUoXCJwYXJlbnREYXRhUHJvcGVydHlcIiksXG4gICAgcm9vdERhdGE6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInJvb3REYXRhXCIpLCAvLyByb290IGRhdGEgLSBzYW1lIGFzIHRoZSBkYXRhIHBhc3NlZCB0byB0aGUgZmlyc3QvdG9wIHZhbGlkYXRpb24gZnVuY3Rpb25cbiAgICBkeW5hbWljQW5jaG9yczogbmV3IGNvZGVnZW5fMS5OYW1lKFwiZHluYW1pY0FuY2hvcnNcIiksIC8vIHVzZWQgdG8gc3VwcG9ydCByZWN1cnNpdmVSZWYgYW5kIGR5bmFtaWNSZWZcbiAgICAvLyBmdW5jdGlvbiBzY29wZWQgdmFyaWFibGVzXG4gICAgdkVycm9yczogbmV3IGNvZGVnZW5fMS5OYW1lKFwidkVycm9yc1wiKSwgLy8gbnVsbCBvciBhcnJheSBvZiB2YWxpZGF0aW9uIGVycm9yc1xuICAgIGVycm9yczogbmV3IGNvZGVnZW5fMS5OYW1lKFwiZXJyb3JzXCIpLCAvLyBjb3VudGVyIG9mIHZhbGlkYXRpb24gZXJyb3JzXG4gICAgdGhpczogbmV3IGNvZGVnZW5fMS5OYW1lKFwidGhpc1wiKSxcbiAgICAvLyBcImdsb2JhbHNcIlxuICAgIHNlbGY6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInNlbGZcIiksXG4gICAgc2NvcGU6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInNjb3BlXCIpLFxuICAgIC8vIEpURCBzZXJpYWxpemUvcGFyc2UgbmFtZSBmb3IgSlNPTiBzdHJpbmcgYW5kIHBvc2l0aW9uXG4gICAganNvbjogbmV3IGNvZGVnZW5fMS5OYW1lKFwianNvblwiKSxcbiAgICBqc29uUG9zOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJqc29uUG9zXCIpLFxuICAgIGpzb25MZW46IG5ldyBjb2RlZ2VuXzEuTmFtZShcImpzb25MZW5cIiksXG4gICAganNvblBhcnQ6IG5ldyBjb2RlZ2VuXzEuTmFtZShcImpzb25QYXJ0XCIpLFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IG5hbWVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmFtZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmV4dGVuZEVycm9ycyA9IGV4cG9ydHMucmVzZXRFcnJvcnNDb3VudCA9IGV4cG9ydHMucmVwb3J0RXh0cmFFcnJvciA9IGV4cG9ydHMucmVwb3J0RXJyb3IgPSBleHBvcnRzLmtleXdvcmQkRGF0YUVycm9yID0gZXhwb3J0cy5rZXl3b3JkRXJyb3IgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbmNvbnN0IG5hbWVzXzEgPSByZXF1aXJlKFwiLi9uYW1lc1wiKTtcbmV4cG9ydHMua2V5d29yZEVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IGtleXdvcmQgfSkgPT4gKDAsIGNvZGVnZW5fMS5zdHIpIGBtdXN0IHBhc3MgXCIke2tleXdvcmR9XCIga2V5d29yZCB2YWxpZGF0aW9uYCxcbn07XG5leHBvcnRzLmtleXdvcmQkRGF0YUVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IGtleXdvcmQsIHNjaGVtYVR5cGUgfSkgPT4gc2NoZW1hVHlwZVxuICAgICAgICA/ICgwLCBjb2RlZ2VuXzEuc3RyKSBgXCIke2tleXdvcmR9XCIga2V5d29yZCBtdXN0IGJlICR7c2NoZW1hVHlwZX0gKCRkYXRhKWBcbiAgICAgICAgOiAoMCwgY29kZWdlbl8xLnN0cikgYFwiJHtrZXl3b3JkfVwiIGtleXdvcmQgaXMgaW52YWxpZCAoJGRhdGEpYCxcbn07XG5mdW5jdGlvbiByZXBvcnRFcnJvcihjeHQsIGVycm9yID0gZXhwb3J0cy5rZXl3b3JkRXJyb3IsIGVycm9yUGF0aHMsIG92ZXJyaWRlQWxsRXJyb3JzKSB7XG4gICAgY29uc3QgeyBpdCB9ID0gY3h0O1xuICAgIGNvbnN0IHsgZ2VuLCBjb21wb3NpdGVSdWxlLCBhbGxFcnJvcnMgfSA9IGl0O1xuICAgIGNvbnN0IGVyck9iaiA9IGVycm9yT2JqZWN0Q29kZShjeHQsIGVycm9yLCBlcnJvclBhdGhzKTtcbiAgICBpZiAob3ZlcnJpZGVBbGxFcnJvcnMgIT09IG51bGwgJiYgb3ZlcnJpZGVBbGxFcnJvcnMgIT09IHZvaWQgMCA/IG92ZXJyaWRlQWxsRXJyb3JzIDogKGNvbXBvc2l0ZVJ1bGUgfHwgYWxsRXJyb3JzKSkge1xuICAgICAgICBhZGRFcnJvcihnZW4sIGVyck9iaik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm5FcnJvcnMoaXQsICgwLCBjb2RlZ2VuXzEuXykgYFske2Vyck9ian1dYCk7XG4gICAgfVxufVxuZXhwb3J0cy5yZXBvcnRFcnJvciA9IHJlcG9ydEVycm9yO1xuZnVuY3Rpb24gcmVwb3J0RXh0cmFFcnJvcihjeHQsIGVycm9yID0gZXhwb3J0cy5rZXl3b3JkRXJyb3IsIGVycm9yUGF0aHMpIHtcbiAgICBjb25zdCB7IGl0IH0gPSBjeHQ7XG4gICAgY29uc3QgeyBnZW4sIGNvbXBvc2l0ZVJ1bGUsIGFsbEVycm9ycyB9ID0gaXQ7XG4gICAgY29uc3QgZXJyT2JqID0gZXJyb3JPYmplY3RDb2RlKGN4dCwgZXJyb3IsIGVycm9yUGF0aHMpO1xuICAgIGFkZEVycm9yKGdlbiwgZXJyT2JqKTtcbiAgICBpZiAoIShjb21wb3NpdGVSdWxlIHx8IGFsbEVycm9ycykpIHtcbiAgICAgICAgcmV0dXJuRXJyb3JzKGl0LCBuYW1lc18xLmRlZmF1bHQudkVycm9ycyk7XG4gICAgfVxufVxuZXhwb3J0cy5yZXBvcnRFeHRyYUVycm9yID0gcmVwb3J0RXh0cmFFcnJvcjtcbmZ1bmN0aW9uIHJlc2V0RXJyb3JzQ291bnQoZ2VuLCBlcnJzQ291bnQpIHtcbiAgICBnZW4uYXNzaWduKG5hbWVzXzEuZGVmYXVsdC5lcnJvcnMsIGVycnNDb3VudCk7XG4gICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9ICE9PSBudWxsYCwgKCkgPT4gZ2VuLmlmKGVycnNDb3VudCwgKCkgPT4gZ2VuLmFzc2lnbigoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfS5sZW5ndGhgLCBlcnJzQ291bnQpLCAoKSA9PiBnZW4uYXNzaWduKG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzLCBudWxsKSkpO1xufVxuZXhwb3J0cy5yZXNldEVycm9yc0NvdW50ID0gcmVzZXRFcnJvcnNDb3VudDtcbmZ1bmN0aW9uIGV4dGVuZEVycm9ycyh7IGdlbiwga2V5d29yZCwgc2NoZW1hVmFsdWUsIGRhdGEsIGVycnNDb3VudCwgaXQsIH0pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoZXJyc0NvdW50ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImFqdiBpbXBsZW1lbnRhdGlvbiBlcnJvclwiKTtcbiAgICBjb25zdCBlcnIgPSBnZW4ubmFtZShcImVyclwiKTtcbiAgICBnZW4uZm9yUmFuZ2UoXCJpXCIsIGVycnNDb3VudCwgbmFtZXNfMS5kZWZhdWx0LmVycm9ycywgKGkpID0+IHtcbiAgICAgICAgZ2VuLmNvbnN0KGVyciwgKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc31bJHtpfV1gKTtcbiAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZXJyfS5pbnN0YW5jZVBhdGggPT09IHVuZGVmaW5lZGAsICgpID0+IGdlbi5hc3NpZ24oKDAsIGNvZGVnZW5fMS5fKSBgJHtlcnJ9Lmluc3RhbmNlUGF0aGAsICgwLCBjb2RlZ2VuXzEuc3RyQ29uY2F0KShuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRoLCBpdC5lcnJvclBhdGgpKSk7XG4gICAgICAgIGdlbi5hc3NpZ24oKDAsIGNvZGVnZW5fMS5fKSBgJHtlcnJ9LnNjaGVtYVBhdGhgLCAoMCwgY29kZWdlbl8xLnN0cikgYCR7aXQuZXJyU2NoZW1hUGF0aH0vJHtrZXl3b3JkfWApO1xuICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgICAgICBnZW4uYXNzaWduKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZXJyfS5zY2hlbWFgLCBzY2hlbWFWYWx1ZSk7XG4gICAgICAgICAgICBnZW4uYXNzaWduKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZXJyfS5kYXRhYCwgZGF0YSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuZXh0ZW5kRXJyb3JzID0gZXh0ZW5kRXJyb3JzO1xuZnVuY3Rpb24gYWRkRXJyb3IoZ2VuLCBlcnJPYmopIHtcbiAgICBjb25zdCBlcnIgPSBnZW4uY29uc3QoXCJlcnJcIiwgZXJyT2JqKTtcbiAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30gPT09IG51bGxgLCAoKSA9PiBnZW4uYXNzaWduKG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzLCAoMCwgY29kZWdlbl8xLl8pIGBbJHtlcnJ9XWApLCAoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfS5wdXNoKCR7ZXJyfSlgKTtcbiAgICBnZW4uY29kZSgoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC5lcnJvcnN9KytgKTtcbn1cbmZ1bmN0aW9uIHJldHVybkVycm9ycyhpdCwgZXJycykge1xuICAgIGNvbnN0IHsgZ2VuLCB2YWxpZGF0ZU5hbWUsIHNjaGVtYUVudiB9ID0gaXQ7XG4gICAgaWYgKHNjaGVtYUVudi4kYXN5bmMpIHtcbiAgICAgICAgZ2VuLnRocm93KCgwLCBjb2RlZ2VuXzEuXykgYG5ldyAke2l0LlZhbGlkYXRpb25FcnJvcn0oJHtlcnJzfSlgKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdlbi5hc3NpZ24oKDAsIGNvZGVnZW5fMS5fKSBgJHt2YWxpZGF0ZU5hbWV9LmVycm9yc2AsIGVycnMpO1xuICAgICAgICBnZW4ucmV0dXJuKGZhbHNlKTtcbiAgICB9XG59XG5jb25zdCBFID0ge1xuICAgIGtleXdvcmQ6IG5ldyBjb2RlZ2VuXzEuTmFtZShcImtleXdvcmRcIiksXG4gICAgc2NoZW1hUGF0aDogbmV3IGNvZGVnZW5fMS5OYW1lKFwic2NoZW1hUGF0aFwiKSwgLy8gYWxzbyB1c2VkIGluIEpURCBlcnJvcnNcbiAgICBwYXJhbXM6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInBhcmFtc1wiKSxcbiAgICBwcm9wZXJ0eU5hbWU6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInByb3BlcnR5TmFtZVwiKSxcbiAgICBtZXNzYWdlOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJtZXNzYWdlXCIpLFxuICAgIHNjaGVtYTogbmV3IGNvZGVnZW5fMS5OYW1lKFwic2NoZW1hXCIpLFxuICAgIHBhcmVudFNjaGVtYTogbmV3IGNvZGVnZW5fMS5OYW1lKFwicGFyZW50U2NoZW1hXCIpLFxufTtcbmZ1bmN0aW9uIGVycm9yT2JqZWN0Q29kZShjeHQsIGVycm9yLCBlcnJvclBhdGhzKSB7XG4gICAgY29uc3QgeyBjcmVhdGVFcnJvcnMgfSA9IGN4dC5pdDtcbiAgICBpZiAoY3JlYXRlRXJyb3JzID09PSBmYWxzZSlcbiAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuXykgYHt9YDtcbiAgICByZXR1cm4gZXJyb3JPYmplY3QoY3h0LCBlcnJvciwgZXJyb3JQYXRocyk7XG59XG5mdW5jdGlvbiBlcnJvck9iamVjdChjeHQsIGVycm9yLCBlcnJvclBhdGhzID0ge30pIHtcbiAgICBjb25zdCB7IGdlbiwgaXQgfSA9IGN4dDtcbiAgICBjb25zdCBrZXlWYWx1ZXMgPSBbXG4gICAgICAgIGVycm9ySW5zdGFuY2VQYXRoKGl0LCBlcnJvclBhdGhzKSxcbiAgICAgICAgZXJyb3JTY2hlbWFQYXRoKGN4dCwgZXJyb3JQYXRocyksXG4gICAgXTtcbiAgICBleHRyYUVycm9yUHJvcHMoY3h0LCBlcnJvciwga2V5VmFsdWVzKTtcbiAgICByZXR1cm4gZ2VuLm9iamVjdCguLi5rZXlWYWx1ZXMpO1xufVxuZnVuY3Rpb24gZXJyb3JJbnN0YW5jZVBhdGgoeyBlcnJvclBhdGggfSwgeyBpbnN0YW5jZVBhdGggfSkge1xuICAgIGNvbnN0IGluc3RQYXRoID0gaW5zdGFuY2VQYXRoXG4gICAgICAgID8gKDAsIGNvZGVnZW5fMS5zdHIpIGAke2Vycm9yUGF0aH0keygwLCB1dGlsXzEuZ2V0RXJyb3JQYXRoKShpbnN0YW5jZVBhdGgsIHV0aWxfMS5UeXBlLlN0cil9YFxuICAgICAgICA6IGVycm9yUGF0aDtcbiAgICByZXR1cm4gW25hbWVzXzEuZGVmYXVsdC5pbnN0YW5jZVBhdGgsICgwLCBjb2RlZ2VuXzEuc3RyQ29uY2F0KShuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRoLCBpbnN0UGF0aCldO1xufVxuZnVuY3Rpb24gZXJyb3JTY2hlbWFQYXRoKHsga2V5d29yZCwgaXQ6IHsgZXJyU2NoZW1hUGF0aCB9IH0sIHsgc2NoZW1hUGF0aCwgcGFyZW50U2NoZW1hIH0pIHtcbiAgICBsZXQgc2NoUGF0aCA9IHBhcmVudFNjaGVtYSA/IGVyclNjaGVtYVBhdGggOiAoMCwgY29kZWdlbl8xLnN0cikgYCR7ZXJyU2NoZW1hUGF0aH0vJHtrZXl3b3JkfWA7XG4gICAgaWYgKHNjaGVtYVBhdGgpIHtcbiAgICAgICAgc2NoUGF0aCA9ICgwLCBjb2RlZ2VuXzEuc3RyKSBgJHtzY2hQYXRofSR7KDAsIHV0aWxfMS5nZXRFcnJvclBhdGgpKHNjaGVtYVBhdGgsIHV0aWxfMS5UeXBlLlN0cil9YDtcbiAgICB9XG4gICAgcmV0dXJuIFtFLnNjaGVtYVBhdGgsIHNjaFBhdGhdO1xufVxuZnVuY3Rpb24gZXh0cmFFcnJvclByb3BzKGN4dCwgeyBwYXJhbXMsIG1lc3NhZ2UgfSwga2V5VmFsdWVzKSB7XG4gICAgY29uc3QgeyBrZXl3b3JkLCBkYXRhLCBzY2hlbWFWYWx1ZSwgaXQgfSA9IGN4dDtcbiAgICBjb25zdCB7IG9wdHMsIHByb3BlcnR5TmFtZSwgdG9wU2NoZW1hUmVmLCBzY2hlbWFQYXRoIH0gPSBpdDtcbiAgICBrZXlWYWx1ZXMucHVzaChbRS5rZXl3b3JkLCBrZXl3b3JkXSwgW0UucGFyYW1zLCB0eXBlb2YgcGFyYW1zID09IFwiZnVuY3Rpb25cIiA/IHBhcmFtcyhjeHQpIDogcGFyYW1zIHx8ICgwLCBjb2RlZ2VuXzEuXykgYHt9YF0pO1xuICAgIGlmIChvcHRzLm1lc3NhZ2VzKSB7XG4gICAgICAgIGtleVZhbHVlcy5wdXNoKFtFLm1lc3NhZ2UsIHR5cGVvZiBtZXNzYWdlID09IFwiZnVuY3Rpb25cIiA/IG1lc3NhZ2UoY3h0KSA6IG1lc3NhZ2VdKTtcbiAgICB9XG4gICAgaWYgKG9wdHMudmVyYm9zZSkge1xuICAgICAgICBrZXlWYWx1ZXMucHVzaChbRS5zY2hlbWEsIHNjaGVtYVZhbHVlXSwgW0UucGFyZW50U2NoZW1hLCAoMCwgY29kZWdlbl8xLl8pIGAke3RvcFNjaGVtYVJlZn0ke3NjaGVtYVBhdGh9YF0sIFtuYW1lc18xLmRlZmF1bHQuZGF0YSwgZGF0YV0pO1xuICAgIH1cbiAgICBpZiAocHJvcGVydHlOYW1lKVxuICAgICAgICBrZXlWYWx1ZXMucHVzaChbRS5wcm9wZXJ0eU5hbWUsIHByb3BlcnR5TmFtZV0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ib29sT3JFbXB0eVNjaGVtYSA9IGV4cG9ydHMudG9wQm9vbE9yRW1wdHlTY2hlbWEgPSB2b2lkIDA7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuLi9lcnJvcnNcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vY29kZWdlblwiKTtcbmNvbnN0IG5hbWVzXzEgPSByZXF1aXJlKFwiLi4vbmFtZXNcIik7XG5jb25zdCBib29sRXJyb3IgPSB7XG4gICAgbWVzc2FnZTogXCJib29sZWFuIHNjaGVtYSBpcyBmYWxzZVwiLFxufTtcbmZ1bmN0aW9uIHRvcEJvb2xPckVtcHR5U2NoZW1hKGl0KSB7XG4gICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgdmFsaWRhdGVOYW1lIH0gPSBpdDtcbiAgICBpZiAoc2NoZW1hID09PSBmYWxzZSkge1xuICAgICAgICBmYWxzZVNjaGVtYUVycm9yKGl0LCBmYWxzZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIiAmJiBzY2hlbWEuJGFzeW5jID09PSB0cnVlKSB7XG4gICAgICAgIGdlbi5yZXR1cm4obmFtZXNfMS5kZWZhdWx0LmRhdGEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2VuLmFzc2lnbigoMCwgY29kZWdlbl8xLl8pIGAke3ZhbGlkYXRlTmFtZX0uZXJyb3JzYCwgbnVsbCk7XG4gICAgICAgIGdlbi5yZXR1cm4odHJ1ZSk7XG4gICAgfVxufVxuZXhwb3J0cy50b3BCb29sT3JFbXB0eVNjaGVtYSA9IHRvcEJvb2xPckVtcHR5U2NoZW1hO1xuZnVuY3Rpb24gYm9vbE9yRW1wdHlTY2hlbWEoaXQsIHZhbGlkKSB7XG4gICAgY29uc3QgeyBnZW4sIHNjaGVtYSB9ID0gaXQ7XG4gICAgaWYgKHNjaGVtYSA9PT0gZmFsc2UpIHtcbiAgICAgICAgZ2VuLnZhcih2YWxpZCwgZmFsc2UpOyAvLyBUT0RPIHZhclxuICAgICAgICBmYWxzZVNjaGVtYUVycm9yKGl0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdlbi52YXIodmFsaWQsIHRydWUpOyAvLyBUT0RPIHZhclxuICAgIH1cbn1cbmV4cG9ydHMuYm9vbE9yRW1wdHlTY2hlbWEgPSBib29sT3JFbXB0eVNjaGVtYTtcbmZ1bmN0aW9uIGZhbHNlU2NoZW1hRXJyb3IoaXQsIG92ZXJyaWRlQWxsRXJyb3JzKSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEgfSA9IGl0O1xuICAgIC8vIFRPRE8gbWF5YmUgc29tZSBvdGhlciBpbnRlcmZhY2Ugc2hvdWxkIGJlIHVzZWQgZm9yIG5vbi1rZXl3b3JkIHZhbGlkYXRpb24gZXJyb3JzLi4uXG4gICAgY29uc3QgY3h0ID0ge1xuICAgICAgICBnZW4sXG4gICAgICAgIGtleXdvcmQ6IFwiZmFsc2Ugc2NoZW1hXCIsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIHNjaGVtYTogZmFsc2UsXG4gICAgICAgIHNjaGVtYUNvZGU6IGZhbHNlLFxuICAgICAgICBzY2hlbWFWYWx1ZTogZmFsc2UsXG4gICAgICAgIHBhcmFtczoge30sXG4gICAgICAgIGl0LFxuICAgIH07XG4gICAgKDAsIGVycm9yc18xLnJlcG9ydEVycm9yKShjeHQsIGJvb2xFcnJvciwgdW5kZWZpbmVkLCBvdmVycmlkZUFsbEVycm9ycyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ib29sU2NoZW1hLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRSdWxlcyA9IGV4cG9ydHMuaXNKU09OVHlwZSA9IHZvaWQgMDtcbmNvbnN0IF9qc29uVHlwZXMgPSBbXCJzdHJpbmdcIiwgXCJudW1iZXJcIiwgXCJpbnRlZ2VyXCIsIFwiYm9vbGVhblwiLCBcIm51bGxcIiwgXCJvYmplY3RcIiwgXCJhcnJheVwiXTtcbmNvbnN0IGpzb25UeXBlcyA9IG5ldyBTZXQoX2pzb25UeXBlcyk7XG5mdW5jdGlvbiBpc0pTT05UeXBlKHgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHggPT0gXCJzdHJpbmdcIiAmJiBqc29uVHlwZXMuaGFzKHgpO1xufVxuZXhwb3J0cy5pc0pTT05UeXBlID0gaXNKU09OVHlwZTtcbmZ1bmN0aW9uIGdldFJ1bGVzKCkge1xuICAgIGNvbnN0IGdyb3VwcyA9IHtcbiAgICAgICAgbnVtYmVyOiB7IHR5cGU6IFwibnVtYmVyXCIsIHJ1bGVzOiBbXSB9LFxuICAgICAgICBzdHJpbmc6IHsgdHlwZTogXCJzdHJpbmdcIiwgcnVsZXM6IFtdIH0sXG4gICAgICAgIGFycmF5OiB7IHR5cGU6IFwiYXJyYXlcIiwgcnVsZXM6IFtdIH0sXG4gICAgICAgIG9iamVjdDogeyB0eXBlOiBcIm9iamVjdFwiLCBydWxlczogW10gfSxcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGVzOiB7IC4uLmdyb3VwcywgaW50ZWdlcjogdHJ1ZSwgYm9vbGVhbjogdHJ1ZSwgbnVsbDogdHJ1ZSB9LFxuICAgICAgICBydWxlczogW3sgcnVsZXM6IFtdIH0sIGdyb3Vwcy5udW1iZXIsIGdyb3Vwcy5zdHJpbmcsIGdyb3Vwcy5hcnJheSwgZ3JvdXBzLm9iamVjdF0sXG4gICAgICAgIHBvc3Q6IHsgcnVsZXM6IFtdIH0sXG4gICAgICAgIGFsbDoge30sXG4gICAgICAgIGtleXdvcmRzOiB7fSxcbiAgICB9O1xufVxuZXhwb3J0cy5nZXRSdWxlcyA9IGdldFJ1bGVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cnVsZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNob3VsZFVzZVJ1bGUgPSBleHBvcnRzLnNob3VsZFVzZUdyb3VwID0gZXhwb3J0cy5zY2hlbWFIYXNSdWxlc0ZvclR5cGUgPSB2b2lkIDA7XG5mdW5jdGlvbiBzY2hlbWFIYXNSdWxlc0ZvclR5cGUoeyBzY2hlbWEsIHNlbGYgfSwgdHlwZSkge1xuICAgIGNvbnN0IGdyb3VwID0gc2VsZi5SVUxFUy50eXBlc1t0eXBlXTtcbiAgICByZXR1cm4gZ3JvdXAgJiYgZ3JvdXAgIT09IHRydWUgJiYgc2hvdWxkVXNlR3JvdXAoc2NoZW1hLCBncm91cCk7XG59XG5leHBvcnRzLnNjaGVtYUhhc1J1bGVzRm9yVHlwZSA9IHNjaGVtYUhhc1J1bGVzRm9yVHlwZTtcbmZ1bmN0aW9uIHNob3VsZFVzZUdyb3VwKHNjaGVtYSwgZ3JvdXApIHtcbiAgICByZXR1cm4gZ3JvdXAucnVsZXMuc29tZSgocnVsZSkgPT4gc2hvdWxkVXNlUnVsZShzY2hlbWEsIHJ1bGUpKTtcbn1cbmV4cG9ydHMuc2hvdWxkVXNlR3JvdXAgPSBzaG91bGRVc2VHcm91cDtcbmZ1bmN0aW9uIHNob3VsZFVzZVJ1bGUoc2NoZW1hLCBydWxlKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoc2NoZW1hW3J1bGUua2V5d29yZF0gIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAoKF9hID0gcnVsZS5kZWZpbml0aW9uLmltcGxlbWVudHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zb21lKChrd2QpID0+IHNjaGVtYVtrd2RdICE9PSB1bmRlZmluZWQpKSk7XG59XG5leHBvcnRzLnNob3VsZFVzZVJ1bGUgPSBzaG91bGRVc2VSdWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwbGljYWJpbGl0eS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVwb3J0VHlwZUVycm9yID0gZXhwb3J0cy5jaGVja0RhdGFUeXBlcyA9IGV4cG9ydHMuY2hlY2tEYXRhVHlwZSA9IGV4cG9ydHMuY29lcmNlQW5kQ2hlY2tEYXRhVHlwZSA9IGV4cG9ydHMuZ2V0SlNPTlR5cGVzID0gZXhwb3J0cy5nZXRTY2hlbWFUeXBlcyA9IGV4cG9ydHMuRGF0YVR5cGUgPSB2b2lkIDA7XG5jb25zdCBydWxlc18xID0gcmVxdWlyZShcIi4uL3J1bGVzXCIpO1xuY29uc3QgYXBwbGljYWJpbGl0eV8xID0gcmVxdWlyZShcIi4vYXBwbGljYWJpbGl0eVwiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgRGF0YVR5cGU7XG4oZnVuY3Rpb24gKERhdGFUeXBlKSB7XG4gICAgRGF0YVR5cGVbRGF0YVR5cGVbXCJDb3JyZWN0XCJdID0gMF0gPSBcIkNvcnJlY3RcIjtcbiAgICBEYXRhVHlwZVtEYXRhVHlwZVtcIldyb25nXCJdID0gMV0gPSBcIldyb25nXCI7XG59KShEYXRhVHlwZSB8fCAoZXhwb3J0cy5EYXRhVHlwZSA9IERhdGFUeXBlID0ge30pKTtcbmZ1bmN0aW9uIGdldFNjaGVtYVR5cGVzKHNjaGVtYSkge1xuICAgIGNvbnN0IHR5cGVzID0gZ2V0SlNPTlR5cGVzKHNjaGVtYS50eXBlKTtcbiAgICBjb25zdCBoYXNOdWxsID0gdHlwZXMuaW5jbHVkZXMoXCJudWxsXCIpO1xuICAgIGlmIChoYXNOdWxsKSB7XG4gICAgICAgIGlmIChzY2hlbWEubnVsbGFibGUgPT09IGZhbHNlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHlwZTogbnVsbCBjb250cmFkaWN0cyBudWxsYWJsZTogZmFsc2VcIik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoIXR5cGVzLmxlbmd0aCAmJiBzY2hlbWEubnVsbGFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIm51bGxhYmxlXCIgY2Fubm90IGJlIHVzZWQgd2l0aG91dCBcInR5cGVcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWEubnVsbGFibGUgPT09IHRydWUpXG4gICAgICAgICAgICB0eXBlcy5wdXNoKFwibnVsbFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVzO1xufVxuZXhwb3J0cy5nZXRTY2hlbWFUeXBlcyA9IGdldFNjaGVtYVR5cGVzO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZWR1bmRhbnQtdHlwZS1jb25zdGl0dWVudHNcbmZ1bmN0aW9uIGdldEpTT05UeXBlcyh0cykge1xuICAgIGNvbnN0IHR5cGVzID0gQXJyYXkuaXNBcnJheSh0cykgPyB0cyA6IHRzID8gW3RzXSA6IFtdO1xuICAgIGlmICh0eXBlcy5ldmVyeShydWxlc18xLmlzSlNPTlR5cGUpKVxuICAgICAgICByZXR1cm4gdHlwZXM7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidHlwZSBtdXN0IGJlIEpTT05UeXBlIG9yIEpTT05UeXBlW106IFwiICsgdHlwZXMuam9pbihcIixcIikpO1xufVxuZXhwb3J0cy5nZXRKU09OVHlwZXMgPSBnZXRKU09OVHlwZXM7XG5mdW5jdGlvbiBjb2VyY2VBbmRDaGVja0RhdGFUeXBlKGl0LCB0eXBlcykge1xuICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBvcHRzIH0gPSBpdDtcbiAgICBjb25zdCBjb2VyY2VUbyA9IGNvZXJjZVRvVHlwZXModHlwZXMsIG9wdHMuY29lcmNlVHlwZXMpO1xuICAgIGNvbnN0IGNoZWNrVHlwZXMgPSB0eXBlcy5sZW5ndGggPiAwICYmXG4gICAgICAgICEoY29lcmNlVG8ubGVuZ3RoID09PSAwICYmIHR5cGVzLmxlbmd0aCA9PT0gMSAmJiAoMCwgYXBwbGljYWJpbGl0eV8xLnNjaGVtYUhhc1J1bGVzRm9yVHlwZSkoaXQsIHR5cGVzWzBdKSk7XG4gICAgaWYgKGNoZWNrVHlwZXMpIHtcbiAgICAgICAgY29uc3Qgd3JvbmdUeXBlID0gY2hlY2tEYXRhVHlwZXModHlwZXMsIGRhdGEsIG9wdHMuc3RyaWN0TnVtYmVycywgRGF0YVR5cGUuV3JvbmcpO1xuICAgICAgICBnZW4uaWYod3JvbmdUeXBlLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoY29lcmNlVG8ubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGNvZXJjZURhdGEoaXQsIHR5cGVzLCBjb2VyY2VUbyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmVwb3J0VHlwZUVycm9yKGl0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjaGVja1R5cGVzO1xufVxuZXhwb3J0cy5jb2VyY2VBbmRDaGVja0RhdGFUeXBlID0gY29lcmNlQW5kQ2hlY2tEYXRhVHlwZTtcbmNvbnN0IENPRVJDSUJMRSA9IG5ldyBTZXQoW1wic3RyaW5nXCIsIFwibnVtYmVyXCIsIFwiaW50ZWdlclwiLCBcImJvb2xlYW5cIiwgXCJudWxsXCJdKTtcbmZ1bmN0aW9uIGNvZXJjZVRvVHlwZXModHlwZXMsIGNvZXJjZVR5cGVzKSB7XG4gICAgcmV0dXJuIGNvZXJjZVR5cGVzXG4gICAgICAgID8gdHlwZXMuZmlsdGVyKCh0KSA9PiBDT0VSQ0lCTEUuaGFzKHQpIHx8IChjb2VyY2VUeXBlcyA9PT0gXCJhcnJheVwiICYmIHQgPT09IFwiYXJyYXlcIikpXG4gICAgICAgIDogW107XG59XG5mdW5jdGlvbiBjb2VyY2VEYXRhKGl0LCB0eXBlcywgY29lcmNlVG8pIHtcbiAgICBjb25zdCB7IGdlbiwgZGF0YSwgb3B0cyB9ID0gaXQ7XG4gICAgY29uc3QgZGF0YVR5cGUgPSBnZW4ubGV0KFwiZGF0YVR5cGVcIiwgKDAsIGNvZGVnZW5fMS5fKSBgdHlwZW9mICR7ZGF0YX1gKTtcbiAgICBjb25zdCBjb2VyY2VkID0gZ2VuLmxldChcImNvZXJjZWRcIiwgKDAsIGNvZGVnZW5fMS5fKSBgdW5kZWZpbmVkYCk7XG4gICAgaWYgKG9wdHMuY29lcmNlVHlwZXMgPT09IFwiYXJyYXlcIikge1xuICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhVHlwZX0gPT0gJ29iamVjdCcgJiYgQXJyYXkuaXNBcnJheSgke2RhdGF9KSAmJiAke2RhdGF9Lmxlbmd0aCA9PSAxYCwgKCkgPT4gZ2VuXG4gICAgICAgICAgICAuYXNzaWduKGRhdGEsICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX1bMF1gKVxuICAgICAgICAgICAgLmFzc2lnbihkYXRhVHlwZSwgKDAsIGNvZGVnZW5fMS5fKSBgdHlwZW9mICR7ZGF0YX1gKVxuICAgICAgICAgICAgLmlmKGNoZWNrRGF0YVR5cGVzKHR5cGVzLCBkYXRhLCBvcHRzLnN0cmljdE51bWJlcnMpLCAoKSA9PiBnZW4uYXNzaWduKGNvZXJjZWQsIGRhdGEpKSk7XG4gICAgfVxuICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke2NvZXJjZWR9ICE9PSB1bmRlZmluZWRgKTtcbiAgICBmb3IgKGNvbnN0IHQgb2YgY29lcmNlVG8pIHtcbiAgICAgICAgaWYgKENPRVJDSUJMRS5oYXModCkgfHwgKHQgPT09IFwiYXJyYXlcIiAmJiBvcHRzLmNvZXJjZVR5cGVzID09PSBcImFycmF5XCIpKSB7XG4gICAgICAgICAgICBjb2VyY2VTcGVjaWZpY1R5cGUodCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2VuLmVsc2UoKTtcbiAgICByZXBvcnRUeXBlRXJyb3IoaXQpO1xuICAgIGdlbi5lbmRJZigpO1xuICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke2NvZXJjZWR9ICE9PSB1bmRlZmluZWRgLCAoKSA9PiB7XG4gICAgICAgIGdlbi5hc3NpZ24oZGF0YSwgY29lcmNlZCk7XG4gICAgICAgIGFzc2lnblBhcmVudERhdGEoaXQsIGNvZXJjZWQpO1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGNvZXJjZVNwZWNpZmljVHlwZSh0KSB7XG4gICAgICAgIHN3aXRjaCAodCkge1xuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgICAgICAgICAuZWxzZUlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YVR5cGV9ID09IFwibnVtYmVyXCIgfHwgJHtkYXRhVHlwZX0gPT0gXCJib29sZWFuXCJgKVxuICAgICAgICAgICAgICAgICAgICAuYXNzaWduKGNvZXJjZWQsICgwLCBjb2RlZ2VuXzEuXykgYFwiXCIgKyAke2RhdGF9YClcbiAgICAgICAgICAgICAgICAgICAgLmVsc2VJZigoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9ID09PSBudWxsYClcbiAgICAgICAgICAgICAgICAgICAgLmFzc2lnbihjb2VyY2VkLCAoMCwgY29kZWdlbl8xLl8pIGBcIlwiYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgICAgICAgICAuZWxzZUlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YVR5cGV9ID09IFwiYm9vbGVhblwiIHx8ICR7ZGF0YX0gPT09IG51bGxcbiAgICAgICAgICAgICAgfHwgKCR7ZGF0YVR5cGV9ID09IFwic3RyaW5nXCIgJiYgJHtkYXRhfSAmJiAke2RhdGF9ID09ICske2RhdGF9KWApXG4gICAgICAgICAgICAgICAgICAgIC5hc3NpZ24oY29lcmNlZCwgKDAsIGNvZGVnZW5fMS5fKSBgKyR7ZGF0YX1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIFwiaW50ZWdlclwiOlxuICAgICAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgICAgICAgICAuZWxzZUlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YVR5cGV9ID09PSBcImJvb2xlYW5cIiB8fCAke2RhdGF9ID09PSBudWxsXG4gICAgICAgICAgICAgIHx8ICgke2RhdGFUeXBlfSA9PT0gXCJzdHJpbmdcIiAmJiAke2RhdGF9ICYmICR7ZGF0YX0gPT0gKyR7ZGF0YX0gJiYgISgke2RhdGF9ICUgMSkpYClcbiAgICAgICAgICAgICAgICAgICAgLmFzc2lnbihjb2VyY2VkLCAoMCwgY29kZWdlbl8xLl8pIGArJHtkYXRhfWApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICAgICAgZ2VuXG4gICAgICAgICAgICAgICAgICAgIC5lbHNlSWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfSA9PT0gXCJmYWxzZVwiIHx8ICR7ZGF0YX0gPT09IDAgfHwgJHtkYXRhfSA9PT0gbnVsbGApXG4gICAgICAgICAgICAgICAgICAgIC5hc3NpZ24oY29lcmNlZCwgZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIC5lbHNlSWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfSA9PT0gXCJ0cnVlXCIgfHwgJHtkYXRhfSA9PT0gMWApXG4gICAgICAgICAgICAgICAgICAgIC5hc3NpZ24oY29lcmNlZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBcIm51bGxcIjpcbiAgICAgICAgICAgICAgICBnZW4uZWxzZUlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0gPT09IFwiXCIgfHwgJHtkYXRhfSA9PT0gMCB8fCAke2RhdGF9ID09PSBmYWxzZWApO1xuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24oY29lcmNlZCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBcImFycmF5XCI6XG4gICAgICAgICAgICAgICAgZ2VuXG4gICAgICAgICAgICAgICAgICAgIC5lbHNlSWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhVHlwZX0gPT09IFwic3RyaW5nXCIgfHwgJHtkYXRhVHlwZX0gPT09IFwibnVtYmVyXCJcbiAgICAgICAgICAgICAgfHwgJHtkYXRhVHlwZX0gPT09IFwiYm9vbGVhblwiIHx8ICR7ZGF0YX0gPT09IG51bGxgKVxuICAgICAgICAgICAgICAgICAgICAuYXNzaWduKGNvZXJjZWQsICgwLCBjb2RlZ2VuXzEuXykgYFske2RhdGF9XWApO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gYXNzaWduUGFyZW50RGF0YSh7IGdlbiwgcGFyZW50RGF0YSwgcGFyZW50RGF0YVByb3BlcnR5IH0sIGV4cHIpIHtcbiAgICAvLyBUT0RPIHVzZSBnZW4ucHJvcGVydHlcbiAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtwYXJlbnREYXRhfSAhPT0gdW5kZWZpbmVkYCwgKCkgPT4gZ2VuLmFzc2lnbigoMCwgY29kZWdlbl8xLl8pIGAke3BhcmVudERhdGF9WyR7cGFyZW50RGF0YVByb3BlcnR5fV1gLCBleHByKSk7XG59XG5mdW5jdGlvbiBjaGVja0RhdGFUeXBlKGRhdGFUeXBlLCBkYXRhLCBzdHJpY3ROdW1zLCBjb3JyZWN0ID0gRGF0YVR5cGUuQ29ycmVjdCkge1xuICAgIGNvbnN0IEVRID0gY29ycmVjdCA9PT0gRGF0YVR5cGUuQ29ycmVjdCA/IGNvZGVnZW5fMS5vcGVyYXRvcnMuRVEgOiBjb2RlZ2VuXzEub3BlcmF0b3JzLk5FUTtcbiAgICBsZXQgY29uZDtcbiAgICBzd2l0Y2ggKGRhdGFUeXBlKSB7XG4gICAgICAgIGNhc2UgXCJudWxsXCI6XG4gICAgICAgICAgICByZXR1cm4gKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfSAke0VRfSBudWxsYDtcbiAgICAgICAgY2FzZSBcImFycmF5XCI6XG4gICAgICAgICAgICBjb25kID0gKDAsIGNvZGVnZW5fMS5fKSBgQXJyYXkuaXNBcnJheSgke2RhdGF9KWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgY29uZCA9ICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0gJiYgdHlwZW9mICR7ZGF0YX0gPT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheSgke2RhdGF9KWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImludGVnZXJcIjpcbiAgICAgICAgICAgIGNvbmQgPSBudW1Db25kKCgwLCBjb2RlZ2VuXzEuXykgYCEoJHtkYXRhfSAlIDEpICYmICFpc05hTigke2RhdGF9KWApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIGNvbmQgPSBudW1Db25kKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLl8pIGB0eXBlb2YgJHtkYXRhfSAke0VRfSAke2RhdGFUeXBlfWA7XG4gICAgfVxuICAgIHJldHVybiBjb3JyZWN0ID09PSBEYXRhVHlwZS5Db3JyZWN0ID8gY29uZCA6ICgwLCBjb2RlZ2VuXzEubm90KShjb25kKTtcbiAgICBmdW5jdGlvbiBudW1Db25kKF9jb25kID0gY29kZWdlbl8xLm5pbCkge1xuICAgICAgICByZXR1cm4gKDAsIGNvZGVnZW5fMS5hbmQpKCgwLCBjb2RlZ2VuXzEuXykgYHR5cGVvZiAke2RhdGF9ID09IFwibnVtYmVyXCJgLCBfY29uZCwgc3RyaWN0TnVtcyA/ICgwLCBjb2RlZ2VuXzEuXykgYGlzRmluaXRlKCR7ZGF0YX0pYCA6IGNvZGVnZW5fMS5uaWwpO1xuICAgIH1cbn1cbmV4cG9ydHMuY2hlY2tEYXRhVHlwZSA9IGNoZWNrRGF0YVR5cGU7XG5mdW5jdGlvbiBjaGVja0RhdGFUeXBlcyhkYXRhVHlwZXMsIGRhdGEsIHN0cmljdE51bXMsIGNvcnJlY3QpIHtcbiAgICBpZiAoZGF0YVR5cGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gY2hlY2tEYXRhVHlwZShkYXRhVHlwZXNbMF0sIGRhdGEsIHN0cmljdE51bXMsIGNvcnJlY3QpO1xuICAgIH1cbiAgICBsZXQgY29uZDtcbiAgICBjb25zdCB0eXBlcyA9ICgwLCB1dGlsXzEudG9IYXNoKShkYXRhVHlwZXMpO1xuICAgIGlmICh0eXBlcy5hcnJheSAmJiB0eXBlcy5vYmplY3QpIHtcbiAgICAgICAgY29uc3Qgbm90T2JqID0gKDAsIGNvZGVnZW5fMS5fKSBgdHlwZW9mICR7ZGF0YX0gIT0gXCJvYmplY3RcImA7XG4gICAgICAgIGNvbmQgPSB0eXBlcy5udWxsID8gbm90T2JqIDogKDAsIGNvZGVnZW5fMS5fKSBgISR7ZGF0YX0gfHwgJHtub3RPYmp9YDtcbiAgICAgICAgZGVsZXRlIHR5cGVzLm51bGw7XG4gICAgICAgIGRlbGV0ZSB0eXBlcy5hcnJheTtcbiAgICAgICAgZGVsZXRlIHR5cGVzLm9iamVjdDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbmQgPSBjb2RlZ2VuXzEubmlsO1xuICAgIH1cbiAgICBpZiAodHlwZXMubnVtYmVyKVxuICAgICAgICBkZWxldGUgdHlwZXMuaW50ZWdlcjtcbiAgICBmb3IgKGNvbnN0IHQgaW4gdHlwZXMpXG4gICAgICAgIGNvbmQgPSAoMCwgY29kZWdlbl8xLmFuZCkoY29uZCwgY2hlY2tEYXRhVHlwZSh0LCBkYXRhLCBzdHJpY3ROdW1zLCBjb3JyZWN0KSk7XG4gICAgcmV0dXJuIGNvbmQ7XG59XG5leHBvcnRzLmNoZWNrRGF0YVR5cGVzID0gY2hlY2tEYXRhVHlwZXM7XG5jb25zdCB0eXBlRXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsgc2NoZW1hIH0pID0+IGBtdXN0IGJlICR7c2NoZW1hfWAsXG4gICAgcGFyYW1zOiAoeyBzY2hlbWEsIHNjaGVtYVZhbHVlIH0pID0+IHR5cGVvZiBzY2hlbWEgPT0gXCJzdHJpbmdcIiA/ICgwLCBjb2RlZ2VuXzEuXykgYHt0eXBlOiAke3NjaGVtYX19YCA6ICgwLCBjb2RlZ2VuXzEuXykgYHt0eXBlOiAke3NjaGVtYVZhbHVlfX1gLFxufTtcbmZ1bmN0aW9uIHJlcG9ydFR5cGVFcnJvcihpdCkge1xuICAgIGNvbnN0IGN4dCA9IGdldFR5cGVFcnJvckNvbnRleHQoaXQpO1xuICAgICgwLCBlcnJvcnNfMS5yZXBvcnRFcnJvcikoY3h0LCB0eXBlRXJyb3IpO1xufVxuZXhwb3J0cy5yZXBvcnRUeXBlRXJyb3IgPSByZXBvcnRUeXBlRXJyb3I7XG5mdW5jdGlvbiBnZXRUeXBlRXJyb3JDb250ZXh0KGl0KSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEsIHNjaGVtYSB9ID0gaXQ7XG4gICAgY29uc3Qgc2NoZW1hQ29kZSA9ICgwLCB1dGlsXzEuc2NoZW1hUmVmT3JWYWwpKGl0LCBzY2hlbWEsIFwidHlwZVwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBnZW4sXG4gICAgICAgIGtleXdvcmQ6IFwidHlwZVwiLFxuICAgICAgICBkYXRhLFxuICAgICAgICBzY2hlbWE6IHNjaGVtYS50eXBlLFxuICAgICAgICBzY2hlbWFDb2RlLFxuICAgICAgICBzY2hlbWFWYWx1ZTogc2NoZW1hQ29kZSxcbiAgICAgICAgcGFyZW50U2NoZW1hOiBzY2hlbWEsXG4gICAgICAgIHBhcmFtczoge30sXG4gICAgICAgIGl0LFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhVHlwZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYXNzaWduRGVmYXVsdHMgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuZnVuY3Rpb24gYXNzaWduRGVmYXVsdHMoaXQsIHR5KSB7XG4gICAgY29uc3QgeyBwcm9wZXJ0aWVzLCBpdGVtcyB9ID0gaXQuc2NoZW1hO1xuICAgIGlmICh0eSA9PT0gXCJvYmplY3RcIiAmJiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGFzc2lnbkRlZmF1bHQoaXQsIGtleSwgcHJvcGVydGllc1trZXldLmRlZmF1bHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5ID09PSBcImFycmF5XCIgJiYgQXJyYXkuaXNBcnJheShpdGVtcykpIHtcbiAgICAgICAgaXRlbXMuZm9yRWFjaCgoc2NoLCBpKSA9PiBhc3NpZ25EZWZhdWx0KGl0LCBpLCBzY2guZGVmYXVsdCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuYXNzaWduRGVmYXVsdHMgPSBhc3NpZ25EZWZhdWx0cztcbmZ1bmN0aW9uIGFzc2lnbkRlZmF1bHQoaXQsIHByb3AsIGRlZmF1bHRWYWx1ZSkge1xuICAgIGNvbnN0IHsgZ2VuLCBjb21wb3NpdGVSdWxlLCBkYXRhLCBvcHRzIH0gPSBpdDtcbiAgICBpZiAoZGVmYXVsdFZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCBjaGlsZERhdGEgPSAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9JHsoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KShwcm9wKX1gO1xuICAgIGlmIChjb21wb3NpdGVSdWxlKSB7XG4gICAgICAgICgwLCB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKShpdCwgYGRlZmF1bHQgaXMgaWdub3JlZCBmb3I6ICR7Y2hpbGREYXRhfWApO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBjb25kaXRpb24gPSAoMCwgY29kZWdlbl8xLl8pIGAke2NoaWxkRGF0YX0gPT09IHVuZGVmaW5lZGA7XG4gICAgaWYgKG9wdHMudXNlRGVmYXVsdHMgPT09IFwiZW1wdHlcIikge1xuICAgICAgICBjb25kaXRpb24gPSAoMCwgY29kZWdlbl8xLl8pIGAke2NvbmRpdGlvbn0gfHwgJHtjaGlsZERhdGF9ID09PSBudWxsIHx8ICR7Y2hpbGREYXRhfSA9PT0gXCJcImA7XG4gICAgfVxuICAgIC8vIGAke2NoaWxkRGF0YX0gPT09IHVuZGVmaW5lZGAgK1xuICAgIC8vIChvcHRzLnVzZURlZmF1bHRzID09PSBcImVtcHR5XCIgPyBgIHx8ICR7Y2hpbGREYXRhfSA9PT0gbnVsbCB8fCAke2NoaWxkRGF0YX0gPT09IFwiXCJgIDogXCJcIilcbiAgICBnZW4uaWYoY29uZGl0aW9uLCAoMCwgY29kZWdlbl8xLl8pIGAke2NoaWxkRGF0YX0gPSAkeygwLCBjb2RlZ2VuXzEuc3RyaW5naWZ5KShkZWZhdWx0VmFsdWUpfWApO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmYXVsdHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlVW5pb24gPSBleHBvcnRzLnZhbGlkYXRlQXJyYXkgPSBleHBvcnRzLnVzZVBhdHRlcm4gPSBleHBvcnRzLmNhbGxWYWxpZGF0ZUNvZGUgPSBleHBvcnRzLnNjaGVtYVByb3BlcnRpZXMgPSBleHBvcnRzLmFsbFNjaGVtYVByb3BlcnRpZXMgPSBleHBvcnRzLm5vUHJvcGVydHlJbkRhdGEgPSBleHBvcnRzLnByb3BlcnR5SW5EYXRhID0gZXhwb3J0cy5pc093blByb3BlcnR5ID0gZXhwb3J0cy5oYXNQcm9wRnVuYyA9IGV4cG9ydHMucmVwb3J0TWlzc2luZ1Byb3AgPSBleHBvcnRzLmNoZWNrTWlzc2luZ1Byb3AgPSBleHBvcnRzLmNoZWNrUmVwb3J0TWlzc2luZ1Byb3AgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IG5hbWVzXzEgPSByZXF1aXJlKFwiLi4vY29tcGlsZS9uYW1lc1wiKTtcbmNvbnN0IHV0aWxfMiA9IHJlcXVpcmUoXCIuLi9jb21waWxlL3V0aWxcIik7XG5mdW5jdGlvbiBjaGVja1JlcG9ydE1pc3NpbmdQcm9wKGN4dCwgcHJvcCkge1xuICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBpdCB9ID0gY3h0O1xuICAgIGdlbi5pZihub1Byb3BlcnR5SW5EYXRhKGdlbiwgZGF0YSwgcHJvcCwgaXQub3B0cy5vd25Qcm9wZXJ0aWVzKSwgKCkgPT4ge1xuICAgICAgICBjeHQuc2V0UGFyYW1zKHsgbWlzc2luZ1Byb3BlcnR5OiAoMCwgY29kZWdlbl8xLl8pIGAke3Byb3B9YCB9LCB0cnVlKTtcbiAgICAgICAgY3h0LmVycm9yKCk7XG4gICAgfSk7XG59XG5leHBvcnRzLmNoZWNrUmVwb3J0TWlzc2luZ1Byb3AgPSBjaGVja1JlcG9ydE1pc3NpbmdQcm9wO1xuZnVuY3Rpb24gY2hlY2tNaXNzaW5nUHJvcCh7IGdlbiwgZGF0YSwgaXQ6IHsgb3B0cyB9IH0sIHByb3BlcnRpZXMsIG1pc3NpbmcpIHtcbiAgICByZXR1cm4gKDAsIGNvZGVnZW5fMS5vcikoLi4ucHJvcGVydGllcy5tYXAoKHByb3ApID0+ICgwLCBjb2RlZ2VuXzEuYW5kKShub1Byb3BlcnR5SW5EYXRhKGdlbiwgZGF0YSwgcHJvcCwgb3B0cy5vd25Qcm9wZXJ0aWVzKSwgKDAsIGNvZGVnZW5fMS5fKSBgJHttaXNzaW5nfSA9ICR7cHJvcH1gKSkpO1xufVxuZXhwb3J0cy5jaGVja01pc3NpbmdQcm9wID0gY2hlY2tNaXNzaW5nUHJvcDtcbmZ1bmN0aW9uIHJlcG9ydE1pc3NpbmdQcm9wKGN4dCwgbWlzc2luZykge1xuICAgIGN4dC5zZXRQYXJhbXMoeyBtaXNzaW5nUHJvcGVydHk6IG1pc3NpbmcgfSwgdHJ1ZSk7XG4gICAgY3h0LmVycm9yKCk7XG59XG5leHBvcnRzLnJlcG9ydE1pc3NpbmdQcm9wID0gcmVwb3J0TWlzc2luZ1Byb3A7XG5mdW5jdGlvbiBoYXNQcm9wRnVuYyhnZW4pIHtcbiAgICByZXR1cm4gZ2VuLnNjb3BlVmFsdWUoXCJmdW5jXCIsIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZFxuICAgICAgICByZWY6IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXG4gICAgICAgIGNvZGU6ICgwLCBjb2RlZ2VuXzEuXykgYE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlgLFxuICAgIH0pO1xufVxuZXhwb3J0cy5oYXNQcm9wRnVuYyA9IGhhc1Byb3BGdW5jO1xuZnVuY3Rpb24gaXNPd25Qcm9wZXJ0eShnZW4sIGRhdGEsIHByb3BlcnR5KSB7XG4gICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuXykgYCR7aGFzUHJvcEZ1bmMoZ2VuKX0uY2FsbCgke2RhdGF9LCAke3Byb3BlcnR5fSlgO1xufVxuZXhwb3J0cy5pc093blByb3BlcnR5ID0gaXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIHByb3BlcnR5SW5EYXRhKGdlbiwgZGF0YSwgcHJvcGVydHksIG93blByb3BlcnRpZXMpIHtcbiAgICBjb25zdCBjb25kID0gKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfSR7KDAsIGNvZGVnZW5fMS5nZXRQcm9wZXJ0eSkocHJvcGVydHkpfSAhPT0gdW5kZWZpbmVkYDtcbiAgICByZXR1cm4gb3duUHJvcGVydGllcyA/ICgwLCBjb2RlZ2VuXzEuXykgYCR7Y29uZH0gJiYgJHtpc093blByb3BlcnR5KGdlbiwgZGF0YSwgcHJvcGVydHkpfWAgOiBjb25kO1xufVxuZXhwb3J0cy5wcm9wZXJ0eUluRGF0YSA9IHByb3BlcnR5SW5EYXRhO1xuZnVuY3Rpb24gbm9Qcm9wZXJ0eUluRGF0YShnZW4sIGRhdGEsIHByb3BlcnR5LCBvd25Qcm9wZXJ0aWVzKSB7XG4gICAgY29uc3QgY29uZCA9ICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0keygwLCBjb2RlZ2VuXzEuZ2V0UHJvcGVydHkpKHByb3BlcnR5KX0gPT09IHVuZGVmaW5lZGA7XG4gICAgcmV0dXJuIG93blByb3BlcnRpZXMgPyAoMCwgY29kZWdlbl8xLm9yKShjb25kLCAoMCwgY29kZWdlbl8xLm5vdCkoaXNPd25Qcm9wZXJ0eShnZW4sIGRhdGEsIHByb3BlcnR5KSkpIDogY29uZDtcbn1cbmV4cG9ydHMubm9Qcm9wZXJ0eUluRGF0YSA9IG5vUHJvcGVydHlJbkRhdGE7XG5mdW5jdGlvbiBhbGxTY2hlbWFQcm9wZXJ0aWVzKHNjaGVtYU1hcCkge1xuICAgIHJldHVybiBzY2hlbWFNYXAgPyBPYmplY3Qua2V5cyhzY2hlbWFNYXApLmZpbHRlcigocCkgPT4gcCAhPT0gXCJfX3Byb3RvX19cIikgOiBbXTtcbn1cbmV4cG9ydHMuYWxsU2NoZW1hUHJvcGVydGllcyA9IGFsbFNjaGVtYVByb3BlcnRpZXM7XG5mdW5jdGlvbiBzY2hlbWFQcm9wZXJ0aWVzKGl0LCBzY2hlbWFNYXApIHtcbiAgICByZXR1cm4gYWxsU2NoZW1hUHJvcGVydGllcyhzY2hlbWFNYXApLmZpbHRlcigocCkgPT4gISgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2hlbWFNYXBbcF0pKTtcbn1cbmV4cG9ydHMuc2NoZW1hUHJvcGVydGllcyA9IHNjaGVtYVByb3BlcnRpZXM7XG5mdW5jdGlvbiBjYWxsVmFsaWRhdGVDb2RlKHsgc2NoZW1hQ29kZSwgZGF0YSwgaXQ6IHsgZ2VuLCB0b3BTY2hlbWFSZWYsIHNjaGVtYVBhdGgsIGVycm9yUGF0aCB9LCBpdCB9LCBmdW5jLCBjb250ZXh0LCBwYXNzU2NoZW1hKSB7XG4gICAgY29uc3QgZGF0YUFuZFNjaGVtYSA9IHBhc3NTY2hlbWEgPyAoMCwgY29kZWdlbl8xLl8pIGAke3NjaGVtYUNvZGV9LCAke2RhdGF9LCAke3RvcFNjaGVtYVJlZn0ke3NjaGVtYVBhdGh9YCA6IGRhdGE7XG4gICAgY29uc3QgdmFsQ3h0ID0gW1xuICAgICAgICBbbmFtZXNfMS5kZWZhdWx0Lmluc3RhbmNlUGF0aCwgKDAsIGNvZGVnZW5fMS5zdHJDb25jYXQpKG5hbWVzXzEuZGVmYXVsdC5pbnN0YW5jZVBhdGgsIGVycm9yUGF0aCldLFxuICAgICAgICBbbmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGEsIGl0LnBhcmVudERhdGFdLFxuICAgICAgICBbbmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGFQcm9wZXJ0eSwgaXQucGFyZW50RGF0YVByb3BlcnR5XSxcbiAgICAgICAgW25hbWVzXzEuZGVmYXVsdC5yb290RGF0YSwgbmFtZXNfMS5kZWZhdWx0LnJvb3REYXRhXSxcbiAgICBdO1xuICAgIGlmIChpdC5vcHRzLmR5bmFtaWNSZWYpXG4gICAgICAgIHZhbEN4dC5wdXNoKFtuYW1lc18xLmRlZmF1bHQuZHluYW1pY0FuY2hvcnMsIG5hbWVzXzEuZGVmYXVsdC5keW5hbWljQW5jaG9yc10pO1xuICAgIGNvbnN0IGFyZ3MgPSAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGFBbmRTY2hlbWF9LCAke2dlbi5vYmplY3QoLi4udmFsQ3h0KX1gO1xuICAgIHJldHVybiBjb250ZXh0ICE9PSBjb2RlZ2VuXzEubmlsID8gKDAsIGNvZGVnZW5fMS5fKSBgJHtmdW5jfS5jYWxsKCR7Y29udGV4dH0sICR7YXJnc30pYCA6ICgwLCBjb2RlZ2VuXzEuXykgYCR7ZnVuY30oJHthcmdzfSlgO1xufVxuZXhwb3J0cy5jYWxsVmFsaWRhdGVDb2RlID0gY2FsbFZhbGlkYXRlQ29kZTtcbmNvbnN0IG5ld1JlZ0V4cCA9ICgwLCBjb2RlZ2VuXzEuXykgYG5ldyBSZWdFeHBgO1xuZnVuY3Rpb24gdXNlUGF0dGVybih7IGdlbiwgaXQ6IHsgb3B0cyB9IH0sIHBhdHRlcm4pIHtcbiAgICBjb25zdCB1ID0gb3B0cy51bmljb2RlUmVnRXhwID8gXCJ1XCIgOiBcIlwiO1xuICAgIGNvbnN0IHsgcmVnRXhwIH0gPSBvcHRzLmNvZGU7XG4gICAgY29uc3QgcnggPSByZWdFeHAocGF0dGVybiwgdSk7XG4gICAgcmV0dXJuIGdlbi5zY29wZVZhbHVlKFwicGF0dGVyblwiLCB7XG4gICAgICAgIGtleTogcngudG9TdHJpbmcoKSxcbiAgICAgICAgcmVmOiByeCxcbiAgICAgICAgY29kZTogKDAsIGNvZGVnZW5fMS5fKSBgJHtyZWdFeHAuY29kZSA9PT0gXCJuZXcgUmVnRXhwXCIgPyBuZXdSZWdFeHAgOiAoMCwgdXRpbF8yLnVzZUZ1bmMpKGdlbiwgcmVnRXhwKX0oJHtwYXR0ZXJufSwgJHt1fSlgLFxuICAgIH0pO1xufVxuZXhwb3J0cy51c2VQYXR0ZXJuID0gdXNlUGF0dGVybjtcbmZ1bmN0aW9uIHZhbGlkYXRlQXJyYXkoY3h0KSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEsIGtleXdvcmQsIGl0IH0gPSBjeHQ7XG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgIGlmIChpdC5hbGxFcnJvcnMpIHtcbiAgICAgICAgY29uc3QgdmFsaWRBcnIgPSBnZW4ubGV0KFwidmFsaWRcIiwgdHJ1ZSk7XG4gICAgICAgIHZhbGlkYXRlSXRlbXMoKCkgPT4gZ2VuLmFzc2lnbih2YWxpZEFyciwgZmFsc2UpKTtcbiAgICAgICAgcmV0dXJuIHZhbGlkQXJyO1xuICAgIH1cbiAgICBnZW4udmFyKHZhbGlkLCB0cnVlKTtcbiAgICB2YWxpZGF0ZUl0ZW1zKCgpID0+IGdlbi5icmVhaygpKTtcbiAgICByZXR1cm4gdmFsaWQ7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVJdGVtcyhub3RWYWxpZCkge1xuICAgICAgICBjb25zdCBsZW4gPSBnZW4uY29uc3QoXCJsZW5cIiwgKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfS5sZW5ndGhgKTtcbiAgICAgICAgZ2VuLmZvclJhbmdlKFwiaVwiLCAwLCBsZW4sIChpKSA9PiB7XG4gICAgICAgICAgICBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgICAgICBrZXl3b3JkLFxuICAgICAgICAgICAgICAgIGRhdGFQcm9wOiBpLFxuICAgICAgICAgICAgICAgIGRhdGFQcm9wVHlwZTogdXRpbF8xLlR5cGUuTnVtLFxuICAgICAgICAgICAgfSwgdmFsaWQpO1xuICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEubm90KSh2YWxpZCksIG5vdFZhbGlkKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZUFycmF5ID0gdmFsaWRhdGVBcnJheTtcbmZ1bmN0aW9uIHZhbGlkYXRlVW5pb24oY3h0KSB7XG4gICAgY29uc3QgeyBnZW4sIHNjaGVtYSwga2V5d29yZCwgaXQgfSA9IGN4dDtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgIGNvbnN0IGFsd2F5c1ZhbGlkID0gc2NoZW1hLnNvbWUoKHNjaCkgPT4gKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaCkpO1xuICAgIGlmIChhbHdheXNWYWxpZCAmJiAhaXQub3B0cy51bmV2YWx1YXRlZClcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIsIGZhbHNlKTtcbiAgICBjb25zdCBzY2hWYWxpZCA9IGdlbi5uYW1lKFwiX3ZhbGlkXCIpO1xuICAgIGdlbi5ibG9jaygoKSA9PiBzY2hlbWEuZm9yRWFjaCgoX3NjaCwgaSkgPT4ge1xuICAgICAgICBjb25zdCBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgIGtleXdvcmQsXG4gICAgICAgICAgICBzY2hlbWFQcm9wOiBpLFxuICAgICAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICAgICAgfSwgc2NoVmFsaWQpO1xuICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCAoMCwgY29kZWdlbl8xLl8pIGAke3ZhbGlkfSB8fCAke3NjaFZhbGlkfWApO1xuICAgICAgICBjb25zdCBtZXJnZWQgPSBjeHQubWVyZ2VWYWxpZEV2YWx1YXRlZChzY2hDeHQsIHNjaFZhbGlkKTtcbiAgICAgICAgLy8gY2FuIHNob3J0LWNpcmN1aXQgaWYgYHVuZXZhbHVhdGVkUHJvcGVydGllcy9JdGVtc2Agbm90IHN1cHBvcnRlZCAob3B0cy51bmV2YWx1YXRlZCAhPT0gdHJ1ZSlcbiAgICAgICAgLy8gb3IgaWYgYWxsIHByb3BlcnRpZXMgYW5kIGl0ZW1zIHdlcmUgZXZhbHVhdGVkIChpdC5wcm9wcyA9PT0gdHJ1ZSAmJiBpdC5pdGVtcyA9PT0gdHJ1ZSlcbiAgICAgICAgaWYgKCFtZXJnZWQpXG4gICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5ub3QpKHZhbGlkKSk7XG4gICAgfSkpO1xuICAgIGN4dC5yZXN1bHQodmFsaWQsICgpID0+IGN4dC5yZXNldCgpLCAoKSA9PiBjeHQuZXJyb3IodHJ1ZSkpO1xufVxuZXhwb3J0cy52YWxpZGF0ZVVuaW9uID0gdmFsaWRhdGVVbmlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvZGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlS2V5d29yZFVzYWdlID0gZXhwb3J0cy52YWxpZFNjaGVtYVR5cGUgPSBleHBvcnRzLmZ1bmNLZXl3b3JkQ29kZSA9IGV4cG9ydHMubWFjcm9LZXl3b3JkQ29kZSA9IHZvaWQgMDtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi9jb2RlZ2VuXCIpO1xuY29uc3QgbmFtZXNfMSA9IHJlcXVpcmUoXCIuLi9uYW1lc1wiKTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi8uLi92b2NhYnVsYXJpZXMvY29kZVwiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbmZ1bmN0aW9uIG1hY3JvS2V5d29yZENvZGUoY3h0LCBkZWYpIHtcbiAgICBjb25zdCB7IGdlbiwga2V5d29yZCwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgY29uc3QgbWFjcm9TY2hlbWEgPSBkZWYubWFjcm8uY2FsbChpdC5zZWxmLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgaXQpO1xuICAgIGNvbnN0IHNjaGVtYVJlZiA9IHVzZUtleXdvcmQoZ2VuLCBrZXl3b3JkLCBtYWNyb1NjaGVtYSk7XG4gICAgaWYgKGl0Lm9wdHMudmFsaWRhdGVTY2hlbWEgIT09IGZhbHNlKVxuICAgICAgICBpdC5zZWxmLnZhbGlkYXRlU2NoZW1hKG1hY3JvU2NoZW1hLCB0cnVlKTtcbiAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgIHNjaGVtYTogbWFjcm9TY2hlbWEsXG4gICAgICAgIHNjaGVtYVBhdGg6IGNvZGVnZW5fMS5uaWwsXG4gICAgICAgIGVyclNjaGVtYVBhdGg6IGAke2l0LmVyclNjaGVtYVBhdGh9LyR7a2V5d29yZH1gLFxuICAgICAgICB0b3BTY2hlbWFSZWY6IHNjaGVtYVJlZixcbiAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICB9LCB2YWxpZCk7XG4gICAgY3h0LnBhc3ModmFsaWQsICgpID0+IGN4dC5lcnJvcih0cnVlKSk7XG59XG5leHBvcnRzLm1hY3JvS2V5d29yZENvZGUgPSBtYWNyb0tleXdvcmRDb2RlO1xuZnVuY3Rpb24gZnVuY0tleXdvcmRDb2RlKGN4dCwgZGVmKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHsgZ2VuLCBrZXl3b3JkLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgJGRhdGEsIGl0IH0gPSBjeHQ7XG4gICAgY2hlY2tBc3luY0tleXdvcmQoaXQsIGRlZik7XG4gICAgY29uc3QgdmFsaWRhdGUgPSAhJGRhdGEgJiYgZGVmLmNvbXBpbGUgPyBkZWYuY29tcGlsZS5jYWxsKGl0LnNlbGYsIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBpdCkgOiBkZWYudmFsaWRhdGU7XG4gICAgY29uc3QgdmFsaWRhdGVSZWYgPSB1c2VLZXl3b3JkKGdlbiwga2V5d29yZCwgdmFsaWRhdGUpO1xuICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIpO1xuICAgIGN4dC5ibG9jayRkYXRhKHZhbGlkLCB2YWxpZGF0ZUtleXdvcmQpO1xuICAgIGN4dC5vaygoX2EgPSBkZWYudmFsaWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHZhbGlkKTtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUtleXdvcmQoKSB7XG4gICAgICAgIGlmIChkZWYuZXJyb3JzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYXNzaWduVmFsaWQoKTtcbiAgICAgICAgICAgIGlmIChkZWYubW9kaWZ5aW5nKVxuICAgICAgICAgICAgICAgIG1vZGlmeURhdGEoY3h0KTtcbiAgICAgICAgICAgIHJlcG9ydEVycnMoKCkgPT4gY3h0LmVycm9yKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcnVsZUVycnMgPSBkZWYuYXN5bmMgPyB2YWxpZGF0ZUFzeW5jKCkgOiB2YWxpZGF0ZVN5bmMoKTtcbiAgICAgICAgICAgIGlmIChkZWYubW9kaWZ5aW5nKVxuICAgICAgICAgICAgICAgIG1vZGlmeURhdGEoY3h0KTtcbiAgICAgICAgICAgIHJlcG9ydEVycnMoKCkgPT4gYWRkRXJycyhjeHQsIHJ1bGVFcnJzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVBc3luYygpIHtcbiAgICAgICAgY29uc3QgcnVsZUVycnMgPSBnZW4ubGV0KFwicnVsZUVycnNcIiwgbnVsbCk7XG4gICAgICAgIGdlbi50cnkoKCkgPT4gYXNzaWduVmFsaWQoKDAsIGNvZGVnZW5fMS5fKSBgYXdhaXQgYCksIChlKSA9PiBnZW4uYXNzaWduKHZhbGlkLCBmYWxzZSkuaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtlfSBpbnN0YW5jZW9mICR7aXQuVmFsaWRhdGlvbkVycm9yfWAsICgpID0+IGdlbi5hc3NpZ24ocnVsZUVycnMsICgwLCBjb2RlZ2VuXzEuXykgYCR7ZX0uZXJyb3JzYCksICgpID0+IGdlbi50aHJvdyhlKSkpO1xuICAgICAgICByZXR1cm4gcnVsZUVycnM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlU3luYygpIHtcbiAgICAgICAgY29uc3QgdmFsaWRhdGVFcnJzID0gKDAsIGNvZGVnZW5fMS5fKSBgJHt2YWxpZGF0ZVJlZn0uZXJyb3JzYDtcbiAgICAgICAgZ2VuLmFzc2lnbih2YWxpZGF0ZUVycnMsIG51bGwpO1xuICAgICAgICBhc3NpZ25WYWxpZChjb2RlZ2VuXzEubmlsKTtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlRXJycztcbiAgICB9XG4gICAgZnVuY3Rpb24gYXNzaWduVmFsaWQoX2F3YWl0ID0gZGVmLmFzeW5jID8gKDAsIGNvZGVnZW5fMS5fKSBgYXdhaXQgYCA6IGNvZGVnZW5fMS5uaWwpIHtcbiAgICAgICAgY29uc3QgcGFzc0N4dCA9IGl0Lm9wdHMucGFzc0NvbnRleHQgPyBuYW1lc18xLmRlZmF1bHQudGhpcyA6IG5hbWVzXzEuZGVmYXVsdC5zZWxmO1xuICAgICAgICBjb25zdCBwYXNzU2NoZW1hID0gISgoXCJjb21waWxlXCIgaW4gZGVmICYmICEkZGF0YSkgfHwgZGVmLnNjaGVtYSA9PT0gZmFsc2UpO1xuICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCAoMCwgY29kZWdlbl8xLl8pIGAke19hd2FpdH0keygwLCBjb2RlXzEuY2FsbFZhbGlkYXRlQ29kZSkoY3h0LCB2YWxpZGF0ZVJlZiwgcGFzc0N4dCwgcGFzc1NjaGVtYSl9YCwgZGVmLm1vZGlmeWluZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcG9ydEVycnMoZXJyb3JzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEubm90KSgoX2EgPSBkZWYudmFsaWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHZhbGlkKSwgZXJyb3JzKTtcbiAgICB9XG59XG5leHBvcnRzLmZ1bmNLZXl3b3JkQ29kZSA9IGZ1bmNLZXl3b3JkQ29kZTtcbmZ1bmN0aW9uIG1vZGlmeURhdGEoY3h0KSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEsIGl0IH0gPSBjeHQ7XG4gICAgZ2VuLmlmKGl0LnBhcmVudERhdGEsICgpID0+IGdlbi5hc3NpZ24oZGF0YSwgKDAsIGNvZGVnZW5fMS5fKSBgJHtpdC5wYXJlbnREYXRhfVske2l0LnBhcmVudERhdGFQcm9wZXJ0eX1dYCkpO1xufVxuZnVuY3Rpb24gYWRkRXJycyhjeHQsIGVycnMpIHtcbiAgICBjb25zdCB7IGdlbiB9ID0gY3h0O1xuICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGBBcnJheS5pc0FycmF5KCR7ZXJyc30pYCwgKCkgPT4ge1xuICAgICAgICBnZW5cbiAgICAgICAgICAgIC5hc3NpZ24obmFtZXNfMS5kZWZhdWx0LnZFcnJvcnMsICgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9ID09PSBudWxsID8gJHtlcnJzfSA6ICR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9LmNvbmNhdCgke2VycnN9KWApXG4gICAgICAgICAgICAuYXNzaWduKG5hbWVzXzEuZGVmYXVsdC5lcnJvcnMsICgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9Lmxlbmd0aGApO1xuICAgICAgICAoMCwgZXJyb3JzXzEuZXh0ZW5kRXJyb3JzKShjeHQpO1xuICAgIH0sICgpID0+IGN4dC5lcnJvcigpKTtcbn1cbmZ1bmN0aW9uIGNoZWNrQXN5bmNLZXl3b3JkKHsgc2NoZW1hRW52IH0sIGRlZikge1xuICAgIGlmIChkZWYuYXN5bmMgJiYgIXNjaGVtYUVudi4kYXN5bmMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImFzeW5jIGtleXdvcmQgaW4gc3luYyBzY2hlbWFcIik7XG59XG5mdW5jdGlvbiB1c2VLZXl3b3JkKGdlbiwga2V5d29yZCwgcmVzdWx0KSB7XG4gICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGtleXdvcmQgXCIke2tleXdvcmR9XCIgZmFpbGVkIHRvIGNvbXBpbGVgKTtcbiAgICByZXR1cm4gZ2VuLnNjb3BlVmFsdWUoXCJrZXl3b3JkXCIsIHR5cGVvZiByZXN1bHQgPT0gXCJmdW5jdGlvblwiID8geyByZWY6IHJlc3VsdCB9IDogeyByZWY6IHJlc3VsdCwgY29kZTogKDAsIGNvZGVnZW5fMS5zdHJpbmdpZnkpKHJlc3VsdCkgfSk7XG59XG5mdW5jdGlvbiB2YWxpZFNjaGVtYVR5cGUoc2NoZW1hLCBzY2hlbWFUeXBlLCBhbGxvd1VuZGVmaW5lZCA9IGZhbHNlKSB7XG4gICAgLy8gVE9ETyBhZGQgdGVzdHNcbiAgICByZXR1cm4gKCFzY2hlbWFUeXBlLmxlbmd0aCB8fFxuICAgICAgICBzY2hlbWFUeXBlLnNvbWUoKHN0KSA9PiBzdCA9PT0gXCJhcnJheVwiXG4gICAgICAgICAgICA/IEFycmF5LmlzQXJyYXkoc2NoZW1hKVxuICAgICAgICAgICAgOiBzdCA9PT0gXCJvYmplY3RcIlxuICAgICAgICAgICAgICAgID8gc2NoZW1hICYmIHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShzY2hlbWEpXG4gICAgICAgICAgICAgICAgOiB0eXBlb2Ygc2NoZW1hID09IHN0IHx8IChhbGxvd1VuZGVmaW5lZCAmJiB0eXBlb2Ygc2NoZW1hID09IFwidW5kZWZpbmVkXCIpKSk7XG59XG5leHBvcnRzLnZhbGlkU2NoZW1hVHlwZSA9IHZhbGlkU2NoZW1hVHlwZTtcbmZ1bmN0aW9uIHZhbGlkYXRlS2V5d29yZFVzYWdlKHsgc2NoZW1hLCBvcHRzLCBzZWxmLCBlcnJTY2hlbWFQYXRoIH0sIGRlZiwga2V5d29yZCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChBcnJheS5pc0FycmF5KGRlZi5rZXl3b3JkKSA/ICFkZWYua2V5d29yZC5pbmNsdWRlcyhrZXl3b3JkKSA6IGRlZi5rZXl3b3JkICE9PSBrZXl3b3JkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImFqdiBpbXBsZW1lbnRhdGlvbiBlcnJvclwiKTtcbiAgICB9XG4gICAgY29uc3QgZGVwcyA9IGRlZi5kZXBlbmRlbmNpZXM7XG4gICAgaWYgKGRlcHMgPT09IG51bGwgfHwgZGVwcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVwcy5zb21lKChrd2QpID0+ICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2NoZW1hLCBrd2QpKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHBhcmVudCBzY2hlbWEgbXVzdCBoYXZlIGRlcGVuZGVuY2llcyBvZiAke2tleXdvcmR9OiAke2RlcHMuam9pbihcIixcIil9YCk7XG4gICAgfVxuICAgIGlmIChkZWYudmFsaWRhdGVTY2hlbWEpIHtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBkZWYudmFsaWRhdGVTY2hlbWEoc2NoZW1hW2tleXdvcmRdKTtcbiAgICAgICAgaWYgKCF2YWxpZCkge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gYGtleXdvcmQgXCIke2tleXdvcmR9XCIgdmFsdWUgaXMgaW52YWxpZCBhdCBwYXRoIFwiJHtlcnJTY2hlbWFQYXRofVwiOiBgICtcbiAgICAgICAgICAgICAgICBzZWxmLmVycm9yc1RleHQoZGVmLnZhbGlkYXRlU2NoZW1hLmVycm9ycyk7XG4gICAgICAgICAgICBpZiAob3B0cy52YWxpZGF0ZVNjaGVtYSA9PT0gXCJsb2dcIilcbiAgICAgICAgICAgICAgICBzZWxmLmxvZ2dlci5lcnJvcihtc2cpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZUtleXdvcmRVc2FnZSA9IHZhbGlkYXRlS2V5d29yZFVzYWdlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9a2V5d29yZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZXh0ZW5kU3Vic2NoZW1hTW9kZSA9IGV4cG9ydHMuZXh0ZW5kU3Vic2NoZW1hRGF0YSA9IGV4cG9ydHMuZ2V0U3Vic2NoZW1hID0gdm9pZCAwO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmZ1bmN0aW9uIGdldFN1YnNjaGVtYShpdCwgeyBrZXl3b3JkLCBzY2hlbWFQcm9wLCBzY2hlbWEsIHNjaGVtYVBhdGgsIGVyclNjaGVtYVBhdGgsIHRvcFNjaGVtYVJlZiB9KSB7XG4gICAgaWYgKGtleXdvcmQgIT09IHVuZGVmaW5lZCAmJiBzY2hlbWEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JvdGggXCJrZXl3b3JkXCIgYW5kIFwic2NoZW1hXCIgcGFzc2VkLCBvbmx5IG9uZSBhbGxvd2VkJyk7XG4gICAgfVxuICAgIGlmIChrZXl3b3JkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3Qgc2NoID0gaXQuc2NoZW1hW2tleXdvcmRdO1xuICAgICAgICByZXR1cm4gc2NoZW1hUHJvcCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBzY2hlbWE6IHNjaCxcbiAgICAgICAgICAgICAgICBzY2hlbWFQYXRoOiAoMCwgY29kZWdlbl8xLl8pIGAke2l0LnNjaGVtYVBhdGh9JHsoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KShrZXl3b3JkKX1gLFxuICAgICAgICAgICAgICAgIGVyclNjaGVtYVBhdGg6IGAke2l0LmVyclNjaGVtYVBhdGh9LyR7a2V5d29yZH1gLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgc2NoZW1hOiBzY2hbc2NoZW1hUHJvcF0sXG4gICAgICAgICAgICAgICAgc2NoZW1hUGF0aDogKDAsIGNvZGVnZW5fMS5fKSBgJHtpdC5zY2hlbWFQYXRofSR7KDAsIGNvZGVnZW5fMS5nZXRQcm9wZXJ0eSkoa2V5d29yZCl9JHsoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KShzY2hlbWFQcm9wKX1gLFxuICAgICAgICAgICAgICAgIGVyclNjaGVtYVBhdGg6IGAke2l0LmVyclNjaGVtYVBhdGh9LyR7a2V5d29yZH0vJHsoMCwgdXRpbF8xLmVzY2FwZUZyYWdtZW50KShzY2hlbWFQcm9wKX1gLFxuICAgICAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChzY2hlbWFQYXRoID09PSB1bmRlZmluZWQgfHwgZXJyU2NoZW1hUGF0aCA9PT0gdW5kZWZpbmVkIHx8IHRvcFNjaGVtYVJlZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wic2NoZW1hUGF0aFwiLCBcImVyclNjaGVtYVBhdGhcIiBhbmQgXCJ0b3BTY2hlbWFSZWZcIiBhcmUgcmVxdWlyZWQgd2l0aCBcInNjaGVtYVwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNjaGVtYSxcbiAgICAgICAgICAgIHNjaGVtYVBhdGgsXG4gICAgICAgICAgICB0b3BTY2hlbWFSZWYsXG4gICAgICAgICAgICBlcnJTY2hlbWFQYXRoLFxuICAgICAgICB9O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2VpdGhlciBcImtleXdvcmRcIiBvciBcInNjaGVtYVwiIG11c3QgYmUgcGFzc2VkJyk7XG59XG5leHBvcnRzLmdldFN1YnNjaGVtYSA9IGdldFN1YnNjaGVtYTtcbmZ1bmN0aW9uIGV4dGVuZFN1YnNjaGVtYURhdGEoc3Vic2NoZW1hLCBpdCwgeyBkYXRhUHJvcCwgZGF0YVByb3BUeXBlOiBkcFR5cGUsIGRhdGEsIGRhdGFUeXBlcywgcHJvcGVydHlOYW1lIH0pIHtcbiAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkICYmIGRhdGFQcm9wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdib3RoIFwiZGF0YVwiIGFuZCBcImRhdGFQcm9wXCIgcGFzc2VkLCBvbmx5IG9uZSBhbGxvd2VkJyk7XG4gICAgfVxuICAgIGNvbnN0IHsgZ2VuIH0gPSBpdDtcbiAgICBpZiAoZGF0YVByb3AgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCB7IGVycm9yUGF0aCwgZGF0YVBhdGhBcnIsIG9wdHMgfSA9IGl0O1xuICAgICAgICBjb25zdCBuZXh0RGF0YSA9IGdlbi5sZXQoXCJkYXRhXCIsICgwLCBjb2RlZ2VuXzEuXykgYCR7aXQuZGF0YX0keygwLCBjb2RlZ2VuXzEuZ2V0UHJvcGVydHkpKGRhdGFQcm9wKX1gLCB0cnVlKTtcbiAgICAgICAgZGF0YUNvbnRleHRQcm9wcyhuZXh0RGF0YSk7XG4gICAgICAgIHN1YnNjaGVtYS5lcnJvclBhdGggPSAoMCwgY29kZWdlbl8xLnN0cikgYCR7ZXJyb3JQYXRofSR7KDAsIHV0aWxfMS5nZXRFcnJvclBhdGgpKGRhdGFQcm9wLCBkcFR5cGUsIG9wdHMuanNQcm9wZXJ0eVN5bnRheCl9YDtcbiAgICAgICAgc3Vic2NoZW1hLnBhcmVudERhdGFQcm9wZXJ0eSA9ICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YVByb3B9YDtcbiAgICAgICAgc3Vic2NoZW1hLmRhdGFQYXRoQXJyID0gWy4uLmRhdGFQYXRoQXJyLCBzdWJzY2hlbWEucGFyZW50RGF0YVByb3BlcnR5XTtcbiAgICB9XG4gICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBuZXh0RGF0YSA9IGRhdGEgaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSA/IGRhdGEgOiBnZW4ubGV0KFwiZGF0YVwiLCBkYXRhLCB0cnVlKTsgLy8gcmVwbGFjZWFibGUgaWYgdXNlZCBvbmNlP1xuICAgICAgICBkYXRhQ29udGV4dFByb3BzKG5leHREYXRhKTtcbiAgICAgICAgaWYgKHByb3BlcnR5TmFtZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgc3Vic2NoZW1hLnByb3BlcnR5TmFtZSA9IHByb3BlcnR5TmFtZTtcbiAgICAgICAgLy8gVE9ETyBzb21ldGhpbmcgaXMgcG9zc2libHkgd3JvbmcgaGVyZSB3aXRoIG5vdCBjaGFuZ2luZyBwYXJlbnREYXRhUHJvcGVydHkgYW5kIG5vdCBhcHBlbmRpbmcgZGF0YVBhdGhBcnJcbiAgICB9XG4gICAgaWYgKGRhdGFUeXBlcylcbiAgICAgICAgc3Vic2NoZW1hLmRhdGFUeXBlcyA9IGRhdGFUeXBlcztcbiAgICBmdW5jdGlvbiBkYXRhQ29udGV4dFByb3BzKF9uZXh0RGF0YSkge1xuICAgICAgICBzdWJzY2hlbWEuZGF0YSA9IF9uZXh0RGF0YTtcbiAgICAgICAgc3Vic2NoZW1hLmRhdGFMZXZlbCA9IGl0LmRhdGFMZXZlbCArIDE7XG4gICAgICAgIHN1YnNjaGVtYS5kYXRhVHlwZXMgPSBbXTtcbiAgICAgICAgaXQuZGVmaW5lZFByb3BlcnRpZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHN1YnNjaGVtYS5wYXJlbnREYXRhID0gaXQuZGF0YTtcbiAgICAgICAgc3Vic2NoZW1hLmRhdGFOYW1lcyA9IFsuLi5pdC5kYXRhTmFtZXMsIF9uZXh0RGF0YV07XG4gICAgfVxufVxuZXhwb3J0cy5leHRlbmRTdWJzY2hlbWFEYXRhID0gZXh0ZW5kU3Vic2NoZW1hRGF0YTtcbmZ1bmN0aW9uIGV4dGVuZFN1YnNjaGVtYU1vZGUoc3Vic2NoZW1hLCB7IGp0ZERpc2NyaW1pbmF0b3IsIGp0ZE1ldGFkYXRhLCBjb21wb3NpdGVSdWxlLCBjcmVhdGVFcnJvcnMsIGFsbEVycm9ycyB9KSB7XG4gICAgaWYgKGNvbXBvc2l0ZVJ1bGUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgc3Vic2NoZW1hLmNvbXBvc2l0ZVJ1bGUgPSBjb21wb3NpdGVSdWxlO1xuICAgIGlmIChjcmVhdGVFcnJvcnMgIT09IHVuZGVmaW5lZClcbiAgICAgICAgc3Vic2NoZW1hLmNyZWF0ZUVycm9ycyA9IGNyZWF0ZUVycm9ycztcbiAgICBpZiAoYWxsRXJyb3JzICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHN1YnNjaGVtYS5hbGxFcnJvcnMgPSBhbGxFcnJvcnM7XG4gICAgc3Vic2NoZW1hLmp0ZERpc2NyaW1pbmF0b3IgPSBqdGREaXNjcmltaW5hdG9yOyAvLyBub3QgaW5oZXJpdGVkXG4gICAgc3Vic2NoZW1hLmp0ZE1ldGFkYXRhID0ganRkTWV0YWRhdGE7IC8vIG5vdCBpbmhlcml0ZWRcbn1cbmV4cG9ydHMuZXh0ZW5kU3Vic2NoZW1hTW9kZSA9IGV4dGVuZFN1YnNjaGVtYU1vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdWJzY2hlbWEuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBkbyBub3QgZWRpdCAuanMgZmlsZXMgZGlyZWN0bHkgLSBlZGl0IHNyYy9pbmRleC5qc3RcblxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXF1YWwoYSwgYikge1xuICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWU7XG5cbiAgaWYgKGEgJiYgYiAmJiB0eXBlb2YgYSA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgYiA9PSAnb2JqZWN0Jykge1xuICAgIGlmIChhLmNvbnN0cnVjdG9yICE9PSBiLmNvbnN0cnVjdG9yKSByZXR1cm4gZmFsc2U7XG5cbiAgICB2YXIgbGVuZ3RoLCBpLCBrZXlzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggIT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOylcbiAgICAgICAgaWYgKCFlcXVhbChhW2ldLCBiW2ldKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG5cblxuICAgIGlmIChhLmNvbnN0cnVjdG9yID09PSBSZWdFeHApIHJldHVybiBhLnNvdXJjZSA9PT0gYi5zb3VyY2UgJiYgYS5mbGFncyA9PT0gYi5mbGFncztcbiAgICBpZiAoYS52YWx1ZU9mICE9PSBPYmplY3QucHJvdG90eXBlLnZhbHVlT2YpIHJldHVybiBhLnZhbHVlT2YoKSA9PT0gYi52YWx1ZU9mKCk7XG4gICAgaWYgKGEudG9TdHJpbmcgIT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpIHJldHVybiBhLnRvU3RyaW5nKCkgPT09IGIudG9TdHJpbmcoKTtcblxuICAgIGtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoICE9PSBPYmplY3Qua2V5cyhiKS5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOylcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIGtleXNbaV0pKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoIWVxdWFsKGFba2V5XSwgYltrZXldKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gdHJ1ZSBpZiBib3RoIE5hTiwgZmFsc2Ugb3RoZXJ3aXNlXG4gIHJldHVybiBhIT09YSAmJiBiIT09Yjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB0cmF2ZXJzZSA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNjaGVtYSwgb3B0cywgY2IpIHtcbiAgLy8gTGVnYWN5IHN1cHBvcnQgZm9yIHYwLjMuMSBhbmQgZWFybGllci5cbiAgaWYgKHR5cGVvZiBvcHRzID09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG5cbiAgY2IgPSBvcHRzLmNiIHx8IGNiO1xuICB2YXIgcHJlID0gKHR5cGVvZiBjYiA9PSAnZnVuY3Rpb24nKSA/IGNiIDogY2IucHJlIHx8IGZ1bmN0aW9uKCkge307XG4gIHZhciBwb3N0ID0gY2IucG9zdCB8fCBmdW5jdGlvbigpIHt9O1xuXG4gIF90cmF2ZXJzZShvcHRzLCBwcmUsIHBvc3QsIHNjaGVtYSwgJycsIHNjaGVtYSk7XG59O1xuXG5cbnRyYXZlcnNlLmtleXdvcmRzID0ge1xuICBhZGRpdGlvbmFsSXRlbXM6IHRydWUsXG4gIGl0ZW1zOiB0cnVlLFxuICBjb250YWluczogdHJ1ZSxcbiAgYWRkaXRpb25hbFByb3BlcnRpZXM6IHRydWUsXG4gIHByb3BlcnR5TmFtZXM6IHRydWUsXG4gIG5vdDogdHJ1ZSxcbiAgaWY6IHRydWUsXG4gIHRoZW46IHRydWUsXG4gIGVsc2U6IHRydWVcbn07XG5cbnRyYXZlcnNlLmFycmF5S2V5d29yZHMgPSB7XG4gIGl0ZW1zOiB0cnVlLFxuICBhbGxPZjogdHJ1ZSxcbiAgYW55T2Y6IHRydWUsXG4gIG9uZU9mOiB0cnVlXG59O1xuXG50cmF2ZXJzZS5wcm9wc0tleXdvcmRzID0ge1xuICAkZGVmczogdHJ1ZSxcbiAgZGVmaW5pdGlvbnM6IHRydWUsXG4gIHByb3BlcnRpZXM6IHRydWUsXG4gIHBhdHRlcm5Qcm9wZXJ0aWVzOiB0cnVlLFxuICBkZXBlbmRlbmNpZXM6IHRydWVcbn07XG5cbnRyYXZlcnNlLnNraXBLZXl3b3JkcyA9IHtcbiAgZGVmYXVsdDogdHJ1ZSxcbiAgZW51bTogdHJ1ZSxcbiAgY29uc3Q6IHRydWUsXG4gIHJlcXVpcmVkOiB0cnVlLFxuICBtYXhpbXVtOiB0cnVlLFxuICBtaW5pbXVtOiB0cnVlLFxuICBleGNsdXNpdmVNYXhpbXVtOiB0cnVlLFxuICBleGNsdXNpdmVNaW5pbXVtOiB0cnVlLFxuICBtdWx0aXBsZU9mOiB0cnVlLFxuICBtYXhMZW5ndGg6IHRydWUsXG4gIG1pbkxlbmd0aDogdHJ1ZSxcbiAgcGF0dGVybjogdHJ1ZSxcbiAgZm9ybWF0OiB0cnVlLFxuICBtYXhJdGVtczogdHJ1ZSxcbiAgbWluSXRlbXM6IHRydWUsXG4gIHVuaXF1ZUl0ZW1zOiB0cnVlLFxuICBtYXhQcm9wZXJ0aWVzOiB0cnVlLFxuICBtaW5Qcm9wZXJ0aWVzOiB0cnVlXG59O1xuXG5cbmZ1bmN0aW9uIF90cmF2ZXJzZShvcHRzLCBwcmUsIHBvc3QsIHNjaGVtYSwganNvblB0ciwgcm9vdFNjaGVtYSwgcGFyZW50SnNvblB0ciwgcGFyZW50S2V5d29yZCwgcGFyZW50U2NoZW1hLCBrZXlJbmRleCkge1xuICBpZiAoc2NoZW1hICYmIHR5cGVvZiBzY2hlbWEgPT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoc2NoZW1hKSkge1xuICAgIHByZShzY2hlbWEsIGpzb25QdHIsIHJvb3RTY2hlbWEsIHBhcmVudEpzb25QdHIsIHBhcmVudEtleXdvcmQsIHBhcmVudFNjaGVtYSwga2V5SW5kZXgpO1xuICAgIGZvciAodmFyIGtleSBpbiBzY2hlbWEpIHtcbiAgICAgIHZhciBzY2ggPSBzY2hlbWFba2V5XTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaCkpIHtcbiAgICAgICAgaWYgKGtleSBpbiB0cmF2ZXJzZS5hcnJheUtleXdvcmRzKSB7XG4gICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHNjaC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIF90cmF2ZXJzZShvcHRzLCBwcmUsIHBvc3QsIHNjaFtpXSwganNvblB0ciArICcvJyArIGtleSArICcvJyArIGksIHJvb3RTY2hlbWEsIGpzb25QdHIsIGtleSwgc2NoZW1hLCBpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChrZXkgaW4gdHJhdmVyc2UucHJvcHNLZXl3b3Jkcykge1xuICAgICAgICBpZiAoc2NoICYmIHR5cGVvZiBzY2ggPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIHNjaClcbiAgICAgICAgICAgIF90cmF2ZXJzZShvcHRzLCBwcmUsIHBvc3QsIHNjaFtwcm9wXSwganNvblB0ciArICcvJyArIGtleSArICcvJyArIGVzY2FwZUpzb25QdHIocHJvcCksIHJvb3RTY2hlbWEsIGpzb25QdHIsIGtleSwgc2NoZW1hLCBwcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChrZXkgaW4gdHJhdmVyc2Uua2V5d29yZHMgfHwgKG9wdHMuYWxsS2V5cyAmJiAhKGtleSBpbiB0cmF2ZXJzZS5za2lwS2V5d29yZHMpKSkge1xuICAgICAgICBfdHJhdmVyc2Uob3B0cywgcHJlLCBwb3N0LCBzY2gsIGpzb25QdHIgKyAnLycgKyBrZXksIHJvb3RTY2hlbWEsIGpzb25QdHIsIGtleSwgc2NoZW1hKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcG9zdChzY2hlbWEsIGpzb25QdHIsIHJvb3RTY2hlbWEsIHBhcmVudEpzb25QdHIsIHBhcmVudEtleXdvcmQsIHBhcmVudFNjaGVtYSwga2V5SW5kZXgpO1xuICB9XG59XG5cblxuZnVuY3Rpb24gZXNjYXBlSnNvblB0cihzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9+L2csICd+MCcpLnJlcGxhY2UoL1xcLy9nLCAnfjEnKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRTY2hlbWFSZWZzID0gZXhwb3J0cy5yZXNvbHZlVXJsID0gZXhwb3J0cy5ub3JtYWxpemVJZCA9IGV4cG9ydHMuX2dldEZ1bGxQYXRoID0gZXhwb3J0cy5nZXRGdWxsUGF0aCA9IGV4cG9ydHMuaW5saW5lUmVmID0gdm9pZCAwO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbmNvbnN0IGVxdWFsID0gcmVxdWlyZShcImZhc3QtZGVlcC1lcXVhbFwiKTtcbmNvbnN0IHRyYXZlcnNlID0gcmVxdWlyZShcImpzb24tc2NoZW1hLXRyYXZlcnNlXCIpO1xuLy8gVE9ETyByZWZhY3RvciB0byB1c2Uga2V5d29yZCBkZWZpbml0aW9uc1xuY29uc3QgU0lNUExFX0lOTElORUQgPSBuZXcgU2V0KFtcbiAgICBcInR5cGVcIixcbiAgICBcImZvcm1hdFwiLFxuICAgIFwicGF0dGVyblwiLFxuICAgIFwibWF4TGVuZ3RoXCIsXG4gICAgXCJtaW5MZW5ndGhcIixcbiAgICBcIm1heFByb3BlcnRpZXNcIixcbiAgICBcIm1pblByb3BlcnRpZXNcIixcbiAgICBcIm1heEl0ZW1zXCIsXG4gICAgXCJtaW5JdGVtc1wiLFxuICAgIFwibWF4aW11bVwiLFxuICAgIFwibWluaW11bVwiLFxuICAgIFwidW5pcXVlSXRlbXNcIixcbiAgICBcIm11bHRpcGxlT2ZcIixcbiAgICBcInJlcXVpcmVkXCIsXG4gICAgXCJlbnVtXCIsXG4gICAgXCJjb25zdFwiLFxuXSk7XG5mdW5jdGlvbiBpbmxpbmVSZWYoc2NoZW1hLCBsaW1pdCA9IHRydWUpIHtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKGxpbWl0ID09PSB0cnVlKVxuICAgICAgICByZXR1cm4gIWhhc1JlZihzY2hlbWEpO1xuICAgIGlmICghbGltaXQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gY291bnRLZXlzKHNjaGVtYSkgPD0gbGltaXQ7XG59XG5leHBvcnRzLmlubGluZVJlZiA9IGlubGluZVJlZjtcbmNvbnN0IFJFRl9LRVlXT1JEUyA9IG5ldyBTZXQoW1xuICAgIFwiJHJlZlwiLFxuICAgIFwiJHJlY3Vyc2l2ZVJlZlwiLFxuICAgIFwiJHJlY3Vyc2l2ZUFuY2hvclwiLFxuICAgIFwiJGR5bmFtaWNSZWZcIixcbiAgICBcIiRkeW5hbWljQW5jaG9yXCIsXG5dKTtcbmZ1bmN0aW9uIGhhc1JlZihzY2hlbWEpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIHtcbiAgICAgICAgaWYgKFJFRl9LRVlXT1JEUy5oYXMoa2V5KSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjb25zdCBzY2ggPSBzY2hlbWFba2V5XTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoKSAmJiBzY2guc29tZShoYXNSZWYpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoID09IFwib2JqZWN0XCIgJiYgaGFzUmVmKHNjaCkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY291bnRLZXlzKHNjaGVtYSkge1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSB7XG4gICAgICAgIGlmIChrZXkgPT09IFwiJHJlZlwiKVxuICAgICAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgICBjb3VudCsrO1xuICAgICAgICBpZiAoU0lNUExFX0lOTElORUQuaGFzKGtleSkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWFba2V5XSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAoMCwgdXRpbF8xLmVhY2hJdGVtKShzY2hlbWFba2V5XSwgKHNjaCkgPT4gKGNvdW50ICs9IGNvdW50S2V5cyhzY2gpKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvdW50ID09PSBJbmZpbml0eSlcbiAgICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICB9XG4gICAgcmV0dXJuIGNvdW50O1xufVxuZnVuY3Rpb24gZ2V0RnVsbFBhdGgocmVzb2x2ZXIsIGlkID0gXCJcIiwgbm9ybWFsaXplKSB7XG4gICAgaWYgKG5vcm1hbGl6ZSAhPT0gZmFsc2UpXG4gICAgICAgIGlkID0gbm9ybWFsaXplSWQoaWQpO1xuICAgIGNvbnN0IHAgPSByZXNvbHZlci5wYXJzZShpZCk7XG4gICAgcmV0dXJuIF9nZXRGdWxsUGF0aChyZXNvbHZlciwgcCk7XG59XG5leHBvcnRzLmdldEZ1bGxQYXRoID0gZ2V0RnVsbFBhdGg7XG5mdW5jdGlvbiBfZ2V0RnVsbFBhdGgocmVzb2x2ZXIsIHApIHtcbiAgICBjb25zdCBzZXJpYWxpemVkID0gcmVzb2x2ZXIuc2VyaWFsaXplKHApO1xuICAgIHJldHVybiBzZXJpYWxpemVkLnNwbGl0KFwiI1wiKVswXSArIFwiI1wiO1xufVxuZXhwb3J0cy5fZ2V0RnVsbFBhdGggPSBfZ2V0RnVsbFBhdGg7XG5jb25zdCBUUkFJTElOR19TTEFTSF9IQVNIID0gLyNcXC8/JC87XG5mdW5jdGlvbiBub3JtYWxpemVJZChpZCkge1xuICAgIHJldHVybiBpZCA/IGlkLnJlcGxhY2UoVFJBSUxJTkdfU0xBU0hfSEFTSCwgXCJcIikgOiBcIlwiO1xufVxuZXhwb3J0cy5ub3JtYWxpemVJZCA9IG5vcm1hbGl6ZUlkO1xuZnVuY3Rpb24gcmVzb2x2ZVVybChyZXNvbHZlciwgYmFzZUlkLCBpZCkge1xuICAgIGlkID0gbm9ybWFsaXplSWQoaWQpO1xuICAgIHJldHVybiByZXNvbHZlci5yZXNvbHZlKGJhc2VJZCwgaWQpO1xufVxuZXhwb3J0cy5yZXNvbHZlVXJsID0gcmVzb2x2ZVVybDtcbmNvbnN0IEFOQ0hPUiA9IC9eW2Etel9dWy1hLXowLTkuX10qJC9pO1xuZnVuY3Rpb24gZ2V0U2NoZW1hUmVmcyhzY2hlbWEsIGJhc2VJZCkge1xuICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKVxuICAgICAgICByZXR1cm4ge307XG4gICAgY29uc3QgeyBzY2hlbWFJZCwgdXJpUmVzb2x2ZXIgfSA9IHRoaXMub3B0cztcbiAgICBjb25zdCBzY2hJZCA9IG5vcm1hbGl6ZUlkKHNjaGVtYVtzY2hlbWFJZF0gfHwgYmFzZUlkKTtcbiAgICBjb25zdCBiYXNlSWRzID0geyBcIlwiOiBzY2hJZCB9O1xuICAgIGNvbnN0IHBhdGhQcmVmaXggPSBnZXRGdWxsUGF0aCh1cmlSZXNvbHZlciwgc2NoSWQsIGZhbHNlKTtcbiAgICBjb25zdCBsb2NhbFJlZnMgPSB7fTtcbiAgICBjb25zdCBzY2hlbWFSZWZzID0gbmV3IFNldCgpO1xuICAgIHRyYXZlcnNlKHNjaGVtYSwgeyBhbGxLZXlzOiB0cnVlIH0sIChzY2gsIGpzb25QdHIsIF8sIHBhcmVudEpzb25QdHIpID0+IHtcbiAgICAgICAgaWYgKHBhcmVudEpzb25QdHIgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgZnVsbFBhdGggPSBwYXRoUHJlZml4ICsganNvblB0cjtcbiAgICAgICAgbGV0IGlubmVyQmFzZUlkID0gYmFzZUlkc1twYXJlbnRKc29uUHRyXTtcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hbc2NoZW1hSWRdID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICBpbm5lckJhc2VJZCA9IGFkZFJlZi5jYWxsKHRoaXMsIHNjaFtzY2hlbWFJZF0pO1xuICAgICAgICBhZGRBbmNob3IuY2FsbCh0aGlzLCBzY2guJGFuY2hvcik7XG4gICAgICAgIGFkZEFuY2hvci5jYWxsKHRoaXMsIHNjaC4kZHluYW1pY0FuY2hvcik7XG4gICAgICAgIGJhc2VJZHNbanNvblB0cl0gPSBpbm5lckJhc2VJZDtcbiAgICAgICAgZnVuY3Rpb24gYWRkUmVmKHJlZikge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZFxuICAgICAgICAgICAgY29uc3QgX3Jlc29sdmUgPSB0aGlzLm9wdHMudXJpUmVzb2x2ZXIucmVzb2x2ZTtcbiAgICAgICAgICAgIHJlZiA9IG5vcm1hbGl6ZUlkKGlubmVyQmFzZUlkID8gX3Jlc29sdmUoaW5uZXJCYXNlSWQsIHJlZikgOiByZWYpO1xuICAgICAgICAgICAgaWYgKHNjaGVtYVJlZnMuaGFzKHJlZikpXG4gICAgICAgICAgICAgICAgdGhyb3cgYW1iaWd1b3MocmVmKTtcbiAgICAgICAgICAgIHNjaGVtYVJlZnMuYWRkKHJlZik7XG4gICAgICAgICAgICBsZXQgc2NoT3JSZWYgPSB0aGlzLnJlZnNbcmVmXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoT3JSZWYgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICBzY2hPclJlZiA9IHRoaXMucmVmc1tzY2hPclJlZl07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNjaE9yUmVmID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBjaGVja0FtYmlndW9zUmVmKHNjaCwgc2NoT3JSZWYuc2NoZW1hLCByZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVmICE9PSBub3JtYWxpemVJZChmdWxsUGF0aCkpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVmWzBdID09PSBcIiNcIikge1xuICAgICAgICAgICAgICAgICAgICBjaGVja0FtYmlndW9zUmVmKHNjaCwgbG9jYWxSZWZzW3JlZl0sIHJlZik7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsUmVmc1tyZWZdID0gc2NoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWZzW3JlZl0gPSBmdWxsUGF0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVmO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFkZEFuY2hvcihhbmNob3IpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYW5jaG9yID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFOQ0hPUi50ZXN0KGFuY2hvcikpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBhbmNob3IgXCIke2FuY2hvcn1cImApO1xuICAgICAgICAgICAgICAgIGFkZFJlZi5jYWxsKHRoaXMsIGAjJHthbmNob3J9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbG9jYWxSZWZzO1xuICAgIGZ1bmN0aW9uIGNoZWNrQW1iaWd1b3NSZWYoc2NoMSwgc2NoMiwgcmVmKSB7XG4gICAgICAgIGlmIChzY2gyICE9PSB1bmRlZmluZWQgJiYgIWVxdWFsKHNjaDEsIHNjaDIpKVxuICAgICAgICAgICAgdGhyb3cgYW1iaWd1b3MocmVmKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYW1iaWd1b3MocmVmKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoYHJlZmVyZW5jZSBcIiR7cmVmfVwiIHJlc29sdmVzIHRvIG1vcmUgdGhhbiBvbmUgc2NoZW1hYCk7XG4gICAgfVxufVxuZXhwb3J0cy5nZXRTY2hlbWFSZWZzID0gZ2V0U2NoZW1hUmVmcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldERhdGEgPSBleHBvcnRzLktleXdvcmRDeHQgPSBleHBvcnRzLnZhbGlkYXRlRnVuY3Rpb25Db2RlID0gdm9pZCAwO1xuY29uc3QgYm9vbFNjaGVtYV8xID0gcmVxdWlyZShcIi4vYm9vbFNjaGVtYVwiKTtcbmNvbnN0IGRhdGFUeXBlXzEgPSByZXF1aXJlKFwiLi9kYXRhVHlwZVwiKTtcbmNvbnN0IGFwcGxpY2FiaWxpdHlfMSA9IHJlcXVpcmUoXCIuL2FwcGxpY2FiaWxpdHlcIik7XG5jb25zdCBkYXRhVHlwZV8yID0gcmVxdWlyZShcIi4vZGF0YVR5cGVcIik7XG5jb25zdCBkZWZhdWx0c18xID0gcmVxdWlyZShcIi4vZGVmYXVsdHNcIik7XG5jb25zdCBrZXl3b3JkXzEgPSByZXF1aXJlKFwiLi9rZXl3b3JkXCIpO1xuY29uc3Qgc3Vic2NoZW1hXzEgPSByZXF1aXJlKFwiLi9zdWJzY2hlbWFcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vY29kZWdlblwiKTtcbmNvbnN0IG5hbWVzXzEgPSByZXF1aXJlKFwiLi4vbmFtZXNcIik7XG5jb25zdCByZXNvbHZlXzEgPSByZXF1aXJlKFwiLi4vcmVzb2x2ZVwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xuLy8gc2NoZW1hIGNvbXBpbGF0aW9uIC0gZ2VuZXJhdGVzIHZhbGlkYXRpb24gZnVuY3Rpb24sIHN1YnNjaGVtYUNvZGUgKGJlbG93KSBpcyB1c2VkIGZvciBzdWJzY2hlbWFzXG5mdW5jdGlvbiB2YWxpZGF0ZUZ1bmN0aW9uQ29kZShpdCkge1xuICAgIGlmIChpc1NjaGVtYU9iaihpdCkpIHtcbiAgICAgICAgY2hlY2tLZXl3b3JkcyhpdCk7XG4gICAgICAgIGlmIChzY2hlbWFDeHRIYXNSdWxlcyhpdCkpIHtcbiAgICAgICAgICAgIHRvcFNjaGVtYU9iakNvZGUoaXQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhbGlkYXRlRnVuY3Rpb24oaXQsICgpID0+ICgwLCBib29sU2NoZW1hXzEudG9wQm9vbE9yRW1wdHlTY2hlbWEpKGl0KSk7XG59XG5leHBvcnRzLnZhbGlkYXRlRnVuY3Rpb25Db2RlID0gdmFsaWRhdGVGdW5jdGlvbkNvZGU7XG5mdW5jdGlvbiB2YWxpZGF0ZUZ1bmN0aW9uKHsgZ2VuLCB2YWxpZGF0ZU5hbWUsIHNjaGVtYSwgc2NoZW1hRW52LCBvcHRzIH0sIGJvZHkpIHtcbiAgICBpZiAob3B0cy5jb2RlLmVzNSkge1xuICAgICAgICBnZW4uZnVuYyh2YWxpZGF0ZU5hbWUsICgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LmRhdGF9LCAke25hbWVzXzEuZGVmYXVsdC52YWxDeHR9YCwgc2NoZW1hRW52LiRhc3luYywgKCkgPT4ge1xuICAgICAgICAgICAgZ2VuLmNvZGUoKDAsIGNvZGVnZW5fMS5fKSBgXCJ1c2Ugc3RyaWN0XCI7ICR7ZnVuY1NvdXJjZVVybChzY2hlbWEsIG9wdHMpfWApO1xuICAgICAgICAgICAgZGVzdHJ1Y3R1cmVWYWxDeHRFUzUoZ2VuLCBvcHRzKTtcbiAgICAgICAgICAgIGdlbi5jb2RlKGJvZHkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdlbi5mdW5jKHZhbGlkYXRlTmFtZSwgKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQuZGF0YX0sICR7ZGVzdHJ1Y3R1cmVWYWxDeHQob3B0cyl9YCwgc2NoZW1hRW52LiRhc3luYywgKCkgPT4gZ2VuLmNvZGUoZnVuY1NvdXJjZVVybChzY2hlbWEsIG9wdHMpKS5jb2RlKGJvZHkpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkZXN0cnVjdHVyZVZhbEN4dChvcHRzKSB7XG4gICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuXykgYHske25hbWVzXzEuZGVmYXVsdC5pbnN0YW5jZVBhdGh9PVwiXCIsICR7bmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGF9LCAke25hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhUHJvcGVydHl9LCAke25hbWVzXzEuZGVmYXVsdC5yb290RGF0YX09JHtuYW1lc18xLmRlZmF1bHQuZGF0YX0ke29wdHMuZHluYW1pY1JlZiA/ICgwLCBjb2RlZ2VuXzEuXykgYCwgJHtuYW1lc18xLmRlZmF1bHQuZHluYW1pY0FuY2hvcnN9PXt9YCA6IGNvZGVnZW5fMS5uaWx9fT17fWA7XG59XG5mdW5jdGlvbiBkZXN0cnVjdHVyZVZhbEN4dEVTNShnZW4sIG9wdHMpIHtcbiAgICBnZW4uaWYobmFtZXNfMS5kZWZhdWx0LnZhbEN4dCwgKCkgPT4ge1xuICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5pbnN0YW5jZVBhdGgsICgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LnZhbEN4dH0uJHtuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRofWApO1xuICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhLCAoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC52YWxDeHR9LiR7bmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGF9YCk7XG4gICAgICAgIGdlbi52YXIobmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGFQcm9wZXJ0eSwgKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQudmFsQ3h0fS4ke25hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhUHJvcGVydHl9YCk7XG4gICAgICAgIGdlbi52YXIobmFtZXNfMS5kZWZhdWx0LnJvb3REYXRhLCAoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC52YWxDeHR9LiR7bmFtZXNfMS5kZWZhdWx0LnJvb3REYXRhfWApO1xuICAgICAgICBpZiAob3B0cy5keW5hbWljUmVmKVxuICAgICAgICAgICAgZ2VuLnZhcihuYW1lc18xLmRlZmF1bHQuZHluYW1pY0FuY2hvcnMsICgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LnZhbEN4dH0uJHtuYW1lc18xLmRlZmF1bHQuZHluYW1pY0FuY2hvcnN9YCk7XG4gICAgfSwgKCkgPT4ge1xuICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5pbnN0YW5jZVBhdGgsICgwLCBjb2RlZ2VuXzEuXykgYFwiXCJgKTtcbiAgICAgICAgZ2VuLnZhcihuYW1lc18xLmRlZmF1bHQucGFyZW50RGF0YSwgKDAsIGNvZGVnZW5fMS5fKSBgdW5kZWZpbmVkYCk7XG4gICAgICAgIGdlbi52YXIobmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGFQcm9wZXJ0eSwgKDAsIGNvZGVnZW5fMS5fKSBgdW5kZWZpbmVkYCk7XG4gICAgICAgIGdlbi52YXIobmFtZXNfMS5kZWZhdWx0LnJvb3REYXRhLCBuYW1lc18xLmRlZmF1bHQuZGF0YSk7XG4gICAgICAgIGlmIChvcHRzLmR5bmFtaWNSZWYpXG4gICAgICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5keW5hbWljQW5jaG9ycywgKDAsIGNvZGVnZW5fMS5fKSBge31gKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHRvcFNjaGVtYU9iakNvZGUoaXQpIHtcbiAgICBjb25zdCB7IHNjaGVtYSwgb3B0cywgZ2VuIH0gPSBpdDtcbiAgICB2YWxpZGF0ZUZ1bmN0aW9uKGl0LCAoKSA9PiB7XG4gICAgICAgIGlmIChvcHRzLiRjb21tZW50ICYmIHNjaGVtYS4kY29tbWVudClcbiAgICAgICAgICAgIGNvbW1lbnRLZXl3b3JkKGl0KTtcbiAgICAgICAgY2hlY2tOb0RlZmF1bHQoaXQpO1xuICAgICAgICBnZW4ubGV0KG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzLCBudWxsKTtcbiAgICAgICAgZ2VuLmxldChuYW1lc18xLmRlZmF1bHQuZXJyb3JzLCAwKTtcbiAgICAgICAgaWYgKG9wdHMudW5ldmFsdWF0ZWQpXG4gICAgICAgICAgICByZXNldEV2YWx1YXRlZChpdCk7XG4gICAgICAgIHR5cGVBbmRLZXl3b3JkcyhpdCk7XG4gICAgICAgIHJldHVyblJlc3VsdHMoaXQpO1xuICAgIH0pO1xuICAgIHJldHVybjtcbn1cbmZ1bmN0aW9uIHJlc2V0RXZhbHVhdGVkKGl0KSB7XG4gICAgLy8gVE9ETyBtYXliZSBzb21lIGhvb2sgdG8gZXhlY3V0ZSBpdCBpbiB0aGUgZW5kIHRvIGNoZWNrIHdoZXRoZXIgcHJvcHMvaXRlbXMgYXJlIE5hbWUsIGFzIGluIGFzc2lnbkV2YWx1YXRlZFxuICAgIGNvbnN0IHsgZ2VuLCB2YWxpZGF0ZU5hbWUgfSA9IGl0O1xuICAgIGl0LmV2YWx1YXRlZCA9IGdlbi5jb25zdChcImV2YWx1YXRlZFwiLCAoMCwgY29kZWdlbl8xLl8pIGAke3ZhbGlkYXRlTmFtZX0uZXZhbHVhdGVkYCk7XG4gICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7aXQuZXZhbHVhdGVkfS5keW5hbWljUHJvcHNgLCAoKSA9PiBnZW4uYXNzaWduKCgwLCBjb2RlZ2VuXzEuXykgYCR7aXQuZXZhbHVhdGVkfS5wcm9wc2AsICgwLCBjb2RlZ2VuXzEuXykgYHVuZGVmaW5lZGApKTtcbiAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtpdC5ldmFsdWF0ZWR9LmR5bmFtaWNJdGVtc2AsICgpID0+IGdlbi5hc3NpZ24oKDAsIGNvZGVnZW5fMS5fKSBgJHtpdC5ldmFsdWF0ZWR9Lml0ZW1zYCwgKDAsIGNvZGVnZW5fMS5fKSBgdW5kZWZpbmVkYCkpO1xufVxuZnVuY3Rpb24gZnVuY1NvdXJjZVVybChzY2hlbWEsIG9wdHMpIHtcbiAgICBjb25zdCBzY2hJZCA9IHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIiAmJiBzY2hlbWFbb3B0cy5zY2hlbWFJZF07XG4gICAgcmV0dXJuIHNjaElkICYmIChvcHRzLmNvZGUuc291cmNlIHx8IG9wdHMuY29kZS5wcm9jZXNzKSA/ICgwLCBjb2RlZ2VuXzEuXykgYC8qIyBzb3VyY2VVUkw9JHtzY2hJZH0gKi9gIDogY29kZWdlbl8xLm5pbDtcbn1cbi8vIHNjaGVtYSBjb21waWxhdGlvbiAtIHRoaXMgZnVuY3Rpb24gaXMgdXNlZCByZWN1cnNpdmVseSB0byBnZW5lcmF0ZSBjb2RlIGZvciBzdWItc2NoZW1hc1xuZnVuY3Rpb24gc3Vic2NoZW1hQ29kZShpdCwgdmFsaWQpIHtcbiAgICBpZiAoaXNTY2hlbWFPYmooaXQpKSB7XG4gICAgICAgIGNoZWNrS2V5d29yZHMoaXQpO1xuICAgICAgICBpZiAoc2NoZW1hQ3h0SGFzUnVsZXMoaXQpKSB7XG4gICAgICAgICAgICBzdWJTY2hlbWFPYmpDb2RlKGl0LCB2YWxpZCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgKDAsIGJvb2xTY2hlbWFfMS5ib29sT3JFbXB0eVNjaGVtYSkoaXQsIHZhbGlkKTtcbn1cbmZ1bmN0aW9uIHNjaGVtYUN4dEhhc1J1bGVzKHsgc2NoZW1hLCBzZWxmIH0pIHtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIilcbiAgICAgICAgcmV0dXJuICFzY2hlbWE7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKVxuICAgICAgICBpZiAoc2VsZi5SVUxFUy5hbGxba2V5XSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzU2NoZW1hT2JqKGl0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBpdC5zY2hlbWEgIT0gXCJib29sZWFuXCI7XG59XG5mdW5jdGlvbiBzdWJTY2hlbWFPYmpDb2RlKGl0LCB2YWxpZCkge1xuICAgIGNvbnN0IHsgc2NoZW1hLCBnZW4sIG9wdHMgfSA9IGl0O1xuICAgIGlmIChvcHRzLiRjb21tZW50ICYmIHNjaGVtYS4kY29tbWVudClcbiAgICAgICAgY29tbWVudEtleXdvcmQoaXQpO1xuICAgIHVwZGF0ZUNvbnRleHQoaXQpO1xuICAgIGNoZWNrQXN5bmNTY2hlbWEoaXQpO1xuICAgIGNvbnN0IGVycnNDb3VudCA9IGdlbi5jb25zdChcIl9lcnJzXCIsIG5hbWVzXzEuZGVmYXVsdC5lcnJvcnMpO1xuICAgIHR5cGVBbmRLZXl3b3JkcyhpdCwgZXJyc0NvdW50KTtcbiAgICAvLyBUT0RPIHZhclxuICAgIGdlbi52YXIodmFsaWQsICgwLCBjb2RlZ2VuXzEuXykgYCR7ZXJyc0NvdW50fSA9PT0gJHtuYW1lc18xLmRlZmF1bHQuZXJyb3JzfWApO1xufVxuZnVuY3Rpb24gY2hlY2tLZXl3b3JkcyhpdCkge1xuICAgICgwLCB1dGlsXzEuY2hlY2tVbmtub3duUnVsZXMpKGl0KTtcbiAgICBjaGVja1JlZnNBbmRLZXl3b3JkcyhpdCk7XG59XG5mdW5jdGlvbiB0eXBlQW5kS2V5d29yZHMoaXQsIGVycnNDb3VudCkge1xuICAgIGlmIChpdC5vcHRzLmp0ZClcbiAgICAgICAgcmV0dXJuIHNjaGVtYUtleXdvcmRzKGl0LCBbXSwgZmFsc2UsIGVycnNDb3VudCk7XG4gICAgY29uc3QgdHlwZXMgPSAoMCwgZGF0YVR5cGVfMS5nZXRTY2hlbWFUeXBlcykoaXQuc2NoZW1hKTtcbiAgICBjb25zdCBjaGVja2VkVHlwZXMgPSAoMCwgZGF0YVR5cGVfMS5jb2VyY2VBbmRDaGVja0RhdGFUeXBlKShpdCwgdHlwZXMpO1xuICAgIHNjaGVtYUtleXdvcmRzKGl0LCB0eXBlcywgIWNoZWNrZWRUeXBlcywgZXJyc0NvdW50KTtcbn1cbmZ1bmN0aW9uIGNoZWNrUmVmc0FuZEtleXdvcmRzKGl0KSB7XG4gICAgY29uc3QgeyBzY2hlbWEsIGVyclNjaGVtYVBhdGgsIG9wdHMsIHNlbGYgfSA9IGl0O1xuICAgIGlmIChzY2hlbWEuJHJlZiAmJiBvcHRzLmlnbm9yZUtleXdvcmRzV2l0aFJlZiAmJiAoMCwgdXRpbF8xLnNjaGVtYUhhc1J1bGVzQnV0UmVmKShzY2hlbWEsIHNlbGYuUlVMRVMpKSB7XG4gICAgICAgIHNlbGYubG9nZ2VyLndhcm4oYCRyZWY6IGtleXdvcmRzIGlnbm9yZWQgaW4gc2NoZW1hIGF0IHBhdGggXCIke2VyclNjaGVtYVBhdGh9XCJgKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja05vRGVmYXVsdChpdCkge1xuICAgIGNvbnN0IHsgc2NoZW1hLCBvcHRzIH0gPSBpdDtcbiAgICBpZiAoc2NoZW1hLmRlZmF1bHQgIT09IHVuZGVmaW5lZCAmJiBvcHRzLnVzZURlZmF1bHRzICYmIG9wdHMuc3RyaWN0U2NoZW1hKSB7XG4gICAgICAgICgwLCB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKShpdCwgXCJkZWZhdWx0IGlzIGlnbm9yZWQgaW4gdGhlIHNjaGVtYSByb290XCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZUNvbnRleHQoaXQpIHtcbiAgICBjb25zdCBzY2hJZCA9IGl0LnNjaGVtYVtpdC5vcHRzLnNjaGVtYUlkXTtcbiAgICBpZiAoc2NoSWQpXG4gICAgICAgIGl0LmJhc2VJZCA9ICgwLCByZXNvbHZlXzEucmVzb2x2ZVVybCkoaXQub3B0cy51cmlSZXNvbHZlciwgaXQuYmFzZUlkLCBzY2hJZCk7XG59XG5mdW5jdGlvbiBjaGVja0FzeW5jU2NoZW1hKGl0KSB7XG4gICAgaWYgKGl0LnNjaGVtYS4kYXN5bmMgJiYgIWl0LnNjaGVtYUVudi4kYXN5bmMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImFzeW5jIHNjaGVtYSBpbiBzeW5jIHNjaGVtYVwiKTtcbn1cbmZ1bmN0aW9uIGNvbW1lbnRLZXl3b3JkKHsgZ2VuLCBzY2hlbWFFbnYsIHNjaGVtYSwgZXJyU2NoZW1hUGF0aCwgb3B0cyB9KSB7XG4gICAgY29uc3QgbXNnID0gc2NoZW1hLiRjb21tZW50O1xuICAgIGlmIChvcHRzLiRjb21tZW50ID09PSB0cnVlKSB7XG4gICAgICAgIGdlbi5jb2RlKCgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LnNlbGZ9LmxvZ2dlci5sb2coJHttc2d9KWApO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Ygb3B0cy4kY29tbWVudCA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29uc3Qgc2NoZW1hUGF0aCA9ICgwLCBjb2RlZ2VuXzEuc3RyKSBgJHtlcnJTY2hlbWFQYXRofS8kY29tbWVudGA7XG4gICAgICAgIGNvbnN0IHJvb3ROYW1lID0gZ2VuLnNjb3BlVmFsdWUoXCJyb290XCIsIHsgcmVmOiBzY2hlbWFFbnYucm9vdCB9KTtcbiAgICAgICAgZ2VuLmNvZGUoKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQuc2VsZn0ub3B0cy4kY29tbWVudCgke21zZ30sICR7c2NoZW1hUGF0aH0sICR7cm9vdE5hbWV9LnNjaGVtYSlgKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZXR1cm5SZXN1bHRzKGl0KSB7XG4gICAgY29uc3QgeyBnZW4sIHNjaGVtYUVudiwgdmFsaWRhdGVOYW1lLCBWYWxpZGF0aW9uRXJyb3IsIG9wdHMgfSA9IGl0O1xuICAgIGlmIChzY2hlbWFFbnYuJGFzeW5jKSB7XG4gICAgICAgIC8vIFRPRE8gYXNzaWduIHVuZXZhbHVhdGVkXG4gICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC5lcnJvcnN9ID09PSAwYCwgKCkgPT4gZ2VuLnJldHVybihuYW1lc18xLmRlZmF1bHQuZGF0YSksICgpID0+IGdlbi50aHJvdygoMCwgY29kZWdlbl8xLl8pIGBuZXcgJHtWYWxpZGF0aW9uRXJyb3J9KCR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9KWApKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdlbi5hc3NpZ24oKDAsIGNvZGVnZW5fMS5fKSBgJHt2YWxpZGF0ZU5hbWV9LmVycm9yc2AsIG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzKTtcbiAgICAgICAgaWYgKG9wdHMudW5ldmFsdWF0ZWQpXG4gICAgICAgICAgICBhc3NpZ25FdmFsdWF0ZWQoaXQpO1xuICAgICAgICBnZW4ucmV0dXJuKCgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LmVycm9yc30gPT09IDBgKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhc3NpZ25FdmFsdWF0ZWQoeyBnZW4sIGV2YWx1YXRlZCwgcHJvcHMsIGl0ZW1zIH0pIHtcbiAgICBpZiAocHJvcHMgaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSlcbiAgICAgICAgZ2VuLmFzc2lnbigoMCwgY29kZWdlbl8xLl8pIGAke2V2YWx1YXRlZH0ucHJvcHNgLCBwcm9wcyk7XG4gICAgaWYgKGl0ZW1zIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUpXG4gICAgICAgIGdlbi5hc3NpZ24oKDAsIGNvZGVnZW5fMS5fKSBgJHtldmFsdWF0ZWR9Lml0ZW1zYCwgaXRlbXMpO1xufVxuZnVuY3Rpb24gc2NoZW1hS2V5d29yZHMoaXQsIHR5cGVzLCB0eXBlRXJyb3JzLCBlcnJzQ291bnQpIHtcbiAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBkYXRhLCBhbGxFcnJvcnMsIG9wdHMsIHNlbGYgfSA9IGl0O1xuICAgIGNvbnN0IHsgUlVMRVMgfSA9IHNlbGY7XG4gICAgaWYgKHNjaGVtYS4kcmVmICYmIChvcHRzLmlnbm9yZUtleXdvcmRzV2l0aFJlZiB8fCAhKDAsIHV0aWxfMS5zY2hlbWFIYXNSdWxlc0J1dFJlZikoc2NoZW1hLCBSVUxFUykpKSB7XG4gICAgICAgIGdlbi5ibG9jaygoKSA9PiBrZXl3b3JkQ29kZShpdCwgXCIkcmVmXCIsIFJVTEVTLmFsbC4kcmVmLmRlZmluaXRpb24pKTsgLy8gVE9ETyB0eXBlY2FzdFxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghb3B0cy5qdGQpXG4gICAgICAgIGNoZWNrU3RyaWN0VHlwZXMoaXQsIHR5cGVzKTtcbiAgICBnZW4uYmxvY2soKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIFJVTEVTLnJ1bGVzKVxuICAgICAgICAgICAgZ3JvdXBLZXl3b3Jkcyhncm91cCk7XG4gICAgICAgIGdyb3VwS2V5d29yZHMoUlVMRVMucG9zdCk7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gZ3JvdXBLZXl3b3Jkcyhncm91cCkge1xuICAgICAgICBpZiAoISgwLCBhcHBsaWNhYmlsaXR5XzEuc2hvdWxkVXNlR3JvdXApKHNjaGVtYSwgZ3JvdXApKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoZ3JvdXAudHlwZSkge1xuICAgICAgICAgICAgZ2VuLmlmKCgwLCBkYXRhVHlwZV8yLmNoZWNrRGF0YVR5cGUpKGdyb3VwLnR5cGUsIGRhdGEsIG9wdHMuc3RyaWN0TnVtYmVycykpO1xuICAgICAgICAgICAgaXRlcmF0ZUtleXdvcmRzKGl0LCBncm91cCk7XG4gICAgICAgICAgICBpZiAodHlwZXMubGVuZ3RoID09PSAxICYmIHR5cGVzWzBdID09PSBncm91cC50eXBlICYmIHR5cGVFcnJvcnMpIHtcbiAgICAgICAgICAgICAgICBnZW4uZWxzZSgpO1xuICAgICAgICAgICAgICAgICgwLCBkYXRhVHlwZV8yLnJlcG9ydFR5cGVFcnJvcikoaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2VuLmVuZElmKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpdGVyYXRlS2V5d29yZHMoaXQsIGdyb3VwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPIG1ha2UgaXQgXCJva1wiIGNhbGw/XG4gICAgICAgIGlmICghYWxsRXJyb3JzKVxuICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LmVycm9yc30gPT09ICR7ZXJyc0NvdW50IHx8IDB9YCk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXRlcmF0ZUtleXdvcmRzKGl0LCBncm91cCkge1xuICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIG9wdHM6IHsgdXNlRGVmYXVsdHMgfSwgfSA9IGl0O1xuICAgIGlmICh1c2VEZWZhdWx0cylcbiAgICAgICAgKDAsIGRlZmF1bHRzXzEuYXNzaWduRGVmYXVsdHMpKGl0LCBncm91cC50eXBlKTtcbiAgICBnZW4uYmxvY2soKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IHJ1bGUgb2YgZ3JvdXAucnVsZXMpIHtcbiAgICAgICAgICAgIGlmICgoMCwgYXBwbGljYWJpbGl0eV8xLnNob3VsZFVzZVJ1bGUpKHNjaGVtYSwgcnVsZSkpIHtcbiAgICAgICAgICAgICAgICBrZXl3b3JkQ29kZShpdCwgcnVsZS5rZXl3b3JkLCBydWxlLmRlZmluaXRpb24sIGdyb3VwLnR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBjaGVja1N0cmljdFR5cGVzKGl0LCB0eXBlcykge1xuICAgIGlmIChpdC5zY2hlbWFFbnYubWV0YSB8fCAhaXQub3B0cy5zdHJpY3RUeXBlcylcbiAgICAgICAgcmV0dXJuO1xuICAgIGNoZWNrQ29udGV4dFR5cGVzKGl0LCB0eXBlcyk7XG4gICAgaWYgKCFpdC5vcHRzLmFsbG93VW5pb25UeXBlcylcbiAgICAgICAgY2hlY2tNdWx0aXBsZVR5cGVzKGl0LCB0eXBlcyk7XG4gICAgY2hlY2tLZXl3b3JkVHlwZXMoaXQsIGl0LmRhdGFUeXBlcyk7XG59XG5mdW5jdGlvbiBjaGVja0NvbnRleHRUeXBlcyhpdCwgdHlwZXMpIHtcbiAgICBpZiAoIXR5cGVzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICghaXQuZGF0YVR5cGVzLmxlbmd0aCkge1xuICAgICAgICBpdC5kYXRhVHlwZXMgPSB0eXBlcztcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0eXBlcy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICAgIGlmICghaW5jbHVkZXNUeXBlKGl0LmRhdGFUeXBlcywgdCkpIHtcbiAgICAgICAgICAgIHN0cmljdFR5cGVzRXJyb3IoaXQsIGB0eXBlIFwiJHt0fVwiIG5vdCBhbGxvd2VkIGJ5IGNvbnRleHQgXCIke2l0LmRhdGFUeXBlcy5qb2luKFwiLFwiKX1cImApO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgbmFycm93U2NoZW1hVHlwZXMoaXQsIHR5cGVzKTtcbn1cbmZ1bmN0aW9uIGNoZWNrTXVsdGlwbGVUeXBlcyhpdCwgdHMpIHtcbiAgICBpZiAodHMubGVuZ3RoID4gMSAmJiAhKHRzLmxlbmd0aCA9PT0gMiAmJiB0cy5pbmNsdWRlcyhcIm51bGxcIikpKSB7XG4gICAgICAgIHN0cmljdFR5cGVzRXJyb3IoaXQsIFwidXNlIGFsbG93VW5pb25UeXBlcyB0byBhbGxvdyB1bmlvbiB0eXBlIGtleXdvcmRcIik7XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tLZXl3b3JkVHlwZXMoaXQsIHRzKSB7XG4gICAgY29uc3QgcnVsZXMgPSBpdC5zZWxmLlJVTEVTLmFsbDtcbiAgICBmb3IgKGNvbnN0IGtleXdvcmQgaW4gcnVsZXMpIHtcbiAgICAgICAgY29uc3QgcnVsZSA9IHJ1bGVzW2tleXdvcmRdO1xuICAgICAgICBpZiAodHlwZW9mIHJ1bGUgPT0gXCJvYmplY3RcIiAmJiAoMCwgYXBwbGljYWJpbGl0eV8xLnNob3VsZFVzZVJ1bGUpKGl0LnNjaGVtYSwgcnVsZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdHlwZSB9ID0gcnVsZS5kZWZpbml0aW9uO1xuICAgICAgICAgICAgaWYgKHR5cGUubGVuZ3RoICYmICF0eXBlLnNvbWUoKHQpID0+IGhhc0FwcGxpY2FibGVUeXBlKHRzLCB0KSkpIHtcbiAgICAgICAgICAgICAgICBzdHJpY3RUeXBlc0Vycm9yKGl0LCBgbWlzc2luZyB0eXBlIFwiJHt0eXBlLmpvaW4oXCIsXCIpfVwiIGZvciBrZXl3b3JkIFwiJHtrZXl3b3JkfVwiYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBoYXNBcHBsaWNhYmxlVHlwZShzY2hUcywga3dkVCkge1xuICAgIHJldHVybiBzY2hUcy5pbmNsdWRlcyhrd2RUKSB8fCAoa3dkVCA9PT0gXCJudW1iZXJcIiAmJiBzY2hUcy5pbmNsdWRlcyhcImludGVnZXJcIikpO1xufVxuZnVuY3Rpb24gaW5jbHVkZXNUeXBlKHRzLCB0KSB7XG4gICAgcmV0dXJuIHRzLmluY2x1ZGVzKHQpIHx8ICh0ID09PSBcImludGVnZXJcIiAmJiB0cy5pbmNsdWRlcyhcIm51bWJlclwiKSk7XG59XG5mdW5jdGlvbiBuYXJyb3dTY2hlbWFUeXBlcyhpdCwgd2l0aFR5cGVzKSB7XG4gICAgY29uc3QgdHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHQgb2YgaXQuZGF0YVR5cGVzKSB7XG4gICAgICAgIGlmIChpbmNsdWRlc1R5cGUod2l0aFR5cGVzLCB0KSlcbiAgICAgICAgICAgIHRzLnB1c2godCk7XG4gICAgICAgIGVsc2UgaWYgKHdpdGhUeXBlcy5pbmNsdWRlcyhcImludGVnZXJcIikgJiYgdCA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRzLnB1c2goXCJpbnRlZ2VyXCIpO1xuICAgIH1cbiAgICBpdC5kYXRhVHlwZXMgPSB0cztcbn1cbmZ1bmN0aW9uIHN0cmljdFR5cGVzRXJyb3IoaXQsIG1zZykge1xuICAgIGNvbnN0IHNjaGVtYVBhdGggPSBpdC5zY2hlbWFFbnYuYmFzZUlkICsgaXQuZXJyU2NoZW1hUGF0aDtcbiAgICBtc2cgKz0gYCBhdCBcIiR7c2NoZW1hUGF0aH1cIiAoc3RyaWN0VHlwZXMpYDtcbiAgICAoMCwgdXRpbF8xLmNoZWNrU3RyaWN0TW9kZSkoaXQsIG1zZywgaXQub3B0cy5zdHJpY3RUeXBlcyk7XG59XG5jbGFzcyBLZXl3b3JkQ3h0IHtcbiAgICBjb25zdHJ1Y3RvcihpdCwgZGVmLCBrZXl3b3JkKSB7XG4gICAgICAgICgwLCBrZXl3b3JkXzEudmFsaWRhdGVLZXl3b3JkVXNhZ2UpKGl0LCBkZWYsIGtleXdvcmQpO1xuICAgICAgICB0aGlzLmdlbiA9IGl0LmdlbjtcbiAgICAgICAgdGhpcy5hbGxFcnJvcnMgPSBpdC5hbGxFcnJvcnM7XG4gICAgICAgIHRoaXMua2V5d29yZCA9IGtleXdvcmQ7XG4gICAgICAgIHRoaXMuZGF0YSA9IGl0LmRhdGE7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gaXQuc2NoZW1hW2tleXdvcmRdO1xuICAgICAgICB0aGlzLiRkYXRhID0gZGVmLiRkYXRhICYmIGl0Lm9wdHMuJGRhdGEgJiYgdGhpcy5zY2hlbWEgJiYgdGhpcy5zY2hlbWEuJGRhdGE7XG4gICAgICAgIHRoaXMuc2NoZW1hVmFsdWUgPSAoMCwgdXRpbF8xLnNjaGVtYVJlZk9yVmFsKShpdCwgdGhpcy5zY2hlbWEsIGtleXdvcmQsIHRoaXMuJGRhdGEpO1xuICAgICAgICB0aGlzLnNjaGVtYVR5cGUgPSBkZWYuc2NoZW1hVHlwZTtcbiAgICAgICAgdGhpcy5wYXJlbnRTY2hlbWEgPSBpdC5zY2hlbWE7XG4gICAgICAgIHRoaXMucGFyYW1zID0ge307XG4gICAgICAgIHRoaXMuaXQgPSBpdDtcbiAgICAgICAgdGhpcy5kZWYgPSBkZWY7XG4gICAgICAgIGlmICh0aGlzLiRkYXRhKSB7XG4gICAgICAgICAgICB0aGlzLnNjaGVtYUNvZGUgPSBpdC5nZW4uY29uc3QoXCJ2U2NoZW1hXCIsIGdldERhdGEodGhpcy4kZGF0YSwgaXQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2NoZW1hQ29kZSA9IHRoaXMuc2NoZW1hVmFsdWU7XG4gICAgICAgICAgICBpZiAoISgwLCBrZXl3b3JkXzEudmFsaWRTY2hlbWFUeXBlKSh0aGlzLnNjaGVtYSwgZGVmLnNjaGVtYVR5cGUsIGRlZi5hbGxvd1VuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7a2V5d29yZH0gdmFsdWUgbXVzdCBiZSAke0pTT04uc3RyaW5naWZ5KGRlZi5zY2hlbWFUeXBlKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJjb2RlXCIgaW4gZGVmID8gZGVmLnRyYWNrRXJyb3JzIDogZGVmLmVycm9ycyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyc0NvdW50ID0gaXQuZ2VuLmNvbnN0KFwiX2VycnNcIiwgbmFtZXNfMS5kZWZhdWx0LmVycm9ycyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0KGNvbmRpdGlvbiwgc3VjY2Vzc0FjdGlvbiwgZmFpbEFjdGlvbikge1xuICAgICAgICB0aGlzLmZhaWxSZXN1bHQoKDAsIGNvZGVnZW5fMS5ub3QpKGNvbmRpdGlvbiksIHN1Y2Nlc3NBY3Rpb24sIGZhaWxBY3Rpb24pO1xuICAgIH1cbiAgICBmYWlsUmVzdWx0KGNvbmRpdGlvbiwgc3VjY2Vzc0FjdGlvbiwgZmFpbEFjdGlvbikge1xuICAgICAgICB0aGlzLmdlbi5pZihjb25kaXRpb24pO1xuICAgICAgICBpZiAoZmFpbEFjdGlvbilcbiAgICAgICAgICAgIGZhaWxBY3Rpb24oKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5lcnJvcigpO1xuICAgICAgICBpZiAoc3VjY2Vzc0FjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5nZW4uZWxzZSgpO1xuICAgICAgICAgICAgc3VjY2Vzc0FjdGlvbigpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgIHRoaXMuZ2VuLmVuZElmKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hbGxFcnJvcnMpXG4gICAgICAgICAgICAgICAgdGhpcy5nZW4uZW5kSWYoKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLmdlbi5lbHNlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGFzcyhjb25kaXRpb24sIGZhaWxBY3Rpb24pIHtcbiAgICAgICAgdGhpcy5mYWlsUmVzdWx0KCgwLCBjb2RlZ2VuXzEubm90KShjb25kaXRpb24pLCB1bmRlZmluZWQsIGZhaWxBY3Rpb24pO1xuICAgIH1cbiAgICBmYWlsKGNvbmRpdGlvbikge1xuICAgICAgICBpZiAoY29uZGl0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5hbGxFcnJvcnMpXG4gICAgICAgICAgICAgICAgdGhpcy5nZW4uaWYoZmFsc2UpOyAvLyB0aGlzIGJyYW5jaCB3aWxsIGJlIHJlbW92ZWQgYnkgZ2VuLm9wdGltaXplXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nZW4uaWYoY29uZGl0aW9uKTtcbiAgICAgICAgdGhpcy5lcnJvcigpO1xuICAgICAgICBpZiAodGhpcy5hbGxFcnJvcnMpXG4gICAgICAgICAgICB0aGlzLmdlbi5lbmRJZigpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmdlbi5lbHNlKCk7XG4gICAgfVxuICAgIGZhaWwkZGF0YShjb25kaXRpb24pIHtcbiAgICAgICAgaWYgKCF0aGlzLiRkYXRhKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmFpbChjb25kaXRpb24pO1xuICAgICAgICBjb25zdCB7IHNjaGVtYUNvZGUgfSA9IHRoaXM7XG4gICAgICAgIHRoaXMuZmFpbCgoMCwgY29kZWdlbl8xLl8pIGAke3NjaGVtYUNvZGV9ICE9PSB1bmRlZmluZWQgJiYgKCR7KDAsIGNvZGVnZW5fMS5vcikodGhpcy5pbnZhbGlkJGRhdGEoKSwgY29uZGl0aW9uKX0pYCk7XG4gICAgfVxuICAgIGVycm9yKGFwcGVuZCwgZXJyb3JQYXJhbXMsIGVycm9yUGF0aHMpIHtcbiAgICAgICAgaWYgKGVycm9yUGFyYW1zKSB7XG4gICAgICAgICAgICB0aGlzLnNldFBhcmFtcyhlcnJvclBhcmFtcyk7XG4gICAgICAgICAgICB0aGlzLl9lcnJvcihhcHBlbmQsIGVycm9yUGF0aHMpO1xuICAgICAgICAgICAgdGhpcy5zZXRQYXJhbXMoe30pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Vycm9yKGFwcGVuZCwgZXJyb3JQYXRocyk7XG4gICAgfVxuICAgIF9lcnJvcihhcHBlbmQsIGVycm9yUGF0aHMpIHtcbiAgICAgICAgO1xuICAgICAgICAoYXBwZW5kID8gZXJyb3JzXzEucmVwb3J0RXh0cmFFcnJvciA6IGVycm9yc18xLnJlcG9ydEVycm9yKSh0aGlzLCB0aGlzLmRlZi5lcnJvciwgZXJyb3JQYXRocyk7XG4gICAgfVxuICAgICRkYXRhRXJyb3IoKSB7XG4gICAgICAgICgwLCBlcnJvcnNfMS5yZXBvcnRFcnJvcikodGhpcywgdGhpcy5kZWYuJGRhdGFFcnJvciB8fCBlcnJvcnNfMS5rZXl3b3JkJERhdGFFcnJvcik7XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgICAgICBpZiAodGhpcy5lcnJzQ291bnQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYWRkIFwidHJhY2tFcnJvcnNcIiB0byBrZXl3b3JkIGRlZmluaXRpb24nKTtcbiAgICAgICAgKDAsIGVycm9yc18xLnJlc2V0RXJyb3JzQ291bnQpKHRoaXMuZ2VuLCB0aGlzLmVycnNDb3VudCk7XG4gICAgfVxuICAgIG9rKGNvbmQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFsbEVycm9ycylcbiAgICAgICAgICAgIHRoaXMuZ2VuLmlmKGNvbmQpO1xuICAgIH1cbiAgICBzZXRQYXJhbXMob2JqLCBhc3NpZ24pIHtcbiAgICAgICAgaWYgKGFzc2lnbilcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5wYXJhbXMsIG9iaik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMucGFyYW1zID0gb2JqO1xuICAgIH1cbiAgICBibG9jayRkYXRhKHZhbGlkLCBjb2RlQmxvY2ssICRkYXRhVmFsaWQgPSBjb2RlZ2VuXzEubmlsKSB7XG4gICAgICAgIHRoaXMuZ2VuLmJsb2NrKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2skZGF0YSh2YWxpZCwgJGRhdGFWYWxpZCk7XG4gICAgICAgICAgICBjb2RlQmxvY2soKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNoZWNrJGRhdGEodmFsaWQgPSBjb2RlZ2VuXzEubmlsLCAkZGF0YVZhbGlkID0gY29kZWdlbl8xLm5pbCkge1xuICAgICAgICBpZiAoIXRoaXMuJGRhdGEpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWFDb2RlLCBzY2hlbWFUeXBlLCBkZWYgfSA9IHRoaXM7XG4gICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLm9yKSgoMCwgY29kZWdlbl8xLl8pIGAke3NjaGVtYUNvZGV9ID09PSB1bmRlZmluZWRgLCAkZGF0YVZhbGlkKSk7XG4gICAgICAgIGlmICh2YWxpZCAhPT0gY29kZWdlbl8xLm5pbClcbiAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIHRydWUpO1xuICAgICAgICBpZiAoc2NoZW1hVHlwZS5sZW5ndGggfHwgZGVmLnZhbGlkYXRlU2NoZW1hKSB7XG4gICAgICAgICAgICBnZW4uZWxzZUlmKHRoaXMuaW52YWxpZCRkYXRhKCkpO1xuICAgICAgICAgICAgdGhpcy4kZGF0YUVycm9yKCk7XG4gICAgICAgICAgICBpZiAodmFsaWQgIT09IGNvZGVnZW5fMS5uaWwpXG4gICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGdlbi5lbHNlKCk7XG4gICAgfVxuICAgIGludmFsaWQkZGF0YSgpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYUNvZGUsIHNjaGVtYVR5cGUsIGRlZiwgaXQgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLm9yKSh3cm9uZyREYXRhVHlwZSgpLCBpbnZhbGlkJERhdGFTY2hlbWEoKSk7XG4gICAgICAgIGZ1bmN0aW9uIHdyb25nJERhdGFUeXBlKCkge1xuICAgICAgICAgICAgaWYgKHNjaGVtYVR5cGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgaWYgKCEoc2NoZW1hQ29kZSBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0ID0gQXJyYXkuaXNBcnJheShzY2hlbWFUeXBlKSA/IHNjaGVtYVR5cGUgOiBbc2NoZW1hVHlwZV07XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuXykgYCR7KDAsIGRhdGFUeXBlXzIuY2hlY2tEYXRhVHlwZXMpKHN0LCBzY2hlbWFDb2RlLCBpdC5vcHRzLnN0cmljdE51bWJlcnMsIGRhdGFUeXBlXzIuRGF0YVR5cGUuV3JvbmcpfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29kZWdlbl8xLm5pbDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpbnZhbGlkJERhdGFTY2hlbWEoKSB7XG4gICAgICAgICAgICBpZiAoZGVmLnZhbGlkYXRlU2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsaWRhdGVTY2hlbWFSZWYgPSBnZW4uc2NvcGVWYWx1ZShcInZhbGlkYXRlJGRhdGFcIiwgeyByZWY6IGRlZi52YWxpZGF0ZVNjaGVtYSB9KTsgLy8gVE9ETyB2YWx1ZS5jb2RlIGZvciBzdGFuZGFsb25lXG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuXykgYCEke3ZhbGlkYXRlU2NoZW1hUmVmfSgke3NjaGVtYUNvZGV9KWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29kZWdlbl8xLm5pbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdWJzY2hlbWEoYXBwbCwgdmFsaWQpIHtcbiAgICAgICAgY29uc3Qgc3Vic2NoZW1hID0gKDAsIHN1YnNjaGVtYV8xLmdldFN1YnNjaGVtYSkodGhpcy5pdCwgYXBwbCk7XG4gICAgICAgICgwLCBzdWJzY2hlbWFfMS5leHRlbmRTdWJzY2hlbWFEYXRhKShzdWJzY2hlbWEsIHRoaXMuaXQsIGFwcGwpO1xuICAgICAgICAoMCwgc3Vic2NoZW1hXzEuZXh0ZW5kU3Vic2NoZW1hTW9kZSkoc3Vic2NoZW1hLCBhcHBsKTtcbiAgICAgICAgY29uc3QgbmV4dENvbnRleHQgPSB7IC4uLnRoaXMuaXQsIC4uLnN1YnNjaGVtYSwgaXRlbXM6IHVuZGVmaW5lZCwgcHJvcHM6IHVuZGVmaW5lZCB9O1xuICAgICAgICBzdWJzY2hlbWFDb2RlKG5leHRDb250ZXh0LCB2YWxpZCk7XG4gICAgICAgIHJldHVybiBuZXh0Q29udGV4dDtcbiAgICB9XG4gICAgbWVyZ2VFdmFsdWF0ZWQoc2NoZW1hQ3h0LCB0b05hbWUpIHtcbiAgICAgICAgY29uc3QgeyBpdCwgZ2VuIH0gPSB0aGlzO1xuICAgICAgICBpZiAoIWl0Lm9wdHMudW5ldmFsdWF0ZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChpdC5wcm9wcyAhPT0gdHJ1ZSAmJiBzY2hlbWFDeHQucHJvcHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaXQucHJvcHMgPSB1dGlsXzEubWVyZ2VFdmFsdWF0ZWQucHJvcHMoZ2VuLCBzY2hlbWFDeHQucHJvcHMsIGl0LnByb3BzLCB0b05hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdC5pdGVtcyAhPT0gdHJ1ZSAmJiBzY2hlbWFDeHQuaXRlbXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaXQuaXRlbXMgPSB1dGlsXzEubWVyZ2VFdmFsdWF0ZWQuaXRlbXMoZ2VuLCBzY2hlbWFDeHQuaXRlbXMsIGl0Lml0ZW1zLCB0b05hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1lcmdlVmFsaWRFdmFsdWF0ZWQoc2NoZW1hQ3h0LCB2YWxpZCkge1xuICAgICAgICBjb25zdCB7IGl0LCBnZW4gfSA9IHRoaXM7XG4gICAgICAgIGlmIChpdC5vcHRzLnVuZXZhbHVhdGVkICYmIChpdC5wcm9wcyAhPT0gdHJ1ZSB8fCBpdC5pdGVtcyAhPT0gdHJ1ZSkpIHtcbiAgICAgICAgICAgIGdlbi5pZih2YWxpZCwgKCkgPT4gdGhpcy5tZXJnZUV2YWx1YXRlZChzY2hlbWFDeHQsIGNvZGVnZW5fMS5OYW1lKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuS2V5d29yZEN4dCA9IEtleXdvcmRDeHQ7XG5mdW5jdGlvbiBrZXl3b3JkQ29kZShpdCwga2V5d29yZCwgZGVmLCBydWxlVHlwZSkge1xuICAgIGNvbnN0IGN4dCA9IG5ldyBLZXl3b3JkQ3h0KGl0LCBkZWYsIGtleXdvcmQpO1xuICAgIGlmIChcImNvZGVcIiBpbiBkZWYpIHtcbiAgICAgICAgZGVmLmNvZGUoY3h0LCBydWxlVHlwZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGN4dC4kZGF0YSAmJiBkZWYudmFsaWRhdGUpIHtcbiAgICAgICAgKDAsIGtleXdvcmRfMS5mdW5jS2V5d29yZENvZGUpKGN4dCwgZGVmKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoXCJtYWNyb1wiIGluIGRlZikge1xuICAgICAgICAoMCwga2V5d29yZF8xLm1hY3JvS2V5d29yZENvZGUpKGN4dCwgZGVmKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGVmLmNvbXBpbGUgfHwgZGVmLnZhbGlkYXRlKSB7XG4gICAgICAgICgwLCBrZXl3b3JkXzEuZnVuY0tleXdvcmRDb2RlKShjeHQsIGRlZik7XG4gICAgfVxufVxuY29uc3QgSlNPTl9QT0lOVEVSID0gL15cXC8oPzpbXn5dfH4wfH4xKSokLztcbmNvbnN0IFJFTEFUSVZFX0pTT05fUE9JTlRFUiA9IC9eKFswLTldKykoI3xcXC8oPzpbXn5dfH4wfH4xKSopPyQvO1xuZnVuY3Rpb24gZ2V0RGF0YSgkZGF0YSwgeyBkYXRhTGV2ZWwsIGRhdGFOYW1lcywgZGF0YVBhdGhBcnIgfSkge1xuICAgIGxldCBqc29uUG9pbnRlcjtcbiAgICBsZXQgZGF0YTtcbiAgICBpZiAoJGRhdGEgPT09IFwiXCIpXG4gICAgICAgIHJldHVybiBuYW1lc18xLmRlZmF1bHQucm9vdERhdGE7XG4gICAgaWYgKCRkYXRhWzBdID09PSBcIi9cIikge1xuICAgICAgICBpZiAoIUpTT05fUE9JTlRFUi50ZXN0KCRkYXRhKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBKU09OLXBvaW50ZXI6ICR7JGRhdGF9YCk7XG4gICAgICAgIGpzb25Qb2ludGVyID0gJGRhdGE7XG4gICAgICAgIGRhdGEgPSBuYW1lc18xLmRlZmF1bHQucm9vdERhdGE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBtYXRjaGVzID0gUkVMQVRJVkVfSlNPTl9QT0lOVEVSLmV4ZWMoJGRhdGEpO1xuICAgICAgICBpZiAoIW1hdGNoZXMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgSlNPTi1wb2ludGVyOiAkeyRkYXRhfWApO1xuICAgICAgICBjb25zdCB1cCA9ICttYXRjaGVzWzFdO1xuICAgICAgICBqc29uUG9pbnRlciA9IG1hdGNoZXNbMl07XG4gICAgICAgIGlmIChqc29uUG9pbnRlciA9PT0gXCIjXCIpIHtcbiAgICAgICAgICAgIGlmICh1cCA+PSBkYXRhTGV2ZWwpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTXNnKFwicHJvcGVydHkvaW5kZXhcIiwgdXApKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhUGF0aEFycltkYXRhTGV2ZWwgLSB1cF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwID4gZGF0YUxldmVsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTXNnKFwiZGF0YVwiLCB1cCkpO1xuICAgICAgICBkYXRhID0gZGF0YU5hbWVzW2RhdGFMZXZlbCAtIHVwXTtcbiAgICAgICAgaWYgKCFqc29uUG9pbnRlcilcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBsZXQgZXhwciA9IGRhdGE7XG4gICAgY29uc3Qgc2VnbWVudHMgPSBqc29uUG9pbnRlci5zcGxpdChcIi9cIik7XG4gICAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgICAgIGlmIChzZWdtZW50KSB7XG4gICAgICAgICAgICBkYXRhID0gKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfSR7KDAsIGNvZGVnZW5fMS5nZXRQcm9wZXJ0eSkoKDAsIHV0aWxfMS51bmVzY2FwZUpzb25Qb2ludGVyKShzZWdtZW50KSl9YDtcbiAgICAgICAgICAgIGV4cHIgPSAoMCwgY29kZWdlbl8xLl8pIGAke2V4cHJ9ICYmICR7ZGF0YX1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBleHByO1xuICAgIGZ1bmN0aW9uIGVycm9yTXNnKHBvaW50ZXJUeXBlLCB1cCkge1xuICAgICAgICByZXR1cm4gYENhbm5vdCBhY2Nlc3MgJHtwb2ludGVyVHlwZX0gJHt1cH0gbGV2ZWxzIHVwLCBjdXJyZW50IGxldmVsIGlzICR7ZGF0YUxldmVsfWA7XG4gICAgfVxufVxuZXhwb3J0cy5nZXREYXRhID0gZ2V0RGF0YTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgVmFsaWRhdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGVycm9ycykge1xuICAgICAgICBzdXBlcihcInZhbGlkYXRpb24gZmFpbGVkXCIpO1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICAgICAgdGhpcy5hanYgPSB0aGlzLnZhbGlkYXRpb24gPSB0cnVlO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFZhbGlkYXRpb25FcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZhbGlkYXRpb25fZXJyb3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCByZXNvbHZlXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZlXCIpO1xuY2xhc3MgTWlzc2luZ1JlZkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHJlc29sdmVyLCBiYXNlSWQsIHJlZiwgbXNnKSB7XG4gICAgICAgIHN1cGVyKG1zZyB8fCBgY2FuJ3QgcmVzb2x2ZSByZWZlcmVuY2UgJHtyZWZ9IGZyb20gaWQgJHtiYXNlSWR9YCk7XG4gICAgICAgIHRoaXMubWlzc2luZ1JlZiA9ICgwLCByZXNvbHZlXzEucmVzb2x2ZVVybCkocmVzb2x2ZXIsIGJhc2VJZCwgcmVmKTtcbiAgICAgICAgdGhpcy5taXNzaW5nU2NoZW1hID0gKDAsIHJlc29sdmVfMS5ub3JtYWxpemVJZCkoKDAsIHJlc29sdmVfMS5nZXRGdWxsUGF0aCkocmVzb2x2ZXIsIHRoaXMubWlzc2luZ1JlZikpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IE1pc3NpbmdSZWZFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZl9lcnJvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVzb2x2ZVNjaGVtYSA9IGV4cG9ydHMuZ2V0Q29tcGlsaW5nU2NoZW1hID0gZXhwb3J0cy5yZXNvbHZlUmVmID0gZXhwb3J0cy5jb21waWxlU2NoZW1hID0gZXhwb3J0cy5TY2hlbWFFbnYgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi9jb2RlZ2VuXCIpO1xuY29uc3QgdmFsaWRhdGlvbl9lcnJvcl8xID0gcmVxdWlyZShcIi4uL3J1bnRpbWUvdmFsaWRhdGlvbl9lcnJvclwiKTtcbmNvbnN0IG5hbWVzXzEgPSByZXF1aXJlKFwiLi9uYW1lc1wiKTtcbmNvbnN0IHJlc29sdmVfMSA9IHJlcXVpcmUoXCIuL3Jlc29sdmVcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuY29uc3QgdmFsaWRhdGVfMSA9IHJlcXVpcmUoXCIuL3ZhbGlkYXRlXCIpO1xuY2xhc3MgU2NoZW1hRW52IHtcbiAgICBjb25zdHJ1Y3RvcihlbnYpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLnJlZnMgPSB7fTtcbiAgICAgICAgdGhpcy5keW5hbWljQW5jaG9ycyA9IHt9O1xuICAgICAgICBsZXQgc2NoZW1hO1xuICAgICAgICBpZiAodHlwZW9mIGVudi5zY2hlbWEgPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgIHNjaGVtYSA9IGVudi5zY2hlbWE7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gZW52LnNjaGVtYTtcbiAgICAgICAgdGhpcy5zY2hlbWFJZCA9IGVudi5zY2hlbWFJZDtcbiAgICAgICAgdGhpcy5yb290ID0gZW52LnJvb3QgfHwgdGhpcztcbiAgICAgICAgdGhpcy5iYXNlSWQgPSAoX2EgPSBlbnYuYmFzZUlkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoMCwgcmVzb2x2ZV8xLm5vcm1hbGl6ZUlkKShzY2hlbWEgPT09IG51bGwgfHwgc2NoZW1hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY2hlbWFbZW52LnNjaGVtYUlkIHx8IFwiJGlkXCJdKTtcbiAgICAgICAgdGhpcy5zY2hlbWFQYXRoID0gZW52LnNjaGVtYVBhdGg7XG4gICAgICAgIHRoaXMubG9jYWxSZWZzID0gZW52LmxvY2FsUmVmcztcbiAgICAgICAgdGhpcy5tZXRhID0gZW52Lm1ldGE7XG4gICAgICAgIHRoaXMuJGFzeW5jID0gc2NoZW1hID09PSBudWxsIHx8IHNjaGVtYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2NoZW1hLiRhc3luYztcbiAgICAgICAgdGhpcy5yZWZzID0ge307XG4gICAgfVxufVxuZXhwb3J0cy5TY2hlbWFFbnYgPSBTY2hlbWFFbnY7XG4vLyBsZXQgY29kZVNpemUgPSAwXG4vLyBsZXQgbm9kZUNvdW50ID0gMFxuLy8gQ29tcGlsZXMgc2NoZW1hIGluIFNjaGVtYUVudlxuZnVuY3Rpb24gY29tcGlsZVNjaGVtYShzY2gpIHtcbiAgICAvLyBUT0RPIHJlZmFjdG9yIC0gcmVtb3ZlIGNvbXBpbGF0aW9uc1xuICAgIGNvbnN0IF9zY2ggPSBnZXRDb21waWxpbmdTY2hlbWEuY2FsbCh0aGlzLCBzY2gpO1xuICAgIGlmIChfc2NoKVxuICAgICAgICByZXR1cm4gX3NjaDtcbiAgICBjb25zdCByb290SWQgPSAoMCwgcmVzb2x2ZV8xLmdldEZ1bGxQYXRoKSh0aGlzLm9wdHMudXJpUmVzb2x2ZXIsIHNjaC5yb290LmJhc2VJZCk7IC8vIFRPRE8gaWYgZ2V0RnVsbFBhdGggcmVtb3ZlZCAxIHRlc3RzIGZhaWxzXG4gICAgY29uc3QgeyBlczUsIGxpbmVzIH0gPSB0aGlzLm9wdHMuY29kZTtcbiAgICBjb25zdCB7IG93blByb3BlcnRpZXMgfSA9IHRoaXMub3B0cztcbiAgICBjb25zdCBnZW4gPSBuZXcgY29kZWdlbl8xLkNvZGVHZW4odGhpcy5zY29wZSwgeyBlczUsIGxpbmVzLCBvd25Qcm9wZXJ0aWVzIH0pO1xuICAgIGxldCBfVmFsaWRhdGlvbkVycm9yO1xuICAgIGlmIChzY2guJGFzeW5jKSB7XG4gICAgICAgIF9WYWxpZGF0aW9uRXJyb3IgPSBnZW4uc2NvcGVWYWx1ZShcIkVycm9yXCIsIHtcbiAgICAgICAgICAgIHJlZjogdmFsaWRhdGlvbl9lcnJvcl8xLmRlZmF1bHQsXG4gICAgICAgICAgICBjb2RlOiAoMCwgY29kZWdlbl8xLl8pIGByZXF1aXJlKFwiYWp2L2Rpc3QvcnVudGltZS92YWxpZGF0aW9uX2Vycm9yXCIpLmRlZmF1bHRgLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgdmFsaWRhdGVOYW1lID0gZ2VuLnNjb3BlTmFtZShcInZhbGlkYXRlXCIpO1xuICAgIHNjaC52YWxpZGF0ZU5hbWUgPSB2YWxpZGF0ZU5hbWU7XG4gICAgY29uc3Qgc2NoZW1hQ3h0ID0ge1xuICAgICAgICBnZW4sXG4gICAgICAgIGFsbEVycm9yczogdGhpcy5vcHRzLmFsbEVycm9ycyxcbiAgICAgICAgZGF0YTogbmFtZXNfMS5kZWZhdWx0LmRhdGEsXG4gICAgICAgIHBhcmVudERhdGE6IG5hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhLFxuICAgICAgICBwYXJlbnREYXRhUHJvcGVydHk6IG5hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhUHJvcGVydHksXG4gICAgICAgIGRhdGFOYW1lczogW25hbWVzXzEuZGVmYXVsdC5kYXRhXSxcbiAgICAgICAgZGF0YVBhdGhBcnI6IFtjb2RlZ2VuXzEubmlsXSwgLy8gVE9ETyBjYW4gaXRzIGxlbmd0aCBiZSB1c2VkIGFzIGRhdGFMZXZlbCBpZiBuaWwgaXMgcmVtb3ZlZD9cbiAgICAgICAgZGF0YUxldmVsOiAwLFxuICAgICAgICBkYXRhVHlwZXM6IFtdLFxuICAgICAgICBkZWZpbmVkUHJvcGVydGllczogbmV3IFNldCgpLFxuICAgICAgICB0b3BTY2hlbWFSZWY6IGdlbi5zY29wZVZhbHVlKFwic2NoZW1hXCIsIHRoaXMub3B0cy5jb2RlLnNvdXJjZSA9PT0gdHJ1ZVxuICAgICAgICAgICAgPyB7IHJlZjogc2NoLnNjaGVtYSwgY29kZTogKDAsIGNvZGVnZW5fMS5zdHJpbmdpZnkpKHNjaC5zY2hlbWEpIH1cbiAgICAgICAgICAgIDogeyByZWY6IHNjaC5zY2hlbWEgfSksXG4gICAgICAgIHZhbGlkYXRlTmFtZSxcbiAgICAgICAgVmFsaWRhdGlvbkVycm9yOiBfVmFsaWRhdGlvbkVycm9yLFxuICAgICAgICBzY2hlbWE6IHNjaC5zY2hlbWEsXG4gICAgICAgIHNjaGVtYUVudjogc2NoLFxuICAgICAgICByb290SWQsXG4gICAgICAgIGJhc2VJZDogc2NoLmJhc2VJZCB8fCByb290SWQsXG4gICAgICAgIHNjaGVtYVBhdGg6IGNvZGVnZW5fMS5uaWwsXG4gICAgICAgIGVyclNjaGVtYVBhdGg6IHNjaC5zY2hlbWFQYXRoIHx8ICh0aGlzLm9wdHMuanRkID8gXCJcIiA6IFwiI1wiKSxcbiAgICAgICAgZXJyb3JQYXRoOiAoMCwgY29kZWdlbl8xLl8pIGBcIlwiYCxcbiAgICAgICAgb3B0czogdGhpcy5vcHRzLFxuICAgICAgICBzZWxmOiB0aGlzLFxuICAgIH07XG4gICAgbGV0IHNvdXJjZUNvZGU7XG4gICAgdHJ5IHtcbiAgICAgICAgdGhpcy5fY29tcGlsYXRpb25zLmFkZChzY2gpO1xuICAgICAgICAoMCwgdmFsaWRhdGVfMS52YWxpZGF0ZUZ1bmN0aW9uQ29kZSkoc2NoZW1hQ3h0KTtcbiAgICAgICAgZ2VuLm9wdGltaXplKHRoaXMub3B0cy5jb2RlLm9wdGltaXplKTtcbiAgICAgICAgLy8gZ2VuLm9wdGltaXplKDEpXG4gICAgICAgIGNvbnN0IHZhbGlkYXRlQ29kZSA9IGdlbi50b1N0cmluZygpO1xuICAgICAgICBzb3VyY2VDb2RlID0gYCR7Z2VuLnNjb3BlUmVmcyhuYW1lc18xLmRlZmF1bHQuc2NvcGUpfXJldHVybiAke3ZhbGlkYXRlQ29kZX1gO1xuICAgICAgICAvLyBjb25zb2xlLmxvZygoY29kZVNpemUgKz0gc291cmNlQ29kZS5sZW5ndGgpLCAobm9kZUNvdW50ICs9IGdlbi5ub2RlQ291bnQpKVxuICAgICAgICBpZiAodGhpcy5vcHRzLmNvZGUucHJvY2VzcylcbiAgICAgICAgICAgIHNvdXJjZUNvZGUgPSB0aGlzLm9wdHMuY29kZS5wcm9jZXNzKHNvdXJjZUNvZGUsIHNjaCk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiXFxuXFxuXFxuICoqKiBcXG5cIiwgc291cmNlQ29kZSlcbiAgICAgICAgY29uc3QgbWFrZVZhbGlkYXRlID0gbmV3IEZ1bmN0aW9uKGAke25hbWVzXzEuZGVmYXVsdC5zZWxmfWAsIGAke25hbWVzXzEuZGVmYXVsdC5zY29wZX1gLCBzb3VyY2VDb2RlKTtcbiAgICAgICAgY29uc3QgdmFsaWRhdGUgPSBtYWtlVmFsaWRhdGUodGhpcywgdGhpcy5zY29wZS5nZXQoKSk7XG4gICAgICAgIHRoaXMuc2NvcGUudmFsdWUodmFsaWRhdGVOYW1lLCB7IHJlZjogdmFsaWRhdGUgfSk7XG4gICAgICAgIHZhbGlkYXRlLmVycm9ycyA9IG51bGw7XG4gICAgICAgIHZhbGlkYXRlLnNjaGVtYSA9IHNjaC5zY2hlbWE7XG4gICAgICAgIHZhbGlkYXRlLnNjaGVtYUVudiA9IHNjaDtcbiAgICAgICAgaWYgKHNjaC4kYXN5bmMpXG4gICAgICAgICAgICB2YWxpZGF0ZS4kYXN5bmMgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5vcHRzLmNvZGUuc291cmNlID09PSB0cnVlKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZS5zb3VyY2UgPSB7IHZhbGlkYXRlTmFtZSwgdmFsaWRhdGVDb2RlLCBzY29wZVZhbHVlczogZ2VuLl92YWx1ZXMgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRzLnVuZXZhbHVhdGVkKSB7XG4gICAgICAgICAgICBjb25zdCB7IHByb3BzLCBpdGVtcyB9ID0gc2NoZW1hQ3h0O1xuICAgICAgICAgICAgdmFsaWRhdGUuZXZhbHVhdGVkID0ge1xuICAgICAgICAgICAgICAgIHByb3BzOiBwcm9wcyBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lID8gdW5kZWZpbmVkIDogcHJvcHMsXG4gICAgICAgICAgICAgICAgaXRlbXM6IGl0ZW1zIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUgPyB1bmRlZmluZWQgOiBpdGVtcyxcbiAgICAgICAgICAgICAgICBkeW5hbWljUHJvcHM6IHByb3BzIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUsXG4gICAgICAgICAgICAgICAgZHluYW1pY0l0ZW1zOiBpdGVtcyBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh2YWxpZGF0ZS5zb3VyY2UpXG4gICAgICAgICAgICAgICAgdmFsaWRhdGUuc291cmNlLmV2YWx1YXRlZCA9ICgwLCBjb2RlZ2VuXzEuc3RyaW5naWZ5KSh2YWxpZGF0ZS5ldmFsdWF0ZWQpO1xuICAgICAgICB9XG4gICAgICAgIHNjaC52YWxpZGF0ZSA9IHZhbGlkYXRlO1xuICAgICAgICByZXR1cm4gc2NoO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBkZWxldGUgc2NoLnZhbGlkYXRlO1xuICAgICAgICBkZWxldGUgc2NoLnZhbGlkYXRlTmFtZTtcbiAgICAgICAgaWYgKHNvdXJjZUNvZGUpXG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIkVycm9yIGNvbXBpbGluZyBzY2hlbWEsIGZ1bmN0aW9uIGNvZGU6XCIsIHNvdXJjZUNvZGUpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIlxcblxcblxcbiAqKiogXFxuXCIsIHNvdXJjZUNvZGUsIHRoaXMub3B0cylcbiAgICAgICAgdGhyb3cgZTtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRoaXMuX2NvbXBpbGF0aW9ucy5kZWxldGUoc2NoKTtcbiAgICB9XG59XG5leHBvcnRzLmNvbXBpbGVTY2hlbWEgPSBjb21waWxlU2NoZW1hO1xuZnVuY3Rpb24gcmVzb2x2ZVJlZihyb290LCBiYXNlSWQsIHJlZikge1xuICAgIHZhciBfYTtcbiAgICByZWYgPSAoMCwgcmVzb2x2ZV8xLnJlc29sdmVVcmwpKHRoaXMub3B0cy51cmlSZXNvbHZlciwgYmFzZUlkLCByZWYpO1xuICAgIGNvbnN0IHNjaE9yRnVuYyA9IHJvb3QucmVmc1tyZWZdO1xuICAgIGlmIChzY2hPckZ1bmMpXG4gICAgICAgIHJldHVybiBzY2hPckZ1bmM7XG4gICAgbGV0IF9zY2ggPSByZXNvbHZlLmNhbGwodGhpcywgcm9vdCwgcmVmKTtcbiAgICBpZiAoX3NjaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHNjaGVtYSA9IChfYSA9IHJvb3QubG9jYWxSZWZzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbcmVmXTsgLy8gVE9ETyBtYXliZSBsb2NhbFJlZnMgc2hvdWxkIGhvbGQgU2NoZW1hRW52XG4gICAgICAgIGNvbnN0IHsgc2NoZW1hSWQgfSA9IHRoaXMub3B0cztcbiAgICAgICAgaWYgKHNjaGVtYSlcbiAgICAgICAgICAgIF9zY2ggPSBuZXcgU2NoZW1hRW52KHsgc2NoZW1hLCBzY2hlbWFJZCwgcm9vdCwgYmFzZUlkIH0pO1xuICAgIH1cbiAgICBpZiAoX3NjaCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm47XG4gICAgcmV0dXJuIChyb290LnJlZnNbcmVmXSA9IGlubGluZU9yQ29tcGlsZS5jYWxsKHRoaXMsIF9zY2gpKTtcbn1cbmV4cG9ydHMucmVzb2x2ZVJlZiA9IHJlc29sdmVSZWY7XG5mdW5jdGlvbiBpbmxpbmVPckNvbXBpbGUoc2NoKSB7XG4gICAgaWYgKCgwLCByZXNvbHZlXzEuaW5saW5lUmVmKShzY2guc2NoZW1hLCB0aGlzLm9wdHMuaW5saW5lUmVmcykpXG4gICAgICAgIHJldHVybiBzY2guc2NoZW1hO1xuICAgIHJldHVybiBzY2gudmFsaWRhdGUgPyBzY2ggOiBjb21waWxlU2NoZW1hLmNhbGwodGhpcywgc2NoKTtcbn1cbi8vIEluZGV4IG9mIHNjaGVtYSBjb21waWxhdGlvbiBpbiB0aGUgY3VycmVudGx5IGNvbXBpbGVkIGxpc3RcbmZ1bmN0aW9uIGdldENvbXBpbGluZ1NjaGVtYShzY2hFbnYpIHtcbiAgICBmb3IgKGNvbnN0IHNjaCBvZiB0aGlzLl9jb21waWxhdGlvbnMpIHtcbiAgICAgICAgaWYgKHNhbWVTY2hlbWFFbnYoc2NoLCBzY2hFbnYpKVxuICAgICAgICAgICAgcmV0dXJuIHNjaDtcbiAgICB9XG59XG5leHBvcnRzLmdldENvbXBpbGluZ1NjaGVtYSA9IGdldENvbXBpbGluZ1NjaGVtYTtcbmZ1bmN0aW9uIHNhbWVTY2hlbWFFbnYoczEsIHMyKSB7XG4gICAgcmV0dXJuIHMxLnNjaGVtYSA9PT0gczIuc2NoZW1hICYmIHMxLnJvb3QgPT09IHMyLnJvb3QgJiYgczEuYmFzZUlkID09PSBzMi5iYXNlSWQ7XG59XG4vLyByZXNvbHZlIGFuZCBjb21waWxlIHRoZSByZWZlcmVuY2VzICgkcmVmKVxuLy8gVE9ETyByZXR1cm5zIEFueVNjaGVtYU9iamVjdCAoaWYgdGhlIHNjaGVtYSBjYW4gYmUgaW5saW5lZCkgb3IgdmFsaWRhdGlvbiBmdW5jdGlvblxuZnVuY3Rpb24gcmVzb2x2ZShyb290LCAvLyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcm9vdCBzY2hlbWEgZm9yIHRoZSBjdXJyZW50IHNjaGVtYVxucmVmIC8vIHJlZmVyZW5jZSB0byByZXNvbHZlXG4pIHtcbiAgICBsZXQgc2NoO1xuICAgIHdoaWxlICh0eXBlb2YgKHNjaCA9IHRoaXMucmVmc1tyZWZdKSA9PSBcInN0cmluZ1wiKVxuICAgICAgICByZWYgPSBzY2g7XG4gICAgcmV0dXJuIHNjaCB8fCB0aGlzLnNjaGVtYXNbcmVmXSB8fCByZXNvbHZlU2NoZW1hLmNhbGwodGhpcywgcm9vdCwgcmVmKTtcbn1cbi8vIFJlc29sdmUgc2NoZW1hLCBpdHMgcm9vdCBhbmQgYmFzZUlkXG5mdW5jdGlvbiByZXNvbHZlU2NoZW1hKHJvb3QsIC8vIHJvb3Qgb2JqZWN0IHdpdGggcHJvcGVydGllcyBzY2hlbWEsIHJlZnMgVE9ETyBiZWxvdyBTY2hlbWFFbnYgaXMgYXNzaWduZWQgdG8gaXRcbnJlZiAvLyByZWZlcmVuY2UgdG8gcmVzb2x2ZVxuKSB7XG4gICAgY29uc3QgcCA9IHRoaXMub3B0cy51cmlSZXNvbHZlci5wYXJzZShyZWYpO1xuICAgIGNvbnN0IHJlZlBhdGggPSAoMCwgcmVzb2x2ZV8xLl9nZXRGdWxsUGF0aCkodGhpcy5vcHRzLnVyaVJlc29sdmVyLCBwKTtcbiAgICBsZXQgYmFzZUlkID0gKDAsIHJlc29sdmVfMS5nZXRGdWxsUGF0aCkodGhpcy5vcHRzLnVyaVJlc29sdmVyLCByb290LmJhc2VJZCwgdW5kZWZpbmVkKTtcbiAgICAvLyBUT0RPIGBPYmplY3Qua2V5cyhyb290LnNjaGVtYSkubGVuZ3RoID4gMGAgc2hvdWxkIG5vdCBiZSBuZWVkZWQgLSBidXQgcmVtb3ZpbmcgYnJlYWtzIDIgdGVzdHNcbiAgICBpZiAoT2JqZWN0LmtleXMocm9vdC5zY2hlbWEpLmxlbmd0aCA+IDAgJiYgcmVmUGF0aCA9PT0gYmFzZUlkKSB7XG4gICAgICAgIHJldHVybiBnZXRKc29uUG9pbnRlci5jYWxsKHRoaXMsIHAsIHJvb3QpO1xuICAgIH1cbiAgICBjb25zdCBpZCA9ICgwLCByZXNvbHZlXzEubm9ybWFsaXplSWQpKHJlZlBhdGgpO1xuICAgIGNvbnN0IHNjaE9yUmVmID0gdGhpcy5yZWZzW2lkXSB8fCB0aGlzLnNjaGVtYXNbaWRdO1xuICAgIGlmICh0eXBlb2Ygc2NoT3JSZWYgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCBzY2ggPSByZXNvbHZlU2NoZW1hLmNhbGwodGhpcywgcm9vdCwgc2NoT3JSZWYpO1xuICAgICAgICBpZiAodHlwZW9mIChzY2ggPT09IG51bGwgfHwgc2NoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY2guc2NoZW1hKSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcmV0dXJuIGdldEpzb25Qb2ludGVyLmNhbGwodGhpcywgcCwgc2NoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAoc2NoT3JSZWYgPT09IG51bGwgfHwgc2NoT3JSZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNjaE9yUmVmLnNjaGVtYSkgIT09IFwib2JqZWN0XCIpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoIXNjaE9yUmVmLnZhbGlkYXRlKVxuICAgICAgICBjb21waWxlU2NoZW1hLmNhbGwodGhpcywgc2NoT3JSZWYpO1xuICAgIGlmIChpZCA9PT0gKDAsIHJlc29sdmVfMS5ub3JtYWxpemVJZCkocmVmKSkge1xuICAgICAgICBjb25zdCB7IHNjaGVtYSB9ID0gc2NoT3JSZWY7XG4gICAgICAgIGNvbnN0IHsgc2NoZW1hSWQgfSA9IHRoaXMub3B0cztcbiAgICAgICAgY29uc3Qgc2NoSWQgPSBzY2hlbWFbc2NoZW1hSWRdO1xuICAgICAgICBpZiAoc2NoSWQpXG4gICAgICAgICAgICBiYXNlSWQgPSAoMCwgcmVzb2x2ZV8xLnJlc29sdmVVcmwpKHRoaXMub3B0cy51cmlSZXNvbHZlciwgYmFzZUlkLCBzY2hJZCk7XG4gICAgICAgIHJldHVybiBuZXcgU2NoZW1hRW52KHsgc2NoZW1hLCBzY2hlbWFJZCwgcm9vdCwgYmFzZUlkIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0SnNvblBvaW50ZXIuY2FsbCh0aGlzLCBwLCBzY2hPclJlZik7XG59XG5leHBvcnRzLnJlc29sdmVTY2hlbWEgPSByZXNvbHZlU2NoZW1hO1xuY29uc3QgUFJFVkVOVF9TQ09QRV9DSEFOR0UgPSBuZXcgU2V0KFtcbiAgICBcInByb3BlcnRpZXNcIixcbiAgICBcInBhdHRlcm5Qcm9wZXJ0aWVzXCIsXG4gICAgXCJlbnVtXCIsXG4gICAgXCJkZXBlbmRlbmNpZXNcIixcbiAgICBcImRlZmluaXRpb25zXCIsXG5dKTtcbmZ1bmN0aW9uIGdldEpzb25Qb2ludGVyKHBhcnNlZFJlZiwgeyBiYXNlSWQsIHNjaGVtYSwgcm9vdCB9KSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICgoKF9hID0gcGFyc2VkUmVmLmZyYWdtZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0pICE9PSBcIi9cIilcbiAgICAgICAgcmV0dXJuO1xuICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJzZWRSZWYuZnJhZ21lbnQuc2xpY2UoMSkuc3BsaXQoXCIvXCIpKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hID09PSBcImJvb2xlYW5cIilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgcGFydFNjaGVtYSA9IHNjaGVtYVsoMCwgdXRpbF8xLnVuZXNjYXBlRnJhZ21lbnQpKHBhcnQpXTtcbiAgICAgICAgaWYgKHBhcnRTY2hlbWEgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgc2NoZW1hID0gcGFydFNjaGVtYTtcbiAgICAgICAgLy8gVE9ETyBQUkVWRU5UX1NDT1BFX0NIQU5HRSBjb3VsZCBiZSBkZWZpbmVkIGluIGtleXdvcmQgZGVmP1xuICAgICAgICBjb25zdCBzY2hJZCA9IHR5cGVvZiBzY2hlbWEgPT09IFwib2JqZWN0XCIgJiYgc2NoZW1hW3RoaXMub3B0cy5zY2hlbWFJZF07XG4gICAgICAgIGlmICghUFJFVkVOVF9TQ09QRV9DSEFOR0UuaGFzKHBhcnQpICYmIHNjaElkKSB7XG4gICAgICAgICAgICBiYXNlSWQgPSAoMCwgcmVzb2x2ZV8xLnJlc29sdmVVcmwpKHRoaXMub3B0cy51cmlSZXNvbHZlciwgYmFzZUlkLCBzY2hJZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGVudjtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSAhPSBcImJvb2xlYW5cIiAmJiBzY2hlbWEuJHJlZiAmJiAhKDAsIHV0aWxfMS5zY2hlbWFIYXNSdWxlc0J1dFJlZikoc2NoZW1hLCB0aGlzLlJVTEVTKSkge1xuICAgICAgICBjb25zdCAkcmVmID0gKDAsIHJlc29sdmVfMS5yZXNvbHZlVXJsKSh0aGlzLm9wdHMudXJpUmVzb2x2ZXIsIGJhc2VJZCwgc2NoZW1hLiRyZWYpO1xuICAgICAgICBlbnYgPSByZXNvbHZlU2NoZW1hLmNhbGwodGhpcywgcm9vdCwgJHJlZik7XG4gICAgfVxuICAgIC8vIGV2ZW4gdGhvdWdoIHJlc29sdXRpb24gZmFpbGVkIHdlIG5lZWQgdG8gcmV0dXJuIFNjaGVtYUVudiB0byB0aHJvdyBleGNlcHRpb25cbiAgICAvLyBzbyB0aGF0IGNvbXBpbGVBc3luYyBsb2FkcyBtaXNzaW5nIHNjaGVtYS5cbiAgICBjb25zdCB7IHNjaGVtYUlkIH0gPSB0aGlzLm9wdHM7XG4gICAgZW52ID0gZW52IHx8IG5ldyBTY2hlbWFFbnYoeyBzY2hlbWEsIHNjaGVtYUlkLCByb290LCBiYXNlSWQgfSk7XG4gICAgaWYgKGVudi5zY2hlbWEgIT09IGVudi5yb290LnNjaGVtYSlcbiAgICAgICAgcmV0dXJuIGVudjtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwie1xuICBcIiRpZFwiOiBcImh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9hanYtdmFsaWRhdG9yL2Fqdi9tYXN0ZXIvbGliL3JlZnMvZGF0YS5qc29uI1wiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiTWV0YS1zY2hlbWEgZm9yICRkYXRhIHJlZmVyZW5jZSAoSlNPTiBBbnlTY2hlbWEgZXh0ZW5zaW9uIHByb3Bvc2FsKVwiLFxuICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgXCJyZXF1aXJlZFwiOiBbXCIkZGF0YVwiXSxcbiAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICBcIiRkYXRhXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJhbnlPZlwiOiBbe1wiZm9ybWF0XCI6IFwicmVsYXRpdmUtanNvbi1wb2ludGVyXCJ9LCB7XCJmb3JtYXRcIjogXCJqc29uLXBvaW50ZXJcIn1dXG4gICAgfVxuICB9LFxuICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IGZhbHNlXG59XG4iLCIndXNlIHN0cmljdCdcblxuLyoqIEB0eXBlIHsodmFsdWU6IHN0cmluZykgPT4gYm9vbGVhbn0gKi9cbmNvbnN0IGlzVVVJRCA9IFJlZ0V4cC5wcm90b3R5cGUudGVzdC5iaW5kKC9eW1xcZGEtZl17OH0tW1xcZGEtZl17NH0tW1xcZGEtZl17NH0tW1xcZGEtZl17NH0tW1xcZGEtZl17MTJ9JC9pdSlcblxuLyoqIEB0eXBlIHsodmFsdWU6IHN0cmluZykgPT4gYm9vbGVhbn0gKi9cbmNvbnN0IGlzSVB2NCA9IFJlZ0V4cC5wcm90b3R5cGUudGVzdC5iaW5kKC9eKD86KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZHsyfXxbMS05XVxcZHxcXGQpXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfDFcXGR7Mn18WzEtOV1cXGR8XFxkKSQvdSlcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGlucHV0XG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBzdHJpbmdBcnJheVRvSGV4U3RyaXBwZWQgKGlucHV0KSB7XG4gIGxldCBhY2MgPSAnJ1xuICBsZXQgY29kZSA9IDBcbiAgbGV0IGkgPSAwXG5cbiAgZm9yIChpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29kZSA9IGlucHV0W2ldLmNoYXJDb2RlQXQoMClcbiAgICBpZiAoY29kZSA9PT0gNDgpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmICghKChjb2RlID49IDQ4ICYmIGNvZGUgPD0gNTcpIHx8IChjb2RlID49IDY1ICYmIGNvZGUgPD0gNzApIHx8IChjb2RlID49IDk3ICYmIGNvZGUgPD0gMTAyKSkpIHtcbiAgICAgIHJldHVybiAnJ1xuICAgIH1cbiAgICBhY2MgKz0gaW5wdXRbaV1cbiAgICBicmVha1xuICB9XG5cbiAgZm9yIChpICs9IDE7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgIGNvZGUgPSBpbnB1dFtpXS5jaGFyQ29kZUF0KDApXG4gICAgaWYgKCEoKGNvZGUgPj0gNDggJiYgY29kZSA8PSA1NykgfHwgKGNvZGUgPj0gNjUgJiYgY29kZSA8PSA3MCkgfHwgKGNvZGUgPj0gOTcgJiYgY29kZSA8PSAxMDIpKSkge1xuICAgICAgcmV0dXJuICcnXG4gICAgfVxuICAgIGFjYyArPSBpbnB1dFtpXVxuICB9XG4gIHJldHVybiBhY2Ncbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBHZXRJUFY2UmVzdWx0XG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGVycm9yIC0gSW5kaWNhdGVzIGlmIHRoZXJlIHdhcyBhbiBlcnJvciBwYXJzaW5nIHRoZSBJUHY2IGFkZHJlc3MuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gYWRkcmVzcyAtIFRoZSBwYXJzZWQgSVB2NiBhZGRyZXNzLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt6b25lXSAtIFRoZSB6b25lIGlkZW50aWZpZXIsIGlmIHByZXNlbnQuXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5jb25zdCBub25TaW1wbGVEb21haW4gPSBSZWdFeHAucHJvdG90eXBlLnRlc3QuYmluZCgvW14hXCIkJicoKSorLFxcLS47PV9gYS16e31+XS91KVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gYnVmZmVyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gY29uc3VtZUlzWm9uZSAoYnVmZmVyKSB7XG4gIGJ1ZmZlci5sZW5ndGggPSAwXG4gIHJldHVybiB0cnVlXG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBidWZmZXJcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gYWRkcmVzc1xuICogQHBhcmFtIHtHZXRJUFY2UmVzdWx0fSBvdXRwdXRcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBjb25zdW1lSGV4dGV0cyAoYnVmZmVyLCBhZGRyZXNzLCBvdXRwdXQpIHtcbiAgaWYgKGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBjb25zdCBoZXggPSBzdHJpbmdBcnJheVRvSGV4U3RyaXBwZWQoYnVmZmVyKVxuICAgIGlmIChoZXggIT09ICcnKSB7XG4gICAgICBhZGRyZXNzLnB1c2goaGV4KVxuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQuZXJyb3IgPSB0cnVlXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgYnVmZmVyLmxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFxuICogQHJldHVybnMge0dldElQVjZSZXN1bHR9XG4gKi9cbmZ1bmN0aW9uIGdldElQVjYgKGlucHV0KSB7XG4gIGxldCB0b2tlbkNvdW50ID0gMFxuICBjb25zdCBvdXRwdXQgPSB7IGVycm9yOiBmYWxzZSwgYWRkcmVzczogJycsIHpvbmU6ICcnIH1cbiAgLyoqIEB0eXBlIHtBcnJheTxzdHJpbmc+fSAqL1xuICBjb25zdCBhZGRyZXNzID0gW11cbiAgLyoqIEB0eXBlIHtBcnJheTxzdHJpbmc+fSAqL1xuICBjb25zdCBidWZmZXIgPSBbXVxuICBsZXQgZW5kaXB2NkVuY291bnRlcmVkID0gZmFsc2VcbiAgbGV0IGVuZElwdjYgPSBmYWxzZVxuXG4gIGxldCBjb25zdW1lID0gY29uc3VtZUhleHRldHNcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY3Vyc29yID0gaW5wdXRbaV1cbiAgICBpZiAoY3Vyc29yID09PSAnWycgfHwgY3Vyc29yID09PSAnXScpIHsgY29udGludWUgfVxuICAgIGlmIChjdXJzb3IgPT09ICc6Jykge1xuICAgICAgaWYgKGVuZGlwdjZFbmNvdW50ZXJlZCA9PT0gdHJ1ZSkge1xuICAgICAgICBlbmRJcHY2ID0gdHJ1ZVxuICAgICAgfVxuICAgICAgaWYgKCFjb25zdW1lKGJ1ZmZlciwgYWRkcmVzcywgb3V0cHV0KSkgeyBicmVhayB9XG4gICAgICBpZiAoKyt0b2tlbkNvdW50ID4gNykge1xuICAgICAgICAvLyBub3QgdmFsaWRcbiAgICAgICAgb3V0cHV0LmVycm9yID0gdHJ1ZVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgaWYgKGkgPiAwICYmIGlucHV0W2kgLSAxXSA9PT0gJzonKSB7XG4gICAgICAgIGVuZGlwdjZFbmNvdW50ZXJlZCA9IHRydWVcbiAgICAgIH1cbiAgICAgIGFkZHJlc3MucHVzaCgnOicpXG4gICAgICBjb250aW51ZVxuICAgIH0gZWxzZSBpZiAoY3Vyc29yID09PSAnJScpIHtcbiAgICAgIGlmICghY29uc3VtZShidWZmZXIsIGFkZHJlc3MsIG91dHB1dCkpIHsgYnJlYWsgfVxuICAgICAgLy8gc3dpdGNoIHRvIHpvbmUgZGV0ZWN0aW9uXG4gICAgICBjb25zdW1lID0gY29uc3VtZUlzWm9uZVxuICAgIH0gZWxzZSB7XG4gICAgICBidWZmZXIucHVzaChjdXJzb3IpXG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgfVxuICBpZiAoYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChjb25zdW1lID09PSBjb25zdW1lSXNab25lKSB7XG4gICAgICBvdXRwdXQuem9uZSA9IGJ1ZmZlci5qb2luKCcnKVxuICAgIH0gZWxzZSBpZiAoZW5kSXB2Nikge1xuICAgICAgYWRkcmVzcy5wdXNoKGJ1ZmZlci5qb2luKCcnKSlcbiAgICB9IGVsc2Uge1xuICAgICAgYWRkcmVzcy5wdXNoKHN0cmluZ0FycmF5VG9IZXhTdHJpcHBlZChidWZmZXIpKVxuICAgIH1cbiAgfVxuICBvdXRwdXQuYWRkcmVzcyA9IGFkZHJlc3Muam9pbignJylcbiAgcmV0dXJuIG91dHB1dFxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE5vcm1hbGl6ZUlQdjZSZXN1bHRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBob3N0IC0gVGhlIG5vcm1hbGl6ZWQgaG9zdC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZXNjYXBlZEhvc3RdIC0gVGhlIGVzY2FwZWQgaG9zdC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNJUFY2IC0gSW5kaWNhdGVzIGlmIHRoZSBob3N0IGlzIGFuIElQdjYgYWRkcmVzcy5cbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBob3N0XG4gKiBAcmV0dXJucyB7Tm9ybWFsaXplSVB2NlJlc3VsdH1cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplSVB2NiAoaG9zdCkge1xuICBpZiAoZmluZFRva2VuKGhvc3QsICc6JykgPCAyKSB7IHJldHVybiB7IGhvc3QsIGlzSVBWNjogZmFsc2UgfSB9XG4gIGNvbnN0IGlwdjYgPSBnZXRJUFY2KGhvc3QpXG5cbiAgaWYgKCFpcHY2LmVycm9yKSB7XG4gICAgbGV0IG5ld0hvc3QgPSBpcHY2LmFkZHJlc3NcbiAgICBsZXQgZXNjYXBlZEhvc3QgPSBpcHY2LmFkZHJlc3NcbiAgICBpZiAoaXB2Ni56b25lKSB7XG4gICAgICBuZXdIb3N0ICs9ICclJyArIGlwdjYuem9uZVxuICAgICAgZXNjYXBlZEhvc3QgKz0gJyUyNScgKyBpcHY2LnpvbmVcbiAgICB9XG4gICAgcmV0dXJuIHsgaG9zdDogbmV3SG9zdCwgaXNJUFY2OiB0cnVlLCBlc2NhcGVkSG9zdCB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHsgaG9zdCwgaXNJUFY2OiBmYWxzZSB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9rZW5cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGZpbmRUb2tlbiAoc3RyLCB0b2tlbikge1xuICBsZXQgaW5kID0gMFxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChzdHJbaV0gPT09IHRva2VuKSBpbmQrK1xuICB9XG4gIHJldHVybiBpbmRcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aFxuICogQHJldHVybnMge3N0cmluZ31cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTUuMi40XG4gKi9cbmZ1bmN0aW9uIHJlbW92ZURvdFNlZ21lbnRzIChwYXRoKSB7XG4gIGxldCBpbnB1dCA9IHBhdGhcbiAgY29uc3Qgb3V0cHV0ID0gW11cbiAgbGV0IG5leHRTbGFzaCA9IC0xXG4gIGxldCBsZW4gPSAwXG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbmQtYXNzaWduXG4gIHdoaWxlIChsZW4gPSBpbnB1dC5sZW5ndGgpIHtcbiAgICBpZiAobGVuID09PSAxKSB7XG4gICAgICBpZiAoaW5wdXQgPT09ICcuJykge1xuICAgICAgICBicmVha1xuICAgICAgfSBlbHNlIGlmIChpbnB1dCA9PT0gJy8nKSB7XG4gICAgICAgIG91dHB1dC5wdXNoKCcvJylcbiAgICAgICAgYnJlYWtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dHB1dC5wdXNoKGlucHV0KVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobGVuID09PSAyKSB7XG4gICAgICBpZiAoaW5wdXRbMF0gPT09ICcuJykge1xuICAgICAgICBpZiAoaW5wdXRbMV0gPT09ICcuJykge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXRbMV0gPT09ICcvJykge1xuICAgICAgICAgIGlucHV0ID0gaW5wdXQuc2xpY2UoMilcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlucHV0WzBdID09PSAnLycpIHtcbiAgICAgICAgaWYgKGlucHV0WzFdID09PSAnLicgfHwgaW5wdXRbMV0gPT09ICcvJykge1xuICAgICAgICAgIG91dHB1dC5wdXNoKCcvJylcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsZW4gPT09IDMpIHtcbiAgICAgIGlmIChpbnB1dCA9PT0gJy8uLicpIHtcbiAgICAgICAgaWYgKG91dHB1dC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICBvdXRwdXQucG9wKClcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXQucHVzaCgnLycpXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpbnB1dFswXSA9PT0gJy4nKSB7XG4gICAgICBpZiAoaW5wdXRbMV0gPT09ICcuJykge1xuICAgICAgICBpZiAoaW5wdXRbMl0gPT09ICcvJykge1xuICAgICAgICAgIGlucHV0ID0gaW5wdXQuc2xpY2UoMylcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlucHV0WzFdID09PSAnLycpIHtcbiAgICAgICAgaW5wdXQgPSBpbnB1dC5zbGljZSgyKVxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaW5wdXRbMF0gPT09ICcvJykge1xuICAgICAgaWYgKGlucHV0WzFdID09PSAnLicpIHtcbiAgICAgICAgaWYgKGlucHV0WzJdID09PSAnLycpIHtcbiAgICAgICAgICBpbnB1dCA9IGlucHV0LnNsaWNlKDIpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dFsyXSA9PT0gJy4nKSB7XG4gICAgICAgICAgaWYgKGlucHV0WzNdID09PSAnLycpIHtcbiAgICAgICAgICAgIGlucHV0ID0gaW5wdXQuc2xpY2UoMylcbiAgICAgICAgICAgIGlmIChvdXRwdXQubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgIG91dHB1dC5wb3AoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSdWxlIDJFOiBNb3ZlIG5vcm1hbCBwYXRoIHNlZ21lbnQgdG8gb3V0cHV0XG4gICAgaWYgKChuZXh0U2xhc2ggPSBpbnB1dC5pbmRleE9mKCcvJywgMSkpID09PSAtMSkge1xuICAgICAgb3V0cHV0LnB1c2goaW5wdXQpXG4gICAgICBicmVha1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaChpbnB1dC5zbGljZSgwLCBuZXh0U2xhc2gpKVxuICAgICAgaW5wdXQgPSBpbnB1dC5zbGljZShuZXh0U2xhc2gpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi90eXBlcy9pbmRleCcpLlVSSUNvbXBvbmVudH0gY29tcG9uZW50XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGVzY1xuICogQHJldHVybnMge2ltcG9ydCgnLi4vdHlwZXMvaW5kZXgnKS5VUklDb21wb25lbnR9XG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nIChjb21wb25lbnQsIGVzYykge1xuICBjb25zdCBmdW5jID0gZXNjICE9PSB0cnVlID8gZXNjYXBlIDogdW5lc2NhcGVcbiAgaWYgKGNvbXBvbmVudC5zY2hlbWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbXBvbmVudC5zY2hlbWUgPSBmdW5jKGNvbXBvbmVudC5zY2hlbWUpXG4gIH1cbiAgaWYgKGNvbXBvbmVudC51c2VyaW5mbyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29tcG9uZW50LnVzZXJpbmZvID0gZnVuYyhjb21wb25lbnQudXNlcmluZm8pXG4gIH1cbiAgaWYgKGNvbXBvbmVudC5ob3N0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb21wb25lbnQuaG9zdCA9IGZ1bmMoY29tcG9uZW50Lmhvc3QpXG4gIH1cbiAgaWYgKGNvbXBvbmVudC5wYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb21wb25lbnQucGF0aCA9IGZ1bmMoY29tcG9uZW50LnBhdGgpXG4gIH1cbiAgaWYgKGNvbXBvbmVudC5xdWVyeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29tcG9uZW50LnF1ZXJ5ID0gZnVuYyhjb21wb25lbnQucXVlcnkpXG4gIH1cbiAgaWYgKGNvbXBvbmVudC5mcmFnbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29tcG9uZW50LmZyYWdtZW50ID0gZnVuYyhjb21wb25lbnQuZnJhZ21lbnQpXG4gIH1cbiAgcmV0dXJuIGNvbXBvbmVudFxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi90eXBlcy9pbmRleCcpLlVSSUNvbXBvbmVudH0gY29tcG9uZW50XG4gKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gcmVjb21wb3NlQXV0aG9yaXR5IChjb21wb25lbnQpIHtcbiAgY29uc3QgdXJpVG9rZW5zID0gW11cblxuICBpZiAoY29tcG9uZW50LnVzZXJpbmZvICE9PSB1bmRlZmluZWQpIHtcbiAgICB1cmlUb2tlbnMucHVzaChjb21wb25lbnQudXNlcmluZm8pXG4gICAgdXJpVG9rZW5zLnB1c2goJ0AnKVxuICB9XG5cbiAgaWYgKGNvbXBvbmVudC5ob3N0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBsZXQgaG9zdCA9IHVuZXNjYXBlKGNvbXBvbmVudC5ob3N0KVxuICAgIGlmICghaXNJUHY0KGhvc3QpKSB7XG4gICAgICBjb25zdCBpcFY2cmVzID0gbm9ybWFsaXplSVB2Nihob3N0KVxuICAgICAgaWYgKGlwVjZyZXMuaXNJUFY2ID09PSB0cnVlKSB7XG4gICAgICAgIGhvc3QgPSBgWyR7aXBWNnJlcy5lc2NhcGVkSG9zdH1dYFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaG9zdCA9IGNvbXBvbmVudC5ob3N0XG4gICAgICB9XG4gICAgfVxuICAgIHVyaVRva2Vucy5wdXNoKGhvc3QpXG4gIH1cblxuICBpZiAodHlwZW9mIGNvbXBvbmVudC5wb3J0ID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgY29tcG9uZW50LnBvcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgdXJpVG9rZW5zLnB1c2goJzonKVxuICAgIHVyaVRva2Vucy5wdXNoKFN0cmluZyhjb21wb25lbnQucG9ydCkpXG4gIH1cblxuICByZXR1cm4gdXJpVG9rZW5zLmxlbmd0aCA/IHVyaVRva2Vucy5qb2luKCcnKSA6IHVuZGVmaW5lZFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG5vblNpbXBsZURvbWFpbixcbiAgcmVjb21wb3NlQXV0aG9yaXR5LFxuICBub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyxcbiAgcmVtb3ZlRG90U2VnbWVudHMsXG4gIGlzSVB2NCxcbiAgaXNVVUlELFxuICBub3JtYWxpemVJUHY2LFxuICBzdHJpbmdBcnJheVRvSGV4U3RyaXBwZWRcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IGlzVVVJRCB9ID0gcmVxdWlyZSgnLi91dGlscycpXG5jb25zdCBVUk5fUkVHID0gLyhbXFxkYS16XVtcXGRcXC1hLXpdezAsMzF9KTooKD86W1xcdyEkJygpKissXFwtLjo7PUBdfCVbXFxkYS1mXXsyfSkrKS9pdVxuXG5jb25zdCBzdXBwb3J0ZWRTY2hlbWVOYW1lcyA9IC8qKiBAdHlwZSB7Y29uc3R9ICovIChbJ2h0dHAnLCAnaHR0cHMnLCAnd3MnLFxuICAnd3NzJywgJ3VybicsICd1cm46dXVpZCddKVxuXG4vKiogQHR5cGVkZWYge3N1cHBvcnRlZFNjaGVtZU5hbWVzW251bWJlcl19IFNjaGVtZU5hbWUgKi9cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybnMge25hbWUgaXMgU2NoZW1lTmFtZX1cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZFNjaGVtZU5hbWUgKG5hbWUpIHtcbiAgcmV0dXJuIHN1cHBvcnRlZFNjaGVtZU5hbWVzLmluZGV4T2YoLyoqIEB0eXBlIHsqfSAqLyAobmFtZSkpICE9PSAtMVxufVxuXG4vKipcbiAqIEBjYWxsYmFjayBTY2hlbWVGblxuICogQHBhcmFtIHtpbXBvcnQoJy4uL3R5cGVzL2luZGV4JykuVVJJQ29tcG9uZW50fSBjb21wb25lbnRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi90eXBlcy9pbmRleCcpLk9wdGlvbnN9IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4uL3R5cGVzL2luZGV4JykuVVJJQ29tcG9uZW50fVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gU2NoZW1lSGFuZGxlclxuICogQHByb3BlcnR5IHtTY2hlbWVOYW1lfSBzY2hlbWUgLSBUaGUgc2NoZW1lIG5hbWUuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtkb21haW5Ib3N0XSAtIEluZGljYXRlcyBpZiB0aGUgc2NoZW1lIHN1cHBvcnRzIGRvbWFpbiBob3N0cy5cbiAqIEBwcm9wZXJ0eSB7U2NoZW1lRm59IHBhcnNlIC0gRnVuY3Rpb24gdG8gcGFyc2UgdGhlIFVSSSBjb21wb25lbnQgZm9yIHRoaXMgc2NoZW1lLlxuICogQHByb3BlcnR5IHtTY2hlbWVGbn0gc2VyaWFsaXplIC0gRnVuY3Rpb24gdG8gc2VyaWFsaXplIHRoZSBVUkkgY29tcG9uZW50IGZvciB0aGlzIHNjaGVtZS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3NraXBOb3JtYWxpemVdIC0gSW5kaWNhdGVzIGlmIG5vcm1hbGl6YXRpb24gc2hvdWxkIGJlIHNraXBwZWQgZm9yIHRoaXMgc2NoZW1lLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbYWJzb2x1dGVQYXRoXSAtIEluZGljYXRlcyBpZiB0aGUgc2NoZW1lIHVzZXMgYWJzb2x1dGUgcGF0aHMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt1bmljb2RlU3VwcG9ydF0gLSBJbmRpY2F0ZXMgaWYgdGhlIHNjaGVtZSBzdXBwb3J0cyBVbmljb2RlLlxuICovXG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4uL3R5cGVzL2luZGV4JykuVVJJQ29tcG9uZW50fSB3c0NvbXBvbmVudFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIHdzSXNTZWN1cmUgKHdzQ29tcG9uZW50KSB7XG4gIGlmICh3c0NvbXBvbmVudC5zZWN1cmUgPT09IHRydWUpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9IGVsc2UgaWYgKHdzQ29tcG9uZW50LnNlY3VyZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGlmICh3c0NvbXBvbmVudC5zY2hlbWUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgd3NDb21wb25lbnQuc2NoZW1lLmxlbmd0aCA9PT0gMyAmJlxuICAgICAgKHdzQ29tcG9uZW50LnNjaGVtZVswXSA9PT0gJ3cnIHx8IHdzQ29tcG9uZW50LnNjaGVtZVswXSA9PT0gJ1cnKSAmJlxuICAgICAgKHdzQ29tcG9uZW50LnNjaGVtZVsxXSA9PT0gJ3MnIHx8IHdzQ29tcG9uZW50LnNjaGVtZVsxXSA9PT0gJ1MnKSAmJlxuICAgICAgKHdzQ29tcG9uZW50LnNjaGVtZVsyXSA9PT0gJ3MnIHx8IHdzQ29tcG9uZW50LnNjaGVtZVsyXSA9PT0gJ1MnKVxuICAgIClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG4vKiogQHR5cGUge1NjaGVtZUZufSAqL1xuZnVuY3Rpb24gaHR0cFBhcnNlIChjb21wb25lbnQpIHtcbiAgaWYgKCFjb21wb25lbnQuaG9zdCkge1xuICAgIGNvbXBvbmVudC5lcnJvciA9IGNvbXBvbmVudC5lcnJvciB8fCAnSFRUUCBVUklzIG11c3QgaGF2ZSBhIGhvc3QuJ1xuICB9XG5cbiAgcmV0dXJuIGNvbXBvbmVudFxufVxuXG4vKiogQHR5cGUge1NjaGVtZUZufSAqL1xuZnVuY3Rpb24gaHR0cFNlcmlhbGl6ZSAoY29tcG9uZW50KSB7XG4gIGNvbnN0IHNlY3VyZSA9IFN0cmluZyhjb21wb25lbnQuc2NoZW1lKS50b0xvd2VyQ2FzZSgpID09PSAnaHR0cHMnXG5cbiAgLy8gbm9ybWFsaXplIHRoZSBkZWZhdWx0IHBvcnRcbiAgaWYgKGNvbXBvbmVudC5wb3J0ID09PSAoc2VjdXJlID8gNDQzIDogODApIHx8IGNvbXBvbmVudC5wb3J0ID09PSAnJykge1xuICAgIGNvbXBvbmVudC5wb3J0ID0gdW5kZWZpbmVkXG4gIH1cblxuICAvLyBub3JtYWxpemUgdGhlIGVtcHR5IHBhdGhcbiAgaWYgKCFjb21wb25lbnQucGF0aCkge1xuICAgIGNvbXBvbmVudC5wYXRoID0gJy8nXG4gIH1cblxuICAvLyBOT1RFOiBXZSBkbyBub3QgcGFyc2UgcXVlcnkgc3RyaW5ncyBmb3IgSFRUUCBVUklzXG4gIC8vIGFzIFdXVyBGb3JtIFVybCBFbmNvZGVkIHF1ZXJ5IHN0cmluZ3MgYXJlIHBhcnQgb2YgdGhlIEhUTUw0KyBzcGVjLFxuICAvLyBhbmQgbm90IHRoZSBIVFRQIHNwZWMuXG5cbiAgcmV0dXJuIGNvbXBvbmVudFxufVxuXG4vKiogQHR5cGUge1NjaGVtZUZufSAqL1xuZnVuY3Rpb24gd3NQYXJzZSAod3NDb21wb25lbnQpIHtcbi8vIGluZGljYXRlIGlmIHRoZSBzZWN1cmUgZmxhZyBpcyBzZXRcbiAgd3NDb21wb25lbnQuc2VjdXJlID0gd3NJc1NlY3VyZSh3c0NvbXBvbmVudClcblxuICAvLyBjb25zdHJ1Y3QgcmVzb3VjZSBuYW1lXG4gIHdzQ29tcG9uZW50LnJlc291cmNlTmFtZSA9ICh3c0NvbXBvbmVudC5wYXRoIHx8ICcvJykgKyAod3NDb21wb25lbnQucXVlcnkgPyAnPycgKyB3c0NvbXBvbmVudC5xdWVyeSA6ICcnKVxuICB3c0NvbXBvbmVudC5wYXRoID0gdW5kZWZpbmVkXG4gIHdzQ29tcG9uZW50LnF1ZXJ5ID0gdW5kZWZpbmVkXG5cbiAgcmV0dXJuIHdzQ29tcG9uZW50XG59XG5cbi8qKiBAdHlwZSB7U2NoZW1lRm59ICovXG5mdW5jdGlvbiB3c1NlcmlhbGl6ZSAod3NDb21wb25lbnQpIHtcbi8vIG5vcm1hbGl6ZSB0aGUgZGVmYXVsdCBwb3J0XG4gIGlmICh3c0NvbXBvbmVudC5wb3J0ID09PSAod3NJc1NlY3VyZSh3c0NvbXBvbmVudCkgPyA0NDMgOiA4MCkgfHwgd3NDb21wb25lbnQucG9ydCA9PT0gJycpIHtcbiAgICB3c0NvbXBvbmVudC5wb3J0ID0gdW5kZWZpbmVkXG4gIH1cblxuICAvLyBlbnN1cmUgc2NoZW1lIG1hdGNoZXMgc2VjdXJlIGZsYWdcbiAgaWYgKHR5cGVvZiB3c0NvbXBvbmVudC5zZWN1cmUgPT09ICdib29sZWFuJykge1xuICAgIHdzQ29tcG9uZW50LnNjaGVtZSA9ICh3c0NvbXBvbmVudC5zZWN1cmUgPyAnd3NzJyA6ICd3cycpXG4gICAgd3NDb21wb25lbnQuc2VjdXJlID0gdW5kZWZpbmVkXG4gIH1cblxuICAvLyByZWNvbnN0cnVjdCBwYXRoIGZyb20gcmVzb3VyY2UgbmFtZVxuICBpZiAod3NDb21wb25lbnQucmVzb3VyY2VOYW1lKSB7XG4gICAgY29uc3QgW3BhdGgsIHF1ZXJ5XSA9IHdzQ29tcG9uZW50LnJlc291cmNlTmFtZS5zcGxpdCgnPycpXG4gICAgd3NDb21wb25lbnQucGF0aCA9IChwYXRoICYmIHBhdGggIT09ICcvJyA/IHBhdGggOiB1bmRlZmluZWQpXG4gICAgd3NDb21wb25lbnQucXVlcnkgPSBxdWVyeVxuICAgIHdzQ29tcG9uZW50LnJlc291cmNlTmFtZSA9IHVuZGVmaW5lZFxuICB9XG5cbiAgLy8gZm9yYmlkIGZyYWdtZW50IGNvbXBvbmVudFxuICB3c0NvbXBvbmVudC5mcmFnbWVudCA9IHVuZGVmaW5lZFxuXG4gIHJldHVybiB3c0NvbXBvbmVudFxufVxuXG4vKiogQHR5cGUge1NjaGVtZUZufSAqL1xuZnVuY3Rpb24gdXJuUGFyc2UgKHVybkNvbXBvbmVudCwgb3B0aW9ucykge1xuICBpZiAoIXVybkNvbXBvbmVudC5wYXRoKSB7XG4gICAgdXJuQ29tcG9uZW50LmVycm9yID0gJ1VSTiBjYW4gbm90IGJlIHBhcnNlZCdcbiAgICByZXR1cm4gdXJuQ29tcG9uZW50XG4gIH1cbiAgY29uc3QgbWF0Y2hlcyA9IHVybkNvbXBvbmVudC5wYXRoLm1hdGNoKFVSTl9SRUcpXG4gIGlmIChtYXRjaGVzKSB7XG4gICAgY29uc3Qgc2NoZW1lID0gb3B0aW9ucy5zY2hlbWUgfHwgdXJuQ29tcG9uZW50LnNjaGVtZSB8fCAndXJuJ1xuICAgIHVybkNvbXBvbmVudC5uaWQgPSBtYXRjaGVzWzFdLnRvTG93ZXJDYXNlKClcbiAgICB1cm5Db21wb25lbnQubnNzID0gbWF0Y2hlc1syXVxuICAgIGNvbnN0IHVyblNjaGVtZSA9IGAke3NjaGVtZX06JHtvcHRpb25zLm5pZCB8fCB1cm5Db21wb25lbnQubmlkfWBcbiAgICBjb25zdCBzY2hlbWVIYW5kbGVyID0gZ2V0U2NoZW1lSGFuZGxlcih1cm5TY2hlbWUpXG4gICAgdXJuQ29tcG9uZW50LnBhdGggPSB1bmRlZmluZWRcblxuICAgIGlmIChzY2hlbWVIYW5kbGVyKSB7XG4gICAgICB1cm5Db21wb25lbnQgPSBzY2hlbWVIYW5kbGVyLnBhcnNlKHVybkNvbXBvbmVudCwgb3B0aW9ucylcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdXJuQ29tcG9uZW50LmVycm9yID0gdXJuQ29tcG9uZW50LmVycm9yIHx8ICdVUk4gY2FuIG5vdCBiZSBwYXJzZWQuJ1xuICB9XG5cbiAgcmV0dXJuIHVybkNvbXBvbmVudFxufVxuXG4vKiogQHR5cGUge1NjaGVtZUZufSAqL1xuZnVuY3Rpb24gdXJuU2VyaWFsaXplICh1cm5Db21wb25lbnQsIG9wdGlvbnMpIHtcbiAgaWYgKHVybkNvbXBvbmVudC5uaWQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVVJOIHdpdGhvdXQgbmlkIGNhbm5vdCBiZSBzZXJpYWxpemVkJylcbiAgfVxuICBjb25zdCBzY2hlbWUgPSBvcHRpb25zLnNjaGVtZSB8fCB1cm5Db21wb25lbnQuc2NoZW1lIHx8ICd1cm4nXG4gIGNvbnN0IG5pZCA9IHVybkNvbXBvbmVudC5uaWQudG9Mb3dlckNhc2UoKVxuICBjb25zdCB1cm5TY2hlbWUgPSBgJHtzY2hlbWV9OiR7b3B0aW9ucy5uaWQgfHwgbmlkfWBcbiAgY29uc3Qgc2NoZW1lSGFuZGxlciA9IGdldFNjaGVtZUhhbmRsZXIodXJuU2NoZW1lKVxuXG4gIGlmIChzY2hlbWVIYW5kbGVyKSB7XG4gICAgdXJuQ29tcG9uZW50ID0gc2NoZW1lSGFuZGxlci5zZXJpYWxpemUodXJuQ29tcG9uZW50LCBvcHRpb25zKVxuICB9XG5cbiAgY29uc3QgdXJpQ29tcG9uZW50ID0gdXJuQ29tcG9uZW50XG4gIGNvbnN0IG5zcyA9IHVybkNvbXBvbmVudC5uc3NcbiAgdXJpQ29tcG9uZW50LnBhdGggPSBgJHtuaWQgfHwgb3B0aW9ucy5uaWR9OiR7bnNzfWBcblxuICBvcHRpb25zLnNraXBFc2NhcGUgPSB0cnVlXG4gIHJldHVybiB1cmlDb21wb25lbnRcbn1cblxuLyoqIEB0eXBlIHtTY2hlbWVGbn0gKi9cbmZ1bmN0aW9uIHVybnV1aWRQYXJzZSAodXJuQ29tcG9uZW50LCBvcHRpb25zKSB7XG4gIGNvbnN0IHV1aWRDb21wb25lbnQgPSB1cm5Db21wb25lbnRcbiAgdXVpZENvbXBvbmVudC51dWlkID0gdXVpZENvbXBvbmVudC5uc3NcbiAgdXVpZENvbXBvbmVudC5uc3MgPSB1bmRlZmluZWRcblxuICBpZiAoIW9wdGlvbnMudG9sZXJhbnQgJiYgKCF1dWlkQ29tcG9uZW50LnV1aWQgfHwgIWlzVVVJRCh1dWlkQ29tcG9uZW50LnV1aWQpKSkge1xuICAgIHV1aWRDb21wb25lbnQuZXJyb3IgPSB1dWlkQ29tcG9uZW50LmVycm9yIHx8ICdVVUlEIGlzIG5vdCB2YWxpZC4nXG4gIH1cblxuICByZXR1cm4gdXVpZENvbXBvbmVudFxufVxuXG4vKiogQHR5cGUge1NjaGVtZUZufSAqL1xuZnVuY3Rpb24gdXJudXVpZFNlcmlhbGl6ZSAodXVpZENvbXBvbmVudCkge1xuICBjb25zdCB1cm5Db21wb25lbnQgPSB1dWlkQ29tcG9uZW50XG4gIC8vIG5vcm1hbGl6ZSBVVUlEXG4gIHVybkNvbXBvbmVudC5uc3MgPSAodXVpZENvbXBvbmVudC51dWlkIHx8ICcnKS50b0xvd2VyQ2FzZSgpXG4gIHJldHVybiB1cm5Db21wb25lbnRcbn1cblxuY29uc3QgaHR0cCA9IC8qKiBAdHlwZSB7U2NoZW1lSGFuZGxlcn0gKi8gKHtcbiAgc2NoZW1lOiAnaHR0cCcsXG4gIGRvbWFpbkhvc3Q6IHRydWUsXG4gIHBhcnNlOiBodHRwUGFyc2UsXG4gIHNlcmlhbGl6ZTogaHR0cFNlcmlhbGl6ZVxufSlcblxuY29uc3QgaHR0cHMgPSAvKiogQHR5cGUge1NjaGVtZUhhbmRsZXJ9ICovICh7XG4gIHNjaGVtZTogJ2h0dHBzJyxcbiAgZG9tYWluSG9zdDogaHR0cC5kb21haW5Ib3N0LFxuICBwYXJzZTogaHR0cFBhcnNlLFxuICBzZXJpYWxpemU6IGh0dHBTZXJpYWxpemVcbn0pXG5cbmNvbnN0IHdzID0gLyoqIEB0eXBlIHtTY2hlbWVIYW5kbGVyfSAqLyAoe1xuICBzY2hlbWU6ICd3cycsXG4gIGRvbWFpbkhvc3Q6IHRydWUsXG4gIHBhcnNlOiB3c1BhcnNlLFxuICBzZXJpYWxpemU6IHdzU2VyaWFsaXplXG59KVxuXG5jb25zdCB3c3MgPSAvKiogQHR5cGUge1NjaGVtZUhhbmRsZXJ9ICovICh7XG4gIHNjaGVtZTogJ3dzcycsXG4gIGRvbWFpbkhvc3Q6IHdzLmRvbWFpbkhvc3QsXG4gIHBhcnNlOiB3cy5wYXJzZSxcbiAgc2VyaWFsaXplOiB3cy5zZXJpYWxpemVcbn0pXG5cbmNvbnN0IHVybiA9IC8qKiBAdHlwZSB7U2NoZW1lSGFuZGxlcn0gKi8gKHtcbiAgc2NoZW1lOiAndXJuJyxcbiAgcGFyc2U6IHVyblBhcnNlLFxuICBzZXJpYWxpemU6IHVyblNlcmlhbGl6ZSxcbiAgc2tpcE5vcm1hbGl6ZTogdHJ1ZVxufSlcblxuY29uc3QgdXJudXVpZCA9IC8qKiBAdHlwZSB7U2NoZW1lSGFuZGxlcn0gKi8gKHtcbiAgc2NoZW1lOiAndXJuOnV1aWQnLFxuICBwYXJzZTogdXJudXVpZFBhcnNlLFxuICBzZXJpYWxpemU6IHVybnV1aWRTZXJpYWxpemUsXG4gIHNraXBOb3JtYWxpemU6IHRydWVcbn0pXG5cbmNvbnN0IFNDSEVNRVMgPSAvKiogQHR5cGUge1JlY29yZDxTY2hlbWVOYW1lLCBTY2hlbWVIYW5kbGVyPn0gKi8gKHtcbiAgaHR0cCxcbiAgaHR0cHMsXG4gIHdzLFxuICB3c3MsXG4gIHVybixcbiAgJ3Vybjp1dWlkJzogdXJudXVpZFxufSlcblxuT2JqZWN0LnNldFByb3RvdHlwZU9mKFNDSEVNRVMsIG51bGwpXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8dW5kZWZpbmVkfSBzY2hlbWVcbiAqIEByZXR1cm5zIHtTY2hlbWVIYW5kbGVyfHVuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gZ2V0U2NoZW1lSGFuZGxlciAoc2NoZW1lKSB7XG4gIHJldHVybiAoXG4gICAgc2NoZW1lICYmIChcbiAgICAgIFNDSEVNRVNbLyoqIEB0eXBlIHtTY2hlbWVOYW1lfSAqLyAoc2NoZW1lKV0gfHxcbiAgICAgIFNDSEVNRVNbLyoqIEB0eXBlIHtTY2hlbWVOYW1lfSAqLyhzY2hlbWUudG9Mb3dlckNhc2UoKSldKVxuICApIHx8XG4gICAgdW5kZWZpbmVkXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB3c0lzU2VjdXJlLFxuICBTQ0hFTUVTLFxuICBpc1ZhbGlkU2NoZW1lTmFtZSxcbiAgZ2V0U2NoZW1lSGFuZGxlcixcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IG5vcm1hbGl6ZUlQdjYsIHJlbW92ZURvdFNlZ21lbnRzLCByZWNvbXBvc2VBdXRob3JpdHksIG5vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nLCBpc0lQdjQsIG5vblNpbXBsZURvbWFpbiB9ID0gcmVxdWlyZSgnLi9saWIvdXRpbHMnKVxuY29uc3QgeyBTQ0hFTUVTLCBnZXRTY2hlbWVIYW5kbGVyIH0gPSByZXF1aXJlKCcuL2xpYi9zY2hlbWVzJylcblxuLyoqXG4gKiBAdGVtcGxhdGUge2ltcG9ydCgnLi90eXBlcy9pbmRleCcpLlVSSUNvbXBvbmVudHxzdHJpbmd9IFRcbiAqIEBwYXJhbSB7VH0gdXJpXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi90eXBlcy9pbmRleCcpLk9wdGlvbnN9IFtvcHRpb25zXVxuICogQHJldHVybnMge1R9XG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZSAodXJpLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgdXJpID09PSAnc3RyaW5nJykge1xuICAgIHVyaSA9IC8qKiBAdHlwZSB7VH0gKi8gKHNlcmlhbGl6ZShwYXJzZSh1cmksIG9wdGlvbnMpLCBvcHRpb25zKSlcbiAgfSBlbHNlIGlmICh0eXBlb2YgdXJpID09PSAnb2JqZWN0Jykge1xuICAgIHVyaSA9IC8qKiBAdHlwZSB7VH0gKi8gKHBhcnNlKHNlcmlhbGl6ZSh1cmksIG9wdGlvbnMpLCBvcHRpb25zKSlcbiAgfVxuICByZXR1cm4gdXJpXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUklcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWxhdGl2ZVVSSVxuICogQHBhcmFtIHtpbXBvcnQoJy4vdHlwZXMvaW5kZXgnKS5PcHRpb25zfSBbb3B0aW9uc11cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHJlc29sdmUgKGJhc2VVUkksIHJlbGF0aXZlVVJJLCBvcHRpb25zKSB7XG4gIGNvbnN0IHNjaGVtZWxlc3NPcHRpb25zID0gb3B0aW9ucyA/IE9iamVjdC5hc3NpZ24oeyBzY2hlbWU6ICdudWxsJyB9LCBvcHRpb25zKSA6IHsgc2NoZW1lOiAnbnVsbCcgfVxuICBjb25zdCByZXNvbHZlZCA9IHJlc29sdmVDb21wb25lbnQocGFyc2UoYmFzZVVSSSwgc2NoZW1lbGVzc09wdGlvbnMpLCBwYXJzZShyZWxhdGl2ZVVSSSwgc2NoZW1lbGVzc09wdGlvbnMpLCBzY2hlbWVsZXNzT3B0aW9ucywgdHJ1ZSlcbiAgc2NoZW1lbGVzc09wdGlvbnMuc2tpcEVzY2FwZSA9IHRydWVcbiAgcmV0dXJuIHNlcmlhbGl6ZShyZXNvbHZlZCwgc2NoZW1lbGVzc09wdGlvbnMpXG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQgKCcuL3R5cGVzL2luZGV4JykuVVJJQ29tcG9uZW50fSBiYXNlXG4gKiBAcGFyYW0ge2ltcG9ydCAoJy4vdHlwZXMvaW5kZXgnKS5VUklDb21wb25lbnR9IHJlbGF0aXZlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi90eXBlcy9pbmRleCcpLk9wdGlvbnN9IFtvcHRpb25zXVxuICogQHBhcmFtIHtib29sZWFufSBbc2tpcE5vcm1hbGl6YXRpb249ZmFsc2VdXG4gKiBAcmV0dXJucyB7aW1wb3J0ICgnLi90eXBlcy9pbmRleCcpLlVSSUNvbXBvbmVudH1cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUNvbXBvbmVudCAoYmFzZSwgcmVsYXRpdmUsIG9wdGlvbnMsIHNraXBOb3JtYWxpemF0aW9uKSB7XG4gIC8qKiBAdHlwZSB7aW1wb3J0KCcuL3R5cGVzL2luZGV4JykuVVJJQ29tcG9uZW50fSAqL1xuICBjb25zdCB0YXJnZXQgPSB7fVxuICBpZiAoIXNraXBOb3JtYWxpemF0aW9uKSB7XG4gICAgYmFzZSA9IHBhcnNlKHNlcmlhbGl6ZShiYXNlLCBvcHRpb25zKSwgb3B0aW9ucykgLy8gbm9ybWFsaXplIGJhc2UgY29tcG9uZW50XG4gICAgcmVsYXRpdmUgPSBwYXJzZShzZXJpYWxpemUocmVsYXRpdmUsIG9wdGlvbnMpLCBvcHRpb25zKSAvLyBub3JtYWxpemUgcmVsYXRpdmUgY29tcG9uZW50XG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblxuICBpZiAoIW9wdGlvbnMudG9sZXJhbnQgJiYgcmVsYXRpdmUuc2NoZW1lKSB7XG4gICAgdGFyZ2V0LnNjaGVtZSA9IHJlbGF0aXZlLnNjaGVtZVxuICAgIC8vIHRhcmdldC5hdXRob3JpdHkgPSByZWxhdGl2ZS5hdXRob3JpdHk7XG4gICAgdGFyZ2V0LnVzZXJpbmZvID0gcmVsYXRpdmUudXNlcmluZm9cbiAgICB0YXJnZXQuaG9zdCA9IHJlbGF0aXZlLmhvc3RcbiAgICB0YXJnZXQucG9ydCA9IHJlbGF0aXZlLnBvcnRcbiAgICB0YXJnZXQucGF0aCA9IHJlbW92ZURvdFNlZ21lbnRzKHJlbGF0aXZlLnBhdGggfHwgJycpXG4gICAgdGFyZ2V0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnlcbiAgfSBlbHNlIHtcbiAgICBpZiAocmVsYXRpdmUudXNlcmluZm8gIT09IHVuZGVmaW5lZCB8fCByZWxhdGl2ZS5ob3N0ICE9PSB1bmRlZmluZWQgfHwgcmVsYXRpdmUucG9ydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyB0YXJnZXQuYXV0aG9yaXR5ID0gcmVsYXRpdmUuYXV0aG9yaXR5O1xuICAgICAgdGFyZ2V0LnVzZXJpbmZvID0gcmVsYXRpdmUudXNlcmluZm9cbiAgICAgIHRhcmdldC5ob3N0ID0gcmVsYXRpdmUuaG9zdFxuICAgICAgdGFyZ2V0LnBvcnQgPSByZWxhdGl2ZS5wb3J0XG4gICAgICB0YXJnZXQucGF0aCA9IHJlbW92ZURvdFNlZ21lbnRzKHJlbGF0aXZlLnBhdGggfHwgJycpXG4gICAgICB0YXJnZXQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXJlbGF0aXZlLnBhdGgpIHtcbiAgICAgICAgdGFyZ2V0LnBhdGggPSBiYXNlLnBhdGhcbiAgICAgICAgaWYgKHJlbGF0aXZlLnF1ZXJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0YXJnZXQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldC5xdWVyeSA9IGJhc2UucXVlcnlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHJlbGF0aXZlLnBhdGhbMF0gPT09ICcvJykge1xuICAgICAgICAgIHRhcmdldC5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHMocmVsYXRpdmUucGF0aClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoKGJhc2UudXNlcmluZm8gIT09IHVuZGVmaW5lZCB8fCBiYXNlLmhvc3QgIT09IHVuZGVmaW5lZCB8fCBiYXNlLnBvcnQgIT09IHVuZGVmaW5lZCkgJiYgIWJhc2UucGF0aCkge1xuICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSAnLycgKyByZWxhdGl2ZS5wYXRoXG4gICAgICAgICAgfSBlbHNlIGlmICghYmFzZS5wYXRoKSB7XG4gICAgICAgICAgICB0YXJnZXQucGF0aCA9IHJlbGF0aXZlLnBhdGhcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSBiYXNlLnBhdGguc2xpY2UoMCwgYmFzZS5wYXRoLmxhc3RJbmRleE9mKCcvJykgKyAxKSArIHJlbGF0aXZlLnBhdGhcbiAgICAgICAgICB9XG4gICAgICAgICAgdGFyZ2V0LnBhdGggPSByZW1vdmVEb3RTZWdtZW50cyh0YXJnZXQucGF0aClcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeVxuICAgICAgfVxuICAgICAgLy8gdGFyZ2V0LmF1dGhvcml0eSA9IGJhc2UuYXV0aG9yaXR5O1xuICAgICAgdGFyZ2V0LnVzZXJpbmZvID0gYmFzZS51c2VyaW5mb1xuICAgICAgdGFyZ2V0Lmhvc3QgPSBiYXNlLmhvc3RcbiAgICAgIHRhcmdldC5wb3J0ID0gYmFzZS5wb3J0XG4gICAgfVxuICAgIHRhcmdldC5zY2hlbWUgPSBiYXNlLnNjaGVtZVxuICB9XG5cbiAgdGFyZ2V0LmZyYWdtZW50ID0gcmVsYXRpdmUuZnJhZ21lbnRcblxuICByZXR1cm4gdGFyZ2V0XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQgKCcuL3R5cGVzL2luZGV4JykuVVJJQ29tcG9uZW50fHN0cmluZ30gdXJpQVxuICogQHBhcmFtIHtpbXBvcnQgKCcuL3R5cGVzL2luZGV4JykuVVJJQ29tcG9uZW50fHN0cmluZ30gdXJpQlxuICogQHBhcmFtIHtpbXBvcnQgKCcuL3R5cGVzL2luZGV4JykuT3B0aW9uc30gb3B0aW9uc1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGVxdWFsICh1cmlBLCB1cmlCLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgdXJpQSA9PT0gJ3N0cmluZycpIHtcbiAgICB1cmlBID0gdW5lc2NhcGUodXJpQSlcbiAgICB1cmlBID0gc2VyaWFsaXplKG5vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nKHBhcnNlKHVyaUEsIG9wdGlvbnMpLCB0cnVlKSwgeyAuLi5vcHRpb25zLCBza2lwRXNjYXBlOiB0cnVlIH0pXG4gIH0gZWxzZSBpZiAodHlwZW9mIHVyaUEgPT09ICdvYmplY3QnKSB7XG4gICAgdXJpQSA9IHNlcmlhbGl6ZShub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyh1cmlBLCB0cnVlKSwgeyAuLi5vcHRpb25zLCBza2lwRXNjYXBlOiB0cnVlIH0pXG4gIH1cblxuICBpZiAodHlwZW9mIHVyaUIgPT09ICdzdHJpbmcnKSB7XG4gICAgdXJpQiA9IHVuZXNjYXBlKHVyaUIpXG4gICAgdXJpQiA9IHNlcmlhbGl6ZShub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyhwYXJzZSh1cmlCLCBvcHRpb25zKSwgdHJ1ZSksIHsgLi4ub3B0aW9ucywgc2tpcEVzY2FwZTogdHJ1ZSB9KVxuICB9IGVsc2UgaWYgKHR5cGVvZiB1cmlCID09PSAnb2JqZWN0Jykge1xuICAgIHVyaUIgPSBzZXJpYWxpemUobm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcodXJpQiwgdHJ1ZSksIHsgLi4ub3B0aW9ucywgc2tpcEVzY2FwZTogdHJ1ZSB9KVxuICB9XG5cbiAgcmV0dXJuIHVyaUEudG9Mb3dlckNhc2UoKSA9PT0gdXJpQi50b0xvd2VyQ2FzZSgpXG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWFkb25seTxpbXBvcnQoJy4vdHlwZXMvaW5kZXgnKS5VUklDb21wb25lbnQ+fSBjbXB0c1xuICogQHBhcmFtIHtpbXBvcnQoJy4vdHlwZXMvaW5kZXgnKS5PcHRpb25zfSBbb3B0c11cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHNlcmlhbGl6ZSAoY21wdHMsIG9wdHMpIHtcbiAgY29uc3QgY29tcG9uZW50ID0ge1xuICAgIGhvc3Q6IGNtcHRzLmhvc3QsXG4gICAgc2NoZW1lOiBjbXB0cy5zY2hlbWUsXG4gICAgdXNlcmluZm86IGNtcHRzLnVzZXJpbmZvLFxuICAgIHBvcnQ6IGNtcHRzLnBvcnQsXG4gICAgcGF0aDogY21wdHMucGF0aCxcbiAgICBxdWVyeTogY21wdHMucXVlcnksXG4gICAgbmlkOiBjbXB0cy5uaWQsXG4gICAgbnNzOiBjbXB0cy5uc3MsXG4gICAgdXVpZDogY21wdHMudXVpZCxcbiAgICBmcmFnbWVudDogY21wdHMuZnJhZ21lbnQsXG4gICAgcmVmZXJlbmNlOiBjbXB0cy5yZWZlcmVuY2UsXG4gICAgcmVzb3VyY2VOYW1lOiBjbXB0cy5yZXNvdXJjZU5hbWUsXG4gICAgc2VjdXJlOiBjbXB0cy5zZWN1cmUsXG4gICAgZXJyb3I6ICcnXG4gIH1cbiAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdHMpXG4gIGNvbnN0IHVyaVRva2VucyA9IFtdXG5cbiAgLy8gZmluZCBzY2hlbWUgaGFuZGxlclxuICBjb25zdCBzY2hlbWVIYW5kbGVyID0gZ2V0U2NoZW1lSGFuZGxlcihvcHRpb25zLnNjaGVtZSB8fCBjb21wb25lbnQuc2NoZW1lKVxuXG4gIC8vIHBlcmZvcm0gc2NoZW1lIHNwZWNpZmljIHNlcmlhbGl6YXRpb25cbiAgaWYgKHNjaGVtZUhhbmRsZXIgJiYgc2NoZW1lSGFuZGxlci5zZXJpYWxpemUpIHNjaGVtZUhhbmRsZXIuc2VyaWFsaXplKGNvbXBvbmVudCwgb3B0aW9ucylcblxuICBpZiAoY29tcG9uZW50LnBhdGggIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICghb3B0aW9ucy5za2lwRXNjYXBlKSB7XG4gICAgICBjb21wb25lbnQucGF0aCA9IGVzY2FwZShjb21wb25lbnQucGF0aClcblxuICAgICAgaWYgKGNvbXBvbmVudC5zY2hlbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb21wb25lbnQucGF0aCA9IGNvbXBvbmVudC5wYXRoLnNwbGl0KCclM0EnKS5qb2luKCc6JylcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29tcG9uZW50LnBhdGggPSB1bmVzY2FwZShjb21wb25lbnQucGF0aClcbiAgICB9XG4gIH1cblxuICBpZiAob3B0aW9ucy5yZWZlcmVuY2UgIT09ICdzdWZmaXgnICYmIGNvbXBvbmVudC5zY2hlbWUpIHtcbiAgICB1cmlUb2tlbnMucHVzaChjb21wb25lbnQuc2NoZW1lLCAnOicpXG4gIH1cblxuICBjb25zdCBhdXRob3JpdHkgPSByZWNvbXBvc2VBdXRob3JpdHkoY29tcG9uZW50KVxuICBpZiAoYXV0aG9yaXR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAob3B0aW9ucy5yZWZlcmVuY2UgIT09ICdzdWZmaXgnKSB7XG4gICAgICB1cmlUb2tlbnMucHVzaCgnLy8nKVxuICAgIH1cblxuICAgIHVyaVRva2Vucy5wdXNoKGF1dGhvcml0eSlcblxuICAgIGlmIChjb21wb25lbnQucGF0aCAmJiBjb21wb25lbnQucGF0aFswXSAhPT0gJy8nKSB7XG4gICAgICB1cmlUb2tlbnMucHVzaCgnLycpXG4gICAgfVxuICB9XG4gIGlmIChjb21wb25lbnQucGF0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgbGV0IHMgPSBjb21wb25lbnQucGF0aFxuXG4gICAgaWYgKCFvcHRpb25zLmFic29sdXRlUGF0aCAmJiAoIXNjaGVtZUhhbmRsZXIgfHwgIXNjaGVtZUhhbmRsZXIuYWJzb2x1dGVQYXRoKSkge1xuICAgICAgcyA9IHJlbW92ZURvdFNlZ21lbnRzKHMpXG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgYXV0aG9yaXR5ID09PSB1bmRlZmluZWQgJiZcbiAgICAgIHNbMF0gPT09ICcvJyAmJlxuICAgICAgc1sxXSA9PT0gJy8nXG4gICAgKSB7XG4gICAgICAvLyBkb24ndCBhbGxvdyB0aGUgcGF0aCB0byBzdGFydCB3aXRoIFwiLy9cIlxuICAgICAgcyA9ICcvJTJGJyArIHMuc2xpY2UoMilcbiAgICB9XG5cbiAgICB1cmlUb2tlbnMucHVzaChzKVxuICB9XG5cbiAgaWYgKGNvbXBvbmVudC5xdWVyeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdXJpVG9rZW5zLnB1c2goJz8nLCBjb21wb25lbnQucXVlcnkpXG4gIH1cblxuICBpZiAoY29tcG9uZW50LmZyYWdtZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICB1cmlUb2tlbnMucHVzaCgnIycsIGNvbXBvbmVudC5mcmFnbWVudClcbiAgfVxuICByZXR1cm4gdXJpVG9rZW5zLmpvaW4oJycpXG59XG5cbmNvbnN0IFVSSV9QQVJTRSA9IC9eKD86KFteIy86P10rKTopPyg/OlxcL1xcLygoPzooW14jLz9AXSopQCk/KFxcW1teIy8/XFxdXStcXF18W14jLzo/XSopKD86OihcXGQqKSk/KSk/KFteIz9dKikoPzpcXD8oW14jXSopKT8oPzojKCg/Oi58W1xcblxccl0pKikpPy91XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHVyaVxuICogQHBhcmFtIHtpbXBvcnQoJy4vdHlwZXMvaW5kZXgnKS5PcHRpb25zfSBbb3B0c11cbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIHBhcnNlICh1cmksIG9wdHMpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdHMpXG4gIC8qKiBAdHlwZSB7aW1wb3J0KCcuL3R5cGVzL2luZGV4JykuVVJJQ29tcG9uZW50fSAqL1xuICBjb25zdCBwYXJzZWQgPSB7XG4gICAgc2NoZW1lOiB1bmRlZmluZWQsXG4gICAgdXNlcmluZm86IHVuZGVmaW5lZCxcbiAgICBob3N0OiAnJyxcbiAgICBwb3J0OiB1bmRlZmluZWQsXG4gICAgcGF0aDogJycsXG4gICAgcXVlcnk6IHVuZGVmaW5lZCxcbiAgICBmcmFnbWVudDogdW5kZWZpbmVkXG4gIH1cblxuICBsZXQgaXNJUCA9IGZhbHNlXG4gIGlmIChvcHRpb25zLnJlZmVyZW5jZSA9PT0gJ3N1ZmZpeCcpIHtcbiAgICBpZiAob3B0aW9ucy5zY2hlbWUpIHtcbiAgICAgIHVyaSA9IG9wdGlvbnMuc2NoZW1lICsgJzonICsgdXJpXG4gICAgfSBlbHNlIHtcbiAgICAgIHVyaSA9ICcvLycgKyB1cmlcbiAgICB9XG4gIH1cblxuICBjb25zdCBtYXRjaGVzID0gdXJpLm1hdGNoKFVSSV9QQVJTRSlcblxuICBpZiAobWF0Y2hlcykge1xuICAgIC8vIHN0b3JlIGVhY2ggY29tcG9uZW50XG4gICAgcGFyc2VkLnNjaGVtZSA9IG1hdGNoZXNbMV1cbiAgICBwYXJzZWQudXNlcmluZm8gPSBtYXRjaGVzWzNdXG4gICAgcGFyc2VkLmhvc3QgPSBtYXRjaGVzWzRdXG4gICAgcGFyc2VkLnBvcnQgPSBwYXJzZUludChtYXRjaGVzWzVdLCAxMClcbiAgICBwYXJzZWQucGF0aCA9IG1hdGNoZXNbNl0gfHwgJydcbiAgICBwYXJzZWQucXVlcnkgPSBtYXRjaGVzWzddXG4gICAgcGFyc2VkLmZyYWdtZW50ID0gbWF0Y2hlc1s4XVxuXG4gICAgLy8gZml4IHBvcnQgbnVtYmVyXG4gICAgaWYgKGlzTmFOKHBhcnNlZC5wb3J0KSkge1xuICAgICAgcGFyc2VkLnBvcnQgPSBtYXRjaGVzWzVdXG4gICAgfVxuICAgIGlmIChwYXJzZWQuaG9zdCkge1xuICAgICAgY29uc3QgaXB2NHJlc3VsdCA9IGlzSVB2NChwYXJzZWQuaG9zdClcbiAgICAgIGlmIChpcHY0cmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICBjb25zdCBpcHY2cmVzdWx0ID0gbm9ybWFsaXplSVB2NihwYXJzZWQuaG9zdClcbiAgICAgICAgcGFyc2VkLmhvc3QgPSBpcHY2cmVzdWx0Lmhvc3QudG9Mb3dlckNhc2UoKVxuICAgICAgICBpc0lQID0gaXB2NnJlc3VsdC5pc0lQVjZcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlzSVAgPSB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwYXJzZWQuc2NoZW1lID09PSB1bmRlZmluZWQgJiYgcGFyc2VkLnVzZXJpbmZvID09PSB1bmRlZmluZWQgJiYgcGFyc2VkLmhvc3QgPT09IHVuZGVmaW5lZCAmJiBwYXJzZWQucG9ydCA9PT0gdW5kZWZpbmVkICYmIHBhcnNlZC5xdWVyeSA9PT0gdW5kZWZpbmVkICYmICFwYXJzZWQucGF0aCkge1xuICAgICAgcGFyc2VkLnJlZmVyZW5jZSA9ICdzYW1lLWRvY3VtZW50J1xuICAgIH0gZWxzZSBpZiAocGFyc2VkLnNjaGVtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBwYXJzZWQucmVmZXJlbmNlID0gJ3JlbGF0aXZlJ1xuICAgIH0gZWxzZSBpZiAocGFyc2VkLmZyYWdtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHBhcnNlZC5yZWZlcmVuY2UgPSAnYWJzb2x1dGUnXG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnNlZC5yZWZlcmVuY2UgPSAndXJpJ1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGZvciByZWZlcmVuY2UgZXJyb3JzXG4gICAgaWYgKG9wdGlvbnMucmVmZXJlbmNlICYmIG9wdGlvbnMucmVmZXJlbmNlICE9PSAnc3VmZml4JyAmJiBvcHRpb25zLnJlZmVyZW5jZSAhPT0gcGFyc2VkLnJlZmVyZW5jZSkge1xuICAgICAgcGFyc2VkLmVycm9yID0gcGFyc2VkLmVycm9yIHx8ICdVUkkgaXMgbm90IGEgJyArIG9wdGlvbnMucmVmZXJlbmNlICsgJyByZWZlcmVuY2UuJ1xuICAgIH1cblxuICAgIC8vIGZpbmQgc2NoZW1lIGhhbmRsZXJcbiAgICBjb25zdCBzY2hlbWVIYW5kbGVyID0gZ2V0U2NoZW1lSGFuZGxlcihvcHRpb25zLnNjaGVtZSB8fCBwYXJzZWQuc2NoZW1lKVxuXG4gICAgLy8gY2hlY2sgaWYgc2NoZW1lIGNhbid0IGhhbmRsZSBJUklzXG4gICAgaWYgKCFvcHRpb25zLnVuaWNvZGVTdXBwb3J0ICYmICghc2NoZW1lSGFuZGxlciB8fCAhc2NoZW1lSGFuZGxlci51bmljb2RlU3VwcG9ydCkpIHtcbiAgICAgIC8vIGlmIGhvc3QgY29tcG9uZW50IGlzIGEgZG9tYWluIG5hbWVcbiAgICAgIGlmIChwYXJzZWQuaG9zdCAmJiAob3B0aW9ucy5kb21haW5Ib3N0IHx8IChzY2hlbWVIYW5kbGVyICYmIHNjaGVtZUhhbmRsZXIuZG9tYWluSG9zdCkpICYmIGlzSVAgPT09IGZhbHNlICYmIG5vblNpbXBsZURvbWFpbihwYXJzZWQuaG9zdCkpIHtcbiAgICAgICAgLy8gY29udmVydCBVbmljb2RlIElETiAtPiBBU0NJSSBJRE5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwYXJzZWQuaG9zdCA9IFVSTC5kb21haW5Ub0FTQ0lJKHBhcnNlZC5ob3N0LnRvTG93ZXJDYXNlKCkpXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBwYXJzZWQuZXJyb3IgPSBwYXJzZWQuZXJyb3IgfHwgXCJIb3N0J3MgZG9tYWluIG5hbWUgY2FuIG5vdCBiZSBjb252ZXJ0ZWQgdG8gQVNDSUk6IFwiICsgZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBjb252ZXJ0IElSSSAtPiBVUklcbiAgICB9XG5cbiAgICBpZiAoIXNjaGVtZUhhbmRsZXIgfHwgKHNjaGVtZUhhbmRsZXIgJiYgIXNjaGVtZUhhbmRsZXIuc2tpcE5vcm1hbGl6ZSkpIHtcbiAgICAgIGlmICh1cmkuaW5kZXhPZignJScpICE9PSAtMSkge1xuICAgICAgICBpZiAocGFyc2VkLnNjaGVtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcGFyc2VkLnNjaGVtZSA9IHVuZXNjYXBlKHBhcnNlZC5zY2hlbWUpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnNlZC5ob3N0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwYXJzZWQuaG9zdCA9IHVuZXNjYXBlKHBhcnNlZC5ob3N0KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocGFyc2VkLnBhdGgpIHtcbiAgICAgICAgcGFyc2VkLnBhdGggPSBlc2NhcGUodW5lc2NhcGUocGFyc2VkLnBhdGgpKVxuICAgICAgfVxuICAgICAgaWYgKHBhcnNlZC5mcmFnbWVudCkge1xuICAgICAgICBwYXJzZWQuZnJhZ21lbnQgPSBlbmNvZGVVUkkoZGVjb2RlVVJJQ29tcG9uZW50KHBhcnNlZC5mcmFnbWVudCkpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcGVyZm9ybSBzY2hlbWUgc3BlY2lmaWMgcGFyc2luZ1xuICAgIGlmIChzY2hlbWVIYW5kbGVyICYmIHNjaGVtZUhhbmRsZXIucGFyc2UpIHtcbiAgICAgIHNjaGVtZUhhbmRsZXIucGFyc2UocGFyc2VkLCBvcHRpb25zKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwYXJzZWQuZXJyb3IgPSBwYXJzZWQuZXJyb3IgfHwgJ1VSSSBjYW4gbm90IGJlIHBhcnNlZC4nXG4gIH1cbiAgcmV0dXJuIHBhcnNlZFxufVxuXG5jb25zdCBmYXN0VXJpID0ge1xuICBTQ0hFTUVTLFxuICBub3JtYWxpemUsXG4gIHJlc29sdmUsXG4gIHJlc29sdmVDb21wb25lbnQsXG4gIGVxdWFsLFxuICBzZXJpYWxpemUsXG4gIHBhcnNlXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmFzdFVyaVxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGZhc3RVcmlcbm1vZHVsZS5leHBvcnRzLmZhc3RVcmkgPSBmYXN0VXJpXG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHVyaSA9IHJlcXVpcmUoXCJmYXN0LXVyaVwiKTtcbnVyaS5jb2RlID0gJ3JlcXVpcmUoXCJhanYvZGlzdC9ydW50aW1lL3VyaVwiKS5kZWZhdWx0JztcbmV4cG9ydHMuZGVmYXVsdCA9IHVyaTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVyaS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29kZUdlbiA9IGV4cG9ydHMuTmFtZSA9IGV4cG9ydHMubmlsID0gZXhwb3J0cy5zdHJpbmdpZnkgPSBleHBvcnRzLnN0ciA9IGV4cG9ydHMuXyA9IGV4cG9ydHMuS2V5d29yZEN4dCA9IHZvaWQgMDtcbnZhciB2YWxpZGF0ZV8xID0gcmVxdWlyZShcIi4vY29tcGlsZS92YWxpZGF0ZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIktleXdvcmRDeHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbGlkYXRlXzEuS2V5d29yZEN4dDsgfSB9KTtcbnZhciBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi9jb21waWxlL2NvZGVnZW5cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuXzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0clwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLnN0cjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0cmluZ2lmeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLnN0cmluZ2lmeTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm5pbFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLm5pbDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5hbWVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVnZW5fMS5OYW1lOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29kZUdlblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLkNvZGVHZW47IH0gfSk7XG5jb25zdCB2YWxpZGF0aW9uX2Vycm9yXzEgPSByZXF1aXJlKFwiLi9ydW50aW1lL3ZhbGlkYXRpb25fZXJyb3JcIik7XG5jb25zdCByZWZfZXJyb3JfMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvcmVmX2Vycm9yXCIpO1xuY29uc3QgcnVsZXNfMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvcnVsZXNcIik7XG5jb25zdCBjb21waWxlXzEgPSByZXF1aXJlKFwiLi9jb21waWxlXCIpO1xuY29uc3QgY29kZWdlbl8yID0gcmVxdWlyZShcIi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgcmVzb2x2ZV8xID0gcmVxdWlyZShcIi4vY29tcGlsZS9yZXNvbHZlXCIpO1xuY29uc3QgZGF0YVR5cGVfMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvdmFsaWRhdGUvZGF0YVR5cGVcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCAkZGF0YVJlZlNjaGVtYSA9IHJlcXVpcmUoXCIuL3JlZnMvZGF0YS5qc29uXCIpO1xuY29uc3QgdXJpXzEgPSByZXF1aXJlKFwiLi9ydW50aW1lL3VyaVwiKTtcbmNvbnN0IGRlZmF1bHRSZWdFeHAgPSAoc3RyLCBmbGFncykgPT4gbmV3IFJlZ0V4cChzdHIsIGZsYWdzKTtcbmRlZmF1bHRSZWdFeHAuY29kZSA9IFwibmV3IFJlZ0V4cFwiO1xuY29uc3QgTUVUQV9JR05PUkVfT1BUSU9OUyA9IFtcInJlbW92ZUFkZGl0aW9uYWxcIiwgXCJ1c2VEZWZhdWx0c1wiLCBcImNvZXJjZVR5cGVzXCJdO1xuY29uc3QgRVhUX1NDT1BFX05BTUVTID0gbmV3IFNldChbXG4gICAgXCJ2YWxpZGF0ZVwiLFxuICAgIFwic2VyaWFsaXplXCIsXG4gICAgXCJwYXJzZVwiLFxuICAgIFwid3JhcHBlclwiLFxuICAgIFwicm9vdFwiLFxuICAgIFwic2NoZW1hXCIsXG4gICAgXCJrZXl3b3JkXCIsXG4gICAgXCJwYXR0ZXJuXCIsXG4gICAgXCJmb3JtYXRzXCIsXG4gICAgXCJ2YWxpZGF0ZSRkYXRhXCIsXG4gICAgXCJmdW5jXCIsXG4gICAgXCJvYmpcIixcbiAgICBcIkVycm9yXCIsXG5dKTtcbmNvbnN0IHJlbW92ZWRPcHRpb25zID0ge1xuICAgIGVycm9yRGF0YVBhdGg6IFwiXCIsXG4gICAgZm9ybWF0OiBcImB2YWxpZGF0ZUZvcm1hdHM6IGZhbHNlYCBjYW4gYmUgdXNlZCBpbnN0ZWFkLlwiLFxuICAgIG51bGxhYmxlOiAnXCJudWxsYWJsZVwiIGtleXdvcmQgaXMgc3VwcG9ydGVkIGJ5IGRlZmF1bHQuJyxcbiAgICBqc29uUG9pbnRlcnM6IFwiRGVwcmVjYXRlZCBqc1Byb3BlcnR5U3ludGF4IGNhbiBiZSB1c2VkIGluc3RlYWQuXCIsXG4gICAgZXh0ZW5kUmVmczogXCJEZXByZWNhdGVkIGlnbm9yZUtleXdvcmRzV2l0aFJlZiBjYW4gYmUgdXNlZCBpbnN0ZWFkLlwiLFxuICAgIG1pc3NpbmdSZWZzOiBcIlBhc3MgZW1wdHkgc2NoZW1hIHdpdGggJGlkIHRoYXQgc2hvdWxkIGJlIGlnbm9yZWQgdG8gYWp2LmFkZFNjaGVtYS5cIixcbiAgICBwcm9jZXNzQ29kZTogXCJVc2Ugb3B0aW9uIGBjb2RlOiB7cHJvY2VzczogKGNvZGUsIHNjaGVtYUVudjogb2JqZWN0KSA9PiBzdHJpbmd9YFwiLFxuICAgIHNvdXJjZUNvZGU6IFwiVXNlIG9wdGlvbiBgY29kZToge3NvdXJjZTogdHJ1ZX1gXCIsXG4gICAgc3RyaWN0RGVmYXVsdHM6IFwiSXQgaXMgZGVmYXVsdCBub3csIHNlZSBvcHRpb24gYHN0cmljdGAuXCIsXG4gICAgc3RyaWN0S2V5d29yZHM6IFwiSXQgaXMgZGVmYXVsdCBub3csIHNlZSBvcHRpb24gYHN0cmljdGAuXCIsXG4gICAgdW5pcXVlSXRlbXM6ICdcInVuaXF1ZUl0ZW1zXCIga2V5d29yZCBpcyBhbHdheXMgdmFsaWRhdGVkLicsXG4gICAgdW5rbm93bkZvcm1hdHM6IFwiRGlzYWJsZSBzdHJpY3QgbW9kZSBvciBwYXNzIGB0cnVlYCB0byBgYWp2LmFkZEZvcm1hdGAgKG9yIGBmb3JtYXRzYCBvcHRpb24pLlwiLFxuICAgIGNhY2hlOiBcIk1hcCBpcyB1c2VkIGFzIGNhY2hlLCBzY2hlbWEgb2JqZWN0IGFzIGtleS5cIixcbiAgICBzZXJpYWxpemU6IFwiTWFwIGlzIHVzZWQgYXMgY2FjaGUsIHNjaGVtYSBvYmplY3QgYXMga2V5LlwiLFxuICAgIGFqdkVycm9yczogXCJJdCBpcyBkZWZhdWx0IG5vdy5cIixcbn07XG5jb25zdCBkZXByZWNhdGVkT3B0aW9ucyA9IHtcbiAgICBpZ25vcmVLZXl3b3Jkc1dpdGhSZWY6IFwiXCIsXG4gICAganNQcm9wZXJ0eVN5bnRheDogXCJcIixcbiAgICB1bmljb2RlOiAnXCJtaW5MZW5ndGhcIi9cIm1heExlbmd0aFwiIGFjY291bnQgZm9yIHVuaWNvZGUgY2hhcmFjdGVycyBieSBkZWZhdWx0LicsXG59O1xuY29uc3QgTUFYX0VYUFJFU1NJT04gPSAyMDA7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZnVuY3Rpb24gcmVxdWlyZWRPcHRpb25zKG8pIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaiwgX2ssIF9sLCBfbSwgX28sIF9wLCBfcSwgX3IsIF9zLCBfdCwgX3UsIF92LCBfdywgX3gsIF95LCBfeiwgXzA7XG4gICAgY29uc3QgcyA9IG8uc3RyaWN0O1xuICAgIGNvbnN0IF9vcHR6ID0gKF9hID0gby5jb2RlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3B0aW1pemU7XG4gICAgY29uc3Qgb3B0aW1pemUgPSBfb3B0eiA9PT0gdHJ1ZSB8fCBfb3B0eiA9PT0gdW5kZWZpbmVkID8gMSA6IF9vcHR6IHx8IDA7XG4gICAgY29uc3QgcmVnRXhwID0gKF9jID0gKF9iID0gby5jb2RlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucmVnRXhwKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBkZWZhdWx0UmVnRXhwO1xuICAgIGNvbnN0IHVyaVJlc29sdmVyID0gKF9kID0gby51cmlSZXNvbHZlcikgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogdXJpXzEuZGVmYXVsdDtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdHJpY3RTY2hlbWE6IChfZiA9IChfZSA9IG8uc3RyaWN0U2NoZW1hKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiBzKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiB0cnVlLFxuICAgICAgICBzdHJpY3ROdW1iZXJzOiAoX2ggPSAoX2cgPSBvLnN0cmljdE51bWJlcnMpICE9PSBudWxsICYmIF9nICE9PSB2b2lkIDAgPyBfZyA6IHMpICE9PSBudWxsICYmIF9oICE9PSB2b2lkIDAgPyBfaCA6IHRydWUsXG4gICAgICAgIHN0cmljdFR5cGVzOiAoX2sgPSAoX2ogPSBvLnN0cmljdFR5cGVzKSAhPT0gbnVsbCAmJiBfaiAhPT0gdm9pZCAwID8gX2ogOiBzKSAhPT0gbnVsbCAmJiBfayAhPT0gdm9pZCAwID8gX2sgOiBcImxvZ1wiLFxuICAgICAgICBzdHJpY3RUdXBsZXM6IChfbSA9IChfbCA9IG8uc3RyaWN0VHVwbGVzKSAhPT0gbnVsbCAmJiBfbCAhPT0gdm9pZCAwID8gX2wgOiBzKSAhPT0gbnVsbCAmJiBfbSAhPT0gdm9pZCAwID8gX20gOiBcImxvZ1wiLFxuICAgICAgICBzdHJpY3RSZXF1aXJlZDogKF9wID0gKF9vID0gby5zdHJpY3RSZXF1aXJlZCkgIT09IG51bGwgJiYgX28gIT09IHZvaWQgMCA/IF9vIDogcykgIT09IG51bGwgJiYgX3AgIT09IHZvaWQgMCA/IF9wIDogZmFsc2UsXG4gICAgICAgIGNvZGU6IG8uY29kZSA/IHsgLi4uby5jb2RlLCBvcHRpbWl6ZSwgcmVnRXhwIH0gOiB7IG9wdGltaXplLCByZWdFeHAgfSxcbiAgICAgICAgbG9vcFJlcXVpcmVkOiAoX3EgPSBvLmxvb3BSZXF1aXJlZCkgIT09IG51bGwgJiYgX3EgIT09IHZvaWQgMCA/IF9xIDogTUFYX0VYUFJFU1NJT04sXG4gICAgICAgIGxvb3BFbnVtOiAoX3IgPSBvLmxvb3BFbnVtKSAhPT0gbnVsbCAmJiBfciAhPT0gdm9pZCAwID8gX3IgOiBNQVhfRVhQUkVTU0lPTixcbiAgICAgICAgbWV0YTogKF9zID0gby5tZXRhKSAhPT0gbnVsbCAmJiBfcyAhPT0gdm9pZCAwID8gX3MgOiB0cnVlLFxuICAgICAgICBtZXNzYWdlczogKF90ID0gby5tZXNzYWdlcykgIT09IG51bGwgJiYgX3QgIT09IHZvaWQgMCA/IF90IDogdHJ1ZSxcbiAgICAgICAgaW5saW5lUmVmczogKF91ID0gby5pbmxpbmVSZWZzKSAhPT0gbnVsbCAmJiBfdSAhPT0gdm9pZCAwID8gX3UgOiB0cnVlLFxuICAgICAgICBzY2hlbWFJZDogKF92ID0gby5zY2hlbWFJZCkgIT09IG51bGwgJiYgX3YgIT09IHZvaWQgMCA/IF92IDogXCIkaWRcIixcbiAgICAgICAgYWRkVXNlZFNjaGVtYTogKF93ID0gby5hZGRVc2VkU2NoZW1hKSAhPT0gbnVsbCAmJiBfdyAhPT0gdm9pZCAwID8gX3cgOiB0cnVlLFxuICAgICAgICB2YWxpZGF0ZVNjaGVtYTogKF94ID0gby52YWxpZGF0ZVNjaGVtYSkgIT09IG51bGwgJiYgX3ggIT09IHZvaWQgMCA/IF94IDogdHJ1ZSxcbiAgICAgICAgdmFsaWRhdGVGb3JtYXRzOiAoX3kgPSBvLnZhbGlkYXRlRm9ybWF0cykgIT09IG51bGwgJiYgX3kgIT09IHZvaWQgMCA/IF95IDogdHJ1ZSxcbiAgICAgICAgdW5pY29kZVJlZ0V4cDogKF96ID0gby51bmljb2RlUmVnRXhwKSAhPT0gbnVsbCAmJiBfeiAhPT0gdm9pZCAwID8gX3ogOiB0cnVlLFxuICAgICAgICBpbnQzMnJhbmdlOiAoXzAgPSBvLmludDMycmFuZ2UpICE9PSBudWxsICYmIF8wICE9PSB2b2lkIDAgPyBfMCA6IHRydWUsXG4gICAgICAgIHVyaVJlc29sdmVyOiB1cmlSZXNvbHZlcixcbiAgICB9O1xufVxuY2xhc3MgQWp2IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICAgICAgdGhpcy5zY2hlbWFzID0ge307XG4gICAgICAgIHRoaXMucmVmcyA9IHt9O1xuICAgICAgICB0aGlzLmZvcm1hdHMgPSB7fTtcbiAgICAgICAgdGhpcy5fY29tcGlsYXRpb25zID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLl9sb2FkaW5nID0ge307XG4gICAgICAgIHRoaXMuX2NhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICBvcHRzID0gdGhpcy5vcHRzID0geyAuLi5vcHRzLCAuLi5yZXF1aXJlZE9wdGlvbnMob3B0cykgfTtcbiAgICAgICAgY29uc3QgeyBlczUsIGxpbmVzIH0gPSB0aGlzLm9wdHMuY29kZTtcbiAgICAgICAgdGhpcy5zY29wZSA9IG5ldyBjb2RlZ2VuXzIuVmFsdWVTY29wZSh7IHNjb3BlOiB7fSwgcHJlZml4ZXM6IEVYVF9TQ09QRV9OQU1FUywgZXM1LCBsaW5lcyB9KTtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBnZXRMb2dnZXIob3B0cy5sb2dnZXIpO1xuICAgICAgICBjb25zdCBmb3JtYXRPcHQgPSBvcHRzLnZhbGlkYXRlRm9ybWF0cztcbiAgICAgICAgb3B0cy52YWxpZGF0ZUZvcm1hdHMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5SVUxFUyA9ICgwLCBydWxlc18xLmdldFJ1bGVzKSgpO1xuICAgICAgICBjaGVja09wdGlvbnMuY2FsbCh0aGlzLCByZW1vdmVkT3B0aW9ucywgb3B0cywgXCJOT1QgU1VQUE9SVEVEXCIpO1xuICAgICAgICBjaGVja09wdGlvbnMuY2FsbCh0aGlzLCBkZXByZWNhdGVkT3B0aW9ucywgb3B0cywgXCJERVBSRUNBVEVEXCIsIFwid2FyblwiKTtcbiAgICAgICAgdGhpcy5fbWV0YU9wdHMgPSBnZXRNZXRhU2NoZW1hT3B0aW9ucy5jYWxsKHRoaXMpO1xuICAgICAgICBpZiAob3B0cy5mb3JtYXRzKVxuICAgICAgICAgICAgYWRkSW5pdGlhbEZvcm1hdHMuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5fYWRkVm9jYWJ1bGFyaWVzKCk7XG4gICAgICAgIHRoaXMuX2FkZERlZmF1bHRNZXRhU2NoZW1hKCk7XG4gICAgICAgIGlmIChvcHRzLmtleXdvcmRzKVxuICAgICAgICAgICAgYWRkSW5pdGlhbEtleXdvcmRzLmNhbGwodGhpcywgb3B0cy5rZXl3b3Jkcyk7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0cy5tZXRhID09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICB0aGlzLmFkZE1ldGFTY2hlbWEob3B0cy5tZXRhKTtcbiAgICAgICAgYWRkSW5pdGlhbFNjaGVtYXMuY2FsbCh0aGlzKTtcbiAgICAgICAgb3B0cy52YWxpZGF0ZUZvcm1hdHMgPSBmb3JtYXRPcHQ7XG4gICAgfVxuICAgIF9hZGRWb2NhYnVsYXJpZXMoKSB7XG4gICAgICAgIHRoaXMuYWRkS2V5d29yZChcIiRhc3luY1wiKTtcbiAgICB9XG4gICAgX2FkZERlZmF1bHRNZXRhU2NoZW1hKCkge1xuICAgICAgICBjb25zdCB7ICRkYXRhLCBtZXRhLCBzY2hlbWFJZCB9ID0gdGhpcy5vcHRzO1xuICAgICAgICBsZXQgX2RhdGFSZWZTY2hlbWEgPSAkZGF0YVJlZlNjaGVtYTtcbiAgICAgICAgaWYgKHNjaGVtYUlkID09PSBcImlkXCIpIHtcbiAgICAgICAgICAgIF9kYXRhUmVmU2NoZW1hID0geyAuLi4kZGF0YVJlZlNjaGVtYSB9O1xuICAgICAgICAgICAgX2RhdGFSZWZTY2hlbWEuaWQgPSBfZGF0YVJlZlNjaGVtYS4kaWQ7XG4gICAgICAgICAgICBkZWxldGUgX2RhdGFSZWZTY2hlbWEuJGlkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhICYmICRkYXRhKVxuICAgICAgICAgICAgdGhpcy5hZGRNZXRhU2NoZW1hKF9kYXRhUmVmU2NoZW1hLCBfZGF0YVJlZlNjaGVtYVtzY2hlbWFJZF0sIGZhbHNlKTtcbiAgICB9XG4gICAgZGVmYXVsdE1ldGEoKSB7XG4gICAgICAgIGNvbnN0IHsgbWV0YSwgc2NoZW1hSWQgfSA9IHRoaXMub3B0cztcbiAgICAgICAgcmV0dXJuICh0aGlzLm9wdHMuZGVmYXVsdE1ldGEgPSB0eXBlb2YgbWV0YSA9PSBcIm9iamVjdFwiID8gbWV0YVtzY2hlbWFJZF0gfHwgbWV0YSA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIHZhbGlkYXRlKHNjaGVtYUtleVJlZiwgLy8ga2V5LCByZWYgb3Igc2NoZW1hIG9iamVjdFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVkdW5kYW50LXR5cGUtY29uc3RpdHVlbnRzXG4gICAgZGF0YSAvLyB0byBiZSB2YWxpZGF0ZWRcbiAgICApIHtcbiAgICAgICAgbGV0IHY7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hS2V5UmVmID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHYgPSB0aGlzLmdldFNjaGVtYShzY2hlbWFLZXlSZWYpO1xuICAgICAgICAgICAgaWYgKCF2KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbm8gc2NoZW1hIHdpdGgga2V5IG9yIHJlZiBcIiR7c2NoZW1hS2V5UmVmfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2ID0gdGhpcy5jb21waWxlKHNjaGVtYUtleVJlZik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsaWQgPSB2KGRhdGEpO1xuICAgICAgICBpZiAoIShcIiRhc3luY1wiIGluIHYpKVxuICAgICAgICAgICAgdGhpcy5lcnJvcnMgPSB2LmVycm9ycztcbiAgICAgICAgcmV0dXJuIHZhbGlkO1xuICAgIH1cbiAgICBjb21waWxlKHNjaGVtYSwgX21ldGEpIHtcbiAgICAgICAgY29uc3Qgc2NoID0gdGhpcy5fYWRkU2NoZW1hKHNjaGVtYSwgX21ldGEpO1xuICAgICAgICByZXR1cm4gKHNjaC52YWxpZGF0ZSB8fCB0aGlzLl9jb21waWxlU2NoZW1hRW52KHNjaCkpO1xuICAgIH1cbiAgICBjb21waWxlQXN5bmMoc2NoZW1hLCBtZXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRzLmxvYWRTY2hlbWEgIT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvcHRpb25zLmxvYWRTY2hlbWEgc2hvdWxkIGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBsb2FkU2NoZW1hIH0gPSB0aGlzLm9wdHM7XG4gICAgICAgIHJldHVybiBydW5Db21waWxlQXN5bmMuY2FsbCh0aGlzLCBzY2hlbWEsIG1ldGEpO1xuICAgICAgICBhc3luYyBmdW5jdGlvbiBydW5Db21waWxlQXN5bmMoX3NjaGVtYSwgX21ldGEpIHtcbiAgICAgICAgICAgIGF3YWl0IGxvYWRNZXRhU2NoZW1hLmNhbGwodGhpcywgX3NjaGVtYS4kc2NoZW1hKTtcbiAgICAgICAgICAgIGNvbnN0IHNjaCA9IHRoaXMuX2FkZFNjaGVtYShfc2NoZW1hLCBfbWV0YSk7XG4gICAgICAgICAgICByZXR1cm4gc2NoLnZhbGlkYXRlIHx8IF9jb21waWxlQXN5bmMuY2FsbCh0aGlzLCBzY2gpO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGxvYWRNZXRhU2NoZW1hKCRyZWYpIHtcbiAgICAgICAgICAgIGlmICgkcmVmICYmICF0aGlzLmdldFNjaGVtYSgkcmVmKSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHJ1bkNvbXBpbGVBc3luYy5jYWxsKHRoaXMsIHsgJHJlZiB9LCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhc3luYyBmdW5jdGlvbiBfY29tcGlsZUFzeW5jKHNjaCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY29tcGlsZVNjaGVtYUVudihzY2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShlIGluc3RhbmNlb2YgcmVmX2Vycm9yXzEuZGVmYXVsdCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgY2hlY2tMb2FkZWQuY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBsb2FkTWlzc2luZ1NjaGVtYS5jYWxsKHRoaXMsIGUubWlzc2luZ1NjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb21waWxlQXN5bmMuY2FsbCh0aGlzLCBzY2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrTG9hZGVkKHsgbWlzc2luZ1NjaGVtYTogcmVmLCBtaXNzaW5nUmVmIH0pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlZnNbcmVmXSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQW55U2NoZW1hICR7cmVmfSBpcyBsb2FkZWQgYnV0ICR7bWlzc2luZ1JlZn0gY2Fubm90IGJlIHJlc29sdmVkYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gbG9hZE1pc3NpbmdTY2hlbWEocmVmKSB7XG4gICAgICAgICAgICBjb25zdCBfc2NoZW1hID0gYXdhaXQgX2xvYWRTY2hlbWEuY2FsbCh0aGlzLCByZWYpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJlZnNbcmVmXSlcbiAgICAgICAgICAgICAgICBhd2FpdCBsb2FkTWV0YVNjaGVtYS5jYWxsKHRoaXMsIF9zY2hlbWEuJHNjaGVtYSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMucmVmc1tyZWZdKVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkU2NoZW1hKF9zY2hlbWEsIHJlZiwgbWV0YSk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gX2xvYWRTY2hlbWEocmVmKSB7XG4gICAgICAgICAgICBjb25zdCBwID0gdGhpcy5fbG9hZGluZ1tyZWZdO1xuICAgICAgICAgICAgaWYgKHApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCAodGhpcy5fbG9hZGluZ1tyZWZdID0gbG9hZFNjaGVtYShyZWYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9sb2FkaW5nW3JlZl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQWRkcyBzY2hlbWEgdG8gdGhlIGluc3RhbmNlXG4gICAgYWRkU2NoZW1hKHNjaGVtYSwgLy8gSWYgYXJyYXkgaXMgcGFzc2VkLCBga2V5YCB3aWxsIGJlIGlnbm9yZWRcbiAgICBrZXksIC8vIE9wdGlvbmFsIHNjaGVtYSBrZXkuIENhbiBiZSBwYXNzZWQgdG8gYHZhbGlkYXRlYCBtZXRob2QgaW5zdGVhZCBvZiBzY2hlbWEgb2JqZWN0IG9yIGlkL3JlZi4gT25lIHNjaGVtYSBwZXIgaW5zdGFuY2UgY2FuIGhhdmUgZW1wdHkgYGlkYCBhbmQgYGtleWAuXG4gICAgX21ldGEsIC8vIHRydWUgaWYgc2NoZW1hIGlzIGEgbWV0YS1zY2hlbWEuIFVzZWQgaW50ZXJuYWxseSwgYWRkTWV0YVNjaGVtYSBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxuICAgIF92YWxpZGF0ZVNjaGVtYSA9IHRoaXMub3B0cy52YWxpZGF0ZVNjaGVtYSAvLyBmYWxzZSB0byBza2lwIHNjaGVtYSB2YWxpZGF0aW9uLiBVc2VkIGludGVybmFsbHksIG9wdGlvbiB2YWxpZGF0ZVNjaGVtYSBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxuICAgICkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNjaCBvZiBzY2hlbWEpXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRTY2hlbWEoc2NoLCB1bmRlZmluZWQsIF9tZXRhLCBfdmFsaWRhdGVTY2hlbWEpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGlkO1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgY29uc3QgeyBzY2hlbWFJZCB9ID0gdGhpcy5vcHRzO1xuICAgICAgICAgICAgaWQgPSBzY2hlbWFbc2NoZW1hSWRdO1xuICAgICAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGlkICE9IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHNjaGVtYSAke3NjaGVtYUlkfSBtdXN0IGJlIHN0cmluZ2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGtleSA9ICgwLCByZXNvbHZlXzEubm9ybWFsaXplSWQpKGtleSB8fCBpZCk7XG4gICAgICAgIHRoaXMuX2NoZWNrVW5pcXVlKGtleSk7XG4gICAgICAgIHRoaXMuc2NoZW1hc1trZXldID0gdGhpcy5fYWRkU2NoZW1hKHNjaGVtYSwgX21ldGEsIGtleSwgX3ZhbGlkYXRlU2NoZW1hLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIEFkZCBzY2hlbWEgdGhhdCB3aWxsIGJlIHVzZWQgdG8gdmFsaWRhdGUgb3RoZXIgc2NoZW1hc1xuICAgIC8vIG9wdGlvbnMgaW4gTUVUQV9JR05PUkVfT1BUSU9OUyBhcmUgYWx3YXkgc2V0IHRvIGZhbHNlXG4gICAgYWRkTWV0YVNjaGVtYShzY2hlbWEsIGtleSwgLy8gc2NoZW1hIGtleVxuICAgIF92YWxpZGF0ZVNjaGVtYSA9IHRoaXMub3B0cy52YWxpZGF0ZVNjaGVtYSAvLyBmYWxzZSB0byBza2lwIHNjaGVtYSB2YWxpZGF0aW9uLCBjYW4gYmUgdXNlZCB0byBvdmVycmlkZSB2YWxpZGF0ZVNjaGVtYSBvcHRpb24gZm9yIG1ldGEtc2NoZW1hXG4gICAgKSB7XG4gICAgICAgIHRoaXMuYWRkU2NoZW1hKHNjaGVtYSwga2V5LCB0cnVlLCBfdmFsaWRhdGVTY2hlbWEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gIFZhbGlkYXRlIHNjaGVtYSBhZ2FpbnN0IGl0cyBtZXRhLXNjaGVtYVxuICAgIHZhbGlkYXRlU2NoZW1hKHNjaGVtYSwgdGhyb3dPckxvZ0Vycm9yKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGxldCAkc2NoZW1hO1xuICAgICAgICAkc2NoZW1hID0gc2NoZW1hLiRzY2hlbWE7XG4gICAgICAgIGlmICgkc2NoZW1hICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mICRzY2hlbWEgIT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJHNjaGVtYSBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuICAgICAgICB9XG4gICAgICAgICRzY2hlbWEgPSAkc2NoZW1hIHx8IHRoaXMub3B0cy5kZWZhdWx0TWV0YSB8fCB0aGlzLmRlZmF1bHRNZXRhKCk7XG4gICAgICAgIGlmICghJHNjaGVtYSkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIm1ldGEtc2NoZW1hIG5vdCBhdmFpbGFibGVcIik7XG4gICAgICAgICAgICB0aGlzLmVycm9ycyA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWxpZCA9IHRoaXMudmFsaWRhdGUoJHNjaGVtYSwgc2NoZW1hKTtcbiAgICAgICAgaWYgKCF2YWxpZCAmJiB0aHJvd09yTG9nRXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBcInNjaGVtYSBpcyBpbnZhbGlkOiBcIiArIHRoaXMuZXJyb3JzVGV4dCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0cy52YWxpZGF0ZVNjaGVtYSA9PT0gXCJsb2dcIilcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbGlkO1xuICAgIH1cbiAgICAvLyBHZXQgY29tcGlsZWQgc2NoZW1hIGJ5IGBrZXlgIG9yIGByZWZgLlxuICAgIC8vIChga2V5YCB0aGF0IHdhcyBwYXNzZWQgdG8gYGFkZFNjaGVtYWAgb3IgZnVsbCBzY2hlbWEgcmVmZXJlbmNlIC0gYHNjaGVtYS4kaWRgIG9yIHJlc29sdmVkIGlkKVxuICAgIGdldFNjaGVtYShrZXlSZWYpIHtcbiAgICAgICAgbGV0IHNjaDtcbiAgICAgICAgd2hpbGUgKHR5cGVvZiAoc2NoID0gZ2V0U2NoRW52LmNhbGwodGhpcywga2V5UmVmKSkgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIGtleVJlZiA9IHNjaDtcbiAgICAgICAgaWYgKHNjaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCB7IHNjaGVtYUlkIH0gPSB0aGlzLm9wdHM7XG4gICAgICAgICAgICBjb25zdCByb290ID0gbmV3IGNvbXBpbGVfMS5TY2hlbWFFbnYoeyBzY2hlbWE6IHt9LCBzY2hlbWFJZCB9KTtcbiAgICAgICAgICAgIHNjaCA9IGNvbXBpbGVfMS5yZXNvbHZlU2NoZW1hLmNhbGwodGhpcywgcm9vdCwga2V5UmVmKTtcbiAgICAgICAgICAgIGlmICghc2NoKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMucmVmc1trZXlSZWZdID0gc2NoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoc2NoLnZhbGlkYXRlIHx8IHRoaXMuX2NvbXBpbGVTY2hlbWFFbnYoc2NoKSk7XG4gICAgfVxuICAgIC8vIFJlbW92ZSBjYWNoZWQgc2NoZW1hKHMpLlxuICAgIC8vIElmIG5vIHBhcmFtZXRlciBpcyBwYXNzZWQgYWxsIHNjaGVtYXMgYnV0IG1ldGEtc2NoZW1hcyBhcmUgcmVtb3ZlZC5cbiAgICAvLyBJZiBSZWdFeHAgaXMgcGFzc2VkIGFsbCBzY2hlbWFzIHdpdGgga2V5L2lkIG1hdGNoaW5nIHBhdHRlcm4gYnV0IG1ldGEtc2NoZW1hcyBhcmUgcmVtb3ZlZC5cbiAgICAvLyBFdmVuIGlmIHNjaGVtYSBpcyByZWZlcmVuY2VkIGJ5IG90aGVyIHNjaGVtYXMgaXQgc3RpbGwgY2FuIGJlIHJlbW92ZWQgYXMgb3RoZXIgc2NoZW1hcyBoYXZlIGxvY2FsIHJlZmVyZW5jZXMuXG4gICAgcmVtb3ZlU2NoZW1hKHNjaGVtYUtleVJlZikge1xuICAgICAgICBpZiAoc2NoZW1hS2V5UmVmIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVBbGxTY2hlbWFzKHRoaXMuc2NoZW1hcywgc2NoZW1hS2V5UmVmKTtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZUFsbFNjaGVtYXModGhpcy5yZWZzLCBzY2hlbWFLZXlSZWYpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0eXBlb2Ygc2NoZW1hS2V5UmVmKSB7XG4gICAgICAgICAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlQWxsU2NoZW1hcyh0aGlzLnNjaGVtYXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUFsbFNjaGVtYXModGhpcy5yZWZzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZS5jbGVhcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoID0gZ2V0U2NoRW52LmNhbGwodGhpcywgc2NoZW1hS2V5UmVmKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNjaCA9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZS5kZWxldGUoc2NoLnNjaGVtYSk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuc2NoZW1hc1tzY2hlbWFLZXlSZWZdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnJlZnNbc2NoZW1hS2V5UmVmXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJvYmplY3RcIjoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gc2NoZW1hS2V5UmVmO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlLmRlbGV0ZShjYWNoZUtleSk7XG4gICAgICAgICAgICAgICAgbGV0IGlkID0gc2NoZW1hS2V5UmVmW3RoaXMub3B0cy5zY2hlbWFJZF07XG4gICAgICAgICAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlkID0gKDAsIHJlc29sdmVfMS5ub3JtYWxpemVJZCkoaWQpO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5zY2hlbWFzW2lkXTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMucmVmc1tpZF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhanYucmVtb3ZlU2NoZW1hOiBpbnZhbGlkIHBhcmFtZXRlclwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBhZGQgXCJ2b2NhYnVsYXJ5XCIgLSBhIGNvbGxlY3Rpb24gb2Yga2V5d29yZHNcbiAgICBhZGRWb2NhYnVsYXJ5KGRlZmluaXRpb25zKSB7XG4gICAgICAgIGZvciAoY29uc3QgZGVmIG9mIGRlZmluaXRpb25zKVxuICAgICAgICAgICAgdGhpcy5hZGRLZXl3b3JkKGRlZik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhZGRLZXl3b3JkKGt3ZE9yRGVmLCBkZWYgLy8gZGVwcmVjYXRlZFxuICAgICkge1xuICAgICAgICBsZXQga2V5d29yZDtcbiAgICAgICAgaWYgKHR5cGVvZiBrd2RPckRlZiA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBrZXl3b3JkID0ga3dkT3JEZWY7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRlZiA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcInRoZXNlIHBhcmFtZXRlcnMgYXJlIGRlcHJlY2F0ZWQsIHNlZSBkb2NzIGZvciBhZGRLZXl3b3JkXCIpO1xuICAgICAgICAgICAgICAgIGRlZi5rZXl3b3JkID0ga2V5d29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Yga3dkT3JEZWYgPT0gXCJvYmplY3RcIiAmJiBkZWYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGVmID0ga3dkT3JEZWY7XG4gICAgICAgICAgICBrZXl3b3JkID0gZGVmLmtleXdvcmQ7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShrZXl3b3JkKSAmJiAha2V5d29yZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhZGRLZXl3b3Jkczoga2V5d29yZCBtdXN0IGJlIHN0cmluZyBvciBub24tZW1wdHkgYXJyYXlcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGFkZEtleXdvcmRzIHBhcmFtZXRlcnNcIik7XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tLZXl3b3JkLmNhbGwodGhpcywga2V5d29yZCwgZGVmKTtcbiAgICAgICAgaWYgKCFkZWYpIHtcbiAgICAgICAgICAgICgwLCB1dGlsXzEuZWFjaEl0ZW0pKGtleXdvcmQsIChrd2QpID0+IGFkZFJ1bGUuY2FsbCh0aGlzLCBrd2QpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGtleXdvcmRNZXRhc2NoZW1hLmNhbGwodGhpcywgZGVmKTtcbiAgICAgICAgY29uc3QgZGVmaW5pdGlvbiA9IHtcbiAgICAgICAgICAgIC4uLmRlZixcbiAgICAgICAgICAgIHR5cGU6ICgwLCBkYXRhVHlwZV8xLmdldEpTT05UeXBlcykoZGVmLnR5cGUpLFxuICAgICAgICAgICAgc2NoZW1hVHlwZTogKDAsIGRhdGFUeXBlXzEuZ2V0SlNPTlR5cGVzKShkZWYuc2NoZW1hVHlwZSksXG4gICAgICAgIH07XG4gICAgICAgICgwLCB1dGlsXzEuZWFjaEl0ZW0pKGtleXdvcmQsIGRlZmluaXRpb24udHlwZS5sZW5ndGggPT09IDBcbiAgICAgICAgICAgID8gKGspID0+IGFkZFJ1bGUuY2FsbCh0aGlzLCBrLCBkZWZpbml0aW9uKVxuICAgICAgICAgICAgOiAoaykgPT4gZGVmaW5pdGlvbi50eXBlLmZvckVhY2goKHQpID0+IGFkZFJ1bGUuY2FsbCh0aGlzLCBrLCBkZWZpbml0aW9uLCB0KSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0S2V5d29yZChrZXl3b3JkKSB7XG4gICAgICAgIGNvbnN0IHJ1bGUgPSB0aGlzLlJVTEVTLmFsbFtrZXl3b3JkXTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBydWxlID09IFwib2JqZWN0XCIgPyBydWxlLmRlZmluaXRpb24gOiAhIXJ1bGU7XG4gICAgfVxuICAgIC8vIFJlbW92ZSBrZXl3b3JkXG4gICAgcmVtb3ZlS2V5d29yZChrZXl3b3JkKSB7XG4gICAgICAgIC8vIFRPRE8gcmV0dXJuIHR5cGUgc2hvdWxkIGJlIEFqdlxuICAgICAgICBjb25zdCB7IFJVTEVTIH0gPSB0aGlzO1xuICAgICAgICBkZWxldGUgUlVMRVMua2V5d29yZHNba2V5d29yZF07XG4gICAgICAgIGRlbGV0ZSBSVUxFUy5hbGxba2V5d29yZF07XG4gICAgICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgUlVMRVMucnVsZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGkgPSBncm91cC5ydWxlcy5maW5kSW5kZXgoKHJ1bGUpID0+IHJ1bGUua2V5d29yZCA9PT0ga2V5d29yZCk7XG4gICAgICAgICAgICBpZiAoaSA+PSAwKVxuICAgICAgICAgICAgICAgIGdyb3VwLnJ1bGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gQWRkIGZvcm1hdFxuICAgIGFkZEZvcm1hdChuYW1lLCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXQgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIGZvcm1hdCA9IG5ldyBSZWdFeHAoZm9ybWF0KTtcbiAgICAgICAgdGhpcy5mb3JtYXRzW25hbWVdID0gZm9ybWF0O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZXJyb3JzVGV4dChlcnJvcnMgPSB0aGlzLmVycm9ycywgLy8gb3B0aW9uYWwgYXJyYXkgb2YgdmFsaWRhdGlvbiBlcnJvcnNcbiAgICB7IHNlcGFyYXRvciA9IFwiLCBcIiwgZGF0YVZhciA9IFwiZGF0YVwiIH0gPSB7fSAvLyBvcHRpb25hbCBvcHRpb25zIHdpdGggcHJvcGVydGllcyBgc2VwYXJhdG9yYCBhbmQgYGRhdGFWYXJgXG4gICAgKSB7XG4gICAgICAgIGlmICghZXJyb3JzIHx8IGVycm9ycy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gXCJObyBlcnJvcnNcIjtcbiAgICAgICAgcmV0dXJuIGVycm9yc1xuICAgICAgICAgICAgLm1hcCgoZSkgPT4gYCR7ZGF0YVZhcn0ke2UuaW5zdGFuY2VQYXRofSAke2UubWVzc2FnZX1gKVxuICAgICAgICAgICAgLnJlZHVjZSgodGV4dCwgbXNnKSA9PiB0ZXh0ICsgc2VwYXJhdG9yICsgbXNnKTtcbiAgICB9XG4gICAgJGRhdGFNZXRhU2NoZW1hKG1ldGFTY2hlbWEsIGtleXdvcmRzSnNvblBvaW50ZXJzKSB7XG4gICAgICAgIGNvbnN0IHJ1bGVzID0gdGhpcy5SVUxFUy5hbGw7XG4gICAgICAgIG1ldGFTY2hlbWEgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG1ldGFTY2hlbWEpKTtcbiAgICAgICAgZm9yIChjb25zdCBqc29uUG9pbnRlciBvZiBrZXl3b3Jkc0pzb25Qb2ludGVycykge1xuICAgICAgICAgICAgY29uc3Qgc2VnbWVudHMgPSBqc29uUG9pbnRlci5zcGxpdChcIi9cIikuc2xpY2UoMSk7IC8vIGZpcnN0IHNlZ21lbnQgaXMgYW4gZW1wdHkgc3RyaW5nXG4gICAgICAgICAgICBsZXQga2V5d29yZHMgPSBtZXRhU2NoZW1hO1xuICAgICAgICAgICAgZm9yIChjb25zdCBzZWcgb2Ygc2VnbWVudHMpXG4gICAgICAgICAgICAgICAga2V5d29yZHMgPSBrZXl3b3Jkc1tzZWddO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcnVsZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBydWxlID0gcnVsZXNba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJ1bGUgIT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY29uc3QgeyAkZGF0YSB9ID0gcnVsZS5kZWZpbml0aW9uO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjaGVtYSA9IGtleXdvcmRzW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKCRkYXRhICYmIHNjaGVtYSlcbiAgICAgICAgICAgICAgICAgICAga2V5d29yZHNba2V5XSA9IHNjaGVtYU9yRGF0YShzY2hlbWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXRhU2NoZW1hO1xuICAgIH1cbiAgICBfcmVtb3ZlQWxsU2NoZW1hcyhzY2hlbWFzLCByZWdleCkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleVJlZiBpbiBzY2hlbWFzKSB7XG4gICAgICAgICAgICBjb25zdCBzY2ggPSBzY2hlbWFzW2tleVJlZl07XG4gICAgICAgICAgICBpZiAoIXJlZ2V4IHx8IHJlZ2V4LnRlc3Qoa2V5UmVmKSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNjaGVtYXNba2V5UmVmXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2NoICYmICFzY2gubWV0YSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZS5kZWxldGUoc2NoLnNjaGVtYSk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzY2hlbWFzW2tleVJlZl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF9hZGRTY2hlbWEoc2NoZW1hLCBtZXRhLCBiYXNlSWQsIHZhbGlkYXRlU2NoZW1hID0gdGhpcy5vcHRzLnZhbGlkYXRlU2NoZW1hLCBhZGRTY2hlbWEgPSB0aGlzLm9wdHMuYWRkVXNlZFNjaGVtYSkge1xuICAgICAgICBsZXQgaWQ7XG4gICAgICAgIGNvbnN0IHsgc2NoZW1hSWQgfSA9IHRoaXMub3B0cztcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgaWQgPSBzY2hlbWFbc2NoZW1hSWRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5qdGQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2NoZW1hIG11c3QgYmUgb2JqZWN0XCIpO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHNjaGVtYSAhPSBcImJvb2xlYW5cIilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzY2hlbWEgbXVzdCBiZSBvYmplY3Qgb3IgYm9vbGVhblwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2NoID0gdGhpcy5fY2FjaGUuZ2V0KHNjaGVtYSk7XG4gICAgICAgIGlmIChzY2ggIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiBzY2g7XG4gICAgICAgIGJhc2VJZCA9ICgwLCByZXNvbHZlXzEubm9ybWFsaXplSWQpKGlkIHx8IGJhc2VJZCk7XG4gICAgICAgIGNvbnN0IGxvY2FsUmVmcyA9IHJlc29sdmVfMS5nZXRTY2hlbWFSZWZzLmNhbGwodGhpcywgc2NoZW1hLCBiYXNlSWQpO1xuICAgICAgICBzY2ggPSBuZXcgY29tcGlsZV8xLlNjaGVtYUVudih7IHNjaGVtYSwgc2NoZW1hSWQsIG1ldGEsIGJhc2VJZCwgbG9jYWxSZWZzIH0pO1xuICAgICAgICB0aGlzLl9jYWNoZS5zZXQoc2NoLnNjaGVtYSwgc2NoKTtcbiAgICAgICAgaWYgKGFkZFNjaGVtYSAmJiAhYmFzZUlkLnN0YXJ0c1dpdGgoXCIjXCIpKSB7XG4gICAgICAgICAgICAvLyBUT0RPIGF0bSBpdCBpcyBhbGxvd2VkIHRvIG92ZXJ3cml0ZSBzY2hlbWFzIHdpdGhvdXQgaWQgKGluc3RlYWQgb2Ygbm90IGFkZGluZyB0aGVtKVxuICAgICAgICAgICAgaWYgKGJhc2VJZClcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGVja1VuaXF1ZShiYXNlSWQpO1xuICAgICAgICAgICAgdGhpcy5yZWZzW2Jhc2VJZF0gPSBzY2g7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbGlkYXRlU2NoZW1hKVxuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZVNjaGVtYShzY2hlbWEsIHRydWUpO1xuICAgICAgICByZXR1cm4gc2NoO1xuICAgIH1cbiAgICBfY2hlY2tVbmlxdWUoaWQpIHtcbiAgICAgICAgaWYgKHRoaXMuc2NoZW1hc1tpZF0gfHwgdGhpcy5yZWZzW2lkXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzY2hlbWEgd2l0aCBrZXkgb3IgaWQgXCIke2lkfVwiIGFscmVhZHkgZXhpc3RzYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2NvbXBpbGVTY2hlbWFFbnYoc2NoKSB7XG4gICAgICAgIGlmIChzY2gubWV0YSlcbiAgICAgICAgICAgIHRoaXMuX2NvbXBpbGVNZXRhU2NoZW1hKHNjaCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNvbXBpbGVfMS5jb21waWxlU2NoZW1hLmNhbGwodGhpcywgc2NoKTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghc2NoLnZhbGlkYXRlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgICAgICByZXR1cm4gc2NoLnZhbGlkYXRlO1xuICAgIH1cbiAgICBfY29tcGlsZU1ldGFTY2hlbWEoc2NoKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRPcHRzID0gdGhpcy5vcHRzO1xuICAgICAgICB0aGlzLm9wdHMgPSB0aGlzLl9tZXRhT3B0cztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbXBpbGVfMS5jb21waWxlU2NoZW1hLmNhbGwodGhpcywgc2NoKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMub3B0cyA9IGN1cnJlbnRPcHRzO1xuICAgICAgICB9XG4gICAgfVxufVxuQWp2LlZhbGlkYXRpb25FcnJvciA9IHZhbGlkYXRpb25fZXJyb3JfMS5kZWZhdWx0O1xuQWp2Lk1pc3NpbmdSZWZFcnJvciA9IHJlZl9lcnJvcl8xLmRlZmF1bHQ7XG5leHBvcnRzLmRlZmF1bHQgPSBBanY7XG5mdW5jdGlvbiBjaGVja09wdGlvbnMoY2hlY2tPcHRzLCBvcHRpb25zLCBtc2csIGxvZyA9IFwiZXJyb3JcIikge1xuICAgIGZvciAoY29uc3Qga2V5IGluIGNoZWNrT3B0cykge1xuICAgICAgICBjb25zdCBvcHQgPSBrZXk7XG4gICAgICAgIGlmIChvcHQgaW4gb3B0aW9ucylcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyW2xvZ10oYCR7bXNnfTogb3B0aW9uICR7a2V5fS4gJHtjaGVja09wdHNbb3B0XX1gKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRTY2hFbnYoa2V5UmVmKSB7XG4gICAga2V5UmVmID0gKDAsIHJlc29sdmVfMS5ub3JtYWxpemVJZCkoa2V5UmVmKTsgLy8gVE9ETyB0ZXN0cyBmYWlsIHdpdGhvdXQgdGhpcyBsaW5lXG4gICAgcmV0dXJuIHRoaXMuc2NoZW1hc1trZXlSZWZdIHx8IHRoaXMucmVmc1trZXlSZWZdO1xufVxuZnVuY3Rpb24gYWRkSW5pdGlhbFNjaGVtYXMoKSB7XG4gICAgY29uc3Qgb3B0c1NjaGVtYXMgPSB0aGlzLm9wdHMuc2NoZW1hcztcbiAgICBpZiAoIW9wdHNTY2hlbWFzKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0c1NjaGVtYXMpKVxuICAgICAgICB0aGlzLmFkZFNjaGVtYShvcHRzU2NoZW1hcyk7XG4gICAgZWxzZVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvcHRzU2NoZW1hcylcbiAgICAgICAgICAgIHRoaXMuYWRkU2NoZW1hKG9wdHNTY2hlbWFzW2tleV0sIGtleSk7XG59XG5mdW5jdGlvbiBhZGRJbml0aWFsRm9ybWF0cygpIHtcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdGhpcy5vcHRzLmZvcm1hdHMpIHtcbiAgICAgICAgY29uc3QgZm9ybWF0ID0gdGhpcy5vcHRzLmZvcm1hdHNbbmFtZV07XG4gICAgICAgIGlmIChmb3JtYXQpXG4gICAgICAgICAgICB0aGlzLmFkZEZvcm1hdChuYW1lLCBmb3JtYXQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZEluaXRpYWxLZXl3b3JkcyhkZWZzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGVmcykpIHtcbiAgICAgICAgdGhpcy5hZGRWb2NhYnVsYXJ5KGRlZnMpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubG9nZ2VyLndhcm4oXCJrZXl3b3JkcyBvcHRpb24gYXMgbWFwIGlzIGRlcHJlY2F0ZWQsIHBhc3MgYXJyYXlcIik7XG4gICAgZm9yIChjb25zdCBrZXl3b3JkIGluIGRlZnMpIHtcbiAgICAgICAgY29uc3QgZGVmID0gZGVmc1trZXl3b3JkXTtcbiAgICAgICAgaWYgKCFkZWYua2V5d29yZClcbiAgICAgICAgICAgIGRlZi5rZXl3b3JkID0ga2V5d29yZDtcbiAgICAgICAgdGhpcy5hZGRLZXl3b3JkKGRlZik7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0TWV0YVNjaGVtYU9wdGlvbnMoKSB7XG4gICAgY29uc3QgbWV0YU9wdHMgPSB7IC4uLnRoaXMub3B0cyB9O1xuICAgIGZvciAoY29uc3Qgb3B0IG9mIE1FVEFfSUdOT1JFX09QVElPTlMpXG4gICAgICAgIGRlbGV0ZSBtZXRhT3B0c1tvcHRdO1xuICAgIHJldHVybiBtZXRhT3B0cztcbn1cbmNvbnN0IG5vTG9ncyA9IHsgbG9nKCkgeyB9LCB3YXJuKCkgeyB9LCBlcnJvcigpIHsgfSB9O1xuZnVuY3Rpb24gZ2V0TG9nZ2VyKGxvZ2dlcikge1xuICAgIGlmIChsb2dnZXIgPT09IGZhbHNlKVxuICAgICAgICByZXR1cm4gbm9Mb2dzO1xuICAgIGlmIChsb2dnZXIgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIGNvbnNvbGU7XG4gICAgaWYgKGxvZ2dlci5sb2cgJiYgbG9nZ2VyLndhcm4gJiYgbG9nZ2VyLmVycm9yKVxuICAgICAgICByZXR1cm4gbG9nZ2VyO1xuICAgIHRocm93IG5ldyBFcnJvcihcImxvZ2dlciBtdXN0IGltcGxlbWVudCBsb2csIHdhcm4gYW5kIGVycm9yIG1ldGhvZHNcIik7XG59XG5jb25zdCBLRVlXT1JEX05BTUUgPSAvXlthLXpfJF1bYS16MC05XyQ6LV0qJC9pO1xuZnVuY3Rpb24gY2hlY2tLZXl3b3JkKGtleXdvcmQsIGRlZikge1xuICAgIGNvbnN0IHsgUlVMRVMgfSA9IHRoaXM7XG4gICAgKDAsIHV0aWxfMS5lYWNoSXRlbSkoa2V5d29yZCwgKGt3ZCkgPT4ge1xuICAgICAgICBpZiAoUlVMRVMua2V5d29yZHNba3dkXSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5d29yZCAke2t3ZH0gaXMgYWxyZWFkeSBkZWZpbmVkYCk7XG4gICAgICAgIGlmICghS0VZV09SRF9OQU1FLnRlc3Qoa3dkKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5d29yZCAke2t3ZH0gaGFzIGludmFsaWQgbmFtZWApO1xuICAgIH0pO1xuICAgIGlmICghZGVmKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKGRlZi4kZGF0YSAmJiAhKFwiY29kZVwiIGluIGRlZiB8fCBcInZhbGlkYXRlXCIgaW4gZGVmKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJyRkYXRhIGtleXdvcmQgbXVzdCBoYXZlIFwiY29kZVwiIG9yIFwidmFsaWRhdGVcIiBmdW5jdGlvbicpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZFJ1bGUoa2V5d29yZCwgZGVmaW5pdGlvbiwgZGF0YVR5cGUpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgcG9zdCA9IGRlZmluaXRpb24gPT09IG51bGwgfHwgZGVmaW5pdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVmaW5pdGlvbi5wb3N0O1xuICAgIGlmIChkYXRhVHlwZSAmJiBwb3N0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2tleXdvcmQgd2l0aCBcInBvc3RcIiBmbGFnIGNhbm5vdCBoYXZlIFwidHlwZVwiJyk7XG4gICAgY29uc3QgeyBSVUxFUyB9ID0gdGhpcztcbiAgICBsZXQgcnVsZUdyb3VwID0gcG9zdCA/IFJVTEVTLnBvc3QgOiBSVUxFUy5ydWxlcy5maW5kKCh7IHR5cGU6IHQgfSkgPT4gdCA9PT0gZGF0YVR5cGUpO1xuICAgIGlmICghcnVsZUdyb3VwKSB7XG4gICAgICAgIHJ1bGVHcm91cCA9IHsgdHlwZTogZGF0YVR5cGUsIHJ1bGVzOiBbXSB9O1xuICAgICAgICBSVUxFUy5ydWxlcy5wdXNoKHJ1bGVHcm91cCk7XG4gICAgfVxuICAgIFJVTEVTLmtleXdvcmRzW2tleXdvcmRdID0gdHJ1ZTtcbiAgICBpZiAoIWRlZmluaXRpb24pXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCBydWxlID0ge1xuICAgICAgICBrZXl3b3JkLFxuICAgICAgICBkZWZpbml0aW9uOiB7XG4gICAgICAgICAgICAuLi5kZWZpbml0aW9uLFxuICAgICAgICAgICAgdHlwZTogKDAsIGRhdGFUeXBlXzEuZ2V0SlNPTlR5cGVzKShkZWZpbml0aW9uLnR5cGUpLFxuICAgICAgICAgICAgc2NoZW1hVHlwZTogKDAsIGRhdGFUeXBlXzEuZ2V0SlNPTlR5cGVzKShkZWZpbml0aW9uLnNjaGVtYVR5cGUpLFxuICAgICAgICB9LFxuICAgIH07XG4gICAgaWYgKGRlZmluaXRpb24uYmVmb3JlKVxuICAgICAgICBhZGRCZWZvcmVSdWxlLmNhbGwodGhpcywgcnVsZUdyb3VwLCBydWxlLCBkZWZpbml0aW9uLmJlZm9yZSk7XG4gICAgZWxzZVxuICAgICAgICBydWxlR3JvdXAucnVsZXMucHVzaChydWxlKTtcbiAgICBSVUxFUy5hbGxba2V5d29yZF0gPSBydWxlO1xuICAgIChfYSA9IGRlZmluaXRpb24uaW1wbGVtZW50cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvckVhY2goKGt3ZCkgPT4gdGhpcy5hZGRLZXl3b3JkKGt3ZCkpO1xufVxuZnVuY3Rpb24gYWRkQmVmb3JlUnVsZShydWxlR3JvdXAsIHJ1bGUsIGJlZm9yZSkge1xuICAgIGNvbnN0IGkgPSBydWxlR3JvdXAucnVsZXMuZmluZEluZGV4KChfcnVsZSkgPT4gX3J1bGUua2V5d29yZCA9PT0gYmVmb3JlKTtcbiAgICBpZiAoaSA+PSAwKSB7XG4gICAgICAgIHJ1bGVHcm91cC5ydWxlcy5zcGxpY2UoaSwgMCwgcnVsZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBydWxlR3JvdXAucnVsZXMucHVzaChydWxlKTtcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybihgcnVsZSAke2JlZm9yZX0gaXMgbm90IGRlZmluZWRgKTtcbiAgICB9XG59XG5mdW5jdGlvbiBrZXl3b3JkTWV0YXNjaGVtYShkZWYpIHtcbiAgICBsZXQgeyBtZXRhU2NoZW1hIH0gPSBkZWY7XG4gICAgaWYgKG1ldGFTY2hlbWEgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmIChkZWYuJGRhdGEgJiYgdGhpcy5vcHRzLiRkYXRhKVxuICAgICAgICBtZXRhU2NoZW1hID0gc2NoZW1hT3JEYXRhKG1ldGFTY2hlbWEpO1xuICAgIGRlZi52YWxpZGF0ZVNjaGVtYSA9IHRoaXMuY29tcGlsZShtZXRhU2NoZW1hLCB0cnVlKTtcbn1cbmNvbnN0ICRkYXRhUmVmID0ge1xuICAgICRyZWY6IFwiaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2Fqdi12YWxpZGF0b3IvYWp2L21hc3Rlci9saWIvcmVmcy9kYXRhLmpzb24jXCIsXG59O1xuZnVuY3Rpb24gc2NoZW1hT3JEYXRhKHNjaGVtYSkge1xuICAgIHJldHVybiB7IGFueU9mOiBbc2NoZW1hLCAkZGF0YVJlZl0gfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvcmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJpZFwiLFxuICAgIGNvZGUoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTk9UIFNVUFBPUlRFRDoga2V5d29yZCBcImlkXCIsIHVzZSBcIiRpZFwiIGZvciBzY2hlbWEgSUQnKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jYWxsUmVmID0gZXhwb3J0cy5nZXRWYWxpZGF0ZSA9IHZvaWQgMDtcbmNvbnN0IHJlZl9lcnJvcl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvcmVmX2Vycm9yXCIpO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uL2NvZGVcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgbmFtZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL25hbWVzXCIpO1xuY29uc3QgY29tcGlsZV8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGVcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiJHJlZlwiLFxuICAgIHNjaGVtYVR5cGU6IFwic3RyaW5nXCIsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYTogJHJlZiwgaXQgfSA9IGN4dDtcbiAgICAgICAgY29uc3QgeyBiYXNlSWQsIHNjaGVtYUVudjogZW52LCB2YWxpZGF0ZU5hbWUsIG9wdHMsIHNlbGYgfSA9IGl0O1xuICAgICAgICBjb25zdCB7IHJvb3QgfSA9IGVudjtcbiAgICAgICAgaWYgKCgkcmVmID09PSBcIiNcIiB8fCAkcmVmID09PSBcIiMvXCIpICYmIGJhc2VJZCA9PT0gcm9vdC5iYXNlSWQpXG4gICAgICAgICAgICByZXR1cm4gY2FsbFJvb3RSZWYoKTtcbiAgICAgICAgY29uc3Qgc2NoT3JFbnYgPSBjb21waWxlXzEucmVzb2x2ZVJlZi5jYWxsKHNlbGYsIHJvb3QsIGJhc2VJZCwgJHJlZik7XG4gICAgICAgIGlmIChzY2hPckVudiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IHJlZl9lcnJvcl8xLmRlZmF1bHQoaXQub3B0cy51cmlSZXNvbHZlciwgYmFzZUlkLCAkcmVmKTtcbiAgICAgICAgaWYgKHNjaE9yRW52IGluc3RhbmNlb2YgY29tcGlsZV8xLlNjaGVtYUVudilcbiAgICAgICAgICAgIHJldHVybiBjYWxsVmFsaWRhdGUoc2NoT3JFbnYpO1xuICAgICAgICByZXR1cm4gaW5saW5lUmVmU2NoZW1hKHNjaE9yRW52KTtcbiAgICAgICAgZnVuY3Rpb24gY2FsbFJvb3RSZWYoKSB7XG4gICAgICAgICAgICBpZiAoZW52ID09PSByb290KVxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsUmVmKGN4dCwgdmFsaWRhdGVOYW1lLCBlbnYsIGVudi4kYXN5bmMpO1xuICAgICAgICAgICAgY29uc3Qgcm9vdE5hbWUgPSBnZW4uc2NvcGVWYWx1ZShcInJvb3RcIiwgeyByZWY6IHJvb3QgfSk7XG4gICAgICAgICAgICByZXR1cm4gY2FsbFJlZihjeHQsICgwLCBjb2RlZ2VuXzEuXykgYCR7cm9vdE5hbWV9LnZhbGlkYXRlYCwgcm9vdCwgcm9vdC4kYXN5bmMpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNhbGxWYWxpZGF0ZShzY2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSBnZXRWYWxpZGF0ZShjeHQsIHNjaCk7XG4gICAgICAgICAgICBjYWxsUmVmKGN4dCwgdiwgc2NoLCBzY2guJGFzeW5jKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpbmxpbmVSZWZTY2hlbWEoc2NoKSB7XG4gICAgICAgICAgICBjb25zdCBzY2hOYW1lID0gZ2VuLnNjb3BlVmFsdWUoXCJzY2hlbWFcIiwgb3B0cy5jb2RlLnNvdXJjZSA9PT0gdHJ1ZSA/IHsgcmVmOiBzY2gsIGNvZGU6ICgwLCBjb2RlZ2VuXzEuc3RyaW5naWZ5KShzY2gpIH0gOiB7IHJlZjogc2NoIH0pO1xuICAgICAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgICAgICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICAgICAgc2NoZW1hOiBzY2gsXG4gICAgICAgICAgICAgICAgZGF0YVR5cGVzOiBbXSxcbiAgICAgICAgICAgICAgICBzY2hlbWFQYXRoOiBjb2RlZ2VuXzEubmlsLFxuICAgICAgICAgICAgICAgIHRvcFNjaGVtYVJlZjogc2NoTmFtZSxcbiAgICAgICAgICAgICAgICBlcnJTY2hlbWFQYXRoOiAkcmVmLFxuICAgICAgICAgICAgfSwgdmFsaWQpO1xuICAgICAgICAgICAgY3h0Lm1lcmdlRXZhbHVhdGVkKHNjaEN4dCk7XG4gICAgICAgICAgICBjeHQub2sodmFsaWQpO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5mdW5jdGlvbiBnZXRWYWxpZGF0ZShjeHQsIHNjaCkge1xuICAgIGNvbnN0IHsgZ2VuIH0gPSBjeHQ7XG4gICAgcmV0dXJuIHNjaC52YWxpZGF0ZVxuICAgICAgICA/IGdlbi5zY29wZVZhbHVlKFwidmFsaWRhdGVcIiwgeyByZWY6IHNjaC52YWxpZGF0ZSB9KVxuICAgICAgICA6ICgwLCBjb2RlZ2VuXzEuXykgYCR7Z2VuLnNjb3BlVmFsdWUoXCJ3cmFwcGVyXCIsIHsgcmVmOiBzY2ggfSl9LnZhbGlkYXRlYDtcbn1cbmV4cG9ydHMuZ2V0VmFsaWRhdGUgPSBnZXRWYWxpZGF0ZTtcbmZ1bmN0aW9uIGNhbGxSZWYoY3h0LCB2LCBzY2gsICRhc3luYykge1xuICAgIGNvbnN0IHsgZ2VuLCBpdCB9ID0gY3h0O1xuICAgIGNvbnN0IHsgYWxsRXJyb3JzLCBzY2hlbWFFbnY6IGVudiwgb3B0cyB9ID0gaXQ7XG4gICAgY29uc3QgcGFzc0N4dCA9IG9wdHMucGFzc0NvbnRleHQgPyBuYW1lc18xLmRlZmF1bHQudGhpcyA6IGNvZGVnZW5fMS5uaWw7XG4gICAgaWYgKCRhc3luYylcbiAgICAgICAgY2FsbEFzeW5jUmVmKCk7XG4gICAgZWxzZVxuICAgICAgICBjYWxsU3luY1JlZigpO1xuICAgIGZ1bmN0aW9uIGNhbGxBc3luY1JlZigpIHtcbiAgICAgICAgaWYgKCFlbnYuJGFzeW5jKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXN5bmMgc2NoZW1hIHJlZmVyZW5jZWQgYnkgc3luYyBzY2hlbWFcIik7XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIpO1xuICAgICAgICBnZW4udHJ5KCgpID0+IHtcbiAgICAgICAgICAgIGdlbi5jb2RlKCgwLCBjb2RlZ2VuXzEuXykgYGF3YWl0ICR7KDAsIGNvZGVfMS5jYWxsVmFsaWRhdGVDb2RlKShjeHQsIHYsIHBhc3NDeHQpfWApO1xuICAgICAgICAgICAgYWRkRXZhbHVhdGVkRnJvbSh2KTsgLy8gVE9ETyB3aWxsIG5vdCB3b3JrIHdpdGggYXN5bmMsIGl0IGhhcyB0byBiZSByZXR1cm5lZCB3aXRoIHRoZSByZXN1bHRcbiAgICAgICAgICAgIGlmICghYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIHRydWUpO1xuICAgICAgICB9LCAoZSkgPT4ge1xuICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCEoJHtlfSBpbnN0YW5jZW9mICR7aXQuVmFsaWRhdGlvbkVycm9yfSlgLCAoKSA9PiBnZW4udGhyb3coZSkpO1xuICAgICAgICAgICAgYWRkRXJyb3JzRnJvbShlKTtcbiAgICAgICAgICAgIGlmICghYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhbGxTeW5jUmVmKCkge1xuICAgICAgICBjeHQucmVzdWx0KCgwLCBjb2RlXzEuY2FsbFZhbGlkYXRlQ29kZSkoY3h0LCB2LCBwYXNzQ3h0KSwgKCkgPT4gYWRkRXZhbHVhdGVkRnJvbSh2KSwgKCkgPT4gYWRkRXJyb3JzRnJvbSh2KSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZEVycm9yc0Zyb20oc291cmNlKSB7XG4gICAgICAgIGNvbnN0IGVycnMgPSAoMCwgY29kZWdlbl8xLl8pIGAke3NvdXJjZX0uZXJyb3JzYDtcbiAgICAgICAgZ2VuLmFzc2lnbihuYW1lc18xLmRlZmF1bHQudkVycm9ycywgKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30gPT09IG51bGwgPyAke2VycnN9IDogJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30uY29uY2F0KCR7ZXJyc30pYCk7IC8vIFRPRE8gdGFnZ2VkXG4gICAgICAgIGdlbi5hc3NpZ24obmFtZXNfMS5kZWZhdWx0LmVycm9ycywgKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30ubGVuZ3RoYCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZEV2YWx1YXRlZEZyb20oc291cmNlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCFpdC5vcHRzLnVuZXZhbHVhdGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBzY2hFdmFsdWF0ZWQgPSAoX2EgPSBzY2ggPT09IG51bGwgfHwgc2NoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY2gudmFsaWRhdGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ldmFsdWF0ZWQ7XG4gICAgICAgIC8vIFRPRE8gcmVmYWN0b3JcbiAgICAgICAgaWYgKGl0LnByb3BzICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBpZiAoc2NoRXZhbHVhdGVkICYmICFzY2hFdmFsdWF0ZWQuZHluYW1pY1Byb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNjaEV2YWx1YXRlZC5wcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0LnByb3BzID0gdXRpbF8xLm1lcmdlRXZhbHVhdGVkLnByb3BzKGdlbiwgc2NoRXZhbHVhdGVkLnByb3BzLCBpdC5wcm9wcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcHMgPSBnZW4udmFyKFwicHJvcHNcIiwgKDAsIGNvZGVnZW5fMS5fKSBgJHtzb3VyY2V9LmV2YWx1YXRlZC5wcm9wc2ApO1xuICAgICAgICAgICAgICAgIGl0LnByb3BzID0gdXRpbF8xLm1lcmdlRXZhbHVhdGVkLnByb3BzKGdlbiwgcHJvcHMsIGl0LnByb3BzLCBjb2RlZ2VuXzEuTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0Lml0ZW1zICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBpZiAoc2NoRXZhbHVhdGVkICYmICFzY2hFdmFsdWF0ZWQuZHluYW1pY0l0ZW1zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNjaEV2YWx1YXRlZC5pdGVtcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0Lml0ZW1zID0gdXRpbF8xLm1lcmdlRXZhbHVhdGVkLml0ZW1zKGdlbiwgc2NoRXZhbHVhdGVkLml0ZW1zLCBpdC5pdGVtcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbXMgPSBnZW4udmFyKFwiaXRlbXNcIiwgKDAsIGNvZGVnZW5fMS5fKSBgJHtzb3VyY2V9LmV2YWx1YXRlZC5pdGVtc2ApO1xuICAgICAgICAgICAgICAgIGl0Lml0ZW1zID0gdXRpbF8xLm1lcmdlRXZhbHVhdGVkLml0ZW1zKGdlbiwgaXRlbXMsIGl0Lml0ZW1zLCBjb2RlZ2VuXzEuTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmNhbGxSZWYgPSBjYWxsUmVmO1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVmLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgaWRfMSA9IHJlcXVpcmUoXCIuL2lkXCIpO1xuY29uc3QgcmVmXzEgPSByZXF1aXJlKFwiLi9yZWZcIik7XG5jb25zdCBjb3JlID0gW1xuICAgIFwiJHNjaGVtYVwiLFxuICAgIFwiJGlkXCIsXG4gICAgXCIkZGVmc1wiLFxuICAgIFwiJHZvY2FidWxhcnlcIixcbiAgICB7IGtleXdvcmQ6IFwiJGNvbW1lbnRcIiB9LFxuICAgIFwiZGVmaW5pdGlvbnNcIixcbiAgICBpZF8xLmRlZmF1bHQsXG4gICAgcmVmXzEuZGVmYXVsdCxcbl07XG5leHBvcnRzLmRlZmF1bHQgPSBjb3JlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3Qgb3BzID0gY29kZWdlbl8xLm9wZXJhdG9ycztcbmNvbnN0IEtXRHMgPSB7XG4gICAgbWF4aW11bTogeyBva1N0cjogXCI8PVwiLCBvazogb3BzLkxURSwgZmFpbDogb3BzLkdUIH0sXG4gICAgbWluaW11bTogeyBva1N0cjogXCI+PVwiLCBvazogb3BzLkdURSwgZmFpbDogb3BzLkxUIH0sXG4gICAgZXhjbHVzaXZlTWF4aW11bTogeyBva1N0cjogXCI8XCIsIG9rOiBvcHMuTFQsIGZhaWw6IG9wcy5HVEUgfSxcbiAgICBleGNsdXNpdmVNaW5pbXVtOiB7IG9rU3RyOiBcIj5cIiwgb2s6IG9wcy5HVCwgZmFpbDogb3BzLkxURSB9LFxufTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IGtleXdvcmQsIHNjaGVtYUNvZGUgfSkgPT4gKDAsIGNvZGVnZW5fMS5zdHIpIGBtdXN0IGJlICR7S1dEc1trZXl3b3JkXS5va1N0cn0gJHtzY2hlbWFDb2RlfWAsXG4gICAgcGFyYW1zOiAoeyBrZXl3b3JkLCBzY2hlbWFDb2RlIH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHtjb21wYXJpc29uOiAke0tXRHNba2V5d29yZF0ub2tTdHJ9LCBsaW1pdDogJHtzY2hlbWFDb2RlfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBPYmplY3Qua2V5cyhLV0RzKSxcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIHNjaGVtYVR5cGU6IFwibnVtYmVyXCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBrZXl3b3JkLCBkYXRhLCBzY2hlbWFDb2RlIH0gPSBjeHQ7XG4gICAgICAgIGN4dC5mYWlsJGRhdGEoKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfSAke0tXRHNba2V5d29yZF0uZmFpbH0gJHtzY2hlbWFDb2RlfSB8fCBpc05hTigke2RhdGF9KWApO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGltaXROdW1iZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsgc2NoZW1hQ29kZSB9KSA9PiAoMCwgY29kZWdlbl8xLnN0cikgYG11c3QgYmUgbXVsdGlwbGUgb2YgJHtzY2hlbWFDb2RlfWAsXG4gICAgcGFyYW1zOiAoeyBzY2hlbWFDb2RlIH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHttdWx0aXBsZU9mOiAke3NjaGVtYUNvZGV9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwibXVsdGlwbGVPZlwiLFxuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgc2NoZW1hVHlwZTogXCJudW1iZXJcIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgZGF0YSwgc2NoZW1hQ29kZSwgaXQgfSA9IGN4dDtcbiAgICAgICAgLy8gY29uc3QgYmR0ID0gYmFkJERhdGFUeXBlKHNjaGVtYUNvZGUsIDxzdHJpbmc+ZGVmLnNjaGVtYVR5cGUsICRkYXRhKVxuICAgICAgICBjb25zdCBwcmVjID0gaXQub3B0cy5tdWx0aXBsZU9mUHJlY2lzaW9uO1xuICAgICAgICBjb25zdCByZXMgPSBnZW4ubGV0KFwicmVzXCIpO1xuICAgICAgICBjb25zdCBpbnZhbGlkID0gcHJlY1xuICAgICAgICAgICAgPyAoMCwgY29kZWdlbl8xLl8pIGBNYXRoLmFicyhNYXRoLnJvdW5kKCR7cmVzfSkgLSAke3Jlc30pID4gMWUtJHtwcmVjfWBcbiAgICAgICAgICAgIDogKDAsIGNvZGVnZW5fMS5fKSBgJHtyZXN9ICE9PSBwYXJzZUludCgke3Jlc30pYDtcbiAgICAgICAgY3h0LmZhaWwkZGF0YSgoMCwgY29kZWdlbl8xLl8pIGAoJHtzY2hlbWFDb2RlfSA9PT0gMCB8fCAoJHtyZXN9ID0gJHtkYXRhfS8ke3NjaGVtYUNvZGV9LCAke2ludmFsaWR9KSlgKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW11bHRpcGxlT2YuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZ1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Jlc3RpZWpzL3B1bnljb2RlLmpzIC0gcHVueWNvZGUudWNzMi5kZWNvZGVcbmZ1bmN0aW9uIHVjczJsZW5ndGgoc3RyKSB7XG4gICAgY29uc3QgbGVuID0gc3RyLmxlbmd0aDtcbiAgICBsZXQgbGVuZ3RoID0gMDtcbiAgICBsZXQgcG9zID0gMDtcbiAgICBsZXQgdmFsdWU7XG4gICAgd2hpbGUgKHBvcyA8IGxlbikge1xuICAgICAgICBsZW5ndGgrKztcbiAgICAgICAgdmFsdWUgPSBzdHIuY2hhckNvZGVBdChwb3MrKyk7XG4gICAgICAgIGlmICh2YWx1ZSA+PSAweGQ4MDAgJiYgdmFsdWUgPD0gMHhkYmZmICYmIHBvcyA8IGxlbikge1xuICAgICAgICAgICAgLy8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG4gICAgICAgICAgICB2YWx1ZSA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgICAgICBpZiAoKHZhbHVlICYgMHhmYzAwKSA9PT0gMHhkYzAwKVxuICAgICAgICAgICAgICAgIHBvcysrOyAvLyBsb3cgc3Vycm9nYXRlXG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxlbmd0aDtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHVjczJsZW5ndGg7XG51Y3MybGVuZ3RoLmNvZGUgPSAncmVxdWlyZShcImFqdi9kaXN0L3J1bnRpbWUvdWNzMmxlbmd0aFwiKS5kZWZhdWx0Jztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVjczJsZW5ndGguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IHVjczJsZW5ndGhfMSA9IHJlcXVpcmUoXCIuLi8uLi9ydW50aW1lL3VjczJsZW5ndGhcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlKHsga2V5d29yZCwgc2NoZW1hQ29kZSB9KSB7XG4gICAgICAgIGNvbnN0IGNvbXAgPSBrZXl3b3JkID09PSBcIm1heExlbmd0aFwiID8gXCJtb3JlXCIgOiBcImZld2VyXCI7XG4gICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLnN0cikgYG11c3QgTk9UIGhhdmUgJHtjb21wfSB0aGFuICR7c2NoZW1hQ29kZX0gY2hhcmFjdGVyc2A7XG4gICAgfSxcbiAgICBwYXJhbXM6ICh7IHNjaGVtYUNvZGUgfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge2xpbWl0OiAke3NjaGVtYUNvZGV9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFtcIm1heExlbmd0aFwiLCBcIm1pbkxlbmd0aFwiXSxcbiAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgIHNjaGVtYVR5cGU6IFwibnVtYmVyXCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBrZXl3b3JkLCBkYXRhLCBzY2hlbWFDb2RlLCBpdCB9ID0gY3h0O1xuICAgICAgICBjb25zdCBvcCA9IGtleXdvcmQgPT09IFwibWF4TGVuZ3RoXCIgPyBjb2RlZ2VuXzEub3BlcmF0b3JzLkdUIDogY29kZWdlbl8xLm9wZXJhdG9ycy5MVDtcbiAgICAgICAgY29uc3QgbGVuID0gaXQub3B0cy51bmljb2RlID09PSBmYWxzZSA/ICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0ubGVuZ3RoYCA6ICgwLCBjb2RlZ2VuXzEuXykgYCR7KDAsIHV0aWxfMS51c2VGdW5jKShjeHQuZ2VuLCB1Y3MybGVuZ3RoXzEuZGVmYXVsdCl9KCR7ZGF0YX0pYDtcbiAgICAgICAgY3h0LmZhaWwkZGF0YSgoMCwgY29kZWdlbl8xLl8pIGAke2xlbn0gJHtvcH0gJHtzY2hlbWFDb2RlfWApO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGltaXRMZW5ndGguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi4vY29kZVwiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBzY2hlbWFDb2RlIH0pID0+ICgwLCBjb2RlZ2VuXzEuc3RyKSBgbXVzdCBtYXRjaCBwYXR0ZXJuIFwiJHtzY2hlbWFDb2RlfVwiYCxcbiAgICBwYXJhbXM6ICh7IHNjaGVtYUNvZGUgfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge3BhdHRlcm46ICR7c2NoZW1hQ29kZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJwYXR0ZXJuXCIsXG4gICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICBzY2hlbWFUeXBlOiBcInN0cmluZ1wiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZGF0YSwgJGRhdGEsIHNjaGVtYSwgc2NoZW1hQ29kZSwgaXQgfSA9IGN4dDtcbiAgICAgICAgLy8gVE9ETyByZWdleHAgc2hvdWxkIGJlIHdyYXBwZWQgaW4gdHJ5L2NhdGNoc1xuICAgICAgICBjb25zdCB1ID0gaXQub3B0cy51bmljb2RlUmVnRXhwID8gXCJ1XCIgOiBcIlwiO1xuICAgICAgICBjb25zdCByZWdFeHAgPSAkZGF0YSA/ICgwLCBjb2RlZ2VuXzEuXykgYChuZXcgUmVnRXhwKCR7c2NoZW1hQ29kZX0sICR7dX0pKWAgOiAoMCwgY29kZV8xLnVzZVBhdHRlcm4pKGN4dCwgc2NoZW1hKTtcbiAgICAgICAgY3h0LmZhaWwkZGF0YSgoMCwgY29kZWdlbl8xLl8pIGAhJHtyZWdFeHB9LnRlc3QoJHtkYXRhfSlgKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhdHRlcm4uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZSh7IGtleXdvcmQsIHNjaGVtYUNvZGUgfSkge1xuICAgICAgICBjb25zdCBjb21wID0ga2V5d29yZCA9PT0gXCJtYXhQcm9wZXJ0aWVzXCIgPyBcIm1vcmVcIiA6IFwiZmV3ZXJcIjtcbiAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuc3RyKSBgbXVzdCBOT1QgaGF2ZSAke2NvbXB9IHRoYW4gJHtzY2hlbWFDb2RlfSBwcm9wZXJ0aWVzYDtcbiAgICB9LFxuICAgIHBhcmFtczogKHsgc2NoZW1hQ29kZSB9KSA9PiAoMCwgY29kZWdlbl8xLl8pIGB7bGltaXQ6ICR7c2NoZW1hQ29kZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogW1wibWF4UHJvcGVydGllc1wiLCBcIm1pblByb3BlcnRpZXNcIl0sXG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICBzY2hlbWFUeXBlOiBcIm51bWJlclwiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsga2V5d29yZCwgZGF0YSwgc2NoZW1hQ29kZSB9ID0gY3h0O1xuICAgICAgICBjb25zdCBvcCA9IGtleXdvcmQgPT09IFwibWF4UHJvcGVydGllc1wiID8gY29kZWdlbl8xLm9wZXJhdG9ycy5HVCA6IGNvZGVnZW5fMS5vcGVyYXRvcnMuTFQ7XG4gICAgICAgIGN4dC5mYWlsJGRhdGEoKDAsIGNvZGVnZW5fMS5fKSBgT2JqZWN0LmtleXMoJHtkYXRhfSkubGVuZ3RoICR7b3B9ICR7c2NoZW1hQ29kZX1gKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpbWl0UHJvcGVydGllcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi9jb2RlXCIpO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBwYXJhbXM6IHsgbWlzc2luZ1Byb3BlcnR5IH0gfSkgPT4gKDAsIGNvZGVnZW5fMS5zdHIpIGBtdXN0IGhhdmUgcmVxdWlyZWQgcHJvcGVydHkgJyR7bWlzc2luZ1Byb3BlcnR5fSdgLFxuICAgIHBhcmFtczogKHsgcGFyYW1zOiB7IG1pc3NpbmdQcm9wZXJ0eSB9IH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHttaXNzaW5nUHJvcGVydHk6ICR7bWlzc2luZ1Byb3BlcnR5fX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcInJlcXVpcmVkXCIsXG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICBzY2hlbWFUeXBlOiBcImFycmF5XCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgc2NoZW1hQ29kZSwgZGF0YSwgJGRhdGEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGNvbnN0IHsgb3B0cyB9ID0gaXQ7XG4gICAgICAgIGlmICghJGRhdGEgJiYgc2NoZW1hLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgdXNlTG9vcCA9IHNjaGVtYS5sZW5ndGggPj0gb3B0cy5sb29wUmVxdWlyZWQ7XG4gICAgICAgIGlmIChpdC5hbGxFcnJvcnMpXG4gICAgICAgICAgICBhbGxFcnJvcnNNb2RlKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGV4aXRPbkVycm9yTW9kZSgpO1xuICAgICAgICBpZiAob3B0cy5zdHJpY3RSZXF1aXJlZCkge1xuICAgICAgICAgICAgY29uc3QgcHJvcHMgPSBjeHQucGFyZW50U2NoZW1hLnByb3BlcnRpZXM7XG4gICAgICAgICAgICBjb25zdCB7IGRlZmluZWRQcm9wZXJ0aWVzIH0gPSBjeHQuaXQ7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJlcXVpcmVkS2V5IG9mIHNjaGVtYSkge1xuICAgICAgICAgICAgICAgIGlmICgocHJvcHMgPT09IG51bGwgfHwgcHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb3BzW3JlcXVpcmVkS2V5XSkgPT09IHVuZGVmaW5lZCAmJiAhZGVmaW5lZFByb3BlcnRpZXMuaGFzKHJlcXVpcmVkS2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzY2hlbWFQYXRoID0gaXQuc2NoZW1hRW52LmJhc2VJZCArIGl0LmVyclNjaGVtYVBhdGg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1zZyA9IGByZXF1aXJlZCBwcm9wZXJ0eSBcIiR7cmVxdWlyZWRLZXl9XCIgaXMgbm90IGRlZmluZWQgYXQgXCIke3NjaGVtYVBhdGh9XCIgKHN0cmljdFJlcXVpcmVkKWA7XG4gICAgICAgICAgICAgICAgICAgICgwLCB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKShpdCwgbXNnLCBpdC5vcHRzLnN0cmljdFJlcXVpcmVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYWxsRXJyb3JzTW9kZSgpIHtcbiAgICAgICAgICAgIGlmICh1c2VMb29wIHx8ICRkYXRhKSB7XG4gICAgICAgICAgICAgICAgY3h0LmJsb2NrJGRhdGEoY29kZWdlbl8xLm5pbCwgbG9vcEFsbFJlcXVpcmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcCBvZiBzY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIGNvZGVfMS5jaGVja1JlcG9ydE1pc3NpbmdQcm9wKShjeHQsIHByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBleGl0T25FcnJvck1vZGUoKSB7XG4gICAgICAgICAgICBjb25zdCBtaXNzaW5nID0gZ2VuLmxldChcIm1pc3NpbmdcIik7XG4gICAgICAgICAgICBpZiAodXNlTG9vcCB8fCAkZGF0YSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIsIHRydWUpO1xuICAgICAgICAgICAgICAgIGN4dC5ibG9jayRkYXRhKHZhbGlkLCAoKSA9PiBsb29wVW50aWxNaXNzaW5nKG1pc3NpbmcsIHZhbGlkKSk7XG4gICAgICAgICAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZV8xLmNoZWNrTWlzc2luZ1Byb3ApKGN4dCwgc2NoZW1hLCBtaXNzaW5nKSk7XG4gICAgICAgICAgICAgICAgKDAsIGNvZGVfMS5yZXBvcnRNaXNzaW5nUHJvcCkoY3h0LCBtaXNzaW5nKTtcbiAgICAgICAgICAgICAgICBnZW4uZWxzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGxvb3BBbGxSZXF1aXJlZCgpIHtcbiAgICAgICAgICAgIGdlbi5mb3JPZihcInByb3BcIiwgc2NoZW1hQ29kZSwgKHByb3ApID0+IHtcbiAgICAgICAgICAgICAgICBjeHQuc2V0UGFyYW1zKHsgbWlzc2luZ1Byb3BlcnR5OiBwcm9wIH0pO1xuICAgICAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZV8xLm5vUHJvcGVydHlJbkRhdGEpKGdlbiwgZGF0YSwgcHJvcCwgb3B0cy5vd25Qcm9wZXJ0aWVzKSwgKCkgPT4gY3h0LmVycm9yKCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbG9vcFVudGlsTWlzc2luZyhtaXNzaW5nLCB2YWxpZCkge1xuICAgICAgICAgICAgY3h0LnNldFBhcmFtcyh7IG1pc3NpbmdQcm9wZXJ0eTogbWlzc2luZyB9KTtcbiAgICAgICAgICAgIGdlbi5mb3JPZihtaXNzaW5nLCBzY2hlbWFDb2RlLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgKDAsIGNvZGVfMS5wcm9wZXJ0eUluRGF0YSkoZ2VuLCBkYXRhLCBtaXNzaW5nLCBvcHRzLm93blByb3BlcnRpZXMpKTtcbiAgICAgICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5ub3QpKHZhbGlkKSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjeHQuZXJyb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmJyZWFrKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBjb2RlZ2VuXzEubmlsKTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVxdWlyZWQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZSh7IGtleXdvcmQsIHNjaGVtYUNvZGUgfSkge1xuICAgICAgICBjb25zdCBjb21wID0ga2V5d29yZCA9PT0gXCJtYXhJdGVtc1wiID8gXCJtb3JlXCIgOiBcImZld2VyXCI7XG4gICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLnN0cikgYG11c3QgTk9UIGhhdmUgJHtjb21wfSB0aGFuICR7c2NoZW1hQ29kZX0gaXRlbXNgO1xuICAgIH0sXG4gICAgcGFyYW1zOiAoeyBzY2hlbWFDb2RlIH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHtsaW1pdDogJHtzY2hlbWFDb2RlfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBbXCJtYXhJdGVtc1wiLCBcIm1pbkl0ZW1zXCJdLFxuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBzY2hlbWFUeXBlOiBcIm51bWJlclwiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsga2V5d29yZCwgZGF0YSwgc2NoZW1hQ29kZSB9ID0gY3h0O1xuICAgICAgICBjb25zdCBvcCA9IGtleXdvcmQgPT09IFwibWF4SXRlbXNcIiA/IGNvZGVnZW5fMS5vcGVyYXRvcnMuR1QgOiBjb2RlZ2VuXzEub3BlcmF0b3JzLkxUO1xuICAgICAgICBjeHQuZmFpbCRkYXRhKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0ubGVuZ3RoICR7b3B9ICR7c2NoZW1hQ29kZX1gKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpbWl0SXRlbXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vYWp2LXZhbGlkYXRvci9hanYvaXNzdWVzLzg4OVxuY29uc3QgZXF1YWwgPSByZXF1aXJlKFwiZmFzdC1kZWVwLWVxdWFsXCIpO1xuZXF1YWwuY29kZSA9ICdyZXF1aXJlKFwiYWp2L2Rpc3QvcnVudGltZS9lcXVhbFwiKS5kZWZhdWx0JztcbmV4cG9ydHMuZGVmYXVsdCA9IGVxdWFsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXF1YWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBkYXRhVHlwZV8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGUvZGF0YVR5cGVcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVxdWFsXzEgPSByZXF1aXJlKFwiLi4vLi4vcnVudGltZS9lcXVhbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHBhcmFtczogeyBpLCBqIH0gfSkgPT4gKDAsIGNvZGVnZW5fMS5zdHIpIGBtdXN0IE5PVCBoYXZlIGR1cGxpY2F0ZSBpdGVtcyAoaXRlbXMgIyMgJHtqfSBhbmQgJHtpfSBhcmUgaWRlbnRpY2FsKWAsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXM6IHsgaSwgaiB9IH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHtpOiAke2l9LCBqOiAke2p9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwidW5pcXVlSXRlbXNcIixcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgc2NoZW1hVHlwZTogXCJib29sZWFuXCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIGRhdGEsICRkYXRhLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgc2NoZW1hQ29kZSwgaXQgfSA9IGN4dDtcbiAgICAgICAgaWYgKCEkZGF0YSAmJiAhc2NoZW1hKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiKTtcbiAgICAgICAgY29uc3QgaXRlbVR5cGVzID0gcGFyZW50U2NoZW1hLml0ZW1zID8gKDAsIGRhdGFUeXBlXzEuZ2V0U2NoZW1hVHlwZXMpKHBhcmVudFNjaGVtYS5pdGVtcykgOiBbXTtcbiAgICAgICAgY3h0LmJsb2NrJGRhdGEodmFsaWQsIHZhbGlkYXRlVW5pcXVlSXRlbXMsICgwLCBjb2RlZ2VuXzEuXykgYCR7c2NoZW1hQ29kZX0gPT09IGZhbHNlYCk7XG4gICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlVW5pcXVlSXRlbXMoKSB7XG4gICAgICAgICAgICBjb25zdCBpID0gZ2VuLmxldChcImlcIiwgKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfS5sZW5ndGhgKTtcbiAgICAgICAgICAgIGNvbnN0IGogPSBnZW4ubGV0KFwialwiKTtcbiAgICAgICAgICAgIGN4dC5zZXRQYXJhbXMoeyBpLCBqIH0pO1xuICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSk7XG4gICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtpfSA+IDFgLCAoKSA9PiAoY2FuT3B0aW1pemUoKSA/IGxvb3BOIDogbG9vcE4yKShpLCBqKSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2FuT3B0aW1pemUoKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbVR5cGVzLmxlbmd0aCA+IDAgJiYgIWl0ZW1UeXBlcy5zb21lKCh0KSA9PiB0ID09PSBcIm9iamVjdFwiIHx8IHQgPT09IFwiYXJyYXlcIik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbG9vcE4oaSwgaikge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IGdlbi5uYW1lKFwiaXRlbVwiKTtcbiAgICAgICAgICAgIGNvbnN0IHdyb25nVHlwZSA9ICgwLCBkYXRhVHlwZV8xLmNoZWNrRGF0YVR5cGVzKShpdGVtVHlwZXMsIGl0ZW0sIGl0Lm9wdHMuc3RyaWN0TnVtYmVycywgZGF0YVR5cGVfMS5EYXRhVHlwZS5Xcm9uZyk7XG4gICAgICAgICAgICBjb25zdCBpbmRpY2VzID0gZ2VuLmNvbnN0KFwiaW5kaWNlc1wiLCAoMCwgY29kZWdlbl8xLl8pIGB7fWApO1xuICAgICAgICAgICAgZ2VuLmZvcigoMCwgY29kZWdlbl8xLl8pIGA7JHtpfS0tO2AsICgpID0+IHtcbiAgICAgICAgICAgICAgICBnZW4ubGV0KGl0ZW0sICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX1bJHtpfV1gKTtcbiAgICAgICAgICAgICAgICBnZW4uaWYod3JvbmdUeXBlLCAoMCwgY29kZWdlbl8xLl8pIGBjb250aW51ZWApO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtVHlwZXMubGVuZ3RoID4gMSlcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYHR5cGVvZiAke2l0ZW19ID09IFwic3RyaW5nXCJgLCAoMCwgY29kZWdlbl8xLl8pIGAke2l0ZW19ICs9IFwiX1wiYCk7XG4gICAgICAgICAgICAgICAgZ2VuXG4gICAgICAgICAgICAgICAgICAgIC5pZigoMCwgY29kZWdlbl8xLl8pIGB0eXBlb2YgJHtpbmRpY2VzfVske2l0ZW19XSA9PSBcIm51bWJlclwiYCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBnZW4uYXNzaWduKGosICgwLCBjb2RlZ2VuXzEuXykgYCR7aW5kaWNlc31bJHtpdGVtfV1gKTtcbiAgICAgICAgICAgICAgICAgICAgY3h0LmVycm9yKCk7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIGZhbHNlKS5icmVhaygpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5jb2RlKCgwLCBjb2RlZ2VuXzEuXykgYCR7aW5kaWNlc31bJHtpdGVtfV0gPSAke2l9YCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBsb29wTjIoaSwgaikge1xuICAgICAgICAgICAgY29uc3QgZXFsID0gKDAsIHV0aWxfMS51c2VGdW5jKShnZW4sIGVxdWFsXzEuZGVmYXVsdCk7XG4gICAgICAgICAgICBjb25zdCBvdXRlciA9IGdlbi5uYW1lKFwib3V0ZXJcIik7XG4gICAgICAgICAgICBnZW4ubGFiZWwob3V0ZXIpLmZvcigoMCwgY29kZWdlbl8xLl8pIGA7JHtpfS0tO2AsICgpID0+IGdlbi5mb3IoKDAsIGNvZGVnZW5fMS5fKSBgJHtqfSA9ICR7aX07ICR7an0tLTtgLCAoKSA9PiBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtlcWx9KCR7ZGF0YX1bJHtpfV0sICR7ZGF0YX1bJHtqfV0pYCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGN4dC5lcnJvcigpO1xuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIGZhbHNlKS5icmVhayhvdXRlcik7XG4gICAgICAgICAgICB9KSkpO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11bmlxdWVJdGVtcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZXF1YWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9ydW50aW1lL2VxdWFsXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogXCJtdXN0IGJlIGVxdWFsIHRvIGNvbnN0YW50XCIsXG4gICAgcGFyYW1zOiAoeyBzY2hlbWFDb2RlIH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHthbGxvd2VkVmFsdWU6ICR7c2NoZW1hQ29kZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJjb25zdFwiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCAkZGF0YSwgc2NoZW1hQ29kZSwgc2NoZW1hIH0gPSBjeHQ7XG4gICAgICAgIGlmICgkZGF0YSB8fCAoc2NoZW1hICYmIHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIikpIHtcbiAgICAgICAgICAgIGN4dC5mYWlsJGRhdGEoKDAsIGNvZGVnZW5fMS5fKSBgISR7KDAsIHV0aWxfMS51c2VGdW5jKShnZW4sIGVxdWFsXzEuZGVmYXVsdCl9KCR7ZGF0YX0sICR7c2NoZW1hQ29kZX0pYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjeHQuZmFpbCgoMCwgY29kZWdlbl8xLl8pIGAke3NjaGVtYX0gIT09ICR7ZGF0YX1gKTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVxdWFsXzEgPSByZXF1aXJlKFwiLi4vLi4vcnVudGltZS9lcXVhbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6IFwibXVzdCBiZSBlcXVhbCB0byBvbmUgb2YgdGhlIGFsbG93ZWQgdmFsdWVzXCIsXG4gICAgcGFyYW1zOiAoeyBzY2hlbWFDb2RlIH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHthbGxvd2VkVmFsdWVzOiAke3NjaGVtYUNvZGV9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiZW51bVwiLFxuICAgIHNjaGVtYVR5cGU6IFwiYXJyYXlcIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgZGF0YSwgJGRhdGEsIHNjaGVtYSwgc2NoZW1hQ29kZSwgaXQgfSA9IGN4dDtcbiAgICAgICAgaWYgKCEkZGF0YSAmJiBzY2hlbWEubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZW51bSBtdXN0IGhhdmUgbm9uLWVtcHR5IGFycmF5XCIpO1xuICAgICAgICBjb25zdCB1c2VMb29wID0gc2NoZW1hLmxlbmd0aCA+PSBpdC5vcHRzLmxvb3BFbnVtO1xuICAgICAgICBsZXQgZXFsO1xuICAgICAgICBjb25zdCBnZXRFcWwgPSAoKSA9PiAoZXFsICE9PSBudWxsICYmIGVxbCAhPT0gdm9pZCAwID8gZXFsIDogKGVxbCA9ICgwLCB1dGlsXzEudXNlRnVuYykoZ2VuLCBlcXVhbF8xLmRlZmF1bHQpKSk7XG4gICAgICAgIGxldCB2YWxpZDtcbiAgICAgICAgaWYgKHVzZUxvb3AgfHwgJGRhdGEpIHtcbiAgICAgICAgICAgIHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIpO1xuICAgICAgICAgICAgY3h0LmJsb2NrJGRhdGEodmFsaWQsIGxvb3BFbnVtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNjaGVtYSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgICAgICAgICAgY29uc3QgdlNjaGVtYSA9IGdlbi5jb25zdChcInZTY2hlbWFcIiwgc2NoZW1hQ29kZSk7XG4gICAgICAgICAgICB2YWxpZCA9ICgwLCBjb2RlZ2VuXzEub3IpKC4uLnNjaGVtYS5tYXAoKF94LCBpKSA9PiBlcXVhbENvZGUodlNjaGVtYSwgaSkpKTtcbiAgICAgICAgfVxuICAgICAgICBjeHQucGFzcyh2YWxpZCk7XG4gICAgICAgIGZ1bmN0aW9uIGxvb3BFbnVtKCkge1xuICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgZmFsc2UpO1xuICAgICAgICAgICAgZ2VuLmZvck9mKFwidlwiLCBzY2hlbWFDb2RlLCAodikgPT4gZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7Z2V0RXFsKCl9KCR7ZGF0YX0sICR7dn0pYCwgKCkgPT4gZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSkuYnJlYWsoKSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGVxdWFsQ29kZSh2U2NoZW1hLCBpKSB7XG4gICAgICAgICAgICBjb25zdCBzY2ggPSBzY2hlbWFbaV07XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHNjaCA9PT0gXCJvYmplY3RcIiAmJiBzY2ggIT09IG51bGxcbiAgICAgICAgICAgICAgICA/ICgwLCBjb2RlZ2VuXzEuXykgYCR7Z2V0RXFsKCl9KCR7ZGF0YX0sICR7dlNjaGVtYX1bJHtpfV0pYFxuICAgICAgICAgICAgICAgIDogKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfSA9PT0gJHtzY2h9YDtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW51bS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGxpbWl0TnVtYmVyXzEgPSByZXF1aXJlKFwiLi9saW1pdE51bWJlclwiKTtcbmNvbnN0IG11bHRpcGxlT2ZfMSA9IHJlcXVpcmUoXCIuL211bHRpcGxlT2ZcIik7XG5jb25zdCBsaW1pdExlbmd0aF8xID0gcmVxdWlyZShcIi4vbGltaXRMZW5ndGhcIik7XG5jb25zdCBwYXR0ZXJuXzEgPSByZXF1aXJlKFwiLi9wYXR0ZXJuXCIpO1xuY29uc3QgbGltaXRQcm9wZXJ0aWVzXzEgPSByZXF1aXJlKFwiLi9saW1pdFByb3BlcnRpZXNcIik7XG5jb25zdCByZXF1aXJlZF8xID0gcmVxdWlyZShcIi4vcmVxdWlyZWRcIik7XG5jb25zdCBsaW1pdEl0ZW1zXzEgPSByZXF1aXJlKFwiLi9saW1pdEl0ZW1zXCIpO1xuY29uc3QgdW5pcXVlSXRlbXNfMSA9IHJlcXVpcmUoXCIuL3VuaXF1ZUl0ZW1zXCIpO1xuY29uc3QgY29uc3RfMSA9IHJlcXVpcmUoXCIuL2NvbnN0XCIpO1xuY29uc3QgZW51bV8xID0gcmVxdWlyZShcIi4vZW51bVwiKTtcbmNvbnN0IHZhbGlkYXRpb24gPSBbXG4gICAgLy8gbnVtYmVyXG4gICAgbGltaXROdW1iZXJfMS5kZWZhdWx0LFxuICAgIG11bHRpcGxlT2ZfMS5kZWZhdWx0LFxuICAgIC8vIHN0cmluZ1xuICAgIGxpbWl0TGVuZ3RoXzEuZGVmYXVsdCxcbiAgICBwYXR0ZXJuXzEuZGVmYXVsdCxcbiAgICAvLyBvYmplY3RcbiAgICBsaW1pdFByb3BlcnRpZXNfMS5kZWZhdWx0LFxuICAgIHJlcXVpcmVkXzEuZGVmYXVsdCxcbiAgICAvLyBhcnJheVxuICAgIGxpbWl0SXRlbXNfMS5kZWZhdWx0LFxuICAgIHVuaXF1ZUl0ZW1zXzEuZGVmYXVsdCxcbiAgICAvLyBhbnlcbiAgICB7IGtleXdvcmQ6IFwidHlwZVwiLCBzY2hlbWFUeXBlOiBbXCJzdHJpbmdcIiwgXCJhcnJheVwiXSB9LFxuICAgIHsga2V5d29yZDogXCJudWxsYWJsZVwiLCBzY2hlbWFUeXBlOiBcImJvb2xlYW5cIiB9LFxuICAgIGNvbnN0XzEuZGVmYXVsdCxcbiAgICBlbnVtXzEuZGVmYXVsdCxcbl07XG5leHBvcnRzLmRlZmF1bHQgPSB2YWxpZGF0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlQWRkaXRpb25hbEl0ZW1zID0gdm9pZCAwO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBwYXJhbXM6IHsgbGVuIH0gfSkgPT4gKDAsIGNvZGVnZW5fMS5zdHIpIGBtdXN0IE5PVCBoYXZlIG1vcmUgdGhhbiAke2xlbn0gaXRlbXNgLFxuICAgIHBhcmFtczogKHsgcGFyYW1zOiB7IGxlbiB9IH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHtsaW1pdDogJHtsZW59fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiYWRkaXRpb25hbEl0ZW1zXCIsXG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHNjaGVtYVR5cGU6IFtcImJvb2xlYW5cIiwgXCJvYmplY3RcIl0sXG4gICAgYmVmb3JlOiBcInVuaXF1ZUl0ZW1zXCIsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBwYXJlbnRTY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGNvbnN0IHsgaXRlbXMgfSA9IHBhcmVudFNjaGVtYTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xuICAgICAgICAgICAgKDAsIHV0aWxfMS5jaGVja1N0cmljdE1vZGUpKGl0LCAnXCJhZGRpdGlvbmFsSXRlbXNcIiBpcyBpZ25vcmVkIHdoZW4gXCJpdGVtc1wiIGlzIG5vdCBhbiBhcnJheSBvZiBzY2hlbWFzJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFsaWRhdGVBZGRpdGlvbmFsSXRlbXMoY3h0LCBpdGVtcyk7XG4gICAgfSxcbn07XG5mdW5jdGlvbiB2YWxpZGF0ZUFkZGl0aW9uYWxJdGVtcyhjeHQsIGl0ZW1zKSB7XG4gICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgZGF0YSwga2V5d29yZCwgaXQgfSA9IGN4dDtcbiAgICBpdC5pdGVtcyA9IHRydWU7XG4gICAgY29uc3QgbGVuID0gZ2VuLmNvbnN0KFwibGVuXCIsICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0ubGVuZ3RoYCk7XG4gICAgaWYgKHNjaGVtYSA9PT0gZmFsc2UpIHtcbiAgICAgICAgY3h0LnNldFBhcmFtcyh7IGxlbjogaXRlbXMubGVuZ3RoIH0pO1xuICAgICAgICBjeHQucGFzcygoMCwgY29kZWdlbl8xLl8pIGAke2xlbn0gPD0gJHtpdGVtcy5sZW5ndGh9YCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIiAmJiAhKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaGVtYSkpIHtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4udmFyKFwidmFsaWRcIiwgKDAsIGNvZGVnZW5fMS5fKSBgJHtsZW59IDw9ICR7aXRlbXMubGVuZ3RofWApOyAvLyBUT0RPIHZhclxuICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5ub3QpKHZhbGlkKSwgKCkgPT4gdmFsaWRhdGVJdGVtcyh2YWxpZCkpO1xuICAgICAgICBjeHQub2sodmFsaWQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUl0ZW1zKHZhbGlkKSB7XG4gICAgICAgIGdlbi5mb3JSYW5nZShcImlcIiwgaXRlbXMubGVuZ3RoLCBsZW4sIChpKSA9PiB7XG4gICAgICAgICAgICBjeHQuc3Vic2NoZW1hKHsga2V5d29yZCwgZGF0YVByb3A6IGksIGRhdGFQcm9wVHlwZTogdXRpbF8xLlR5cGUuTnVtIH0sIHZhbGlkKTtcbiAgICAgICAgICAgIGlmICghaXQuYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLm5vdCkodmFsaWQpLCAoKSA9PiBnZW4uYnJlYWsoKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVBZGRpdGlvbmFsSXRlbXMgPSB2YWxpZGF0ZUFkZGl0aW9uYWxJdGVtcztcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkZGl0aW9uYWxJdGVtcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmFsaWRhdGVUdXBsZSA9IHZvaWQgMDtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uL2NvZGVcIik7XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJpdGVtc1wiLFxuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBzY2hlbWFUeXBlOiBbXCJvYmplY3RcIiwgXCJhcnJheVwiLCBcImJvb2xlYW5cIl0sXG4gICAgYmVmb3JlOiBcInVuaXF1ZUl0ZW1zXCIsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBzY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYSkpXG4gICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVUdXBsZShjeHQsIFwiYWRkaXRpb25hbEl0ZW1zXCIsIHNjaGVtYSk7XG4gICAgICAgIGl0Lml0ZW1zID0gdHJ1ZTtcbiAgICAgICAgaWYgKCgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2hlbWEpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjeHQub2soKDAsIGNvZGVfMS52YWxpZGF0ZUFycmF5KShjeHQpKTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIHZhbGlkYXRlVHVwbGUoY3h0LCBleHRyYUl0ZW1zLCBzY2hBcnIgPSBjeHQuc2NoZW1hKSB7XG4gICAgY29uc3QgeyBnZW4sIHBhcmVudFNjaGVtYSwgZGF0YSwga2V5d29yZCwgaXQgfSA9IGN4dDtcbiAgICBjaGVja1N0cmljdFR1cGxlKHBhcmVudFNjaGVtYSk7XG4gICAgaWYgKGl0Lm9wdHMudW5ldmFsdWF0ZWQgJiYgc2NoQXJyLmxlbmd0aCAmJiBpdC5pdGVtcyAhPT0gdHJ1ZSkge1xuICAgICAgICBpdC5pdGVtcyA9IHV0aWxfMS5tZXJnZUV2YWx1YXRlZC5pdGVtcyhnZW4sIHNjaEFyci5sZW5ndGgsIGl0Lml0ZW1zKTtcbiAgICB9XG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgIGNvbnN0IGxlbiA9IGdlbi5jb25zdChcImxlblwiLCAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9Lmxlbmd0aGApO1xuICAgIHNjaEFyci5mb3JFYWNoKChzY2gsIGkpID0+IHtcbiAgICAgICAgaWYgKCgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2gpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtsZW59ID4gJHtpfWAsICgpID0+IGN4dC5zdWJzY2hlbWEoe1xuICAgICAgICAgICAga2V5d29yZCxcbiAgICAgICAgICAgIHNjaGVtYVByb3A6IGksXG4gICAgICAgICAgICBkYXRhUHJvcDogaSxcbiAgICAgICAgfSwgdmFsaWQpKTtcbiAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBjaGVja1N0cmljdFR1cGxlKHNjaCkge1xuICAgICAgICBjb25zdCB7IG9wdHMsIGVyclNjaGVtYVBhdGggfSA9IGl0O1xuICAgICAgICBjb25zdCBsID0gc2NoQXJyLmxlbmd0aDtcbiAgICAgICAgY29uc3QgZnVsbFR1cGxlID0gbCA9PT0gc2NoLm1pbkl0ZW1zICYmIChsID09PSBzY2gubWF4SXRlbXMgfHwgc2NoW2V4dHJhSXRlbXNdID09PSBmYWxzZSk7XG4gICAgICAgIGlmIChvcHRzLnN0cmljdFR1cGxlcyAmJiAhZnVsbFR1cGxlKSB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSBgXCIke2tleXdvcmR9XCIgaXMgJHtsfS10dXBsZSwgYnV0IG1pbkl0ZW1zIG9yIG1heEl0ZW1zLyR7ZXh0cmFJdGVtc30gYXJlIG5vdCBzcGVjaWZpZWQgb3IgZGlmZmVyZW50IGF0IHBhdGggXCIke2VyclNjaGVtYVBhdGh9XCJgO1xuICAgICAgICAgICAgKDAsIHV0aWxfMS5jaGVja1N0cmljdE1vZGUpKGl0LCBtc2csIG9wdHMuc3RyaWN0VHVwbGVzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVUdXBsZSA9IHZhbGlkYXRlVHVwbGU7XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pdGVtcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGl0ZW1zXzEgPSByZXF1aXJlKFwiLi9pdGVtc1wiKTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcInByZWZpeEl0ZW1zXCIsXG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHNjaGVtYVR5cGU6IFtcImFycmF5XCJdLFxuICAgIGJlZm9yZTogXCJ1bmlxdWVJdGVtc1wiLFxuICAgIGNvZGU6IChjeHQpID0+ICgwLCBpdGVtc18xLnZhbGlkYXRlVHVwbGUpKGN4dCwgXCJpdGVtc1wiKSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcmVmaXhJdGVtcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uL2NvZGVcIik7XG5jb25zdCBhZGRpdGlvbmFsSXRlbXNfMSA9IHJlcXVpcmUoXCIuL2FkZGl0aW9uYWxJdGVtc1wiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHBhcmFtczogeyBsZW4gfSB9KSA9PiAoMCwgY29kZWdlbl8xLnN0cikgYG11c3QgTk9UIGhhdmUgbW9yZSB0aGFuICR7bGVufSBpdGVtc2AsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXM6IHsgbGVuIH0gfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge2xpbWl0OiAke2xlbn19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJpdGVtc1wiLFxuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBzY2hlbWFUeXBlOiBbXCJvYmplY3RcIiwgXCJib29sZWFuXCJdLFxuICAgIGJlZm9yZTogXCJ1bmlxdWVJdGVtc1wiLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4SXRlbXMgfSA9IHBhcmVudFNjaGVtYTtcbiAgICAgICAgaXQuaXRlbXMgPSB0cnVlO1xuICAgICAgICBpZiAoKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaGVtYSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChwcmVmaXhJdGVtcylcbiAgICAgICAgICAgICgwLCBhZGRpdGlvbmFsSXRlbXNfMS52YWxpZGF0ZUFkZGl0aW9uYWxJdGVtcykoY3h0LCBwcmVmaXhJdGVtcyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGN4dC5vaygoMCwgY29kZV8xLnZhbGlkYXRlQXJyYXkpKGN4dCkpO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXRlbXMyMDIwLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBwYXJhbXM6IHsgbWluLCBtYXggfSB9KSA9PiBtYXggPT09IHVuZGVmaW5lZFxuICAgICAgICA/ICgwLCBjb2RlZ2VuXzEuc3RyKSBgbXVzdCBjb250YWluIGF0IGxlYXN0ICR7bWlufSB2YWxpZCBpdGVtKHMpYFxuICAgICAgICA6ICgwLCBjb2RlZ2VuXzEuc3RyKSBgbXVzdCBjb250YWluIGF0IGxlYXN0ICR7bWlufSBhbmQgbm8gbW9yZSB0aGFuICR7bWF4fSB2YWxpZCBpdGVtKHMpYCxcbiAgICBwYXJhbXM6ICh7IHBhcmFtczogeyBtaW4sIG1heCB9IH0pID0+IG1heCA9PT0gdW5kZWZpbmVkID8gKDAsIGNvZGVnZW5fMS5fKSBge21pbkNvbnRhaW5zOiAke21pbn19YCA6ICgwLCBjb2RlZ2VuXzEuXykgYHttaW5Db250YWluczogJHttaW59LCBtYXhDb250YWluczogJHttYXh9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiY29udGFpbnNcIixcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgc2NoZW1hVHlwZTogW1wib2JqZWN0XCIsIFwiYm9vbGVhblwiXSxcbiAgICBiZWZvcmU6IFwidW5pcXVlSXRlbXNcIixcbiAgICB0cmFja0Vycm9yczogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGRhdGEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGxldCBtaW47XG4gICAgICAgIGxldCBtYXg7XG4gICAgICAgIGNvbnN0IHsgbWluQ29udGFpbnMsIG1heENvbnRhaW5zIH0gPSBwYXJlbnRTY2hlbWE7XG4gICAgICAgIGlmIChpdC5vcHRzLm5leHQpIHtcbiAgICAgICAgICAgIG1pbiA9IG1pbkNvbnRhaW5zID09PSB1bmRlZmluZWQgPyAxIDogbWluQ29udGFpbnM7XG4gICAgICAgICAgICBtYXggPSBtYXhDb250YWlucztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1pbiA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVuID0gZ2VuLmNvbnN0KFwibGVuXCIsICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0ubGVuZ3RoYCk7XG4gICAgICAgIGN4dC5zZXRQYXJhbXMoeyBtaW4sIG1heCB9KTtcbiAgICAgICAgaWYgKG1heCA9PT0gdW5kZWZpbmVkICYmIG1pbiA9PT0gMCkge1xuICAgICAgICAgICAgKDAsIHV0aWxfMS5jaGVja1N0cmljdE1vZGUpKGl0LCBgXCJtaW5Db250YWluc1wiID09IDAgd2l0aG91dCBcIm1heENvbnRhaW5zXCI6IFwiY29udGFpbnNcIiBrZXl3b3JkIGlnbm9yZWRgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF4ICE9PSB1bmRlZmluZWQgJiYgbWluID4gbWF4KSB7XG4gICAgICAgICAgICAoMCwgdXRpbF8xLmNoZWNrU3RyaWN0TW9kZSkoaXQsIGBcIm1pbkNvbnRhaW5zXCIgPiBcIm1heENvbnRhaW5zXCIgaXMgYWx3YXlzIGludmFsaWRgKTtcbiAgICAgICAgICAgIGN4dC5mYWlsKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2hlbWEpKSB7XG4gICAgICAgICAgICBsZXQgY29uZCA9ICgwLCBjb2RlZ2VuXzEuXykgYCR7bGVufSA+PSAke21pbn1gO1xuICAgICAgICAgICAgaWYgKG1heCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGNvbmQgPSAoMCwgY29kZWdlbl8xLl8pIGAke2NvbmR9ICYmICR7bGVufSA8PSAke21heH1gO1xuICAgICAgICAgICAgY3h0LnBhc3MoY29uZCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaXQuaXRlbXMgPSB0cnVlO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgICAgIGlmIChtYXggPT09IHVuZGVmaW5lZCAmJiBtaW4gPT09IDEpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlSXRlbXModmFsaWQsICgpID0+IGdlbi5pZih2YWxpZCwgKCkgPT4gZ2VuLmJyZWFrKCkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtaW4gPT09IDApIHtcbiAgICAgICAgICAgIGdlbi5sZXQodmFsaWQsIHRydWUpO1xuICAgICAgICAgICAgaWYgKG1heCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9Lmxlbmd0aCA+IDBgLCB2YWxpZGF0ZUl0ZW1zV2l0aENvdW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdlbi5sZXQodmFsaWQsIGZhbHNlKTtcbiAgICAgICAgICAgIHZhbGlkYXRlSXRlbXNXaXRoQ291bnQoKTtcbiAgICAgICAgfVxuICAgICAgICBjeHQucmVzdWx0KHZhbGlkLCAoKSA9PiBjeHQucmVzZXQoKSk7XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlSXRlbXNXaXRoQ291bnQoKSB7XG4gICAgICAgICAgICBjb25zdCBzY2hWYWxpZCA9IGdlbi5uYW1lKFwiX3ZhbGlkXCIpO1xuICAgICAgICAgICAgY29uc3QgY291bnQgPSBnZW4ubGV0KFwiY291bnRcIiwgMCk7XG4gICAgICAgICAgICB2YWxpZGF0ZUl0ZW1zKHNjaFZhbGlkLCAoKSA9PiBnZW4uaWYoc2NoVmFsaWQsICgpID0+IGNoZWNrTGltaXRzKGNvdW50KSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlSXRlbXMoX3ZhbGlkLCBibG9jaykge1xuICAgICAgICAgICAgZ2VuLmZvclJhbmdlKFwiaVwiLCAwLCBsZW4sIChpKSA9PiB7XG4gICAgICAgICAgICAgICAgY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICAgICAgICAgIGtleXdvcmQ6IFwiY29udGFpbnNcIixcbiAgICAgICAgICAgICAgICAgICAgZGF0YVByb3A6IGksXG4gICAgICAgICAgICAgICAgICAgIGRhdGFQcm9wVHlwZTogdXRpbF8xLlR5cGUuTnVtLFxuICAgICAgICAgICAgICAgICAgICBjb21wb3NpdGVSdWxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0sIF92YWxpZCk7XG4gICAgICAgICAgICAgICAgYmxvY2soKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrTGltaXRzKGNvdW50KSB7XG4gICAgICAgICAgICBnZW4uY29kZSgoMCwgY29kZWdlbl8xLl8pIGAke2NvdW50fSsrYCk7XG4gICAgICAgICAgICBpZiAobWF4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtjb3VudH0gPj0gJHttaW59YCwgKCkgPT4gZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSkuYnJlYWsoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtjb3VudH0gPiAke21heH1gLCAoKSA9PiBnZW4uYXNzaWduKHZhbGlkLCBmYWxzZSkuYnJlYWsoKSk7XG4gICAgICAgICAgICAgICAgaWYgKG1pbiA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtjb3VudH0gPj0gJHttaW59YCwgKCkgPT4gZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb250YWlucy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmFsaWRhdGVTY2hlbWFEZXBzID0gZXhwb3J0cy52YWxpZGF0ZVByb3BlcnR5RGVwcyA9IGV4cG9ydHMuZXJyb3IgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi9jb2RlXCIpO1xuZXhwb3J0cy5lcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBwYXJhbXM6IHsgcHJvcGVydHksIGRlcHNDb3VudCwgZGVwcyB9IH0pID0+IHtcbiAgICAgICAgY29uc3QgcHJvcGVydHlfaWVzID0gZGVwc0NvdW50ID09PSAxID8gXCJwcm9wZXJ0eVwiIDogXCJwcm9wZXJ0aWVzXCI7XG4gICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLnN0cikgYG11c3QgaGF2ZSAke3Byb3BlcnR5X2llc30gJHtkZXBzfSB3aGVuIHByb3BlcnR5ICR7cHJvcGVydHl9IGlzIHByZXNlbnRgO1xuICAgIH0sXG4gICAgcGFyYW1zOiAoeyBwYXJhbXM6IHsgcHJvcGVydHksIGRlcHNDb3VudCwgZGVwcywgbWlzc2luZ1Byb3BlcnR5IH0gfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge3Byb3BlcnR5OiAke3Byb3BlcnR5fSxcbiAgICBtaXNzaW5nUHJvcGVydHk6ICR7bWlzc2luZ1Byb3BlcnR5fSxcbiAgICBkZXBzQ291bnQ6ICR7ZGVwc0NvdW50fSxcbiAgICBkZXBzOiAke2RlcHN9fWAsIC8vIFRPRE8gY2hhbmdlIHRvIHJlZmVyZW5jZVxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImRlcGVuZGVuY2llc1wiLFxuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgc2NoZW1hVHlwZTogXCJvYmplY3RcIixcbiAgICBlcnJvcjogZXhwb3J0cy5lcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCBbcHJvcERlcHMsIHNjaERlcHNdID0gc3BsaXREZXBlbmRlbmNpZXMoY3h0KTtcbiAgICAgICAgdmFsaWRhdGVQcm9wZXJ0eURlcHMoY3h0LCBwcm9wRGVwcyk7XG4gICAgICAgIHZhbGlkYXRlU2NoZW1hRGVwcyhjeHQsIHNjaERlcHMpO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gc3BsaXREZXBlbmRlbmNpZXMoeyBzY2hlbWEgfSkge1xuICAgIGNvbnN0IHByb3BlcnR5RGVwcyA9IHt9O1xuICAgIGNvbnN0IHNjaGVtYURlcHMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gXCJfX3Byb3RvX19cIilcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBkZXBzID0gQXJyYXkuaXNBcnJheShzY2hlbWFba2V5XSkgPyBwcm9wZXJ0eURlcHMgOiBzY2hlbWFEZXBzO1xuICAgICAgICBkZXBzW2tleV0gPSBzY2hlbWFba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIFtwcm9wZXJ0eURlcHMsIHNjaGVtYURlcHNdO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0eURlcHMoY3h0LCBwcm9wZXJ0eURlcHMgPSBjeHQuc2NoZW1hKSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEsIGl0IH0gPSBjeHQ7XG4gICAgaWYgKE9iamVjdC5rZXlzKHByb3BlcnR5RGVwcykubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgbWlzc2luZyA9IGdlbi5sZXQoXCJtaXNzaW5nXCIpO1xuICAgIGZvciAoY29uc3QgcHJvcCBpbiBwcm9wZXJ0eURlcHMpIHtcbiAgICAgICAgY29uc3QgZGVwcyA9IHByb3BlcnR5RGVwc1twcm9wXTtcbiAgICAgICAgaWYgKGRlcHMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IGhhc1Byb3BlcnR5ID0gKDAsIGNvZGVfMS5wcm9wZXJ0eUluRGF0YSkoZ2VuLCBkYXRhLCBwcm9wLCBpdC5vcHRzLm93blByb3BlcnRpZXMpO1xuICAgICAgICBjeHQuc2V0UGFyYW1zKHtcbiAgICAgICAgICAgIHByb3BlcnR5OiBwcm9wLFxuICAgICAgICAgICAgZGVwc0NvdW50OiBkZXBzLmxlbmd0aCxcbiAgICAgICAgICAgIGRlcHM6IGRlcHMuam9pbihcIiwgXCIpLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGl0LmFsbEVycm9ycykge1xuICAgICAgICAgICAgZ2VuLmlmKGhhc1Byb3BlcnR5LCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBkZXBQcm9wIG9mIGRlcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIGNvZGVfMS5jaGVja1JlcG9ydE1pc3NpbmdQcm9wKShjeHQsIGRlcFByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7aGFzUHJvcGVydHl9ICYmICgkeygwLCBjb2RlXzEuY2hlY2tNaXNzaW5nUHJvcCkoY3h0LCBkZXBzLCBtaXNzaW5nKX0pYCk7XG4gICAgICAgICAgICAoMCwgY29kZV8xLnJlcG9ydE1pc3NpbmdQcm9wKShjeHQsIG1pc3NpbmcpO1xuICAgICAgICAgICAgZ2VuLmVsc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVQcm9wZXJ0eURlcHMgPSB2YWxpZGF0ZVByb3BlcnR5RGVwcztcbmZ1bmN0aW9uIHZhbGlkYXRlU2NoZW1hRGVwcyhjeHQsIHNjaGVtYURlcHMgPSBjeHQuc2NoZW1hKSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEsIGtleXdvcmQsIGl0IH0gPSBjeHQ7XG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgIGZvciAoY29uc3QgcHJvcCBpbiBzY2hlbWFEZXBzKSB7XG4gICAgICAgIGlmICgoMCwgdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKShpdCwgc2NoZW1hRGVwc1twcm9wXSkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgZ2VuLmlmKCgwLCBjb2RlXzEucHJvcGVydHlJbkRhdGEpKGdlbiwgZGF0YSwgcHJvcCwgaXQub3B0cy5vd25Qcm9wZXJ0aWVzKSwgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7IGtleXdvcmQsIHNjaGVtYVByb3A6IHByb3AgfSwgdmFsaWQpO1xuICAgICAgICAgICAgY3h0Lm1lcmdlVmFsaWRFdmFsdWF0ZWQoc2NoQ3h0LCB2YWxpZCk7XG4gICAgICAgIH0sICgpID0+IGdlbi52YXIodmFsaWQsIHRydWUpIC8vIFRPRE8gdmFyXG4gICAgICAgICk7XG4gICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZVNjaGVtYURlcHMgPSB2YWxpZGF0ZVNjaGVtYURlcHM7XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXBlbmRlbmNpZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6IFwicHJvcGVydHkgbmFtZSBtdXN0IGJlIHZhbGlkXCIsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXMgfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge3Byb3BlcnR5TmFtZTogJHtwYXJhbXMucHJvcGVydHlOYW1lfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcInByb3BlcnR5TmFtZXNcIixcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIHNjaGVtYVR5cGU6IFtcIm9iamVjdFwiLCBcImJvb2xlYW5cIl0sXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgZGF0YSwgaXQgfSA9IGN4dDtcbiAgICAgICAgaWYgKCgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2hlbWEpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgICAgIGdlbi5mb3JJbihcImtleVwiLCBkYXRhLCAoa2V5KSA9PiB7XG4gICAgICAgICAgICBjeHQuc2V0UGFyYW1zKHsgcHJvcGVydHlOYW1lOiBrZXkgfSk7XG4gICAgICAgICAgICBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgICAgICBrZXl3b3JkOiBcInByb3BlcnR5TmFtZXNcIixcbiAgICAgICAgICAgICAgICBkYXRhOiBrZXksXG4gICAgICAgICAgICAgICAgZGF0YVR5cGVzOiBbXCJzdHJpbmdcIl0sXG4gICAgICAgICAgICAgICAgcHJvcGVydHlOYW1lOiBrZXksXG4gICAgICAgICAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICAgICAgICAgIH0sIHZhbGlkKTtcbiAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLm5vdCkodmFsaWQpLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY3h0LmVycm9yKHRydWUpO1xuICAgICAgICAgICAgICAgIGlmICghaXQuYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgICAgICBnZW4uYnJlYWsoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3BlcnR5TmFtZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi4vY29kZVwiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBuYW1lc18xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvbmFtZXNcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogXCJtdXN0IE5PVCBoYXZlIGFkZGl0aW9uYWwgcHJvcGVydGllc1wiLFxuICAgIHBhcmFtczogKHsgcGFyYW1zIH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHthZGRpdGlvbmFsUHJvcGVydHk6ICR7cGFyYW1zLmFkZGl0aW9uYWxQcm9wZXJ0eX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiLFxuICAgIHR5cGU6IFtcIm9iamVjdFwiXSxcbiAgICBzY2hlbWFUeXBlOiBbXCJib29sZWFuXCIsIFwib2JqZWN0XCJdLFxuICAgIGFsbG93VW5kZWZpbmVkOiB0cnVlLFxuICAgIHRyYWNrRXJyb3JzOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgZGF0YSwgZXJyc0NvdW50LCBpdCB9ID0gY3h0O1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFlcnJzQ291bnQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIik7XG4gICAgICAgIGNvbnN0IHsgYWxsRXJyb3JzLCBvcHRzIH0gPSBpdDtcbiAgICAgICAgaXQucHJvcHMgPSB0cnVlO1xuICAgICAgICBpZiAob3B0cy5yZW1vdmVBZGRpdGlvbmFsICE9PSBcImFsbFwiICYmICgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2hlbWEpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBwcm9wcyA9ICgwLCBjb2RlXzEuYWxsU2NoZW1hUHJvcGVydGllcykocGFyZW50U2NoZW1hLnByb3BlcnRpZXMpO1xuICAgICAgICBjb25zdCBwYXRQcm9wcyA9ICgwLCBjb2RlXzEuYWxsU2NoZW1hUHJvcGVydGllcykocGFyZW50U2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzKTtcbiAgICAgICAgY2hlY2tBZGRpdGlvbmFsUHJvcGVydGllcygpO1xuICAgICAgICBjeHQub2soKDAsIGNvZGVnZW5fMS5fKSBgJHtlcnJzQ291bnR9ID09PSAke25hbWVzXzEuZGVmYXVsdC5lcnJvcnN9YCk7XG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrQWRkaXRpb25hbFByb3BlcnRpZXMoKSB7XG4gICAgICAgICAgICBnZW4uZm9ySW4oXCJrZXlcIiwgZGF0YSwgKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghcHJvcHMubGVuZ3RoICYmICFwYXRQcm9wcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0eUNvZGUoa2V5KTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGdlbi5pZihpc0FkZGl0aW9uYWwoa2V5KSwgKCkgPT4gYWRkaXRpb25hbFByb3BlcnR5Q29kZShrZXkpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzQWRkaXRpb25hbChrZXkpIHtcbiAgICAgICAgICAgIGxldCBkZWZpbmVkUHJvcDtcbiAgICAgICAgICAgIGlmIChwcm9wcy5sZW5ndGggPiA4KSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBtYXliZSBhbiBvcHRpb24gaW5zdGVhZCBvZiBoYXJkLWNvZGVkIDg/XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcHNTY2hlbWEgPSAoMCwgdXRpbF8xLnNjaGVtYVJlZk9yVmFsKShpdCwgcGFyZW50U2NoZW1hLnByb3BlcnRpZXMsIFwicHJvcGVydGllc1wiKTtcbiAgICAgICAgICAgICAgICBkZWZpbmVkUHJvcCA9ICgwLCBjb2RlXzEuaXNPd25Qcm9wZXJ0eSkoZ2VuLCBwcm9wc1NjaGVtYSwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByb3BzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGRlZmluZWRQcm9wID0gKDAsIGNvZGVnZW5fMS5vcikoLi4ucHJvcHMubWFwKChwKSA9PiAoMCwgY29kZWdlbl8xLl8pIGAke2tleX0gPT09ICR7cH1gKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVkUHJvcCA9IGNvZGVnZW5fMS5uaWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGF0UHJvcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZGVmaW5lZFByb3AgPSAoMCwgY29kZWdlbl8xLm9yKShkZWZpbmVkUHJvcCwgLi4ucGF0UHJvcHMubWFwKChwKSA9PiAoMCwgY29kZWdlbl8xLl8pIGAkeygwLCBjb2RlXzEudXNlUGF0dGVybikoY3h0LCBwKX0udGVzdCgke2tleX0pYCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEubm90KShkZWZpbmVkUHJvcCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZGVsZXRlQWRkaXRpb25hbChrZXkpIHtcbiAgICAgICAgICAgIGdlbi5jb2RlKCgwLCBjb2RlZ2VuXzEuXykgYGRlbGV0ZSAke2RhdGF9WyR7a2V5fV1gKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhZGRpdGlvbmFsUHJvcGVydHlDb2RlKGtleSkge1xuICAgICAgICAgICAgaWYgKG9wdHMucmVtb3ZlQWRkaXRpb25hbCA9PT0gXCJhbGxcIiB8fCAob3B0cy5yZW1vdmVBZGRpdGlvbmFsICYmIHNjaGVtYSA9PT0gZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlQWRkaXRpb25hbChrZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzY2hlbWEgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgY3h0LnNldFBhcmFtcyh7IGFkZGl0aW9uYWxQcm9wZXJ0eToga2V5IH0pO1xuICAgICAgICAgICAgICAgIGN4dC5lcnJvcigpO1xuICAgICAgICAgICAgICAgIGlmICghYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgICAgICBnZW4uYnJlYWsoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcIm9iamVjdFwiICYmICEoMCwgdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKShpdCwgc2NoZW1hKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICAgICAgICAgICAgICBpZiAob3B0cy5yZW1vdmVBZGRpdGlvbmFsID09PSBcImZhaWxpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBhcHBseUFkZGl0aW9uYWxTY2hlbWEoa2V5LCB2YWxpZCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5ub3QpKHZhbGlkKSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3h0LnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVBZGRpdGlvbmFsKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXBwbHlBZGRpdGlvbmFsU2NoZW1hKGtleSwgdmFsaWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWFsbEVycm9ycylcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLm5vdCkodmFsaWQpLCAoKSA9PiBnZW4uYnJlYWsoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFwcGx5QWRkaXRpb25hbFNjaGVtYShrZXksIHZhbGlkLCBlcnJvcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YnNjaGVtYSA9IHtcbiAgICAgICAgICAgICAgICBrZXl3b3JkOiBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCIsXG4gICAgICAgICAgICAgICAgZGF0YVByb3A6IGtleSxcbiAgICAgICAgICAgICAgICBkYXRhUHJvcFR5cGU6IHV0aWxfMS5UeXBlLlN0cixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoZXJyb3JzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oc3Vic2NoZW1hLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvc2l0ZVJ1bGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVycm9yczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGFsbEVycm9yczogZmFsc2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjeHQuc3Vic2NoZW1hKHN1YnNjaGVtYSwgdmFsaWQpO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRpdGlvbmFsUHJvcGVydGllcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHZhbGlkYXRlXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZVwiKTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi9jb2RlXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGFkZGl0aW9uYWxQcm9wZXJ0aWVzXzEgPSByZXF1aXJlKFwiLi9hZGRpdGlvbmFsUHJvcGVydGllc1wiKTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcInByb3BlcnRpZXNcIixcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIHNjaGVtYVR5cGU6IFwib2JqZWN0XCIsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBkYXRhLCBpdCB9ID0gY3h0O1xuICAgICAgICBpZiAoaXQub3B0cy5yZW1vdmVBZGRpdGlvbmFsID09PSBcImFsbFwiICYmIHBhcmVudFNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhZGRpdGlvbmFsUHJvcGVydGllc18xLmRlZmF1bHQuY29kZShuZXcgdmFsaWRhdGVfMS5LZXl3b3JkQ3h0KGl0LCBhZGRpdGlvbmFsUHJvcGVydGllc18xLmRlZmF1bHQsIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIikpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFsbFByb3BzID0gKDAsIGNvZGVfMS5hbGxTY2hlbWFQcm9wZXJ0aWVzKShzY2hlbWEpO1xuICAgICAgICBmb3IgKGNvbnN0IHByb3Agb2YgYWxsUHJvcHMpIHtcbiAgICAgICAgICAgIGl0LmRlZmluZWRQcm9wZXJ0aWVzLmFkZChwcm9wKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXQub3B0cy51bmV2YWx1YXRlZCAmJiBhbGxQcm9wcy5sZW5ndGggJiYgaXQucHJvcHMgIT09IHRydWUpIHtcbiAgICAgICAgICAgIGl0LnByb3BzID0gdXRpbF8xLm1lcmdlRXZhbHVhdGVkLnByb3BzKGdlbiwgKDAsIHV0aWxfMS50b0hhc2gpKGFsbFByb3BzKSwgaXQucHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBhbGxQcm9wcy5maWx0ZXIoKHApID0+ICEoMCwgdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKShpdCwgc2NoZW1hW3BdKSk7XG4gICAgICAgIGlmIChwcm9wZXJ0aWVzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgICAgICBmb3IgKGNvbnN0IHByb3Agb2YgcHJvcGVydGllcykge1xuICAgICAgICAgICAgaWYgKGhhc0RlZmF1bHQocHJvcCkpIHtcbiAgICAgICAgICAgICAgICBhcHBseVByb3BlcnR5U2NoZW1hKHByb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlXzEucHJvcGVydHlJbkRhdGEpKGdlbiwgZGF0YSwgcHJvcCwgaXQub3B0cy5vd25Qcm9wZXJ0aWVzKSk7XG4gICAgICAgICAgICAgICAgYXBwbHlQcm9wZXJ0eVNjaGVtYShwcm9wKTtcbiAgICAgICAgICAgICAgICBpZiAoIWl0LmFsbEVycm9ycylcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmVsc2UoKS52YXIodmFsaWQsIHRydWUpO1xuICAgICAgICAgICAgICAgIGdlbi5lbmRJZigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3h0Lml0LmRlZmluZWRQcm9wZXJ0aWVzLmFkZChwcm9wKTtcbiAgICAgICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaGFzRGVmYXVsdChwcm9wKSB7XG4gICAgICAgICAgICByZXR1cm4gaXQub3B0cy51c2VEZWZhdWx0cyAmJiAhaXQuY29tcG9zaXRlUnVsZSAmJiBzY2hlbWFbcHJvcF0uZGVmYXVsdCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFwcGx5UHJvcGVydHlTY2hlbWEocHJvcCkge1xuICAgICAgICAgICAgY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICAgICAga2V5d29yZDogXCJwcm9wZXJ0aWVzXCIsXG4gICAgICAgICAgICAgICAgc2NoZW1hUHJvcDogcHJvcCxcbiAgICAgICAgICAgICAgICBkYXRhUHJvcDogcHJvcCxcbiAgICAgICAgICAgIH0sIHZhbGlkKTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvcGVydGllcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi9jb2RlXCIpO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCB1dGlsXzIgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwicGF0dGVyblByb3BlcnRpZXNcIixcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIHNjaGVtYVR5cGU6IFwib2JqZWN0XCIsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgZGF0YSwgcGFyZW50U2NoZW1hLCBpdCB9ID0gY3h0O1xuICAgICAgICBjb25zdCB7IG9wdHMgfSA9IGl0O1xuICAgICAgICBjb25zdCBwYXR0ZXJucyA9ICgwLCBjb2RlXzEuYWxsU2NoZW1hUHJvcGVydGllcykoc2NoZW1hKTtcbiAgICAgICAgY29uc3QgYWx3YXlzVmFsaWRQYXR0ZXJucyA9IHBhdHRlcm5zLmZpbHRlcigocCkgPT4gKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaGVtYVtwXSkpO1xuICAgICAgICBpZiAocGF0dGVybnMubGVuZ3RoID09PSAwIHx8XG4gICAgICAgICAgICAoYWx3YXlzVmFsaWRQYXR0ZXJucy5sZW5ndGggPT09IHBhdHRlcm5zLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICghaXQub3B0cy51bmV2YWx1YXRlZCB8fCBpdC5wcm9wcyA9PT0gdHJ1ZSkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hlY2tQcm9wZXJ0aWVzID0gb3B0cy5zdHJpY3RTY2hlbWEgJiYgIW9wdHMuYWxsb3dNYXRjaGluZ1Byb3BlcnRpZXMgJiYgcGFyZW50U2NoZW1hLnByb3BlcnRpZXM7XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICAgICAgaWYgKGl0LnByb3BzICE9PSB0cnVlICYmICEoaXQucHJvcHMgaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSkpIHtcbiAgICAgICAgICAgIGl0LnByb3BzID0gKDAsIHV0aWxfMi5ldmFsdWF0ZWRQcm9wc1RvTmFtZSkoZ2VuLCBpdC5wcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gaXQ7XG4gICAgICAgIHZhbGlkYXRlUGF0dGVyblByb3BlcnRpZXMoKTtcbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVQYXR0ZXJuUHJvcGVydGllcygpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGF0IG9mIHBhdHRlcm5zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrUHJvcGVydGllcylcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tNYXRjaGluZ1Byb3BlcnRpZXMocGF0KTtcbiAgICAgICAgICAgICAgICBpZiAoaXQuYWxsRXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlUHJvcGVydGllcyhwYXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLnZhcih2YWxpZCwgdHJ1ZSk7IC8vIFRPRE8gdmFyXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlUHJvcGVydGllcyhwYXQpO1xuICAgICAgICAgICAgICAgICAgICBnZW4uaWYodmFsaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjaGVja01hdGNoaW5nUHJvcGVydGllcyhwYXQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBjaGVja1Byb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAobmV3IFJlZ0V4cChwYXQpLnRlc3QocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIHV0aWxfMS5jaGVja1N0cmljdE1vZGUpKGl0LCBgcHJvcGVydHkgJHtwcm9wfSBtYXRjaGVzIHBhdHRlcm4gJHtwYXR9ICh1c2UgYWxsb3dNYXRjaGluZ1Byb3BlcnRpZXMpYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyhwYXQpIHtcbiAgICAgICAgICAgIGdlbi5mb3JJbihcImtleVwiLCBkYXRhLCAoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7KDAsIGNvZGVfMS51c2VQYXR0ZXJuKShjeHQsIHBhdCl9LnRlc3QoJHtrZXl9KWAsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWx3YXlzVmFsaWQgPSBhbHdheXNWYWxpZFBhdHRlcm5zLmluY2x1ZGVzKHBhdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYWx3YXlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN4dC5zdWJzY2hlbWEoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleXdvcmQ6IFwicGF0dGVyblByb3BlcnRpZXNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2hlbWFQcm9wOiBwYXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVByb3A6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhUHJvcFR5cGU6IHV0aWxfMi5UeXBlLlN0cixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHZhbGlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXQub3B0cy51bmV2YWx1YXRlZCAmJiBwcm9wcyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbigoMCwgY29kZWdlbl8xLl8pIGAke3Byb3BzfVske2tleX1dYCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWFsd2F5c1ZhbGlkICYmICFpdC5hbGxFcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbiBzaG9ydC1jaXJjdWl0IGlmIGB1bmV2YWx1YXRlZFByb3BlcnRpZXNgIGlzIG5vdCBzdXBwb3J0ZWQgKG9wdHMubmV4dCA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvciBpZiBhbGwgcHJvcGVydGllcyB3ZXJlIGV2YWx1YXRlZCAocHJvcHMgPT09IHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5ub3QpKHZhbGlkKSwgKCkgPT4gZ2VuLmJyZWFrKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGF0dGVyblByb3BlcnRpZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwibm90XCIsXG4gICAgc2NoZW1hVHlwZTogW1wib2JqZWN0XCIsIFwiYm9vbGVhblwiXSxcbiAgICB0cmFja0Vycm9yczogdHJ1ZSxcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBpdCB9ID0gY3h0O1xuICAgICAgICBpZiAoKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaGVtYSkpIHtcbiAgICAgICAgICAgIGN4dC5mYWlsKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgICAgICBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgIGtleXdvcmQ6IFwibm90XCIsXG4gICAgICAgICAgICBjb21wb3NpdGVSdWxlOiB0cnVlLFxuICAgICAgICAgICAgY3JlYXRlRXJyb3JzOiBmYWxzZSxcbiAgICAgICAgICAgIGFsbEVycm9yczogZmFsc2UsXG4gICAgICAgIH0sIHZhbGlkKTtcbiAgICAgICAgY3h0LmZhaWxSZXN1bHQodmFsaWQsICgpID0+IGN4dC5yZXNldCgpLCAoKSA9PiBjeHQuZXJyb3IoKSk7XG4gICAgfSxcbiAgICBlcnJvcjogeyBtZXNzYWdlOiBcIm11c3QgTk9UIGJlIHZhbGlkXCIgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi4vY29kZVwiKTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImFueU9mXCIsXG4gICAgc2NoZW1hVHlwZTogXCJhcnJheVwiLFxuICAgIHRyYWNrRXJyb3JzOiB0cnVlLFxuICAgIGNvZGU6IGNvZGVfMS52YWxpZGF0ZVVuaW9uLFxuICAgIGVycm9yOiB7IG1lc3NhZ2U6IFwibXVzdCBtYXRjaCBhIHNjaGVtYSBpbiBhbnlPZlwiIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YW55T2YuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6IFwibXVzdCBtYXRjaCBleGFjdGx5IG9uZSBzY2hlbWEgaW4gb25lT2ZcIixcbiAgICBwYXJhbXM6ICh7IHBhcmFtcyB9KSA9PiAoMCwgY29kZWdlbl8xLl8pIGB7cGFzc2luZ1NjaGVtYXM6ICR7cGFyYW1zLnBhc3Npbmd9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwib25lT2ZcIixcbiAgICBzY2hlbWFUeXBlOiBcImFycmF5XCIsXG4gICAgdHJhY2tFcnJvcnM6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBpdCB9ID0gY3h0O1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNjaGVtYSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIik7XG4gICAgICAgIGlmIChpdC5vcHRzLmRpc2NyaW1pbmF0b3IgJiYgcGFyZW50U2NoZW1hLmRpc2NyaW1pbmF0b3IpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHNjaEFyciA9IHNjaGVtYTtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIiwgZmFsc2UpO1xuICAgICAgICBjb25zdCBwYXNzaW5nID0gZ2VuLmxldChcInBhc3NpbmdcIiwgbnVsbCk7XG4gICAgICAgIGNvbnN0IHNjaFZhbGlkID0gZ2VuLm5hbWUoXCJfdmFsaWRcIik7XG4gICAgICAgIGN4dC5zZXRQYXJhbXMoeyBwYXNzaW5nIH0pO1xuICAgICAgICAvLyBUT0RPIHBvc3NpYmx5IGZhaWwgc3RyYWlnaHQgYXdheSAod2l0aCB3YXJuaW5nIG9yIGV4Y2VwdGlvbikgaWYgdGhlcmUgYXJlIHR3byBlbXB0eSBhbHdheXMgdmFsaWQgc2NoZW1hc1xuICAgICAgICBnZW4uYmxvY2sodmFsaWRhdGVPbmVPZik7XG4gICAgICAgIGN4dC5yZXN1bHQodmFsaWQsICgpID0+IGN4dC5yZXNldCgpLCAoKSA9PiBjeHQuZXJyb3IodHJ1ZSkpO1xuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZU9uZU9mKCkge1xuICAgICAgICAgICAgc2NoQXJyLmZvckVhY2goKHNjaCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBzY2hDeHQ7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIGdlbi52YXIoc2NoVmFsaWQsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXl3b3JkOiBcIm9uZU9mXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzY2hlbWFQcm9wOiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSwgc2NoVmFsaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuXG4gICAgICAgICAgICAgICAgICAgICAgICAuaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtzY2hWYWxpZH0gJiYgJHt2YWxpZH1gKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFzc2lnbih2YWxpZCwgZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXNzaWduKHBhc3NpbmcsICgwLCBjb2RlZ2VuXzEuXykgYFske3Bhc3Npbmd9LCAke2l9XWApXG4gICAgICAgICAgICAgICAgICAgICAgICAuZWxzZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnZW4uaWYoc2NoVmFsaWQsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24ocGFzc2luZywgaSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY2hDeHQpXG4gICAgICAgICAgICAgICAgICAgICAgICBjeHQubWVyZ2VFdmFsdWF0ZWQoc2NoQ3h0LCBjb2RlZ2VuXzEuTmFtZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b25lT2YuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiYWxsT2ZcIixcbiAgICBzY2hlbWFUeXBlOiBcImFycmF5XCIsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgaXQgfSA9IGN4dDtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzY2hlbWEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgICAgIHNjaGVtYS5mb3JFYWNoKChzY2gsIGkpID0+IHtcbiAgICAgICAgICAgIGlmICgoMCwgdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKShpdCwgc2NoKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKHsga2V5d29yZDogXCJhbGxPZlwiLCBzY2hlbWFQcm9wOiBpIH0sIHZhbGlkKTtcbiAgICAgICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgICAgICAgICBjeHQubWVyZ2VFdmFsdWF0ZWQoc2NoQ3h0KTtcbiAgICAgICAgfSk7XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbGxPZi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsgcGFyYW1zIH0pID0+ICgwLCBjb2RlZ2VuXzEuc3RyKSBgbXVzdCBtYXRjaCBcIiR7cGFyYW1zLmlmQ2xhdXNlfVwiIHNjaGVtYWAsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXMgfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge2ZhaWxpbmdLZXl3b3JkOiAke3BhcmFtcy5pZkNsYXVzZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJpZlwiLFxuICAgIHNjaGVtYVR5cGU6IFtcIm9iamVjdFwiLCBcImJvb2xlYW5cIl0sXG4gICAgdHJhY2tFcnJvcnM6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHBhcmVudFNjaGVtYSwgaXQgfSA9IGN4dDtcbiAgICAgICAgaWYgKHBhcmVudFNjaGVtYS50aGVuID09PSB1bmRlZmluZWQgJiYgcGFyZW50U2NoZW1hLmVsc2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgKDAsIHV0aWxfMS5jaGVja1N0cmljdE1vZGUpKGl0LCAnXCJpZlwiIHdpdGhvdXQgXCJ0aGVuXCIgYW5kIFwiZWxzZVwiIGlzIGlnbm9yZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoYXNUaGVuID0gaGFzU2NoZW1hKGl0LCBcInRoZW5cIik7XG4gICAgICAgIGNvbnN0IGhhc0Vsc2UgPSBoYXNTY2hlbWEoaXQsIFwiZWxzZVwiKTtcbiAgICAgICAgaWYgKCFoYXNUaGVuICYmICFoYXNFbHNlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiLCB0cnVlKTtcbiAgICAgICAgY29uc3Qgc2NoVmFsaWQgPSBnZW4ubmFtZShcIl92YWxpZFwiKTtcbiAgICAgICAgdmFsaWRhdGVJZigpO1xuICAgICAgICBjeHQucmVzZXQoKTtcbiAgICAgICAgaWYgKGhhc1RoZW4gJiYgaGFzRWxzZSkge1xuICAgICAgICAgICAgY29uc3QgaWZDbGF1c2UgPSBnZW4ubGV0KFwiaWZDbGF1c2VcIik7XG4gICAgICAgICAgICBjeHQuc2V0UGFyYW1zKHsgaWZDbGF1c2UgfSk7XG4gICAgICAgICAgICBnZW4uaWYoc2NoVmFsaWQsIHZhbGlkYXRlQ2xhdXNlKFwidGhlblwiLCBpZkNsYXVzZSksIHZhbGlkYXRlQ2xhdXNlKFwiZWxzZVwiLCBpZkNsYXVzZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhhc1RoZW4pIHtcbiAgICAgICAgICAgIGdlbi5pZihzY2hWYWxpZCwgdmFsaWRhdGVDbGF1c2UoXCJ0aGVuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLm5vdCkoc2NoVmFsaWQpLCB2YWxpZGF0ZUNsYXVzZShcImVsc2VcIikpO1xuICAgICAgICB9XG4gICAgICAgIGN4dC5wYXNzKHZhbGlkLCAoKSA9PiBjeHQuZXJyb3IodHJ1ZSkpO1xuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZUlmKCkge1xuICAgICAgICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICAgICAga2V5d29yZDogXCJpZlwiLFxuICAgICAgICAgICAgICAgIGNvbXBvc2l0ZVJ1bGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY3JlYXRlRXJyb3JzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBhbGxFcnJvcnM6IGZhbHNlLFxuICAgICAgICAgICAgfSwgc2NoVmFsaWQpO1xuICAgICAgICAgICAgY3h0Lm1lcmdlRXZhbHVhdGVkKHNjaEN4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVDbGF1c2Uoa2V5d29yZCwgaWZDbGF1c2UpIHtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7IGtleXdvcmQgfSwgc2NoVmFsaWQpO1xuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIHNjaFZhbGlkKTtcbiAgICAgICAgICAgICAgICBjeHQubWVyZ2VWYWxpZEV2YWx1YXRlZChzY2hDeHQsIHZhbGlkKTtcbiAgICAgICAgICAgICAgICBpZiAoaWZDbGF1c2UpXG4gICAgICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24oaWZDbGF1c2UsICgwLCBjb2RlZ2VuXzEuXykgYCR7a2V5d29yZH1gKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGN4dC5zZXRQYXJhbXMoeyBpZkNsYXVzZToga2V5d29yZCB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmZ1bmN0aW9uIGhhc1NjaGVtYShpdCwga2V5d29yZCkge1xuICAgIGNvbnN0IHNjaGVtYSA9IGl0LnNjaGVtYVtrZXl3b3JkXTtcbiAgICByZXR1cm4gc2NoZW1hICE9PSB1bmRlZmluZWQgJiYgISgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2hlbWEpO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aWYuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFtcInRoZW5cIiwgXCJlbHNlXCJdLFxuICAgIHNjaGVtYVR5cGU6IFtcIm9iamVjdFwiLCBcImJvb2xlYW5cIl0sXG4gICAgY29kZSh7IGtleXdvcmQsIHBhcmVudFNjaGVtYSwgaXQgfSkge1xuICAgICAgICBpZiAocGFyZW50U2NoZW1hLmlmID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAoMCwgdXRpbF8xLmNoZWNrU3RyaWN0TW9kZSkoaXQsIGBcIiR7a2V5d29yZH1cIiB3aXRob3V0IFwiaWZcIiBpcyBpZ25vcmVkYCk7XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aGVuRWxzZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGFkZGl0aW9uYWxJdGVtc18xID0gcmVxdWlyZShcIi4vYWRkaXRpb25hbEl0ZW1zXCIpO1xuY29uc3QgcHJlZml4SXRlbXNfMSA9IHJlcXVpcmUoXCIuL3ByZWZpeEl0ZW1zXCIpO1xuY29uc3QgaXRlbXNfMSA9IHJlcXVpcmUoXCIuL2l0ZW1zXCIpO1xuY29uc3QgaXRlbXMyMDIwXzEgPSByZXF1aXJlKFwiLi9pdGVtczIwMjBcIik7XG5jb25zdCBjb250YWluc18xID0gcmVxdWlyZShcIi4vY29udGFpbnNcIik7XG5jb25zdCBkZXBlbmRlbmNpZXNfMSA9IHJlcXVpcmUoXCIuL2RlcGVuZGVuY2llc1wiKTtcbmNvbnN0IHByb3BlcnR5TmFtZXNfMSA9IHJlcXVpcmUoXCIuL3Byb3BlcnR5TmFtZXNcIik7XG5jb25zdCBhZGRpdGlvbmFsUHJvcGVydGllc18xID0gcmVxdWlyZShcIi4vYWRkaXRpb25hbFByb3BlcnRpZXNcIik7XG5jb25zdCBwcm9wZXJ0aWVzXzEgPSByZXF1aXJlKFwiLi9wcm9wZXJ0aWVzXCIpO1xuY29uc3QgcGF0dGVyblByb3BlcnRpZXNfMSA9IHJlcXVpcmUoXCIuL3BhdHRlcm5Qcm9wZXJ0aWVzXCIpO1xuY29uc3Qgbm90XzEgPSByZXF1aXJlKFwiLi9ub3RcIik7XG5jb25zdCBhbnlPZl8xID0gcmVxdWlyZShcIi4vYW55T2ZcIik7XG5jb25zdCBvbmVPZl8xID0gcmVxdWlyZShcIi4vb25lT2ZcIik7XG5jb25zdCBhbGxPZl8xID0gcmVxdWlyZShcIi4vYWxsT2ZcIik7XG5jb25zdCBpZl8xID0gcmVxdWlyZShcIi4vaWZcIik7XG5jb25zdCB0aGVuRWxzZV8xID0gcmVxdWlyZShcIi4vdGhlbkVsc2VcIik7XG5mdW5jdGlvbiBnZXRBcHBsaWNhdG9yKGRyYWZ0MjAyMCA9IGZhbHNlKSB7XG4gICAgY29uc3QgYXBwbGljYXRvciA9IFtcbiAgICAgICAgLy8gYW55XG4gICAgICAgIG5vdF8xLmRlZmF1bHQsXG4gICAgICAgIGFueU9mXzEuZGVmYXVsdCxcbiAgICAgICAgb25lT2ZfMS5kZWZhdWx0LFxuICAgICAgICBhbGxPZl8xLmRlZmF1bHQsXG4gICAgICAgIGlmXzEuZGVmYXVsdCxcbiAgICAgICAgdGhlbkVsc2VfMS5kZWZhdWx0LFxuICAgICAgICAvLyBvYmplY3RcbiAgICAgICAgcHJvcGVydHlOYW1lc18xLmRlZmF1bHQsXG4gICAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzXzEuZGVmYXVsdCxcbiAgICAgICAgZGVwZW5kZW5jaWVzXzEuZGVmYXVsdCxcbiAgICAgICAgcHJvcGVydGllc18xLmRlZmF1bHQsXG4gICAgICAgIHBhdHRlcm5Qcm9wZXJ0aWVzXzEuZGVmYXVsdCxcbiAgICBdO1xuICAgIC8vIGFycmF5XG4gICAgaWYgKGRyYWZ0MjAyMClcbiAgICAgICAgYXBwbGljYXRvci5wdXNoKHByZWZpeEl0ZW1zXzEuZGVmYXVsdCwgaXRlbXMyMDIwXzEuZGVmYXVsdCk7XG4gICAgZWxzZVxuICAgICAgICBhcHBsaWNhdG9yLnB1c2goYWRkaXRpb25hbEl0ZW1zXzEuZGVmYXVsdCwgaXRlbXNfMS5kZWZhdWx0KTtcbiAgICBhcHBsaWNhdG9yLnB1c2goY29udGFpbnNfMS5kZWZhdWx0KTtcbiAgICByZXR1cm4gYXBwbGljYXRvcjtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGdldEFwcGxpY2F0b3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBzY2hlbWFDb2RlIH0pID0+ICgwLCBjb2RlZ2VuXzEuc3RyKSBgbXVzdCBtYXRjaCBmb3JtYXQgXCIke3NjaGVtYUNvZGV9XCJgLFxuICAgIHBhcmFtczogKHsgc2NoZW1hQ29kZSB9KSA9PiAoMCwgY29kZWdlbl8xLl8pIGB7Zm9ybWF0OiAke3NjaGVtYUNvZGV9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiZm9ybWF0XCIsXG4gICAgdHlwZTogW1wibnVtYmVyXCIsIFwic3RyaW5nXCJdLFxuICAgIHNjaGVtYVR5cGU6IFwic3RyaW5nXCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQsIHJ1bGVUeXBlKSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCAkZGF0YSwgc2NoZW1hLCBzY2hlbWFDb2RlLCBpdCB9ID0gY3h0O1xuICAgICAgICBjb25zdCB7IG9wdHMsIGVyclNjaGVtYVBhdGgsIHNjaGVtYUVudiwgc2VsZiB9ID0gaXQ7XG4gICAgICAgIGlmICghb3B0cy52YWxpZGF0ZUZvcm1hdHMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICgkZGF0YSlcbiAgICAgICAgICAgIHZhbGlkYXRlJERhdGFGb3JtYXQoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdmFsaWRhdGVGb3JtYXQoKTtcbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGUkRGF0YUZvcm1hdCgpIHtcbiAgICAgICAgICAgIGNvbnN0IGZtdHMgPSBnZW4uc2NvcGVWYWx1ZShcImZvcm1hdHNcIiwge1xuICAgICAgICAgICAgICAgIHJlZjogc2VsZi5mb3JtYXRzLFxuICAgICAgICAgICAgICAgIGNvZGU6IG9wdHMuY29kZS5mb3JtYXRzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBmRGVmID0gZ2VuLmNvbnN0KFwiZkRlZlwiLCAoMCwgY29kZWdlbl8xLl8pIGAke2ZtdHN9WyR7c2NoZW1hQ29kZX1dYCk7XG4gICAgICAgICAgICBjb25zdCBmVHlwZSA9IGdlbi5sZXQoXCJmVHlwZVwiKTtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdCA9IGdlbi5sZXQoXCJmb3JtYXRcIik7XG4gICAgICAgICAgICAvLyBUT0RPIHNpbXBsaWZ5XG4gICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgdHlwZW9mICR7ZkRlZn0gPT0gXCJvYmplY3RcIiAmJiAhKCR7ZkRlZn0gaW5zdGFuY2VvZiBSZWdFeHApYCwgKCkgPT4gZ2VuLmFzc2lnbihmVHlwZSwgKDAsIGNvZGVnZW5fMS5fKSBgJHtmRGVmfS50eXBlIHx8IFwic3RyaW5nXCJgKS5hc3NpZ24oZm9ybWF0LCAoMCwgY29kZWdlbl8xLl8pIGAke2ZEZWZ9LnZhbGlkYXRlYCksICgpID0+IGdlbi5hc3NpZ24oZlR5cGUsICgwLCBjb2RlZ2VuXzEuXykgYFwic3RyaW5nXCJgKS5hc3NpZ24oZm9ybWF0LCBmRGVmKSk7XG4gICAgICAgICAgICBjeHQuZmFpbCRkYXRhKCgwLCBjb2RlZ2VuXzEub3IpKHVua25vd25GbXQoKSwgaW52YWxpZEZtdCgpKSk7XG4gICAgICAgICAgICBmdW5jdGlvbiB1bmtub3duRm10KCkge1xuICAgICAgICAgICAgICAgIGlmIChvcHRzLnN0cmljdFNjaGVtYSA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2RlZ2VuXzEubmlsO1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLl8pIGAke3NjaGVtYUNvZGV9ICYmICEke2Zvcm1hdH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gaW52YWxpZEZtdCgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYWxsRm9ybWF0ID0gc2NoZW1hRW52LiRhc3luY1xuICAgICAgICAgICAgICAgICAgICA/ICgwLCBjb2RlZ2VuXzEuXykgYCgke2ZEZWZ9LmFzeW5jID8gYXdhaXQgJHtmb3JtYXR9KCR7ZGF0YX0pIDogJHtmb3JtYXR9KCR7ZGF0YX0pKWBcbiAgICAgICAgICAgICAgICAgICAgOiAoMCwgY29kZWdlbl8xLl8pIGAke2Zvcm1hdH0oJHtkYXRhfSlgO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkRGF0YSA9ICgwLCBjb2RlZ2VuXzEuXykgYCh0eXBlb2YgJHtmb3JtYXR9ID09IFwiZnVuY3Rpb25cIiA/ICR7Y2FsbEZvcm1hdH0gOiAke2Zvcm1hdH0udGVzdCgke2RhdGF9KSlgO1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLl8pIGAke2Zvcm1hdH0gJiYgJHtmb3JtYXR9ICE9PSB0cnVlICYmICR7ZlR5cGV9ID09PSAke3J1bGVUeXBlfSAmJiAhJHt2YWxpZERhdGF9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdCgpIHtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdERlZiA9IHNlbGYuZm9ybWF0c1tzY2hlbWFdO1xuICAgICAgICAgICAgaWYgKCFmb3JtYXREZWYpIHtcbiAgICAgICAgICAgICAgICB1bmtub3duRm9ybWF0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvcm1hdERlZiA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBbZm10VHlwZSwgZm9ybWF0LCBmbXRSZWZdID0gZ2V0Rm9ybWF0KGZvcm1hdERlZik7XG4gICAgICAgICAgICBpZiAoZm10VHlwZSA9PT0gcnVsZVR5cGUpXG4gICAgICAgICAgICAgICAgY3h0LnBhc3ModmFsaWRDb25kaXRpb24oKSk7XG4gICAgICAgICAgICBmdW5jdGlvbiB1bmtub3duRm9ybWF0KCkge1xuICAgICAgICAgICAgICAgIGlmIChvcHRzLnN0cmljdFNjaGVtYSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5sb2dnZXIud2Fybih1bmtub3duTXNnKCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih1bmtub3duTXNnKCkpO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHVua25vd25Nc2coKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgdW5rbm93biBmb3JtYXQgXCIke3NjaGVtYX1cIiBpZ25vcmVkIGluIHNjaGVtYSBhdCBwYXRoIFwiJHtlcnJTY2hlbWFQYXRofVwiYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRGb3JtYXQoZm10RGVmKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IGZtdERlZiBpbnN0YW5jZW9mIFJlZ0V4cFxuICAgICAgICAgICAgICAgICAgICA/ICgwLCBjb2RlZ2VuXzEucmVnZXhwQ29kZSkoZm10RGVmKVxuICAgICAgICAgICAgICAgICAgICA6IG9wdHMuY29kZS5mb3JtYXRzXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICgwLCBjb2RlZ2VuXzEuXykgYCR7b3B0cy5jb2RlLmZvcm1hdHN9JHsoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KShzY2hlbWEpfWBcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZtdCA9IGdlbi5zY29wZVZhbHVlKFwiZm9ybWF0c1wiLCB7IGtleTogc2NoZW1hLCByZWY6IGZtdERlZiwgY29kZSB9KTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZtdERlZiA9PSBcIm9iamVjdFwiICYmICEoZm10RGVmIGluc3RhbmNlb2YgUmVnRXhwKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2ZtdERlZi50eXBlIHx8IFwic3RyaW5nXCIsIGZtdERlZi52YWxpZGF0ZSwgKDAsIGNvZGVnZW5fMS5fKSBgJHtmbXR9LnZhbGlkYXRlYF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbXCJzdHJpbmdcIiwgZm10RGVmLCBmbXRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gdmFsaWRDb25kaXRpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXREZWYgPT0gXCJvYmplY3RcIiAmJiAhKGZvcm1hdERlZiBpbnN0YW5jZW9mIFJlZ0V4cCkgJiYgZm9ybWF0RGVmLmFzeW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2NoZW1hRW52LiRhc3luYylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFzeW5jIGZvcm1hdCBpbiBzeW5jIHNjaGVtYVwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuXykgYGF3YWl0ICR7Zm10UmVmfSgke2RhdGF9KWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgZm9ybWF0ID09IFwiZnVuY3Rpb25cIiA/ICgwLCBjb2RlZ2VuXzEuXykgYCR7Zm10UmVmfSgke2RhdGF9KWAgOiAoMCwgY29kZWdlbl8xLl8pIGAke2ZtdFJlZn0udGVzdCgke2RhdGF9KWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvcm1hdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGZvcm1hdF8xID0gcmVxdWlyZShcIi4vZm9ybWF0XCIpO1xuY29uc3QgZm9ybWF0ID0gW2Zvcm1hdF8xLmRlZmF1bHRdO1xuZXhwb3J0cy5kZWZhdWx0ID0gZm9ybWF0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNvbnRlbnRWb2NhYnVsYXJ5ID0gZXhwb3J0cy5tZXRhZGF0YVZvY2FidWxhcnkgPSB2b2lkIDA7XG5leHBvcnRzLm1ldGFkYXRhVm9jYWJ1bGFyeSA9IFtcbiAgICBcInRpdGxlXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiLFxuICAgIFwiZGVmYXVsdFwiLFxuICAgIFwiZGVwcmVjYXRlZFwiLFxuICAgIFwicmVhZE9ubHlcIixcbiAgICBcIndyaXRlT25seVwiLFxuICAgIFwiZXhhbXBsZXNcIixcbl07XG5leHBvcnRzLmNvbnRlbnRWb2NhYnVsYXJ5ID0gW1xuICAgIFwiY29udGVudE1lZGlhVHlwZVwiLFxuICAgIFwiY29udGVudEVuY29kaW5nXCIsXG4gICAgXCJjb250ZW50U2NoZW1hXCIsXG5dO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWV0YWRhdGEuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb3JlXzEgPSByZXF1aXJlKFwiLi9jb3JlXCIpO1xuY29uc3QgdmFsaWRhdGlvbl8xID0gcmVxdWlyZShcIi4vdmFsaWRhdGlvblwiKTtcbmNvbnN0IGFwcGxpY2F0b3JfMSA9IHJlcXVpcmUoXCIuL2FwcGxpY2F0b3JcIik7XG5jb25zdCBmb3JtYXRfMSA9IHJlcXVpcmUoXCIuL2Zvcm1hdFwiKTtcbmNvbnN0IG1ldGFkYXRhXzEgPSByZXF1aXJlKFwiLi9tZXRhZGF0YVwiKTtcbmNvbnN0IGRyYWZ0N1ZvY2FidWxhcmllcyA9IFtcbiAgICBjb3JlXzEuZGVmYXVsdCxcbiAgICB2YWxpZGF0aW9uXzEuZGVmYXVsdCxcbiAgICAoMCwgYXBwbGljYXRvcl8xLmRlZmF1bHQpKCksXG4gICAgZm9ybWF0XzEuZGVmYXVsdCxcbiAgICBtZXRhZGF0YV8xLm1ldGFkYXRhVm9jYWJ1bGFyeSxcbiAgICBtZXRhZGF0YV8xLmNvbnRlbnRWb2NhYnVsYXJ5LFxuXTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRyYWZ0N1ZvY2FidWxhcmllcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRyYWZ0Ny5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRGlzY3JFcnJvciA9IHZvaWQgMDtcbnZhciBEaXNjckVycm9yO1xuKGZ1bmN0aW9uIChEaXNjckVycm9yKSB7XG4gICAgRGlzY3JFcnJvcltcIlRhZ1wiXSA9IFwidGFnXCI7XG4gICAgRGlzY3JFcnJvcltcIk1hcHBpbmdcIl0gPSBcIm1hcHBpbmdcIjtcbn0pKERpc2NyRXJyb3IgfHwgKGV4cG9ydHMuRGlzY3JFcnJvciA9IERpc2NyRXJyb3IgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCIuLi9kaXNjcmltaW5hdG9yL3R5cGVzXCIpO1xuY29uc3QgY29tcGlsZV8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGVcIik7XG5jb25zdCByZWZfZXJyb3JfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3JlZl9lcnJvclwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBwYXJhbXM6IHsgZGlzY3JFcnJvciwgdGFnTmFtZSB9IH0pID0+IGRpc2NyRXJyb3IgPT09IHR5cGVzXzEuRGlzY3JFcnJvci5UYWdcbiAgICAgICAgPyBgdGFnIFwiJHt0YWdOYW1lfVwiIG11c3QgYmUgc3RyaW5nYFxuICAgICAgICA6IGB2YWx1ZSBvZiB0YWcgXCIke3RhZ05hbWV9XCIgbXVzdCBiZSBpbiBvbmVPZmAsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXM6IHsgZGlzY3JFcnJvciwgdGFnLCB0YWdOYW1lIH0gfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge2Vycm9yOiAke2Rpc2NyRXJyb3J9LCB0YWc6ICR7dGFnTmFtZX0sIHRhZ1ZhbHVlOiAke3RhZ319YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJkaXNjcmltaW5hdG9yXCIsXG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICBzY2hlbWFUeXBlOiBcIm9iamVjdFwiLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgaXQgfSA9IGN4dDtcbiAgICAgICAgY29uc3QgeyBvbmVPZiB9ID0gcGFyZW50U2NoZW1hO1xuICAgICAgICBpZiAoIWl0Lm9wdHMuZGlzY3JpbWluYXRvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGlzY3JpbWluYXRvcjogcmVxdWlyZXMgZGlzY3JpbWluYXRvciBvcHRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFnTmFtZSA9IHNjaGVtYS5wcm9wZXJ0eU5hbWU7XG4gICAgICAgIGlmICh0eXBlb2YgdGFnTmFtZSAhPSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGlzY3JpbWluYXRvcjogcmVxdWlyZXMgcHJvcGVydHlOYW1lXCIpO1xuICAgICAgICBpZiAoc2NoZW1hLm1hcHBpbmcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkaXNjcmltaW5hdG9yOiBtYXBwaW5nIGlzIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgICAgIGlmICghb25lT2YpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkaXNjcmltaW5hdG9yOiByZXF1aXJlcyBvbmVPZiBrZXl3b3JkXCIpO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiLCBmYWxzZSk7XG4gICAgICAgIGNvbnN0IHRhZyA9IGdlbi5jb25zdChcInRhZ1wiLCAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9JHsoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KSh0YWdOYW1lKX1gKTtcbiAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYHR5cGVvZiAke3RhZ30gPT0gXCJzdHJpbmdcImAsICgpID0+IHZhbGlkYXRlTWFwcGluZygpLCAoKSA9PiBjeHQuZXJyb3IoZmFsc2UsIHsgZGlzY3JFcnJvcjogdHlwZXNfMS5EaXNjckVycm9yLlRhZywgdGFnLCB0YWdOYW1lIH0pKTtcbiAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVNYXBwaW5nKCkge1xuICAgICAgICAgICAgY29uc3QgbWFwcGluZyA9IGdldE1hcHBpbmcoKTtcbiAgICAgICAgICAgIGdlbi5pZihmYWxzZSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRhZ1ZhbHVlIGluIG1hcHBpbmcpIHtcbiAgICAgICAgICAgICAgICBnZW4uZWxzZUlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7dGFnfSA9PT0gJHt0YWdWYWx1ZX1gKTtcbiAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCBhcHBseVRhZ1NjaGVtYShtYXBwaW5nW3RhZ1ZhbHVlXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2VuLmVsc2UoKTtcbiAgICAgICAgICAgIGN4dC5lcnJvcihmYWxzZSwgeyBkaXNjckVycm9yOiB0eXBlc18xLkRpc2NyRXJyb3IuTWFwcGluZywgdGFnLCB0YWdOYW1lIH0pO1xuICAgICAgICAgICAgZ2VuLmVuZElmKCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYXBwbHlUYWdTY2hlbWEoc2NoZW1hUHJvcCkge1xuICAgICAgICAgICAgY29uc3QgX3ZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICAgICAgICAgIGNvbnN0IHNjaEN4dCA9IGN4dC5zdWJzY2hlbWEoeyBrZXl3b3JkOiBcIm9uZU9mXCIsIHNjaGVtYVByb3AgfSwgX3ZhbGlkKTtcbiAgICAgICAgICAgIGN4dC5tZXJnZUV2YWx1YXRlZChzY2hDeHQsIGNvZGVnZW5fMS5OYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBfdmFsaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0TWFwcGluZygpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IG9uZU9mTWFwcGluZyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgdG9wUmVxdWlyZWQgPSBoYXNSZXF1aXJlZChwYXJlbnRTY2hlbWEpO1xuICAgICAgICAgICAgbGV0IHRhZ1JlcXVpcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb25lT2YubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgc2NoID0gb25lT2ZbaV07XG4gICAgICAgICAgICAgICAgaWYgKChzY2ggPT09IG51bGwgfHwgc2NoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY2guJHJlZikgJiYgISgwLCB1dGlsXzEuc2NoZW1hSGFzUnVsZXNCdXRSZWYpKHNjaCwgaXQuc2VsZi5SVUxFUykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVmID0gc2NoLiRyZWY7XG4gICAgICAgICAgICAgICAgICAgIHNjaCA9IGNvbXBpbGVfMS5yZXNvbHZlUmVmLmNhbGwoaXQuc2VsZiwgaXQuc2NoZW1hRW52LnJvb3QsIGl0LmJhc2VJZCwgcmVmKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjaCBpbnN0YW5jZW9mIGNvbXBpbGVfMS5TY2hlbWFFbnYpXG4gICAgICAgICAgICAgICAgICAgICAgICBzY2ggPSBzY2guc2NoZW1hO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2NoID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgcmVmX2Vycm9yXzEuZGVmYXVsdChpdC5vcHRzLnVyaVJlc29sdmVyLCBpdC5iYXNlSWQsIHJlZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BTY2ggPSAoX2EgPSBzY2ggPT09IG51bGwgfHwgc2NoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY2gucHJvcGVydGllcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW3RhZ05hbWVdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcFNjaCAhPSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZGlzY3JpbWluYXRvcjogb25lT2Ygc3Vic2NoZW1hcyAob3IgcmVmZXJlbmNlZCBzY2hlbWFzKSBtdXN0IGhhdmUgXCJwcm9wZXJ0aWVzLyR7dGFnTmFtZX1cImApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0YWdSZXF1aXJlZCA9IHRhZ1JlcXVpcmVkICYmICh0b3BSZXF1aXJlZCB8fCBoYXNSZXF1aXJlZChzY2gpKTtcbiAgICAgICAgICAgICAgICBhZGRNYXBwaW5ncyhwcm9wU2NoLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGFnUmVxdWlyZWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkaXNjcmltaW5hdG9yOiBcIiR7dGFnTmFtZX1cIiBtdXN0IGJlIHJlcXVpcmVkYCk7XG4gICAgICAgICAgICByZXR1cm4gb25lT2ZNYXBwaW5nO1xuICAgICAgICAgICAgZnVuY3Rpb24gaGFzUmVxdWlyZWQoeyByZXF1aXJlZCB9KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkocmVxdWlyZWQpICYmIHJlcXVpcmVkLmluY2x1ZGVzKHRhZ05hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gYWRkTWFwcGluZ3Moc2NoLCBpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNjaC5jb25zdCkge1xuICAgICAgICAgICAgICAgICAgICBhZGRNYXBwaW5nKHNjaC5jb25zdCwgaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNjaC5lbnVtKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdGFnVmFsdWUgb2Ygc2NoLmVudW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZE1hcHBpbmcodGFnVmFsdWUsIGkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRpc2NyaW1pbmF0b3I6IFwicHJvcGVydGllcy8ke3RhZ05hbWV9XCIgbXVzdCBoYXZlIFwiY29uc3RcIiBvciBcImVudW1cImApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGFkZE1hcHBpbmcodGFnVmFsdWUsIGkpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRhZ1ZhbHVlICE9IFwic3RyaW5nXCIgfHwgdGFnVmFsdWUgaW4gb25lT2ZNYXBwaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZGlzY3JpbWluYXRvcjogXCIke3RhZ05hbWV9XCIgdmFsdWVzIG11c3QgYmUgdW5pcXVlIHN0cmluZ3NgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb25lT2ZNYXBwaW5nW3RhZ1ZhbHVlXSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIntcbiAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNy9zY2hlbWEjXCIsXG4gIFwiJGlkXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNy9zY2hlbWEjXCIsXG4gIFwidGl0bGVcIjogXCJDb3JlIHNjaGVtYSBtZXRhLXNjaGVtYVwiLFxuICBcImRlZmluaXRpb25zXCI6IHtcbiAgICBcInNjaGVtYUFycmF5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcIm1pbkl0ZW1zXCI6IDEsXG4gICAgICBcIml0ZW1zXCI6IHtcIiRyZWZcIjogXCIjXCJ9XG4gICAgfSxcbiAgICBcIm5vbk5lZ2F0aXZlSW50ZWdlclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCIsXG4gICAgICBcIm1pbmltdW1cIjogMFxuICAgIH0sXG4gICAgXCJub25OZWdhdGl2ZUludGVnZXJEZWZhdWx0MFwiOiB7XG4gICAgICBcImFsbE9mXCI6IFt7XCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9ub25OZWdhdGl2ZUludGVnZXJcIn0sIHtcImRlZmF1bHRcIjogMH1dXG4gICAgfSxcbiAgICBcInNpbXBsZVR5cGVzXCI6IHtcbiAgICAgIFwiZW51bVwiOiBbXCJhcnJheVwiLCBcImJvb2xlYW5cIiwgXCJpbnRlZ2VyXCIsIFwibnVsbFwiLCBcIm51bWJlclwiLCBcIm9iamVjdFwiLCBcInN0cmluZ1wiXVxuICAgIH0sXG4gICAgXCJzdHJpbmdBcnJheVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgXCJpdGVtc1wiOiB7XCJ0eXBlXCI6IFwic3RyaW5nXCJ9LFxuICAgICAgXCJ1bmlxdWVJdGVtc1wiOiB0cnVlLFxuICAgICAgXCJkZWZhdWx0XCI6IFtdXG4gICAgfVxuICB9LFxuICBcInR5cGVcIjogW1wib2JqZWN0XCIsIFwiYm9vbGVhblwiXSxcbiAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICBcIiRpZFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZm9ybWF0XCI6IFwidXJpLXJlZmVyZW5jZVwiXG4gICAgfSxcbiAgICBcIiRzY2hlbWFcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImZvcm1hdFwiOiBcInVyaVwiXG4gICAgfSxcbiAgICBcIiRyZWZcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImZvcm1hdFwiOiBcInVyaS1yZWZlcmVuY2VcIlxuICAgIH0sXG4gICAgXCIkY29tbWVudFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgIH0sXG4gICAgXCJ0aXRsZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgIH0sXG4gICAgXCJkZXNjcmlwdGlvblwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgIH0sXG4gICAgXCJkZWZhdWx0XCI6IHRydWUsXG4gICAgXCJyZWFkT25seVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICBcImRlZmF1bHRcIjogZmFsc2VcbiAgICB9LFxuICAgIFwiZXhhbXBsZXNcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwiaXRlbXNcIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJtdWx0aXBsZU9mXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJleGNsdXNpdmVNaW5pbXVtXCI6IDBcbiAgICB9LFxuICAgIFwibWF4aW11bVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIlxuICAgIH0sXG4gICAgXCJleGNsdXNpdmVNYXhpbXVtXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiXG4gICAgfSxcbiAgICBcIm1pbmltdW1cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCJcbiAgICB9LFxuICAgIFwiZXhjbHVzaXZlTWluaW11bVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIlxuICAgIH0sXG4gICAgXCJtYXhMZW5ndGhcIjoge1wiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvbm9uTmVnYXRpdmVJbnRlZ2VyXCJ9LFxuICAgIFwibWluTGVuZ3RoXCI6IHtcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL25vbk5lZ2F0aXZlSW50ZWdlckRlZmF1bHQwXCJ9LFxuICAgIFwicGF0dGVyblwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZm9ybWF0XCI6IFwicmVnZXhcIlxuICAgIH0sXG4gICAgXCJhZGRpdGlvbmFsSXRlbXNcIjoge1wiJHJlZlwiOiBcIiNcIn0sXG4gICAgXCJpdGVtc1wiOiB7XG4gICAgICBcImFueU9mXCI6IFt7XCIkcmVmXCI6IFwiI1wifSwge1wiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvc2NoZW1hQXJyYXlcIn1dLFxuICAgICAgXCJkZWZhdWx0XCI6IHRydWVcbiAgICB9LFxuICAgIFwibWF4SXRlbXNcIjoge1wiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvbm9uTmVnYXRpdmVJbnRlZ2VyXCJ9LFxuICAgIFwibWluSXRlbXNcIjoge1wiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvbm9uTmVnYXRpdmVJbnRlZ2VyRGVmYXVsdDBcIn0sXG4gICAgXCJ1bmlxdWVJdGVtc1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICBcImRlZmF1bHRcIjogZmFsc2VcbiAgICB9LFxuICAgIFwiY29udGFpbnNcIjoge1wiJHJlZlwiOiBcIiNcIn0sXG4gICAgXCJtYXhQcm9wZXJ0aWVzXCI6IHtcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL25vbk5lZ2F0aXZlSW50ZWdlclwifSxcbiAgICBcIm1pblByb3BlcnRpZXNcIjoge1wiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvbm9uTmVnYXRpdmVJbnRlZ2VyRGVmYXVsdDBcIn0sXG4gICAgXCJyZXF1aXJlZFwiOiB7XCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9zdHJpbmdBcnJheVwifSxcbiAgICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IHtcIiRyZWZcIjogXCIjXCJ9LFxuICAgIFwiZGVmaW5pdGlvbnNcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gICAgICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IHtcIiRyZWZcIjogXCIjXCJ9LFxuICAgICAgXCJkZWZhdWx0XCI6IHt9XG4gICAgfSxcbiAgICBcInByb3BlcnRpZXNcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gICAgICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IHtcIiRyZWZcIjogXCIjXCJ9LFxuICAgICAgXCJkZWZhdWx0XCI6IHt9XG4gICAgfSxcbiAgICBcInBhdHRlcm5Qcm9wZXJ0aWVzXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICAgICAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiB7XCIkcmVmXCI6IFwiI1wifSxcbiAgICAgIFwicHJvcGVydHlOYW1lc1wiOiB7XCJmb3JtYXRcIjogXCJyZWdleFwifSxcbiAgICAgIFwiZGVmYXVsdFwiOiB7fVxuICAgIH0sXG4gICAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gICAgICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IHtcbiAgICAgICAgXCJhbnlPZlwiOiBbe1wiJHJlZlwiOiBcIiNcIn0sIHtcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL3N0cmluZ0FycmF5XCJ9XVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eU5hbWVzXCI6IHtcIiRyZWZcIjogXCIjXCJ9LFxuICAgIFwiY29uc3RcIjogdHJ1ZSxcbiAgICBcImVudW1cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwiaXRlbXNcIjogdHJ1ZSxcbiAgICAgIFwibWluSXRlbXNcIjogMSxcbiAgICAgIFwidW5pcXVlSXRlbXNcIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJ0eXBlXCI6IHtcbiAgICAgIFwiYW55T2ZcIjogW1xuICAgICAgICB7XCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9zaW1wbGVUeXBlc1wifSxcbiAgICAgICAge1xuICAgICAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICAgICAgXCJpdGVtc1wiOiB7XCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9zaW1wbGVUeXBlc1wifSxcbiAgICAgICAgICBcIm1pbkl0ZW1zXCI6IDEsXG4gICAgICAgICAgXCJ1bmlxdWVJdGVtc1wiOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9LFxuICAgIFwiZm9ybWF0XCI6IHtcInR5cGVcIjogXCJzdHJpbmdcIn0sXG4gICAgXCJjb250ZW50TWVkaWFUeXBlXCI6IHtcInR5cGVcIjogXCJzdHJpbmdcIn0sXG4gICAgXCJjb250ZW50RW5jb2RpbmdcIjoge1widHlwZVwiOiBcInN0cmluZ1wifSxcbiAgICBcImlmXCI6IHtcIiRyZWZcIjogXCIjXCJ9LFxuICAgIFwidGhlblwiOiB7XCIkcmVmXCI6IFwiI1wifSxcbiAgICBcImVsc2VcIjoge1wiJHJlZlwiOiBcIiNcIn0sXG4gICAgXCJhbGxPZlwiOiB7XCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9zY2hlbWFBcnJheVwifSxcbiAgICBcImFueU9mXCI6IHtcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL3NjaGVtYUFycmF5XCJ9LFxuICAgIFwib25lT2ZcIjoge1wiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvc2NoZW1hQXJyYXlcIn0sXG4gICAgXCJub3RcIjoge1wiJHJlZlwiOiBcIiNcIn1cbiAgfSxcbiAgXCJkZWZhdWx0XCI6IHRydWVcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NaXNzaW5nUmVmRXJyb3IgPSBleHBvcnRzLlZhbGlkYXRpb25FcnJvciA9IGV4cG9ydHMuQ29kZUdlbiA9IGV4cG9ydHMuTmFtZSA9IGV4cG9ydHMubmlsID0gZXhwb3J0cy5zdHJpbmdpZnkgPSBleHBvcnRzLnN0ciA9IGV4cG9ydHMuXyA9IGV4cG9ydHMuS2V5d29yZEN4dCA9IGV4cG9ydHMuQWp2ID0gdm9pZCAwO1xuY29uc3QgY29yZV8xID0gcmVxdWlyZShcIi4vY29yZVwiKTtcbmNvbnN0IGRyYWZ0N18xID0gcmVxdWlyZShcIi4vdm9jYWJ1bGFyaWVzL2RyYWZ0N1wiKTtcbmNvbnN0IGRpc2NyaW1pbmF0b3JfMSA9IHJlcXVpcmUoXCIuL3ZvY2FidWxhcmllcy9kaXNjcmltaW5hdG9yXCIpO1xuY29uc3QgZHJhZnQ3TWV0YVNjaGVtYSA9IHJlcXVpcmUoXCIuL3JlZnMvanNvbi1zY2hlbWEtZHJhZnQtMDcuanNvblwiKTtcbmNvbnN0IE1FVEFfU1VQUE9SVF9EQVRBID0gW1wiL3Byb3BlcnRpZXNcIl07XG5jb25zdCBNRVRBX1NDSEVNQV9JRCA9IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNy9zY2hlbWFcIjtcbmNsYXNzIEFqdiBleHRlbmRzIGNvcmVfMS5kZWZhdWx0IHtcbiAgICBfYWRkVm9jYWJ1bGFyaWVzKCkge1xuICAgICAgICBzdXBlci5fYWRkVm9jYWJ1bGFyaWVzKCk7XG4gICAgICAgIGRyYWZ0N18xLmRlZmF1bHQuZm9yRWFjaCgodikgPT4gdGhpcy5hZGRWb2NhYnVsYXJ5KHYpKTtcbiAgICAgICAgaWYgKHRoaXMub3B0cy5kaXNjcmltaW5hdG9yKVxuICAgICAgICAgICAgdGhpcy5hZGRLZXl3b3JkKGRpc2NyaW1pbmF0b3JfMS5kZWZhdWx0KTtcbiAgICB9XG4gICAgX2FkZERlZmF1bHRNZXRhU2NoZW1hKCkge1xuICAgICAgICBzdXBlci5fYWRkRGVmYXVsdE1ldGFTY2hlbWEoKTtcbiAgICAgICAgaWYgKCF0aGlzLm9wdHMubWV0YSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgbWV0YVNjaGVtYSA9IHRoaXMub3B0cy4kZGF0YVxuICAgICAgICAgICAgPyB0aGlzLiRkYXRhTWV0YVNjaGVtYShkcmFmdDdNZXRhU2NoZW1hLCBNRVRBX1NVUFBPUlRfREFUQSlcbiAgICAgICAgICAgIDogZHJhZnQ3TWV0YVNjaGVtYTtcbiAgICAgICAgdGhpcy5hZGRNZXRhU2NoZW1hKG1ldGFTY2hlbWEsIE1FVEFfU0NIRU1BX0lELCBmYWxzZSk7XG4gICAgICAgIHRoaXMucmVmc1tcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvc2NoZW1hXCJdID0gTUVUQV9TQ0hFTUFfSUQ7XG4gICAgfVxuICAgIGRlZmF1bHRNZXRhKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMub3B0cy5kZWZhdWx0TWV0YSA9XG4gICAgICAgICAgICBzdXBlci5kZWZhdWx0TWV0YSgpIHx8ICh0aGlzLmdldFNjaGVtYShNRVRBX1NDSEVNQV9JRCkgPyBNRVRBX1NDSEVNQV9JRCA6IHVuZGVmaW5lZCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuQWp2ID0gQWp2O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gQWp2O1xubW9kdWxlLmV4cG9ydHMuQWp2ID0gQWp2O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gQWp2O1xudmFyIHZhbGlkYXRlXzEgPSByZXF1aXJlKFwiLi9jb21waWxlL3ZhbGlkYXRlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiS2V5d29yZEN4dFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsaWRhdGVfMS5LZXl3b3JkQ3h0OyB9IH0pO1xudmFyIGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvY29kZWdlblwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVnZW5fMS5fOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuc3RyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyaW5naWZ5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuc3RyaW5naWZ5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibmlsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEubmlsOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTmFtZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLk5hbWU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb2RlR2VuXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuQ29kZUdlbjsgfSB9KTtcbnZhciB2YWxpZGF0aW9uX2Vycm9yXzEgPSByZXF1aXJlKFwiLi9ydW50aW1lL3ZhbGlkYXRpb25fZXJyb3JcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJWYWxpZGF0aW9uRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbGlkYXRpb25fZXJyb3JfMS5kZWZhdWx0OyB9IH0pO1xudmFyIHJlZl9lcnJvcl8xID0gcmVxdWlyZShcIi4vY29tcGlsZS9yZWZfZXJyb3JcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNaXNzaW5nUmVmRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlZl9lcnJvcl8xLmRlZmF1bHQ7IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hanYuanMubWFwIiwidHlwZSBIYXNoID0gc3RyaW5nICYge2xlbmd0aDogMzJ9XG5cbmNvbnN0IEZOVl9PRkZTRVRfMSA9IDB4Y2JmMjljZTQ4NDIyMjMyNW47XG5jb25zdCBGTlZfT0ZGU0VUXzIgPSAweDg0MjIyMzI1Y2JmMjljZTRuO1xuY29uc3QgRk5WX1BSSU1FID0gMHgxMDAwMDAwMDFiM247XG5jb25zdCBNQVNLXzY0ID0gKDFuIDw8IDY0bikgLSAxbjtcblxuY29uc3QgaGFzaDY0ID0gKHZhbHVlOiBzdHJpbmcsIG9mZnNldDogYmlnaW50KTogYmlnaW50ID0+IHtcbiAgbGV0IGhhc2ggPSBvZmZzZXQ7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBoYXNoIF49IEJpZ0ludCh2YWx1ZS5jaGFyQ29kZUF0KGkpKTtcbiAgICBoYXNoID0gKGhhc2ggKiBGTlZfUFJJTUUpICYgTUFTS182NDtcbiAgfVxuICByZXR1cm4gaGFzaDtcbn07XG5cbmNvbnN0IHRvSGV4NjQgPSAodmFsdWU6IGJpZ2ludCkgPT4gdmFsdWUudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDE2LCBcIjBcIik7XG5cbmV4cG9ydCBjb25zdCBoYXNoMTI4ID0gKC4uLmRhdGE6YW55KTogSGFzaCA9PiB7XG4gIGNvbnN0IGlucHV0ID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gIGNvbnN0IGhpZ2ggPSBoYXNoNjQoaW5wdXQsIEZOVl9PRkZTRVRfMSk7XG4gIGNvbnN0IGxvdyA9IGhhc2g2NChpbnB1dCwgRk5WX09GRlNFVF8yKTtcbiAgcmV0dXJuIGAke3RvSGV4NjQoaGlnaCl9JHt0b0hleDY0KGxvdyl9YCBhcyBIYXNoO1xufTtcblxuXG5cbiIsImltcG9ydCBBanYgZnJvbSBcImFqdlwiXG5cbmltcG9ydCB7IGhhc2gxMjggfSBmcm9tIFwiLi9oYXNoXCJcbmV4cG9ydCB7IGhhc2gxMjggfSBmcm9tIFwiLi9oYXNoXCJcblxuXG5jb25zdCBzdHJpbmcgPSB7dHlwZSA6IFwic3RyaW5nXCJ9XG5jb25zdCBudW1iZXIgPSB7dHlwZSA6IFwibnVtYmVyXCJ9XG5cbmV4cG9ydCB0eXBlIFNjaGVtYSA9IEpzb25hYmxlXG5jb25zdCBvYmplY3QgPSAocHJvcGVydGllczogUmVjb3JkPHN0cmluZywgYW55PiwgZXh0cmE6IGFueSA9IHt9KSA9PiAoe1xuICB0eXBlOiBcIm9iamVjdFwiLFxuICBwcm9wZXJ0aWVzLFxuICByZXF1aXJlZDogT2JqZWN0LmtleXMocHJvcGVydGllcyksXG4gIC4uLmV4dHJhLFxufSlcblxuY29uc3QgYXJyYXlUID0gKGl0ZW1zIDogU2NoZW1hKSA9PiAoe1xuICB0eXBlOlwiYXJyYXlcIixcbiAgaXRlbXNcbn0pXG5cbmV4cG9ydCB0eXBlIEpzb25hYmxlID0gc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IEpzb25hYmxlW10gfCB7W2tleTogc3RyaW5nXTogSnNvbmFibGV9XG5leHBvcnQgY29uc3QgdG9qc29uID0gKHg6IEpzb25hYmxlKT0+SlNPTi5zdHJpbmdpZnkoeCwgbnVsbCwgMilcbmV4cG9ydCBjb25zdCBmcm9tanNvbiA9ICh4OnN0cmluZyk6IEpzb25hYmxlID0+IEpTT04ucGFyc2UoeClcblxuZXhwb3J0IGNvbnN0IHZhbGlkYXRlID0gKGRhdGE6IEpzb25hYmxlLCBzY2hlbWE6IEpzb25hYmxlKSA9PiB7XG4gIGNvbnN0IHZhbGlkYXRlID0gbmV3IEFqdigpLmNvbXBpbGUoc2NoZW1hIGFzIGFueSk7XG4gIGlmICh2YWxpZGF0ZShkYXRhKSkgcmV0dXJuIHRydWU7XG4gIGVsc2UgdGhyb3cgbmV3IEVycm9yKHZhbGlkYXRlLmVycm9ycz8ubWFwKChlOiBhbnkpID0+IGUubWVzc2FnZSkuam9pbihcIiwgXCIpIHx8IFwiSW52YWxpZCBkYXRhXCIpO1xufVxuXG5leHBvcnQgdHlwZSBIYXNoID0gc3RyaW5nICYgeyBsZW5ndGg6IDMyIH1cbmV4cG9ydCB0eXBlIE5vdGUgPSB7IGRhdGE6IHN0cmluZywgaGFzaDogSGFzaCwgc2NoZW1hSGFzaDogSGFzaCB9XG5leHBvcnQgdHlwZSBOb3RlRGF0YSA9IHsgc2NoZW1hSGFzaDogSGFzaCwgZGF0YTogSnNvbmFibGUgfVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNoRGF0YSh7c2NoZW1hSGFzaCwgZGF0YX0gOiBOb3RlRGF0YSl7XG4gIGlmIChzY2hlbWFIYXNoID09PSBcIjBcIiAmJiB0b2pzb24oZGF0YSkgIT0gXCJ7fVwiKSB0aHJvdyBuZXcgRXJyb3IoXCJzY2hlbWEgaGFzaCBpcyAwIGJ1dCBkYXRhIGlzIG5vdCBlbXB0eSA6XCIgKyB0b2pzb24oZGF0YSkpXG4gIHJldHVybiBoYXNoMTI4KHNjaGVtYUhhc2gsIGRhdGEpIFxufVxuXG5leHBvcnQgZnVuY3Rpb24gTm90ZURhdGEodGl0bGU6c3RyaW5nLCBzY2hlbWE6IE5vdGVEYXRhLCBkYXRhOiBhbnkgPSB7fSk6IE5vdGVEYXRhe1xuICByZXR1cm4ge1xuICAgIHNjaGVtYUhhc2g6IGhhc2hEYXRhKHNjaGVtYSksXG4gICAgZGF0YToge1xuICAgICAgLi4uKHRpdGxlPyB7dGl0bGV9IDoge30pLFxuICAgICAgLi4uZGF0YVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgdG9wOiBOb3RlRGF0YSA9IHtzY2hlbWFIYXNoIDogXCIwXCIgYXMgSGFzaCwgZGF0YToge319XG5cbmV4cG9ydCBjb25zdCBzY3JpcHRfc2NoZW1hID0gTm90ZURhdGEoXCJzY3JpcHRfc2NoZW1hXCIsIHRvcCwgb2JqZWN0KHtcbiAgdGl0bGU6IHN0cmluZyxcbiAgY29kZTogc3RyaW5nLFxufSkpXG5cblxuZXhwb3J0IGNvbnN0IHNjcmlwdF9yZXN1bHRfc2NoZW1hID0gTm90ZURhdGEoXCJzY3JpcHRfcmVzdWx0X3NjaGVtYVwiLCB0b3AsIG9iamVjdCh7XG4gIHRpdGxlOiBzdHJpbmcsXG4gIHNjcmlwdDogXCIjXCIgKyBoYXNoRGF0YShzY3JpcHRfc2NoZW1hKSxcbiAgY29udGVudDoge30sXG59LCB7XG4gIHRpdGxlOiBcInNjcmlwdF9yZXN1bHRfc2NoZW1hXCJcbn0pKVxuXG5jb25zdCB0aXRsZWRfc2NoZW1hID0gTm90ZURhdGEoXCJ0aXRsZWRfc2NoZW1hXCIsIHRvcCwgb2JqZWN0KHt0aXRsZTogc3RyaW5nfSkpXG5cbmNvbnN0IGhhc190aXRsZWRfY2hpbGQgPSBOb3RlRGF0YShcImhhc190aXRsZWRfY2hpbGRcIiwgdG9wLCBvYmplY3Qoe1wiY2hpbGRcIjogb2JqZWN0KHt0aXRsZTpzdHJpbmd9KX0pKVxuXG5cbmNvbnN0IHRpdGxlZCA9IE5vdGVEYXRhKFwiYSB0aXRsZWRcIiwgdGl0bGVkX3NjaGVtYSwge3RpdGxlOiBcImltIGNoaWxkXCJ9KVxuY29uc3QgdGl0bGVkMSA9IE5vdGVEYXRhKFwidGl0bGVkMVwiLCBoYXNfdGl0bGVkX2NoaWxkLCB7IGNoaWxkOiB0aXRsZWQuZGF0YSB9KVxuY29uc3QgdGl0bGVkMiA9IE5vdGVEYXRhKFwidGl0bGVkMlwiLCBoYXNfdGl0bGVkX2NoaWxkLCB7Y2hpbGQ6IGAjJHtoYXNoRGF0YSh0aXRsZWQpfWB9KTtcblxuXG5cbmV4cG9ydCBjb25zdCBmdW5jdGlvbl9zY2hlbWEgPSBOb3RlRGF0YShcImZ1bmN0aW9uIHNjaGVtYVwiLCB0b3AsIG9iamVjdCh7XG4gIHRpdGxlOiBzdHJpbmcsXG4gIGFyZ3M6IHsgYWRkaXRpb25hbFByb3BlcnRpZXM6IG9iamVjdCh7bmFtZTogc3RyaW5nLCBzY2hlbWE6IHt9fSkgfSxcbiAgY29kZTogc3RyaW5nLFxuICByZXR1cm5TY2hlbWE6IHt9XG59LCB7cmVxdWlyZWQ6IFtcImFyZ3NcIiwgXCJjb2RlXCIsIFwicmV0dXJuU2NoZW1hXCJdICB9KSlcblxuXG5leHBvcnQgY29uc3Qgc2VydmVyX2Z1bmN0aW9uID0gTm90ZURhdGEoXCJzZXJ2ZXIgZnVuY3Rpb25cIiwgdG9wLCBvYmplY3Qoe1xuICB0aXRsZTogc3RyaW5nLFxuICBjb2RlOiBzdHJpbmcsXG59LCB7XG4gIHJlcXVpcmVkOiBbXCJjb2RlXCJdXG59KSlcblxuXG5cblxuY29uc3QgZXhhbXBsZV9mdW5jdGlvbiA9IE5vdGVEYXRhKFwiZXhhbXBsZSBmdW5jdGlvblwiLCBmdW5jdGlvbl9zY2hlbWEsIHtcbiAgdGl0bGU6IFwiZXhhbXBsZSBmdW5jdGlvblwiLFxuICBpbnB1dHM6IFtcImFcIiwgXCJiXCJdLFxuICBjb2RlOiBcInJldHVybiBhICsgYlwiLFxufSlcblxuXG5cbmV4cG9ydCBjb25zdCBzY2hlbWFzIDogTm90ZURhdGFbXSA9IFtcbiAgc2NyaXB0X3NjaGVtYSxcbiAgc2NyaXB0X3Jlc3VsdF9zY2hlbWEsXG4gIE5vdGVEYXRhKFwiXCIsIHRvcCwgc3RyaW5nKSxcbiAgTm90ZURhdGEoXCJcIiwgdG9wLCBudW1iZXIpLFxuICB0aXRsZWRfc2NoZW1hLFxuICBoYXNfdGl0bGVkX2NoaWxkLFxuICB0aXRsZWQsXG4gIHRpdGxlZDEsIHRpdGxlZDIsXG4gIGZ1bmN0aW9uX3NjaGVtYSwgZXhhbXBsZV9mdW5jdGlvbixcbiAgc2VydmVyX2Z1bmN0aW9uLCAgXG5dXG5cblxuZXhwb3J0IGNvbnN0IGlzUmVmID0gKHZhbHVlOiBhbnkpID0+XG4gIHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiICYmIC9eIyhbYS1mMC05XXszMn0pJC8uZXhlYyh2YWx1ZSkgYXMgUmVmW10gfCBudWxsO1xuXG5leHBvcnQgY29uc3QgZXhwYW5kTGlua3NTeW5jID0gKFxuICB2YWx1ZTogSnNvbmFibGUsXG4gIHJlc29sdmU6IChyZWY6IFJlZikgPT4gSnNvbmFibGUsXG4pOiBKc29uYWJsZSA9PiB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICBjb25zdCBtYXRjaCA9IGlzUmVmKHZhbHVlKTtcbiAgICBpZiAoIW1hdGNoKSByZXR1cm4gdmFsdWU7XG4gICAgY29uc3QgcmVmID0gbWF0Y2hbMV07XG4gICAgcmV0dXJuIGV4cGFuZExpbmtzU3luYyhyZXNvbHZlKHJlZiksIHJlc29sdmUpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkgcmV0dXJuIHZhbHVlLm1hcCgodikgPT4gZXhwYW5kTGlua3NTeW5jKHYsIHJlc29sdmUpKTtcbiAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXModmFsdWUpLm1hcCggKFtrLCB2XSkgPT4gW2ssIGV4cGFuZExpbmtzU3luYyh2LCByZXNvbHZlKV0pKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59O1xuXG5cbmV4cG9ydCBjb25zdCBleHBhbmRMaW5rcyA9IGFzeW5jIChcbiAgdmFsdWU6IEpzb25hYmxlLFxuICByZXNvbHZlOiAocmVmOiBSZWYgKSA9PiBQcm9taXNlPEpzb25hYmxlPixcbik6IFByb21pc2U8SnNvbmFibGU+ID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnN0IG1hdGNoID0gaXNSZWYodmFsdWUpO1xuICAgIGlmICghbWF0Y2gpIHJldHVybiB2YWx1ZTtcbiAgICBjb25zdCByZWYgPSBtYXRjaFsxXTtcbiAgICByZXR1cm4gZXhwYW5kTGlua3MoYXdhaXQgcmVzb2x2ZShyZWYpLCByZXNvbHZlKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHJldHVybiBQcm9taXNlLmFsbCh2YWx1ZS5tYXAoKHYpID0+IGV4cGFuZExpbmtzKHYsIHJlc29sdmUpKSk7XG4gIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKGF3YWl0IFByb21pc2UuYWxsKE9iamVjdC5lbnRyaWVzKHZhbHVlKS5tYXAoYXN5bmMgKFtrLCB2XSkgPT4gW2ssIGF3YWl0IGV4cGFuZExpbmtzKHYsIHJlc29sdmUpXSkpKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59O1xuLyoqKiByZXByZXNlbnRzIGEgbm90ZSBoYXNoIChvcHRpb25hbGx5IHByZWZpeGVkIHdpdGggIykgKioqL1xuZXhwb3J0IHR5cGUgUmVmID0gSGFzaCB8IGAjJHtIYXNofWBcblxuZXhwb3J0IGNvbnN0IG5vcm1hbGl6ZVJlZiA9IChyZWY6IFJlZik6IEhhc2ggPT5cbiAgKHJlZlswXSA9PT0gXCIjXCIgPyByZWYuc2xpY2UoMSkgOiByZWYpIGFzIEhhc2g7XG4iLCJ0eXBlIFRva2VuVHlwZSA9XG4gIHwgXCJudW1iZXJcIlxuICB8IFwic3RyaW5nXCJcbiAgfCBcImlkZW50aWZpZXJcIlxuICB8IFwia2V5d29yZFwiXG4gIHwgXCJvcGVyYXRvclwiXG4gIHwgXCJwdW5jdFwiXG4gIHwgXCJlb2ZcIjtcblxudHlwZSBUb2tlbiA9IHsgdHlwZTogVG9rZW5UeXBlOyB2YWx1ZTogc3RyaW5nOyBwb3M6IG51bWJlciB9O1xuXG5jb25zdCBrZXl3b3JkcyA9IG5ldyBTZXQoW1xuICBcImlmXCIsXG4gIFwiZWxzZVwiLFxuICBcInJldHVyblwiLFxuICBcImxldFwiLFxuICBcImNvbnN0XCIsXG4gIFwiZm9yXCIsXG4gIFwid2hpbGVcIixcbiAgXCJpblwiLFxuICBcIm9mXCIsXG4gIFwiYnJlYWtcIixcbiAgXCJjb250aW51ZVwiLFxuICBcInRydWVcIixcbiAgXCJmYWxzZVwiLFxuICBcIm51bGxcIixcbl0pO1xuXG5jb25zdCBpc0lkZW50U3RhcnQgPSAoYzogc3RyaW5nKSA9PiAvW0EtWmEtel8kXS8udGVzdChjKTtcbmNvbnN0IGlzSWRlbnRQYXJ0ID0gKGM6IHN0cmluZykgPT4gL1tBLVphLXowLTlfJF0vLnRlc3QoYyk7XG5jb25zdCBpc0RpZ2l0ID0gKGM6IHN0cmluZykgPT4gL1swLTldLy50ZXN0KGMpO1xuXG5jb25zdCB0b2tlbml6ZSA9IChzcmM6IHN0cmluZyk6IFRva2VuW10gPT4ge1xuICBjb25zdCB0b2tlbnM6IFRva2VuW10gPSBbXTtcbiAgbGV0IGkgPSAwO1xuICBjb25zdCBwdXNoID0gKHR5cGU6IFRva2VuVHlwZSwgdmFsdWU6IHN0cmluZywgcG9zOiBudW1iZXIpID0+IHRva2Vucy5wdXNoKHsgdHlwZSwgdmFsdWUsIHBvcyB9KTtcbiAgY29uc3QgcGVlayA9ICgpID0+IHNyY1tpXTtcbiAgY29uc3QgbmV4dCA9ICgpID0+IHNyY1tpKytdO1xuXG4gIHdoaWxlIChpIDwgc3JjLmxlbmd0aCkge1xuICAgIGNvbnN0IGMgPSBwZWVrKCk7XG4gICAgaWYgKGMgPT09IFwiIFwiIHx8IGMgPT09IFwiXFxuXCIgfHwgYyA9PT0gXCJcXHJcIiB8fCBjID09PSBcIlxcdFwiKSB7XG4gICAgICBpKys7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGMgPT09IFwiL1wiICYmIHNyY1tpICsgMV0gPT09IFwiL1wiKSB7XG4gICAgICBpICs9IDI7XG4gICAgICB3aGlsZSAoaSA8IHNyYy5sZW5ndGggJiYgc3JjW2ldICE9PSBcIlxcblwiKSBpKys7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGMgPT09IFwiL1wiICYmIHNyY1tpICsgMV0gPT09IFwiKlwiKSB7XG4gICAgICBpICs9IDI7XG4gICAgICB3aGlsZSAoaSA8IHNyYy5sZW5ndGggJiYgIShzcmNbaV0gPT09IFwiKlwiICYmIHNyY1tpICsgMV0gPT09IFwiL1wiKSkgaSsrO1xuICAgICAgaSArPSAyO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChjID09PSBcIidcIiB8fCBjID09PSBcIlxcXCJcIikge1xuICAgICAgY29uc3QgcXVvdGUgPSBuZXh0KCk7XG4gICAgICBsZXQgb3V0ID0gXCJcIjtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gaSAtIDE7XG4gICAgICB3aGlsZSAoaSA8IHNyYy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgY2ggPSBuZXh0KCk7XG4gICAgICAgIGlmIChjaCA9PT0gXCJcXFxcXCIpIHtcbiAgICAgICAgICBjb25zdCBlc2MgPSBuZXh0KCk7XG4gICAgICAgICAgb3V0ICs9IGVzYztcbiAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gcXVvdGUpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgKz0gY2g7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHB1c2goXCJzdHJpbmdcIiwgb3V0LCBzdGFydCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGlzRGlnaXQoYykpIHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gaTtcbiAgICAgIGxldCBudW0gPSBcIlwiO1xuICAgICAgd2hpbGUgKGkgPCBzcmMubGVuZ3RoICYmIGlzRGlnaXQocGVlaygpKSkgbnVtICs9IG5leHQoKTtcbiAgICAgIGlmIChwZWVrKCkgPT09IFwiLlwiKSB7XG4gICAgICAgIG51bSArPSBuZXh0KCk7XG4gICAgICAgIHdoaWxlIChpIDwgc3JjLmxlbmd0aCAmJiBpc0RpZ2l0KHBlZWsoKSkpIG51bSArPSBuZXh0KCk7XG4gICAgICB9XG4gICAgICBwdXNoKFwibnVtYmVyXCIsIG51bSwgc3RhcnQpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChpc0lkZW50U3RhcnQoYykpIHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gaTtcbiAgICAgIGxldCBpZCA9IFwiXCI7XG4gICAgICB3aGlsZSAoaSA8IHNyYy5sZW5ndGggJiYgaXNJZGVudFBhcnQocGVlaygpKSkgaWQgKz0gbmV4dCgpO1xuICAgICAgaWYgKGtleXdvcmRzLmhhcyhpZCkpIHB1c2goXCJrZXl3b3JkXCIsIGlkLCBzdGFydCk7XG4gICAgICBlbHNlIHB1c2goXCJpZGVudGlmaWVyXCIsIGlkLCBzdGFydCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnQgPSBpO1xuICAgIGNvbnN0IHR3byA9IHNyYy5zbGljZShpLCBpICsgMik7XG4gICAgY29uc3QgdGhyZWUgPSBzcmMuc2xpY2UoaSwgaSArIDMpO1xuICAgIGlmICh0aHJlZSA9PT0gXCI9PT1cIiB8fCB0aHJlZSA9PT0gXCIhPT1cIikge1xuICAgICAgaSArPSAzO1xuICAgICAgcHVzaChcIm9wZXJhdG9yXCIsIHRocmVlLCBzdGFydCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHR3byA9PT0gXCImJlwiIHx8IHR3byA9PT0gXCJ8fFwiIHx8IHR3byA9PT0gXCI9PVwiIHx8IHR3byA9PT0gXCIhPVwiIHx8IHR3byA9PT0gXCI8PVwiIHx8IHR3byA9PT0gXCI+PVwiIHx8IHR3byA9PT0gXCI9PlwiIHx8IHR3byA9PT0gXCIrPVwiIHx8IHR3byA9PT0gXCItPVwiIHx8IHR3byA9PT0gXCIqPVwiIHx8IHR3byA9PT0gXCIvPVwiIHx8IHR3byA9PT0gXCIlPVwiIHx8IHR3byA9PT0gXCIrK1wiIHx8IHR3byA9PT0gXCItLVwiKSB7XG4gICAgICBpICs9IDI7XG4gICAgICBwdXNoKFwib3BlcmF0b3JcIiwgdHdvLCBzdGFydCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKFwiKy0qLyU8Pj0hLiw7Oj8oKXt9W11cIi5pbmNsdWRlcyhjKSkge1xuICAgICAgaSsrO1xuICAgICAgY29uc3QgdHlwZSA9IFwiLjssKCl7fVtdXCIuaW5jbHVkZXMoYykgPyBcInB1bmN0XCIgOiBcIm9wZXJhdG9yXCI7XG4gICAgICBwdXNoKHR5cGUsIGMsIHN0YXJ0KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyICcke2N9JyBhdCAke2l9YCk7XG4gIH1cbiAgdG9rZW5zLnB1c2goeyB0eXBlOiBcImVvZlwiLCB2YWx1ZTogXCJcIiwgcG9zOiBpIH0pO1xuICByZXR1cm4gdG9rZW5zO1xufTtcblxuZXhwb3J0IHR5cGUgUHJvZ3JhbSA9IHsgdHlwZTogXCJQcm9ncmFtXCI7IGJvZHk6IFN0bXRbXSB9O1xuZXhwb3J0IHR5cGUgQmxvY2tTdGF0ZW1lbnQgPSB7IHR5cGU6IFwiQmxvY2tTdGF0ZW1lbnRcIjsgYm9keTogU3RtdFtdIH07XG5leHBvcnQgdHlwZSBTdG10ID1cbiAgfCBCbG9ja1N0YXRlbWVudFxuICB8IHsgdHlwZTogXCJFeHByZXNzaW9uU3RhdGVtZW50XCI7IGV4cHJlc3Npb246IEV4cHIgfVxuICB8IHsgdHlwZTogXCJJZlN0YXRlbWVudFwiOyB0ZXN0OiBFeHByOyBjb25zZXF1ZW50OiBTdG10OyBhbHRlcm5hdGU6IFN0bXQgfCBudWxsIH1cbiAgfCB7IHR5cGU6IFwiUmV0dXJuU3RhdGVtZW50XCI7IGFyZ3VtZW50OiBFeHByIHwgbnVsbCB9XG4gIHwgeyB0eXBlOiBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIjsga2luZDogXCJsZXRcIiB8IFwiY29uc3RcIjsgZGVjbGFyYXRpb25zOiBWYXJEZWNsW10gfVxuICB8IHsgdHlwZTogXCJCcmVha1N0YXRlbWVudFwiIH1cbiAgfCB7IHR5cGU6IFwiQ29udGludWVTdGF0ZW1lbnRcIiB9XG4gIHwgeyB0eXBlOiBcIldoaWxlU3RhdGVtZW50XCI7IHRlc3Q6IEV4cHI7IGJvZHk6IFN0bXQgfVxuICB8IHtcbiAgICAgIHR5cGU6IFwiRm9yU3RhdGVtZW50XCI7XG4gICAgICBpbml0OiBWYXJEZWNsW10gfCBFeHByIHwgbnVsbDtcbiAgICAgIGluaXRLaW5kOiBcImxldFwiIHwgXCJjb25zdFwiIHwgbnVsbDtcbiAgICAgIHRlc3Q6IEV4cHIgfCBudWxsO1xuICAgICAgdXBkYXRlOiBFeHByIHwgbnVsbDtcbiAgICAgIGJvZHk6IFN0bXQ7XG4gICAgfVxuICB8IHsgdHlwZTogXCJGb3JJblN0YXRlbWVudFwiOyBsZWZ0OiBWYXJEZWNsW10gfCBFeHByOyBsZWZ0S2luZDogXCJsZXRcIiB8IFwiY29uc3RcIiB8IG51bGw7IHJpZ2h0OiBFeHByOyBib2R5OiBTdG10IH1cbiAgfCB7IHR5cGU6IFwiRm9yT2ZTdGF0ZW1lbnRcIjsgbGVmdDogVmFyRGVjbFtdIHwgRXhwcjsgbGVmdEtpbmQ6IFwibGV0XCIgfCBcImNvbnN0XCIgfCBudWxsOyByaWdodDogRXhwcjsgYm9keTogU3RtdCB9O1xuZXhwb3J0IHR5cGUgUGF0dGVybiA9XG4gIHwgSWRlbnRpZmllclxuICB8IHsgdHlwZTogXCJBcnJheVBhdHRlcm5cIjsgZWxlbWVudHM6IElkZW50aWZpZXJbXSB9XG4gIHwgeyB0eXBlOiBcIk9iamVjdFBhdHRlcm5cIjsgcHJvcGVydGllczogSWRlbnRpZmllcltdIH07XG5cbmV4cG9ydCB0eXBlIFZhckRlY2wgPSB7IHR5cGU6IFwiVmFyaWFibGVEZWNsYXJhdG9yXCI7IGlkOiBQYXR0ZXJuOyBpbml0OiBFeHByIHwgbnVsbCB9O1xuXG5leHBvcnQgdHlwZSBFeHByID1cbiAgfCBJZGVudGlmaWVyXG4gIHwgTGl0ZXJhbFxuICB8IHsgdHlwZTogXCJBcnJheUV4cHJlc3Npb25cIjsgZWxlbWVudHM6IEV4cHJbXSB9XG4gIHwgeyB0eXBlOiBcIk9iamVjdEV4cHJlc3Npb25cIjsgcHJvcGVydGllczogUHJvcGVydHlbXSB9XG4gIHwgeyB0eXBlOiBcIkNhbGxFeHByZXNzaW9uXCI7IGNhbGxlZTogRXhwcjsgYXJndW1lbnRzOiBFeHByW10gfVxuICB8IHsgdHlwZTogXCJNZW1iZXJFeHByZXNzaW9uXCI7IG9iamVjdDogRXhwcjsgcHJvcGVydHk6IEV4cHI7IGNvbXB1dGVkOiBib29sZWFuIH1cbiAgfCB7IHR5cGU6IFwiQXNzaWdubWVudEV4cHJlc3Npb25cIjsgb3BlcmF0b3I6IHN0cmluZzsgbGVmdDogRXhwcjsgcmlnaHQ6IEV4cHIgfVxuICB8IHsgdHlwZTogXCJVcGRhdGVFeHByZXNzaW9uXCI7IG9wZXJhdG9yOiBcIisrXCIgfCBcIi0tXCI7IGFyZ3VtZW50OiBFeHByOyBwcmVmaXg6IGJvb2xlYW4gfVxuICB8IHsgdHlwZTogXCJCaW5hcnlFeHByZXNzaW9uXCI7IG9wZXJhdG9yOiBzdHJpbmc7IGxlZnQ6IEV4cHI7IHJpZ2h0OiBFeHByIH1cbiAgfCB7IHR5cGU6IFwiTG9naWNhbEV4cHJlc3Npb25cIjsgb3BlcmF0b3I6IHN0cmluZzsgbGVmdDogRXhwcjsgcmlnaHQ6IEV4cHIgfVxuICB8IHsgdHlwZTogXCJVbmFyeUV4cHJlc3Npb25cIjsgb3BlcmF0b3I6IHN0cmluZzsgYXJndW1lbnQ6IEV4cHIgfVxuICB8IHsgdHlwZTogXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIjsgdGVzdDogRXhwcjsgY29uc2VxdWVudDogRXhwcjsgYWx0ZXJuYXRlOiBFeHByIH1cbiAgfCB7IHR5cGU6IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIjsgcGFyYW1zOiBJZGVudGlmaWVyW107IGJvZHk6IEV4cHIgfCBCbG9ja1N0YXRlbWVudCB9O1xuXG5leHBvcnQgdHlwZSBJZGVudGlmaWVyID0geyB0eXBlOiBcIklkZW50aWZpZXJcIjsgbmFtZTogc3RyaW5nIH07XG5leHBvcnQgdHlwZSBMaXRlcmFsID0geyB0eXBlOiBcIkxpdGVyYWxcIjsgdmFsdWU6IHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBudWxsIH07XG5leHBvcnQgdHlwZSBQcm9wZXJ0eSA9IHsgdHlwZTogXCJQcm9wZXJ0eVwiOyBrZXk6IElkZW50aWZpZXIgfCBMaXRlcmFsOyB2YWx1ZTogRXhwcjsgc2hvcnRoYW5kOiBib29sZWFuIH07XG5cbmV4cG9ydCBjb25zdCB2YWxpZGF0ZVNjb3BlcyA9IChwcm9ncmFtOiBQcm9ncmFtLCBhbGxvd2VkR2xvYmFsczogc3RyaW5nW10gPSBbXSkgPT4ge1xuICBjb25zdCBlcnJvcnM6IHN0cmluZ1tdID0gW107XG4gIGNvbnN0IGdsb2JhbHMgPSBuZXcgU2V0KGFsbG93ZWRHbG9iYWxzKTtcbiAgY29uc3Qgc2NvcGVzOiBBcnJheTxTZXQ8c3RyaW5nPj4gPSBbbmV3IFNldCgpXTtcblxuICBjb25zdCBkZWNsYXJlID0gKG5hbWU6IHN0cmluZykgPT4gc2NvcGVzW3Njb3Blcy5sZW5ndGggLSAxXS5hZGQobmFtZSk7XG4gIGNvbnN0IGlzRGVjbGFyZWQgPSAobmFtZTogc3RyaW5nKSA9PiBzY29wZXMuc29tZSgocykgPT4gcy5oYXMobmFtZSkpIHx8IGdsb2JhbHMuaGFzKG5hbWUpO1xuICBjb25zdCBlbnRlciA9ICgpID0+IHNjb3Blcy5wdXNoKG5ldyBTZXQoKSk7XG4gIGNvbnN0IGV4aXQgPSAoKSA9PiB7IHNjb3Blcy5wb3AoKTsgfTtcbiAgY29uc3QgY2hlY2tJZGVudCA9IChuYW1lOiBzdHJpbmcpID0+IHtcbiAgICBpZiAoIWlzRGVjbGFyZWQobmFtZSkpIGVycm9ycy5wdXNoKGB1bmRlY2xhcmVkOiAke25hbWV9YCk7XG4gIH07XG5cbiAgY29uc3QgZGVjbGFyZVBhdHRlcm4gPSAocDogUGF0dGVybikgPT4ge1xuICAgIGlmIChwLnR5cGUgPT09IFwiSWRlbnRpZmllclwiKSBkZWNsYXJlKHAubmFtZSk7XG4gICAgZWxzZSBpZiAocC50eXBlID09PSBcIkFycmF5UGF0dGVyblwiKSBwLmVsZW1lbnRzLmZvckVhY2goKGUpID0+IGRlY2xhcmUoZS5uYW1lKSk7XG4gICAgZWxzZSBwLnByb3BlcnRpZXMuZm9yRWFjaCgoZSkgPT4gZGVjbGFyZShlLm5hbWUpKTtcbiAgfTtcblxuICBjb25zdCB2aXNpdEV4cHIgPSAoZTogRXhwcik6IHZvaWQgPT4ge1xuICAgIHN3aXRjaCAoZS50eXBlKSB7XG4gICAgICBjYXNlIFwiSWRlbnRpZmllclwiOlxuICAgICAgICBjaGVja0lkZW50KGUubmFtZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJMaXRlcmFsXCI6XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJBcnJheUV4cHJlc3Npb25cIjpcbiAgICAgICAgZS5lbGVtZW50cy5mb3JFYWNoKHZpc2l0RXhwcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJPYmplY3RFeHByZXNzaW9uXCI6XG4gICAgICAgIGUucHJvcGVydGllcy5mb3JFYWNoKChwKSA9PiB2aXNpdEV4cHIocC52YWx1ZSkpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiQ2FsbEV4cHJlc3Npb25cIjpcbiAgICAgICAgdmlzaXRFeHByKGUuY2FsbGVlKTtcbiAgICAgICAgZS5hcmd1bWVudHMuZm9yRWFjaCh2aXNpdEV4cHIpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgICAgICB2aXNpdEV4cHIoZS5vYmplY3QpO1xuICAgICAgICBpZiAoZS5jb21wdXRlZCkgdmlzaXRFeHByKGUucHJvcGVydHkpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIjpcbiAgICAgICAgdmlzaXRFeHByKGUubGVmdCk7XG4gICAgICAgIHZpc2l0RXhwcihlLnJpZ2h0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcIlVwZGF0ZUV4cHJlc3Npb25cIjpcbiAgICAgICAgdmlzaXRFeHByKGUuYXJndW1lbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiQmluYXJ5RXhwcmVzc2lvblwiOlxuICAgICAgY2FzZSBcIkxvZ2ljYWxFeHByZXNzaW9uXCI6XG4gICAgICAgIHZpc2l0RXhwcihlLmxlZnQpO1xuICAgICAgICB2aXNpdEV4cHIoZS5yaWdodCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJVbmFyeUV4cHJlc3Npb25cIjpcbiAgICAgICAgdmlzaXRFeHByKGUuYXJndW1lbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCI6XG4gICAgICAgIHZpc2l0RXhwcihlLnRlc3QpO1xuICAgICAgICB2aXNpdEV4cHIoZS5jb25zZXF1ZW50KTtcbiAgICAgICAgdmlzaXRFeHByKGUuYWx0ZXJuYXRlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCI6XG4gICAgICAgIGVudGVyKCk7XG4gICAgICAgIGUucGFyYW1zLmZvckVhY2goKHApID0+IGRlY2xhcmUocC5uYW1lKSk7XG4gICAgICAgIGlmIChlLmJvZHkudHlwZSA9PT0gXCJCbG9ja1N0YXRlbWVudFwiKSB2aXNpdFN0bXQoZS5ib2R5KTtcbiAgICAgICAgZWxzZSB2aXNpdEV4cHIoZS5ib2R5KTtcbiAgICAgICAgZXhpdCgpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHZpc2l0VmFyRGVjbCA9IChkOiBWYXJEZWNsKSA9PiB7XG4gICAgZGVjbGFyZVBhdHRlcm4oZC5pZCk7XG4gICAgaWYgKGQuaW5pdCkgdmlzaXRFeHByKGQuaW5pdCk7XG4gIH07XG5cbiAgY29uc3QgdmlzaXRTdG10ID0gKHM6IFN0bXQpOiB2b2lkID0+IHtcbiAgICBzd2l0Y2ggKHMudHlwZSkge1xuICAgICAgY2FzZSBcIkJsb2NrU3RhdGVtZW50XCI6XG4gICAgICAgIGVudGVyKCk7XG4gICAgICAgIHMuYm9keS5mb3JFYWNoKHZpc2l0U3RtdCk7XG4gICAgICAgIGV4aXQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIjpcbiAgICAgICAgdmlzaXRFeHByKHMuZXhwcmVzc2lvbik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJJZlN0YXRlbWVudFwiOlxuICAgICAgICB2aXNpdEV4cHIocy50ZXN0KTtcbiAgICAgICAgdmlzaXRTdG10KHMuY29uc2VxdWVudCk7XG4gICAgICAgIGlmIChzLmFsdGVybmF0ZSkgdmlzaXRTdG10KHMuYWx0ZXJuYXRlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcIlJldHVyblN0YXRlbWVudFwiOlxuICAgICAgICBpZiAocy5hcmd1bWVudCkgdmlzaXRFeHByKHMuYXJndW1lbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiVmFyaWFibGVEZWNsYXJhdGlvblwiOlxuICAgICAgICBzLmRlY2xhcmF0aW9ucy5mb3JFYWNoKHZpc2l0VmFyRGVjbCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJXaGlsZVN0YXRlbWVudFwiOlxuICAgICAgICB2aXNpdEV4cHIocy50ZXN0KTtcbiAgICAgICAgdmlzaXRTdG10KHMuYm9keSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJGb3JTdGF0ZW1lbnRcIjoge1xuICAgICAgICBlbnRlcigpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzLmluaXQpKSBzLmluaXQuZm9yRWFjaCh2aXNpdFZhckRlY2wpO1xuICAgICAgICBlbHNlIGlmIChzLmluaXQpIHZpc2l0RXhwcihzLmluaXQpO1xuICAgICAgICBpZiAocy50ZXN0KSB2aXNpdEV4cHIocy50ZXN0KTtcbiAgICAgICAgaWYgKHMudXBkYXRlKSB2aXNpdEV4cHIocy51cGRhdGUpO1xuICAgICAgICB2aXNpdFN0bXQocy5ib2R5KTtcbiAgICAgICAgZXhpdCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjYXNlIFwiRm9ySW5TdGF0ZW1lbnRcIjpcbiAgICAgIGNhc2UgXCJGb3JPZlN0YXRlbWVudFwiOiB7XG4gICAgICAgIGVudGVyKCk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHMubGVmdCkpIHMubGVmdC5mb3JFYWNoKHZpc2l0VmFyRGVjbCk7XG4gICAgICAgIGVsc2UgdmlzaXRFeHByKHMubGVmdCk7XG4gICAgICAgIHZpc2l0RXhwcihzLnJpZ2h0KTtcbiAgICAgICAgdmlzaXRTdG10KHMuYm9keSk7XG4gICAgICAgIGV4aXQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY2FzZSBcIkJyZWFrU3RhdGVtZW50XCI6XG4gICAgICBjYXNlIFwiQ29udGludWVTdGF0ZW1lbnRcIjpcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfTtcblxuICBwcm9ncmFtLmJvZHkuZm9yRWFjaCh2aXNpdFN0bXQpO1xuICByZXR1cm4gZXJyb3JzO1xufTtcblxuZXhwb3J0IGNvbnN0IHZhbGlkYXRlTm9Qcm90b3R5cGUgPSAocHJvZ3JhbTogUHJvZ3JhbSkgPT4ge1xuICBjb25zdCBlcnJvcnM6IHN0cmluZ1tdID0gW107XG4gIGNvbnN0IHZpc2l0RXhwciA9IChlOiBFeHByKTogdm9pZCA9PiB7XG4gICAgc3dpdGNoIChlLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgICAgIGlmICghZS5jb21wdXRlZCAmJiBlLnByb3BlcnR5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIGUucHJvcGVydHkubmFtZSA9PT0gXCJwcm90b3R5cGVcIikge1xuICAgICAgICAgIGVycm9ycy5wdXNoKFwicHJvdG90eXBlIGFjY2Vzc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZS5jb21wdXRlZCAmJiBlLnByb3BlcnR5LnR5cGUgPT09IFwiTGl0ZXJhbFwiICYmIGUucHJvcGVydHkudmFsdWUgPT09IFwicHJvdG90eXBlXCIpIHtcbiAgICAgICAgICBlcnJvcnMucHVzaChcInByb3RvdHlwZSBhY2Nlc3NcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmlzaXRFeHByKGUub2JqZWN0KTtcbiAgICAgICAgaWYgKGUuY29tcHV0ZWQpIHZpc2l0RXhwcihlLnByb3BlcnR5KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcIkNhbGxFeHByZXNzaW9uXCI6XG4gICAgICAgIHZpc2l0RXhwcihlLmNhbGxlZSk7XG4gICAgICAgIGUuYXJndW1lbnRzLmZvckVhY2godmlzaXRFeHByKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcIkFycmF5RXhwcmVzc2lvblwiOlxuICAgICAgICBlLmVsZW1lbnRzLmZvckVhY2godmlzaXRFeHByKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcIk9iamVjdEV4cHJlc3Npb25cIjpcbiAgICAgICAgZS5wcm9wZXJ0aWVzLmZvckVhY2goKHApID0+IHZpc2l0RXhwcihwLnZhbHVlKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiOlxuICAgICAgICB2aXNpdEV4cHIoZS5sZWZ0KTtcbiAgICAgICAgdmlzaXRFeHByKGUucmlnaHQpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiVXBkYXRlRXhwcmVzc2lvblwiOlxuICAgICAgICB2aXNpdEV4cHIoZS5hcmd1bWVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJCaW5hcnlFeHByZXNzaW9uXCI6XG4gICAgICBjYXNlIFwiTG9naWNhbEV4cHJlc3Npb25cIjpcbiAgICAgICAgdmlzaXRFeHByKGUubGVmdCk7XG4gICAgICAgIHZpc2l0RXhwcihlLnJpZ2h0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcIlVuYXJ5RXhwcmVzc2lvblwiOlxuICAgICAgICB2aXNpdEV4cHIoZS5hcmd1bWVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIjpcbiAgICAgICAgdmlzaXRFeHByKGUudGVzdCk7XG4gICAgICAgIHZpc2l0RXhwcihlLmNvbnNlcXVlbnQpO1xuICAgICAgICB2aXNpdEV4cHIoZS5hbHRlcm5hdGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIjpcbiAgICAgICAgaWYgKGUuYm9keS50eXBlID09PSBcIkJsb2NrU3RhdGVtZW50XCIpIHZpc2l0U3RtdChlLmJvZHkpO1xuICAgICAgICBlbHNlIHZpc2l0RXhwcihlLmJvZHkpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiSWRlbnRpZmllclwiOlxuICAgICAgY2FzZSBcIkxpdGVyYWxcIjpcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgdmlzaXRTdG10ID0gKHM6IFN0bXQpOiB2b2lkID0+IHtcbiAgICBzd2l0Y2ggKHMudHlwZSkge1xuICAgICAgY2FzZSBcIkJsb2NrU3RhdGVtZW50XCI6XG4gICAgICAgIHMuYm9keS5mb3JFYWNoKHZpc2l0U3RtdCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJFeHByZXNzaW9uU3RhdGVtZW50XCI6XG4gICAgICAgIHZpc2l0RXhwcihzLmV4cHJlc3Npb24pO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiSWZTdGF0ZW1lbnRcIjpcbiAgICAgICAgdmlzaXRFeHByKHMudGVzdCk7XG4gICAgICAgIHZpc2l0U3RtdChzLmNvbnNlcXVlbnQpO1xuICAgICAgICBpZiAocy5hbHRlcm5hdGUpIHZpc2l0U3RtdChzLmFsdGVybmF0ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJSZXR1cm5TdGF0ZW1lbnRcIjpcbiAgICAgICAgaWYgKHMuYXJndW1lbnQpIHZpc2l0RXhwcihzLmFyZ3VtZW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIjpcbiAgICAgICAgcy5kZWNsYXJhdGlvbnMuZm9yRWFjaCgoZCkgPT4gZC5pbml0ICYmIHZpc2l0RXhwcihkLmluaXQpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcIldoaWxlU3RhdGVtZW50XCI6XG4gICAgICAgIHZpc2l0RXhwcihzLnRlc3QpO1xuICAgICAgICB2aXNpdFN0bXQocy5ib2R5KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcIkZvclN0YXRlbWVudFwiOlxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzLmluaXQpKSBzLmluaXQuZm9yRWFjaCgoZCkgPT4gZC5pbml0ICYmIHZpc2l0RXhwcihkLmluaXQpKTtcbiAgICAgICAgZWxzZSBpZiAocy5pbml0KSB2aXNpdEV4cHIocy5pbml0KTtcbiAgICAgICAgaWYgKHMudGVzdCkgdmlzaXRFeHByKHMudGVzdCk7XG4gICAgICAgIGlmIChzLnVwZGF0ZSkgdmlzaXRFeHByKHMudXBkYXRlKTtcbiAgICAgICAgdmlzaXRTdG10KHMuYm9keSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJGb3JJblN0YXRlbWVudFwiOlxuICAgICAgY2FzZSBcIkZvck9mU3RhdGVtZW50XCI6XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHMubGVmdCkpIHMubGVmdC5mb3JFYWNoKChkKSA9PiBkLmluaXQgJiYgdmlzaXRFeHByKGQuaW5pdCkpO1xuICAgICAgICBlbHNlIHZpc2l0RXhwcihzLmxlZnQpO1xuICAgICAgICB2aXNpdEV4cHIocy5yaWdodCk7XG4gICAgICAgIHZpc2l0U3RtdChzLmJvZHkpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiQnJlYWtTdGF0ZW1lbnRcIjpcbiAgICAgIGNhc2UgXCJDb250aW51ZVN0YXRlbWVudFwiOlxuICAgICAgICByZXR1cm47XG4gICAgfVxuICB9O1xuICBwcm9ncmFtLmJvZHkuZm9yRWFjaCh2aXNpdFN0bXQpO1xuICByZXR1cm4gZXJyb3JzO1xufTtcblxuY29uc3QgcmVuZGVyTGl0ZXJhbCA9ICh2OiBMaXRlcmFsW1widmFsdWVcIl0pID0+IHtcbiAgaWYgKHYgPT09IG51bGwpIHJldHVybiBcIm51bGxcIjtcbiAgaWYgKHR5cGVvZiB2ID09PSBcInN0cmluZ1wiKSByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG4gIHJldHVybiBTdHJpbmcodik7XG59O1xuXG5jb25zdCByZW5kZXJFeHByID0gKGU6IEV4cHIpOiBzdHJpbmcgPT4ge1xuICBzd2l0Y2ggKGUudHlwZSkge1xuICAgIGNhc2UgXCJJZGVudGlmaWVyXCI6XG4gICAgICByZXR1cm4gZS5uYW1lO1xuICAgIGNhc2UgXCJMaXRlcmFsXCI6XG4gICAgICByZXR1cm4gcmVuZGVyTGl0ZXJhbChlLnZhbHVlKTtcbiAgICBjYXNlIFwiQXJyYXlFeHByZXNzaW9uXCI6XG4gICAgICByZXR1cm4gYFske2UuZWxlbWVudHMubWFwKHJlbmRlckV4cHIpLmpvaW4oXCIsIFwiKX1dYDtcbiAgICBjYXNlIFwiT2JqZWN0RXhwcmVzc2lvblwiOlxuICAgICAgcmV0dXJuIGB7JHtlLnByb3BlcnRpZXMubWFwKHJlbmRlclByb3ApLmpvaW4oXCIsIFwiKX19YDtcbiAgICBjYXNlIFwiQ2FsbEV4cHJlc3Npb25cIjoge1xuICAgICAgY29uc3QgY2FsbGVlU3RyID0gcmVuZGVyRXhwcihlLmNhbGxlZSk7XG4gICAgICBjb25zdCBuZWVkc1BhcmVucyA9IGUuY2FsbGVlLnR5cGUgPT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIjtcbiAgICAgIHJldHVybiBgJHtuZWVkc1BhcmVucyA/IFwiKFwiIDogXCJcIn0ke2NhbGxlZVN0cn0ke25lZWRzUGFyZW5zID8gXCIpXCIgOiBcIlwifSgke2UuYXJndW1lbnRzLm1hcChyZW5kZXJFeHByKS5qb2luKFwiLCBcIil9KWA7XG4gICAgfVxuICAgIGNhc2UgXCJNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgICByZXR1cm4gZS5jb21wdXRlZFxuICAgICAgICA/IGAke3JlbmRlckV4cHIoZS5vYmplY3QpfVske3JlbmRlckV4cHIoZS5wcm9wZXJ0eSl9XWBcbiAgICAgICAgOiBgJHtyZW5kZXJFeHByKGUub2JqZWN0KX0uJHtyZW5kZXJFeHByKGUucHJvcGVydHkpfWA7XG4gICAgY2FzZSBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCI6XG4gICAgICByZXR1cm4gYCR7cmVuZGVyRXhwcihlLmxlZnQpfSAke2Uub3BlcmF0b3J9ICR7cmVuZGVyRXhwcihlLnJpZ2h0KX1gO1xuICAgIGNhc2UgXCJVcGRhdGVFeHByZXNzaW9uXCI6XG4gICAgICByZXR1cm4gZS5wcmVmaXhcbiAgICAgICAgPyBgJHtlLm9wZXJhdG9yfSR7cmVuZGVyRXhwcihlLmFyZ3VtZW50KX1gXG4gICAgICAgIDogYCR7cmVuZGVyRXhwcihlLmFyZ3VtZW50KX0ke2Uub3BlcmF0b3J9YDtcbiAgICBjYXNlIFwiQmluYXJ5RXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJMb2dpY2FsRXhwcmVzc2lvblwiOlxuICAgICAgcmV0dXJuIGAoJHtyZW5kZXJFeHByKGUubGVmdCl9ICR7ZS5vcGVyYXRvcn0gJHtyZW5kZXJFeHByKGUucmlnaHQpfSlgO1xuICAgIGNhc2UgXCJVbmFyeUV4cHJlc3Npb25cIjpcbiAgICAgIHJldHVybiBgKCR7ZS5vcGVyYXRvcn0ke3JlbmRlckV4cHIoZS5hcmd1bWVudCl9KWA7XG4gICAgY2FzZSBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiOlxuICAgICAgcmV0dXJuIGAoJHtyZW5kZXJFeHByKGUudGVzdCl9ID8gJHtyZW5kZXJFeHByKGUuY29uc2VxdWVudCl9IDogJHtyZW5kZXJFeHByKGUuYWx0ZXJuYXRlKX0pYDtcbiAgICBjYXNlIFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIjpcbiAgICAgIHJldHVybiByZW5kZXJBcnJvdyhlKTtcbiAgfVxufTtcblxuY29uc3QgcmVuZGVyUHJvcCA9IChwOiBQcm9wZXJ0eSkgPT4ge1xuICBjb25zdCBrZXkgPVxuICAgIHAua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiID8gcC5rZXkubmFtZSA6IHJlbmRlckxpdGVyYWwocC5rZXkudmFsdWUpO1xuICBpZiAocC5zaG9ydGhhbmQgJiYgcC52YWx1ZS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBwLnZhbHVlLm5hbWUgPT09IGtleSkgcmV0dXJuIGtleTtcbiAgcmV0dXJuIGAke2tleX06ICR7cmVuZGVyRXhwcihwLnZhbHVlKX1gO1xufTtcblxuY29uc3QgcmVuZGVyQXJyb3cgPSAoZTogRXh0cmFjdDxFeHByLCB7IHR5cGU6IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiB9PikgPT4ge1xuICBjb25zdCBwYXJhbXMgPSBgKCR7ZS5wYXJhbXMubWFwKChwKSA9PiBwLm5hbWUpLmpvaW4oXCIsIFwiKX0pYDtcbiAgaWYgKGUuYm9keS50eXBlID09PSBcIkJsb2NrU3RhdGVtZW50XCIpIHtcbiAgICByZXR1cm4gYCR7cGFyYW1zfSA9PiAke3JlbmRlclN0bXQoZS5ib2R5LCB0cnVlKX1gO1xuICB9XG4gIHJldHVybiBgJHtwYXJhbXN9ID0+IHsgX19idXJuKCk7IHJldHVybiAke3JlbmRlckV4cHIoZS5ib2R5KX07IH1gO1xufTtcblxuY29uc3QgcmVuZGVyU3RtdCA9IChzOiBTdG10LCBpbkZuID0gZmFsc2UpOiBzdHJpbmcgPT4ge1xuICBjb25zdCBidXJuID0gaW5GbiA/IFwiX19idXJuKCk7XCIgOiBcIlwiO1xuICBjb25zdCByZW5kZXJMb29wQm9keSA9IChib2R5OiBTdG10KSA9PiB7XG4gICAgaWYgKGJvZHkudHlwZSA9PT0gXCJCbG9ja1N0YXRlbWVudFwiKSB7XG4gICAgICBjb25zdCBpbm5lciA9IGJvZHkuYm9keS5tYXAoKGIpID0+IHJlbmRlclN0bXQoYiwgaW5GbikpLmpvaW4oXCJcIik7XG4gICAgICByZXR1cm4gYHtfX2J1cm4oKTske2lubmVyfX1gO1xuICAgIH1cbiAgICByZXR1cm4gYHtfX2J1cm4oKTske3JlbmRlclN0bXQoYm9keSwgaW5Gbil9fWA7XG4gIH07XG4gIHN3aXRjaCAocy50eXBlKSB7XG4gICAgY2FzZSBcIkJsb2NrU3RhdGVtZW50XCI6XG4gICAgICByZXR1cm4gYHske3MuYm9keS5tYXAoKGIpID0+IHJlbmRlclN0bXQoYiwgaW5GbikpLmpvaW4oXCJcIil9fWA7XG4gICAgY2FzZSBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIjpcbiAgICAgIHJldHVybiBgJHtidXJufSR7cmVuZGVyRXhwcihzLmV4cHJlc3Npb24pfTtgO1xuICAgIGNhc2UgXCJJZlN0YXRlbWVudFwiOiB7XG4gICAgICBjb25zdCB3cmFwID0gKHN0bXQ6IFN0bXQpID0+XG4gICAgICAgIHN0bXQudHlwZSA9PT0gXCJCbG9ja1N0YXRlbWVudFwiID8gcmVuZGVyU3RtdChzdG10LCBpbkZuKSA6IGB7JHtyZW5kZXJTdG10KHN0bXQsIGluRm4pfX1gO1xuICAgICAgcmV0dXJuIGAke2J1cm59aWYgKCR7cmVuZGVyRXhwcihzLnRlc3QpfSkgJHt3cmFwKHMuY29uc2VxdWVudCl9JHtzLmFsdGVybmF0ZSA/IGAgZWxzZSAke3dyYXAocy5hbHRlcm5hdGUpfWAgOiBcIlwifWA7XG4gICAgfVxuICAgIGNhc2UgXCJSZXR1cm5TdGF0ZW1lbnRcIjpcbiAgICAgIHJldHVybiBgJHtidXJufXJldHVybiR7cy5hcmd1bWVudCA/IGAgJHtyZW5kZXJFeHByKHMuYXJndW1lbnQpfWAgOiBcIlwifTtgO1xuICAgIGNhc2UgXCJWYXJpYWJsZURlY2xhcmF0aW9uXCI6XG4gICAgICByZXR1cm4gYCR7YnVybn0ke3Mua2luZH0gJHtzLmRlY2xhcmF0aW9ucy5tYXAocmVuZGVyRGVjbCkuam9pbihcIiwgXCIpfTtgO1xuICAgIGNhc2UgXCJCcmVha1N0YXRlbWVudFwiOlxuICAgICAgcmV0dXJuIGAke2J1cm59YnJlYWs7YDtcbiAgICBjYXNlIFwiQ29udGludWVTdGF0ZW1lbnRcIjpcbiAgICAgIHJldHVybiBgJHtidXJufWNvbnRpbnVlO2A7XG4gICAgY2FzZSBcIldoaWxlU3RhdGVtZW50XCI6XG4gICAgICByZXR1cm4gYCR7YnVybn13aGlsZSAoJHtyZW5kZXJFeHByKHMudGVzdCl9KSAke3JlbmRlckxvb3BCb2R5KHMuYm9keSl9YDtcbiAgICBjYXNlIFwiRm9yU3RhdGVtZW50XCI6IHtcbiAgICAgIGNvbnN0IGluaXQgPVxuICAgICAgICBzLmluaXQgPT0gbnVsbFxuICAgICAgICAgID8gXCJcIlxuICAgICAgICAgIDogQXJyYXkuaXNBcnJheShzLmluaXQpXG4gICAgICAgICAgPyBgJHtzLmluaXRLaW5kfSAke3MuaW5pdC5tYXAocmVuZGVyRGVjbCkuam9pbihcIiwgXCIpfWBcbiAgICAgICAgICA6IHJlbmRlckV4cHIocy5pbml0KTtcbiAgICAgIGNvbnN0IHRlc3QgPSBzLnRlc3QgPyByZW5kZXJFeHByKHMudGVzdCkgOiBcIlwiO1xuICAgICAgY29uc3QgdXBkYXRlID0gcy51cGRhdGUgPyByZW5kZXJFeHByKHMudXBkYXRlKSA6IFwiXCI7XG4gICAgICByZXR1cm4gYCR7YnVybn1mb3IgKCR7aW5pdH07ICR7dGVzdH07ICR7dXBkYXRlfSkgJHtyZW5kZXJMb29wQm9keShzLmJvZHkpfWA7XG4gICAgfVxuICAgIGNhc2UgXCJGb3JJblN0YXRlbWVudFwiOiB7XG4gICAgICBjb25zdCBsZWZ0ID0gQXJyYXkuaXNBcnJheShzLmxlZnQpXG4gICAgICAgID8gYCR7cy5sZWZ0S2luZH0gJHtzLmxlZnQubWFwKHJlbmRlckRlY2wpLmpvaW4oXCIsIFwiKX1gXG4gICAgICAgIDogcmVuZGVyRXhwcihzLmxlZnQpO1xuICAgICAgcmV0dXJuIGAke2J1cm59Zm9yICgke2xlZnR9IGluICR7cmVuZGVyRXhwcihzLnJpZ2h0KX0pICR7cmVuZGVyTG9vcEJvZHkocy5ib2R5KX1gO1xuICAgIH1cbiAgICBjYXNlIFwiRm9yT2ZTdGF0ZW1lbnRcIjoge1xuICAgICAgY29uc3QgbGVmdCA9IEFycmF5LmlzQXJyYXkocy5sZWZ0KVxuICAgICAgICA/IGAke3MubGVmdEtpbmR9ICR7cy5sZWZ0Lm1hcChyZW5kZXJEZWNsKS5qb2luKFwiLCBcIil9YFxuICAgICAgICA6IHJlbmRlckV4cHIocy5sZWZ0KTtcbiAgICAgIHJldHVybiBgJHtidXJufWZvciAoJHtsZWZ0fSBvZiAke3JlbmRlckV4cHIocy5yaWdodCl9KSAke3JlbmRlckxvb3BCb2R5KHMuYm9keSl9YDtcbiAgICB9XG4gIH1cbn07XG5cbmNvbnN0IHJlbmRlckRlY2wgPSAoZDogVmFyRGVjbCkgPT5cbiAgYCR7cmVuZGVyUGF0dGVybihkLmlkKX0ke2QuaW5pdCA/IGAgPSAke3JlbmRlckV4cHIoZC5pbml0KX1gIDogXCJcIn1gO1xuXG5jb25zdCByZW5kZXJQYXR0ZXJuID0gKHA6IFBhdHRlcm4pOiBzdHJpbmcgPT4ge1xuICBpZiAocC50eXBlID09PSBcIklkZW50aWZpZXJcIikgcmV0dXJuIHAubmFtZTtcbiAgaWYgKHAudHlwZSA9PT0gXCJBcnJheVBhdHRlcm5cIikgcmV0dXJuIGBbJHtwLmVsZW1lbnRzLm1hcCgoZSkgPT4gZS5uYW1lKS5qb2luKFwiLCBcIil9XWA7XG4gIHJldHVybiBgeyR7cC5wcm9wZXJ0aWVzLm1hcCgoZSkgPT4gZS5uYW1lKS5qb2luKFwiLCBcIil9fWA7XG59O1xuXG5leHBvcnQgY29uc3QgcmVuZGVyV2l0aEZ1ZWwgPSAocHJvZ3JhbTogUHJvZ3JhbSwgZnVlbCA9IDEwMDAwKSA9PiB7XG4gIGNvbnN0IHByZWx1ZGUgPSBgbGV0IF9fZnVlbCA9ICR7ZnVlbH07IGNvbnN0IF9fYnVybiA9ICgpID0+IHsgaWYgKC0tX19mdWVsIDwgMCkgdGhyb3cgbmV3IEVycm9yKFwiZnVlbCBleGhhdXN0ZWRcIik7IH07YDtcbiAgY29uc3QgYm9keSA9IHByb2dyYW0uYm9keS5tYXAoKHMpID0+IHJlbmRlclN0bXQocywgdHJ1ZSkpLmpvaW4oXCJcIik7XG4gIHJldHVybiBgJHtwcmVsdWRlfSR7Ym9keX1gO1xufTtcblxuZXhwb3J0IGNvbnN0IHJlbmRlclJ1bm5lcldpdGhGdWVsID0gKHByb2dyYW06IFByb2dyYW0sIGZ1ZWwgPSAxMDAwMCkgPT4ge1xuICBjb25zdCBwcmVsdWRlID0gYGxldCBfX2Z1ZWwgPSAke2Z1ZWx9OyBjb25zdCBfX2J1cm4gPSAoKSA9PiB7IGlmICgtLV9fZnVlbCA8IDApIHRocm93IG5ldyBFcnJvcihcImZ1ZWwgZXhoYXVzdGVkXCIpOyB9O2A7XG4gIGNvbnN0IGJvZHkgPSBwcm9ncmFtLmJvZHkubWFwKChzKSA9PiByZW5kZXJTdG10KHMsIHRydWUpKS5qb2luKFwiXCIpO1xuICByZXR1cm4gYCR7cHJlbHVkZX1jb25zdCBfX3J1biA9ICgpID0+IHske2JvZHl9fTsgdHJ5IHsgY29uc3Qgb2sgPSBfX3J1bigpOyByZXR1cm4geyBvaywgZnVlbDogX19mdWVsIH07IH0gY2F0Y2ggKGVycikgeyByZXR1cm4geyBlcnI6IFN0cmluZyhlcnIpLCBmdWVsOiBfX2Z1ZWwgfTsgfWA7XG59O1xuXG5leHBvcnQgY29uc3QgcmVuZGVyUnVubmVyV2l0aEZ1ZWxTaGFyZWQgPSAocHJvZ3JhbTogUHJvZ3JhbSwgZnVlbFJlZk5hbWUgPSBcIl9fZnVlbFwiKSA9PiB7XG4gIGNvbnN0IHByZWx1ZGUgPSBgY29uc3QgX19idXJuID0gKCkgPT4geyBpZiAoLS0ke2Z1ZWxSZWZOYW1lfS52YWx1ZSA8IDApIHRocm93IG5ldyBFcnJvcihcImZ1ZWwgZXhoYXVzdGVkXCIpOyB9O2A7XG4gIGNvbnN0IGJvZHkgPSBwcm9ncmFtLmJvZHkubWFwKChzKSA9PiByZW5kZXJTdG10KHMsIHRydWUpKS5qb2luKFwiXCIpO1xuICByZXR1cm4gYCR7cHJlbHVkZX1jb25zdCBfX3J1biA9ICgpID0+IHske2JvZHl9fTsgdHJ5IHsgY29uc3Qgb2sgPSBfX3J1bigpOyByZXR1cm4geyBvaywgZnVlbDogJHtmdWVsUmVmTmFtZX0udmFsdWUgfTsgfSBjYXRjaCAoZXJyKSB7IHJldHVybiB7IGVycjogU3RyaW5nKGVyciksIGZ1ZWw6ICR7ZnVlbFJlZk5hbWV9LnZhbHVlIH07IH1gO1xufTtcblxuZXhwb3J0IGNvbnN0IHJlbmRlclJ1bm5lcldpdGhGdWVsQXN5bmMgPSAocHJvZ3JhbTogUHJvZ3JhbSwgZnVlbCA9IDEwMDAwKSA9PiB7XG4gIGNvbnN0IHByZWx1ZGUgPSBgbGV0IF9fZnVlbCA9ICR7ZnVlbH07IGNvbnN0IF9fYnVybiA9ICgpID0+IHsgaWYgKC0tX19mdWVsIDwgMCkgdGhyb3cgbmV3IEVycm9yKFwiZnVlbCBleGhhdXN0ZWRcIik7IH07YDtcbiAgY29uc3QgYm9keSA9IHByb2dyYW0uYm9keS5tYXAoKHMpID0+IHJlbmRlclN0bXQocywgdHJ1ZSkpLmpvaW4oXCJcIik7XG4gIHJldHVybiBgJHtwcmVsdWRlfWNvbnN0IF9fcnVuID0gYXN5bmMgKCkgPT4geyR7Ym9keX19OyByZXR1cm4gX19ydW4oKS50aGVuKG9rID0+ICh7IG9rLCBmdWVsOiBfX2Z1ZWwgfSkpLmNhdGNoKGVyciA9PiAoeyBlcnI6IFN0cmluZyhlcnIpLCBmdWVsOiBfX2Z1ZWwgfSkpO2A7XG59O1xuXG5leHBvcnQgdHlwZSBydW5SZXMgPSB7IG9rOiB1bmtub3duOyBmdWVsOiBudW1iZXIgfSB8IHsgZXJyOiBzdHJpbmc7IGZ1ZWw6IG51bWJlciB9O1xuXG5jb25zdCBzdHJpbmdpZnlFcnJvciA9IChlcnI6IHVua25vd24pOiBzdHJpbmcgPT4ge1xuICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICBjb25zdCBzdGFjayA9IGVyci5zdGFjayB8fCAnJztcbiAgICBjb25zdCBwcmVmaXggPSBgJHtlcnIubmFtZX06ICR7ZXJyLm1lc3NhZ2V9YDtcbiAgICBjb25zdCBjbGVhblN0YWNrID0gc3RhY2tcbiAgICAgIC5yZXBsYWNlKC9eW15cXG5dKlxcbj8vLCAnJylcbiAgICAgIC5yZXBsYWNlKC9zcGFjZXRpbWVkYl9tb2R1bGU6KFxcZCspOihcXGQrKS9nLCAnPGJ1bmRsZWQ6JDE6JDI+Jyk7XG4gICAgcmV0dXJuIGNsZWFuU3RhY2sgPyBgJHtwcmVmaXh9XFxuJHtjbGVhblN0YWNrfWAgOiBwcmVmaXg7XG4gIH1cbiAgaWYgKHR5cGVvZiBlcnIgPT09ICdvYmplY3QnICYmIGVyciAhPT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZXJyKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBTdHJpbmcoZXJyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFN0cmluZyhlcnIpO1xufTtcblxuZXhwb3J0IGNvbnN0IHJ1bldpdGhGdWVsID0gKFxuICBzcmM6IHN0cmluZyxcbiAgZnVlbCA9IDEwMDAwLFxuICBlbnY6IFJlY29yZDxzdHJpbmcsIHVua25vd24+ID0ge30sXG4pOiBydW5SZXMgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHByb2dyYW0gPSBwYXJzZShzcmMpO1xuICAgIGNvbnN0IHByb3RvRXJycyA9IHZhbGlkYXRlTm9Qcm90b3R5cGUocHJvZ3JhbSk7XG4gICAgaWYgKHByb3RvRXJycy5sZW5ndGgpIHJldHVybiB7IGVycjogXCJwcm90b3R5cGUgYWNjZXNzXCIsIGZ1ZWwgfTtcbiAgICByZXR1cm4gKG5ldyBGdW5jdGlvbiguLi5PYmplY3Qua2V5cyhlbnYpLHJlbmRlclJ1bm5lcldpdGhGdWVsKHByb2dyYW0sIGZ1ZWwpKSBhcyAoLi4uYXJnczp1bmtub3duW10pID0+IHJ1blJlcykoLi4uT2JqZWN0LnZhbHVlcyhlbnYpKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc29sZS5sb2coXCJydW4gd2l0aCBGdWVsIGVycm9yOiBcIixlcnIpXG4gICAgcmV0dXJuIHtlcnI6IHN0cmluZ2lmeUVycm9yKGVyciksIGZ1ZWwgfTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHJ1bldpdGhGdWVsU2hhcmVkID0gKFxuICBzcmM6IHN0cmluZyxcbiAgZnVlbFJlZjogeyB2YWx1ZTogbnVtYmVyIH0sXG4gIGVudjogUmVjb3JkPHN0cmluZywgdW5rbm93bj4gPSB7fSxcbiAgZnVlbFJlZk5hbWUgPSBcIl9fZnVlbFwiXG4pOiBydW5SZXMgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHByb2dyYW0gPSBwYXJzZShzcmMpO1xuICAgIGNvbnN0IHByb3RvRXJycyA9IHZhbGlkYXRlTm9Qcm90b3R5cGUocHJvZ3JhbSk7XG4gICAgaWYgKHByb3RvRXJycy5sZW5ndGgpIHJldHVybiB7IGVycjogXCJwcm90b3R5cGUgYWNjZXNzXCIsIGZ1ZWw6IGZ1ZWxSZWYudmFsdWUgfTtcbiAgICBjb25zdCBjb2RlID0gcmVuZGVyUnVubmVyV2l0aEZ1ZWxTaGFyZWQocHJvZ3JhbSwgZnVlbFJlZk5hbWUpO1xuICAgIGNvbnN0IGZ1bGxFbnYgPSB7IC4uLmVudiwgW2Z1ZWxSZWZOYW1lXTogZnVlbFJlZiB9O1xuICAgIHJldHVybiAobmV3IEZ1bmN0aW9uKC4uLk9iamVjdC5rZXlzKGZ1bGxFbnYpLCBjb2RlKSBhcyAoLi4uYXJnczp1bmtub3duW10pID0+IHJ1blJlcykoLi4uT2JqZWN0LnZhbHVlcyhmdWxsRW52KSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiB7IGVycjogc3RyaW5naWZ5RXJyb3IoZXJyKSwgZnVlbDogZnVlbFJlZi52YWx1ZSB9O1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgcnVuV2l0aEZ1ZWxBc3luYyA9IGFzeW5jIChcbiAgc3JjOiBzdHJpbmcsXG4gIGZ1ZWwgPSAxMDAwMCxcbiAgZW52OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiA9IHt9XG4pOiBQcm9taXNlPHJ1blJlcz4gPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHByb2dyYW0gPSBwYXJzZShzcmMpO1xuICAgIGNvbnN0IHByb3RvRXJycyA9IHZhbGlkYXRlTm9Qcm90b3R5cGUocHJvZ3JhbSk7XG4gICAgaWYgKHByb3RvRXJycy5sZW5ndGgpIHJldHVybiB7IGVycjogXCJwcm90b3R5cGUgYWNjZXNzXCIsIGZ1ZWwgfTtcbiAgICBjb25zdCBjb2RlID0gcmVuZGVyUnVubmVyV2l0aEZ1ZWxBc3luYyhwcm9ncmFtLCBmdWVsKTtcbiAgICBjb25zdCBmbiA9IG5ldyBGdW5jdGlvbiguLi5PYmplY3Qua2V5cyhlbnYpLCBjb2RlKSBhcyAoLi4uYXJnczp1bmtub3duW10pID0+IFByb21pc2U8cnVuUmVzPjtcbiAgICByZXR1cm4gYXdhaXQgZm4oLi4uT2JqZWN0LnZhbHVlcyhlbnYpKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIHsgZXJyOiBzdHJpbmdpZnlFcnJvcihlcnIpLCBmdWVsIH07XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZSA9IChzcmM6IHN0cmluZyk6IFByb2dyYW0gPT4ge1xuICBjb25zdCB0b2tlbnMgPSB0b2tlbml6ZShzcmMpO1xuICBsZXQgaSA9IDA7XG4gIGNvbnN0IHBlZWsgPSAoKSA9PiB0b2tlbnNbaV07XG4gIGNvbnN0IG5leHQgPSAoKSA9PiB0b2tlbnNbaSsrXTtcbiAgY29uc3QgZWF0ID0gKHR5cGU6IFRva2VuVHlwZSwgdmFsdWU/OiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCB0ID0gcGVlaygpO1xuICAgIGlmICh0LnR5cGUgIT09IHR5cGUgfHwgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdC52YWx1ZSAhPT0gdmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkICR7dmFsdWUgPz8gdHlwZX0gYXQgJHt0LnBvc31gKTtcbiAgICB9XG4gICAgcmV0dXJuIG5leHQoKTtcbiAgfTtcbiAgY29uc3QgbWF0Y2ggPSAodHlwZTogVG9rZW5UeXBlLCB2YWx1ZT86IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IHQgPSBwZWVrKCk7XG4gICAgcmV0dXJuIHQudHlwZSA9PT0gdHlwZSAmJiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0LnZhbHVlID09PSB2YWx1ZSk7XG4gIH07XG5cbiAgY29uc3QgcGFyc2VQcm9ncmFtID0gKCk6IFByb2dyYW0gPT4ge1xuICAgIGNvbnN0IGJvZHk6IFN0bXRbXSA9IFtdO1xuICAgIHdoaWxlICghbWF0Y2goXCJlb2ZcIikpIGJvZHkucHVzaChwYXJzZVN0YXRlbWVudCgpKTtcbiAgICByZXR1cm4geyB0eXBlOiBcIlByb2dyYW1cIiwgYm9keSB9O1xuICB9O1xuXG4gIGNvbnN0IHBhcnNlU3RhdGVtZW50ID0gKCk6IFN0bXQgPT4ge1xuICAgIGlmIChtYXRjaChcInB1bmN0XCIsIFwie1wiKSkgcmV0dXJuIHBhcnNlQmxvY2soKTtcbiAgICBpZiAobWF0Y2goXCJrZXl3b3JkXCIsIFwiaWZcIikpIHJldHVybiBwYXJzZUlmKCk7XG4gICAgaWYgKG1hdGNoKFwia2V5d29yZFwiLCBcIndoaWxlXCIpKSByZXR1cm4gcGFyc2VXaGlsZSgpO1xuICAgIGlmIChtYXRjaChcImtleXdvcmRcIiwgXCJmb3JcIikpIHJldHVybiBwYXJzZUZvcigpO1xuICAgIGlmIChtYXRjaChcImtleXdvcmRcIiwgXCJicmVha1wiKSkgeyBuZXh0KCk7IGlmIChtYXRjaChcInB1bmN0XCIsIFwiO1wiKSkgbmV4dCgpOyByZXR1cm4geyB0eXBlOiBcIkJyZWFrU3RhdGVtZW50XCIgfTsgfVxuICAgIGlmIChtYXRjaChcImtleXdvcmRcIiwgXCJjb250aW51ZVwiKSkgeyBuZXh0KCk7IGlmIChtYXRjaChcInB1bmN0XCIsIFwiO1wiKSkgbmV4dCgpOyByZXR1cm4geyB0eXBlOiBcIkNvbnRpbnVlU3RhdGVtZW50XCIgfTsgfVxuICAgIGlmIChtYXRjaChcImtleXdvcmRcIiwgXCJyZXR1cm5cIikpIHJldHVybiBwYXJzZVJldHVybigpO1xuICAgIGlmIChtYXRjaChcImtleXdvcmRcIiwgXCJsZXRcIikgfHwgbWF0Y2goXCJrZXl3b3JkXCIsIFwiY29uc3RcIikpIHJldHVybiBwYXJzZVZhckRlY2woKTtcbiAgICBjb25zdCBleHByID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgaWYgKG1hdGNoKFwicHVuY3RcIiwgXCI7XCIpKSBuZXh0KCk7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJFeHByZXNzaW9uU3RhdGVtZW50XCIsIGV4cHJlc3Npb246IGV4cHIgfTtcbiAgfTtcblxuICBjb25zdCBwYXJzZUJsb2NrID0gKCk6IEJsb2NrU3RhdGVtZW50ID0+IHtcbiAgICBlYXQoXCJwdW5jdFwiLCBcIntcIik7XG4gICAgY29uc3QgYm9keTogU3RtdFtdID0gW107XG4gICAgd2hpbGUgKCFtYXRjaChcInB1bmN0XCIsIFwifVwiKSkgYm9keS5wdXNoKHBhcnNlU3RhdGVtZW50KCkpO1xuICAgIGVhdChcInB1bmN0XCIsIFwifVwiKTtcbiAgICByZXR1cm4geyB0eXBlOiBcIkJsb2NrU3RhdGVtZW50XCIsIGJvZHkgfTtcbiAgfTtcblxuICBjb25zdCBwYXJzZUlmID0gKCk6IFN0bXQgPT4ge1xuICAgIGVhdChcImtleXdvcmRcIiwgXCJpZlwiKTtcbiAgICBlYXQoXCJwdW5jdFwiLCBcIihcIik7XG4gICAgY29uc3QgdGVzdCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgIGVhdChcInB1bmN0XCIsIFwiKVwiKTtcbiAgICBjb25zdCBjb25zZXF1ZW50ID0gcGFyc2VTdGF0ZW1lbnQoKTtcbiAgICBjb25zdCBhbHRlcm5hdGUgPSBtYXRjaChcImtleXdvcmRcIiwgXCJlbHNlXCIpID8gKG5leHQoKSwgcGFyc2VTdGF0ZW1lbnQoKSkgOiBudWxsO1xuICAgIHJldHVybiB7IHR5cGU6IFwiSWZTdGF0ZW1lbnRcIiwgdGVzdCwgY29uc2VxdWVudCwgYWx0ZXJuYXRlIH07XG4gIH07XG5cbiAgY29uc3QgcGFyc2VSZXR1cm4gPSAoKTogU3RtdCA9PiB7XG4gICAgZWF0KFwia2V5d29yZFwiLCBcInJldHVyblwiKTtcbiAgICBpZiAobWF0Y2goXCJwdW5jdFwiLCBcIjtcIikpIHtcbiAgICAgIG5leHQoKTtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwiUmV0dXJuU3RhdGVtZW50XCIsIGFyZ3VtZW50OiBudWxsIH07XG4gICAgfVxuICAgIGNvbnN0IGFyZ3VtZW50ID0gbWF0Y2goXCJwdW5jdFwiLCBcIn1cIikgPyBudWxsIDogcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgaWYgKG1hdGNoKFwicHVuY3RcIiwgXCI7XCIpKSBuZXh0KCk7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJSZXR1cm5TdGF0ZW1lbnRcIiwgYXJndW1lbnQgfTtcbiAgfTtcblxuICBjb25zdCBwYXJzZVZhckRlY2xDb3JlID0gKGNvbnN1bWVTZW1pOiBib29sZWFuKSA9PiB7XG4gICAgY29uc3Qga2luZCA9IG5leHQoKS52YWx1ZSBhcyBcImxldFwiIHwgXCJjb25zdFwiO1xuICAgIGNvbnN0IGRlY2xhcmF0aW9uczogVmFyRGVjbFtdID0gW107XG4gICAgZG8ge1xuICAgICAgY29uc3QgaWQgPSBwYXJzZVBhdHRlcm4oKTtcbiAgICAgIGNvbnN0IGluaXQgPSBtYXRjaChcIm9wZXJhdG9yXCIsIFwiPVwiKSA/IChuZXh0KCksIHBhcnNlRXhwcmVzc2lvbigpKSA6IG51bGw7XG4gICAgICBkZWNsYXJhdGlvbnMucHVzaCh7IHR5cGU6IFwiVmFyaWFibGVEZWNsYXJhdG9yXCIsIGlkLCBpbml0IH0pO1xuICAgICAgaWYgKCFtYXRjaChcInB1bmN0XCIsIFwiLFwiKSkgYnJlYWs7XG4gICAgICBuZXh0KCk7XG4gICAgfSB3aGlsZSAodHJ1ZSk7XG4gICAgaWYgKGNvbnN1bWVTZW1pICYmIG1hdGNoKFwicHVuY3RcIiwgXCI7XCIpKSBuZXh0KCk7XG4gICAgcmV0dXJuIHsga2luZCwgZGVjbGFyYXRpb25zIH07XG4gIH07XG5cbiAgY29uc3QgcGFyc2VWYXJEZWNsID0gKCk6IFN0bXQgPT4ge1xuICAgIGNvbnN0IHsga2luZCwgZGVjbGFyYXRpb25zIH0gPSBwYXJzZVZhckRlY2xDb3JlKHRydWUpO1xuICAgIHJldHVybiB7IHR5cGU6IFwiVmFyaWFibGVEZWNsYXJhdGlvblwiLCBraW5kLCBkZWNsYXJhdGlvbnMgfTtcbiAgfTtcblxuICBjb25zdCBwYXJzZVdoaWxlID0gKCk6IFN0bXQgPT4ge1xuICAgIGVhdChcImtleXdvcmRcIiwgXCJ3aGlsZVwiKTtcbiAgICBlYXQoXCJwdW5jdFwiLCBcIihcIik7XG4gICAgY29uc3QgdGVzdCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgIGVhdChcInB1bmN0XCIsIFwiKVwiKTtcbiAgICBjb25zdCBib2R5ID0gcGFyc2VTdGF0ZW1lbnQoKTtcbiAgICByZXR1cm4geyB0eXBlOiBcIldoaWxlU3RhdGVtZW50XCIsIHRlc3QsIGJvZHkgfTtcbiAgfTtcblxuICBjb25zdCBwYXJzZUZvciA9ICgpOiBTdG10ID0+IHtcbiAgICBlYXQoXCJrZXl3b3JkXCIsIFwiZm9yXCIpO1xuICAgIGVhdChcInB1bmN0XCIsIFwiKFwiKTtcbiAgICBsZXQgaW5pdDogVmFyRGVjbFtdIHwgRXhwciB8IG51bGwgPSBudWxsO1xuICAgIGxldCBpbml0S2luZDogXCJsZXRcIiB8IFwiY29uc3RcIiB8IG51bGwgPSBudWxsO1xuICAgIGlmICghbWF0Y2goXCJwdW5jdFwiLCBcIjtcIikpIHtcbiAgICAgIGlmIChtYXRjaChcImtleXdvcmRcIiwgXCJsZXRcIikgfHwgbWF0Y2goXCJrZXl3b3JkXCIsIFwiY29uc3RcIikpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VWYXJEZWNsQ29yZShmYWxzZSk7XG4gICAgICAgIGluaXQgPSBwYXJzZWQuZGVjbGFyYXRpb25zO1xuICAgICAgICBpbml0S2luZCA9IHBhcnNlZC5raW5kO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5pdCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobWF0Y2goXCJrZXl3b3JkXCIsIFwiaW5cIikgfHwgbWF0Y2goXCJrZXl3b3JkXCIsIFwib2ZcIikpIHtcbiAgICAgIGNvbnN0IGtpbmQgPSBuZXh0KCkudmFsdWU7XG4gICAgICBjb25zdCByaWdodCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgZWF0KFwicHVuY3RcIiwgXCIpXCIpO1xuICAgICAgY29uc3QgYm9keSA9IHBhcnNlU3RhdGVtZW50KCk7XG4gICAgICBpZiAoIWluaXQpIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgaW5pdGlhbGl6ZXIgYmVmb3JlICR7a2luZH0gYXQgJHtwZWVrKCkucG9zfWApO1xuICAgICAgcmV0dXJuIGtpbmQgPT09IFwiaW5cIlxuICAgICAgICA/IHsgdHlwZTogXCJGb3JJblN0YXRlbWVudFwiLCBsZWZ0OiBpbml0LCBsZWZ0S2luZDogaW5pdEtpbmQsIHJpZ2h0LCBib2R5IH1cbiAgICAgICAgOiB7IHR5cGU6IFwiRm9yT2ZTdGF0ZW1lbnRcIiwgbGVmdDogaW5pdCwgbGVmdEtpbmQ6IGluaXRLaW5kLCByaWdodCwgYm9keSB9O1xuICAgIH1cbiAgICBlYXQoXCJwdW5jdFwiLCBcIjtcIik7XG4gICAgY29uc3QgdGVzdCA9IG1hdGNoKFwicHVuY3RcIiwgXCI7XCIpID8gbnVsbCA6IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgIGVhdChcInB1bmN0XCIsIFwiO1wiKTtcbiAgICBjb25zdCB1cGRhdGUgPSBtYXRjaChcInB1bmN0XCIsIFwiKVwiKSA/IG51bGwgOiBwYXJzZUV4cHJlc3Npb24oKTtcbiAgICBlYXQoXCJwdW5jdFwiLCBcIilcIik7XG4gICAgY29uc3QgYm9keSA9IHBhcnNlU3RhdGVtZW50KCk7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJGb3JTdGF0ZW1lbnRcIiwgaW5pdCwgaW5pdEtpbmQsIHRlc3QsIHVwZGF0ZSwgYm9keSB9O1xuICB9O1xuXG4gIGNvbnN0IHBhcnNlRXhwcmVzc2lvbiA9ICgpOiBFeHByID0+IHBhcnNlQXNzaWdubWVudCgpO1xuXG4gIGNvbnN0IHBhcnNlQXNzaWdubWVudCA9ICgpOiBFeHByID0+IHtcbiAgICBjb25zdCBsZWZ0ID0gcGFyc2VDb25kaXRpb25hbCgpO1xuICAgIGlmIChtYXRjaChcIm9wZXJhdG9yXCIsIFwiPVwiKSB8fCBtYXRjaChcIm9wZXJhdG9yXCIsIFwiKz1cIikgfHwgbWF0Y2goXCJvcGVyYXRvclwiLCBcIi09XCIpIHx8IG1hdGNoKFwib3BlcmF0b3JcIiwgXCIqPVwiKSB8fCBtYXRjaChcIm9wZXJhdG9yXCIsIFwiLz1cIikgfHwgbWF0Y2goXCJvcGVyYXRvclwiLCBcIiU9XCIpKSB7XG4gICAgICBjb25zdCBvcCA9IG5leHQoKS52YWx1ZTtcbiAgICAgIGNvbnN0IHJpZ2h0ID0gcGFyc2VBc3NpZ25tZW50KCk7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCIsIG9wZXJhdG9yOiBvcCwgbGVmdCwgcmlnaHQgfTtcbiAgICB9XG4gICAgcmV0dXJuIGxlZnQ7XG4gIH07XG5cbiAgY29uc3QgcGFyc2VDb25kaXRpb25hbCA9ICgpOiBFeHByID0+IHtcbiAgICBsZXQgdGVzdCA9IHBhcnNlTG9naWNhbE9yKCk7XG4gICAgaWYgKG1hdGNoKFwib3BlcmF0b3JcIiwgXCI/XCIpKSB7XG4gICAgICBuZXh0KCk7XG4gICAgICBjb25zdCBjb25zZXF1ZW50ID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICBlYXQoXCJvcGVyYXRvclwiLCBcIjpcIik7XG4gICAgICBjb25zdCBhbHRlcm5hdGUgPSBwYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCIsIHRlc3QsIGNvbnNlcXVlbnQsIGFsdGVybmF0ZSB9O1xuICAgIH1cbiAgICByZXR1cm4gdGVzdDtcbiAgfTtcblxuICBjb25zdCBwYXJzZUxvZ2ljYWxPciA9ICgpOiBFeHByID0+IHtcbiAgICBsZXQgbGVmdCA9IHBhcnNlTG9naWNhbEFuZCgpO1xuICAgIHdoaWxlIChtYXRjaChcIm9wZXJhdG9yXCIsIFwifHxcIikpIHtcbiAgICAgIGNvbnN0IG9wID0gbmV4dCgpLnZhbHVlO1xuICAgICAgY29uc3QgcmlnaHQgPSBwYXJzZUxvZ2ljYWxBbmQoKTtcbiAgICAgIGxlZnQgPSB7IHR5cGU6IFwiTG9naWNhbEV4cHJlc3Npb25cIiwgb3BlcmF0b3I6IG9wLCBsZWZ0LCByaWdodCB9O1xuICAgIH1cbiAgICByZXR1cm4gbGVmdDtcbiAgfTtcblxuICBjb25zdCBwYXJzZUxvZ2ljYWxBbmQgPSAoKTogRXhwciA9PiB7XG4gICAgbGV0IGxlZnQgPSBwYXJzZUVxdWFsaXR5KCk7XG4gICAgd2hpbGUgKG1hdGNoKFwib3BlcmF0b3JcIiwgXCImJlwiKSkge1xuICAgICAgY29uc3Qgb3AgPSBuZXh0KCkudmFsdWU7XG4gICAgICBjb25zdCByaWdodCA9IHBhcnNlRXF1YWxpdHkoKTtcbiAgICAgIGxlZnQgPSB7IHR5cGU6IFwiTG9naWNhbEV4cHJlc3Npb25cIiwgb3BlcmF0b3I6IG9wLCBsZWZ0LCByaWdodCB9O1xuICAgIH1cbiAgICByZXR1cm4gbGVmdDtcbiAgfTtcblxuICBjb25zdCBwYXJzZUVxdWFsaXR5ID0gKCk6IEV4cHIgPT4ge1xuICAgIGxldCBsZWZ0ID0gcGFyc2VSZWxhdGlvbmFsKCk7XG4gICAgd2hpbGUgKG1hdGNoKFwib3BlcmF0b3JcIiwgXCI9PVwiKSB8fCBtYXRjaChcIm9wZXJhdG9yXCIsIFwiIT1cIikgfHwgbWF0Y2goXCJvcGVyYXRvclwiLCBcIj09PVwiKSB8fCBtYXRjaChcIm9wZXJhdG9yXCIsIFwiIT09XCIpKSB7XG4gICAgICBjb25zdCBvcCA9IG5leHQoKS52YWx1ZTtcbiAgICAgIGNvbnN0IHJpZ2h0ID0gcGFyc2VSZWxhdGlvbmFsKCk7XG4gICAgICBsZWZ0ID0geyB0eXBlOiBcIkJpbmFyeUV4cHJlc3Npb25cIiwgb3BlcmF0b3I6IG9wLCBsZWZ0LCByaWdodCB9O1xuICAgIH1cbiAgICByZXR1cm4gbGVmdDtcbiAgfTtcblxuICBjb25zdCBwYXJzZVJlbGF0aW9uYWwgPSAoKTogRXhwciA9PiB7XG4gICAgbGV0IGxlZnQgPSBwYXJzZUFkZGl0aXZlKCk7XG4gICAgd2hpbGUgKG1hdGNoKFwib3BlcmF0b3JcIiwgXCI8XCIpIHx8IG1hdGNoKFwib3BlcmF0b3JcIiwgXCI8PVwiKSB8fCBtYXRjaChcIm9wZXJhdG9yXCIsIFwiPlwiKSB8fCBtYXRjaChcIm9wZXJhdG9yXCIsIFwiPj1cIikpIHtcbiAgICAgIGNvbnN0IG9wID0gbmV4dCgpLnZhbHVlO1xuICAgICAgY29uc3QgcmlnaHQgPSBwYXJzZUFkZGl0aXZlKCk7XG4gICAgICBsZWZ0ID0geyB0eXBlOiBcIkJpbmFyeUV4cHJlc3Npb25cIiwgb3BlcmF0b3I6IG9wLCBsZWZ0LCByaWdodCB9O1xuICAgIH1cbiAgICByZXR1cm4gbGVmdDtcbiAgfTtcblxuICBjb25zdCBwYXJzZUFkZGl0aXZlID0gKCk6IEV4cHIgPT4ge1xuICAgIGxldCBsZWZ0ID0gcGFyc2VNdWx0aXBsaWNhdGl2ZSgpO1xuICAgIHdoaWxlIChtYXRjaChcIm9wZXJhdG9yXCIsIFwiK1wiKSB8fCBtYXRjaChcIm9wZXJhdG9yXCIsIFwiLVwiKSkge1xuICAgICAgY29uc3Qgb3AgPSBuZXh0KCkudmFsdWU7XG4gICAgICBjb25zdCByaWdodCA9IHBhcnNlTXVsdGlwbGljYXRpdmUoKTtcbiAgICAgIGxlZnQgPSB7IHR5cGU6IFwiQmluYXJ5RXhwcmVzc2lvblwiLCBvcGVyYXRvcjogb3AsIGxlZnQsIHJpZ2h0IH07XG4gICAgfVxuICAgIHJldHVybiBsZWZ0O1xuICB9O1xuXG4gIGNvbnN0IHBhcnNlTXVsdGlwbGljYXRpdmUgPSAoKTogRXhwciA9PiB7XG4gICAgbGV0IGxlZnQgPSBwYXJzZVVuYXJ5KCk7XG4gICAgd2hpbGUgKG1hdGNoKFwib3BlcmF0b3JcIiwgXCIqXCIpIHx8IG1hdGNoKFwib3BlcmF0b3JcIiwgXCIvXCIpIHx8IG1hdGNoKFwib3BlcmF0b3JcIiwgXCIlXCIpKSB7XG4gICAgICBjb25zdCBvcCA9IG5leHQoKS52YWx1ZTtcbiAgICAgIGNvbnN0IHJpZ2h0ID0gcGFyc2VVbmFyeSgpO1xuICAgICAgbGVmdCA9IHsgdHlwZTogXCJCaW5hcnlFeHByZXNzaW9uXCIsIG9wZXJhdG9yOiBvcCwgbGVmdCwgcmlnaHQgfTtcbiAgICB9XG4gICAgcmV0dXJuIGxlZnQ7XG4gIH07XG5cbiAgY29uc3QgcGFyc2VVbmFyeSA9ICgpOiBFeHByID0+IHtcbiAgICBpZiAobWF0Y2goXCJvcGVyYXRvclwiLCBcIisrXCIpIHx8IG1hdGNoKFwib3BlcmF0b3JcIiwgXCItLVwiKSkge1xuICAgICAgY29uc3Qgb3AgPSBuZXh0KCkudmFsdWUgYXMgXCIrK1wiIHwgXCItLVwiO1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJVcGRhdGVFeHByZXNzaW9uXCIsIG9wZXJhdG9yOiBvcCwgYXJndW1lbnQ6IHBhcnNlVW5hcnkoKSwgcHJlZml4OiB0cnVlIH07XG4gICAgfVxuICAgIGlmIChtYXRjaChcIm9wZXJhdG9yXCIsIFwiIVwiKSB8fCBtYXRjaChcIm9wZXJhdG9yXCIsIFwiLVwiKSB8fCBtYXRjaChcIm9wZXJhdG9yXCIsIFwiK1wiKSkge1xuICAgICAgY29uc3Qgb3AgPSBuZXh0KCkudmFsdWU7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIlVuYXJ5RXhwcmVzc2lvblwiLCBvcGVyYXRvcjogb3AsIGFyZ3VtZW50OiBwYXJzZVVuYXJ5KCkgfTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlUG9zdGZpeCgpO1xuICB9O1xuXG4gIGNvbnN0IHBhcnNlUG9zdGZpeCA9ICgpOiBFeHByID0+IHtcbiAgICBsZXQgZXhwciA9IHBhcnNlQXJyb3dPclByaW1hcnkoKTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKG1hdGNoKFwib3BlcmF0b3JcIiwgXCIrK1wiKSB8fCBtYXRjaChcIm9wZXJhdG9yXCIsIFwiLS1cIikpIHtcbiAgICAgICAgY29uc3Qgb3AgPSBuZXh0KCkudmFsdWUgYXMgXCIrK1wiIHwgXCItLVwiO1xuICAgICAgICBleHByID0geyB0eXBlOiBcIlVwZGF0ZUV4cHJlc3Npb25cIiwgb3BlcmF0b3I6IG9wLCBhcmd1bWVudDogZXhwciwgcHJlZml4OiBmYWxzZSB9O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXRjaChcInB1bmN0XCIsIFwiKFwiKSkge1xuICAgICAgICBjb25zdCBhcmdzID0gcGFyc2VBcmd1bWVudHMoKTtcbiAgICAgICAgZXhwciA9IHsgdHlwZTogXCJDYWxsRXhwcmVzc2lvblwiLCBjYWxsZWU6IGV4cHIsIGFyZ3VtZW50czogYXJncyB9O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXRjaChcInB1bmN0XCIsIFwiLlwiKSkge1xuICAgICAgICBuZXh0KCk7XG4gICAgICAgIGNvbnN0IHByb3AgPSBwYXJzZUlkZW50aWZpZXIoKTtcbiAgICAgICAgZXhwciA9IHsgdHlwZTogXCJNZW1iZXJFeHByZXNzaW9uXCIsIG9iamVjdDogZXhwciwgcHJvcGVydHk6IHByb3AsIGNvbXB1dGVkOiBmYWxzZSB9O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXRjaChcInB1bmN0XCIsIFwiW1wiKSkge1xuICAgICAgICBuZXh0KCk7XG4gICAgICAgIGNvbnN0IHByb3AgPSBwYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgZWF0KFwicHVuY3RcIiwgXCJdXCIpO1xuICAgICAgICBleHByID0geyB0eXBlOiBcIk1lbWJlckV4cHJlc3Npb25cIiwgb2JqZWN0OiBleHByLCBwcm9wZXJ0eTogcHJvcCwgY29tcHV0ZWQ6IHRydWUgfTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGV4cHI7XG4gIH07XG5cbiAgY29uc3QgcGFyc2VBcnJvd09yUHJpbWFyeSA9ICgpOiBFeHByID0+IHtcbiAgICBpZiAobWF0Y2goXCJpZGVudGlmaWVyXCIpKSB7XG4gICAgICBjb25zdCBpZCA9IHBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgaWYgKG1hdGNoKFwib3BlcmF0b3JcIiwgXCI9PlwiKSkge1xuICAgICAgICBuZXh0KCk7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBtYXRjaChcInB1bmN0XCIsIFwie1wiKSA/IHBhcnNlQmxvY2soKSA6IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIsIHBhcmFtczogW2lkXSwgYm9keSB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlkO1xuICAgIH1cbiAgICBpZiAobWF0Y2goXCJwdW5jdFwiLCBcIihcIikpIHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gaTtcbiAgICAgIG5leHQoKTtcbiAgICAgIGNvbnN0IHBhcmFtczogSWRlbnRpZmllcltdID0gW107XG4gICAgICBsZXQgaXNQYXJhbXMgPSB0cnVlO1xuICAgICAgaWYgKCFtYXRjaChcInB1bmN0XCIsIFwiKVwiKSkge1xuICAgICAgICBkbyB7XG4gICAgICAgICAgaWYgKCFtYXRjaChcImlkZW50aWZpZXJcIikpIHsgaXNQYXJhbXMgPSBmYWxzZTsgYnJlYWs7IH1cbiAgICAgICAgICBwYXJhbXMucHVzaChwYXJzZUlkZW50aWZpZXIoKSk7XG4gICAgICAgICAgaWYgKCFtYXRjaChcInB1bmN0XCIsIFwiLFwiKSkgYnJlYWs7XG4gICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9IHdoaWxlICh0cnVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1BhcmFtcyAmJiBtYXRjaChcInB1bmN0XCIsIFwiKVwiKSkge1xuICAgICAgICBuZXh0KCk7XG4gICAgICAgIGlmIChtYXRjaChcIm9wZXJhdG9yXCIsIFwiPT5cIikpIHtcbiAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgY29uc3QgYm9keSA9IG1hdGNoKFwicHVuY3RcIiwgXCJ7XCIpID8gcGFyc2VCbG9jaygpIDogcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiLCBwYXJhbXMsIGJvZHkgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaSA9IHN0YXJ0O1xuICAgICAgZWF0KFwicHVuY3RcIiwgXCIoXCIpO1xuICAgICAgY29uc3QgZXhwciA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgZWF0KFwicHVuY3RcIiwgXCIpXCIpO1xuICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZVByaW1hcnkoKTtcbiAgfTtcblxuICBjb25zdCBwYXJzZVByaW1hcnkgPSAoKTogRXhwciA9PiB7XG4gICAgaWYgKG1hdGNoKFwibnVtYmVyXCIpKSByZXR1cm4geyB0eXBlOiBcIkxpdGVyYWxcIiwgdmFsdWU6IE51bWJlcihuZXh0KCkudmFsdWUpIH07XG4gICAgaWYgKG1hdGNoKFwic3RyaW5nXCIpKSByZXR1cm4geyB0eXBlOiBcIkxpdGVyYWxcIiwgdmFsdWU6IG5leHQoKS52YWx1ZSB9O1xuICAgIGlmIChtYXRjaChcImtleXdvcmRcIiwgXCJ0cnVlXCIpKSB7IG5leHQoKTsgcmV0dXJuIHsgdHlwZTogXCJMaXRlcmFsXCIsIHZhbHVlOiB0cnVlIH07IH1cbiAgICBpZiAobWF0Y2goXCJrZXl3b3JkXCIsIFwiZmFsc2VcIikpIHsgbmV4dCgpOyByZXR1cm4geyB0eXBlOiBcIkxpdGVyYWxcIiwgdmFsdWU6IGZhbHNlIH07IH1cbiAgICBpZiAobWF0Y2goXCJrZXl3b3JkXCIsIFwibnVsbFwiKSkgeyBuZXh0KCk7IHJldHVybiB7IHR5cGU6IFwiTGl0ZXJhbFwiLCB2YWx1ZTogbnVsbCB9OyB9XG4gICAgaWYgKG1hdGNoKFwicHVuY3RcIiwgXCJbXCIpKSByZXR1cm4gcGFyc2VBcnJheSgpO1xuICAgIGlmIChtYXRjaChcInB1bmN0XCIsIFwie1wiKSkgcmV0dXJuIHBhcnNlT2JqZWN0KCk7XG4gICAgaWYgKG1hdGNoKFwiaWRlbnRpZmllclwiKSkgcmV0dXJuIHBhcnNlSWRlbnRpZmllcigpO1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCB0b2tlbiAke3BlZWsoKS50eXBlfSAke3BlZWsoKS52YWx1ZX0gYXQgJHtwZWVrKCkucG9zfWApO1xuICB9O1xuXG4gIGNvbnN0IHBhcnNlQXJyYXkgPSAoKTogRXhwciA9PiB7XG4gICAgZWF0KFwicHVuY3RcIiwgXCJbXCIpO1xuICAgIGNvbnN0IGVsZW1lbnRzOiBFeHByW10gPSBbXTtcbiAgICBpZiAoIW1hdGNoKFwicHVuY3RcIiwgXCJdXCIpKSB7XG4gICAgICBkbyB7XG4gICAgICAgIGVsZW1lbnRzLnB1c2gocGFyc2VFeHByZXNzaW9uKCkpO1xuICAgICAgICBpZiAoIW1hdGNoKFwicHVuY3RcIiwgXCIsXCIpKSBicmVhaztcbiAgICAgICAgbmV4dCgpO1xuICAgICAgfSB3aGlsZSAodHJ1ZSk7XG4gICAgfVxuICAgIGVhdChcInB1bmN0XCIsIFwiXVwiKTtcbiAgICByZXR1cm4geyB0eXBlOiBcIkFycmF5RXhwcmVzc2lvblwiLCBlbGVtZW50cyB9O1xuICB9O1xuXG4gIGNvbnN0IHBhcnNlT2JqZWN0ID0gKCk6IEV4cHIgPT4ge1xuICAgIGVhdChcInB1bmN0XCIsIFwie1wiKTtcbiAgICBjb25zdCBwcm9wZXJ0aWVzOiBQcm9wZXJ0eVtdID0gW107XG4gICAgaWYgKCFtYXRjaChcInB1bmN0XCIsIFwifVwiKSkge1xuICAgICAgZG8ge1xuICAgICAgICBsZXQga2V5OiBJZGVudGlmaWVyIHwgTGl0ZXJhbDtcbiAgICAgICAgbGV0IHNob3J0aGFuZCA9IGZhbHNlO1xuICAgICAgICBpZiAobWF0Y2goXCJpZGVudGlmaWVyXCIpKSBrZXkgPSBwYXJzZUlkZW50aWZpZXIoKTtcbiAgICAgICAgZWxzZSBpZiAobWF0Y2goXCJzdHJpbmdcIikpIGtleSA9IHsgdHlwZTogXCJMaXRlcmFsXCIsIHZhbHVlOiBuZXh0KCkudmFsdWUgfTtcbiAgICAgICAgZWxzZSBpZiAobWF0Y2goXCJudW1iZXJcIikpIGtleSA9IHsgdHlwZTogXCJMaXRlcmFsXCIsIHZhbHVlOiBOdW1iZXIobmV4dCgpLnZhbHVlKSB9O1xuICAgICAgICBlbHNlIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgb2JqZWN0IGtleSBhdCAke3BlZWsoKS5wb3N9YCk7XG4gICAgICAgIGxldCB2YWx1ZTogRXhwcjtcbiAgICAgICAgaWYgKG1hdGNoKFwib3BlcmF0b3JcIiwgXCI6XCIpKSB7XG4gICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgIHZhbHVlID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGtleS50eXBlICE9PSBcIklkZW50aWZpZXJcIikgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCAnOicgYWZ0ZXIga2V5IGF0ICR7cGVlaygpLnBvc31gKTtcbiAgICAgICAgICB2YWx1ZSA9IGtleTtcbiAgICAgICAgICBzaG9ydGhhbmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHByb3BlcnRpZXMucHVzaCh7IHR5cGU6IFwiUHJvcGVydHlcIiwga2V5LCB2YWx1ZSwgc2hvcnRoYW5kIH0pO1xuICAgICAgICBpZiAoIW1hdGNoKFwicHVuY3RcIiwgXCIsXCIpKSBicmVhaztcbiAgICAgICAgbmV4dCgpO1xuICAgICAgfSB3aGlsZSAodHJ1ZSk7XG4gICAgfVxuICAgIGVhdChcInB1bmN0XCIsIFwifVwiKTtcbiAgICByZXR1cm4geyB0eXBlOiBcIk9iamVjdEV4cHJlc3Npb25cIiwgcHJvcGVydGllcyB9O1xuICB9O1xuXG4gIGNvbnN0IHBhcnNlQXJndW1lbnRzID0gKCk6IEV4cHJbXSA9PiB7XG4gICAgZWF0KFwicHVuY3RcIiwgXCIoXCIpO1xuICAgIGNvbnN0IGFyZ3M6IEV4cHJbXSA9IFtdO1xuICAgIGlmICghbWF0Y2goXCJwdW5jdFwiLCBcIilcIikpIHtcbiAgICAgIGRvIHtcbiAgICAgICAgYXJncy5wdXNoKHBhcnNlRXhwcmVzc2lvbigpKTtcbiAgICAgICAgaWYgKCFtYXRjaChcInB1bmN0XCIsIFwiLFwiKSkgYnJlYWs7XG4gICAgICAgIG5leHQoKTtcbiAgICAgIH0gd2hpbGUgKHRydWUpO1xuICAgIH1cbiAgICBlYXQoXCJwdW5jdFwiLCBcIilcIik7XG4gICAgcmV0dXJuIGFyZ3M7XG4gIH07XG5cbiAgY29uc3QgcGFyc2VJZGVudGlmaWVyID0gKCk6IElkZW50aWZpZXIgPT4ge1xuICAgIGNvbnN0IHQgPSBlYXQoXCJpZGVudGlmaWVyXCIpO1xuICAgIHJldHVybiB7IHR5cGU6IFwiSWRlbnRpZmllclwiLCBuYW1lOiB0LnZhbHVlIH07XG4gIH07XG5cbiAgY29uc3QgcGFyc2VQYXR0ZXJuID0gKCk6IFBhdHRlcm4gPT4ge1xuICAgIGlmIChtYXRjaChcInB1bmN0XCIsIFwiW1wiKSkge1xuICAgICAgZWF0KFwicHVuY3RcIiwgXCJbXCIpO1xuICAgICAgY29uc3QgZWxlbWVudHM6IElkZW50aWZpZXJbXSA9IFtdO1xuICAgICAgaWYgKCFtYXRjaChcInB1bmN0XCIsIFwiXVwiKSkge1xuICAgICAgICBkbyB7XG4gICAgICAgICAgZWxlbWVudHMucHVzaChwYXJzZUlkZW50aWZpZXIoKSk7XG4gICAgICAgICAgaWYgKCFtYXRjaChcInB1bmN0XCIsIFwiLFwiKSkgYnJlYWs7XG4gICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9IHdoaWxlICh0cnVlKTtcbiAgICAgIH1cbiAgICAgIGVhdChcInB1bmN0XCIsIFwiXVwiKTtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwiQXJyYXlQYXR0ZXJuXCIsIGVsZW1lbnRzIH07XG4gICAgfVxuICAgIGlmIChtYXRjaChcInB1bmN0XCIsIFwie1wiKSkge1xuICAgICAgZWF0KFwicHVuY3RcIiwgXCJ7XCIpO1xuICAgICAgY29uc3QgcHJvcGVydGllczogSWRlbnRpZmllcltdID0gW107XG4gICAgICBpZiAoIW1hdGNoKFwicHVuY3RcIiwgXCJ9XCIpKSB7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBwcm9wZXJ0aWVzLnB1c2gocGFyc2VJZGVudGlmaWVyKCkpO1xuICAgICAgICAgIGlmICghbWF0Y2goXCJwdW5jdFwiLCBcIixcIikpIGJyZWFrO1xuICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgfSB3aGlsZSAodHJ1ZSk7XG4gICAgICB9XG4gICAgICBlYXQoXCJwdW5jdFwiLCBcIn1cIik7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIk9iamVjdFBhdHRlcm5cIiwgcHJvcGVydGllcyB9O1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VJZGVudGlmaWVyKCk7XG4gIH07XG5cbiAgcmV0dXJuIHBhcnNlUHJvZ3JhbSgpO1xufTtcbiIsImltcG9ydCB7IHNjaGVtYSwgdGFibGUsIHQsIFNlbmRlckVycm9yIH0gZnJvbSAnc3BhY2V0aW1lZGIvc2VydmVyJztcbmltcG9ydCB7IGhhc2hEYXRhLCBzY2hlbWFzLCB0b2pzb24sIHRvcCwgdmFsaWRhdGUsIGV4cGFuZExpbmtzU3luYywgZnJvbWpzb24sIHNlcnZlcl9mdW5jdGlvbiwgbm9ybWFsaXplUmVmIH0gZnJvbSAnLi9ub3Rlcyc7XG5pbXBvcnQgdHlwZSB7IEhhc2gsIFJlZiB9IGZyb20gJy4vbm90ZXMnO1xuaW1wb3J0IHsgcnVuV2l0aEZ1ZWxTaGFyZWQgfSBmcm9tICcuL3BhcnNlcic7XG5pbXBvcnQgeyBoYXNoMTI4IH0gZnJvbSAnLi9oYXNoJztcblxuXG5jb25zdCBKc29uTm90ZXMgPSB0YWJsZShcbiAge1xuICAgIG5hbWU6ICdub3RlJyxcbiAgICBwdWJsaWM6IHRydWUsXG4gIH0sIHtcbiAgICBoYXNoOiB0LnN0cmluZygpLnByaW1hcnlLZXkoKSxcbiAgICBzY2hlbWFIYXNoOiB0LnN0cmluZygpLFxuICAgIGRhdGE6IHQuc3RyaW5nKCksXG4gIH1cbik7XG5cbmNvbnN0IFN0b3JlID0gdGFibGUoXG4gIHtcbiAgICBuYW1lOiAnc3RvcmUnLFxuICAgIHB1YmxpYzogZmFsc2UsXG4gIH0sIHtcbiAgICBrZXk6IHQuc3RyaW5nKCkucHJpbWFyeUtleSgpLFxuICAgIHZhbHVlOiB0LnN0cmluZygpXG4gIH1cbilcblxuY29uc3QgTGlua3MgPSB0YWJsZShcbiAge1xuICAgIG5hbWU6IFwibGlua3NcIixcbiAgICBwdWJsaWM6IHRydWVcbiAgfSwge1xuICAgIHRvOiB0LnN0cmluZygpLnByaW1hcnlLZXkoKSxcbiAgICBmcm9tOiB0LmFycmF5KHQuc3RyaW5nKCkpLFxuICB9XG4pXG5cbmV4cG9ydCBjb25zdCBzcGFjZXRpbWVkYiA9IHNjaGVtYShKc29uTm90ZXMsIExpbmtzLCBTdG9yZSk7XG5cbnNwYWNldGltZWRiLnZpZXcoeyBuYW1lOiAnbm90ZV9jb3VudCcsIHB1YmxpYzogdHJ1ZSB9LCB0LmFycmF5KHQub2JqZWN0KCdOb3RlQ291bnRSb3cnLCB7IGNvdW50OiB0LnU2NCgpIH0pKSxcbiAgKGN0eCkgPT4gW3sgY291bnQ6IGN0eC5kYi5ub3RlLmNvdW50KCkgfV1cbik7XG5cblxuXG5cbnNwYWNldGltZWRiLnJlZHVjZXIoJ2FkZF9ub3RlJywge1xuICBzY2hlbWFIYXNoOiB0LnN0cmluZygpLFxuICBkYXRhOiB0LnN0cmluZygpLFxufSwgKGN0eCwgeyBzY2hlbWFIYXNoLCBkYXRhIH0gKSA9PiB7XG5cbiAgY29uc3Qgc2NoZW1hUm93ID0gY3R4LmRiLm5vdGUuaGFzaC5maW5kKHNjaGVtYUhhc2gpO1xuICBpZiAoIXNjaGVtYVJvdykgdGhyb3cgbmV3IFNlbmRlckVycm9yKCdTY2hlbWEgbm90IGZvdW5kJyk7XG5cbiAgdHJ5e1xuICAgIGNvbnN0IHJlc29sdmUgPSAocmVmOiBSZWYpID0+IHtcbiAgICAgIGNvbnN0IG5vdGUgPSBjdHguZGIubm90ZS5oYXNoLmZpbmQobm9ybWFsaXplUmVmKHJlZikpO1xuICAgICAgaWYgKCFub3RlKSB0aHJvdyBuZXcgU2VuZGVyRXJyb3IoJ05vdGUgbm90IGZvdW5kJyk7XG4gICAgICByZXR1cm4gZnJvbWpzb24obm90ZS5kYXRhKTtcbiAgICB9XG4gICAgY29uc3QgcGFyc2VkID0gZnJvbWpzb24oZGF0YSlcbiAgICBjb25zdCBleHBhbmRlZEpzb24gPSBleHBhbmRMaW5rc1N5bmMocGFyc2VkLCByZXNvbHZlKTtcbiAgICBjb25zdCBleHBhbmRlZFNjaGVtYSA9IGV4cGFuZExpbmtzU3luYyhmcm9tanNvbihzY2hlbWFSb3cuZGF0YSksIHJlc29sdmUpO1xuICAgIHZhbGlkYXRlKGV4cGFuZGVkSnNvbiwgZXhwYW5kZWRTY2hlbWEpXG5cbiAgICBjb25zdCBoYXNoID0gaGFzaERhdGEoe3NjaGVtYUhhc2g6IHNjaGVtYUhhc2ggYXMgSGFzaCwgZGF0YTogcGFyc2VkfSlcblxuICAgIGNvbnN0IGV4aXN0aW5nID0gY3R4LmRiLm5vdGUuaGFzaC5maW5kKGhhc2gpO1xuICAgIGlmIChleGlzdGluZykgcmV0dXJuO1xuXG4gICAgY3R4LmRiLm5vdGUuaW5zZXJ0KHsgaGFzaCwgc2NoZW1hSGFzaCwgZGF0YSB9KVxuXG4gICAgY29uc3QgdGFyZ2V0cyA9IG5ldyBTZXQ8c3RyaW5nPihbc2NoZW1hUm93Lmhhc2hdKTtcbiAgICBjb25zdCByZSA9IC8jKFthLWYwLTldezMyfSkvZztcbiAgICBsZXQgbWF0Y2g6IFJlZ0V4cEV4ZWNBcnJheSB8IG51bGw7XG4gICAgd2hpbGUgKChtYXRjaCA9IHJlLmV4ZWMoZGF0YSkpKSB7XG4gICAgICB0YXJnZXRzLmFkZChtYXRjaFsxXSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgdG8gb2YgdGFyZ2V0cykge1xuICAgICAgY29uc3QgZXhpc3RpbmcgPSBjdHguZGIubGlua3MudG8uZmluZCh0byk7XG4gICAgICBpZiAoIWV4aXN0aW5nKSBjdHguZGIubGlua3MuaW5zZXJ0KHsgdG8sIGZyb206IFtoYXNoXSB9KTtcbiAgICAgIGVsc2UgaWYgKCFleGlzdGluZy5mcm9tLnNvbWUoKHgpID0+IHggPT09IGhhc2gpKSBjdHguZGIubGlua3MudG8udXBkYXRlKHsgLi4uZXhpc3RpbmcsIGZyb206IFsuLi5leGlzdGluZy5mcm9tLCBoYXNoXSB9KTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1jYXRjaCAoZSl7XG4gICAgdGhyb3cgbmV3IFNlbmRlckVycm9yKCBcIklOU0VSVCBFUlJPUjogXCIrZnJvbWpzb24oc2NoZW1hUm93LmRhdGEpKVxuICB9XG59KTtcblxuXG5jb25zdCBzZXR1cCA9IHNwYWNldGltZWRiLnJlZHVjZXIoJ3NldHVwJywge30sIChjdHgpID0+IHtcblxuICB0cnl7XG4gICAgY3R4LmRiLm5vdGUuaW5zZXJ0KHsgaGFzaDogaGFzaERhdGEodG9wKSwgc2NoZW1hSGFzaDogdG9wLnNjaGVtYUhhc2gsIGRhdGE6IHRvanNvbih0b3AuZGF0YSkgfSlcbiAgfWNhdGNoIHt9XG5cbiAgZm9yIChjb25zdCBub3RlIG9mIHNjaGVtYXMpIHtcbiAgICBjb25zdCBoYXNoID0gaGFzaERhdGEobm90ZSk7XG4gICAgaWYgKGN0eC5kYi5ub3RlLmhhc2guZmluZChoYXNoKSkgY29udGludWU7XG4gICAgY3R4LmRiLm5vdGUuaW5zZXJ0KHtcbiAgICAgIGhhc2gsXG4gICAgICBzY2hlbWFIYXNoOiBub3RlLnNjaGVtYUhhc2gsXG4gICAgICBkYXRhOiB0b2pzb24obm90ZS5kYXRhKSxcbiAgICB9KTtcbiAgfVxufSlcblxuc3BhY2V0aW1lZGIuaW5pdChzZXR1cClcblxuLyogdGhpcyB3aWxsIG91dHNpZGUgb2YgdHJhbnNhY3Rpb24gYWxsb3dpbmcgZm9yIGZldGNoIHJlcXVlc3RzICovXG5zcGFjZXRpbWVkYi5wcm9jZWR1cmUoJ3J1bl9ub3RlX2FzeW5jJywge2hhc2g6IHQuc3RyaW5nKCksIGFyZzogdC5zdHJpbmcoKX0sIHQuc3RyaW5nKCksIChjdHgsIHtoYXNoLCBhcmd9KT0+IHtcblxuICBjb25zdCBnZXROb3RlID0gKHJlZiA6IFJlZikgPT4gY3R4LndpdGhUeChjPT4gYy5kYi5ub3RlLmhhc2guZmluZChub3JtYWxpemVSZWYocmVmKSkpXG4gIGNvbnN0IGZ1ZWxSZWYgPSB7IHZhbHVlOiAxMDAwMCB9O1xuICBjb25zdCBmblNjaGVtYUhhc2ggPSBoYXNoRGF0YShzZXJ2ZXJfZnVuY3Rpb24pO1xuXG4gIGNvbnN0IGNhbGwgPSAocmVmOiBSZWYsIGFyZzpzdHJpbmcpID0+IHtcblxuICAgIGNvbnN0IGZuID0gZ2V0Tm90ZShyZWYpO1xuICAgIGlmIChmbiA9PSBudWxsKSB0aHJvdyBuZXcgU2VuZGVyRXJyb3IoXCJmbiBub3QgZm91bmRcIilcbiAgICBpZiAoZm4uc2NoZW1hSGFzaCAhPSBmblNjaGVtYUhhc2gpIHRocm93IG5ldyBTZW5kZXJFcnJvcihcIm5vdCBhIHNlcnZlciBmdW5jdGlvblwiKVxuXG4gICAgY29uc3Qga2V5Rm9yID0gKGtleTogc3RyaW5nKSA9PiBgJHtmbi5oYXNofToke2tleX1gO1xuICAgIGNvbnN0IHN0b3JhZ2UgPSB7XG4gICAgICBnZXRJdGVtOiAoa2V5OiBzdHJpbmcpID0+IGN0eC53aXRoVHgoY3R4ID0+IGN0eC5kYi5zdG9yZS5rZXkuZmluZChrZXlGb3Ioa2V5KSk/LnZhbHVlID8/IG51bGwpLFxuICAgICAgc2V0SXRlbTogKGtleTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKSA9PiBjdHgud2l0aFR4KGN0eCA9PiB7XG4gICAgICAgIGNvbnN0IGsgPSBrZXlGb3Ioa2V5KTtcbiAgICAgICAgaWYgKGN0eC5kYi5zdG9yZS5rZXkuZmluZChrKSkgY3R4LmRiLnN0b3JlLmtleS51cGRhdGUoeyBrZXk6IGssIHZhbHVlIH0pO1xuICAgICAgICBlbHNlIGN0eC5kYi5zdG9yZS5pbnNlcnQoeyBrZXk6IGssIHZhbHVlIH0pO1xuICAgICAgfSlcbiAgICB9O1xuXG4gICAgbGV0IHJldCA9IHJ1bldpdGhGdWVsU2hhcmVkKGBsZXQgYXJncyA9ICR7YXJnfTsgJHsoZnJvbWpzb24oZm4uZGF0YSkgYXMge2NvZGU6IHN0cmluZ30pLmNvZGV9YCwgZnVlbFJlZiwge3N0b3JhZ2UsIGNhbGwsIGhhc2g6IGhhc2gxMjh9KVxuICAgIGlmIChcImVyclwiIGluIHJldCkgdGhyb3cgbmV3IFNlbmRlckVycm9yKFN0cmluZyhyZXQuZXJyKSk7XG4gICAgcmV0dXJuIChyZXQgYXMgYW55KS5vaztcbiAgfVxuXG4gIHJldHVybiB0b2pzb24oY2FsbChoYXNoIGFzIEhhc2gsIGFyZykpXG5cbn0pXG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLElBQUlBLGFBQVcsT0FBTztB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QUFLO0FBQzNCLE1BQUksSUFBSSxHQUFHLEtBQUssS0FBSyxLQUFLLEtBQUssQ0FBRTtBQUNqQyxNQUFJLEdBQUcsS0FBSyxPQUFPO0dBQ2pCO0dBQ0EsWUFBWSxLQUFLO0dBQ2pCLE1BQU0sT0FBTyxLQUFLLEtBQUs7R0FDeEIsQ0FBQzs7RUFFSjtBQUVGLFlBQVksS0FBSyxNQUFNO0FBR3ZCLFlBQVksVUFBVSxrQkFBa0I7Q0FBQyxNQUFNLEVBQUUsUUFBUTtDQUFFLEtBQUssRUFBRSxRQUFRO0NBQUMsRUFBRSxFQUFFLFFBQVEsR0FBRyxLQUFLLEVBQUMsTUFBTSxVQUFRO0NBRTVHLE1BQU0sV0FBVyxRQUFjLElBQUksUUFBTyxNQUFJLEVBQUUsR0FBRyxLQUFLLEtBQUssS0FBSyxhQUFhLElBQUksQ0FBQyxDQUFDO0NBQ3JGLE1BQU0sVUFBVSxFQUFFLE9BQU8sS0FBTztDQUNoQyxNQUFNLGVBQWUsU0FBUyxnQkFBZ0I7Q0FFOUMsTUFBTSxRQUFRLEtBQVUsVUFBZTtFQUVyQyxNQUFNLEtBQUssUUFBUSxJQUFJO0FBQ3ZCLE1BQUksTUFBTSxLQUFNLE9BQU0sSUFBSSxZQUFZLGVBQWU7QUFDckQsTUFBSSxHQUFHLGNBQWMsYUFBYyxPQUFNLElBQUksWUFBWSx3QkFBd0I7RUFFakYsTUFBTSxVQUFVLFFBQWdCLEdBQUcsR0FBRyxLQUFLLEdBQUc7RUFVOUMsSUFBSSxNQUFNLGtCQUFrQixjQUFjQyxNQUFJLElBQUssU0FBUyxHQUFHLEtBQUssQ0FBb0IsUUFBUSxTQUFTO0dBQUMsU0FUMUY7SUFDZCxVQUFVLFFBQWdCLElBQUksUUFBTyxVQUFPQyxNQUFJLEdBQUcsTUFBTSxJQUFJLEtBQUssT0FBTyxJQUFJLENBQUMsRUFBRSxTQUFTLEtBQUs7SUFDOUYsVUFBVSxLQUFhLFVBQWtCLElBQUksUUFBTyxVQUFPO0tBQ3pELE1BQU0sSUFBSSxPQUFPLElBQUk7QUFDckIsU0FBSUEsTUFBSSxHQUFHLE1BQU0sSUFBSSxLQUFLLEVBQUUsQ0FBRSxPQUFJLEdBQUcsTUFBTSxJQUFJLE9BQU87TUFBRSxLQUFLO01BQUc7TUFBTyxDQUFDO1NBQ25FLE9BQUksR0FBRyxNQUFNLE9BQU87TUFBRSxLQUFLO01BQUc7TUFBTyxDQUFDO01BQzNDO0lBQ0g7R0FFa0g7R0FBTSxNQUFNO0dBQVEsQ0FBQztBQUN4SSxNQUFJLFNBQVMsSUFBSyxPQUFNLElBQUksWUFBWSxPQUFPLElBQUksSUFBSSxDQUFDO0FBQ3hELFNBQVEsSUFBWTs7QUFHdEIsUUFBTyxPQUFPLEtBQUssTUFBYyxJQUFJLENBQUM7RUFFdEMiLCJkZWJ1Z0lkIjoiNzkzMDVmOTgtY2Y2OC00ZWRmLWFmYWQtYTdjYzVkMWMzNTYyIn0=