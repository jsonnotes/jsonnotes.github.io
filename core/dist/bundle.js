import * as _syscalls1_0 from "spacetime:sys@1.0";
import { register_hooks } from "spacetime:sys@1.0";
import { register_hooks as register_hooks$1 } from "spacetime:sys@1.1";
import * as _syscalls1_2 from "spacetime:sys@1.2";
import { register_hooks as register_hooks$2 } from "spacetime:sys@1.2";

//#region rolldown:runtime
var __create$2 = Object.create;
var __defProp$2 = Object.defineProperty;
var __getOwnPropDesc$2 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames$2 = Object.getOwnPropertyNames;
var __getProtoOf$2 = Object.getPrototypeOf;
var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
var __commonJS$2 = (cb, mod) => function() {
	return mod || (0, cb[__getOwnPropNames$2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps$2 = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") for (var keys = __getOwnPropNames$2(from), i = 0, n = keys.length, key; i < n; i++) {
		key = keys[i];
		if (!__hasOwnProp$2.call(to, key) && key !== except) __defProp$2(to, key, {
			get: ((k) => from[k]).bind(null, key),
			enumerable: !(desc = __getOwnPropDesc$2(from, key)) || desc.enumerable
		});
	}
	return to;
};
var __toESM$2 = (mod, isNodeMode, target) => (target = mod != null ? __create$2(__getProtoOf$2(mod)) : {}, __copyProps$2(isNodeMode || !mod || !mod.__esModule ? __defProp$2(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));

//#endregion
//#region ../node_modules/headers-polyfill/lib/index.mjs
var __create$1 = Object.create;
var __defProp$1 = Object.defineProperty;
var __getOwnPropDesc$1 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames$1 = Object.getOwnPropertyNames;
var __getProtoOf$1 = Object.getPrototypeOf;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __commonJS$1 = (cb, mod) => function __require() {
	return mod || (0, cb[__getOwnPropNames$1(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps$1 = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") {
		for (let key of __getOwnPropNames$1(from)) if (!__hasOwnProp$1.call(to, key) && key !== except) __defProp$1(to, key, {
			get: () => from[key],
			enumerable: !(desc = __getOwnPropDesc$1(from, key)) || desc.enumerable
		});
	}
	return to;
};
var __toESM$1 = (mod, isNodeMode, target) => (target = mod != null ? __create$1(__getProtoOf$1(mod)) : {}, __copyProps$1(isNodeMode || !mod || !mod.__esModule ? __defProp$1(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));
var import_set_cookie_parser = __toESM$1(__commonJS$1({ "node_modules/set-cookie-parser/lib/set-cookie.js"(exports$1, module$1) {
	var defaultParseOptions = {
		decodeValues: true,
		map: false,
		silent: false
	};
	function isNonEmptyString(str$1) {
		return typeof str$1 === "string" && !!str$1.trim();
	}
	function parseString(setCookieValue, options) {
		var parts = setCookieValue.split(";").filter(isNonEmptyString);
		var parsed = parseNameValuePair(parts.shift());
		var name = parsed.name;
		var value = parsed.value;
		options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
		try {
			value = options.decodeValues ? decodeURIComponent(value) : value;
		} catch (e) {
			console.error("set-cookie-parser encountered an error while decoding a cookie with value '" + value + "'. Set options.decodeValues to false to disable this feature.", e);
		}
		var cookie = {
			name,
			value
		};
		parts.forEach(function(part) {
			var sides = part.split("=");
			var key = sides.shift().trimLeft().toLowerCase();
			var value2 = sides.join("=");
			if (key === "expires") cookie.expires = new Date(value2);
			else if (key === "max-age") cookie.maxAge = parseInt(value2, 10);
			else if (key === "secure") cookie.secure = true;
			else if (key === "httponly") cookie.httpOnly = true;
			else if (key === "samesite") cookie.sameSite = value2;
			else cookie[key] = value2;
		});
		return cookie;
	}
	function parseNameValuePair(nameValuePairStr) {
		var name = "";
		var value = "";
		var nameValueArr = nameValuePairStr.split("=");
		if (nameValueArr.length > 1) {
			name = nameValueArr.shift();
			value = nameValueArr.join("=");
		} else value = nameValuePairStr;
		return {
			name,
			value
		};
	}
	function parse$2(input, options) {
		options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
		if (!input) if (!options.map) return [];
		else return {};
		if (input.headers) if (typeof input.headers.getSetCookie === "function") input = input.headers.getSetCookie();
		else if (input.headers["set-cookie"]) input = input.headers["set-cookie"];
		else {
			var sch = input.headers[Object.keys(input.headers).find(function(key) {
				return key.toLowerCase() === "set-cookie";
			})];
			if (!sch && input.headers.cookie && !options.silent) console.warn("Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning.");
			input = sch;
		}
		if (!Array.isArray(input)) input = [input];
		options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
		if (!options.map) return input.filter(isNonEmptyString).map(function(str$1) {
			return parseString(str$1, options);
		});
		else return input.filter(isNonEmptyString).reduce(function(cookies2, str$1) {
			var cookie = parseString(str$1, options);
			cookies2[cookie.name] = cookie;
			return cookies2;
		}, {});
	}
	function splitCookiesString2(cookiesString) {
		if (Array.isArray(cookiesString)) return cookiesString;
		if (typeof cookiesString !== "string") return [];
		var cookiesStrings = [];
		var pos = 0;
		var start;
		var ch;
		var lastComma;
		var nextStart;
		var cookiesSeparatorFound;
		function skipWhitespace() {
			while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) pos += 1;
			return pos < cookiesString.length;
		}
		function notSpecialChar() {
			ch = cookiesString.charAt(pos);
			return ch !== "=" && ch !== ";" && ch !== ",";
		}
		while (pos < cookiesString.length) {
			start = pos;
			cookiesSeparatorFound = false;
			while (skipWhitespace()) {
				ch = cookiesString.charAt(pos);
				if (ch === ",") {
					lastComma = pos;
					pos += 1;
					skipWhitespace();
					nextStart = pos;
					while (pos < cookiesString.length && notSpecialChar()) pos += 1;
					if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
						cookiesSeparatorFound = true;
						pos = nextStart;
						cookiesStrings.push(cookiesString.substring(start, lastComma));
						start = pos;
					} else pos = lastComma + 1;
				} else pos += 1;
			}
			if (!cookiesSeparatorFound || pos >= cookiesString.length) cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
		}
		return cookiesStrings;
	}
	module$1.exports = parse$2;
	module$1.exports.parse = parse$2;
	module$1.exports.parseString = parseString;
	module$1.exports.splitCookiesString = splitCookiesString2;
} })());
var HEADERS_INVALID_CHARACTERS = /[^a-z0-9\-#$%&'*+.^_`|~]/i;
function normalizeHeaderName(name) {
	if (HEADERS_INVALID_CHARACTERS.test(name) || name.trim() === "") throw new TypeError("Invalid character in header field name");
	return name.trim().toLowerCase();
}
var charCodesToRemove = [
	String.fromCharCode(10),
	String.fromCharCode(13),
	String.fromCharCode(9),
	String.fromCharCode(32)
];
var HEADER_VALUE_REMOVE_REGEXP = new RegExp(`(^[${charCodesToRemove.join("")}]|$[${charCodesToRemove.join("")}])`, "g");
function normalizeHeaderValue(value) {
	return value.replace(HEADER_VALUE_REMOVE_REGEXP, "");
}
function isValidHeaderName(value) {
	if (typeof value !== "string") return false;
	if (value.length === 0) return false;
	for (let i = 0; i < value.length; i++) {
		const character = value.charCodeAt(i);
		if (character > 127 || !isToken(character)) return false;
	}
	return true;
}
function isToken(value) {
	return ![
		127,
		32,
		"(",
		")",
		"<",
		">",
		"@",
		",",
		";",
		":",
		"\\",
		"\"",
		"/",
		"[",
		"]",
		"?",
		"=",
		"{",
		"}"
	].includes(value);
}
function isValidHeaderValue(value) {
	if (typeof value !== "string") return false;
	if (value.trim() !== value) return false;
	for (let i = 0; i < value.length; i++) {
		const character = value.charCodeAt(i);
		if (character === 0 || character === 10 || character === 13) return false;
	}
	return true;
}
var NORMALIZED_HEADERS = Symbol("normalizedHeaders");
var RAW_HEADER_NAMES = Symbol("rawHeaderNames");
var HEADER_VALUE_DELIMITER = ", ";
var _a, _b, _c;
var Headers = class _Headers {
	constructor(init$1) {
		this[_a] = {};
		this[_b] = /* @__PURE__ */ new Map();
		this[_c] = "Headers";
		if (["Headers", "HeadersPolyfill"].includes(init$1?.constructor.name) || init$1 instanceof _Headers || typeof globalThis.Headers !== "undefined" && init$1 instanceof globalThis.Headers) init$1.forEach((value, name) => {
			this.append(name, value);
		}, this);
		else if (Array.isArray(init$1)) init$1.forEach(([name, value]) => {
			this.append(name, Array.isArray(value) ? value.join(HEADER_VALUE_DELIMITER) : value);
		});
		else if (init$1) Object.getOwnPropertyNames(init$1).forEach((name) => {
			const value = init$1[name];
			this.append(name, Array.isArray(value) ? value.join(HEADER_VALUE_DELIMITER) : value);
		});
	}
	[(_a = NORMALIZED_HEADERS, _b = RAW_HEADER_NAMES, _c = Symbol.toStringTag, Symbol.iterator)]() {
		return this.entries();
	}
	*keys() {
		for (const [name] of this.entries()) yield name;
	}
	*values() {
		for (const [, value] of this.entries()) yield value;
	}
	*entries() {
		let sortedKeys = Object.keys(this[NORMALIZED_HEADERS]).sort((a, b) => a.localeCompare(b));
		for (const name of sortedKeys) if (name === "set-cookie") for (const value of this.getSetCookie()) yield [name, value];
		else yield [name, this.get(name)];
	}
	/**
	* Returns a boolean stating whether a `Headers` object contains a certain header.
	*/
	has(name) {
		if (!isValidHeaderName(name)) throw new TypeError(`Invalid header name "${name}"`);
		return this[NORMALIZED_HEADERS].hasOwnProperty(normalizeHeaderName(name));
	}
	/**
	* Returns a `ByteString` sequence of all the values of a header with a given name.
	*/
	get(name) {
		if (!isValidHeaderName(name)) throw TypeError(`Invalid header name "${name}"`);
		return this[NORMALIZED_HEADERS][normalizeHeaderName(name)] ?? null;
	}
	/**
	* Sets a new value for an existing header inside a `Headers` object, or adds the header if it does not already exist.
	*/
	set(name, value) {
		if (!isValidHeaderName(name) || !isValidHeaderValue(value)) return;
		const normalizedName = normalizeHeaderName(name);
		const normalizedValue = normalizeHeaderValue(value);
		this[NORMALIZED_HEADERS][normalizedName] = normalizeHeaderValue(normalizedValue);
		this[RAW_HEADER_NAMES].set(normalizedName, name);
	}
	/**
	* Appends a new value onto an existing header inside a `Headers` object, or adds the header if it does not already exist.
	*/
	append(name, value) {
		if (!isValidHeaderName(name) || !isValidHeaderValue(value)) return;
		const normalizedName = normalizeHeaderName(name);
		const normalizedValue = normalizeHeaderValue(value);
		let resolvedValue = this.has(normalizedName) ? `${this.get(normalizedName)}, ${normalizedValue}` : normalizedValue;
		this.set(name, resolvedValue);
	}
	/**
	* Deletes a header from the `Headers` object.
	*/
	delete(name) {
		if (!isValidHeaderName(name)) return;
		if (!this.has(name)) return;
		const normalizedName = normalizeHeaderName(name);
		delete this[NORMALIZED_HEADERS][normalizedName];
		this[RAW_HEADER_NAMES].delete(normalizedName);
	}
	/**
	* Traverses the `Headers` object,
	* calling the given callback for each header.
	*/
	forEach(callback, thisArg) {
		for (const [name, value] of this.entries()) callback.call(thisArg, value, name, this);
	}
	/**
	* Returns an array containing the values
	* of all Set-Cookie headers associated
	* with a response
	*/
	getSetCookie() {
		const setCookieHeader = this.get("set-cookie");
		if (setCookieHeader === null) return [];
		if (setCookieHeader === "") return [""];
		return (0, import_set_cookie_parser.splitCookiesString)(setCookieHeader);
	}
};
function headersToList(headers) {
	const headersList = [];
	headers.forEach((value, name) => {
		const resolvedValue = value.includes(",") ? value.split(",").map((value2) => value2.trim()) : value;
		headersList.push([name, resolvedValue]);
	});
	return headersList;
}

//#endregion
//#region ../node_modules/spacetimedb/dist/server/index.mjs
typeof globalThis !== "undefined" && (globalThis.global = globalThis.global || globalThis, globalThis.window = globalThis.window || globalThis);
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError = (msg) => {
	throw TypeError(msg);
};
var __commonJS = (cb, mod) => function __require() {
	return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") {
		for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
			get: () => from[key],
			enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
		});
	}
	return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(__defProp(target, "default", {
	value: mod,
	enumerable: true
}), mod));
var __using = (stack, value, async) => {
	if (value != null) {
		if (typeof value !== "object" && typeof value !== "function") __typeError("Object expected");
		var dispose, inner;
		if (dispose === void 0) dispose = value[__knownSymbol("dispose")];
		if (typeof dispose !== "function") __typeError("Object not disposable");
		if (inner) dispose = function() {
			try {
				inner.call(this);
			} catch (e) {
				return Promise.reject(e);
			}
		};
		stack.push([
			async,
			dispose,
			value
		]);
	}
	return value;
};
var __callDispose = (stack, error, hasError) => {
	var E$1 = typeof SuppressedError === "function" ? SuppressedError : function(e, s, m, _$1) {
		return _$1 = Error(m), _$1.name = "SuppressedError", _$1.error = e, _$1.suppressed = s, _$1;
	};
	var fail = (e) => error = hasError ? new E$1(e, error, "An error was suppressed during disposal") : (hasError = true, e);
	var next = (it) => {
		while (it = stack.pop()) try {
			var result = it[1] && it[1].call(it[2]);
			if (it[0]) return Promise.resolve(result).then(next, (e) => (fail(e), next()));
		} catch (e) {
			fail(e);
		}
		if (hasError) throw error;
	};
	return next();
};
var require_base64_js = __commonJS({ "../../node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js"(exports$1) {
	exports$1.byteLength = byteLength;
	exports$1.toByteArray = toByteArray;
	exports$1.fromByteArray = fromByteArray2;
	var lookup = [];
	var revLookup = [];
	var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
	var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	for (i = 0, len = code.length; i < len; ++i) {
		lookup[i] = code[i];
		revLookup[code.charCodeAt(i)] = i;
	}
	var i;
	var len;
	revLookup["-".charCodeAt(0)] = 62;
	revLookup["_".charCodeAt(0)] = 63;
	function getLens(b64) {
		var len2 = b64.length;
		if (len2 % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
		var validLen = b64.indexOf("=");
		if (validLen === -1) validLen = len2;
		var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
		return [validLen, placeHoldersLen];
	}
	function byteLength(b64) {
		var lens = getLens(b64);
		var validLen = lens[0];
		var placeHoldersLen = lens[1];
		return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
	}
	function _byteLength(b64, validLen, placeHoldersLen) {
		return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
	}
	function toByteArray(b64) {
		var tmp;
		var lens = getLens(b64);
		var validLen = lens[0];
		var placeHoldersLen = lens[1];
		var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
		var curByte = 0;
		var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
		var i2;
		for (i2 = 0; i2 < len2; i2 += 4) {
			tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
			arr[curByte++] = tmp >> 16 & 255;
			arr[curByte++] = tmp >> 8 & 255;
			arr[curByte++] = tmp & 255;
		}
		if (placeHoldersLen === 2) {
			tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
			arr[curByte++] = tmp & 255;
		}
		if (placeHoldersLen === 1) {
			tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
			arr[curByte++] = tmp >> 8 & 255;
			arr[curByte++] = tmp & 255;
		}
		return arr;
	}
	function tripletToBase64(num) {
		return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
	}
	function encodeChunk(uint8, start, end) {
		var tmp;
		var output = [];
		for (var i2 = start; i2 < end; i2 += 3) {
			tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
			output.push(tripletToBase64(tmp));
		}
		return output.join("");
	}
	function fromByteArray2(uint8) {
		var tmp;
		var len2 = uint8.length;
		var extraBytes = len2 % 3;
		var parts = [];
		var maxChunkLength = 16383;
		for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
		if (extraBytes === 1) {
			tmp = uint8[len2 - 1];
			parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
		} else if (extraBytes === 2) {
			tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
			parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
		}
		return parts.join("");
	}
} });
var require_text_min = __commonJS({ "../../node_modules/.pnpm/fast-text-encoding@1.0.6/node_modules/fast-text-encoding/text.min.js"(exports$1) {
	(function(scope) {
		function B(r, e) {
			var f;
			return r instanceof Buffer ? f = r : f = Buffer.from(r.buffer, r.byteOffset, r.byteLength), f.toString(e);
		}
		var w = function(r) {
			return Buffer.from(r);
		};
		function h(r) {
			for (var e = 0, f = Math.min(256 * 256, r.length + 1), n = new Uint16Array(f), i = [], o = 0;;) {
				var t2 = e < r.length;
				if (!t2 || o >= f - 1) {
					var m = n.subarray(0, o);
					if (i.push(String.fromCharCode.apply(null, m)), !t2) return i.join("");
					r = r.subarray(e), e = 0, o = 0;
				}
				var a = r[e++];
				if ((a & 128) === 0) n[o++] = a;
				else if ((a & 224) === 192) {
					var d = r[e++] & 63;
					n[o++] = (a & 31) << 6 | d;
				} else if ((a & 240) === 224) {
					var d = r[e++] & 63, l = r[e++] & 63;
					n[o++] = (a & 31) << 12 | d << 6 | l;
				} else if ((a & 248) === 240) {
					var d = r[e++] & 63, l = r[e++] & 63, R = r[e++] & 63, c = (a & 7) << 18 | d << 12 | l << 6 | R;
					c > 65535 && (c -= 65536, n[o++] = c >>> 10 & 1023 | 55296, c = 56320 | c & 1023), n[o++] = c;
				}
			}
		}
		function F(r) {
			for (var e = 0, f = r.length, n = 0, i = Math.max(32, f + (f >>> 1) + 7), o = new Uint8Array(i >>> 3 << 3); e < f;) {
				var t2 = r.charCodeAt(e++);
				if (t2 >= 55296 && t2 <= 56319) {
					if (e < f) {
						var s = r.charCodeAt(e);
						(s & 64512) === 56320 && (++e, t2 = ((t2 & 1023) << 10) + (s & 1023) + 65536);
					}
					if (t2 >= 55296 && t2 <= 56319) continue;
				}
				if (n + 4 > o.length) {
					i += 8, i *= 1 + e / r.length * 2, i = i >>> 3 << 3;
					var m = new Uint8Array(i);
					m.set(o), o = m;
				}
				if ((t2 & 4294967168) === 0) {
					o[n++] = t2;
					continue;
				} else if ((t2 & 4294965248) === 0) o[n++] = t2 >>> 6 & 31 | 192;
				else if ((t2 & 4294901760) === 0) o[n++] = t2 >>> 12 & 15 | 224, o[n++] = t2 >>> 6 & 63 | 128;
				else if ((t2 & 4292870144) === 0) o[n++] = t2 >>> 18 & 7 | 240, o[n++] = t2 >>> 12 & 63 | 128, o[n++] = t2 >>> 6 & 63 | 128;
				else continue;
				o[n++] = t2 & 63 | 128;
			}
			return o.slice ? o.slice(0, n) : o.subarray(0, n);
		}
		var u = "Failed to ", p = function(r, e, f) {
			if (r) throw new Error("".concat(u).concat(e, ": the '").concat(f, "' option is unsupported."));
		};
		var x = typeof Buffer == "function" && Buffer.from;
		var A = x ? w : F;
		function v() {
			this.encoding = "utf-8";
		}
		v.prototype.encode = function(r, e) {
			return p(e && e.stream, "encode", "stream"), A(r);
		};
		function U(r) {
			var e;
			try {
				var f = new Blob([r], { type: "text/plain;charset=UTF-8" });
				e = URL.createObjectURL(f);
				var n = new XMLHttpRequest();
				return n.open("GET", e, false), n.send(), n.responseText;
			} finally {
				e && URL.revokeObjectURL(e);
			}
		}
		var O = !x && typeof Blob == "function" && typeof URL == "function" && typeof URL.createObjectURL == "function", S = [
			"utf-8",
			"utf8",
			"unicode-1-1-utf-8"
		], T = h;
		x ? T = B : O && (T = function(r) {
			try {
				return U(r);
			} catch (e) {
				return h(r);
			}
		});
		var y = "construct 'TextDecoder'", E$1 = "".concat(u, " ").concat(y, ": the ");
		function g(r, e) {
			p(e && e.fatal, y, "fatal"), r = r || "utf-8";
			var f;
			if (x ? f = Buffer.isEncoding(r) : f = S.indexOf(r.toLowerCase()) !== -1, !f) throw new RangeError("".concat(E$1, " encoding label provided ('").concat(r, "') is invalid."));
			this.encoding = r, this.fatal = false, this.ignoreBOM = false;
		}
		g.prototype.decode = function(r, e) {
			p(e && e.stream, "decode", "stream");
			var f;
			return r instanceof Uint8Array ? f = r : r.buffer instanceof ArrayBuffer ? f = new Uint8Array(r.buffer) : f = new Uint8Array(r), T(f, this.encoding);
		};
		scope.TextEncoder = scope.TextEncoder || v;
		scope.TextDecoder = scope.TextDecoder || g;
	})(typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : exports$1);
} });
var require_codes = __commonJS({ "../../node_modules/.pnpm/statuses@2.0.2/node_modules/statuses/codes.json"(exports$1, module$1) {
	module$1.exports = {
		"100": "Continue",
		"101": "Switching Protocols",
		"102": "Processing",
		"103": "Early Hints",
		"200": "OK",
		"201": "Created",
		"202": "Accepted",
		"203": "Non-Authoritative Information",
		"204": "No Content",
		"205": "Reset Content",
		"206": "Partial Content",
		"207": "Multi-Status",
		"208": "Already Reported",
		"226": "IM Used",
		"300": "Multiple Choices",
		"301": "Moved Permanently",
		"302": "Found",
		"303": "See Other",
		"304": "Not Modified",
		"305": "Use Proxy",
		"307": "Temporary Redirect",
		"308": "Permanent Redirect",
		"400": "Bad Request",
		"401": "Unauthorized",
		"402": "Payment Required",
		"403": "Forbidden",
		"404": "Not Found",
		"405": "Method Not Allowed",
		"406": "Not Acceptable",
		"407": "Proxy Authentication Required",
		"408": "Request Timeout",
		"409": "Conflict",
		"410": "Gone",
		"411": "Length Required",
		"412": "Precondition Failed",
		"413": "Payload Too Large",
		"414": "URI Too Long",
		"415": "Unsupported Media Type",
		"416": "Range Not Satisfiable",
		"417": "Expectation Failed",
		"418": "I'm a Teapot",
		"421": "Misdirected Request",
		"422": "Unprocessable Entity",
		"423": "Locked",
		"424": "Failed Dependency",
		"425": "Too Early",
		"426": "Upgrade Required",
		"428": "Precondition Required",
		"429": "Too Many Requests",
		"431": "Request Header Fields Too Large",
		"451": "Unavailable For Legal Reasons",
		"500": "Internal Server Error",
		"501": "Not Implemented",
		"502": "Bad Gateway",
		"503": "Service Unavailable",
		"504": "Gateway Timeout",
		"505": "HTTP Version Not Supported",
		"506": "Variant Also Negotiates",
		"507": "Insufficient Storage",
		"508": "Loop Detected",
		"509": "Bandwidth Limit Exceeded",
		"510": "Not Extended",
		"511": "Network Authentication Required"
	};
} });
var require_statuses = __commonJS({ "../../node_modules/.pnpm/statuses@2.0.2/node_modules/statuses/index.js"(exports$1, module$1) {
	var codes = require_codes();
	module$1.exports = status2;
	status2.message = codes;
	status2.code = createMessageToStatusCodeMap(codes);
	status2.codes = createStatusCodeList(codes);
	status2.redirect = {
		300: true,
		301: true,
		302: true,
		303: true,
		305: true,
		307: true,
		308: true
	};
	status2.empty = {
		204: true,
		205: true,
		304: true
	};
	status2.retry = {
		502: true,
		503: true,
		504: true
	};
	function createMessageToStatusCodeMap(codes2) {
		var map = {};
		Object.keys(codes2).forEach(function forEachCode(code) {
			var message = codes2[code];
			var status3 = Number(code);
			map[message.toLowerCase()] = status3;
		});
		return map;
	}
	function createStatusCodeList(codes2) {
		return Object.keys(codes2).map(function mapCode(code) {
			return Number(code);
		});
	}
	function getStatusCode(message) {
		var msg = message.toLowerCase();
		if (!Object.prototype.hasOwnProperty.call(status2.code, msg)) throw new Error("invalid status message: \"" + message + "\"");
		return status2.code[msg];
	}
	function getStatusMessage(code) {
		if (!Object.prototype.hasOwnProperty.call(status2.message, code)) throw new Error("invalid status code: " + code);
		return status2.message[code];
	}
	function status2(code) {
		if (typeof code === "number") return getStatusMessage(code);
		if (typeof code !== "string") throw new TypeError("code must be a number or string");
		var n = parseInt(code, 10);
		if (!isNaN(n)) return getStatusMessage(n);
		return getStatusCode(code);
	}
} });
var TimeDuration = class _TimeDuration {
	__time_duration_micros__;
	static MICROS_PER_MILLIS = 1000n;
	/**
	* Get the algebraic type representation of the {@link TimeDuration} type.
	* @returns The algebraic type representation of the type.
	*/
	static getAlgebraicType() {
		return AlgebraicType.Product({ elements: [{
			name: "__time_duration_micros__",
			algebraicType: AlgebraicType.I64
		}] });
	}
	static isTimeDuration(algebraicType) {
		if (algebraicType.tag !== "Product") return false;
		const elements = algebraicType.value.elements;
		if (elements.length !== 1) return false;
		const microsElement = elements[0];
		return microsElement.name === "__time_duration_micros__" && microsElement.algebraicType.tag === "I64";
	}
	get micros() {
		return this.__time_duration_micros__;
	}
	get millis() {
		return Number(this.micros / _TimeDuration.MICROS_PER_MILLIS);
	}
	constructor(micros) {
		this.__time_duration_micros__ = micros;
	}
	static fromMillis(millis) {
		return new _TimeDuration(BigInt(millis) * _TimeDuration.MICROS_PER_MILLIS);
	}
	/** This outputs the same string format that we use in the host and in Rust modules */
	toString() {
		const micros = this.micros;
		const sign = micros < 0 ? "-" : "+";
		const pos = micros < 0 ? -micros : micros;
		const secs = pos / 1000000n;
		const micros_remaining = pos % 1000000n;
		return `${sign}${secs}.${String(micros_remaining).padStart(6, "0")}`;
	}
};
var Timestamp = class _Timestamp {
	__timestamp_micros_since_unix_epoch__;
	static MICROS_PER_MILLIS = 1000n;
	get microsSinceUnixEpoch() {
		return this.__timestamp_micros_since_unix_epoch__;
	}
	constructor(micros) {
		this.__timestamp_micros_since_unix_epoch__ = micros;
	}
	/**
	* Get the algebraic type representation of the {@link Timestamp} type.
	* @returns The algebraic type representation of the type.
	*/
	static getAlgebraicType() {
		return AlgebraicType.Product({ elements: [{
			name: "__timestamp_micros_since_unix_epoch__",
			algebraicType: AlgebraicType.I64
		}] });
	}
	static isTimestamp(algebraicType) {
		if (algebraicType.tag !== "Product") return false;
		const elements = algebraicType.value.elements;
		if (elements.length !== 1) return false;
		const microsElement = elements[0];
		return microsElement.name === "__timestamp_micros_since_unix_epoch__" && microsElement.algebraicType.tag === "I64";
	}
	/**
	* The Unix epoch, the midnight at the beginning of January 1, 1970, UTC.
	*/
	static UNIX_EPOCH = new _Timestamp(0n);
	/**
	* Get a `Timestamp` representing the execution environment's belief of the current moment in time.
	*/
	static now() {
		return _Timestamp.fromDate(/* @__PURE__ */ new Date());
	}
	/** Convert to milliseconds since Unix epoch. */
	toMillis() {
		return this.microsSinceUnixEpoch / 1000n;
	}
	/**
	* Get a `Timestamp` representing the same point in time as `date`.
	*/
	static fromDate(date) {
		const millis = date.getTime();
		return new _Timestamp(BigInt(millis) * _Timestamp.MICROS_PER_MILLIS);
	}
	/**
	* Get a `Date` representing approximately the same point in time as `this`.
	*
	* This method truncates to millisecond precision,
	* and throws `RangeError` if the `Timestamp` is outside the range representable as a `Date`.
	*/
	toDate() {
		const millis = this.__timestamp_micros_since_unix_epoch__ / _Timestamp.MICROS_PER_MILLIS;
		if (millis > BigInt(Number.MAX_SAFE_INTEGER) || millis < BigInt(Number.MIN_SAFE_INTEGER)) throw new RangeError("Timestamp is outside of the representable range of JS's Date");
		return new Date(Number(millis));
	}
	since(other) {
		return new TimeDuration(this.__timestamp_micros_since_unix_epoch__ - other.__timestamp_micros_since_unix_epoch__);
	}
};
var Uuid = class _Uuid {
	__uuid__;
	/**
	* The nil UUID (all zeros).
	*
	* @example
	* ```ts
	* const uuid = Uuid.NIL;
	* console.assert(
	*   uuid.toString() === "00000000-0000-0000-0000-000000000000"
	* );
	* ```
	*/
	static NIL = new _Uuid(0n);
	static MAX_UUID_BIGINT = 340282366920938463463374607431768211455n;
	/**
	* The max UUID (all ones).
	*
	* @example
	* ```ts
	* const uuid = Uuid.MAX;
	* console.assert(
	*   uuid.toString() === "ffffffff-ffff-ffff-ffff-ffffffffffff"
	* );
	* ```
	*/
	static MAX = new _Uuid(_Uuid.MAX_UUID_BIGINT);
	/**
	* Create a UUID from a raw 128-bit value.
	*
	* @param u - Unsigned 128-bit integer
	* @throws {Error} If the value is outside the valid UUID range
	*/
	constructor(u) {
		if (u < 0n || u > _Uuid.MAX_UUID_BIGINT) throw new Error("Invalid UUID: must be between 0 and `MAX_UUID_BIGINT`");
		this.__uuid__ = u;
	}
	/**
	* Create a UUID `v4` from explicit random bytes.
	*
	* This method assumes the bytes are already sufficiently random.
	* It only sets the appropriate bits for the UUID version and variant.
	*
	* @param bytes - Exactly 16 random bytes
	* @returns A UUID `v4`
	* @throws {Error} If `bytes.length !== 16`
	*
	* @example
	* ```ts
	* const randomBytes = new Uint8Array(16);
	* const uuid = Uuid.fromRandomBytesV4(randomBytes);
	*
	* console.assert(
	*   uuid.toString() === "00000000-0000-4000-8000-000000000000"
	* );
	* ```
	*/
	static fromRandomBytesV4(bytes) {
		if (bytes.length !== 16) throw new Error("UUID v4 requires 16 bytes");
		const arr = new Uint8Array(bytes);
		arr[6] = arr[6] & 15 | 64;
		arr[8] = arr[8] & 63 | 128;
		return new _Uuid(_Uuid.bytesToBigInt(arr));
	}
	/**
	* Generate a UUID `v7` using a monotonic counter from `0` to `2^31 - 1`,
	* a timestamp, and 4 random bytes.
	*
	* The counter wraps around on overflow.
	*
	* The UUID `v7` is structured as follows:
	*
	* ```ascii
	* ┌───────────────────────────────────────────────┬───────────────────┐
	* | B0  | B1  | B2  | B3  | B4  | B5              |         B6        |
	* ├───────────────────────────────────────────────┼───────────────────┤
	* |                 unix_ts_ms                    |      version 7    |
	* └───────────────────────────────────────────────┴───────────────────┘
	* ┌──────────────┬─────────┬──────────────────┬───────────────────────┐
	* | B7           | B8      | B9  | B10 | B11  | B12 | B13 | B14 | B15 |
	* ├──────────────┼─────────┼──────────────────┼───────────────────────┤
	* | counter_high | variant |    counter_low   |        random         |
	* └──────────────┴─────────┴──────────────────┴───────────────────────┘
	* ```
	*
	* @param counter - Mutable monotonic counter (31-bit)
	* @param now - Timestamp since the Unix epoch
	* @param randomBytes - Exactly 4 random bytes
	* @returns A UUID `v7`
	*
	* @throws {Error} If the `counter` is negative
	* @throws {Error} If the `timestamp` is before the Unix epoch
	* @throws {Error} If `randomBytes.length !== 4`
	*
	* @example
	* ```ts
	* const now = Timestamp.fromMillis(1_686_000_000_000n);
	* const counter = { value: 1 };
	* const randomBytes = new Uint8Array(4);
	*
	* const uuid = Uuid.fromCounterV7(counter, now, randomBytes);
	*
	* console.assert(
	*   uuid.toString() === "0000647e-5180-7000-8000-000200000000"
	* );
	* ```
	*/
	static fromCounterV7(counter, now, randomBytes) {
		if (randomBytes.length !== 4) throw new Error("`fromCounterV7` requires `randomBytes.length == 4`");
		if (counter.value < 0) throw new Error("`fromCounterV7` uuid `counter` must be non-negative");
		if (now.__timestamp_micros_since_unix_epoch__ < 0) throw new Error("`fromCounterV7` `timestamp` before unix epoch");
		const counterVal = counter.value;
		counter.value = counterVal + 1 & 2147483647;
		const tsMs = now.toMillis() & 281474976710655n;
		const bytes = new Uint8Array(16);
		bytes[0] = Number(tsMs >> 40n & 255n);
		bytes[1] = Number(tsMs >> 32n & 255n);
		bytes[2] = Number(tsMs >> 24n & 255n);
		bytes[3] = Number(tsMs >> 16n & 255n);
		bytes[4] = Number(tsMs >> 8n & 255n);
		bytes[5] = Number(tsMs & 255n);
		bytes[7] = counterVal >>> 23 & 255;
		bytes[9] = counterVal >>> 15 & 255;
		bytes[10] = counterVal >>> 7 & 255;
		bytes[11] = (counterVal & 127) << 1 & 255;
		bytes[12] |= randomBytes[0] & 127;
		bytes[13] = randomBytes[1];
		bytes[14] = randomBytes[2];
		bytes[15] = randomBytes[3];
		bytes[6] = bytes[6] & 15 | 112;
		bytes[8] = bytes[8] & 63 | 128;
		return new _Uuid(_Uuid.bytesToBigInt(bytes));
	}
	/**
	* Parse a UUID from a string representation.
	*
	* @param s - UUID string
	* @returns Parsed UUID
	* @throws {Error} If the string is not a valid UUID
	*
	* @example
	* ```ts
	* const s = "01888d6e-5c00-7000-8000-000000000000";
	* const uuid = Uuid.parse(s);
	*
	* console.assert(uuid.toString() === s);
	* ```
	*/
	static parse(s) {
		const hex = s.replace(/-/g, "");
		if (hex.length !== 32) throw new Error("Invalid hex UUID");
		let v = 0n;
		for (let i = 0; i < 32; i += 2) v = v << 8n | BigInt(parseInt(hex.slice(i, i + 2), 16));
		return new _Uuid(v);
	}
	/** Convert to string (hyphenated form). */
	toString() {
		const hex = [..._Uuid.bigIntToBytes(this.__uuid__)].map((b) => b.toString(16).padStart(2, "0")).join("");
		return hex.slice(0, 8) + "-" + hex.slice(8, 12) + "-" + hex.slice(12, 16) + "-" + hex.slice(16, 20) + "-" + hex.slice(20);
	}
	/** Convert to bigint (u128). */
	asBigInt() {
		return this.__uuid__;
	}
	/** Return a `Uint8Array` of 16 bytes. */
	toBytes() {
		return _Uuid.bigIntToBytes(this.__uuid__);
	}
	static bytesToBigInt(bytes) {
		let result = 0n;
		for (const b of bytes) result = result << 8n | BigInt(b);
		return result;
	}
	static bigIntToBytes(value) {
		const bytes = new Uint8Array(16);
		for (let i = 15; i >= 0; i--) {
			bytes[i] = Number(value & 255n);
			value >>= 8n;
		}
		return bytes;
	}
	/**
	* Returns the version of this UUID.
	*
	* This represents the algorithm used to generate the value.
	*
	* @returns A `UuidVersion`
	* @throws {Error} If the version field is not recognized
	*/
	getVersion() {
		const version = this.toBytes()[6] >> 4 & 15;
		switch (version) {
			case 4: return "V4";
			case 7: return "V7";
			default:
				if (this == _Uuid.NIL) return "Nil";
				if (this == _Uuid.MAX) return "Max";
				throw new Error(`Unsupported UUID version: ${version}`);
		}
	}
	/**
	* Extract the monotonic counter from a UUIDv7.
	*
	* Intended for testing and diagnostics.
	* Behavior is undefined if called on a non-V7 UUID.
	*
	* @returns 31-bit counter value
	*/
	getCounter() {
		const bytes = this.toBytes();
		const high = bytes[7];
		const mid1 = bytes[9];
		const mid2 = bytes[10];
		const low = bytes[11] >>> 1;
		return high << 23 | mid1 << 15 | mid2 << 7 | low | 0;
	}
	compareTo(other) {
		if (this.__uuid__ < other.__uuid__) return -1;
		if (this.__uuid__ > other.__uuid__) return 1;
		return 0;
	}
	static getAlgebraicType() {
		return AlgebraicType.Product({ elements: [{
			name: "__uuid__",
			algebraicType: AlgebraicType.U128
		}] });
	}
};
var BinaryReader = class {
	/**
	* The DataView used to read values from the binary data.
	*
	* Note: The DataView's `byteOffset` is relative to the beginning of the
	* underlying ArrayBuffer, not the start of the provided Uint8Array input.
	* This `BinaryReader`'s `#offset` field is used to track the current read position
	* relative to the start of the provided Uint8Array input.
	*/
	#view;
	/**
	* Represents the offset (in bytes) relative to the start of the DataView
	* and provided Uint8Array input.
	*
	* Note: This is *not* the absolute byte offset within the underlying ArrayBuffer.
	*/
	#offset = 0;
	constructor(input) {
		this.#view = new DataView(input.buffer, input.byteOffset, input.byteLength);
		this.#offset = 0;
	}
	get offset() {
		return this.#offset;
	}
	get remaining() {
		return this.#view.byteLength - this.#offset;
	}
	/** Ensure we have at least `n` bytes left to read */
	#ensure(n) {
		if (this.#offset + n > this.#view.byteLength) throw new RangeError(`Tried to read ${n} byte(s) at relative offset ${this.#offset}, but only ${this.remaining} byte(s) remain`);
	}
	readUInt8Array() {
		const length = this.readU32();
		this.#ensure(length);
		return this.readBytes(length);
	}
	readBool() {
		const value = this.#view.getUint8(this.#offset);
		this.#offset += 1;
		return value !== 0;
	}
	readByte() {
		const value = this.#view.getUint8(this.#offset);
		this.#offset += 1;
		return value;
	}
	readBytes(length) {
		const array = new Uint8Array(this.#view.buffer, this.#view.byteOffset + this.#offset, length);
		this.#offset += length;
		return array;
	}
	readI8() {
		const value = this.#view.getInt8(this.#offset);
		this.#offset += 1;
		return value;
	}
	readU8() {
		return this.readByte();
	}
	readI16() {
		const value = this.#view.getInt16(this.#offset, true);
		this.#offset += 2;
		return value;
	}
	readU16() {
		const value = this.#view.getUint16(this.#offset, true);
		this.#offset += 2;
		return value;
	}
	readI32() {
		const value = this.#view.getInt32(this.#offset, true);
		this.#offset += 4;
		return value;
	}
	readU32() {
		const value = this.#view.getUint32(this.#offset, true);
		this.#offset += 4;
		return value;
	}
	readI64() {
		const value = this.#view.getBigInt64(this.#offset, true);
		this.#offset += 8;
		return value;
	}
	readU64() {
		const value = this.#view.getBigUint64(this.#offset, true);
		this.#offset += 8;
		return value;
	}
	readU128() {
		const lowerPart = this.#view.getBigUint64(this.#offset, true);
		const upperPart = this.#view.getBigUint64(this.#offset + 8, true);
		this.#offset += 16;
		return (upperPart << BigInt(64)) + lowerPart;
	}
	readI128() {
		const lowerPart = this.#view.getBigUint64(this.#offset, true);
		const upperPart = this.#view.getBigInt64(this.#offset + 8, true);
		this.#offset += 16;
		return (upperPart << BigInt(64)) + lowerPart;
	}
	readU256() {
		const p0 = this.#view.getBigUint64(this.#offset, true);
		const p1 = this.#view.getBigUint64(this.#offset + 8, true);
		const p2 = this.#view.getBigUint64(this.#offset + 16, true);
		const p3 = this.#view.getBigUint64(this.#offset + 24, true);
		this.#offset += 32;
		return (p3 << BigInt(192)) + (p2 << BigInt(128)) + (p1 << BigInt(64)) + p0;
	}
	readI256() {
		const p0 = this.#view.getBigUint64(this.#offset, true);
		const p1 = this.#view.getBigUint64(this.#offset + 8, true);
		const p2 = this.#view.getBigUint64(this.#offset + 16, true);
		const p3 = this.#view.getBigInt64(this.#offset + 24, true);
		this.#offset += 32;
		return (p3 << BigInt(192)) + (p2 << BigInt(128)) + (p1 << BigInt(64)) + p0;
	}
	readF32() {
		const value = this.#view.getFloat32(this.#offset, true);
		this.#offset += 4;
		return value;
	}
	readF64() {
		const value = this.#view.getFloat64(this.#offset, true);
		this.#offset += 8;
		return value;
	}
	readString() {
		const uint8Array = this.readUInt8Array();
		return new TextDecoder("utf-8").decode(uint8Array);
	}
};
var import_base64_js = __toESM(require_base64_js());
var BinaryWriter = class {
	#buffer;
	#view;
	#offset = 0;
	constructor(size) {
		this.#buffer = new Uint8Array(size);
		this.#view = new DataView(this.#buffer.buffer);
	}
	#expandBuffer(additionalCapacity) {
		const minCapacity = this.#offset + additionalCapacity + 1;
		if (minCapacity <= this.#buffer.length) return;
		let newCapacity = this.#buffer.length * 2;
		if (newCapacity < minCapacity) newCapacity = minCapacity;
		const newBuffer = new Uint8Array(newCapacity);
		newBuffer.set(this.#buffer);
		this.#buffer = newBuffer;
		this.#view = new DataView(this.#buffer.buffer);
	}
	toBase64() {
		return (0, import_base64_js.fromByteArray)(this.#buffer.subarray(0, this.#offset));
	}
	getBuffer() {
		return this.#buffer.slice(0, this.#offset);
	}
	get offset() {
		return this.#offset;
	}
	writeUInt8Array(value) {
		const length = value.length;
		this.#expandBuffer(4 + length);
		this.writeU32(length);
		this.#buffer.set(value, this.#offset);
		this.#offset += value.length;
	}
	writeBool(value) {
		this.#expandBuffer(1);
		this.#view.setUint8(this.#offset, value ? 1 : 0);
		this.#offset += 1;
	}
	writeByte(value) {
		this.#expandBuffer(1);
		this.#view.setUint8(this.#offset, value);
		this.#offset += 1;
	}
	writeI8(value) {
		this.#expandBuffer(1);
		this.#view.setInt8(this.#offset, value);
		this.#offset += 1;
	}
	writeU8(value) {
		this.#expandBuffer(1);
		this.#view.setUint8(this.#offset, value);
		this.#offset += 1;
	}
	writeI16(value) {
		this.#expandBuffer(2);
		this.#view.setInt16(this.#offset, value, true);
		this.#offset += 2;
	}
	writeU16(value) {
		this.#expandBuffer(2);
		this.#view.setUint16(this.#offset, value, true);
		this.#offset += 2;
	}
	writeI32(value) {
		this.#expandBuffer(4);
		this.#view.setInt32(this.#offset, value, true);
		this.#offset += 4;
	}
	writeU32(value) {
		this.#expandBuffer(4);
		this.#view.setUint32(this.#offset, value, true);
		this.#offset += 4;
	}
	writeI64(value) {
		this.#expandBuffer(8);
		this.#view.setBigInt64(this.#offset, value, true);
		this.#offset += 8;
	}
	writeU64(value) {
		this.#expandBuffer(8);
		this.#view.setBigUint64(this.#offset, value, true);
		this.#offset += 8;
	}
	writeU128(value) {
		this.#expandBuffer(16);
		const lowerPart = value & BigInt("0xFFFFFFFFFFFFFFFF");
		const upperPart = value >> BigInt(64);
		this.#view.setBigUint64(this.#offset, lowerPart, true);
		this.#view.setBigUint64(this.#offset + 8, upperPart, true);
		this.#offset += 16;
	}
	writeI128(value) {
		this.#expandBuffer(16);
		const lowerPart = value & BigInt("0xFFFFFFFFFFFFFFFF");
		const upperPart = value >> BigInt(64);
		this.#view.setBigInt64(this.#offset, lowerPart, true);
		this.#view.setBigInt64(this.#offset + 8, upperPart, true);
		this.#offset += 16;
	}
	writeU256(value) {
		this.#expandBuffer(32);
		const low_64_mask = BigInt("0xFFFFFFFFFFFFFFFF");
		const p0 = value & low_64_mask;
		const p1 = value >> BigInt(64) & low_64_mask;
		const p2 = value >> BigInt(128) & low_64_mask;
		const p3 = value >> BigInt(192);
		this.#view.setBigUint64(this.#offset + 0, p0, true);
		this.#view.setBigUint64(this.#offset + 8, p1, true);
		this.#view.setBigUint64(this.#offset + 16, p2, true);
		this.#view.setBigUint64(this.#offset + 24, p3, true);
		this.#offset += 32;
	}
	writeI256(value) {
		this.#expandBuffer(32);
		const low_64_mask = BigInt("0xFFFFFFFFFFFFFFFF");
		const p0 = value & low_64_mask;
		const p1 = value >> BigInt(64) & low_64_mask;
		const p2 = value >> BigInt(128) & low_64_mask;
		const p3 = value >> BigInt(192);
		this.#view.setBigUint64(this.#offset + 0, p0, true);
		this.#view.setBigUint64(this.#offset + 8, p1, true);
		this.#view.setBigUint64(this.#offset + 16, p2, true);
		this.#view.setBigInt64(this.#offset + 24, p3, true);
		this.#offset += 32;
	}
	writeF32(value) {
		this.#expandBuffer(4);
		this.#view.setFloat32(this.#offset, value, true);
		this.#offset += 4;
	}
	writeF64(value) {
		this.#expandBuffer(8);
		this.#view.setFloat64(this.#offset, value, true);
		this.#offset += 8;
	}
	writeString(value) {
		const encodedString = new TextEncoder().encode(value);
		this.writeU32(encodedString.length);
		this.#expandBuffer(encodedString.length);
		this.#buffer.set(encodedString, this.#offset);
		this.#offset += encodedString.length;
	}
};
function toPascalCase(s) {
	const str$1 = s.replace(/([-_][a-z])/gi, ($1) => {
		return $1.toUpperCase().replace("-", "").replace("_", "");
	});
	return str$1.charAt(0).toUpperCase() + str$1.slice(1);
}
function uint8ArrayToHexString(array) {
	return Array.prototype.map.call(array.reverse(), (x) => ("00" + x.toString(16)).slice(-2)).join("");
}
function uint8ArrayToU128(array) {
	if (array.length != 16) throw new Error(`Uint8Array is not 16 bytes long: ${array}`);
	return new BinaryReader(array).readU128();
}
function uint8ArrayToU256(array) {
	if (array.length != 32) throw new Error(`Uint8Array is not 32 bytes long: [${array}]`);
	return new BinaryReader(array).readU256();
}
function hexStringToUint8Array(str$1) {
	if (str$1.startsWith("0x")) str$1 = str$1.slice(2);
	const matches = str$1.match(/.{1,2}/g) || [];
	return Uint8Array.from(matches.map((byte) => parseInt(byte, 16))).reverse();
}
function hexStringToU128(str$1) {
	return uint8ArrayToU128(hexStringToUint8Array(str$1));
}
function hexStringToU256(str$1) {
	return uint8ArrayToU256(hexStringToUint8Array(str$1));
}
function u128ToUint8Array(data) {
	const writer = new BinaryWriter(16);
	writer.writeU128(data);
	return writer.getBuffer();
}
function u128ToHexString(data) {
	return uint8ArrayToHexString(u128ToUint8Array(data));
}
function u256ToUint8Array(data) {
	const writer = new BinaryWriter(32);
	writer.writeU256(data);
	return writer.getBuffer();
}
function u256ToHexString(data) {
	return uint8ArrayToHexString(u256ToUint8Array(data));
}
function toCamelCase(str$1) {
	return str$1.replace(/[-_]+/g, "_").replace(/_([a-zA-Z0-9])/g, (_$1, c) => c.toUpperCase());
}
function bsatnBaseSize(typespace, ty) {
	const assumedArrayLength = 4;
	while (ty.tag === "Ref") ty = typespace.types[ty.value];
	if (ty.tag === "Product") {
		let sum = 0;
		for (const { algebraicType: elem } of ty.value.elements) sum += bsatnBaseSize(typespace, elem);
		return sum;
	} else if (ty.tag === "Sum") {
		let min = Infinity;
		for (const { algebraicType: vari } of ty.value.variants) {
			const vSize = bsatnBaseSize(typespace, vari);
			if (vSize < min) min = vSize;
		}
		if (min === Infinity) min = 0;
		return 4 + min;
	} else if (ty.tag == "Array") return 4 + assumedArrayLength * bsatnBaseSize(typespace, ty.value);
	return {
		String: 4 + assumedArrayLength,
		Sum: 1,
		Bool: 1,
		I8: 1,
		U8: 1,
		I16: 2,
		U16: 2,
		I32: 4,
		U32: 4,
		F32: 4,
		I64: 8,
		U64: 8,
		F64: 8,
		I128: 16,
		U128: 16,
		I256: 32,
		U256: 32
	}[ty.tag];
}
var ConnectionId = class _ConnectionId {
	__connection_id__;
	/**
	* Creates a new `ConnectionId`.
	*/
	constructor(data) {
		this.__connection_id__ = data;
	}
	/**
	* Get the algebraic type representation of the {@link ConnectionId} type.
	* @returns The algebraic type representation of the type.
	*/
	static getAlgebraicType() {
		return AlgebraicType.Product({ elements: [{
			name: "__connection_id__",
			algebraicType: AlgebraicType.U128
		}] });
	}
	isZero() {
		return this.__connection_id__ === BigInt(0);
	}
	static nullIfZero(addr) {
		if (addr.isZero()) return null;
		else return addr;
	}
	static random() {
		function randomU8() {
			return Math.floor(Math.random() * 255);
		}
		let result = BigInt(0);
		for (let i = 0; i < 16; i++) result = result << BigInt(8) | BigInt(randomU8());
		return new _ConnectionId(result);
	}
	/**
	* Compare two connection IDs for equality.
	*/
	isEqual(other) {
		return this.__connection_id__ == other.__connection_id__;
	}
	/**
	* Check if two connection IDs are equal.
	*/
	equals(other) {
		return this.isEqual(other);
	}
	/**
	* Print the connection ID as a hexadecimal string.
	*/
	toHexString() {
		return u128ToHexString(this.__connection_id__);
	}
	/**
	* Convert the connection ID to a Uint8Array.
	*/
	toUint8Array() {
		return u128ToUint8Array(this.__connection_id__);
	}
	/**
	* Parse a connection ID from a hexadecimal string.
	*/
	static fromString(str$1) {
		return new _ConnectionId(hexStringToU128(str$1));
	}
	static fromStringOrNull(str$1) {
		const addr = _ConnectionId.fromString(str$1);
		if (addr.isZero()) return null;
		else return addr;
	}
};
var Identity = class _Identity {
	__identity__;
	/**
	* Creates a new `Identity`.
	*
	* `data` can be a hexadecimal string or a `bigint`.
	*/
	constructor(data) {
		this.__identity__ = typeof data === "string" ? hexStringToU256(data) : data;
	}
	/**
	* Get the algebraic type representation of the {@link Identity} type.
	* @returns The algebraic type representation of the type.
	*/
	static getAlgebraicType() {
		return AlgebraicType.Product({ elements: [{
			name: "__identity__",
			algebraicType: AlgebraicType.U256
		}] });
	}
	/**
	* Check if two identities are equal.
	*/
	isEqual(other) {
		return this.toHexString() === other.toHexString();
	}
	/**
	* Check if two identities are equal.
	*/
	equals(other) {
		return this.isEqual(other);
	}
	/**
	* Print the identity as a hexadecimal string.
	*/
	toHexString() {
		return u256ToHexString(this.__identity__);
	}
	/**
	* Convert the address to a Uint8Array.
	*/
	toUint8Array() {
		return u256ToUint8Array(this.__identity__);
	}
	/**
	* Parse an Identity from a hexadecimal string.
	*/
	static fromString(str$1) {
		return new _Identity(str$1);
	}
	/**
	* Zero identity (0x0000000000000000000000000000000000000000000000000000000000000000)
	*/
	static zero() {
		return new _Identity(0n);
	}
	toString() {
		return this.toHexString();
	}
};
var AlgebraicType = {
	Ref: (value) => ({
		tag: "Ref",
		value
	}),
	Sum: (value) => ({
		tag: "Sum",
		value
	}),
	Product: (value) => ({
		tag: "Product",
		value
	}),
	Array: (value) => ({
		tag: "Array",
		value
	}),
	String: { tag: "String" },
	Bool: { tag: "Bool" },
	I8: { tag: "I8" },
	U8: { tag: "U8" },
	I16: { tag: "I16" },
	U16: { tag: "U16" },
	I32: { tag: "I32" },
	U32: { tag: "U32" },
	I64: { tag: "I64" },
	U64: { tag: "U64" },
	I128: { tag: "I128" },
	U128: { tag: "U128" },
	I256: { tag: "I256" },
	U256: { tag: "U256" },
	F32: { tag: "F32" },
	F64: { tag: "F64" },
	serializeValue(writer, ty, value, typespace) {
		if (ty.tag === "Ref") {
			if (!typespace) throw new Error("cannot serialize refs without a typespace");
			while (ty.tag === "Ref") ty = typespace.types[ty.value];
		}
		switch (ty.tag) {
			case "Product":
				ProductType.serializeValue(writer, ty.value, value, typespace);
				break;
			case "Sum":
				SumType.serializeValue(writer, ty.value, value, typespace);
				break;
			case "Array":
				if (ty.value.tag === "U8") writer.writeUInt8Array(value);
				else {
					const elemType = ty.value;
					writer.writeU32(value.length);
					for (const elem of value) AlgebraicType.serializeValue(writer, elemType, elem, typespace);
				}
				break;
			case "Bool":
				writer.writeBool(value);
				break;
			case "I8":
				writer.writeI8(value);
				break;
			case "U8":
				writer.writeU8(value);
				break;
			case "I16":
				writer.writeI16(value);
				break;
			case "U16":
				writer.writeU16(value);
				break;
			case "I32":
				writer.writeI32(value);
				break;
			case "U32":
				writer.writeU32(value);
				break;
			case "I64":
				writer.writeI64(value);
				break;
			case "U64":
				writer.writeU64(value);
				break;
			case "I128":
				writer.writeI128(value);
				break;
			case "U128":
				writer.writeU128(value);
				break;
			case "I256":
				writer.writeI256(value);
				break;
			case "U256":
				writer.writeU256(value);
				break;
			case "F32":
				writer.writeF32(value);
				break;
			case "F64":
				writer.writeF64(value);
				break;
			case "String":
				writer.writeString(value);
				break;
		}
	},
	deserializeValue: function(reader, ty, typespace) {
		if (ty.tag === "Ref") {
			if (!typespace) throw new Error("cannot deserialize refs without a typespace");
			while (ty.tag === "Ref") ty = typespace.types[ty.value];
		}
		switch (ty.tag) {
			case "Product": return ProductType.deserializeValue(reader, ty.value, typespace);
			case "Sum": return SumType.deserializeValue(reader, ty.value, typespace);
			case "Array": if (ty.value.tag === "U8") return reader.readUInt8Array();
			else {
				const elemType = ty.value;
				const length = reader.readU32();
				const result = [];
				for (let i = 0; i < length; i++) result.push(AlgebraicType.deserializeValue(reader, elemType, typespace));
				return result;
			}
			case "Bool": return reader.readBool();
			case "I8": return reader.readI8();
			case "U8": return reader.readU8();
			case "I16": return reader.readI16();
			case "U16": return reader.readU16();
			case "I32": return reader.readI32();
			case "U32": return reader.readU32();
			case "I64": return reader.readI64();
			case "U64": return reader.readU64();
			case "I128": return reader.readI128();
			case "U128": return reader.readU128();
			case "I256": return reader.readI256();
			case "U256": return reader.readU256();
			case "F32": return reader.readF32();
			case "F64": return reader.readF64();
			case "String": return reader.readString();
		}
	},
	intoMapKey: function(ty, value) {
		switch (ty.tag) {
			case "U8":
			case "U16":
			case "U32":
			case "U64":
			case "U128":
			case "U256":
			case "I8":
			case "I16":
			case "I32":
			case "I64":
			case "I128":
			case "I256":
			case "F32":
			case "F64":
			case "String":
			case "Bool": return value;
			case "Product": return ProductType.intoMapKey(ty.value, value);
			default: {
				const writer = new BinaryWriter(10);
				AlgebraicType.serializeValue(writer, ty, value);
				return writer.toBase64();
			}
		}
	}
};
var ProductType = {
	serializeValue(writer, ty, value, typespace) {
		for (const element of ty.elements) AlgebraicType.serializeValue(writer, element.algebraicType, value[element.name], typespace);
	},
	deserializeValue(reader, ty, typespace) {
		const result = {};
		if (ty.elements.length === 1) {
			if (ty.elements[0].name === "__time_duration_micros__") return new TimeDuration(reader.readI64());
			if (ty.elements[0].name === "__timestamp_micros_since_unix_epoch__") return new Timestamp(reader.readI64());
			if (ty.elements[0].name === "__identity__") return new Identity(reader.readU256());
			if (ty.elements[0].name === "__connection_id__") return new ConnectionId(reader.readU128());
			if (ty.elements[0].name === "__uuid__") return new Uuid(reader.readU128());
		}
		for (const element of ty.elements) result[element.name] = AlgebraicType.deserializeValue(reader, element.algebraicType, typespace);
		return result;
	},
	intoMapKey(ty, value) {
		if (ty.elements.length === 1) {
			if (ty.elements[0].name === "__time_duration_micros__") return value.__time_duration_micros__;
			if (ty.elements[0].name === "__timestamp_micros_since_unix_epoch__") return value.__timestamp_micros_since_unix_epoch__;
			if (ty.elements[0].name === "__identity__") return value.__identity__;
			if (ty.elements[0].name === "__connection_id__") return value.__connection_id__;
			if (ty.elements[0].name === "__uuid__") return value.__uuid__;
		}
		const writer = new BinaryWriter(10);
		AlgebraicType.serializeValue(writer, AlgebraicType.Product(ty), value);
		return writer.toBase64();
	}
};
var SumType = {
	serializeValue: function(writer, ty, value, typespace) {
		if (ty.variants.length == 2 && ty.variants[0].name === "some" && ty.variants[1].name === "none") if (value !== null && value !== void 0) {
			writer.writeByte(0);
			AlgebraicType.serializeValue(writer, ty.variants[0].algebraicType, value, typespace);
		} else writer.writeByte(1);
		else if (ty.variants.length == 2 && ty.variants[0].name === "ok" && ty.variants[1].name === "err") {
			let variantName;
			let innerValue;
			let index;
			if ("ok" in value) {
				variantName = "ok";
				innerValue = value.ok;
				index = 0;
			} else {
				variantName = "err";
				innerValue = value.err;
				index = 1;
			}
			if (index < 0) throw `Result serialization error: variant '${variantName}' not found in ${JSON.stringify(ty)}`;
			writer.writeU8(index);
			AlgebraicType.serializeValue(writer, ty.variants[index].algebraicType, innerValue, typespace);
		} else {
			const variant = value["tag"];
			const index = ty.variants.findIndex((v) => v.name === variant);
			if (index < 0) throw `Can't serialize a sum type, couldn't find ${value.tag} tag ${JSON.stringify(value)} in variants ${JSON.stringify(ty)}`;
			writer.writeU8(index);
			AlgebraicType.serializeValue(writer, ty.variants[index].algebraicType, value["value"], typespace);
		}
	},
	deserializeValue: function(reader, ty, typespace) {
		const tag = reader.readU8();
		if (ty.variants.length == 2 && ty.variants[0].name === "some" && ty.variants[1].name === "none") if (tag === 0) return AlgebraicType.deserializeValue(reader, ty.variants[0].algebraicType, typespace);
		else if (tag === 1) return;
		else throw `Can't deserialize an option type, couldn't find ${tag} tag`;
		else if (ty.variants.length == 2 && ty.variants[0].name === "ok" && ty.variants[1].name === "err") if (tag === 0) return { ok: AlgebraicType.deserializeValue(reader, ty.variants[0].algebraicType, typespace) };
		else if (tag === 1) return { err: AlgebraicType.deserializeValue(reader, ty.variants[1].algebraicType, typespace) };
		else throw `Can't deserialize a result type, couldn't find ${tag} tag`;
		else {
			const variant = ty.variants[tag];
			const value = AlgebraicType.deserializeValue(reader, variant.algebraicType, typespace);
			return {
				tag: variant.name,
				value
			};
		}
	}
};
var Option = { getAlgebraicType(innerType) {
	return AlgebraicType.Sum({ variants: [{
		name: "some",
		algebraicType: innerType
	}, {
		name: "none",
		algebraicType: AlgebraicType.Product({ elements: [] })
	}] });
} };
var Result = { getAlgebraicType(okType, errType) {
	return AlgebraicType.Sum({ variants: [{
		name: "ok",
		algebraicType: okType
	}, {
		name: "err",
		algebraicType: errType
	}] });
} };
var ScheduleAt = {
	interval(value) {
		return Interval(value);
	},
	time(value) {
		return Time(value);
	},
	getAlgebraicType() {
		return AlgebraicType.Sum({ variants: [{
			name: "Interval",
			algebraicType: TimeDuration.getAlgebraicType()
		}, {
			name: "Time",
			algebraicType: Timestamp.getAlgebraicType()
		}] });
	},
	isScheduleAt(algebraicType) {
		if (algebraicType.tag !== "Sum") return false;
		const variants = algebraicType.value.variants;
		if (variants.length !== 2) return false;
		const intervalVariant = variants.find((v) => v.name === "Interval");
		const timeVariant = variants.find((v) => v.name === "Time");
		if (!intervalVariant || !timeVariant) return false;
		return TimeDuration.isTimeDuration(intervalVariant.algebraicType) && Timestamp.isTimestamp(timeVariant.algebraicType);
	}
};
var Interval = (micros) => ({
	tag: "Interval",
	value: new TimeDuration(micros)
});
var Time = (microsSinceUnixEpoch) => ({
	tag: "Time",
	value: new Timestamp(microsSinceUnixEpoch)
});
var schedule_at_default = ScheduleAt;
function set(x, t2) {
	return {
		...x,
		...t2
	};
}
var TypeBuilder = class {
	/**
	* The TypeScript phantom type. This is not stored at runtime,
	* but is visible to the compiler
	*/
	type;
	/**
	* The SpacetimeDB algebraic type (run‑time value). In addition to storing
	* the runtime representation of the `AlgebraicType`, it also captures
	* the TypeScript type information of the `AlgebraicType`. That is to say
	* the value is not merely an `AlgebraicType`, but is constructed to be
	* the corresponding concrete `AlgebraicType` for the TypeScript type `Type`.
	*
	* e.g. `string` corresponds to `AlgebraicType.String`
	*/
	algebraicType;
	constructor(algebraicType) {
		this.algebraicType = algebraicType;
	}
	optional() {
		return new OptionBuilder(this);
	}
	serialize(writer, value) {
		AlgebraicType.serializeValue(writer, this.algebraicType, value);
	}
	deserialize(reader) {
		return AlgebraicType.deserializeValue(reader, this.algebraicType);
	}
};
var U8Builder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.U8);
	}
	index(algorithm = "btree") {
		return new U8ColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new U8ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new U8ColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new U8ColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new U8ColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new U8ColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var U16Builder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.U16);
	}
	index(algorithm = "btree") {
		return new U16ColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new U16ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new U16ColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new U16ColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new U16ColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new U16ColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var U32Builder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.U32);
	}
	index(algorithm = "btree") {
		return new U32ColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new U32ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new U32ColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new U32ColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new U32ColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new U32ColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var U64Builder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.U64);
	}
	index(algorithm = "btree") {
		return new U64ColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new U64ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new U64ColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new U64ColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new U64ColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new U64ColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var U128Builder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.U128);
	}
	index(algorithm = "btree") {
		return new U128ColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new U128ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new U128ColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new U128ColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new U128ColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new U128ColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var U256Builder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.U256);
	}
	index(algorithm = "btree") {
		return new U256ColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new U256ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new U256ColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new U256ColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new U256ColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new U256ColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var I8Builder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.I8);
	}
	index(algorithm = "btree") {
		return new I8ColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new I8ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new I8ColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new I8ColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new I8ColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new I8ColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var I16Builder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.I16);
	}
	index(algorithm = "btree") {
		return new I16ColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new I16ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new I16ColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new I16ColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new I16ColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new I16ColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var I32Builder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.I32);
	}
	index(algorithm = "btree") {
		return new I32ColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new I32ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new I32ColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new I32ColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new I32ColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new I32ColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var I64Builder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.I64);
	}
	index(algorithm = "btree") {
		return new I64ColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new I64ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new I64ColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new I64ColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new I64ColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new I64ColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var I128Builder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.I128);
	}
	index(algorithm = "btree") {
		return new I128ColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new I128ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new I128ColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new I128ColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new I128ColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new I128ColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var I256Builder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.I256);
	}
	index(algorithm = "btree") {
		return new I256ColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new I256ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new I256ColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new I256ColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new I256ColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new I256ColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var F32Builder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.F32);
	}
	default(value) {
		return new F32ColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new F32ColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var F64Builder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.F64);
	}
	default(value) {
		return new F64ColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new F64ColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var BoolBuilder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.Bool);
	}
	index(algorithm = "btree") {
		return new BoolColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new BoolColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new BoolColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	default(value) {
		return new BoolColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new BoolColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var StringBuilder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.String);
	}
	index(algorithm = "btree") {
		return new StringColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new StringColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new StringColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	default(value) {
		return new StringColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new StringColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var ArrayBuilder = class extends TypeBuilder {
	element;
	constructor(element) {
		super(AlgebraicType.Array(element.algebraicType));
		this.element = element;
	}
	default(value) {
		return new ArrayColumnBuilder(this.element, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new ArrayColumnBuilder(this.element, set(defaultMetadata, { name }));
	}
};
var ByteArrayBuilder = class extends TypeBuilder {
	constructor() {
		super(AlgebraicType.Array(AlgebraicType.U8));
	}
	default(value) {
		return new ByteArrayColumnBuilder(set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new ByteArrayColumnBuilder(set(defaultMetadata, { name }));
	}
};
var OptionBuilder = class extends TypeBuilder {
	value;
	constructor(value) {
		super(Option.getAlgebraicType(value.algebraicType));
		this.value = value;
	}
	default(value) {
		return new OptionColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new OptionColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var ProductBuilder = class extends TypeBuilder {
	typeName;
	elements;
	constructor(elements, name) {
		function elementsArrayFromElementsObj(obj) {
			return Object.keys(obj).map((key) => ({
				name: key,
				get algebraicType() {
					return obj[key].algebraicType;
				}
			}));
		}
		super(AlgebraicType.Product({ elements: elementsArrayFromElementsObj(elements) }));
		this.typeName = name;
		this.elements = elements;
	}
	default(value) {
		return new ProductColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new ProductColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var ResultBuilder = class extends TypeBuilder {
	ok;
	err;
	constructor(ok, err) {
		super(Result.getAlgebraicType(ok.algebraicType, err.algebraicType));
		this.ok = ok;
		this.err = err;
	}
	default(value) {
		return new ResultColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
};
var UnitBuilder = class extends TypeBuilder {
	constructor() {
		super({
			tag: "Product",
			value: { elements: [] }
		});
	}
};
var RowBuilder = class extends TypeBuilder {
	row;
	typeName;
	constructor(row, name) {
		const mappedRow = Object.fromEntries(Object.entries(row).map(([colName, builder]) => [colName, builder instanceof ColumnBuilder ? builder : new ColumnBuilder(builder, {})]));
		const elements = Object.keys(mappedRow).map((name2) => ({
			name: name2,
			get algebraicType() {
				return mappedRow[name2].typeBuilder.algebraicType;
			}
		}));
		super(AlgebraicType.Product({ elements }));
		this.row = mappedRow;
		this.typeName = name;
	}
};
var SumBuilderImpl = class extends TypeBuilder {
	variants;
	typeName;
	constructor(variants, name) {
		function variantsArrayFromVariantsObj(variants2) {
			return Object.keys(variants2).map((key) => ({
				name: key,
				get algebraicType() {
					return variants2[key].algebraicType;
				}
			}));
		}
		super(AlgebraicType.Sum({ variants: variantsArrayFromVariantsObj(variants) }));
		this.variants = variants;
		this.typeName = name;
		for (const key of Object.keys(variants)) {
			const desc = Object.getOwnPropertyDescriptor(variants, key);
			const isAccessor = !!desc && (typeof desc.get === "function" || typeof desc.set === "function");
			let isUnit2 = false;
			if (!isAccessor) isUnit2 = variants[key] instanceof UnitBuilder;
			if (isUnit2) {
				const constant = this.create(key);
				Object.defineProperty(this, key, {
					value: constant,
					writable: false,
					enumerable: true,
					configurable: false
				});
			} else {
				const fn = ((value) => this.create(key, value));
				Object.defineProperty(this, key, {
					value: fn,
					writable: false,
					enumerable: true,
					configurable: false
				});
			}
		}
	}
	create(tag, value) {
		return value === void 0 ? { tag } : {
			tag,
			value
		};
	}
	default(value) {
		return new SumColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new SumColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var SumBuilder = SumBuilderImpl;
var SimpleSumBuilderImpl = class extends SumBuilderImpl {
	index(algorithm = "btree") {
		return new SimpleSumColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	primaryKey() {
		return new SimpleSumColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
};
var ScheduleAtBuilder = class extends TypeBuilder {
	constructor() {
		super(schedule_at_default.getAlgebraicType());
	}
	default(value) {
		return new ScheduleAtColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new ScheduleAtColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var IdentityBuilder = class extends TypeBuilder {
	constructor() {
		super(Identity.getAlgebraicType());
	}
	index(algorithm = "btree") {
		return new IdentityColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new IdentityColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new IdentityColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new IdentityColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new IdentityColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new IdentityColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var ConnectionIdBuilder = class extends TypeBuilder {
	constructor() {
		super(ConnectionId.getAlgebraicType());
	}
	index(algorithm = "btree") {
		return new ConnectionIdColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new ConnectionIdColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new ConnectionIdColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new ConnectionIdColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new ConnectionIdColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new ConnectionIdColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var TimestampBuilder = class extends TypeBuilder {
	constructor() {
		super(Timestamp.getAlgebraicType());
	}
	index(algorithm = "btree") {
		return new TimestampColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new TimestampColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new TimestampColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new TimestampColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new TimestampColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new TimestampColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var TimeDurationBuilder = class extends TypeBuilder {
	constructor() {
		super(TimeDuration.getAlgebraicType());
	}
	index(algorithm = "btree") {
		return new TimeDurationColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new TimeDurationColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new TimeDurationColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new TimeDurationColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new TimeDurationColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
	name(name) {
		return new TimeDurationColumnBuilder(this, set(defaultMetadata, { name }));
	}
};
var UuidBuilder = class extends TypeBuilder {
	constructor() {
		super(Uuid.getAlgebraicType());
	}
	index(algorithm = "btree") {
		return new UuidColumnBuilder(this, set(defaultMetadata, { indexType: algorithm }));
	}
	unique() {
		return new UuidColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new UuidColumnBuilder(this, set(defaultMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new UuidColumnBuilder(this, set(defaultMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new UuidColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
	}
};
var defaultMetadata = {};
var ColumnBuilder = class {
	typeBuilder;
	columnMetadata;
	constructor(typeBuilder, metadata) {
		this.typeBuilder = typeBuilder;
		this.columnMetadata = metadata;
	}
	serialize(writer, value) {
		AlgebraicType.serializeValue(writer, this.typeBuilder.algebraicType, value);
	}
	deserialize(reader) {
		return AlgebraicType.deserializeValue(reader, this.typeBuilder.algebraicType);
	}
};
var U8ColumnBuilder = class _U8ColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _U8ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _U8ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _U8ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new _U8ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new _U8ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _U8ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var U16ColumnBuilder = class _U16ColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _U16ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _U16ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _U16ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new _U16ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new _U16ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _U16ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var U32ColumnBuilder = class _U32ColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _U32ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _U32ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _U32ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new _U32ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new _U32ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _U32ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var U64ColumnBuilder = class _U64ColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _U64ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _U64ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _U64ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new _U64ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new _U64ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _U64ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var U128ColumnBuilder = class _U128ColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _U128ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _U128ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _U128ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new _U128ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new _U128ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _U128ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var U256ColumnBuilder = class _U256ColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _U256ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _U256ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _U256ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new _U256ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new _U256ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _U256ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var I8ColumnBuilder = class _I8ColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _I8ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _I8ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _I8ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new _I8ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new _I8ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _I8ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var I16ColumnBuilder = class _I16ColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _I16ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _I16ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _I16ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new _I16ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new _I16ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _I16ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var I32ColumnBuilder = class _I32ColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _I32ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _I32ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _I32ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new _I32ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new _I32ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _I32ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var I64ColumnBuilder = class _I64ColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _I64ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _I64ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _I64ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new _I64ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new _I64ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _I64ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var I128ColumnBuilder = class _I128ColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _I128ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _I128ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _I128ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new _I128ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new _I128ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _I128ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var I256ColumnBuilder = class _I256ColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _I256ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _I256ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _I256ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	autoInc() {
		return new _I256ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isAutoIncrement: true }));
	}
	default(value) {
		return new _I256ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _I256ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var F32ColumnBuilder = class _F32ColumnBuilder extends ColumnBuilder {
	default(value) {
		return new _F32ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _F32ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var F64ColumnBuilder = class _F64ColumnBuilder extends ColumnBuilder {
	default(value) {
		return new _F64ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _F64ColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var BoolColumnBuilder = class _BoolColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _BoolColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _BoolColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _BoolColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	default(value) {
		return new _BoolColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _BoolColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var StringColumnBuilder = class _StringColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _StringColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _StringColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _StringColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	default(value) {
		return new _StringColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _StringColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var ArrayColumnBuilder = class _ArrayColumnBuilder extends ColumnBuilder {
	default(value) {
		return new _ArrayColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _ArrayColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var ByteArrayColumnBuilder = class _ByteArrayColumnBuilder extends ColumnBuilder {
	constructor(metadata) {
		super(new TypeBuilder(AlgebraicType.Array(AlgebraicType.U8)), metadata);
	}
	default(value) {
		return new _ByteArrayColumnBuilder(set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _ByteArrayColumnBuilder(set(this.columnMetadata, { name }));
	}
};
var OptionColumnBuilder = class _OptionColumnBuilder extends ColumnBuilder {
	default(value) {
		return new _OptionColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _OptionColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var ResultColumnBuilder = class _ResultColumnBuilder extends ColumnBuilder {
	constructor(typeBuilder, metadata) {
		super(typeBuilder, metadata);
	}
	default(value) {
		return new _ResultColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
};
var ProductColumnBuilder = class _ProductColumnBuilder extends ColumnBuilder {
	default(value) {
		return new _ProductColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _ProductColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var SumColumnBuilder = class _SumColumnBuilder extends ColumnBuilder {
	default(value) {
		return new _SumColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _SumColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var SimpleSumColumnBuilder = class _SimpleSumColumnBuilder extends SumColumnBuilder {
	index(algorithm = "btree") {
		return new _SimpleSumColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	primaryKey() {
		return new _SimpleSumColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
};
var ScheduleAtColumnBuilder = class _ScheduleAtColumnBuilder extends ColumnBuilder {
	default(value) {
		return new _ScheduleAtColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _ScheduleAtColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var IdentityColumnBuilder = class _IdentityColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _IdentityColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _IdentityColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _IdentityColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	default(value) {
		return new _IdentityColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _IdentityColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var ConnectionIdColumnBuilder = class _ConnectionIdColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _ConnectionIdColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _ConnectionIdColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _ConnectionIdColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	default(value) {
		return new _ConnectionIdColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _ConnectionIdColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var TimestampColumnBuilder = class _TimestampColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _TimestampColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _TimestampColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _TimestampColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	default(value) {
		return new _TimestampColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _TimestampColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var TimeDurationColumnBuilder = class _TimeDurationColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _TimeDurationColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _TimeDurationColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _TimeDurationColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	default(value) {
		return new _TimeDurationColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
	name(name) {
		return new _TimeDurationColumnBuilder(this.typeBuilder, set(this.columnMetadata, { name }));
	}
};
var UuidColumnBuilder = class _UuidColumnBuilder extends ColumnBuilder {
	index(algorithm = "btree") {
		return new _UuidColumnBuilder(this.typeBuilder, set(this.columnMetadata, { indexType: algorithm }));
	}
	unique() {
		return new _UuidColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isUnique: true }));
	}
	primaryKey() {
		return new _UuidColumnBuilder(this.typeBuilder, set(this.columnMetadata, { isPrimaryKey: true }));
	}
	default(value) {
		return new _UuidColumnBuilder(this.typeBuilder, set(this.columnMetadata, { defaultValue: value }));
	}
};
var RefBuilder = class extends TypeBuilder {
	ref;
	/** The phantom type of the pointee of this ref. */
	__spacetimeType;
	constructor(ref) {
		super(AlgebraicType.Ref(ref));
		this.ref = ref;
	}
};
var enumImpl = ((nameOrObj, maybeObj) => {
	let obj = nameOrObj;
	let name = void 0;
	if (typeof nameOrObj === "string") {
		if (!maybeObj) throw new TypeError("When providing a name, you must also provide the variants object or array.");
		obj = maybeObj;
		name = nameOrObj;
	}
	if (Array.isArray(obj)) {
		const simpleVariantsObj = {};
		for (const variant of obj) simpleVariantsObj[variant] = new UnitBuilder();
		return new SimpleSumBuilderImpl(simpleVariantsObj, name);
	}
	return new SumBuilder(obj, name);
});
var t = {
	bool: () => new BoolBuilder(),
	string: () => new StringBuilder(),
	number: () => new F64Builder(),
	i8: () => new I8Builder(),
	u8: () => new U8Builder(),
	i16: () => new I16Builder(),
	u16: () => new U16Builder(),
	i32: () => new I32Builder(),
	u32: () => new U32Builder(),
	i64: () => new I64Builder(),
	u64: () => new U64Builder(),
	i128: () => new I128Builder(),
	u128: () => new U128Builder(),
	i256: () => new I256Builder(),
	u256: () => new U256Builder(),
	f32: () => new F32Builder(),
	f64: () => new F64Builder(),
	object: ((nameOrObj, maybeObj) => {
		if (typeof nameOrObj === "string") {
			if (!maybeObj) throw new TypeError("When providing a name, you must also provide the object.");
			return new ProductBuilder(maybeObj, nameOrObj);
		}
		return new ProductBuilder(nameOrObj, void 0);
	}),
	row: ((nameOrObj, maybeObj) => {
		const [obj, name] = typeof nameOrObj === "string" ? [maybeObj, nameOrObj] : [nameOrObj, void 0];
		return new RowBuilder(obj, name);
	}),
	array(e) {
		return new ArrayBuilder(e);
	},
	enum: enumImpl,
	unit() {
		return new UnitBuilder();
	},
	lazy(thunk) {
		let cached = null;
		const get = () => cached ??= thunk();
		return new Proxy({}, {
			get(_t, prop, recv) {
				const target = get();
				const val = Reflect.get(target, prop, recv);
				return typeof val === "function" ? val.bind(target) : val;
			},
			set(_t, prop, value, recv) {
				return Reflect.set(get(), prop, value, recv);
			},
			has(_t, prop) {
				return prop in get();
			},
			ownKeys() {
				return Reflect.ownKeys(get());
			},
			getOwnPropertyDescriptor(_t, prop) {
				return Object.getOwnPropertyDescriptor(get(), prop);
			},
			getPrototypeOf() {
				return Object.getPrototypeOf(get());
			}
		});
	},
	scheduleAt: () => {
		return new ScheduleAtBuilder();
	},
	option(value) {
		return new OptionBuilder(value);
	},
	result(ok, err) {
		return new ResultBuilder(ok, err);
	},
	identity: () => {
		return new IdentityBuilder();
	},
	connectionId: () => {
		return new ConnectionIdBuilder();
	},
	timestamp: () => {
		return new TimestampBuilder();
	},
	timeDuration: () => {
		return new TimeDurationBuilder();
	},
	uuid: () => {
		return new UuidBuilder();
	},
	byteArray: () => {
		return new ByteArrayBuilder();
	}
};
var lifecycle_type_default = t.enum("Lifecycle", {
	Init: t.unit(),
	OnConnect: t.unit(),
	OnDisconnect: t.unit()
});
function pushReducer(name, params, fn, lifecycle) {
	if (existingReducers.has(name)) throw new TypeError(`There is already a reducer with the name '${name}'`);
	existingReducers.add(name);
	if (!(params instanceof RowBuilder)) params = new RowBuilder(params);
	if (params.typeName === void 0) params.typeName = toPascalCase(name);
	const ref = registerTypesRecursively(params);
	const paramsType = resolveType(MODULE_DEF.typespace, ref).value;
	MODULE_DEF.reducers.push({
		name,
		params: paramsType,
		lifecycle
	});
	if (!fn.name) Object.defineProperty(fn, "name", {
		value: name,
		writable: false
	});
	REDUCERS.push(fn);
}
var existingReducers = /* @__PURE__ */ new Set();
var REDUCERS = [];
function reducer(name, params, fn) {
	pushReducer(name, params, fn);
}
function init(name, params, fn) {
	pushReducer(name, params, fn, lifecycle_type_default.Init);
}
function clientConnected(name, params, fn) {
	pushReducer(name, params, fn, lifecycle_type_default.OnConnect);
}
function clientDisconnected(name, params, fn) {
	pushReducer(name, params, fn, lifecycle_type_default.OnDisconnect);
}
var QueryBrand = Symbol("QueryBrand");
var isRowTypedQuery = (val) => !!val && typeof val === "object" && QueryBrand in val;
function toSql(q) {
	return q.toSql();
}
var SemijoinImpl = class _SemijoinImpl {
	constructor(sourceQuery, filterQuery, joinCondition) {
		this.sourceQuery = sourceQuery;
		this.filterQuery = filterQuery;
		this.joinCondition = joinCondition;
		if (sourceQuery.table.name === filterQuery.table.name) throw new Error("Cannot semijoin a table to itself");
	}
	[QueryBrand] = true;
	type = "semijoin";
	build() {
		return this;
	}
	where(predicate) {
		return new _SemijoinImpl(this.sourceQuery.where(predicate), this.filterQuery, this.joinCondition);
	}
	toSql() {
		const left = this.filterQuery;
		const right = this.sourceQuery;
		const leftTable = quoteIdentifier(left.table.name);
		const rightTable = quoteIdentifier(right.table.name);
		let sql = `SELECT ${rightTable}.* FROM ${leftTable} JOIN ${rightTable} ON ${booleanExprToSql(this.joinCondition)}`;
		const clauses = [];
		if (left.whereClause) clauses.push(booleanExprToSql(left.whereClause));
		if (right.whereClause) clauses.push(booleanExprToSql(right.whereClause));
		if (clauses.length > 0) {
			const whereSql = clauses.length === 1 ? clauses[0] : clauses.map(wrapInParens).join(" AND ");
			sql += ` WHERE ${whereSql}`;
		}
		return sql;
	}
};
var FromBuilder = class _FromBuilder {
	constructor(table2, whereClause) {
		this.table = table2;
		this.whereClause = whereClause;
	}
	[QueryBrand] = true;
	where(predicate) {
		const newCondition = predicate(this.table.cols);
		const nextWhere = this.whereClause ? and$1(this.whereClause, newCondition) : newCondition;
		return new _FromBuilder(this.table, nextWhere);
	}
	rightSemijoin(right, on) {
		const sourceQuery = new _FromBuilder(right);
		const joinCondition = on(this.table.indexedCols, right.indexedCols);
		return new SemijoinImpl(sourceQuery, this, joinCondition);
	}
	leftSemijoin(right, on) {
		const filterQuery = new _FromBuilder(right);
		const joinCondition = on(this.table.indexedCols, right.indexedCols);
		return new SemijoinImpl(this, filterQuery, joinCondition);
	}
	toSql() {
		return renderSelectSqlWithJoins(this.table, this.whereClause);
	}
	build() {
		return this;
	}
};
var TableRefImpl = class {
	type = "table";
	name;
	cols;
	indexedCols;
	tableDef;
	constructor(tableDef) {
		this.name = tableDef.name;
		this.cols = createRowExpr(tableDef);
		this.indexedCols = this.cols;
		this.tableDef = tableDef;
		Object.freeze(this);
	}
	asFrom() {
		return new FromBuilder(this);
	}
	rightSemijoin(other, on) {
		return this.asFrom().rightSemijoin(other, on);
	}
	leftSemijoin(other, on) {
		return this.asFrom().leftSemijoin(other, on);
	}
	build() {
		return this.asFrom().build();
	}
	toSql() {
		return this.asFrom().toSql();
	}
	where(predicate) {
		return this.asFrom().where(predicate);
	}
};
function createTableRefFromDef(tableDef) {
	return new TableRefImpl(tableDef);
}
function makeQueryBuilder(schema2) {
	const qb = /* @__PURE__ */ Object.create(null);
	for (const table2 of schema2.tables) {
		const ref = createTableRefFromDef(table2);
		qb[table2.name] = ref;
	}
	return Object.freeze(qb);
}
function createRowExpr(tableDef) {
	const row = {};
	for (const columnName of Object.keys(tableDef.columns)) {
		const columnBuilder = tableDef.columns[columnName];
		const column = new ColumnExpression(tableDef.name, columnName, columnBuilder.typeBuilder.algebraicType);
		row[columnName] = Object.freeze(column);
	}
	return Object.freeze(row);
}
function renderSelectSqlWithJoins(table2, where, extraClauses = []) {
	const sql = `SELECT * FROM ${quoteIdentifier(table2.name)}`;
	const clauses = [];
	if (where) clauses.push(booleanExprToSql(where));
	clauses.push(...extraClauses);
	if (clauses.length === 0) return sql;
	return `${sql} WHERE ${clauses.length === 1 ? clauses[0] : clauses.map(wrapInParens).join(" AND ")}`;
}
var ColumnExpression = class {
	type = "column";
	column;
	table;
	tsValueType;
	spacetimeType;
	constructor(table2, column, spacetimeType) {
		this.table = table2;
		this.column = column;
		this.spacetimeType = spacetimeType;
	}
	eq(x) {
		return {
			type: "eq",
			left: this,
			right: normalizeValue(x)
		};
	}
	lt(x) {
		return {
			type: "lt",
			left: this,
			right: normalizeValue(x)
		};
	}
	lte(x) {
		return {
			type: "lte",
			left: this,
			right: normalizeValue(x)
		};
	}
	gt(x) {
		return {
			type: "gt",
			left: this,
			right: normalizeValue(x)
		};
	}
	gte(x) {
		return {
			type: "gte",
			left: this,
			right: normalizeValue(x)
		};
	}
};
function literal(value) {
	return {
		type: "literal",
		value
	};
}
function normalizeValue(val) {
	if (val.type === "literal") return val;
	if (typeof val === "object" && val != null && "type" in val && val.type === "column") return val;
	return literal(val);
}
function and$1(...clauses) {
	return {
		type: "and",
		clauses
	};
}
function booleanExprToSql(expr, tableAlias) {
	switch (expr.type) {
		case "eq": return `${valueExprToSql(expr.left)} = ${valueExprToSql(expr.right)}`;
		case "ne": return `${valueExprToSql(expr.left)} <> ${valueExprToSql(expr.right)}`;
		case "gt": return `${valueExprToSql(expr.left)} > ${valueExprToSql(expr.right)}`;
		case "gte": return `${valueExprToSql(expr.left)} >= ${valueExprToSql(expr.right)}`;
		case "lt": return `${valueExprToSql(expr.left)} < ${valueExprToSql(expr.right)}`;
		case "lte": return `${valueExprToSql(expr.left)} <= ${valueExprToSql(expr.right)}`;
		case "and": return expr.clauses.map((c) => booleanExprToSql(c)).map(wrapInParens).join(" AND ");
		case "or": return expr.clauses.map((c) => booleanExprToSql(c)).map(wrapInParens).join(" OR ");
		case "not": return `NOT ${wrapInParens(booleanExprToSql(expr.clause))}`;
	}
}
function wrapInParens(sql) {
	return `(${sql})`;
}
function valueExprToSql(expr, tableAlias) {
	if (isLiteralExpr(expr)) return literalValueToSql(expr.value);
	const table2 = expr.table;
	return `${quoteIdentifier(table2)}.${quoteIdentifier(expr.column)}`;
}
function literalValueToSql(value) {
	if (value === null || value === void 0) return "NULL";
	if (value instanceof Identity || value instanceof ConnectionId) return `0x${value.toHexString()}`;
	switch (typeof value) {
		case "number":
		case "bigint": return String(value);
		case "boolean": return value ? "TRUE" : "FALSE";
		case "string": return `'${value.replace(/'/g, "''")}'`;
		default: return `'${JSON.stringify(value).replace(/'/g, "''")}'`;
	}
}
function quoteIdentifier(name) {
	return `"${name.replace(/"/g, "\"\"")}"`;
}
function isLiteralExpr(expr) {
	return expr.type === "literal";
}
function defineView(opts, anon, params, ret, fn) {
	const paramsBuilder = new RowBuilder(params, toPascalCase(opts.name));
	let returnType = registerTypesRecursively(ret).algebraicType;
	const { value: paramType } = resolveType(MODULE_DEF.typespace, registerTypesRecursively(paramsBuilder));
	MODULE_DEF.miscExports.push({
		tag: "View",
		value: {
			name: opts.name,
			index: (anon ? ANON_VIEWS : VIEWS).length,
			isPublic: opts.public,
			isAnonymous: anon,
			params: paramType,
			returnType
		}
	});
	if (returnType.tag == "Sum") {
		const originalFn = fn;
		fn = ((ctx, args) => {
			const ret2 = originalFn(ctx, args);
			return ret2 == null ? [] : [ret2];
		});
		returnType = AlgebraicType.Array(returnType.value.variants[0].algebraicType);
	}
	(anon ? ANON_VIEWS : VIEWS).push({
		fn,
		params: paramType,
		returnType,
		returnTypeBaseSize: bsatnBaseSize(MODULE_DEF.typespace, returnType)
	});
}
var VIEWS = [];
var ANON_VIEWS = [];
function procedure(name, params, ret, fn) {
	const paramsType = { elements: Object.entries(params).map(([n, c]) => ({
		name: n,
		algebraicType: registerTypesRecursively("typeBuilder" in c ? c.typeBuilder : c).algebraicType
	})) };
	const returnType = registerTypesRecursively(ret).algebraicType;
	MODULE_DEF.miscExports.push({
		tag: "Procedure",
		value: {
			name,
			params: paramsType,
			returnType
		}
	});
	PROCEDURES.push({
		fn,
		paramsType,
		returnType,
		returnTypeBaseSize: bsatnBaseSize(MODULE_DEF.typespace, returnType)
	});
}
var PROCEDURES = [];
var REGISTERED_SCHEMA = null;
function getRegisteredSchema() {
	if (REGISTERED_SCHEMA == null) throw new Error("Schema has not been registered yet. Call schema() first.");
	return REGISTERED_SCHEMA;
}
function tablesToSchema(tables) {
	return { tables: tables.map(tableToSchema) };
}
function tableToSchema(schema2) {
	const getColName = (i) => schema2.rowType.algebraicType.value.elements[i].name;
	return {
		name: schema2.tableName,
		accessorName: toCamelCase(schema2.tableName),
		columns: schema2.rowType.row,
		rowType: schema2.rowSpacetimeType,
		constraints: schema2.tableDef.constraints.map((c) => ({
			name: c.name,
			constraint: "unique",
			columns: c.data.value.columns.map(getColName)
		})),
		indexes: schema2.tableDef.indexes.map((idx) => {
			const columnIds = idx.algorithm.tag === "Direct" ? [idx.algorithm.value] : idx.algorithm.value;
			return {
				name: idx.accessorName,
				unique: schema2.tableDef.constraints.some((c) => c.data.value.columns.every((col) => columnIds.includes(col))),
				algorithm: idx.algorithm.tag.toLowerCase(),
				columns: columnIds.map(getColName)
			};
		})
	};
}
var MODULE_DEF = {
	typespace: { types: [] },
	tables: [],
	reducers: [],
	types: [],
	miscExports: [],
	rowLevelSecurity: []
};
var COMPOUND_TYPES = /* @__PURE__ */ new Map();
function resolveType(typespace, typeBuilder) {
	let ty = typeBuilder.algebraicType;
	while (ty.tag === "Ref") ty = typespace.types[ty.value];
	return ty;
}
function registerTypesRecursively(typeBuilder) {
	if (typeBuilder instanceof ProductBuilder && !isUnit(typeBuilder) || typeBuilder instanceof SumBuilder || typeBuilder instanceof RowBuilder) return registerCompoundTypeRecursively(typeBuilder);
	else if (typeBuilder instanceof OptionBuilder) return new OptionBuilder(registerTypesRecursively(typeBuilder.value));
	else if (typeBuilder instanceof ResultBuilder) return new ResultBuilder(registerTypesRecursively(typeBuilder.ok), registerTypesRecursively(typeBuilder.err));
	else if (typeBuilder instanceof ArrayBuilder) return new ArrayBuilder(registerTypesRecursively(typeBuilder.element));
	else return typeBuilder;
}
function registerCompoundTypeRecursively(typeBuilder) {
	const ty = typeBuilder.algebraicType;
	const name = typeBuilder.typeName;
	if (name === void 0) throw new Error(`Missing type name for ${typeBuilder.constructor.name ?? "TypeBuilder"} ${JSON.stringify(typeBuilder)}`);
	let r = COMPOUND_TYPES.get(ty);
	if (r != null) return r;
	const newTy = typeBuilder instanceof RowBuilder || typeBuilder instanceof ProductBuilder ? {
		tag: "Product",
		value: { elements: [] }
	} : {
		tag: "Sum",
		value: { variants: [] }
	};
	r = new RefBuilder(MODULE_DEF.typespace.types.length);
	MODULE_DEF.typespace.types.push(newTy);
	COMPOUND_TYPES.set(ty, r);
	if (typeBuilder instanceof RowBuilder) for (const [name2, elem] of Object.entries(typeBuilder.row)) newTy.value.elements.push({
		name: name2,
		algebraicType: registerTypesRecursively(elem.typeBuilder).algebraicType
	});
	else if (typeBuilder instanceof ProductBuilder) for (const [name2, elem] of Object.entries(typeBuilder.elements)) newTy.value.elements.push({
		name: name2,
		algebraicType: registerTypesRecursively(elem).algebraicType
	});
	else if (typeBuilder instanceof SumBuilder) for (const [name2, variant] of Object.entries(typeBuilder.variants)) newTy.value.variants.push({
		name: name2,
		algebraicType: registerTypesRecursively(variant).algebraicType
	});
	MODULE_DEF.types.push({
		name: splitName(name),
		ty: r.ref,
		customOrdering: true
	});
	return r;
}
function isUnit(typeBuilder) {
	return typeBuilder.typeName == null && typeBuilder.algebraicType.value.elements.length === 0;
}
function splitName(name) {
	const scope = name.split(".");
	return {
		name: scope.pop(),
		scope
	};
}
var Schema = class {
	tablesDef;
	typespace;
	schemaType;
	constructor(tables, typespace, handles) {
		this.tablesDef = { tables };
		this.typespace = typespace;
		this.schemaType = tablesToSchema(handles);
	}
	reducer(name, paramsOrFn, fn) {
		if (typeof paramsOrFn === "function") {
			reducer(name, {}, paramsOrFn);
			return paramsOrFn;
		} else {
			reducer(name, paramsOrFn, fn);
			return fn;
		}
	}
	init(nameOrFn, maybeFn) {
		const [name, fn] = typeof nameOrFn === "string" ? [nameOrFn, maybeFn] : ["init", nameOrFn];
		init(name, {}, fn);
	}
	clientConnected(nameOrFn, maybeFn) {
		const [name, fn] = typeof nameOrFn === "string" ? [nameOrFn, maybeFn] : ["on_connect", nameOrFn];
		clientConnected(name, {}, fn);
	}
	clientDisconnected(nameOrFn, maybeFn) {
		const [name, fn] = typeof nameOrFn === "string" ? [nameOrFn, maybeFn] : ["on_disconnect", nameOrFn];
		clientDisconnected(name, {}, fn);
	}
	view(opts, ret, fn) {
		defineView(opts, false, {}, ret, fn);
	}
	anonymousView(opts, ret, fn) {
		defineView(opts, true, {}, ret, fn);
	}
	procedure(name, paramsOrRet, retOrFn, maybeFn) {
		if (typeof retOrFn === "function") {
			procedure(name, {}, paramsOrRet, retOrFn);
			return retOrFn;
		} else {
			procedure(name, paramsOrRet, retOrFn, maybeFn);
			return maybeFn;
		}
	}
	clientVisibilityFilter = { sql(filter) {
		MODULE_DEF.rowLevelSecurity.push({ sql: filter });
	} };
};
function schema(...args) {
	const handles = args.length === 1 && Array.isArray(args[0]) ? args[0] : args;
	const tableDefs = handles.map((h) => h.tableDef);
	MODULE_DEF.tables.push(...tableDefs);
	REGISTERED_SCHEMA = { tables: handles.map((handle) => ({
		name: handle.tableName,
		accessorName: handle.tableName,
		columns: handle.rowType.row,
		rowType: handle.rowSpacetimeType,
		indexes: handle.idxs,
		constraints: handle.constraints
	})) };
	return new Schema(tableDefs, MODULE_DEF.typespace, handles);
}
var raw_index_algorithm_type_default = t.enum("RawIndexAlgorithm", {
	BTree: t.array(t.u16()),
	Hash: t.array(t.u16()),
	Direct: t.u16()
});
function table(opts, row) {
	const { name, public: isPublic = false, indexes: userIndexes = [], scheduled } = opts;
	const colIds = /* @__PURE__ */ new Map();
	const colNameList = [];
	if (!(row instanceof RowBuilder)) row = new RowBuilder(row);
	if (row.typeName === void 0) row.typeName = toPascalCase(name);
	const rowTypeRef = registerTypesRecursively(row);
	row.algebraicType.value.elements.forEach((elem, i) => {
		colIds.set(elem.name, i);
		colNameList.push(elem.name);
	});
	const pk = [];
	const indexes = [];
	const constraints = [];
	const sequences = [];
	let scheduleAtCol;
	for (const [name2, builder] of Object.entries(row.row)) {
		const meta = builder.columnMetadata;
		if (meta.isPrimaryKey) pk.push(colIds.get(name2));
		const isUnique = meta.isUnique || meta.isPrimaryKey;
		if (meta.indexType || isUnique) {
			const algo = meta.indexType ?? "btree";
			const id = colIds.get(name2);
			let algorithm;
			switch (algo) {
				case "btree":
					algorithm = raw_index_algorithm_type_default.BTree([id]);
					break;
				case "direct":
					algorithm = raw_index_algorithm_type_default.Direct(id);
					break;
			}
			indexes.push({
				name: void 0,
				accessorName: name2,
				algorithm
			});
		}
		if (isUnique) constraints.push({
			name: void 0,
			data: {
				tag: "Unique",
				value: { columns: [colIds.get(name2)] }
			}
		});
		if (meta.isAutoIncrement) sequences.push({
			name: void 0,
			start: void 0,
			minValue: void 0,
			maxValue: void 0,
			column: colIds.get(name2),
			increment: 1n
		});
		if (scheduled) {
			const algebraicType = builder.typeBuilder.algebraicType;
			if (schedule_at_default.isScheduleAt(algebraicType)) scheduleAtCol = colIds.get(name2);
		}
	}
	for (const indexOpts of userIndexes ?? []) {
		let algorithm;
		switch (indexOpts.algorithm) {
			case "btree":
				algorithm = {
					tag: "BTree",
					value: indexOpts.columns.map((c) => colIds.get(c))
				};
				break;
			case "direct":
				algorithm = {
					tag: "Direct",
					value: colIds.get(indexOpts.column)
				};
				break;
		}
		indexes.push({
			name: void 0,
			accessorName: indexOpts.name,
			algorithm
		});
	}
	for (const constraintOpts of opts.constraints ?? []) if (constraintOpts.constraint === "unique") {
		const data = {
			tag: "Unique",
			value: { columns: constraintOpts.columns.map((c) => colIds.get(c)) }
		};
		constraints.push({
			name: constraintOpts.name,
			data
		});
		continue;
	}
	for (const index of indexes) index.name = `${name}_${(index.algorithm.tag === "Direct" ? [index.algorithm.value] : index.algorithm.value).map((i) => colNameList[i]).join("_")}_idx_${index.algorithm.tag.toLowerCase()}`;
	const tableDef = {
		name,
		productTypeRef: rowTypeRef.ref,
		primaryKey: pk,
		indexes,
		constraints,
		sequences,
		schedule: scheduled && scheduleAtCol !== void 0 ? {
			name: void 0,
			reducerName: scheduled,
			scheduledAtColumn: scheduleAtCol
		} : void 0,
		tableType: { tag: "User" },
		tableAccess: { tag: isPublic ? "Public" : "Private" }
	};
	const productType = row.algebraicType.value;
	return {
		rowType: row,
		tableName: name,
		rowSpacetimeType: productType,
		tableDef,
		idxs: {},
		constraints
	};
}
var SpacetimeHostError = class _SpacetimeHostError extends Error {
	code;
	message;
	constructor(code, message) {
		super();
		const proto = Object.getPrototypeOf(this);
		let cls;
		if (errorProtoypes.has(proto)) {
			cls = proto.constructor;
			if (code !== cls.CODE) throw new TypeError(`invalid error code for ${cls.name}`);
		} else if (proto === _SpacetimeHostError.prototype) {
			cls = errnoToClass.get(code);
			if (!cls) throw new RangeError(`unknown error code ${code}`);
		} else throw new TypeError("cannot subclass SpacetimeError");
		Object.setPrototypeOf(this, cls.prototype);
		this.code = cls.CODE;
		this.message = message ?? cls.MESSAGE;
	}
	get name() {
		return errnoToClass.get(this.code)?.name ?? "SpacetimeHostError";
	}
};
var SenderError = class extends Error {
	constructor(message) {
		super(message);
	}
	get name() {
		return "SenderError";
	}
};
var errorData = {
	HostCallFailure: [1, "ABI called by host returned an error"],
	NotInTransaction: [2, "ABI call can only be made while in a transaction"],
	BsatnDecodeError: [3, "Couldn't decode the BSATN to the expected type"],
	NoSuchTable: [4, "No such table"],
	NoSuchIndex: [5, "No such index"],
	NoSuchIter: [6, "The provided row iterator is not valid"],
	NoSuchConsoleTimer: [7, "The provided console timer does not exist"],
	NoSuchBytes: [8, "The provided bytes source or sink is not valid"],
	NoSpace: [9, "The provided sink has no more space left"],
	BufferTooSmall: [11, "The provided buffer is not large enough to store the data"],
	UniqueAlreadyExists: [12, "Value with given unique identifier already exists"],
	ScheduleAtDelayTooLong: [13, "Specified delay in scheduling row was too long"],
	IndexNotUnique: [14, "The index was not unique"],
	NoSuchRow: [15, "The row was not found, e.g., in an update call"],
	AutoIncOverflow: [16, "The auto-increment sequence overflowed"],
	WouldBlockTransaction: [17, "Attempted async or blocking op while holding open a transaction"],
	TransactionNotAnonymous: [18, "Not in an anonymous transaction. Called by a reducer?"],
	TransactionIsReadOnly: [19, "ABI call can only be made while within a mutable transaction"],
	TransactionIsMut: [20, "ABI call can only be made while within a read-only transaction"],
	HttpError: [21, "The HTTP request failed"]
};
function mapEntries(x, f) {
	return Object.fromEntries(Object.entries(x).map(([k, v]) => [k, f(k, v)]));
}
var errors = Object.freeze(mapEntries(errorData, (name, [code, message]) => Object.defineProperty(class extends SpacetimeHostError {
	static CODE = code;
	static MESSAGE = message;
	constructor() {
		super(code);
	}
}, "name", {
	value: name,
	writable: false
})));
var errorProtoypes = new Set(Object.values(errors).map((cls) => cls.prototype));
var errnoToClass = new Map(Object.values(errors).map((cls) => [cls.CODE, cls]));
__toESM(require_text_min());
var sum_type_variant_type_default = t.object("SumTypeVariant", {
	name: t.option(t.string()),
	get algebraicType() {
		return algebraic_type_type_default;
	}
});
var sum_type_type_default = t.object("SumType", { get variants() {
	return t.array(sum_type_variant_type_default);
} });
var product_type_element_type_default = t.object("ProductTypeElement", {
	name: t.option(t.string()),
	get algebraicType() {
		return algebraic_type_type_default;
	}
});
var product_type_type_default = t.object("ProductType", { get elements() {
	return t.array(product_type_element_type_default);
} });
var AlgebraicType2 = t.enum("AlgebraicType", {
	Ref: t.u32(),
	get Sum() {
		return sum_type_type_default;
	},
	get Product() {
		return product_type_type_default;
	},
	get Array() {
		return AlgebraicType2;
	},
	String: t.unit(),
	Bool: t.unit(),
	I8: t.unit(),
	U8: t.unit(),
	I16: t.unit(),
	U16: t.unit(),
	I32: t.unit(),
	U32: t.unit(),
	I64: t.unit(),
	U64: t.unit(),
	I128: t.unit(),
	U128: t.unit(),
	I256: t.unit(),
	U256: t.unit(),
	F32: t.unit(),
	F64: t.unit()
});
var algebraic_type_type_default = AlgebraicType2;
var typespace_type_default = t.object("Typespace", { get types() {
	return t.array(algebraic_type_type_default);
} });
var raw_column_def_v_8_type_default = t.object("RawColumnDefV8", {
	colName: t.string(),
	get colType() {
		return algebraic_type_type_default;
	}
});
var index_type_type_default = t.enum("IndexType", {
	BTree: t.unit(),
	Hash: t.unit()
});
var raw_index_def_v_8_type_default = t.object("RawIndexDefV8", {
	indexName: t.string(),
	isUnique: t.bool(),
	get indexType() {
		return index_type_type_default;
	},
	columns: t.array(t.u16())
});
var raw_constraint_def_v_8_type_default = t.object("RawConstraintDefV8", {
	constraintName: t.string(),
	constraints: t.u8(),
	columns: t.array(t.u16())
});
var raw_sequence_def_v_8_type_default = t.object("RawSequenceDefV8", {
	sequenceName: t.string(),
	colPos: t.u16(),
	increment: t.i128(),
	start: t.option(t.i128()),
	minValue: t.option(t.i128()),
	maxValue: t.option(t.i128()),
	allocated: t.i128()
});
var raw_table_def_v_8_type_default = t.object("RawTableDefV8", {
	tableName: t.string(),
	get columns() {
		return t.array(raw_column_def_v_8_type_default);
	},
	get indexes() {
		return t.array(raw_index_def_v_8_type_default);
	},
	get constraints() {
		return t.array(raw_constraint_def_v_8_type_default);
	},
	get sequences() {
		return t.array(raw_sequence_def_v_8_type_default);
	},
	tableType: t.string(),
	tableAccess: t.string(),
	scheduled: t.option(t.string())
});
var table_desc_type_default = t.object("TableDesc", {
	get schema() {
		return raw_table_def_v_8_type_default;
	},
	data: t.u32()
});
var reducer_def_type_default = t.object("ReducerDef", {
	name: t.string(),
	get args() {
		return t.array(product_type_element_type_default);
	}
});
var type_alias_type_default = t.object("TypeAlias", {
	name: t.string(),
	ty: t.u32()
});
var misc_module_export_type_default = t.enum("MiscModuleExport", { get TypeAlias() {
	return type_alias_type_default;
} });
var raw_module_def_v_8_type_default = t.object("RawModuleDefV8", {
	get typespace() {
		return typespace_type_default;
	},
	get tables() {
		return t.array(table_desc_type_default);
	},
	get reducers() {
		return t.array(reducer_def_type_default);
	},
	get miscExports() {
		return t.array(misc_module_export_type_default);
	}
});
var raw_index_def_v_9_type_default = t.object("RawIndexDefV9", {
	name: t.option(t.string()),
	accessorName: t.option(t.string()),
	get algorithm() {
		return raw_index_algorithm_type_default;
	}
});
var raw_unique_constraint_data_v_9_type_default = t.object("RawUniqueConstraintDataV9", { columns: t.array(t.u16()) });
var raw_constraint_data_v_9_type_default = t.enum("RawConstraintDataV9", { get Unique() {
	return raw_unique_constraint_data_v_9_type_default;
} });
var raw_constraint_def_v_9_type_default = t.object("RawConstraintDefV9", {
	name: t.option(t.string()),
	get data() {
		return raw_constraint_data_v_9_type_default;
	}
});
var raw_sequence_def_v_9_type_default = t.object("RawSequenceDefV9", {
	name: t.option(t.string()),
	column: t.u16(),
	start: t.option(t.i128()),
	minValue: t.option(t.i128()),
	maxValue: t.option(t.i128()),
	increment: t.i128()
});
var raw_schedule_def_v_9_type_default = t.object("RawScheduleDefV9", {
	name: t.option(t.string()),
	reducerName: t.string(),
	scheduledAtColumn: t.u16()
});
var table_type_type_default = t.enum("TableType", {
	System: t.unit(),
	User: t.unit()
});
var table_access_type_default = t.enum("TableAccess", {
	Public: t.unit(),
	Private: t.unit()
});
var raw_table_def_v_9_type_default = t.object("RawTableDefV9", {
	name: t.string(),
	productTypeRef: t.u32(),
	primaryKey: t.array(t.u16()),
	get indexes() {
		return t.array(raw_index_def_v_9_type_default);
	},
	get constraints() {
		return t.array(raw_constraint_def_v_9_type_default);
	},
	get sequences() {
		return t.array(raw_sequence_def_v_9_type_default);
	},
	get schedule() {
		return t.option(raw_schedule_def_v_9_type_default);
	},
	get tableType() {
		return table_type_type_default;
	},
	get tableAccess() {
		return table_access_type_default;
	}
});
var raw_reducer_def_v_9_type_default = t.object("RawReducerDefV9", {
	name: t.string(),
	get params() {
		return product_type_type_default;
	},
	get lifecycle() {
		return t.option(lifecycle_type_default);
	}
});
var raw_scoped_type_name_v_9_type_default = t.object("RawScopedTypeNameV9", {
	scope: t.array(t.string()),
	name: t.string()
});
var raw_type_def_v_9_type_default = t.object("RawTypeDefV9", {
	get name() {
		return raw_scoped_type_name_v_9_type_default;
	},
	ty: t.u32(),
	customOrdering: t.bool()
});
var raw_column_default_value_v_9_type_default = t.object("RawColumnDefaultValueV9", {
	table: t.string(),
	colId: t.u16(),
	value: t.byteArray()
});
var raw_procedure_def_v_9_type_default = t.object("RawProcedureDefV9", {
	name: t.string(),
	get params() {
		return product_type_type_default;
	},
	get returnType() {
		return algebraic_type_type_default;
	}
});
var raw_view_def_v_9_type_default = t.object("RawViewDefV9", {
	name: t.string(),
	index: t.u32(),
	isPublic: t.bool(),
	isAnonymous: t.bool(),
	get params() {
		return product_type_type_default;
	},
	get returnType() {
		return algebraic_type_type_default;
	}
});
var raw_misc_module_export_v_9_type_default = t.enum("RawMiscModuleExportV9", {
	get ColumnDefaultValue() {
		return raw_column_default_value_v_9_type_default;
	},
	get Procedure() {
		return raw_procedure_def_v_9_type_default;
	},
	get View() {
		return raw_view_def_v_9_type_default;
	}
});
var raw_row_level_security_def_v_9_type_default = t.object("RawRowLevelSecurityDefV9", { sql: t.string() });
var raw_module_def_v_9_type_default = t.object("RawModuleDefV9", {
	get typespace() {
		return typespace_type_default;
	},
	get tables() {
		return t.array(raw_table_def_v_9_type_default);
	},
	get reducers() {
		return t.array(raw_reducer_def_v_9_type_default);
	},
	get types() {
		return t.array(raw_type_def_v_9_type_default);
	},
	get miscExports() {
		return t.array(raw_misc_module_export_v_9_type_default);
	},
	get rowLevelSecurity() {
		return t.array(raw_row_level_security_def_v_9_type_default);
	}
});
var raw_module_def_type_default = t.enum("RawModuleDef", {
	get V8BackCompat() {
		return raw_module_def_v_8_type_default;
	},
	get V9() {
		return raw_module_def_v_9_type_default;
	}
});
var Range = class {
	#from;
	#to;
	constructor(from, to) {
		this.#from = from ?? { tag: "unbounded" };
		this.#to = to ?? { tag: "unbounded" };
	}
	get from() {
		return this.#from;
	}
	get to() {
		return this.#to;
	}
};
var import_statuses = __toESM(require_statuses());
var http_header_pair_type_default = t.object("HttpHeaderPair", {
	name: t.string(),
	value: t.byteArray()
});
var http_headers_type_default = t.object("HttpHeaders", { get entries() {
	return t.array(http_header_pair_type_default);
} });
var http_method_type_default = t.enum("HttpMethod", {
	Get: t.unit(),
	Head: t.unit(),
	Post: t.unit(),
	Put: t.unit(),
	Delete: t.unit(),
	Connect: t.unit(),
	Options: t.unit(),
	Trace: t.unit(),
	Patch: t.unit(),
	Extension: t.string()
});
var http_version_type_default = t.enum("HttpVersion", {
	Http09: t.unit(),
	Http10: t.unit(),
	Http11: t.unit(),
	Http2: t.unit(),
	Http3: t.unit()
});
var http_request_type_default = t.object("HttpRequest", {
	get method() {
		return http_method_type_default;
	},
	get headers() {
		return http_headers_type_default;
	},
	timeout: t.option(t.timeDuration()),
	uri: t.string(),
	get version() {
		return http_version_type_default;
	}
});
var http_response_type_default = t.object("HttpResponse", {
	get headers() {
		return http_headers_type_default;
	},
	get version() {
		return http_version_type_default;
	},
	code: t.u16()
});
var { freeze } = Object;
var textEncoder = new TextEncoder();
var textDecoder = new TextDecoder("utf-8");
var makeResponse = Symbol("makeResponse");
var SyncResponse = class _SyncResponse {
	#body;
	#inner;
	constructor(body, init2) {
		if (body == null) this.#body = null;
		else if (typeof body === "string") this.#body = body;
		else this.#body = new Uint8Array(body).buffer;
		this.#inner = {
			headers: new Headers(init2?.headers),
			status: init2?.status ?? 200,
			statusText: init2?.statusText ?? "",
			type: "default",
			url: null,
			aborted: false
		};
	}
	static [makeResponse](body, inner) {
		const me = new _SyncResponse(body);
		me.#inner = inner;
		return me;
	}
	get headers() {
		return this.#inner.headers;
	}
	get status() {
		return this.#inner.status;
	}
	get statusText() {
		return this.#inner.statusText;
	}
	get ok() {
		return 200 <= this.#inner.status && this.#inner.status <= 299;
	}
	get url() {
		return this.#inner.url ?? "";
	}
	get type() {
		return this.#inner.type;
	}
	arrayBuffer() {
		return this.bytes().buffer;
	}
	bytes() {
		if (this.#body == null) return new Uint8Array();
		else if (typeof this.#body === "string") return textEncoder.encode(this.#body);
		else return new Uint8Array(this.#body);
	}
	json() {
		return JSON.parse(this.text());
	}
	text() {
		if (this.#body == null) return "";
		else if (typeof this.#body === "string") return this.#body;
		else return textDecoder.decode(this.#body);
	}
};
var requestBaseSize = bsatnBaseSize({ types: [] }, http_request_type_default.algebraicType);
var methods = /* @__PURE__ */ new Map([
	["GET", { tag: "Get" }],
	["HEAD", { tag: "Head" }],
	["POST", { tag: "Post" }],
	["PUT", { tag: "Put" }],
	["DELETE", { tag: "Delete" }],
	["CONNECT", { tag: "Connect" }],
	["OPTIONS", { tag: "Options" }],
	["TRACE", { tag: "Trace" }],
	["PATCH", { tag: "Patch" }]
]);
function fetch(url, init2 = {}) {
	const method = methods.get(init2.method?.toUpperCase() ?? "GET") ?? {
		tag: "Extension",
		value: init2.method
	};
	const headers = { entries: headersToList(new Headers(init2.headers)).flatMap(([k, v]) => Array.isArray(v) ? v.map((v2) => [k, v2]) : [[k, v]]).map(([name, value]) => ({
		name,
		value: textEncoder.encode(value)
	})) };
	const uri$1 = "" + url;
	const request = freeze({
		method,
		headers,
		timeout: init2.timeout,
		uri: uri$1,
		version: { tag: "Http11" }
	});
	const requestBuf = new BinaryWriter(requestBaseSize);
	http_request_type_default.serialize(requestBuf, request);
	const body = init2.body == null ? new Uint8Array() : typeof init2.body === "string" ? init2.body : new Uint8Array(init2.body);
	const [responseBuf, responseBody] = sys.procedure_http_request(requestBuf.getBuffer(), body);
	const response = http_response_type_default.deserialize(new BinaryReader(responseBuf));
	return SyncResponse[makeResponse](responseBody, {
		type: "basic",
		url: uri$1,
		status: response.code,
		statusText: (0, import_statuses.default)(response.code),
		headers: new Headers(),
		aborted: false
	});
}
freeze(fetch);
var httpClient = freeze({ fetch });
var { freeze: freeze2 } = Object;
function callProcedure(id, sender, connectionId, timestamp, argsBuf) {
	const { fn, paramsType, returnType, returnTypeBaseSize } = PROCEDURES[id];
	const args = ProductType.deserializeValue(new BinaryReader(argsBuf), paramsType, MODULE_DEF.typespace);
	const ctx = {
		sender,
		timestamp,
		connectionId,
		http: httpClient,
		counter_uuid: { value: 0 },
		get identity() {
			return new Identity(sys.identity().__identity__);
		},
		withTx(body) {
			const run = () => {
				const timestamp2 = sys.procedure_start_mut_tx();
				try {
					return body(new ReducerCtxImpl(sender, new Timestamp(timestamp2), connectionId));
				} catch (e) {
					sys.procedure_abort_mut_tx();
					throw e;
				}
			};
			let res = run();
			try {
				sys.procedure_commit_mut_tx();
				return res;
			} catch {}
			console.warn("committing anonymous transaction failed");
			res = run();
			try {
				sys.procedure_commit_mut_tx();
				return res;
			} catch (e) {
				throw new Error("transaction retry failed again", { cause: e });
			}
		},
		newUuidV4() {
			const bytes = crypto.getRandomValues(new Uint8Array(16));
			return Uuid.fromRandomBytesV4(bytes);
		},
		newUuidV7() {
			const bytes = crypto.getRandomValues(new Uint8Array(10));
			return Uuid.fromCounterV7(this.counter_uuid, this.timestamp, bytes);
		}
	};
	freeze2(ctx);
	const ret = callUserFunction(fn, ctx, args);
	const retBuf = new BinaryWriter(returnTypeBaseSize);
	AlgebraicType.serializeValue(retBuf, returnType, ret, MODULE_DEF.typespace);
	return retBuf.getBuffer();
}
var view_result_header_type_default = t.enum("ViewResultHeader", {
	RowData: t.unit(),
	RawSql: t.string()
});
var { freeze: freeze3 } = Object;
var sys = freeze3(wrapSyscalls(_syscalls1_0, _syscalls1_2));
function parseJsonObject(json) {
	let value;
	try {
		value = JSON.parse(json);
	} catch {
		throw new Error("Invalid JSON: failed to parse string");
	}
	if (value === null || typeof value !== "object" || Array.isArray(value)) throw new Error("Expected a JSON object at the top level");
	return value;
}
var JwtClaimsImpl = class {
	/**
	* Creates a new JwtClaims instance.
	* @param rawPayload The JWT payload as a raw JSON string.
	* @param identity The identity for this JWT. We are only taking this because we don't have a blake3 implementation (which we need to compute it).
	*/
	constructor(rawPayload, identity) {
		this.rawPayload = rawPayload;
		this.fullPayload = parseJsonObject(rawPayload);
		this._identity = identity;
	}
	fullPayload;
	_identity;
	get identity() {
		return this._identity;
	}
	get subject() {
		return this.fullPayload["sub"];
	}
	get issuer() {
		return this.fullPayload["iss"];
	}
	get audience() {
		const aud = this.fullPayload["aud"];
		if (aud == null) return [];
		return typeof aud === "string" ? [aud] : aud;
	}
};
var AuthCtxImpl = class _AuthCtxImpl {
	isInternal;
	_jwtSource;
	_initializedJWT = false;
	_jwtClaims;
	_senderIdentity;
	constructor(opts) {
		this.isInternal = opts.isInternal;
		this._jwtSource = opts.jwtSource;
		this._senderIdentity = opts.senderIdentity;
	}
	_initializeJWT() {
		if (this._initializedJWT) return;
		this._initializedJWT = true;
		const token = this._jwtSource();
		if (!token) this._jwtClaims = null;
		else this._jwtClaims = new JwtClaimsImpl(token, this._senderIdentity);
		Object.freeze(this);
	}
	/** Lazily compute whether a JWT exists and is parseable. */
	get hasJWT() {
		this._initializeJWT();
		return this._jwtClaims !== null;
	}
	/** Lazily parse the JwtClaims only when accessed. */
	get jwt() {
		this._initializeJWT();
		return this._jwtClaims;
	}
	/** Create a context representing internal (non-user) requests. */
	static internal() {
		return new _AuthCtxImpl({
			isInternal: true,
			jwtSource: () => null,
			senderIdentity: Identity.zero()
		});
	}
	/** If there is a connection id, look up the JWT payload from the system tables. */
	static fromSystemTables(connectionId, sender) {
		if (connectionId === null) return new _AuthCtxImpl({
			isInternal: false,
			jwtSource: () => null,
			senderIdentity: sender
		});
		return new _AuthCtxImpl({
			isInternal: false,
			jwtSource: () => {
				const payloadBuf = sys.get_jwt_payload(connectionId.__connection_id__);
				if (payloadBuf.length === 0) return null;
				return new TextDecoder().decode(payloadBuf);
			},
			senderIdentity: sender
		});
	}
};
var ReducerCtxImpl = class ReducerCtx {
	#identity;
	#senderAuth;
	#uuidCounter;
	sender;
	timestamp;
	connectionId;
	db;
	constructor(sender, timestamp, connectionId) {
		Object.seal(this);
		this.sender = sender;
		this.timestamp = timestamp;
		this.connectionId = connectionId;
		this.db = getDbView();
	}
	get identity() {
		return this.#identity ??= new Identity(sys.identity().__identity__);
	}
	get senderAuth() {
		return this.#senderAuth ??= AuthCtxImpl.fromSystemTables(this.connectionId, this.sender);
	}
	/**
	* Create a new random {@link Uuid} `v4` using the {@link crypto} RNG.
	*
	* WARN: Until we use a spacetime RNG this make calls non-deterministic.
	*/
	newUuidV4() {
		const bytes = crypto.getRandomValues(new Uint8Array(16));
		return Uuid.fromRandomBytesV4(bytes);
	}
	/**
	* Create a new sortable {@link Uuid} `v7` using the {@link crypto} RNG, counter,
	* and the timestamp.
	*
	* WARN: Until we use a spacetime RNG this make calls non-deterministic.
	*/
	newUuidV7() {
		const bytes = crypto.getRandomValues(new Uint8Array(4));
		const counter = this.#uuidCounter ??= { value: 0 };
		return Uuid.fromCounterV7(counter, this.timestamp, bytes);
	}
};
var callUserFunction = function __spacetimedb_end_short_backtrace(fn, ...args) {
	return fn(...args);
};
var hooks = {
	__describe_module__() {
		const writer = new BinaryWriter(128);
		AlgebraicType.serializeValue(writer, raw_module_def_type_default.algebraicType, raw_module_def_type_default.V9(MODULE_DEF));
		return writer.getBuffer();
	},
	__call_reducer__(reducerId, sender, connId, timestamp, argsBuf) {
		const argsType = AlgebraicType.Product(MODULE_DEF.reducers[reducerId].params);
		const args = AlgebraicType.deserializeValue(new BinaryReader(argsBuf), argsType, MODULE_DEF.typespace);
		const ctx = new ReducerCtxImpl(new Identity(sender), new Timestamp(timestamp), ConnectionId.nullIfZero(new ConnectionId(connId)));
		try {
			return callUserFunction(REDUCERS[reducerId], ctx, args) ?? { tag: "ok" };
		} catch (e) {
			if (e instanceof SenderError) return {
				tag: "err",
				value: e.message
			};
			throw e;
		}
	}
};
var hooks_v1_1 = {
	__call_view__(id, sender, argsBuf) {
		const { fn, params, returnType, returnTypeBaseSize } = VIEWS[id];
		const ret = callUserFunction(fn, freeze3({
			sender: new Identity(sender),
			db: getDbView(),
			from: makeQueryBuilder(getRegisteredSchema())
		}), ProductType.deserializeValue(new BinaryReader(argsBuf), params, MODULE_DEF.typespace));
		const retBuf = new BinaryWriter(returnTypeBaseSize);
		if (isRowTypedQuery(ret)) {
			const query = toSql(ret);
			const v = view_result_header_type_default.RawSql(query);
			AlgebraicType.serializeValue(retBuf, view_result_header_type_default.algebraicType, v, MODULE_DEF.typespace);
			return { data: retBuf.getBuffer() };
		} else {
			AlgebraicType.serializeValue(retBuf, view_result_header_type_default.algebraicType, view_result_header_type_default.RowData, MODULE_DEF.typespace);
			AlgebraicType.serializeValue(retBuf, returnType, ret, MODULE_DEF.typespace);
			return { data: retBuf.getBuffer() };
		}
	},
	__call_view_anon__(id, argsBuf) {
		const { fn, params, returnType, returnTypeBaseSize } = ANON_VIEWS[id];
		const ret = callUserFunction(fn, freeze3({
			db: getDbView(),
			from: makeQueryBuilder(getRegisteredSchema())
		}), ProductType.deserializeValue(new BinaryReader(argsBuf), params, MODULE_DEF.typespace));
		const retBuf = new BinaryWriter(returnTypeBaseSize);
		if (isRowTypedQuery(ret)) {
			const query = toSql(ret);
			const v = view_result_header_type_default.RawSql(query);
			AlgebraicType.serializeValue(retBuf, view_result_header_type_default.algebraicType, v, MODULE_DEF.typespace);
			return { data: retBuf.getBuffer() };
		} else {
			AlgebraicType.serializeValue(retBuf, view_result_header_type_default.algebraicType, view_result_header_type_default.RowData, MODULE_DEF.typespace);
			AlgebraicType.serializeValue(retBuf, returnType, ret, MODULE_DEF.typespace);
			return { data: retBuf.getBuffer() };
		}
	}
};
var hooks_v1_2 = { __call_procedure__(id, sender, connection_id, timestamp, args) {
	return callProcedure(id, new Identity(sender), ConnectionId.nullIfZero(new ConnectionId(connection_id)), new Timestamp(timestamp), args);
} };
var DB_VIEW = null;
function getDbView() {
	DB_VIEW ??= makeDbView(MODULE_DEF);
	return DB_VIEW;
}
function makeDbView(moduleDef) {
	return freeze3(Object.fromEntries(moduleDef.tables.map((table2) => [toCamelCase(table2.name), makeTableView(moduleDef.typespace, table2)])));
}
function makeTableView(typespace, table2) {
	const table_id = sys.table_id_from_name(table2.name);
	const rowType = typespace.types[table2.productTypeRef];
	if (rowType.tag !== "Product") throw "impossible";
	const baseSize = bsatnBaseSize(typespace, rowType);
	const sequences = table2.sequences.map((seq) => {
		const col = rowType.value.elements[seq.column];
		const colType = col.algebraicType;
		let sequenceTrigger;
		switch (colType.tag) {
			case "U8":
			case "I8":
			case "U16":
			case "I16":
			case "U32":
			case "I32":
				sequenceTrigger = 0;
				break;
			case "U64":
			case "I64":
			case "U128":
			case "I128":
			case "U256":
			case "I256":
				sequenceTrigger = 0n;
				break;
			default: throw new TypeError("invalid sequence type");
		}
		return {
			colName: col.name,
			sequenceTrigger,
			read: (reader) => AlgebraicType.deserializeValue(reader, colType, typespace)
		};
	});
	const hasAutoIncrement = sequences.length > 0;
	const iter = () => tableIterator(sys.datastore_table_scan_bsatn(table_id), rowType);
	const integrateGeneratedColumns = hasAutoIncrement ? (row, ret_buf) => {
		const reader = new BinaryReader(ret_buf);
		for (const { colName, read, sequenceTrigger } of sequences) if (row[colName] === sequenceTrigger) row[colName] = read(reader);
	} : null;
	const tableMethods = {
		count: () => sys.datastore_table_row_count(table_id),
		iter,
		[Symbol.iterator]: () => iter(),
		insert: (row) => {
			const writer = new BinaryWriter(baseSize);
			AlgebraicType.serializeValue(writer, rowType, row, typespace);
			const ret_buf = sys.datastore_insert_bsatn(table_id, writer.getBuffer());
			const ret = { ...row };
			integrateGeneratedColumns?.(ret, ret_buf);
			return ret;
		},
		delete: (row) => {
			const writer = new BinaryWriter(4 + baseSize);
			writer.writeU32(1);
			AlgebraicType.serializeValue(writer, rowType, row, typespace);
			return sys.datastore_delete_all_by_eq_bsatn(table_id, writer.getBuffer()) > 0;
		}
	};
	const tableView = Object.assign(/* @__PURE__ */ Object.create(null), tableMethods);
	for (const indexDef of table2.indexes) {
		const index_id = sys.index_id_from_name(indexDef.name);
		let column_ids;
		switch (indexDef.algorithm.tag) {
			case "BTree":
				column_ids = indexDef.algorithm.value;
				break;
			case "Hash": throw new Error("impossible");
			case "Direct":
				column_ids = [indexDef.algorithm.value];
				break;
		}
		const numColumns = column_ids.length;
		const columnSet = new Set(column_ids);
		const isUnique = table2.constraints.filter((x) => x.data.tag === "Unique").some((x) => columnSet.isSubsetOf(new Set(x.data.value.columns)));
		const indexType = AlgebraicType.Product({ elements: column_ids.map((id) => rowType.value.elements[id]) });
		const baseSize2 = bsatnBaseSize(typespace, indexType);
		const serializePrefix = (writer, prefix, prefix_elems) => {
			if (prefix_elems > numColumns - 1) throw new TypeError("too many elements in prefix");
			for (let i = 0; i < prefix_elems; i++) {
				const elemType = indexType.value.elements[i].algebraicType;
				AlgebraicType.serializeValue(writer, elemType, prefix[i], typespace);
			}
			return writer;
		};
		let index;
		if (isUnique) {
			const serializeBound = (colVal) => {
				if (colVal.length !== numColumns) throw new TypeError("wrong number of elements");
				const writer = new BinaryWriter(baseSize2 + 1);
				const prefix_elems = numColumns - 1;
				serializePrefix(writer, colVal, prefix_elems);
				const rstartOffset = writer.offset;
				writer.writeU8(0);
				AlgebraicType.serializeValue(writer, indexType.value.elements[numColumns - 1].algebraicType, colVal[numColumns - 1], typespace);
				const buffer = writer.getBuffer();
				const prefix = buffer.slice(0, rstartOffset);
				const rstart = buffer.slice(rstartOffset);
				return [
					prefix,
					prefix_elems,
					rstart,
					rstart
				];
			};
			index = {
				find: (colVal) => {
					if (numColumns === 1) colVal = [colVal];
					const args = serializeBound(colVal);
					const iter2 = tableIterator(sys.datastore_index_scan_range_bsatn(index_id, ...args), rowType);
					const { value, done } = iter2.next();
					if (done) return null;
					if (!iter2.next().done) throw new Error("`datastore_index_scan_range_bsatn` on unique field cannot return >1 rows");
					return value;
				},
				delete: (colVal) => {
					if (numColumns === 1) colVal = [colVal];
					const args = serializeBound(colVal);
					return sys.datastore_delete_by_index_scan_range_bsatn(index_id, ...args) > 0;
				},
				update: (row) => {
					const writer = new BinaryWriter(baseSize2);
					AlgebraicType.serializeValue(writer, rowType, row, typespace);
					const ret_buf = sys.datastore_update_bsatn(table_id, index_id, writer.getBuffer());
					integrateGeneratedColumns?.(row, ret_buf);
					return row;
				}
			};
		} else {
			const serializeRange = (range) => {
				if (range.length > numColumns) throw new TypeError("too many elements");
				const writer = new BinaryWriter(baseSize2 + 1);
				const prefix_elems = range.length - 1;
				serializePrefix(writer, range, prefix_elems);
				const rstartOffset = writer.offset;
				const term = range[range.length - 1];
				const termType = indexType.value.elements[range.length - 1].algebraicType;
				let rstart, rend;
				if (term instanceof Range) {
					const writeBound = (bound) => {
						writer.writeU8({
							included: 0,
							excluded: 1,
							unbounded: 2
						}[bound.tag]);
						if (bound.tag !== "unbounded") AlgebraicType.serializeValue(writer, termType, bound.value, typespace);
					};
					writeBound(term.from);
					const rendOffset = writer.offset;
					writeBound(term.to);
					rstart = writer.getBuffer().slice(rstartOffset, rendOffset);
					rend = writer.getBuffer().slice(rendOffset);
				} else {
					writer.writeU8(0);
					AlgebraicType.serializeValue(writer, termType, term, typespace);
					rstart = rend = writer.getBuffer().slice(rstartOffset);
				}
				return [
					writer.getBuffer().slice(0, rstartOffset),
					prefix_elems,
					rstart,
					rend
				];
			};
			index = {
				filter: (range) => {
					if (numColumns === 1) range = [range];
					const args = serializeRange(range);
					return tableIterator(sys.datastore_index_scan_range_bsatn(index_id, ...args), rowType);
				},
				delete: (range) => {
					if (numColumns === 1) range = [range];
					const args = serializeRange(range);
					return sys.datastore_delete_by_index_scan_range_bsatn(index_id, ...args);
				}
			};
		}
		if (Object.hasOwn(tableView, indexDef.accessorName)) freeze3(Object.assign(tableView[indexDef.accessorName], index));
		else tableView[indexDef.accessorName] = freeze3(index);
	}
	return freeze3(tableView);
}
function hasOwn(o, k) {
	return Object.hasOwn(o, k);
}
function* tableIterator(id, ty) {
	var _stack = [];
	try {
		const iter = __using(_stack, new IteratorHandle(id));
		const { typespace } = MODULE_DEF;
		let buf;
		while ((buf = advanceIter(iter)) != null) {
			const reader = new BinaryReader(buf);
			while (reader.remaining > 0) yield AlgebraicType.deserializeValue(reader, ty, typespace);
		}
	} catch (_$1) {
		var _error = _$1, _hasError = true;
	} finally {
		__callDispose(_stack, _error, _hasError);
	}
}
function advanceIter(iter) {
	let buf_max_len = 65536;
	while (true) try {
		return iter.advance(buf_max_len);
	} catch (e) {
		if (e && typeof e === "object" && hasOwn(e, "__buffer_too_small__")) {
			buf_max_len = e.__buffer_too_small__;
			continue;
		}
		throw e;
	}
}
var IteratorHandle = class _IteratorHandle {
	#id;
	static #finalizationRegistry = new FinalizationRegistry(sys.row_iter_bsatn_close);
	constructor(id) {
		this.#id = id;
		_IteratorHandle.#finalizationRegistry.register(this, id, this);
	}
	/** Unregister this object with the finalization registry and return the id */
	#detach() {
		const id = this.#id;
		this.#id = -1;
		_IteratorHandle.#finalizationRegistry.unregister(this);
		return id;
	}
	/** Call `row_iter_bsatn_advance`, returning null if this iterator was already exhausted. */
	advance(buf_max_len) {
		if (this.#id === -1) return null;
		const { 0: done, 1: buf } = sys.row_iter_bsatn_advance(this.#id, buf_max_len);
		if (done) this.#detach();
		return buf;
	}
	[Symbol.dispose]() {
		if (this.#id >= 0) {
			const id = this.#detach();
			sys.row_iter_bsatn_close(id);
		}
	}
};
function wrapSyscalls(...modules) {
	return Object.fromEntries(modules.flatMap(Object.entries).map(([k, v]) => [k, wrapSyscall(v)]));
}
function wrapSyscall(func) {
	const name = func.name;
	return { [name](...args) {
		try {
			return func(...args);
		} catch (e) {
			if (e !== null && typeof e === "object" && hasOwn(e, "__code_error__") && typeof e.__code_error__ == "number") {
				const message = hasOwn(e, "__error_message__") && typeof e.__error_message__ === "string" ? e.__error_message__ : void 0;
				throw new SpacetimeHostError(e.__code_error__, message);
			}
			throw e;
		}
	} }[name];
}
function fmtLog(...data) {
	return data.join(" ");
}
var console_level_error = 0;
var console_level_warn = 1;
var console_level_info = 2;
var console_level_debug = 3;
var console_level_trace = 4;
var timerMap = /* @__PURE__ */ new Map();
var console2 = {
	__proto__: {},
	[Symbol.toStringTag]: "console",
	assert: (condition = false, ...data) => {
		if (!condition) sys.console_log(console_level_error, fmtLog(...data));
	},
	clear: () => {},
	debug: (...data) => {
		sys.console_log(console_level_debug, fmtLog(...data));
	},
	error: (...data) => {
		sys.console_log(console_level_error, fmtLog(...data));
	},
	info: (...data) => {
		sys.console_log(console_level_info, fmtLog(...data));
	},
	log: (...data) => {
		sys.console_log(console_level_info, fmtLog(...data));
	},
	table: (tabularData, _properties) => {
		sys.console_log(console_level_info, fmtLog(tabularData));
	},
	trace: (...data) => {
		sys.console_log(console_level_trace, fmtLog(...data));
	},
	warn: (...data) => {
		sys.console_log(console_level_warn, fmtLog(...data));
	},
	dir: (_item, _options) => {},
	dirxml: (..._data) => {},
	count: (_label = "default") => {},
	countReset: (_label = "default") => {},
	group: (..._data) => {},
	groupCollapsed: (..._data) => {},
	groupEnd: () => {},
	time: (label = "default") => {
		if (timerMap.has(label)) {
			sys.console_log(console_level_warn, `Timer '${label}' already exists.`);
			return;
		}
		timerMap.set(label, sys.console_timer_start(label));
	},
	timeLog: (label = "default", ...data) => {
		sys.console_log(console_level_info, fmtLog(label, ...data));
	},
	timeEnd: (label = "default") => {
		const spanId = timerMap.get(label);
		if (spanId === void 0) {
			sys.console_log(console_level_warn, `Timer '${label}' does not exist.`);
			return;
		}
		sys.console_timer_end(spanId);
		timerMap.delete(label);
	},
	timeStamp: () => {},
	profile: () => {},
	profileEnd: () => {}
};
console2.Console = console2;
globalThis.console = console2;
register_hooks(hooks);
register_hooks$1(hooks_v1_1);
register_hooks$2(hooks_v1_2);

//#endregion
//#region ../node_modules/ajv/dist/compile/codegen/code.js
var require_code$1 = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/compile/codegen/code.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;
	var _CodeOrName = class {};
	exports._CodeOrName = _CodeOrName;
	exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
	var Name = class extends _CodeOrName {
		constructor(s) {
			super();
			if (!exports.IDENTIFIER.test(s)) throw new Error("CodeGen: name must be a valid identifier");
			this.str = s;
		}
		toString() {
			return this.str;
		}
		emptyStr() {
			return false;
		}
		get names() {
			return { [this.str]: 1 };
		}
	};
	exports.Name = Name;
	var _Code = class extends _CodeOrName {
		constructor(code) {
			super();
			this._items = typeof code === "string" ? [code] : code;
		}
		toString() {
			return this.str;
		}
		emptyStr() {
			if (this._items.length > 1) return false;
			const item = this._items[0];
			return item === "" || item === "\"\"";
		}
		get str() {
			var _a$1;
			return (_a$1 = this._str) !== null && _a$1 !== void 0 ? _a$1 : this._str = this._items.reduce((s, c) => `${s}${c}`, "");
		}
		get names() {
			var _a$1;
			return (_a$1 = this._names) !== null && _a$1 !== void 0 ? _a$1 : this._names = this._items.reduce((names$1, c) => {
				if (c instanceof Name) names$1[c.str] = (names$1[c.str] || 0) + 1;
				return names$1;
			}, {});
		}
	};
	exports._Code = _Code;
	exports.nil = new _Code("");
	function _(strs, ...args) {
		const code = [strs[0]];
		let i = 0;
		while (i < args.length) {
			addCodeArg(code, args[i]);
			code.push(strs[++i]);
		}
		return new _Code(code);
	}
	exports._ = _;
	const plus = new _Code("+");
	function str(strs, ...args) {
		const expr = [safeStringify(strs[0])];
		let i = 0;
		while (i < args.length) {
			expr.push(plus);
			addCodeArg(expr, args[i]);
			expr.push(plus, safeStringify(strs[++i]));
		}
		optimize(expr);
		return new _Code(expr);
	}
	exports.str = str;
	function addCodeArg(code, arg) {
		if (arg instanceof _Code) code.push(...arg._items);
		else if (arg instanceof Name) code.push(arg);
		else code.push(interpolate(arg));
	}
	exports.addCodeArg = addCodeArg;
	function optimize(expr) {
		let i = 1;
		while (i < expr.length - 1) {
			if (expr[i] === plus) {
				const res = mergeExprItems(expr[i - 1], expr[i + 1]);
				if (res !== void 0) {
					expr.splice(i - 1, 3, res);
					continue;
				}
				expr[i++] = "+";
			}
			i++;
		}
	}
	function mergeExprItems(a, b) {
		if (b === "\"\"") return a;
		if (a === "\"\"") return b;
		if (typeof a == "string") {
			if (b instanceof Name || a[a.length - 1] !== "\"") return;
			if (typeof b != "string") return `${a.slice(0, -1)}${b}"`;
			if (b[0] === "\"") return a.slice(0, -1) + b.slice(1);
			return;
		}
		if (typeof b == "string" && b[0] === "\"" && !(a instanceof Name)) return `"${a}${b.slice(1)}`;
	}
	function strConcat(c1, c2) {
		return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
	}
	exports.strConcat = strConcat;
	function interpolate(x) {
		return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
	}
	function stringify(x) {
		return new _Code(safeStringify(x));
	}
	exports.stringify = stringify;
	function safeStringify(x) {
		return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
	}
	exports.safeStringify = safeStringify;
	function getProperty(key) {
		return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
	}
	exports.getProperty = getProperty;
	function getEsmExportName(key) {
		if (typeof key == "string" && exports.IDENTIFIER.test(key)) return new _Code(`${key}`);
		throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
	}
	exports.getEsmExportName = getEsmExportName;
	function regexpCode(rx) {
		return new _Code(rx.toString());
	}
	exports.regexpCode = regexpCode;
}) });

//#endregion
//#region ../node_modules/ajv/dist/compile/codegen/scope.js
var require_scope = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/compile/codegen/scope.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;
	const code_1$12 = require_code$1();
	var ValueError = class extends Error {
		constructor(name) {
			super(`CodeGen: "code" for ${name} not defined`);
			this.value = name.value;
		}
	};
	var UsedValueState;
	(function(UsedValueState$1) {
		UsedValueState$1[UsedValueState$1["Started"] = 0] = "Started";
		UsedValueState$1[UsedValueState$1["Completed"] = 1] = "Completed";
	})(UsedValueState || (exports.UsedValueState = UsedValueState = {}));
	exports.varKinds = {
		const: new code_1$12.Name("const"),
		let: new code_1$12.Name("let"),
		var: new code_1$12.Name("var")
	};
	var Scope = class {
		constructor({ prefixes, parent } = {}) {
			this._names = {};
			this._prefixes = prefixes;
			this._parent = parent;
		}
		toName(nameOrPrefix) {
			return nameOrPrefix instanceof code_1$12.Name ? nameOrPrefix : this.name(nameOrPrefix);
		}
		name(prefix) {
			return new code_1$12.Name(this._newName(prefix));
		}
		_newName(prefix) {
			const ng = this._names[prefix] || this._nameGroup(prefix);
			return `${prefix}${ng.index++}`;
		}
		_nameGroup(prefix) {
			var _a$1, _b$1;
			if (((_b$1 = (_a$1 = this._parent) === null || _a$1 === void 0 ? void 0 : _a$1._prefixes) === null || _b$1 === void 0 ? void 0 : _b$1.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
			return this._names[prefix] = {
				prefix,
				index: 0
			};
		}
	};
	exports.Scope = Scope;
	var ValueScopeName = class extends code_1$12.Name {
		constructor(prefix, nameStr) {
			super(nameStr);
			this.prefix = prefix;
		}
		setValue(value, { property, itemIndex }) {
			this.value = value;
			this.scopePath = (0, code_1$12._)`.${new code_1$12.Name(property)}[${itemIndex}]`;
		}
	};
	exports.ValueScopeName = ValueScopeName;
	const line = (0, code_1$12._)`\n`;
	var ValueScope = class extends Scope {
		constructor(opts) {
			super(opts);
			this._values = {};
			this._scope = opts.scope;
			this.opts = {
				...opts,
				_n: opts.lines ? line : code_1$12.nil
			};
		}
		get() {
			return this._scope;
		}
		name(prefix) {
			return new ValueScopeName(prefix, this._newName(prefix));
		}
		value(nameOrPrefix, value) {
			var _a$1;
			if (value.ref === void 0) throw new Error("CodeGen: ref must be passed in value");
			const name = this.toName(nameOrPrefix);
			const { prefix } = name;
			const valueKey = (_a$1 = value.key) !== null && _a$1 !== void 0 ? _a$1 : value.ref;
			let vs = this._values[prefix];
			if (vs) {
				const _name = vs.get(valueKey);
				if (_name) return _name;
			} else vs = this._values[prefix] = /* @__PURE__ */ new Map();
			vs.set(valueKey, name);
			const s = this._scope[prefix] || (this._scope[prefix] = []);
			const itemIndex = s.length;
			s[itemIndex] = value.ref;
			name.setValue(value, {
				property: prefix,
				itemIndex
			});
			return name;
		}
		getValue(prefix, keyOrRef) {
			const vs = this._values[prefix];
			if (!vs) return;
			return vs.get(keyOrRef);
		}
		scopeRefs(scopeName, values = this._values) {
			return this._reduceValues(values, (name) => {
				if (name.scopePath === void 0) throw new Error(`CodeGen: name "${name}" has no value`);
				return (0, code_1$12._)`${scopeName}${name.scopePath}`;
			});
		}
		scopeCode(values = this._values, usedValues, getCode) {
			return this._reduceValues(values, (name) => {
				if (name.value === void 0) throw new Error(`CodeGen: name "${name}" has no value`);
				return name.value.code;
			}, usedValues, getCode);
		}
		_reduceValues(values, valueCode, usedValues = {}, getCode) {
			let code = code_1$12.nil;
			for (const prefix in values) {
				const vs = values[prefix];
				if (!vs) continue;
				const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
				vs.forEach((name) => {
					if (nameSet.has(name)) return;
					nameSet.set(name, UsedValueState.Started);
					let c = valueCode(name);
					if (c) {
						const def$30 = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
						code = (0, code_1$12._)`${code}${def$30} ${name} = ${c};${this.opts._n}`;
					} else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) code = (0, code_1$12._)`${code}${c}${this.opts._n}`;
					else throw new ValueError(name);
					nameSet.set(name, UsedValueState.Completed);
				});
			}
			return code;
		}
	};
	exports.ValueScope = ValueScope;
}) });

//#endregion
//#region ../node_modules/ajv/dist/compile/codegen/index.js
var require_codegen = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/compile/codegen/index.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;
	const code_1$11 = require_code$1();
	const scope_1 = require_scope();
	var code_2 = require_code$1();
	Object.defineProperty(exports, "_", {
		enumerable: true,
		get: function() {
			return code_2._;
		}
	});
	Object.defineProperty(exports, "str", {
		enumerable: true,
		get: function() {
			return code_2.str;
		}
	});
	Object.defineProperty(exports, "strConcat", {
		enumerable: true,
		get: function() {
			return code_2.strConcat;
		}
	});
	Object.defineProperty(exports, "nil", {
		enumerable: true,
		get: function() {
			return code_2.nil;
		}
	});
	Object.defineProperty(exports, "getProperty", {
		enumerable: true,
		get: function() {
			return code_2.getProperty;
		}
	});
	Object.defineProperty(exports, "stringify", {
		enumerable: true,
		get: function() {
			return code_2.stringify;
		}
	});
	Object.defineProperty(exports, "regexpCode", {
		enumerable: true,
		get: function() {
			return code_2.regexpCode;
		}
	});
	Object.defineProperty(exports, "Name", {
		enumerable: true,
		get: function() {
			return code_2.Name;
		}
	});
	var scope_2 = require_scope();
	Object.defineProperty(exports, "Scope", {
		enumerable: true,
		get: function() {
			return scope_2.Scope;
		}
	});
	Object.defineProperty(exports, "ValueScope", {
		enumerable: true,
		get: function() {
			return scope_2.ValueScope;
		}
	});
	Object.defineProperty(exports, "ValueScopeName", {
		enumerable: true,
		get: function() {
			return scope_2.ValueScopeName;
		}
	});
	Object.defineProperty(exports, "varKinds", {
		enumerable: true,
		get: function() {
			return scope_2.varKinds;
		}
	});
	exports.operators = {
		GT: new code_1$11._Code(">"),
		GTE: new code_1$11._Code(">="),
		LT: new code_1$11._Code("<"),
		LTE: new code_1$11._Code("<="),
		EQ: new code_1$11._Code("==="),
		NEQ: new code_1$11._Code("!=="),
		NOT: new code_1$11._Code("!"),
		OR: new code_1$11._Code("||"),
		AND: new code_1$11._Code("&&"),
		ADD: new code_1$11._Code("+")
	};
	var Node = class {
		optimizeNodes() {
			return this;
		}
		optimizeNames(_names, _constants) {
			return this;
		}
	};
	var Def = class extends Node {
		constructor(varKind, name, rhs) {
			super();
			this.varKind = varKind;
			this.name = name;
			this.rhs = rhs;
		}
		render({ es5, _n }) {
			const varKind = es5 ? scope_1.varKinds.var : this.varKind;
			const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
			return `${varKind} ${this.name}${rhs};` + _n;
		}
		optimizeNames(names$1, constants) {
			if (!names$1[this.name.str]) return;
			if (this.rhs) this.rhs = optimizeExpr(this.rhs, names$1, constants);
			return this;
		}
		get names() {
			return this.rhs instanceof code_1$11._CodeOrName ? this.rhs.names : {};
		}
	};
	var Assign = class extends Node {
		constructor(lhs, rhs, sideEffects) {
			super();
			this.lhs = lhs;
			this.rhs = rhs;
			this.sideEffects = sideEffects;
		}
		render({ _n }) {
			return `${this.lhs} = ${this.rhs};` + _n;
		}
		optimizeNames(names$1, constants) {
			if (this.lhs instanceof code_1$11.Name && !names$1[this.lhs.str] && !this.sideEffects) return;
			this.rhs = optimizeExpr(this.rhs, names$1, constants);
			return this;
		}
		get names() {
			return addExprNames(this.lhs instanceof code_1$11.Name ? {} : { ...this.lhs.names }, this.rhs);
		}
	};
	var AssignOp = class extends Assign {
		constructor(lhs, op, rhs, sideEffects) {
			super(lhs, rhs, sideEffects);
			this.op = op;
		}
		render({ _n }) {
			return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
		}
	};
	var Label = class extends Node {
		constructor(label) {
			super();
			this.label = label;
			this.names = {};
		}
		render({ _n }) {
			return `${this.label}:` + _n;
		}
	};
	var Break = class extends Node {
		constructor(label) {
			super();
			this.label = label;
			this.names = {};
		}
		render({ _n }) {
			return `break${this.label ? ` ${this.label}` : ""};` + _n;
		}
	};
	var Throw = class extends Node {
		constructor(error) {
			super();
			this.error = error;
		}
		render({ _n }) {
			return `throw ${this.error};` + _n;
		}
		get names() {
			return this.error.names;
		}
	};
	var AnyCode = class extends Node {
		constructor(code) {
			super();
			this.code = code;
		}
		render({ _n }) {
			return `${this.code};` + _n;
		}
		optimizeNodes() {
			return `${this.code}` ? this : void 0;
		}
		optimizeNames(names$1, constants) {
			this.code = optimizeExpr(this.code, names$1, constants);
			return this;
		}
		get names() {
			return this.code instanceof code_1$11._CodeOrName ? this.code.names : {};
		}
	};
	var ParentNode = class extends Node {
		constructor(nodes = []) {
			super();
			this.nodes = nodes;
		}
		render(opts) {
			return this.nodes.reduce((code, n) => code + n.render(opts), "");
		}
		optimizeNodes() {
			const { nodes } = this;
			let i = nodes.length;
			while (i--) {
				const n = nodes[i].optimizeNodes();
				if (Array.isArray(n)) nodes.splice(i, 1, ...n);
				else if (n) nodes[i] = n;
				else nodes.splice(i, 1);
			}
			return nodes.length > 0 ? this : void 0;
		}
		optimizeNames(names$1, constants) {
			const { nodes } = this;
			let i = nodes.length;
			while (i--) {
				const n = nodes[i];
				if (n.optimizeNames(names$1, constants)) continue;
				subtractNames(names$1, n.names);
				nodes.splice(i, 1);
			}
			return nodes.length > 0 ? this : void 0;
		}
		get names() {
			return this.nodes.reduce((names$1, n) => addNames(names$1, n.names), {});
		}
	};
	var BlockNode = class extends ParentNode {
		render(opts) {
			return "{" + opts._n + super.render(opts) + "}" + opts._n;
		}
	};
	var Root = class extends ParentNode {};
	var Else = class extends BlockNode {};
	Else.kind = "else";
	var If = class If extends BlockNode {
		constructor(condition, nodes) {
			super(nodes);
			this.condition = condition;
		}
		render(opts) {
			let code = `if(${this.condition})` + super.render(opts);
			if (this.else) code += "else " + this.else.render(opts);
			return code;
		}
		optimizeNodes() {
			super.optimizeNodes();
			const cond = this.condition;
			if (cond === true) return this.nodes;
			let e = this.else;
			if (e) {
				const ns = e.optimizeNodes();
				e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
			}
			if (e) {
				if (cond === false) return e instanceof If ? e : e.nodes;
				if (this.nodes.length) return this;
				return new If(not(cond), e instanceof If ? [e] : e.nodes);
			}
			if (cond === false || !this.nodes.length) return void 0;
			return this;
		}
		optimizeNames(names$1, constants) {
			var _a$1;
			this.else = (_a$1 = this.else) === null || _a$1 === void 0 ? void 0 : _a$1.optimizeNames(names$1, constants);
			if (!(super.optimizeNames(names$1, constants) || this.else)) return;
			this.condition = optimizeExpr(this.condition, names$1, constants);
			return this;
		}
		get names() {
			const names$1 = super.names;
			addExprNames(names$1, this.condition);
			if (this.else) addNames(names$1, this.else.names);
			return names$1;
		}
	};
	If.kind = "if";
	var For = class extends BlockNode {};
	For.kind = "for";
	var ForLoop = class extends For {
		constructor(iteration) {
			super();
			this.iteration = iteration;
		}
		render(opts) {
			return `for(${this.iteration})` + super.render(opts);
		}
		optimizeNames(names$1, constants) {
			if (!super.optimizeNames(names$1, constants)) return;
			this.iteration = optimizeExpr(this.iteration, names$1, constants);
			return this;
		}
		get names() {
			return addNames(super.names, this.iteration.names);
		}
	};
	var ForRange = class extends For {
		constructor(varKind, name, from, to) {
			super();
			this.varKind = varKind;
			this.name = name;
			this.from = from;
			this.to = to;
		}
		render(opts) {
			const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
			const { name, from, to } = this;
			return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
		}
		get names() {
			return addExprNames(addExprNames(super.names, this.from), this.to);
		}
	};
	var ForIter = class extends For {
		constructor(loop, varKind, name, iterable) {
			super();
			this.loop = loop;
			this.varKind = varKind;
			this.name = name;
			this.iterable = iterable;
		}
		render(opts) {
			return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
		}
		optimizeNames(names$1, constants) {
			if (!super.optimizeNames(names$1, constants)) return;
			this.iterable = optimizeExpr(this.iterable, names$1, constants);
			return this;
		}
		get names() {
			return addNames(super.names, this.iterable.names);
		}
	};
	var Func = class extends BlockNode {
		constructor(name, args, async) {
			super();
			this.name = name;
			this.args = args;
			this.async = async;
		}
		render(opts) {
			return `${this.async ? "async " : ""}function ${this.name}(${this.args})` + super.render(opts);
		}
	};
	Func.kind = "func";
	var Return = class extends ParentNode {
		render(opts) {
			return "return " + super.render(opts);
		}
	};
	Return.kind = "return";
	var Try = class extends BlockNode {
		render(opts) {
			let code = "try" + super.render(opts);
			if (this.catch) code += this.catch.render(opts);
			if (this.finally) code += this.finally.render(opts);
			return code;
		}
		optimizeNodes() {
			var _a$1, _b$1;
			super.optimizeNodes();
			(_a$1 = this.catch) === null || _a$1 === void 0 || _a$1.optimizeNodes();
			(_b$1 = this.finally) === null || _b$1 === void 0 || _b$1.optimizeNodes();
			return this;
		}
		optimizeNames(names$1, constants) {
			var _a$1, _b$1;
			super.optimizeNames(names$1, constants);
			(_a$1 = this.catch) === null || _a$1 === void 0 || _a$1.optimizeNames(names$1, constants);
			(_b$1 = this.finally) === null || _b$1 === void 0 || _b$1.optimizeNames(names$1, constants);
			return this;
		}
		get names() {
			const names$1 = super.names;
			if (this.catch) addNames(names$1, this.catch.names);
			if (this.finally) addNames(names$1, this.finally.names);
			return names$1;
		}
	};
	var Catch = class extends BlockNode {
		constructor(error) {
			super();
			this.error = error;
		}
		render(opts) {
			return `catch(${this.error})` + super.render(opts);
		}
	};
	Catch.kind = "catch";
	var Finally = class extends BlockNode {
		render(opts) {
			return "finally" + super.render(opts);
		}
	};
	Finally.kind = "finally";
	var CodeGen = class {
		constructor(extScope, opts = {}) {
			this._values = {};
			this._blockStarts = [];
			this._constants = {};
			this.opts = {
				...opts,
				_n: opts.lines ? "\n" : ""
			};
			this._extScope = extScope;
			this._scope = new scope_1.Scope({ parent: extScope });
			this._nodes = [new Root()];
		}
		toString() {
			return this._root.render(this.opts);
		}
		name(prefix) {
			return this._scope.name(prefix);
		}
		scopeName(prefix) {
			return this._extScope.name(prefix);
		}
		scopeValue(prefixOrName, value) {
			const name = this._extScope.value(prefixOrName, value);
			(this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set())).add(name);
			return name;
		}
		getScopeValue(prefix, keyOrRef) {
			return this._extScope.getValue(prefix, keyOrRef);
		}
		scopeRefs(scopeName) {
			return this._extScope.scopeRefs(scopeName, this._values);
		}
		scopeCode() {
			return this._extScope.scopeCode(this._values);
		}
		_def(varKind, nameOrPrefix, rhs, constant) {
			const name = this._scope.toName(nameOrPrefix);
			if (rhs !== void 0 && constant) this._constants[name.str] = rhs;
			this._leafNode(new Def(varKind, name, rhs));
			return name;
		}
		const(nameOrPrefix, rhs, _constant) {
			return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
		}
		let(nameOrPrefix, rhs, _constant) {
			return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
		}
		var(nameOrPrefix, rhs, _constant) {
			return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
		}
		assign(lhs, rhs, sideEffects) {
			return this._leafNode(new Assign(lhs, rhs, sideEffects));
		}
		add(lhs, rhs) {
			return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
		}
		code(c) {
			if (typeof c == "function") c();
			else if (c !== code_1$11.nil) this._leafNode(new AnyCode(c));
			return this;
		}
		object(...keyValues) {
			const code = ["{"];
			for (const [key, value] of keyValues) {
				if (code.length > 1) code.push(",");
				code.push(key);
				if (key !== value || this.opts.es5) {
					code.push(":");
					(0, code_1$11.addCodeArg)(code, value);
				}
			}
			code.push("}");
			return new code_1$11._Code(code);
		}
		if(condition, thenBody, elseBody) {
			this._blockNode(new If(condition));
			if (thenBody && elseBody) this.code(thenBody).else().code(elseBody).endIf();
			else if (thenBody) this.code(thenBody).endIf();
			else if (elseBody) throw new Error("CodeGen: \"else\" body without \"then\" body");
			return this;
		}
		elseIf(condition) {
			return this._elseNode(new If(condition));
		}
		else() {
			return this._elseNode(new Else());
		}
		endIf() {
			return this._endBlockNode(If, Else);
		}
		_for(node, forBody) {
			this._blockNode(node);
			if (forBody) this.code(forBody).endFor();
			return this;
		}
		for(iteration, forBody) {
			return this._for(new ForLoop(iteration), forBody);
		}
		forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
			const name = this._scope.toName(nameOrPrefix);
			return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
		}
		forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
			const name = this._scope.toName(nameOrPrefix);
			if (this.opts.es5) {
				const arr = iterable instanceof code_1$11.Name ? iterable : this.var("_arr", iterable);
				return this.forRange("_i", 0, (0, code_1$11._)`${arr}.length`, (i) => {
					this.var(name, (0, code_1$11._)`${arr}[${i}]`);
					forBody(name);
				});
			}
			return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
		}
		forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
			if (this.opts.ownProperties) return this.forOf(nameOrPrefix, (0, code_1$11._)`Object.keys(${obj})`, forBody);
			const name = this._scope.toName(nameOrPrefix);
			return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
		}
		endFor() {
			return this._endBlockNode(For);
		}
		label(label) {
			return this._leafNode(new Label(label));
		}
		break(label) {
			return this._leafNode(new Break(label));
		}
		return(value) {
			const node = new Return();
			this._blockNode(node);
			this.code(value);
			if (node.nodes.length !== 1) throw new Error("CodeGen: \"return\" should have one node");
			return this._endBlockNode(Return);
		}
		try(tryBody, catchCode, finallyCode) {
			if (!catchCode && !finallyCode) throw new Error("CodeGen: \"try\" without \"catch\" and \"finally\"");
			const node = new Try();
			this._blockNode(node);
			this.code(tryBody);
			if (catchCode) {
				const error = this.name("e");
				this._currNode = node.catch = new Catch(error);
				catchCode(error);
			}
			if (finallyCode) {
				this._currNode = node.finally = new Finally();
				this.code(finallyCode);
			}
			return this._endBlockNode(Catch, Finally);
		}
		throw(error) {
			return this._leafNode(new Throw(error));
		}
		block(body, nodeCount) {
			this._blockStarts.push(this._nodes.length);
			if (body) this.code(body).endBlock(nodeCount);
			return this;
		}
		endBlock(nodeCount) {
			const len = this._blockStarts.pop();
			if (len === void 0) throw new Error("CodeGen: not in self-balancing block");
			const toClose = this._nodes.length - len;
			if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
			this._nodes.length = len;
			return this;
		}
		func(name, args = code_1$11.nil, async, funcBody) {
			this._blockNode(new Func(name, args, async));
			if (funcBody) this.code(funcBody).endFunc();
			return this;
		}
		endFunc() {
			return this._endBlockNode(Func);
		}
		optimize(n = 1) {
			while (n-- > 0) {
				this._root.optimizeNodes();
				this._root.optimizeNames(this._root.names, this._constants);
			}
		}
		_leafNode(node) {
			this._currNode.nodes.push(node);
			return this;
		}
		_blockNode(node) {
			this._currNode.nodes.push(node);
			this._nodes.push(node);
		}
		_endBlockNode(N1, N2) {
			const n = this._currNode;
			if (n instanceof N1 || N2 && n instanceof N2) {
				this._nodes.pop();
				return this;
			}
			throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
		}
		_elseNode(node) {
			const n = this._currNode;
			if (!(n instanceof If)) throw new Error("CodeGen: \"else\" without \"if\"");
			this._currNode = n.else = node;
			return this;
		}
		get _root() {
			return this._nodes[0];
		}
		get _currNode() {
			const ns = this._nodes;
			return ns[ns.length - 1];
		}
		set _currNode(node) {
			const ns = this._nodes;
			ns[ns.length - 1] = node;
		}
	};
	exports.CodeGen = CodeGen;
	function addNames(names$1, from) {
		for (const n in from) names$1[n] = (names$1[n] || 0) + (from[n] || 0);
		return names$1;
	}
	function addExprNames(names$1, from) {
		return from instanceof code_1$11._CodeOrName ? addNames(names$1, from.names) : names$1;
	}
	function optimizeExpr(expr, names$1, constants) {
		if (expr instanceof code_1$11.Name) return replaceName(expr);
		if (!canOptimize(expr)) return expr;
		return new code_1$11._Code(expr._items.reduce((items, c) => {
			if (c instanceof code_1$11.Name) c = replaceName(c);
			if (c instanceof code_1$11._Code) items.push(...c._items);
			else items.push(c);
			return items;
		}, []));
		function replaceName(n) {
			const c = constants[n.str];
			if (c === void 0 || names$1[n.str] !== 1) return n;
			delete names$1[n.str];
			return c;
		}
		function canOptimize(e) {
			return e instanceof code_1$11._Code && e._items.some((c) => c instanceof code_1$11.Name && names$1[c.str] === 1 && constants[c.str] !== void 0);
		}
	}
	function subtractNames(names$1, from) {
		for (const n in from) names$1[n] = (names$1[n] || 0) - (from[n] || 0);
	}
	function not(x) {
		return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1$11._)`!${par(x)}`;
	}
	exports.not = not;
	const andCode = mappend(exports.operators.AND);
	function and(...args) {
		return args.reduce(andCode);
	}
	exports.and = and;
	const orCode = mappend(exports.operators.OR);
	function or(...args) {
		return args.reduce(orCode);
	}
	exports.or = or;
	function mappend(op) {
		return (x, y) => x === code_1$11.nil ? y : y === code_1$11.nil ? x : (0, code_1$11._)`${par(x)} ${op} ${par(y)}`;
	}
	function par(x) {
		return x instanceof code_1$11.Name ? x : (0, code_1$11._)`(${x})`;
	}
}) });

//#endregion
//#region ../node_modules/ajv/dist/compile/util.js
var require_util = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/compile/util.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$35 = require_codegen();
	const code_1$10 = require_code$1();
	function toHash(arr) {
		const hash = {};
		for (const item of arr) hash[item] = true;
		return hash;
	}
	exports.toHash = toHash;
	function alwaysValidSchema(it, schema$1) {
		if (typeof schema$1 == "boolean") return schema$1;
		if (Object.keys(schema$1).length === 0) return true;
		checkUnknownRules(it, schema$1);
		return !schemaHasRules(schema$1, it.self.RULES.all);
	}
	exports.alwaysValidSchema = alwaysValidSchema;
	function checkUnknownRules(it, schema$1 = it.schema) {
		const { opts, self } = it;
		if (!opts.strictSchema) return;
		if (typeof schema$1 === "boolean") return;
		const rules = self.RULES.keywords;
		for (const key in schema$1) if (!rules[key]) checkStrictMode(it, `unknown keyword: "${key}"`);
	}
	exports.checkUnknownRules = checkUnknownRules;
	function schemaHasRules(schema$1, rules) {
		if (typeof schema$1 == "boolean") return !schema$1;
		for (const key in schema$1) if (rules[key]) return true;
		return false;
	}
	exports.schemaHasRules = schemaHasRules;
	function schemaHasRulesButRef(schema$1, RULES) {
		if (typeof schema$1 == "boolean") return !schema$1;
		for (const key in schema$1) if (key !== "$ref" && RULES.all[key]) return true;
		return false;
	}
	exports.schemaHasRulesButRef = schemaHasRulesButRef;
	function schemaRefOrVal({ topSchemaRef, schemaPath }, schema$1, keyword, $data) {
		if (!$data) {
			if (typeof schema$1 == "number" || typeof schema$1 == "boolean") return schema$1;
			if (typeof schema$1 == "string") return (0, codegen_1$35._)`${schema$1}`;
		}
		return (0, codegen_1$35._)`${topSchemaRef}${schemaPath}${(0, codegen_1$35.getProperty)(keyword)}`;
	}
	exports.schemaRefOrVal = schemaRefOrVal;
	function unescapeFragment(str$1) {
		return unescapeJsonPointer(decodeURIComponent(str$1));
	}
	exports.unescapeFragment = unescapeFragment;
	function escapeFragment(str$1) {
		return encodeURIComponent(escapeJsonPointer(str$1));
	}
	exports.escapeFragment = escapeFragment;
	function escapeJsonPointer(str$1) {
		if (typeof str$1 == "number") return `${str$1}`;
		return str$1.replace(/~/g, "~0").replace(/\//g, "~1");
	}
	exports.escapeJsonPointer = escapeJsonPointer;
	function unescapeJsonPointer(str$1) {
		return str$1.replace(/~1/g, "/").replace(/~0/g, "~");
	}
	exports.unescapeJsonPointer = unescapeJsonPointer;
	function eachItem(xs, f) {
		if (Array.isArray(xs)) for (const x of xs) f(x);
		else f(xs);
	}
	exports.eachItem = eachItem;
	function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName }) {
		return (gen, from, to, toName) => {
			const res = to === void 0 ? from : to instanceof codegen_1$35.Name ? (from instanceof codegen_1$35.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1$35.Name ? (mergeToName(gen, to, from), from) : mergeValues(from, to);
			return toName === codegen_1$35.Name && !(res instanceof codegen_1$35.Name) ? resultToName(gen, res) : res;
		};
	}
	exports.mergeEvaluated = {
		props: makeMergeEvaluated({
			mergeNames: (gen, from, to) => gen.if((0, codegen_1$35._)`${to} !== true && ${from} !== undefined`, () => {
				gen.if((0, codegen_1$35._)`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1$35._)`${to} || {}`).code((0, codegen_1$35._)`Object.assign(${to}, ${from})`));
			}),
			mergeToName: (gen, from, to) => gen.if((0, codegen_1$35._)`${to} !== true`, () => {
				if (from === true) gen.assign(to, true);
				else {
					gen.assign(to, (0, codegen_1$35._)`${to} || {}`);
					setEvaluated(gen, to, from);
				}
			}),
			mergeValues: (from, to) => from === true ? true : {
				...from,
				...to
			},
			resultToName: evaluatedPropsToName
		}),
		items: makeMergeEvaluated({
			mergeNames: (gen, from, to) => gen.if((0, codegen_1$35._)`${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1$35._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
			mergeToName: (gen, from, to) => gen.if((0, codegen_1$35._)`${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1$35._)`${to} > ${from} ? ${to} : ${from}`)),
			mergeValues: (from, to) => from === true ? true : Math.max(from, to),
			resultToName: (gen, items) => gen.var("items", items)
		})
	};
	function evaluatedPropsToName(gen, ps) {
		if (ps === true) return gen.var("props", true);
		const props = gen.var("props", (0, codegen_1$35._)`{}`);
		if (ps !== void 0) setEvaluated(gen, props, ps);
		return props;
	}
	exports.evaluatedPropsToName = evaluatedPropsToName;
	function setEvaluated(gen, props, ps) {
		Object.keys(ps).forEach((p) => gen.assign((0, codegen_1$35._)`${props}${(0, codegen_1$35.getProperty)(p)}`, true));
	}
	exports.setEvaluated = setEvaluated;
	const snippets = {};
	function useFunc(gen, f) {
		return gen.scopeValue("func", {
			ref: f,
			code: snippets[f.code] || (snippets[f.code] = new code_1$10._Code(f.code))
		});
	}
	exports.useFunc = useFunc;
	var Type;
	(function(Type$1) {
		Type$1[Type$1["Num"] = 0] = "Num";
		Type$1[Type$1["Str"] = 1] = "Str";
	})(Type || (exports.Type = Type = {}));
	function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
		if (dataProp instanceof codegen_1$35.Name) {
			const isNumber = dataPropType === Type.Num;
			return jsPropertySyntax ? isNumber ? (0, codegen_1$35._)`"[" + ${dataProp} + "]"` : (0, codegen_1$35._)`"['" + ${dataProp} + "']"` : isNumber ? (0, codegen_1$35._)`"/" + ${dataProp}` : (0, codegen_1$35._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
		}
		return jsPropertySyntax ? (0, codegen_1$35.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
	}
	exports.getErrorPath = getErrorPath;
	function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
		if (!mode) return;
		msg = `strict mode: ${msg}`;
		if (mode === true) throw new Error(msg);
		it.self.logger.warn(msg);
	}
	exports.checkStrictMode = checkStrictMode;
}) });

//#endregion
//#region ../node_modules/ajv/dist/compile/names.js
var require_names = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/compile/names.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$34 = require_codegen();
	const names = {
		data: new codegen_1$34.Name("data"),
		valCxt: new codegen_1$34.Name("valCxt"),
		instancePath: new codegen_1$34.Name("instancePath"),
		parentData: new codegen_1$34.Name("parentData"),
		parentDataProperty: new codegen_1$34.Name("parentDataProperty"),
		rootData: new codegen_1$34.Name("rootData"),
		dynamicAnchors: new codegen_1$34.Name("dynamicAnchors"),
		vErrors: new codegen_1$34.Name("vErrors"),
		errors: new codegen_1$34.Name("errors"),
		this: new codegen_1$34.Name("this"),
		self: new codegen_1$34.Name("self"),
		scope: new codegen_1$34.Name("scope"),
		json: new codegen_1$34.Name("json"),
		jsonPos: new codegen_1$34.Name("jsonPos"),
		jsonLen: new codegen_1$34.Name("jsonLen"),
		jsonPart: new codegen_1$34.Name("jsonPart")
	};
	exports.default = names;
}) });

//#endregion
//#region ../node_modules/ajv/dist/compile/errors.js
var require_errors = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/compile/errors.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;
	const codegen_1$33 = require_codegen();
	const util_1$29 = require_util();
	const names_1$7 = require_names();
	exports.keywordError = { message: ({ keyword }) => (0, codegen_1$33.str)`must pass "${keyword}" keyword validation` };
	exports.keyword$DataError = { message: ({ keyword, schemaType }) => schemaType ? (0, codegen_1$33.str)`"${keyword}" keyword must be ${schemaType} ($data)` : (0, codegen_1$33.str)`"${keyword}" keyword is invalid ($data)` };
	function reportError(cxt, error = exports.keywordError, errorPaths, overrideAllErrors) {
		const { it } = cxt;
		const { gen, compositeRule, allErrors } = it;
		const errObj = errorObjectCode(cxt, error, errorPaths);
		if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) addError(gen, errObj);
		else returnErrors(it, (0, codegen_1$33._)`[${errObj}]`);
	}
	exports.reportError = reportError;
	function reportExtraError(cxt, error = exports.keywordError, errorPaths) {
		const { it } = cxt;
		const { gen, compositeRule, allErrors } = it;
		addError(gen, errorObjectCode(cxt, error, errorPaths));
		if (!(compositeRule || allErrors)) returnErrors(it, names_1$7.default.vErrors);
	}
	exports.reportExtraError = reportExtraError;
	function resetErrorsCount(gen, errsCount) {
		gen.assign(names_1$7.default.errors, errsCount);
		gen.if((0, codegen_1$33._)`${names_1$7.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1$33._)`${names_1$7.default.vErrors}.length`, errsCount), () => gen.assign(names_1$7.default.vErrors, null)));
	}
	exports.resetErrorsCount = resetErrorsCount;
	function extendErrors({ gen, keyword, schemaValue, data, errsCount, it }) {
		/* istanbul ignore if */
		if (errsCount === void 0) throw new Error("ajv implementation error");
		const err = gen.name("err");
		gen.forRange("i", errsCount, names_1$7.default.errors, (i) => {
			gen.const(err, (0, codegen_1$33._)`${names_1$7.default.vErrors}[${i}]`);
			gen.if((0, codegen_1$33._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_1$33._)`${err}.instancePath`, (0, codegen_1$33.strConcat)(names_1$7.default.instancePath, it.errorPath)));
			gen.assign((0, codegen_1$33._)`${err}.schemaPath`, (0, codegen_1$33.str)`${it.errSchemaPath}/${keyword}`);
			if (it.opts.verbose) {
				gen.assign((0, codegen_1$33._)`${err}.schema`, schemaValue);
				gen.assign((0, codegen_1$33._)`${err}.data`, data);
			}
		});
	}
	exports.extendErrors = extendErrors;
	function addError(gen, errObj) {
		const err = gen.const("err", errObj);
		gen.if((0, codegen_1$33._)`${names_1$7.default.vErrors} === null`, () => gen.assign(names_1$7.default.vErrors, (0, codegen_1$33._)`[${err}]`), (0, codegen_1$33._)`${names_1$7.default.vErrors}.push(${err})`);
		gen.code((0, codegen_1$33._)`${names_1$7.default.errors}++`);
	}
	function returnErrors(it, errs) {
		const { gen, validateName, schemaEnv } = it;
		if (schemaEnv.$async) gen.throw((0, codegen_1$33._)`new ${it.ValidationError}(${errs})`);
		else {
			gen.assign((0, codegen_1$33._)`${validateName}.errors`, errs);
			gen.return(false);
		}
	}
	const E = {
		keyword: new codegen_1$33.Name("keyword"),
		schemaPath: new codegen_1$33.Name("schemaPath"),
		params: new codegen_1$33.Name("params"),
		propertyName: new codegen_1$33.Name("propertyName"),
		message: new codegen_1$33.Name("message"),
		schema: new codegen_1$33.Name("schema"),
		parentSchema: new codegen_1$33.Name("parentSchema")
	};
	function errorObjectCode(cxt, error, errorPaths) {
		const { createErrors } = cxt.it;
		if (createErrors === false) return (0, codegen_1$33._)`{}`;
		return errorObject(cxt, error, errorPaths);
	}
	function errorObject(cxt, error, errorPaths = {}) {
		const { gen, it } = cxt;
		const keyValues = [errorInstancePath(it, errorPaths), errorSchemaPath(cxt, errorPaths)];
		extraErrorProps(cxt, error, keyValues);
		return gen.object(...keyValues);
	}
	function errorInstancePath({ errorPath }, { instancePath }) {
		const instPath = instancePath ? (0, codegen_1$33.str)`${errorPath}${(0, util_1$29.getErrorPath)(instancePath, util_1$29.Type.Str)}` : errorPath;
		return [names_1$7.default.instancePath, (0, codegen_1$33.strConcat)(names_1$7.default.instancePath, instPath)];
	}
	function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
		let schPath = parentSchema ? errSchemaPath : (0, codegen_1$33.str)`${errSchemaPath}/${keyword}`;
		if (schemaPath) schPath = (0, codegen_1$33.str)`${schPath}${(0, util_1$29.getErrorPath)(schemaPath, util_1$29.Type.Str)}`;
		return [E.schemaPath, schPath];
	}
	function extraErrorProps(cxt, { params, message }, keyValues) {
		const { keyword, data, schemaValue, it } = cxt;
		const { opts, propertyName, topSchemaRef, schemaPath } = it;
		keyValues.push([E.keyword, keyword], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1$33._)`{}`]);
		if (opts.messages) keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
		if (opts.verbose) keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1$33._)`${topSchemaRef}${schemaPath}`], [names_1$7.default.data, data]);
		if (propertyName) keyValues.push([E.propertyName, propertyName]);
	}
}) });

//#endregion
//#region ../node_modules/ajv/dist/compile/validate/boolSchema.js
var require_boolSchema = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/compile/validate/boolSchema.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const errors_1$3 = require_errors();
	const codegen_1$32 = require_codegen();
	const names_1$6 = require_names();
	const boolError = { message: "boolean schema is false" };
	function topBoolOrEmptySchema(it) {
		const { gen, schema: schema$1, validateName } = it;
		if (schema$1 === false) falseSchemaError(it, false);
		else if (typeof schema$1 == "object" && schema$1.$async === true) gen.return(names_1$6.default.data);
		else {
			gen.assign((0, codegen_1$32._)`${validateName}.errors`, null);
			gen.return(true);
		}
	}
	exports.topBoolOrEmptySchema = topBoolOrEmptySchema;
	function boolOrEmptySchema(it, valid) {
		const { gen, schema: schema$1 } = it;
		if (schema$1 === false) {
			gen.var(valid, false);
			falseSchemaError(it);
		} else gen.var(valid, true);
	}
	exports.boolOrEmptySchema = boolOrEmptySchema;
	function falseSchemaError(it, overrideAllErrors) {
		const { gen, data } = it;
		const cxt = {
			gen,
			keyword: "false schema",
			data,
			schema: false,
			schemaCode: false,
			schemaValue: false,
			params: {},
			it
		};
		(0, errors_1$3.reportError)(cxt, boolError, void 0, overrideAllErrors);
	}
}) });

//#endregion
//#region ../node_modules/ajv/dist/compile/rules.js
var require_rules = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/compile/rules.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const jsonTypes = new Set([
		"string",
		"number",
		"integer",
		"boolean",
		"null",
		"object",
		"array"
	]);
	function isJSONType(x) {
		return typeof x == "string" && jsonTypes.has(x);
	}
	exports.isJSONType = isJSONType;
	function getRules() {
		const groups = {
			number: {
				type: "number",
				rules: []
			},
			string: {
				type: "string",
				rules: []
			},
			array: {
				type: "array",
				rules: []
			},
			object: {
				type: "object",
				rules: []
			}
		};
		return {
			types: {
				...groups,
				integer: true,
				boolean: true,
				null: true
			},
			rules: [
				{ rules: [] },
				groups.number,
				groups.string,
				groups.array,
				groups.object
			],
			post: { rules: [] },
			all: {},
			keywords: {}
		};
	}
	exports.getRules = getRules;
}) });

//#endregion
//#region ../node_modules/ajv/dist/compile/validate/applicability.js
var require_applicability = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/compile/validate/applicability.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	function schemaHasRulesForType({ schema: schema$1, self }, type) {
		const group = self.RULES.types[type];
		return group && group !== true && shouldUseGroup(schema$1, group);
	}
	exports.schemaHasRulesForType = schemaHasRulesForType;
	function shouldUseGroup(schema$1, group) {
		return group.rules.some((rule) => shouldUseRule(schema$1, rule));
	}
	exports.shouldUseGroup = shouldUseGroup;
	function shouldUseRule(schema$1, rule) {
		var _a$1;
		return schema$1[rule.keyword] !== void 0 || ((_a$1 = rule.definition.implements) === null || _a$1 === void 0 ? void 0 : _a$1.some((kwd) => schema$1[kwd] !== void 0));
	}
	exports.shouldUseRule = shouldUseRule;
}) });

//#endregion
//#region ../node_modules/ajv/dist/compile/validate/dataType.js
var require_dataType = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/compile/validate/dataType.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const rules_1$1 = require_rules();
	const applicability_1$1 = require_applicability();
	const errors_1$2 = require_errors();
	const codegen_1$31 = require_codegen();
	const util_1$28 = require_util();
	var DataType;
	(function(DataType$1) {
		DataType$1[DataType$1["Correct"] = 0] = "Correct";
		DataType$1[DataType$1["Wrong"] = 1] = "Wrong";
	})(DataType || (exports.DataType = DataType = {}));
	function getSchemaTypes(schema$1) {
		const types = getJSONTypes(schema$1.type);
		if (types.includes("null")) {
			if (schema$1.nullable === false) throw new Error("type: null contradicts nullable: false");
		} else {
			if (!types.length && schema$1.nullable !== void 0) throw new Error("\"nullable\" cannot be used without \"type\"");
			if (schema$1.nullable === true) types.push("null");
		}
		return types;
	}
	exports.getSchemaTypes = getSchemaTypes;
	function getJSONTypes(ts) {
		const types = Array.isArray(ts) ? ts : ts ? [ts] : [];
		if (types.every(rules_1$1.isJSONType)) return types;
		throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
	}
	exports.getJSONTypes = getJSONTypes;
	function coerceAndCheckDataType(it, types) {
		const { gen, data, opts } = it;
		const coerceTo = coerceToTypes(types, opts.coerceTypes);
		const checkTypes = types.length > 0 && !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1$1.schemaHasRulesForType)(it, types[0]));
		if (checkTypes) {
			const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);
			gen.if(wrongType, () => {
				if (coerceTo.length) coerceData(it, types, coerceTo);
				else reportTypeError(it);
			});
		}
		return checkTypes;
	}
	exports.coerceAndCheckDataType = coerceAndCheckDataType;
	const COERCIBLE = new Set([
		"string",
		"number",
		"integer",
		"boolean",
		"null"
	]);
	function coerceToTypes(types, coerceTypes) {
		return coerceTypes ? types.filter((t$1) => COERCIBLE.has(t$1) || coerceTypes === "array" && t$1 === "array") : [];
	}
	function coerceData(it, types, coerceTo) {
		const { gen, data, opts } = it;
		const dataType = gen.let("dataType", (0, codegen_1$31._)`typeof ${data}`);
		const coerced = gen.let("coerced", (0, codegen_1$31._)`undefined`);
		if (opts.coerceTypes === "array") gen.if((0, codegen_1$31._)`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1$31._)`${data}[0]`).assign(dataType, (0, codegen_1$31._)`typeof ${data}`).if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));
		gen.if((0, codegen_1$31._)`${coerced} !== undefined`);
		for (const t$1 of coerceTo) if (COERCIBLE.has(t$1) || t$1 === "array" && opts.coerceTypes === "array") coerceSpecificType(t$1);
		gen.else();
		reportTypeError(it);
		gen.endIf();
		gen.if((0, codegen_1$31._)`${coerced} !== undefined`, () => {
			gen.assign(data, coerced);
			assignParentData(it, coerced);
		});
		function coerceSpecificType(t$1) {
			switch (t$1) {
				case "string":
					gen.elseIf((0, codegen_1$31._)`${dataType} == "number" || ${dataType} == "boolean"`).assign(coerced, (0, codegen_1$31._)`"" + ${data}`).elseIf((0, codegen_1$31._)`${data} === null`).assign(coerced, (0, codegen_1$31._)`""`);
					return;
				case "number":
					gen.elseIf((0, codegen_1$31._)`${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1$31._)`+${data}`);
					return;
				case "integer":
					gen.elseIf((0, codegen_1$31._)`${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1$31._)`+${data}`);
					return;
				case "boolean":
					gen.elseIf((0, codegen_1$31._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1$31._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
					return;
				case "null":
					gen.elseIf((0, codegen_1$31._)`${data} === "" || ${data} === 0 || ${data} === false`);
					gen.assign(coerced, null);
					return;
				case "array": gen.elseIf((0, codegen_1$31._)`${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1$31._)`[${data}]`);
			}
		}
	}
	function assignParentData({ gen, parentData, parentDataProperty }, expr) {
		gen.if((0, codegen_1$31._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1$31._)`${parentData}[${parentDataProperty}]`, expr));
	}
	function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
		const EQ = correct === DataType.Correct ? codegen_1$31.operators.EQ : codegen_1$31.operators.NEQ;
		let cond;
		switch (dataType) {
			case "null": return (0, codegen_1$31._)`${data} ${EQ} null`;
			case "array":
				cond = (0, codegen_1$31._)`Array.isArray(${data})`;
				break;
			case "object":
				cond = (0, codegen_1$31._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
				break;
			case "integer":
				cond = numCond((0, codegen_1$31._)`!(${data} % 1) && !isNaN(${data})`);
				break;
			case "number":
				cond = numCond();
				break;
			default: return (0, codegen_1$31._)`typeof ${data} ${EQ} ${dataType}`;
		}
		return correct === DataType.Correct ? cond : (0, codegen_1$31.not)(cond);
		function numCond(_cond = codegen_1$31.nil) {
			return (0, codegen_1$31.and)((0, codegen_1$31._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1$31._)`isFinite(${data})` : codegen_1$31.nil);
		}
	}
	exports.checkDataType = checkDataType;
	function checkDataTypes(dataTypes, data, strictNums, correct) {
		if (dataTypes.length === 1) return checkDataType(dataTypes[0], data, strictNums, correct);
		let cond;
		const types = (0, util_1$28.toHash)(dataTypes);
		if (types.array && types.object) {
			const notObj = (0, codegen_1$31._)`typeof ${data} != "object"`;
			cond = types.null ? notObj : (0, codegen_1$31._)`!${data} || ${notObj}`;
			delete types.null;
			delete types.array;
			delete types.object;
		} else cond = codegen_1$31.nil;
		if (types.number) delete types.integer;
		for (const t$1 in types) cond = (0, codegen_1$31.and)(cond, checkDataType(t$1, data, strictNums, correct));
		return cond;
	}
	exports.checkDataTypes = checkDataTypes;
	const typeError = {
		message: ({ schema: schema$1 }) => `must be ${schema$1}`,
		params: ({ schema: schema$1, schemaValue }) => typeof schema$1 == "string" ? (0, codegen_1$31._)`{type: ${schema$1}}` : (0, codegen_1$31._)`{type: ${schemaValue}}`
	};
	function reportTypeError(it) {
		const cxt = getTypeErrorContext(it);
		(0, errors_1$2.reportError)(cxt, typeError);
	}
	exports.reportTypeError = reportTypeError;
	function getTypeErrorContext(it) {
		const { gen, data, schema: schema$1 } = it;
		const schemaCode = (0, util_1$28.schemaRefOrVal)(it, schema$1, "type");
		return {
			gen,
			keyword: "type",
			data,
			schema: schema$1.type,
			schemaCode,
			schemaValue: schemaCode,
			parentSchema: schema$1,
			params: {},
			it
		};
	}
}) });

//#endregion
//#region ../node_modules/ajv/dist/compile/validate/defaults.js
var require_defaults = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/compile/validate/defaults.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$30 = require_codegen();
	const util_1$27 = require_util();
	function assignDefaults(it, ty) {
		const { properties, items } = it.schema;
		if (ty === "object" && properties) for (const key in properties) assignDefault(it, key, properties[key].default);
		else if (ty === "array" && Array.isArray(items)) items.forEach((sch, i) => assignDefault(it, i, sch.default));
	}
	exports.assignDefaults = assignDefaults;
	function assignDefault(it, prop, defaultValue) {
		const { gen, compositeRule, data, opts } = it;
		if (defaultValue === void 0) return;
		const childData = (0, codegen_1$30._)`${data}${(0, codegen_1$30.getProperty)(prop)}`;
		if (compositeRule) {
			(0, util_1$27.checkStrictMode)(it, `default is ignored for: ${childData}`);
			return;
		}
		let condition = (0, codegen_1$30._)`${childData} === undefined`;
		if (opts.useDefaults === "empty") condition = (0, codegen_1$30._)`${condition} || ${childData} === null || ${childData} === ""`;
		gen.if(condition, (0, codegen_1$30._)`${childData} = ${(0, codegen_1$30.stringify)(defaultValue)}`);
	}
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/code.js
var require_code = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/code.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$29 = require_codegen();
	const util_1$26 = require_util();
	const names_1$5 = require_names();
	const util_2$1 = require_util();
	function checkReportMissingProp(cxt, prop) {
		const { gen, data, it } = cxt;
		gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
			cxt.setParams({ missingProperty: (0, codegen_1$29._)`${prop}` }, true);
			cxt.error();
		});
	}
	exports.checkReportMissingProp = checkReportMissingProp;
	function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
		return (0, codegen_1$29.or)(...properties.map((prop) => (0, codegen_1$29.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1$29._)`${missing} = ${prop}`)));
	}
	exports.checkMissingProp = checkMissingProp;
	function reportMissingProp(cxt, missing) {
		cxt.setParams({ missingProperty: missing }, true);
		cxt.error();
	}
	exports.reportMissingProp = reportMissingProp;
	function hasPropFunc(gen) {
		return gen.scopeValue("func", {
			ref: Object.prototype.hasOwnProperty,
			code: (0, codegen_1$29._)`Object.prototype.hasOwnProperty`
		});
	}
	exports.hasPropFunc = hasPropFunc;
	function isOwnProperty(gen, data, property) {
		return (0, codegen_1$29._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
	}
	exports.isOwnProperty = isOwnProperty;
	function propertyInData(gen, data, property, ownProperties) {
		const cond = (0, codegen_1$29._)`${data}${(0, codegen_1$29.getProperty)(property)} !== undefined`;
		return ownProperties ? (0, codegen_1$29._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
	}
	exports.propertyInData = propertyInData;
	function noPropertyInData(gen, data, property, ownProperties) {
		const cond = (0, codegen_1$29._)`${data}${(0, codegen_1$29.getProperty)(property)} === undefined`;
		return ownProperties ? (0, codegen_1$29.or)(cond, (0, codegen_1$29.not)(isOwnProperty(gen, data, property))) : cond;
	}
	exports.noPropertyInData = noPropertyInData;
	function allSchemaProperties(schemaMap) {
		return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
	}
	exports.allSchemaProperties = allSchemaProperties;
	function schemaProperties(it, schemaMap) {
		return allSchemaProperties(schemaMap).filter((p) => !(0, util_1$26.alwaysValidSchema)(it, schemaMap[p]));
	}
	exports.schemaProperties = schemaProperties;
	function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
		const dataAndSchema = passSchema ? (0, codegen_1$29._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
		const valCxt = [
			[names_1$5.default.instancePath, (0, codegen_1$29.strConcat)(names_1$5.default.instancePath, errorPath)],
			[names_1$5.default.parentData, it.parentData],
			[names_1$5.default.parentDataProperty, it.parentDataProperty],
			[names_1$5.default.rootData, names_1$5.default.rootData]
		];
		if (it.opts.dynamicRef) valCxt.push([names_1$5.default.dynamicAnchors, names_1$5.default.dynamicAnchors]);
		const args = (0, codegen_1$29._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
		return context !== codegen_1$29.nil ? (0, codegen_1$29._)`${func}.call(${context}, ${args})` : (0, codegen_1$29._)`${func}(${args})`;
	}
	exports.callValidateCode = callValidateCode;
	const newRegExp = (0, codegen_1$29._)`new RegExp`;
	function usePattern({ gen, it: { opts } }, pattern) {
		const u = opts.unicodeRegExp ? "u" : "";
		const { regExp } = opts.code;
		const rx = regExp(pattern, u);
		return gen.scopeValue("pattern", {
			key: rx.toString(),
			ref: rx,
			code: (0, codegen_1$29._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2$1.useFunc)(gen, regExp)}(${pattern}, ${u})`
		});
	}
	exports.usePattern = usePattern;
	function validateArray(cxt) {
		const { gen, data, keyword, it } = cxt;
		const valid = gen.name("valid");
		if (it.allErrors) {
			const validArr = gen.let("valid", true);
			validateItems(() => gen.assign(validArr, false));
			return validArr;
		}
		gen.var(valid, true);
		validateItems(() => gen.break());
		return valid;
		function validateItems(notValid) {
			const len = gen.const("len", (0, codegen_1$29._)`${data}.length`);
			gen.forRange("i", 0, len, (i) => {
				cxt.subschema({
					keyword,
					dataProp: i,
					dataPropType: util_1$26.Type.Num
				}, valid);
				gen.if((0, codegen_1$29.not)(valid), notValid);
			});
		}
	}
	exports.validateArray = validateArray;
	function validateUnion(cxt) {
		const { gen, schema: schema$1, keyword, it } = cxt;
		/* istanbul ignore if */
		if (!Array.isArray(schema$1)) throw new Error("ajv implementation error");
		if (schema$1.some((sch) => (0, util_1$26.alwaysValidSchema)(it, sch)) && !it.opts.unevaluated) return;
		const valid = gen.let("valid", false);
		const schValid = gen.name("_valid");
		gen.block(() => schema$1.forEach((_sch, i) => {
			const schCxt = cxt.subschema({
				keyword,
				schemaProp: i,
				compositeRule: true
			}, schValid);
			gen.assign(valid, (0, codegen_1$29._)`${valid} || ${schValid}`);
			if (!cxt.mergeValidEvaluated(schCxt, schValid)) gen.if((0, codegen_1$29.not)(valid));
		}));
		cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
	}
	exports.validateUnion = validateUnion;
}) });

//#endregion
//#region ../node_modules/ajv/dist/compile/validate/keyword.js
var require_keyword = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/compile/validate/keyword.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$28 = require_codegen();
	const names_1$4 = require_names();
	const code_1$9 = require_code();
	const errors_1$1 = require_errors();
	function macroKeywordCode(cxt, def$30) {
		const { gen, keyword, schema: schema$1, parentSchema, it } = cxt;
		const macroSchema = def$30.macro.call(it.self, schema$1, parentSchema, it);
		const schemaRef = useKeyword(gen, keyword, macroSchema);
		if (it.opts.validateSchema !== false) it.self.validateSchema(macroSchema, true);
		const valid = gen.name("valid");
		cxt.subschema({
			schema: macroSchema,
			schemaPath: codegen_1$28.nil,
			errSchemaPath: `${it.errSchemaPath}/${keyword}`,
			topSchemaRef: schemaRef,
			compositeRule: true
		}, valid);
		cxt.pass(valid, () => cxt.error(true));
	}
	exports.macroKeywordCode = macroKeywordCode;
	function funcKeywordCode(cxt, def$30) {
		var _a$1;
		const { gen, keyword, schema: schema$1, parentSchema, $data, it } = cxt;
		checkAsyncKeyword(it, def$30);
		const validateRef = useKeyword(gen, keyword, !$data && def$30.compile ? def$30.compile.call(it.self, schema$1, parentSchema, it) : def$30.validate);
		const valid = gen.let("valid");
		cxt.block$data(valid, validateKeyword);
		cxt.ok((_a$1 = def$30.valid) !== null && _a$1 !== void 0 ? _a$1 : valid);
		function validateKeyword() {
			if (def$30.errors === false) {
				assignValid();
				if (def$30.modifying) modifyData(cxt);
				reportErrs(() => cxt.error());
			} else {
				const ruleErrs = def$30.async ? validateAsync() : validateSync();
				if (def$30.modifying) modifyData(cxt);
				reportErrs(() => addErrs(cxt, ruleErrs));
			}
		}
		function validateAsync() {
			const ruleErrs = gen.let("ruleErrs", null);
			gen.try(() => assignValid((0, codegen_1$28._)`await `), (e) => gen.assign(valid, false).if((0, codegen_1$28._)`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1$28._)`${e}.errors`), () => gen.throw(e)));
			return ruleErrs;
		}
		function validateSync() {
			const validateErrs = (0, codegen_1$28._)`${validateRef}.errors`;
			gen.assign(validateErrs, null);
			assignValid(codegen_1$28.nil);
			return validateErrs;
		}
		function assignValid(_await = def$30.async ? (0, codegen_1$28._)`await ` : codegen_1$28.nil) {
			const passCxt = it.opts.passContext ? names_1$4.default.this : names_1$4.default.self;
			const passSchema = !("compile" in def$30 && !$data || def$30.schema === false);
			gen.assign(valid, (0, codegen_1$28._)`${_await}${(0, code_1$9.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def$30.modifying);
		}
		function reportErrs(errors$1) {
			var _a$2;
			gen.if((0, codegen_1$28.not)((_a$2 = def$30.valid) !== null && _a$2 !== void 0 ? _a$2 : valid), errors$1);
		}
	}
	exports.funcKeywordCode = funcKeywordCode;
	function modifyData(cxt) {
		const { gen, data, it } = cxt;
		gen.if(it.parentData, () => gen.assign(data, (0, codegen_1$28._)`${it.parentData}[${it.parentDataProperty}]`));
	}
	function addErrs(cxt, errs) {
		const { gen } = cxt;
		gen.if((0, codegen_1$28._)`Array.isArray(${errs})`, () => {
			gen.assign(names_1$4.default.vErrors, (0, codegen_1$28._)`${names_1$4.default.vErrors} === null ? ${errs} : ${names_1$4.default.vErrors}.concat(${errs})`).assign(names_1$4.default.errors, (0, codegen_1$28._)`${names_1$4.default.vErrors}.length`);
			(0, errors_1$1.extendErrors)(cxt);
		}, () => cxt.error());
	}
	function checkAsyncKeyword({ schemaEnv }, def$30) {
		if (def$30.async && !schemaEnv.$async) throw new Error("async keyword in sync schema");
	}
	function useKeyword(gen, keyword, result) {
		if (result === void 0) throw new Error(`keyword "${keyword}" failed to compile`);
		return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : {
			ref: result,
			code: (0, codegen_1$28.stringify)(result)
		});
	}
	function validSchemaType(schema$1, schemaType, allowUndefined = false) {
		return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema$1) : st === "object" ? schema$1 && typeof schema$1 == "object" && !Array.isArray(schema$1) : typeof schema$1 == st || allowUndefined && typeof schema$1 == "undefined");
	}
	exports.validSchemaType = validSchemaType;
	function validateKeywordUsage({ schema: schema$1, opts, self, errSchemaPath }, def$30, keyword) {
		/* istanbul ignore if */
		if (Array.isArray(def$30.keyword) ? !def$30.keyword.includes(keyword) : def$30.keyword !== keyword) throw new Error("ajv implementation error");
		const deps = def$30.dependencies;
		if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema$1, kwd))) throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
		if (def$30.validateSchema) {
			if (!def$30.validateSchema(schema$1[keyword])) {
				const msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` + self.errorsText(def$30.validateSchema.errors);
				if (opts.validateSchema === "log") self.logger.error(msg);
				else throw new Error(msg);
			}
		}
	}
	exports.validateKeywordUsage = validateKeywordUsage;
}) });

//#endregion
//#region ../node_modules/ajv/dist/compile/validate/subschema.js
var require_subschema = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/compile/validate/subschema.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$27 = require_codegen();
	const util_1$25 = require_util();
	function getSubschema(it, { keyword, schemaProp, schema: schema$1, schemaPath, errSchemaPath, topSchemaRef }) {
		if (keyword !== void 0 && schema$1 !== void 0) throw new Error("both \"keyword\" and \"schema\" passed, only one allowed");
		if (keyword !== void 0) {
			const sch = it.schema[keyword];
			return schemaProp === void 0 ? {
				schema: sch,
				schemaPath: (0, codegen_1$27._)`${it.schemaPath}${(0, codegen_1$27.getProperty)(keyword)}`,
				errSchemaPath: `${it.errSchemaPath}/${keyword}`
			} : {
				schema: sch[schemaProp],
				schemaPath: (0, codegen_1$27._)`${it.schemaPath}${(0, codegen_1$27.getProperty)(keyword)}${(0, codegen_1$27.getProperty)(schemaProp)}`,
				errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1$25.escapeFragment)(schemaProp)}`
			};
		}
		if (schema$1 !== void 0) {
			if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) throw new Error("\"schemaPath\", \"errSchemaPath\" and \"topSchemaRef\" are required with \"schema\"");
			return {
				schema: schema$1,
				schemaPath,
				topSchemaRef,
				errSchemaPath
			};
		}
		throw new Error("either \"keyword\" or \"schema\" must be passed");
	}
	exports.getSubschema = getSubschema;
	function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
		if (data !== void 0 && dataProp !== void 0) throw new Error("both \"data\" and \"dataProp\" passed, only one allowed");
		const { gen } = it;
		if (dataProp !== void 0) {
			const { errorPath, dataPathArr, opts } = it;
			dataContextProps(gen.let("data", (0, codegen_1$27._)`${it.data}${(0, codegen_1$27.getProperty)(dataProp)}`, true));
			subschema.errorPath = (0, codegen_1$27.str)`${errorPath}${(0, util_1$25.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
			subschema.parentDataProperty = (0, codegen_1$27._)`${dataProp}`;
			subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
		}
		if (data !== void 0) {
			dataContextProps(data instanceof codegen_1$27.Name ? data : gen.let("data", data, true));
			if (propertyName !== void 0) subschema.propertyName = propertyName;
		}
		if (dataTypes) subschema.dataTypes = dataTypes;
		function dataContextProps(_nextData) {
			subschema.data = _nextData;
			subschema.dataLevel = it.dataLevel + 1;
			subschema.dataTypes = [];
			it.definedProperties = /* @__PURE__ */ new Set();
			subschema.parentData = it.data;
			subschema.dataNames = [...it.dataNames, _nextData];
		}
	}
	exports.extendSubschemaData = extendSubschemaData;
	function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
		if (compositeRule !== void 0) subschema.compositeRule = compositeRule;
		if (createErrors !== void 0) subschema.createErrors = createErrors;
		if (allErrors !== void 0) subschema.allErrors = allErrors;
		subschema.jtdDiscriminator = jtdDiscriminator;
		subschema.jtdMetadata = jtdMetadata;
	}
	exports.extendSubschemaMode = extendSubschemaMode;
}) });

//#endregion
//#region ../node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = /* @__PURE__ */ __commonJS$2({ "../node_modules/fast-deep-equal/index.js": ((exports, module) => {
	module.exports = function equal$3(a, b) {
		if (a === b) return true;
		if (a && b && typeof a == "object" && typeof b == "object") {
			if (a.constructor !== b.constructor) return false;
			var length, i, keys;
			if (Array.isArray(a)) {
				length = a.length;
				if (length != b.length) return false;
				for (i = length; i-- !== 0;) if (!equal$3(a[i], b[i])) return false;
				return true;
			}
			if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
			if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
			if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
			keys = Object.keys(a);
			length = keys.length;
			if (length !== Object.keys(b).length) return false;
			for (i = length; i-- !== 0;) if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
			for (i = length; i-- !== 0;) {
				var key = keys[i];
				if (!equal$3(a[key], b[key])) return false;
			}
			return true;
		}
		return a !== a && b !== b;
	};
}) });

//#endregion
//#region ../node_modules/json-schema-traverse/index.js
var require_json_schema_traverse = /* @__PURE__ */ __commonJS$2({ "../node_modules/json-schema-traverse/index.js": ((exports, module) => {
	var traverse$1 = module.exports = function(schema$1, opts, cb) {
		if (typeof opts == "function") {
			cb = opts;
			opts = {};
		}
		cb = opts.cb || cb;
		var pre = typeof cb == "function" ? cb : cb.pre || function() {};
		var post = cb.post || function() {};
		_traverse(opts, pre, post, schema$1, "", schema$1);
	};
	traverse$1.keywords = {
		additionalItems: true,
		items: true,
		contains: true,
		additionalProperties: true,
		propertyNames: true,
		not: true,
		if: true,
		then: true,
		else: true
	};
	traverse$1.arrayKeywords = {
		items: true,
		allOf: true,
		anyOf: true,
		oneOf: true
	};
	traverse$1.propsKeywords = {
		$defs: true,
		definitions: true,
		properties: true,
		patternProperties: true,
		dependencies: true
	};
	traverse$1.skipKeywords = {
		default: true,
		enum: true,
		const: true,
		required: true,
		maximum: true,
		minimum: true,
		exclusiveMaximum: true,
		exclusiveMinimum: true,
		multipleOf: true,
		maxLength: true,
		minLength: true,
		pattern: true,
		format: true,
		maxItems: true,
		minItems: true,
		uniqueItems: true,
		maxProperties: true,
		minProperties: true
	};
	function _traverse(opts, pre, post, schema$1, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
		if (schema$1 && typeof schema$1 == "object" && !Array.isArray(schema$1)) {
			pre(schema$1, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
			for (var key in schema$1) {
				var sch = schema$1[key];
				if (Array.isArray(sch)) {
					if (key in traverse$1.arrayKeywords) for (var i = 0; i < sch.length; i++) _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema$1, i);
				} else if (key in traverse$1.propsKeywords) {
					if (sch && typeof sch == "object") for (var prop in sch) _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema$1, prop);
				} else if (key in traverse$1.keywords || opts.allKeys && !(key in traverse$1.skipKeywords)) _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema$1);
			}
			post(schema$1, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
		}
	}
	function escapeJsonPtr(str$1) {
		return str$1.replace(/~/g, "~0").replace(/\//g, "~1");
	}
}) });

//#endregion
//#region ../node_modules/ajv/dist/compile/resolve.js
var require_resolve = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/compile/resolve.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const util_1$24 = require_util();
	const equal$2 = require_fast_deep_equal();
	const traverse = require_json_schema_traverse();
	const SIMPLE_INLINED = new Set([
		"type",
		"format",
		"pattern",
		"maxLength",
		"minLength",
		"maxProperties",
		"minProperties",
		"maxItems",
		"minItems",
		"maximum",
		"minimum",
		"uniqueItems",
		"multipleOf",
		"required",
		"enum",
		"const"
	]);
	function inlineRef(schema$1, limit = true) {
		if (typeof schema$1 == "boolean") return true;
		if (limit === true) return !hasRef(schema$1);
		if (!limit) return false;
		return countKeys(schema$1) <= limit;
	}
	exports.inlineRef = inlineRef;
	const REF_KEYWORDS = new Set([
		"$ref",
		"$recursiveRef",
		"$recursiveAnchor",
		"$dynamicRef",
		"$dynamicAnchor"
	]);
	function hasRef(schema$1) {
		for (const key in schema$1) {
			if (REF_KEYWORDS.has(key)) return true;
			const sch = schema$1[key];
			if (Array.isArray(sch) && sch.some(hasRef)) return true;
			if (typeof sch == "object" && hasRef(sch)) return true;
		}
		return false;
	}
	function countKeys(schema$1) {
		let count = 0;
		for (const key in schema$1) {
			if (key === "$ref") return Infinity;
			count++;
			if (SIMPLE_INLINED.has(key)) continue;
			if (typeof schema$1[key] == "object") (0, util_1$24.eachItem)(schema$1[key], (sch) => count += countKeys(sch));
			if (count === Infinity) return Infinity;
		}
		return count;
	}
	function getFullPath(resolver, id = "", normalize$1) {
		if (normalize$1 !== false) id = normalizeId(id);
		return _getFullPath(resolver, resolver.parse(id));
	}
	exports.getFullPath = getFullPath;
	function _getFullPath(resolver, p) {
		return resolver.serialize(p).split("#")[0] + "#";
	}
	exports._getFullPath = _getFullPath;
	const TRAILING_SLASH_HASH = /#\/?$/;
	function normalizeId(id) {
		return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
	}
	exports.normalizeId = normalizeId;
	function resolveUrl(resolver, baseId, id) {
		id = normalizeId(id);
		return resolver.resolve(baseId, id);
	}
	exports.resolveUrl = resolveUrl;
	const ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
	function getSchemaRefs(schema$1, baseId) {
		if (typeof schema$1 == "boolean") return {};
		const { schemaId, uriResolver } = this.opts;
		const schId = normalizeId(schema$1[schemaId] || baseId);
		const baseIds = { "": schId };
		const pathPrefix = getFullPath(uriResolver, schId, false);
		const localRefs = {};
		const schemaRefs = /* @__PURE__ */ new Set();
		traverse(schema$1, { allKeys: true }, (sch, jsonPtr, _$1, parentJsonPtr) => {
			if (parentJsonPtr === void 0) return;
			const fullPath = pathPrefix + jsonPtr;
			let innerBaseId = baseIds[parentJsonPtr];
			if (typeof sch[schemaId] == "string") innerBaseId = addRef.call(this, sch[schemaId]);
			addAnchor.call(this, sch.$anchor);
			addAnchor.call(this, sch.$dynamicAnchor);
			baseIds[jsonPtr] = innerBaseId;
			function addRef(ref) {
				const _resolve = this.opts.uriResolver.resolve;
				ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref);
				if (schemaRefs.has(ref)) throw ambiguos(ref);
				schemaRefs.add(ref);
				let schOrRef = this.refs[ref];
				if (typeof schOrRef == "string") schOrRef = this.refs[schOrRef];
				if (typeof schOrRef == "object") checkAmbiguosRef(sch, schOrRef.schema, ref);
				else if (ref !== normalizeId(fullPath)) if (ref[0] === "#") {
					checkAmbiguosRef(sch, localRefs[ref], ref);
					localRefs[ref] = sch;
				} else this.refs[ref] = fullPath;
				return ref;
			}
			function addAnchor(anchor) {
				if (typeof anchor == "string") {
					if (!ANCHOR.test(anchor)) throw new Error(`invalid anchor "${anchor}"`);
					addRef.call(this, `#${anchor}`);
				}
			}
		});
		return localRefs;
		function checkAmbiguosRef(sch1, sch2, ref) {
			if (sch2 !== void 0 && !equal$2(sch1, sch2)) throw ambiguos(ref);
		}
		function ambiguos(ref) {
			return /* @__PURE__ */ new Error(`reference "${ref}" resolves to more than one schema`);
		}
	}
	exports.getSchemaRefs = getSchemaRefs;
}) });

//#endregion
//#region ../node_modules/ajv/dist/compile/validate/index.js
var require_validate = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/compile/validate/index.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const boolSchema_1 = require_boolSchema();
	const dataType_1$2 = require_dataType();
	const applicability_1 = require_applicability();
	const dataType_2 = require_dataType();
	const defaults_1 = require_defaults();
	const keyword_1 = require_keyword();
	const subschema_1 = require_subschema();
	const codegen_1$26 = require_codegen();
	const names_1$3 = require_names();
	const resolve_1$3 = require_resolve();
	const util_1$23 = require_util();
	const errors_1 = require_errors();
	function validateFunctionCode(it) {
		if (isSchemaObj(it)) {
			checkKeywords(it);
			if (schemaCxtHasRules(it)) {
				topSchemaObjCode(it);
				return;
			}
		}
		validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
	}
	exports.validateFunctionCode = validateFunctionCode;
	function validateFunction({ gen, validateName, schema: schema$1, schemaEnv, opts }, body) {
		if (opts.code.es5) gen.func(validateName, (0, codegen_1$26._)`${names_1$3.default.data}, ${names_1$3.default.valCxt}`, schemaEnv.$async, () => {
			gen.code((0, codegen_1$26._)`"use strict"; ${funcSourceUrl(schema$1, opts)}`);
			destructureValCxtES5(gen, opts);
			gen.code(body);
		});
		else gen.func(validateName, (0, codegen_1$26._)`${names_1$3.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema$1, opts)).code(body));
	}
	function destructureValCxt(opts) {
		return (0, codegen_1$26._)`{${names_1$3.default.instancePath}="", ${names_1$3.default.parentData}, ${names_1$3.default.parentDataProperty}, ${names_1$3.default.rootData}=${names_1$3.default.data}${opts.dynamicRef ? (0, codegen_1$26._)`, ${names_1$3.default.dynamicAnchors}={}` : codegen_1$26.nil}}={}`;
	}
	function destructureValCxtES5(gen, opts) {
		gen.if(names_1$3.default.valCxt, () => {
			gen.var(names_1$3.default.instancePath, (0, codegen_1$26._)`${names_1$3.default.valCxt}.${names_1$3.default.instancePath}`);
			gen.var(names_1$3.default.parentData, (0, codegen_1$26._)`${names_1$3.default.valCxt}.${names_1$3.default.parentData}`);
			gen.var(names_1$3.default.parentDataProperty, (0, codegen_1$26._)`${names_1$3.default.valCxt}.${names_1$3.default.parentDataProperty}`);
			gen.var(names_1$3.default.rootData, (0, codegen_1$26._)`${names_1$3.default.valCxt}.${names_1$3.default.rootData}`);
			if (opts.dynamicRef) gen.var(names_1$3.default.dynamicAnchors, (0, codegen_1$26._)`${names_1$3.default.valCxt}.${names_1$3.default.dynamicAnchors}`);
		}, () => {
			gen.var(names_1$3.default.instancePath, (0, codegen_1$26._)`""`);
			gen.var(names_1$3.default.parentData, (0, codegen_1$26._)`undefined`);
			gen.var(names_1$3.default.parentDataProperty, (0, codegen_1$26._)`undefined`);
			gen.var(names_1$3.default.rootData, names_1$3.default.data);
			if (opts.dynamicRef) gen.var(names_1$3.default.dynamicAnchors, (0, codegen_1$26._)`{}`);
		});
	}
	function topSchemaObjCode(it) {
		const { schema: schema$1, opts, gen } = it;
		validateFunction(it, () => {
			if (opts.$comment && schema$1.$comment) commentKeyword(it);
			checkNoDefault(it);
			gen.let(names_1$3.default.vErrors, null);
			gen.let(names_1$3.default.errors, 0);
			if (opts.unevaluated) resetEvaluated(it);
			typeAndKeywords(it);
			returnResults(it);
		});
	}
	function resetEvaluated(it) {
		const { gen, validateName } = it;
		it.evaluated = gen.const("evaluated", (0, codegen_1$26._)`${validateName}.evaluated`);
		gen.if((0, codegen_1$26._)`${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1$26._)`${it.evaluated}.props`, (0, codegen_1$26._)`undefined`));
		gen.if((0, codegen_1$26._)`${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1$26._)`${it.evaluated}.items`, (0, codegen_1$26._)`undefined`));
	}
	function funcSourceUrl(schema$1, opts) {
		const schId = typeof schema$1 == "object" && schema$1[opts.schemaId];
		return schId && (opts.code.source || opts.code.process) ? (0, codegen_1$26._)`/*# sourceURL=${schId} */` : codegen_1$26.nil;
	}
	function subschemaCode(it, valid) {
		if (isSchemaObj(it)) {
			checkKeywords(it);
			if (schemaCxtHasRules(it)) {
				subSchemaObjCode(it, valid);
				return;
			}
		}
		(0, boolSchema_1.boolOrEmptySchema)(it, valid);
	}
	function schemaCxtHasRules({ schema: schema$1, self }) {
		if (typeof schema$1 == "boolean") return !schema$1;
		for (const key in schema$1) if (self.RULES.all[key]) return true;
		return false;
	}
	function isSchemaObj(it) {
		return typeof it.schema != "boolean";
	}
	function subSchemaObjCode(it, valid) {
		const { schema: schema$1, gen, opts } = it;
		if (opts.$comment && schema$1.$comment) commentKeyword(it);
		updateContext(it);
		checkAsyncSchema(it);
		const errsCount = gen.const("_errs", names_1$3.default.errors);
		typeAndKeywords(it, errsCount);
		gen.var(valid, (0, codegen_1$26._)`${errsCount} === ${names_1$3.default.errors}`);
	}
	function checkKeywords(it) {
		(0, util_1$23.checkUnknownRules)(it);
		checkRefsAndKeywords(it);
	}
	function typeAndKeywords(it, errsCount) {
		if (it.opts.jtd) return schemaKeywords(it, [], false, errsCount);
		const types = (0, dataType_1$2.getSchemaTypes)(it.schema);
		schemaKeywords(it, types, !(0, dataType_1$2.coerceAndCheckDataType)(it, types), errsCount);
	}
	function checkRefsAndKeywords(it) {
		const { schema: schema$1, errSchemaPath, opts, self } = it;
		if (schema$1.$ref && opts.ignoreKeywordsWithRef && (0, util_1$23.schemaHasRulesButRef)(schema$1, self.RULES)) self.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
	}
	function checkNoDefault(it) {
		const { schema: schema$1, opts } = it;
		if (schema$1.default !== void 0 && opts.useDefaults && opts.strictSchema) (0, util_1$23.checkStrictMode)(it, "default is ignored in the schema root");
	}
	function updateContext(it) {
		const schId = it.schema[it.opts.schemaId];
		if (schId) it.baseId = (0, resolve_1$3.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
	}
	function checkAsyncSchema(it) {
		if (it.schema.$async && !it.schemaEnv.$async) throw new Error("async schema in sync schema");
	}
	function commentKeyword({ gen, schemaEnv, schema: schema$1, errSchemaPath, opts }) {
		const msg = schema$1.$comment;
		if (opts.$comment === true) gen.code((0, codegen_1$26._)`${names_1$3.default.self}.logger.log(${msg})`);
		else if (typeof opts.$comment == "function") {
			const schemaPath = (0, codegen_1$26.str)`${errSchemaPath}/$comment`;
			const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
			gen.code((0, codegen_1$26._)`${names_1$3.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
		}
	}
	function returnResults(it) {
		const { gen, schemaEnv, validateName, ValidationError: ValidationError$1, opts } = it;
		if (schemaEnv.$async) gen.if((0, codegen_1$26._)`${names_1$3.default.errors} === 0`, () => gen.return(names_1$3.default.data), () => gen.throw((0, codegen_1$26._)`new ${ValidationError$1}(${names_1$3.default.vErrors})`));
		else {
			gen.assign((0, codegen_1$26._)`${validateName}.errors`, names_1$3.default.vErrors);
			if (opts.unevaluated) assignEvaluated(it);
			gen.return((0, codegen_1$26._)`${names_1$3.default.errors} === 0`);
		}
	}
	function assignEvaluated({ gen, evaluated, props, items }) {
		if (props instanceof codegen_1$26.Name) gen.assign((0, codegen_1$26._)`${evaluated}.props`, props);
		if (items instanceof codegen_1$26.Name) gen.assign((0, codegen_1$26._)`${evaluated}.items`, items);
	}
	function schemaKeywords(it, types, typeErrors, errsCount) {
		const { gen, schema: schema$1, data, allErrors, opts, self } = it;
		const { RULES } = self;
		if (schema$1.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1$23.schemaHasRulesButRef)(schema$1, RULES))) {
			gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
			return;
		}
		if (!opts.jtd) checkStrictTypes(it, types);
		gen.block(() => {
			for (const group of RULES.rules) groupKeywords(group);
			groupKeywords(RULES.post);
		});
		function groupKeywords(group) {
			if (!(0, applicability_1.shouldUseGroup)(schema$1, group)) return;
			if (group.type) {
				gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
				iterateKeywords(it, group);
				if (types.length === 1 && types[0] === group.type && typeErrors) {
					gen.else();
					(0, dataType_2.reportTypeError)(it);
				}
				gen.endIf();
			} else iterateKeywords(it, group);
			if (!allErrors) gen.if((0, codegen_1$26._)`${names_1$3.default.errors} === ${errsCount || 0}`);
		}
	}
	function iterateKeywords(it, group) {
		const { gen, schema: schema$1, opts: { useDefaults } } = it;
		if (useDefaults) (0, defaults_1.assignDefaults)(it, group.type);
		gen.block(() => {
			for (const rule of group.rules) if ((0, applicability_1.shouldUseRule)(schema$1, rule)) keywordCode(it, rule.keyword, rule.definition, group.type);
		});
	}
	function checkStrictTypes(it, types) {
		if (it.schemaEnv.meta || !it.opts.strictTypes) return;
		checkContextTypes(it, types);
		if (!it.opts.allowUnionTypes) checkMultipleTypes(it, types);
		checkKeywordTypes(it, it.dataTypes);
	}
	function checkContextTypes(it, types) {
		if (!types.length) return;
		if (!it.dataTypes.length) {
			it.dataTypes = types;
			return;
		}
		types.forEach((t$1) => {
			if (!includesType(it.dataTypes, t$1)) strictTypesError(it, `type "${t$1}" not allowed by context "${it.dataTypes.join(",")}"`);
		});
		narrowSchemaTypes(it, types);
	}
	function checkMultipleTypes(it, ts) {
		if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) strictTypesError(it, "use allowUnionTypes to allow union type keyword");
	}
	function checkKeywordTypes(it, ts) {
		const rules = it.self.RULES.all;
		for (const keyword in rules) {
			const rule = rules[keyword];
			if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
				const { type } = rule.definition;
				if (type.length && !type.some((t$1) => hasApplicableType(ts, t$1))) strictTypesError(it, `missing type "${type.join(",")}" for keyword "${keyword}"`);
			}
		}
	}
	function hasApplicableType(schTs, kwdT) {
		return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
	}
	function includesType(ts, t$1) {
		return ts.includes(t$1) || t$1 === "integer" && ts.includes("number");
	}
	function narrowSchemaTypes(it, withTypes) {
		const ts = [];
		for (const t$1 of it.dataTypes) if (includesType(withTypes, t$1)) ts.push(t$1);
		else if (withTypes.includes("integer") && t$1 === "number") ts.push("integer");
		it.dataTypes = ts;
	}
	function strictTypesError(it, msg) {
		const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
		msg += ` at "${schemaPath}" (strictTypes)`;
		(0, util_1$23.checkStrictMode)(it, msg, it.opts.strictTypes);
	}
	var KeywordCxt = class {
		constructor(it, def$30, keyword) {
			(0, keyword_1.validateKeywordUsage)(it, def$30, keyword);
			this.gen = it.gen;
			this.allErrors = it.allErrors;
			this.keyword = keyword;
			this.data = it.data;
			this.schema = it.schema[keyword];
			this.$data = def$30.$data && it.opts.$data && this.schema && this.schema.$data;
			this.schemaValue = (0, util_1$23.schemaRefOrVal)(it, this.schema, keyword, this.$data);
			this.schemaType = def$30.schemaType;
			this.parentSchema = it.schema;
			this.params = {};
			this.it = it;
			this.def = def$30;
			if (this.$data) this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
			else {
				this.schemaCode = this.schemaValue;
				if (!(0, keyword_1.validSchemaType)(this.schema, def$30.schemaType, def$30.allowUndefined)) throw new Error(`${keyword} value must be ${JSON.stringify(def$30.schemaType)}`);
			}
			if ("code" in def$30 ? def$30.trackErrors : def$30.errors !== false) this.errsCount = it.gen.const("_errs", names_1$3.default.errors);
		}
		result(condition, successAction, failAction) {
			this.failResult((0, codegen_1$26.not)(condition), successAction, failAction);
		}
		failResult(condition, successAction, failAction) {
			this.gen.if(condition);
			if (failAction) failAction();
			else this.error();
			if (successAction) {
				this.gen.else();
				successAction();
				if (this.allErrors) this.gen.endIf();
			} else if (this.allErrors) this.gen.endIf();
			else this.gen.else();
		}
		pass(condition, failAction) {
			this.failResult((0, codegen_1$26.not)(condition), void 0, failAction);
		}
		fail(condition) {
			if (condition === void 0) {
				this.error();
				if (!this.allErrors) this.gen.if(false);
				return;
			}
			this.gen.if(condition);
			this.error();
			if (this.allErrors) this.gen.endIf();
			else this.gen.else();
		}
		fail$data(condition) {
			if (!this.$data) return this.fail(condition);
			const { schemaCode } = this;
			this.fail((0, codegen_1$26._)`${schemaCode} !== undefined && (${(0, codegen_1$26.or)(this.invalid$data(), condition)})`);
		}
		error(append, errorParams, errorPaths) {
			if (errorParams) {
				this.setParams(errorParams);
				this._error(append, errorPaths);
				this.setParams({});
				return;
			}
			this._error(append, errorPaths);
		}
		_error(append, errorPaths) {
			(append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
		}
		$dataError() {
			(0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
		}
		reset() {
			if (this.errsCount === void 0) throw new Error("add \"trackErrors\" to keyword definition");
			(0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
		}
		ok(cond) {
			if (!this.allErrors) this.gen.if(cond);
		}
		setParams(obj, assign) {
			if (assign) Object.assign(this.params, obj);
			else this.params = obj;
		}
		block$data(valid, codeBlock, $dataValid = codegen_1$26.nil) {
			this.gen.block(() => {
				this.check$data(valid, $dataValid);
				codeBlock();
			});
		}
		check$data(valid = codegen_1$26.nil, $dataValid = codegen_1$26.nil) {
			if (!this.$data) return;
			const { gen, schemaCode, schemaType, def: def$30 } = this;
			gen.if((0, codegen_1$26.or)((0, codegen_1$26._)`${schemaCode} === undefined`, $dataValid));
			if (valid !== codegen_1$26.nil) gen.assign(valid, true);
			if (schemaType.length || def$30.validateSchema) {
				gen.elseIf(this.invalid$data());
				this.$dataError();
				if (valid !== codegen_1$26.nil) gen.assign(valid, false);
			}
			gen.else();
		}
		invalid$data() {
			const { gen, schemaCode, schemaType, def: def$30, it } = this;
			return (0, codegen_1$26.or)(wrong$DataType(), invalid$DataSchema());
			function wrong$DataType() {
				if (schemaType.length) {
					/* istanbul ignore if */
					if (!(schemaCode instanceof codegen_1$26.Name)) throw new Error("ajv implementation error");
					const st = Array.isArray(schemaType) ? schemaType : [schemaType];
					return (0, codegen_1$26._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
				}
				return codegen_1$26.nil;
			}
			function invalid$DataSchema() {
				if (def$30.validateSchema) {
					const validateSchemaRef = gen.scopeValue("validate$data", { ref: def$30.validateSchema });
					return (0, codegen_1$26._)`!${validateSchemaRef}(${schemaCode})`;
				}
				return codegen_1$26.nil;
			}
		}
		subschema(appl, valid) {
			const subschema = (0, subschema_1.getSubschema)(this.it, appl);
			(0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
			(0, subschema_1.extendSubschemaMode)(subschema, appl);
			const nextContext = {
				...this.it,
				...subschema,
				items: void 0,
				props: void 0
			};
			subschemaCode(nextContext, valid);
			return nextContext;
		}
		mergeEvaluated(schemaCxt, toName) {
			const { it, gen } = this;
			if (!it.opts.unevaluated) return;
			if (it.props !== true && schemaCxt.props !== void 0) it.props = util_1$23.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
			if (it.items !== true && schemaCxt.items !== void 0) it.items = util_1$23.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
		}
		mergeValidEvaluated(schemaCxt, valid) {
			const { it, gen } = this;
			if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
				gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1$26.Name));
				return true;
			}
		}
	};
	exports.KeywordCxt = KeywordCxt;
	function keywordCode(it, keyword, def$30, ruleType) {
		const cxt = new KeywordCxt(it, def$30, keyword);
		if ("code" in def$30) def$30.code(cxt, ruleType);
		else if (cxt.$data && def$30.validate) (0, keyword_1.funcKeywordCode)(cxt, def$30);
		else if ("macro" in def$30) (0, keyword_1.macroKeywordCode)(cxt, def$30);
		else if (def$30.compile || def$30.validate) (0, keyword_1.funcKeywordCode)(cxt, def$30);
	}
	const JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
	const RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
	function getData($data, { dataLevel, dataNames, dataPathArr }) {
		let jsonPointer;
		let data;
		if ($data === "") return names_1$3.default.rootData;
		if ($data[0] === "/") {
			if (!JSON_POINTER.test($data)) throw new Error(`Invalid JSON-pointer: ${$data}`);
			jsonPointer = $data;
			data = names_1$3.default.rootData;
		} else {
			const matches = RELATIVE_JSON_POINTER.exec($data);
			if (!matches) throw new Error(`Invalid JSON-pointer: ${$data}`);
			const up = +matches[1];
			jsonPointer = matches[2];
			if (jsonPointer === "#") {
				if (up >= dataLevel) throw new Error(errorMsg("property/index", up));
				return dataPathArr[dataLevel - up];
			}
			if (up > dataLevel) throw new Error(errorMsg("data", up));
			data = dataNames[dataLevel - up];
			if (!jsonPointer) return data;
		}
		let expr = data;
		const segments = jsonPointer.split("/");
		for (const segment of segments) if (segment) {
			data = (0, codegen_1$26._)`${data}${(0, codegen_1$26.getProperty)((0, util_1$23.unescapeJsonPointer)(segment))}`;
			expr = (0, codegen_1$26._)`${expr} && ${data}`;
		}
		return expr;
		function errorMsg(pointerType, up) {
			return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
		}
	}
	exports.getData = getData;
}) });

//#endregion
//#region ../node_modules/ajv/dist/runtime/validation_error.js
var require_validation_error = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/runtime/validation_error.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var ValidationError = class extends Error {
		constructor(errors$1) {
			super("validation failed");
			this.errors = errors$1;
			this.ajv = this.validation = true;
		}
	};
	exports.default = ValidationError;
}) });

//#endregion
//#region ../node_modules/ajv/dist/compile/ref_error.js
var require_ref_error = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/compile/ref_error.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const resolve_1$2 = require_resolve();
	var MissingRefError = class extends Error {
		constructor(resolver, baseId, ref, msg) {
			super(msg || `can't resolve reference ${ref} from id ${baseId}`);
			this.missingRef = (0, resolve_1$2.resolveUrl)(resolver, baseId, ref);
			this.missingSchema = (0, resolve_1$2.normalizeId)((0, resolve_1$2.getFullPath)(resolver, this.missingRef));
		}
	};
	exports.default = MissingRefError;
}) });

//#endregion
//#region ../node_modules/ajv/dist/compile/index.js
var require_compile = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/compile/index.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$25 = require_codegen();
	const validation_error_1$2 = require_validation_error();
	const names_1$2 = require_names();
	const resolve_1$1 = require_resolve();
	const util_1$22 = require_util();
	const validate_1$3 = require_validate();
	var SchemaEnv = class {
		constructor(env) {
			var _a$1;
			this.refs = {};
			this.dynamicAnchors = {};
			let schema$1;
			if (typeof env.schema == "object") schema$1 = env.schema;
			this.schema = env.schema;
			this.schemaId = env.schemaId;
			this.root = env.root || this;
			this.baseId = (_a$1 = env.baseId) !== null && _a$1 !== void 0 ? _a$1 : (0, resolve_1$1.normalizeId)(schema$1 === null || schema$1 === void 0 ? void 0 : schema$1[env.schemaId || "$id"]);
			this.schemaPath = env.schemaPath;
			this.localRefs = env.localRefs;
			this.meta = env.meta;
			this.$async = schema$1 === null || schema$1 === void 0 ? void 0 : schema$1.$async;
			this.refs = {};
		}
	};
	exports.SchemaEnv = SchemaEnv;
	function compileSchema(sch) {
		const _sch = getCompilingSchema.call(this, sch);
		if (_sch) return _sch;
		const rootId = (0, resolve_1$1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
		const { es5, lines } = this.opts.code;
		const { ownProperties } = this.opts;
		const gen = new codegen_1$25.CodeGen(this.scope, {
			es5,
			lines,
			ownProperties
		});
		let _ValidationError;
		if (sch.$async) _ValidationError = gen.scopeValue("Error", {
			ref: validation_error_1$2.default,
			code: (0, codegen_1$25._)`require("ajv/dist/runtime/validation_error").default`
		});
		const validateName = gen.scopeName("validate");
		sch.validateName = validateName;
		const schemaCxt = {
			gen,
			allErrors: this.opts.allErrors,
			data: names_1$2.default.data,
			parentData: names_1$2.default.parentData,
			parentDataProperty: names_1$2.default.parentDataProperty,
			dataNames: [names_1$2.default.data],
			dataPathArr: [codegen_1$25.nil],
			dataLevel: 0,
			dataTypes: [],
			definedProperties: /* @__PURE__ */ new Set(),
			topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? {
				ref: sch.schema,
				code: (0, codegen_1$25.stringify)(sch.schema)
			} : { ref: sch.schema }),
			validateName,
			ValidationError: _ValidationError,
			schema: sch.schema,
			schemaEnv: sch,
			rootId,
			baseId: sch.baseId || rootId,
			schemaPath: codegen_1$25.nil,
			errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
			errorPath: (0, codegen_1$25._)`""`,
			opts: this.opts,
			self: this
		};
		let sourceCode;
		try {
			this._compilations.add(sch);
			(0, validate_1$3.validateFunctionCode)(schemaCxt);
			gen.optimize(this.opts.code.optimize);
			const validateCode = gen.toString();
			sourceCode = `${gen.scopeRefs(names_1$2.default.scope)}return ${validateCode}`;
			if (this.opts.code.process) sourceCode = this.opts.code.process(sourceCode, sch);
			const validate$1 = new Function(`${names_1$2.default.self}`, `${names_1$2.default.scope}`, sourceCode)(this, this.scope.get());
			this.scope.value(validateName, { ref: validate$1 });
			validate$1.errors = null;
			validate$1.schema = sch.schema;
			validate$1.schemaEnv = sch;
			if (sch.$async) validate$1.$async = true;
			if (this.opts.code.source === true) validate$1.source = {
				validateName,
				validateCode,
				scopeValues: gen._values
			};
			if (this.opts.unevaluated) {
				const { props, items } = schemaCxt;
				validate$1.evaluated = {
					props: props instanceof codegen_1$25.Name ? void 0 : props,
					items: items instanceof codegen_1$25.Name ? void 0 : items,
					dynamicProps: props instanceof codegen_1$25.Name,
					dynamicItems: items instanceof codegen_1$25.Name
				};
				if (validate$1.source) validate$1.source.evaluated = (0, codegen_1$25.stringify)(validate$1.evaluated);
			}
			sch.validate = validate$1;
			return sch;
		} catch (e) {
			delete sch.validate;
			delete sch.validateName;
			if (sourceCode) this.logger.error("Error compiling schema, function code:", sourceCode);
			throw e;
		} finally {
			this._compilations.delete(sch);
		}
	}
	exports.compileSchema = compileSchema;
	function resolveRef(root, baseId, ref) {
		var _a$1;
		ref = (0, resolve_1$1.resolveUrl)(this.opts.uriResolver, baseId, ref);
		const schOrFunc = root.refs[ref];
		if (schOrFunc) return schOrFunc;
		let _sch = resolve$1.call(this, root, ref);
		if (_sch === void 0) {
			const schema$1 = (_a$1 = root.localRefs) === null || _a$1 === void 0 ? void 0 : _a$1[ref];
			const { schemaId } = this.opts;
			if (schema$1) _sch = new SchemaEnv({
				schema: schema$1,
				schemaId,
				root,
				baseId
			});
		}
		if (_sch === void 0) return;
		return root.refs[ref] = inlineOrCompile.call(this, _sch);
	}
	exports.resolveRef = resolveRef;
	function inlineOrCompile(sch) {
		if ((0, resolve_1$1.inlineRef)(sch.schema, this.opts.inlineRefs)) return sch.schema;
		return sch.validate ? sch : compileSchema.call(this, sch);
	}
	function getCompilingSchema(schEnv) {
		for (const sch of this._compilations) if (sameSchemaEnv(sch, schEnv)) return sch;
	}
	exports.getCompilingSchema = getCompilingSchema;
	function sameSchemaEnv(s1, s2) {
		return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
	}
	function resolve$1(root, ref) {
		let sch;
		while (typeof (sch = this.refs[ref]) == "string") ref = sch;
		return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
	}
	function resolveSchema(root, ref) {
		const p = this.opts.uriResolver.parse(ref);
		const refPath = (0, resolve_1$1._getFullPath)(this.opts.uriResolver, p);
		let baseId = (0, resolve_1$1.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
		if (Object.keys(root.schema).length > 0 && refPath === baseId) return getJsonPointer.call(this, p, root);
		const id = (0, resolve_1$1.normalizeId)(refPath);
		const schOrRef = this.refs[id] || this.schemas[id];
		if (typeof schOrRef == "string") {
			const sch = resolveSchema.call(this, root, schOrRef);
			if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object") return;
			return getJsonPointer.call(this, p, sch);
		}
		if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object") return;
		if (!schOrRef.validate) compileSchema.call(this, schOrRef);
		if (id === (0, resolve_1$1.normalizeId)(ref)) {
			const { schema: schema$1 } = schOrRef;
			const { schemaId } = this.opts;
			const schId = schema$1[schemaId];
			if (schId) baseId = (0, resolve_1$1.resolveUrl)(this.opts.uriResolver, baseId, schId);
			return new SchemaEnv({
				schema: schema$1,
				schemaId,
				root,
				baseId
			});
		}
		return getJsonPointer.call(this, p, schOrRef);
	}
	exports.resolveSchema = resolveSchema;
	const PREVENT_SCOPE_CHANGE = new Set([
		"properties",
		"patternProperties",
		"enum",
		"dependencies",
		"definitions"
	]);
	function getJsonPointer(parsedRef, { baseId, schema: schema$1, root }) {
		var _a$1;
		if (((_a$1 = parsedRef.fragment) === null || _a$1 === void 0 ? void 0 : _a$1[0]) !== "/") return;
		for (const part of parsedRef.fragment.slice(1).split("/")) {
			if (typeof schema$1 === "boolean") return;
			const partSchema = schema$1[(0, util_1$22.unescapeFragment)(part)];
			if (partSchema === void 0) return;
			schema$1 = partSchema;
			const schId = typeof schema$1 === "object" && schema$1[this.opts.schemaId];
			if (!PREVENT_SCOPE_CHANGE.has(part) && schId) baseId = (0, resolve_1$1.resolveUrl)(this.opts.uriResolver, baseId, schId);
		}
		let env;
		if (typeof schema$1 != "boolean" && schema$1.$ref && !(0, util_1$22.schemaHasRulesButRef)(schema$1, this.RULES)) {
			const $ref = (0, resolve_1$1.resolveUrl)(this.opts.uriResolver, baseId, schema$1.$ref);
			env = resolveSchema.call(this, root, $ref);
		}
		const { schemaId } = this.opts;
		env = env || new SchemaEnv({
			schema: schema$1,
			schemaId,
			root,
			baseId
		});
		if (env.schema !== env.root.schema) return env;
	}
}) });

//#endregion
//#region ../node_modules/ajv/dist/refs/data.json
var require_data = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/refs/data.json": ((exports, module) => {
	module.exports = {
		"$id": "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
		"description": "Meta-schema for $data reference (JSON AnySchema extension proposal)",
		"type": "object",
		"required": ["$data"],
		"properties": { "$data": {
			"type": "string",
			"anyOf": [{ "format": "relative-json-pointer" }, { "format": "json-pointer" }]
		} },
		"additionalProperties": false
	};
}) });

//#endregion
//#region ../node_modules/fast-uri/lib/utils.js
var require_utils = /* @__PURE__ */ __commonJS$2({ "../node_modules/fast-uri/lib/utils.js": ((exports, module) => {
	/** @type {(value: string) => boolean} */
	const isUUID$1 = RegExp.prototype.test.bind(/^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu);
	/** @type {(value: string) => boolean} */
	const isIPv4$1 = RegExp.prototype.test.bind(/^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u);
	/**
	* @param {Array<string>} input
	* @returns {string}
	*/
	function stringArrayToHexStripped(input) {
		let acc = "";
		let code = 0;
		let i = 0;
		for (i = 0; i < input.length; i++) {
			code = input[i].charCodeAt(0);
			if (code === 48) continue;
			if (!(code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102)) return "";
			acc += input[i];
			break;
		}
		for (i += 1; i < input.length; i++) {
			code = input[i].charCodeAt(0);
			if (!(code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102)) return "";
			acc += input[i];
		}
		return acc;
	}
	/**
	* @typedef {Object} GetIPV6Result
	* @property {boolean} error - Indicates if there was an error parsing the IPv6 address.
	* @property {string} address - The parsed IPv6 address.
	* @property {string} [zone] - The zone identifier, if present.
	*/
	/**
	* @param {string} value
	* @returns {boolean}
	*/
	const nonSimpleDomain$1 = RegExp.prototype.test.bind(/[^!"$&'()*+,\-.;=_`a-z{}~]/u);
	/**
	* @param {Array<string>} buffer
	* @returns {boolean}
	*/
	function consumeIsZone(buffer) {
		buffer.length = 0;
		return true;
	}
	/**
	* @param {Array<string>} buffer
	* @param {Array<string>} address
	* @param {GetIPV6Result} output
	* @returns {boolean}
	*/
	function consumeHextets(buffer, address, output) {
		if (buffer.length) {
			const hex = stringArrayToHexStripped(buffer);
			if (hex !== "") address.push(hex);
			else {
				output.error = true;
				return false;
			}
			buffer.length = 0;
		}
		return true;
	}
	/**
	* @param {string} input
	* @returns {GetIPV6Result}
	*/
	function getIPV6(input) {
		let tokenCount = 0;
		const output = {
			error: false,
			address: "",
			zone: ""
		};
		/** @type {Array<string>} */
		const address = [];
		/** @type {Array<string>} */
		const buffer = [];
		let endipv6Encountered = false;
		let endIpv6 = false;
		let consume = consumeHextets;
		for (let i = 0; i < input.length; i++) {
			const cursor = input[i];
			if (cursor === "[" || cursor === "]") continue;
			if (cursor === ":") {
				if (endipv6Encountered === true) endIpv6 = true;
				if (!consume(buffer, address, output)) break;
				if (++tokenCount > 7) {
					output.error = true;
					break;
				}
				if (i > 0 && input[i - 1] === ":") endipv6Encountered = true;
				address.push(":");
				continue;
			} else if (cursor === "%") {
				if (!consume(buffer, address, output)) break;
				consume = consumeIsZone;
			} else {
				buffer.push(cursor);
				continue;
			}
		}
		if (buffer.length) if (consume === consumeIsZone) output.zone = buffer.join("");
		else if (endIpv6) address.push(buffer.join(""));
		else address.push(stringArrayToHexStripped(buffer));
		output.address = address.join("");
		return output;
	}
	/**
	* @typedef {Object} NormalizeIPv6Result
	* @property {string} host - The normalized host.
	* @property {string} [escapedHost] - The escaped host.
	* @property {boolean} isIPV6 - Indicates if the host is an IPv6 address.
	*/
	/**
	* @param {string} host
	* @returns {NormalizeIPv6Result}
	*/
	function normalizeIPv6$1(host) {
		if (findToken(host, ":") < 2) return {
			host,
			isIPV6: false
		};
		const ipv6 = getIPV6(host);
		if (!ipv6.error) {
			let newHost = ipv6.address;
			let escapedHost = ipv6.address;
			if (ipv6.zone) {
				newHost += "%" + ipv6.zone;
				escapedHost += "%25" + ipv6.zone;
			}
			return {
				host: newHost,
				isIPV6: true,
				escapedHost
			};
		} else return {
			host,
			isIPV6: false
		};
	}
	/**
	* @param {string} str
	* @param {string} token
	* @returns {number}
	*/
	function findToken(str$1, token) {
		let ind = 0;
		for (let i = 0; i < str$1.length; i++) if (str$1[i] === token) ind++;
		return ind;
	}
	/**
	* @param {string} path
	* @returns {string}
	*
	* @see https://datatracker.ietf.org/doc/html/rfc3986#section-5.2.4
	*/
	function removeDotSegments$1(path) {
		let input = path;
		const output = [];
		let nextSlash = -1;
		let len = 0;
		while (len = input.length) {
			if (len === 1) if (input === ".") break;
			else if (input === "/") {
				output.push("/");
				break;
			} else {
				output.push(input);
				break;
			}
			else if (len === 2) {
				if (input[0] === ".") {
					if (input[1] === ".") break;
					else if (input[1] === "/") {
						input = input.slice(2);
						continue;
					}
				} else if (input[0] === "/") {
					if (input[1] === "." || input[1] === "/") {
						output.push("/");
						break;
					}
				}
			} else if (len === 3) {
				if (input === "/..") {
					if (output.length !== 0) output.pop();
					output.push("/");
					break;
				}
			}
			if (input[0] === ".") {
				if (input[1] === ".") {
					if (input[2] === "/") {
						input = input.slice(3);
						continue;
					}
				} else if (input[1] === "/") {
					input = input.slice(2);
					continue;
				}
			} else if (input[0] === "/") {
				if (input[1] === ".") {
					if (input[2] === "/") {
						input = input.slice(2);
						continue;
					} else if (input[2] === ".") {
						if (input[3] === "/") {
							input = input.slice(3);
							if (output.length !== 0) output.pop();
							continue;
						}
					}
				}
			}
			if ((nextSlash = input.indexOf("/", 1)) === -1) {
				output.push(input);
				break;
			} else {
				output.push(input.slice(0, nextSlash));
				input = input.slice(nextSlash);
			}
		}
		return output.join("");
	}
	/**
	* @param {import('../types/index').URIComponent} component
	* @param {boolean} esc
	* @returns {import('../types/index').URIComponent}
	*/
	function normalizeComponentEncoding$1(component, esc) {
		const func = esc !== true ? escape : unescape;
		if (component.scheme !== void 0) component.scheme = func(component.scheme);
		if (component.userinfo !== void 0) component.userinfo = func(component.userinfo);
		if (component.host !== void 0) component.host = func(component.host);
		if (component.path !== void 0) component.path = func(component.path);
		if (component.query !== void 0) component.query = func(component.query);
		if (component.fragment !== void 0) component.fragment = func(component.fragment);
		return component;
	}
	/**
	* @param {import('../types/index').URIComponent} component
	* @returns {string|undefined}
	*/
	function recomposeAuthority$1(component) {
		const uriTokens = [];
		if (component.userinfo !== void 0) {
			uriTokens.push(component.userinfo);
			uriTokens.push("@");
		}
		if (component.host !== void 0) {
			let host = unescape(component.host);
			if (!isIPv4$1(host)) {
				const ipV6res = normalizeIPv6$1(host);
				if (ipV6res.isIPV6 === true) host = `[${ipV6res.escapedHost}]`;
				else host = component.host;
			}
			uriTokens.push(host);
		}
		if (typeof component.port === "number" || typeof component.port === "string") {
			uriTokens.push(":");
			uriTokens.push(String(component.port));
		}
		return uriTokens.length ? uriTokens.join("") : void 0;
	}
	module.exports = {
		nonSimpleDomain: nonSimpleDomain$1,
		recomposeAuthority: recomposeAuthority$1,
		normalizeComponentEncoding: normalizeComponentEncoding$1,
		removeDotSegments: removeDotSegments$1,
		isIPv4: isIPv4$1,
		isUUID: isUUID$1,
		normalizeIPv6: normalizeIPv6$1,
		stringArrayToHexStripped
	};
}) });

//#endregion
//#region ../node_modules/fast-uri/lib/schemes.js
var require_schemes = /* @__PURE__ */ __commonJS$2({ "../node_modules/fast-uri/lib/schemes.js": ((exports, module) => {
	const { isUUID } = require_utils();
	const URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
	const supportedSchemeNames = [
		"http",
		"https",
		"ws",
		"wss",
		"urn",
		"urn:uuid"
	];
	/** @typedef {supportedSchemeNames[number]} SchemeName */
	/**
	* @param {string} name
	* @returns {name is SchemeName}
	*/
	function isValidSchemeName(name) {
		return supportedSchemeNames.indexOf(name) !== -1;
	}
	/**
	* @callback SchemeFn
	* @param {import('../types/index').URIComponent} component
	* @param {import('../types/index').Options} options
	* @returns {import('../types/index').URIComponent}
	*/
	/**
	* @typedef {Object} SchemeHandler
	* @property {SchemeName} scheme - The scheme name.
	* @property {boolean} [domainHost] - Indicates if the scheme supports domain hosts.
	* @property {SchemeFn} parse - Function to parse the URI component for this scheme.
	* @property {SchemeFn} serialize - Function to serialize the URI component for this scheme.
	* @property {boolean} [skipNormalize] - Indicates if normalization should be skipped for this scheme.
	* @property {boolean} [absolutePath] - Indicates if the scheme uses absolute paths.
	* @property {boolean} [unicodeSupport] - Indicates if the scheme supports Unicode.
	*/
	/**
	* @param {import('../types/index').URIComponent} wsComponent
	* @returns {boolean}
	*/
	function wsIsSecure(wsComponent) {
		if (wsComponent.secure === true) return true;
		else if (wsComponent.secure === false) return false;
		else if (wsComponent.scheme) return wsComponent.scheme.length === 3 && (wsComponent.scheme[0] === "w" || wsComponent.scheme[0] === "W") && (wsComponent.scheme[1] === "s" || wsComponent.scheme[1] === "S") && (wsComponent.scheme[2] === "s" || wsComponent.scheme[2] === "S");
		else return false;
	}
	/** @type {SchemeFn} */
	function httpParse(component) {
		if (!component.host) component.error = component.error || "HTTP URIs must have a host.";
		return component;
	}
	/** @type {SchemeFn} */
	function httpSerialize(component) {
		const secure = String(component.scheme).toLowerCase() === "https";
		if (component.port === (secure ? 443 : 80) || component.port === "") component.port = void 0;
		if (!component.path) component.path = "/";
		return component;
	}
	/** @type {SchemeFn} */
	function wsParse(wsComponent) {
		wsComponent.secure = wsIsSecure(wsComponent);
		wsComponent.resourceName = (wsComponent.path || "/") + (wsComponent.query ? "?" + wsComponent.query : "");
		wsComponent.path = void 0;
		wsComponent.query = void 0;
		return wsComponent;
	}
	/** @type {SchemeFn} */
	function wsSerialize(wsComponent) {
		if (wsComponent.port === (wsIsSecure(wsComponent) ? 443 : 80) || wsComponent.port === "") wsComponent.port = void 0;
		if (typeof wsComponent.secure === "boolean") {
			wsComponent.scheme = wsComponent.secure ? "wss" : "ws";
			wsComponent.secure = void 0;
		}
		if (wsComponent.resourceName) {
			const [path, query] = wsComponent.resourceName.split("?");
			wsComponent.path = path && path !== "/" ? path : void 0;
			wsComponent.query = query;
			wsComponent.resourceName = void 0;
		}
		wsComponent.fragment = void 0;
		return wsComponent;
	}
	/** @type {SchemeFn} */
	function urnParse(urnComponent, options) {
		if (!urnComponent.path) {
			urnComponent.error = "URN can not be parsed";
			return urnComponent;
		}
		const matches = urnComponent.path.match(URN_REG);
		if (matches) {
			const scheme = options.scheme || urnComponent.scheme || "urn";
			urnComponent.nid = matches[1].toLowerCase();
			urnComponent.nss = matches[2];
			const schemeHandler = getSchemeHandler$1(`${scheme}:${options.nid || urnComponent.nid}`);
			urnComponent.path = void 0;
			if (schemeHandler) urnComponent = schemeHandler.parse(urnComponent, options);
		} else urnComponent.error = urnComponent.error || "URN can not be parsed.";
		return urnComponent;
	}
	/** @type {SchemeFn} */
	function urnSerialize(urnComponent, options) {
		if (urnComponent.nid === void 0) throw new Error("URN without nid cannot be serialized");
		const scheme = options.scheme || urnComponent.scheme || "urn";
		const nid = urnComponent.nid.toLowerCase();
		const schemeHandler = getSchemeHandler$1(`${scheme}:${options.nid || nid}`);
		if (schemeHandler) urnComponent = schemeHandler.serialize(urnComponent, options);
		const uriComponent = urnComponent;
		const nss = urnComponent.nss;
		uriComponent.path = `${nid || options.nid}:${nss}`;
		options.skipEscape = true;
		return uriComponent;
	}
	/** @type {SchemeFn} */
	function urnuuidParse(urnComponent, options) {
		const uuidComponent = urnComponent;
		uuidComponent.uuid = uuidComponent.nss;
		uuidComponent.nss = void 0;
		if (!options.tolerant && (!uuidComponent.uuid || !isUUID(uuidComponent.uuid))) uuidComponent.error = uuidComponent.error || "UUID is not valid.";
		return uuidComponent;
	}
	/** @type {SchemeFn} */
	function urnuuidSerialize(uuidComponent) {
		const urnComponent = uuidComponent;
		urnComponent.nss = (uuidComponent.uuid || "").toLowerCase();
		return urnComponent;
	}
	const http = {
		scheme: "http",
		domainHost: true,
		parse: httpParse,
		serialize: httpSerialize
	};
	const https = {
		scheme: "https",
		domainHost: http.domainHost,
		parse: httpParse,
		serialize: httpSerialize
	};
	const ws = {
		scheme: "ws",
		domainHost: true,
		parse: wsParse,
		serialize: wsSerialize
	};
	const wss = {
		scheme: "wss",
		domainHost: ws.domainHost,
		parse: ws.parse,
		serialize: ws.serialize
	};
	const urn = {
		scheme: "urn",
		parse: urnParse,
		serialize: urnSerialize,
		skipNormalize: true
	};
	const urnuuid = {
		scheme: "urn:uuid",
		parse: urnuuidParse,
		serialize: urnuuidSerialize,
		skipNormalize: true
	};
	const SCHEMES$1 = {
		http,
		https,
		ws,
		wss,
		urn,
		"urn:uuid": urnuuid
	};
	Object.setPrototypeOf(SCHEMES$1, null);
	/**
	* @param {string|undefined} scheme
	* @returns {SchemeHandler|undefined}
	*/
	function getSchemeHandler$1(scheme) {
		return scheme && (SCHEMES$1[scheme] || SCHEMES$1[scheme.toLowerCase()]) || void 0;
	}
	module.exports = {
		wsIsSecure,
		SCHEMES: SCHEMES$1,
		isValidSchemeName,
		getSchemeHandler: getSchemeHandler$1
	};
}) });

//#endregion
//#region ../node_modules/fast-uri/index.js
var require_fast_uri = /* @__PURE__ */ __commonJS$2({ "../node_modules/fast-uri/index.js": ((exports, module) => {
	const { normalizeIPv6, removeDotSegments, recomposeAuthority, normalizeComponentEncoding, isIPv4, nonSimpleDomain } = require_utils();
	const { SCHEMES, getSchemeHandler } = require_schemes();
	/**
	* @template {import('./types/index').URIComponent|string} T
	* @param {T} uri
	* @param {import('./types/index').Options} [options]
	* @returns {T}
	*/
	function normalize(uri$1, options) {
		if (typeof uri$1 === "string") uri$1 = serialize(parse$1(uri$1, options), options);
		else if (typeof uri$1 === "object") uri$1 = parse$1(serialize(uri$1, options), options);
		return uri$1;
	}
	/**
	* @param {string} baseURI
	* @param {string} relativeURI
	* @param {import('./types/index').Options} [options]
	* @returns {string}
	*/
	function resolve(baseURI, relativeURI, options) {
		const schemelessOptions = options ? Object.assign({ scheme: "null" }, options) : { scheme: "null" };
		const resolved = resolveComponent(parse$1(baseURI, schemelessOptions), parse$1(relativeURI, schemelessOptions), schemelessOptions, true);
		schemelessOptions.skipEscape = true;
		return serialize(resolved, schemelessOptions);
	}
	/**
	* @param {import ('./types/index').URIComponent} base
	* @param {import ('./types/index').URIComponent} relative
	* @param {import('./types/index').Options} [options]
	* @param {boolean} [skipNormalization=false]
	* @returns {import ('./types/index').URIComponent}
	*/
	function resolveComponent(base, relative, options, skipNormalization) {
		/** @type {import('./types/index').URIComponent} */
		const target = {};
		if (!skipNormalization) {
			base = parse$1(serialize(base, options), options);
			relative = parse$1(serialize(relative, options), options);
		}
		options = options || {};
		if (!options.tolerant && relative.scheme) {
			target.scheme = relative.scheme;
			target.userinfo = relative.userinfo;
			target.host = relative.host;
			target.port = relative.port;
			target.path = removeDotSegments(relative.path || "");
			target.query = relative.query;
		} else {
			if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
				target.userinfo = relative.userinfo;
				target.host = relative.host;
				target.port = relative.port;
				target.path = removeDotSegments(relative.path || "");
				target.query = relative.query;
			} else {
				if (!relative.path) {
					target.path = base.path;
					if (relative.query !== void 0) target.query = relative.query;
					else target.query = base.query;
				} else {
					if (relative.path[0] === "/") target.path = removeDotSegments(relative.path);
					else {
						if ((base.userinfo !== void 0 || base.host !== void 0 || base.port !== void 0) && !base.path) target.path = "/" + relative.path;
						else if (!base.path) target.path = relative.path;
						else target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
						target.path = removeDotSegments(target.path);
					}
					target.query = relative.query;
				}
				target.userinfo = base.userinfo;
				target.host = base.host;
				target.port = base.port;
			}
			target.scheme = base.scheme;
		}
		target.fragment = relative.fragment;
		return target;
	}
	/**
	* @param {import ('./types/index').URIComponent|string} uriA
	* @param {import ('./types/index').URIComponent|string} uriB
	* @param {import ('./types/index').Options} options
	* @returns {boolean}
	*/
	function equal$1(uriA, uriB, options) {
		if (typeof uriA === "string") {
			uriA = unescape(uriA);
			uriA = serialize(normalizeComponentEncoding(parse$1(uriA, options), true), {
				...options,
				skipEscape: true
			});
		} else if (typeof uriA === "object") uriA = serialize(normalizeComponentEncoding(uriA, true), {
			...options,
			skipEscape: true
		});
		if (typeof uriB === "string") {
			uriB = unescape(uriB);
			uriB = serialize(normalizeComponentEncoding(parse$1(uriB, options), true), {
				...options,
				skipEscape: true
			});
		} else if (typeof uriB === "object") uriB = serialize(normalizeComponentEncoding(uriB, true), {
			...options,
			skipEscape: true
		});
		return uriA.toLowerCase() === uriB.toLowerCase();
	}
	/**
	* @param {Readonly<import('./types/index').URIComponent>} cmpts
	* @param {import('./types/index').Options} [opts]
	* @returns {string}
	*/
	function serialize(cmpts, opts) {
		const component = {
			host: cmpts.host,
			scheme: cmpts.scheme,
			userinfo: cmpts.userinfo,
			port: cmpts.port,
			path: cmpts.path,
			query: cmpts.query,
			nid: cmpts.nid,
			nss: cmpts.nss,
			uuid: cmpts.uuid,
			fragment: cmpts.fragment,
			reference: cmpts.reference,
			resourceName: cmpts.resourceName,
			secure: cmpts.secure,
			error: ""
		};
		const options = Object.assign({}, opts);
		const uriTokens = [];
		const schemeHandler = getSchemeHandler(options.scheme || component.scheme);
		if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(component, options);
		if (component.path !== void 0) if (!options.skipEscape) {
			component.path = escape(component.path);
			if (component.scheme !== void 0) component.path = component.path.split("%3A").join(":");
		} else component.path = unescape(component.path);
		if (options.reference !== "suffix" && component.scheme) uriTokens.push(component.scheme, ":");
		const authority = recomposeAuthority(component);
		if (authority !== void 0) {
			if (options.reference !== "suffix") uriTokens.push("//");
			uriTokens.push(authority);
			if (component.path && component.path[0] !== "/") uriTokens.push("/");
		}
		if (component.path !== void 0) {
			let s = component.path;
			if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) s = removeDotSegments(s);
			if (authority === void 0 && s[0] === "/" && s[1] === "/") s = "/%2F" + s.slice(2);
			uriTokens.push(s);
		}
		if (component.query !== void 0) uriTokens.push("?", component.query);
		if (component.fragment !== void 0) uriTokens.push("#", component.fragment);
		return uriTokens.join("");
	}
	const URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
	/**
	* @param {string} uri
	* @param {import('./types/index').Options} [opts]
	* @returns
	*/
	function parse$1(uri$1, opts) {
		const options = Object.assign({}, opts);
		/** @type {import('./types/index').URIComponent} */
		const parsed = {
			scheme: void 0,
			userinfo: void 0,
			host: "",
			port: void 0,
			path: "",
			query: void 0,
			fragment: void 0
		};
		let isIP = false;
		if (options.reference === "suffix") if (options.scheme) uri$1 = options.scheme + ":" + uri$1;
		else uri$1 = "//" + uri$1;
		const matches = uri$1.match(URI_PARSE);
		if (matches) {
			parsed.scheme = matches[1];
			parsed.userinfo = matches[3];
			parsed.host = matches[4];
			parsed.port = parseInt(matches[5], 10);
			parsed.path = matches[6] || "";
			parsed.query = matches[7];
			parsed.fragment = matches[8];
			if (isNaN(parsed.port)) parsed.port = matches[5];
			if (parsed.host) if (isIPv4(parsed.host) === false) {
				const ipv6result = normalizeIPv6(parsed.host);
				parsed.host = ipv6result.host.toLowerCase();
				isIP = ipv6result.isIPV6;
			} else isIP = true;
			if (parsed.scheme === void 0 && parsed.userinfo === void 0 && parsed.host === void 0 && parsed.port === void 0 && parsed.query === void 0 && !parsed.path) parsed.reference = "same-document";
			else if (parsed.scheme === void 0) parsed.reference = "relative";
			else if (parsed.fragment === void 0) parsed.reference = "absolute";
			else parsed.reference = "uri";
			if (options.reference && options.reference !== "suffix" && options.reference !== parsed.reference) parsed.error = parsed.error || "URI is not a " + options.reference + " reference.";
			const schemeHandler = getSchemeHandler(options.scheme || parsed.scheme);
			if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
				if (parsed.host && (options.domainHost || schemeHandler && schemeHandler.domainHost) && isIP === false && nonSimpleDomain(parsed.host)) try {
					parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
				} catch (e) {
					parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e;
				}
			}
			if (!schemeHandler || schemeHandler && !schemeHandler.skipNormalize) {
				if (uri$1.indexOf("%") !== -1) {
					if (parsed.scheme !== void 0) parsed.scheme = unescape(parsed.scheme);
					if (parsed.host !== void 0) parsed.host = unescape(parsed.host);
				}
				if (parsed.path) parsed.path = escape(unescape(parsed.path));
				if (parsed.fragment) parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment));
			}
			if (schemeHandler && schemeHandler.parse) schemeHandler.parse(parsed, options);
		} else parsed.error = parsed.error || "URI can not be parsed.";
		return parsed;
	}
	const fastUri = {
		SCHEMES,
		normalize,
		resolve,
		resolveComponent,
		equal: equal$1,
		serialize,
		parse: parse$1
	};
	module.exports = fastUri;
	module.exports.default = fastUri;
	module.exports.fastUri = fastUri;
}) });

//#endregion
//#region ../node_modules/ajv/dist/runtime/uri.js
var require_uri = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/runtime/uri.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const uri = require_fast_uri();
	uri.code = "require(\"ajv/dist/runtime/uri\").default";
	exports.default = uri;
}) });

//#endregion
//#region ../node_modules/ajv/dist/core.js
var require_core$1 = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/core.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
	var validate_1$2 = require_validate();
	Object.defineProperty(exports, "KeywordCxt", {
		enumerable: true,
		get: function() {
			return validate_1$2.KeywordCxt;
		}
	});
	var codegen_1$24 = require_codegen();
	Object.defineProperty(exports, "_", {
		enumerable: true,
		get: function() {
			return codegen_1$24._;
		}
	});
	Object.defineProperty(exports, "str", {
		enumerable: true,
		get: function() {
			return codegen_1$24.str;
		}
	});
	Object.defineProperty(exports, "stringify", {
		enumerable: true,
		get: function() {
			return codegen_1$24.stringify;
		}
	});
	Object.defineProperty(exports, "nil", {
		enumerable: true,
		get: function() {
			return codegen_1$24.nil;
		}
	});
	Object.defineProperty(exports, "Name", {
		enumerable: true,
		get: function() {
			return codegen_1$24.Name;
		}
	});
	Object.defineProperty(exports, "CodeGen", {
		enumerable: true,
		get: function() {
			return codegen_1$24.CodeGen;
		}
	});
	const validation_error_1$1 = require_validation_error();
	const ref_error_1$3 = require_ref_error();
	const rules_1 = require_rules();
	const compile_1$2 = require_compile();
	const codegen_2 = require_codegen();
	const resolve_1 = require_resolve();
	const dataType_1$1 = require_dataType();
	const util_1$21 = require_util();
	const $dataRefSchema = require_data();
	const uri_1 = require_uri();
	const defaultRegExp = (str$1, flags) => new RegExp(str$1, flags);
	defaultRegExp.code = "new RegExp";
	const META_IGNORE_OPTIONS = [
		"removeAdditional",
		"useDefaults",
		"coerceTypes"
	];
	const EXT_SCOPE_NAMES = new Set([
		"validate",
		"serialize",
		"parse",
		"wrapper",
		"root",
		"schema",
		"keyword",
		"pattern",
		"formats",
		"validate$data",
		"func",
		"obj",
		"Error"
	]);
	const removedOptions = {
		errorDataPath: "",
		format: "`validateFormats: false` can be used instead.",
		nullable: "\"nullable\" keyword is supported by default.",
		jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
		extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
		missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
		processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
		sourceCode: "Use option `code: {source: true}`",
		strictDefaults: "It is default now, see option `strict`.",
		strictKeywords: "It is default now, see option `strict`.",
		uniqueItems: "\"uniqueItems\" keyword is always validated.",
		unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
		cache: "Map is used as cache, schema object as key.",
		serialize: "Map is used as cache, schema object as key.",
		ajvErrors: "It is default now."
	};
	const deprecatedOptions = {
		ignoreKeywordsWithRef: "",
		jsPropertySyntax: "",
		unicode: "\"minLength\"/\"maxLength\" account for unicode characters by default."
	};
	const MAX_EXPRESSION = 200;
	function requiredOptions(o) {
		var _a$1, _b$1, _c$1, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
		const s = o.strict;
		const _optz = (_a$1 = o.code) === null || _a$1 === void 0 ? void 0 : _a$1.optimize;
		const optimize$1 = _optz === true || _optz === void 0 ? 1 : _optz || 0;
		const regExp = (_c$1 = (_b$1 = o.code) === null || _b$1 === void 0 ? void 0 : _b$1.regExp) !== null && _c$1 !== void 0 ? _c$1 : defaultRegExp;
		const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
		return {
			strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
			strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
			strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
			strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
			strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
			code: o.code ? {
				...o.code,
				optimize: optimize$1,
				regExp
			} : {
				optimize: optimize$1,
				regExp
			},
			loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
			loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
			meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
			messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
			inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
			schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
			addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
			validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
			validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
			unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
			int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
			uriResolver
		};
	}
	var Ajv$2 = class {
		constructor(opts = {}) {
			this.schemas = {};
			this.refs = {};
			this.formats = {};
			this._compilations = /* @__PURE__ */ new Set();
			this._loading = {};
			this._cache = /* @__PURE__ */ new Map();
			opts = this.opts = {
				...opts,
				...requiredOptions(opts)
			};
			const { es5, lines } = this.opts.code;
			this.scope = new codegen_2.ValueScope({
				scope: {},
				prefixes: EXT_SCOPE_NAMES,
				es5,
				lines
			});
			this.logger = getLogger(opts.logger);
			const formatOpt = opts.validateFormats;
			opts.validateFormats = false;
			this.RULES = (0, rules_1.getRules)();
			checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
			checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
			this._metaOpts = getMetaSchemaOptions.call(this);
			if (opts.formats) addInitialFormats.call(this);
			this._addVocabularies();
			this._addDefaultMetaSchema();
			if (opts.keywords) addInitialKeywords.call(this, opts.keywords);
			if (typeof opts.meta == "object") this.addMetaSchema(opts.meta);
			addInitialSchemas.call(this);
			opts.validateFormats = formatOpt;
		}
		_addVocabularies() {
			this.addKeyword("$async");
		}
		_addDefaultMetaSchema() {
			const { $data, meta, schemaId } = this.opts;
			let _dataRefSchema = $dataRefSchema;
			if (schemaId === "id") {
				_dataRefSchema = { ...$dataRefSchema };
				_dataRefSchema.id = _dataRefSchema.$id;
				delete _dataRefSchema.$id;
			}
			if (meta && $data) this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
		}
		defaultMeta() {
			const { meta, schemaId } = this.opts;
			return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : void 0;
		}
		validate(schemaKeyRef, data) {
			let v;
			if (typeof schemaKeyRef == "string") {
				v = this.getSchema(schemaKeyRef);
				if (!v) throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
			} else v = this.compile(schemaKeyRef);
			const valid = v(data);
			if (!("$async" in v)) this.errors = v.errors;
			return valid;
		}
		compile(schema$1, _meta) {
			const sch = this._addSchema(schema$1, _meta);
			return sch.validate || this._compileSchemaEnv(sch);
		}
		compileAsync(schema$1, meta) {
			if (typeof this.opts.loadSchema != "function") throw new Error("options.loadSchema should be a function");
			const { loadSchema } = this.opts;
			return runCompileAsync.call(this, schema$1, meta);
			async function runCompileAsync(_schema, _meta) {
				await loadMetaSchema.call(this, _schema.$schema);
				const sch = this._addSchema(_schema, _meta);
				return sch.validate || _compileAsync.call(this, sch);
			}
			async function loadMetaSchema($ref) {
				if ($ref && !this.getSchema($ref)) await runCompileAsync.call(this, { $ref }, true);
			}
			async function _compileAsync(sch) {
				try {
					return this._compileSchemaEnv(sch);
				} catch (e) {
					if (!(e instanceof ref_error_1$3.default)) throw e;
					checkLoaded.call(this, e);
					await loadMissingSchema.call(this, e.missingSchema);
					return _compileAsync.call(this, sch);
				}
			}
			function checkLoaded({ missingSchema: ref, missingRef }) {
				if (this.refs[ref]) throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
			}
			async function loadMissingSchema(ref) {
				const _schema = await _loadSchema.call(this, ref);
				if (!this.refs[ref]) await loadMetaSchema.call(this, _schema.$schema);
				if (!this.refs[ref]) this.addSchema(_schema, ref, meta);
			}
			async function _loadSchema(ref) {
				const p = this._loading[ref];
				if (p) return p;
				try {
					return await (this._loading[ref] = loadSchema(ref));
				} finally {
					delete this._loading[ref];
				}
			}
		}
		addSchema(schema$1, key, _meta, _validateSchema = this.opts.validateSchema) {
			if (Array.isArray(schema$1)) {
				for (const sch of schema$1) this.addSchema(sch, void 0, _meta, _validateSchema);
				return this;
			}
			let id;
			if (typeof schema$1 === "object") {
				const { schemaId } = this.opts;
				id = schema$1[schemaId];
				if (id !== void 0 && typeof id != "string") throw new Error(`schema ${schemaId} must be string`);
			}
			key = (0, resolve_1.normalizeId)(key || id);
			this._checkUnique(key);
			this.schemas[key] = this._addSchema(schema$1, _meta, key, _validateSchema, true);
			return this;
		}
		addMetaSchema(schema$1, key, _validateSchema = this.opts.validateSchema) {
			this.addSchema(schema$1, key, true, _validateSchema);
			return this;
		}
		validateSchema(schema$1, throwOrLogError) {
			if (typeof schema$1 == "boolean") return true;
			let $schema;
			$schema = schema$1.$schema;
			if ($schema !== void 0 && typeof $schema != "string") throw new Error("$schema must be a string");
			$schema = $schema || this.opts.defaultMeta || this.defaultMeta();
			if (!$schema) {
				this.logger.warn("meta-schema not available");
				this.errors = null;
				return true;
			}
			const valid = this.validate($schema, schema$1);
			if (!valid && throwOrLogError) {
				const message = "schema is invalid: " + this.errorsText();
				if (this.opts.validateSchema === "log") this.logger.error(message);
				else throw new Error(message);
			}
			return valid;
		}
		getSchema(keyRef) {
			let sch;
			while (typeof (sch = getSchEnv.call(this, keyRef)) == "string") keyRef = sch;
			if (sch === void 0) {
				const { schemaId } = this.opts;
				const root = new compile_1$2.SchemaEnv({
					schema: {},
					schemaId
				});
				sch = compile_1$2.resolveSchema.call(this, root, keyRef);
				if (!sch) return;
				this.refs[keyRef] = sch;
			}
			return sch.validate || this._compileSchemaEnv(sch);
		}
		removeSchema(schemaKeyRef) {
			if (schemaKeyRef instanceof RegExp) {
				this._removeAllSchemas(this.schemas, schemaKeyRef);
				this._removeAllSchemas(this.refs, schemaKeyRef);
				return this;
			}
			switch (typeof schemaKeyRef) {
				case "undefined":
					this._removeAllSchemas(this.schemas);
					this._removeAllSchemas(this.refs);
					this._cache.clear();
					return this;
				case "string": {
					const sch = getSchEnv.call(this, schemaKeyRef);
					if (typeof sch == "object") this._cache.delete(sch.schema);
					delete this.schemas[schemaKeyRef];
					delete this.refs[schemaKeyRef];
					return this;
				}
				case "object": {
					const cacheKey = schemaKeyRef;
					this._cache.delete(cacheKey);
					let id = schemaKeyRef[this.opts.schemaId];
					if (id) {
						id = (0, resolve_1.normalizeId)(id);
						delete this.schemas[id];
						delete this.refs[id];
					}
					return this;
				}
				default: throw new Error("ajv.removeSchema: invalid parameter");
			}
		}
		addVocabulary(definitions) {
			for (const def$30 of definitions) this.addKeyword(def$30);
			return this;
		}
		addKeyword(kwdOrDef, def$30) {
			let keyword;
			if (typeof kwdOrDef == "string") {
				keyword = kwdOrDef;
				if (typeof def$30 == "object") {
					this.logger.warn("these parameters are deprecated, see docs for addKeyword");
					def$30.keyword = keyword;
				}
			} else if (typeof kwdOrDef == "object" && def$30 === void 0) {
				def$30 = kwdOrDef;
				keyword = def$30.keyword;
				if (Array.isArray(keyword) && !keyword.length) throw new Error("addKeywords: keyword must be string or non-empty array");
			} else throw new Error("invalid addKeywords parameters");
			checkKeyword.call(this, keyword, def$30);
			if (!def$30) {
				(0, util_1$21.eachItem)(keyword, (kwd) => addRule.call(this, kwd));
				return this;
			}
			keywordMetaschema.call(this, def$30);
			const definition = {
				...def$30,
				type: (0, dataType_1$1.getJSONTypes)(def$30.type),
				schemaType: (0, dataType_1$1.getJSONTypes)(def$30.schemaType)
			};
			(0, util_1$21.eachItem)(keyword, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t$1) => addRule.call(this, k, definition, t$1)));
			return this;
		}
		getKeyword(keyword) {
			const rule = this.RULES.all[keyword];
			return typeof rule == "object" ? rule.definition : !!rule;
		}
		removeKeyword(keyword) {
			const { RULES } = this;
			delete RULES.keywords[keyword];
			delete RULES.all[keyword];
			for (const group of RULES.rules) {
				const i = group.rules.findIndex((rule) => rule.keyword === keyword);
				if (i >= 0) group.rules.splice(i, 1);
			}
			return this;
		}
		addFormat(name, format$1) {
			if (typeof format$1 == "string") format$1 = new RegExp(format$1);
			this.formats[name] = format$1;
			return this;
		}
		errorsText(errors$1 = this.errors, { separator = ", ", dataVar = "data" } = {}) {
			if (!errors$1 || errors$1.length === 0) return "No errors";
			return errors$1.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);
		}
		$dataMetaSchema(metaSchema, keywordsJsonPointers) {
			const rules = this.RULES.all;
			metaSchema = JSON.parse(JSON.stringify(metaSchema));
			for (const jsonPointer of keywordsJsonPointers) {
				const segments = jsonPointer.split("/").slice(1);
				let keywords$1 = metaSchema;
				for (const seg of segments) keywords$1 = keywords$1[seg];
				for (const key in rules) {
					const rule = rules[key];
					if (typeof rule != "object") continue;
					const { $data } = rule.definition;
					const schema$1 = keywords$1[key];
					if ($data && schema$1) keywords$1[key] = schemaOrData(schema$1);
				}
			}
			return metaSchema;
		}
		_removeAllSchemas(schemas$1, regex) {
			for (const keyRef in schemas$1) {
				const sch = schemas$1[keyRef];
				if (!regex || regex.test(keyRef)) {
					if (typeof sch == "string") delete schemas$1[keyRef];
					else if (sch && !sch.meta) {
						this._cache.delete(sch.schema);
						delete schemas$1[keyRef];
					}
				}
			}
		}
		_addSchema(schema$1, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
			let id;
			const { schemaId } = this.opts;
			if (typeof schema$1 == "object") id = schema$1[schemaId];
			else if (this.opts.jtd) throw new Error("schema must be object");
			else if (typeof schema$1 != "boolean") throw new Error("schema must be object or boolean");
			let sch = this._cache.get(schema$1);
			if (sch !== void 0) return sch;
			baseId = (0, resolve_1.normalizeId)(id || baseId);
			const localRefs = resolve_1.getSchemaRefs.call(this, schema$1, baseId);
			sch = new compile_1$2.SchemaEnv({
				schema: schema$1,
				schemaId,
				meta,
				baseId,
				localRefs
			});
			this._cache.set(sch.schema, sch);
			if (addSchema && !baseId.startsWith("#")) {
				if (baseId) this._checkUnique(baseId);
				this.refs[baseId] = sch;
			}
			if (validateSchema) this.validateSchema(schema$1, true);
			return sch;
		}
		_checkUnique(id) {
			if (this.schemas[id] || this.refs[id]) throw new Error(`schema with key or id "${id}" already exists`);
		}
		_compileSchemaEnv(sch) {
			if (sch.meta) this._compileMetaSchema(sch);
			else compile_1$2.compileSchema.call(this, sch);
			/* istanbul ignore if */
			if (!sch.validate) throw new Error("ajv implementation error");
			return sch.validate;
		}
		_compileMetaSchema(sch) {
			const currentOpts = this.opts;
			this.opts = this._metaOpts;
			try {
				compile_1$2.compileSchema.call(this, sch);
			} finally {
				this.opts = currentOpts;
			}
		}
	};
	Ajv$2.ValidationError = validation_error_1$1.default;
	Ajv$2.MissingRefError = ref_error_1$3.default;
	exports.default = Ajv$2;
	function checkOptions(checkOpts, options, msg, log = "error") {
		for (const key in checkOpts) {
			const opt = key;
			if (opt in options) this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
		}
	}
	function getSchEnv(keyRef) {
		keyRef = (0, resolve_1.normalizeId)(keyRef);
		return this.schemas[keyRef] || this.refs[keyRef];
	}
	function addInitialSchemas() {
		const optsSchemas = this.opts.schemas;
		if (!optsSchemas) return;
		if (Array.isArray(optsSchemas)) this.addSchema(optsSchemas);
		else for (const key in optsSchemas) this.addSchema(optsSchemas[key], key);
	}
	function addInitialFormats() {
		for (const name in this.opts.formats) {
			const format$1 = this.opts.formats[name];
			if (format$1) this.addFormat(name, format$1);
		}
	}
	function addInitialKeywords(defs) {
		if (Array.isArray(defs)) {
			this.addVocabulary(defs);
			return;
		}
		this.logger.warn("keywords option as map is deprecated, pass array");
		for (const keyword in defs) {
			const def$30 = defs[keyword];
			if (!def$30.keyword) def$30.keyword = keyword;
			this.addKeyword(def$30);
		}
	}
	function getMetaSchemaOptions() {
		const metaOpts = { ...this.opts };
		for (const opt of META_IGNORE_OPTIONS) delete metaOpts[opt];
		return metaOpts;
	}
	const noLogs = {
		log() {},
		warn() {},
		error() {}
	};
	function getLogger(logger) {
		if (logger === false) return noLogs;
		if (logger === void 0) return console;
		if (logger.log && logger.warn && logger.error) return logger;
		throw new Error("logger must implement log, warn and error methods");
	}
	const KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
	function checkKeyword(keyword, def$30) {
		const { RULES } = this;
		(0, util_1$21.eachItem)(keyword, (kwd) => {
			if (RULES.keywords[kwd]) throw new Error(`Keyword ${kwd} is already defined`);
			if (!KEYWORD_NAME.test(kwd)) throw new Error(`Keyword ${kwd} has invalid name`);
		});
		if (!def$30) return;
		if (def$30.$data && !("code" in def$30 || "validate" in def$30)) throw new Error("$data keyword must have \"code\" or \"validate\" function");
	}
	function addRule(keyword, definition, dataType) {
		var _a$1;
		const post = definition === null || definition === void 0 ? void 0 : definition.post;
		if (dataType && post) throw new Error("keyword with \"post\" flag cannot have \"type\"");
		const { RULES } = this;
		let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t$1 }) => t$1 === dataType);
		if (!ruleGroup) {
			ruleGroup = {
				type: dataType,
				rules: []
			};
			RULES.rules.push(ruleGroup);
		}
		RULES.keywords[keyword] = true;
		if (!definition) return;
		const rule = {
			keyword,
			definition: {
				...definition,
				type: (0, dataType_1$1.getJSONTypes)(definition.type),
				schemaType: (0, dataType_1$1.getJSONTypes)(definition.schemaType)
			}
		};
		if (definition.before) addBeforeRule.call(this, ruleGroup, rule, definition.before);
		else ruleGroup.rules.push(rule);
		RULES.all[keyword] = rule;
		(_a$1 = definition.implements) === null || _a$1 === void 0 || _a$1.forEach((kwd) => this.addKeyword(kwd));
	}
	function addBeforeRule(ruleGroup, rule, before) {
		const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
		if (i >= 0) ruleGroup.rules.splice(i, 0, rule);
		else {
			ruleGroup.rules.push(rule);
			this.logger.warn(`rule ${before} is not defined`);
		}
	}
	function keywordMetaschema(def$30) {
		let { metaSchema } = def$30;
		if (metaSchema === void 0) return;
		if (def$30.$data && this.opts.$data) metaSchema = schemaOrData(metaSchema);
		def$30.validateSchema = this.compile(metaSchema, true);
	}
	const $dataRef = { $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" };
	function schemaOrData(schema$1) {
		return { anyOf: [schema$1, $dataRef] };
	}
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/core/id.js
var require_id = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/core/id.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const def$29 = {
		keyword: "id",
		code() {
			throw new Error("NOT SUPPORTED: keyword \"id\", use \"$id\" for schema ID");
		}
	};
	exports.default = def$29;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/core/ref.js
var require_ref = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/core/ref.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const ref_error_1$2 = require_ref_error();
	const code_1$8 = require_code();
	const codegen_1$23 = require_codegen();
	const names_1$1 = require_names();
	const compile_1$1 = require_compile();
	const util_1$20 = require_util();
	const def$28 = {
		keyword: "$ref",
		schemaType: "string",
		code(cxt) {
			const { gen, schema: $ref, it } = cxt;
			const { baseId, schemaEnv: env, validateName, opts, self } = it;
			const { root } = env;
			if (($ref === "#" || $ref === "#/") && baseId === root.baseId) return callRootRef();
			const schOrEnv = compile_1$1.resolveRef.call(self, root, baseId, $ref);
			if (schOrEnv === void 0) throw new ref_error_1$2.default(it.opts.uriResolver, baseId, $ref);
			if (schOrEnv instanceof compile_1$1.SchemaEnv) return callValidate(schOrEnv);
			return inlineRefSchema(schOrEnv);
			function callRootRef() {
				if (env === root) return callRef(cxt, validateName, env, env.$async);
				const rootName = gen.scopeValue("root", { ref: root });
				return callRef(cxt, (0, codegen_1$23._)`${rootName}.validate`, root, root.$async);
			}
			function callValidate(sch) {
				callRef(cxt, getValidate(cxt, sch), sch, sch.$async);
			}
			function inlineRefSchema(sch) {
				const schName = gen.scopeValue("schema", opts.code.source === true ? {
					ref: sch,
					code: (0, codegen_1$23.stringify)(sch)
				} : { ref: sch });
				const valid = gen.name("valid");
				const schCxt = cxt.subschema({
					schema: sch,
					dataTypes: [],
					schemaPath: codegen_1$23.nil,
					topSchemaRef: schName,
					errSchemaPath: $ref
				}, valid);
				cxt.mergeEvaluated(schCxt);
				cxt.ok(valid);
			}
		}
	};
	function getValidate(cxt, sch) {
		const { gen } = cxt;
		return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1$23._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
	}
	exports.getValidate = getValidate;
	function callRef(cxt, v, sch, $async) {
		const { gen, it } = cxt;
		const { allErrors, schemaEnv: env, opts } = it;
		const passCxt = opts.passContext ? names_1$1.default.this : codegen_1$23.nil;
		if ($async) callAsyncRef();
		else callSyncRef();
		function callAsyncRef() {
			if (!env.$async) throw new Error("async schema referenced by sync schema");
			const valid = gen.let("valid");
			gen.try(() => {
				gen.code((0, codegen_1$23._)`await ${(0, code_1$8.callValidateCode)(cxt, v, passCxt)}`);
				addEvaluatedFrom(v);
				if (!allErrors) gen.assign(valid, true);
			}, (e) => {
				gen.if((0, codegen_1$23._)`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
				addErrorsFrom(e);
				if (!allErrors) gen.assign(valid, false);
			});
			cxt.ok(valid);
		}
		function callSyncRef() {
			cxt.result((0, code_1$8.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
		}
		function addErrorsFrom(source) {
			const errs = (0, codegen_1$23._)`${source}.errors`;
			gen.assign(names_1$1.default.vErrors, (0, codegen_1$23._)`${names_1$1.default.vErrors} === null ? ${errs} : ${names_1$1.default.vErrors}.concat(${errs})`);
			gen.assign(names_1$1.default.errors, (0, codegen_1$23._)`${names_1$1.default.vErrors}.length`);
		}
		function addEvaluatedFrom(source) {
			var _a$1;
			if (!it.opts.unevaluated) return;
			const schEvaluated = (_a$1 = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a$1 === void 0 ? void 0 : _a$1.evaluated;
			if (it.props !== true) if (schEvaluated && !schEvaluated.dynamicProps) {
				if (schEvaluated.props !== void 0) it.props = util_1$20.mergeEvaluated.props(gen, schEvaluated.props, it.props);
			} else {
				const props = gen.var("props", (0, codegen_1$23._)`${source}.evaluated.props`);
				it.props = util_1$20.mergeEvaluated.props(gen, props, it.props, codegen_1$23.Name);
			}
			if (it.items !== true) if (schEvaluated && !schEvaluated.dynamicItems) {
				if (schEvaluated.items !== void 0) it.items = util_1$20.mergeEvaluated.items(gen, schEvaluated.items, it.items);
			} else {
				const items = gen.var("items", (0, codegen_1$23._)`${source}.evaluated.items`);
				it.items = util_1$20.mergeEvaluated.items(gen, items, it.items, codegen_1$23.Name);
			}
		}
	}
	exports.callRef = callRef;
	exports.default = def$28;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/core/index.js
var require_core = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/core/index.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const id_1 = require_id();
	const ref_1 = require_ref();
	const core = [
		"$schema",
		"$id",
		"$defs",
		"$vocabulary",
		{ keyword: "$comment" },
		"definitions",
		id_1.default,
		ref_1.default
	];
	exports.default = core;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/validation/limitNumber.js
var require_limitNumber = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/validation/limitNumber.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$22 = require_codegen();
	const ops = codegen_1$22.operators;
	const KWDs = {
		maximum: {
			okStr: "<=",
			ok: ops.LTE,
			fail: ops.GT
		},
		minimum: {
			okStr: ">=",
			ok: ops.GTE,
			fail: ops.LT
		},
		exclusiveMaximum: {
			okStr: "<",
			ok: ops.LT,
			fail: ops.GTE
		},
		exclusiveMinimum: {
			okStr: ">",
			ok: ops.GT,
			fail: ops.LTE
		}
	};
	const def$27 = {
		keyword: Object.keys(KWDs),
		type: "number",
		schemaType: "number",
		$data: true,
		error: {
			message: ({ keyword, schemaCode }) => (0, codegen_1$22.str)`must be ${KWDs[keyword].okStr} ${schemaCode}`,
			params: ({ keyword, schemaCode }) => (0, codegen_1$22._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
		},
		code(cxt) {
			const { keyword, data, schemaCode } = cxt;
			cxt.fail$data((0, codegen_1$22._)`${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
		}
	};
	exports.default = def$27;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/validation/multipleOf.js
var require_multipleOf = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/validation/multipleOf.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$21 = require_codegen();
	const def$26 = {
		keyword: "multipleOf",
		type: "number",
		schemaType: "number",
		$data: true,
		error: {
			message: ({ schemaCode }) => (0, codegen_1$21.str)`must be multiple of ${schemaCode}`,
			params: ({ schemaCode }) => (0, codegen_1$21._)`{multipleOf: ${schemaCode}}`
		},
		code(cxt) {
			const { gen, data, schemaCode, it } = cxt;
			const prec = it.opts.multipleOfPrecision;
			const res = gen.let("res");
			const invalid = prec ? (0, codegen_1$21._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1$21._)`${res} !== parseInt(${res})`;
			cxt.fail$data((0, codegen_1$21._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
		}
	};
	exports.default = def$26;
}) });

//#endregion
//#region ../node_modules/ajv/dist/runtime/ucs2length.js
var require_ucs2length = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/runtime/ucs2length.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	function ucs2length(str$1) {
		const len = str$1.length;
		let length = 0;
		let pos = 0;
		let value;
		while (pos < len) {
			length++;
			value = str$1.charCodeAt(pos++);
			if (value >= 55296 && value <= 56319 && pos < len) {
				value = str$1.charCodeAt(pos);
				if ((value & 64512) === 56320) pos++;
			}
		}
		return length;
	}
	exports.default = ucs2length;
	ucs2length.code = "require(\"ajv/dist/runtime/ucs2length\").default";
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/validation/limitLength.js
var require_limitLength = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/validation/limitLength.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$20 = require_codegen();
	const util_1$19 = require_util();
	const ucs2length_1 = require_ucs2length();
	const def$25 = {
		keyword: ["maxLength", "minLength"],
		type: "string",
		schemaType: "number",
		$data: true,
		error: {
			message({ keyword, schemaCode }) {
				const comp = keyword === "maxLength" ? "more" : "fewer";
				return (0, codegen_1$20.str)`must NOT have ${comp} than ${schemaCode} characters`;
			},
			params: ({ schemaCode }) => (0, codegen_1$20._)`{limit: ${schemaCode}}`
		},
		code(cxt) {
			const { keyword, data, schemaCode, it } = cxt;
			const op = keyword === "maxLength" ? codegen_1$20.operators.GT : codegen_1$20.operators.LT;
			const len = it.opts.unicode === false ? (0, codegen_1$20._)`${data}.length` : (0, codegen_1$20._)`${(0, util_1$19.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
			cxt.fail$data((0, codegen_1$20._)`${len} ${op} ${schemaCode}`);
		}
	};
	exports.default = def$25;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/validation/pattern.js
var require_pattern = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/validation/pattern.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const code_1$7 = require_code();
	const codegen_1$19 = require_codegen();
	const def$24 = {
		keyword: "pattern",
		type: "string",
		schemaType: "string",
		$data: true,
		error: {
			message: ({ schemaCode }) => (0, codegen_1$19.str)`must match pattern "${schemaCode}"`,
			params: ({ schemaCode }) => (0, codegen_1$19._)`{pattern: ${schemaCode}}`
		},
		code(cxt) {
			const { data, $data, schema: schema$1, schemaCode, it } = cxt;
			const u = it.opts.unicodeRegExp ? "u" : "";
			const regExp = $data ? (0, codegen_1$19._)`(new RegExp(${schemaCode}, ${u}))` : (0, code_1$7.usePattern)(cxt, schema$1);
			cxt.fail$data((0, codegen_1$19._)`!${regExp}.test(${data})`);
		}
	};
	exports.default = def$24;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/validation/limitProperties.js
var require_limitProperties = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/validation/limitProperties.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$18 = require_codegen();
	const def$23 = {
		keyword: ["maxProperties", "minProperties"],
		type: "object",
		schemaType: "number",
		$data: true,
		error: {
			message({ keyword, schemaCode }) {
				const comp = keyword === "maxProperties" ? "more" : "fewer";
				return (0, codegen_1$18.str)`must NOT have ${comp} than ${schemaCode} properties`;
			},
			params: ({ schemaCode }) => (0, codegen_1$18._)`{limit: ${schemaCode}}`
		},
		code(cxt) {
			const { keyword, data, schemaCode } = cxt;
			const op = keyword === "maxProperties" ? codegen_1$18.operators.GT : codegen_1$18.operators.LT;
			cxt.fail$data((0, codegen_1$18._)`Object.keys(${data}).length ${op} ${schemaCode}`);
		}
	};
	exports.default = def$23;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/validation/required.js
var require_required = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/validation/required.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const code_1$6 = require_code();
	const codegen_1$17 = require_codegen();
	const util_1$18 = require_util();
	const def$22 = {
		keyword: "required",
		type: "object",
		schemaType: "array",
		$data: true,
		error: {
			message: ({ params: { missingProperty } }) => (0, codegen_1$17.str)`must have required property '${missingProperty}'`,
			params: ({ params: { missingProperty } }) => (0, codegen_1$17._)`{missingProperty: ${missingProperty}}`
		},
		code(cxt) {
			const { gen, schema: schema$1, schemaCode, data, $data, it } = cxt;
			const { opts } = it;
			if (!$data && schema$1.length === 0) return;
			const useLoop = schema$1.length >= opts.loopRequired;
			if (it.allErrors) allErrorsMode();
			else exitOnErrorMode();
			if (opts.strictRequired) {
				const props = cxt.parentSchema.properties;
				const { definedProperties } = cxt.it;
				for (const requiredKey of schema$1) if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
					const msg = `required property "${requiredKey}" is not defined at "${it.schemaEnv.baseId + it.errSchemaPath}" (strictRequired)`;
					(0, util_1$18.checkStrictMode)(it, msg, it.opts.strictRequired);
				}
			}
			function allErrorsMode() {
				if (useLoop || $data) cxt.block$data(codegen_1$17.nil, loopAllRequired);
				else for (const prop of schema$1) (0, code_1$6.checkReportMissingProp)(cxt, prop);
			}
			function exitOnErrorMode() {
				const missing = gen.let("missing");
				if (useLoop || $data) {
					const valid = gen.let("valid", true);
					cxt.block$data(valid, () => loopUntilMissing(missing, valid));
					cxt.ok(valid);
				} else {
					gen.if((0, code_1$6.checkMissingProp)(cxt, schema$1, missing));
					(0, code_1$6.reportMissingProp)(cxt, missing);
					gen.else();
				}
			}
			function loopAllRequired() {
				gen.forOf("prop", schemaCode, (prop) => {
					cxt.setParams({ missingProperty: prop });
					gen.if((0, code_1$6.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
				});
			}
			function loopUntilMissing(missing, valid) {
				cxt.setParams({ missingProperty: missing });
				gen.forOf(missing, schemaCode, () => {
					gen.assign(valid, (0, code_1$6.propertyInData)(gen, data, missing, opts.ownProperties));
					gen.if((0, codegen_1$17.not)(valid), () => {
						cxt.error();
						gen.break();
					});
				}, codegen_1$17.nil);
			}
		}
	};
	exports.default = def$22;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/validation/limitItems.js
var require_limitItems = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/validation/limitItems.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$16 = require_codegen();
	const def$21 = {
		keyword: ["maxItems", "minItems"],
		type: "array",
		schemaType: "number",
		$data: true,
		error: {
			message({ keyword, schemaCode }) {
				const comp = keyword === "maxItems" ? "more" : "fewer";
				return (0, codegen_1$16.str)`must NOT have ${comp} than ${schemaCode} items`;
			},
			params: ({ schemaCode }) => (0, codegen_1$16._)`{limit: ${schemaCode}}`
		},
		code(cxt) {
			const { keyword, data, schemaCode } = cxt;
			const op = keyword === "maxItems" ? codegen_1$16.operators.GT : codegen_1$16.operators.LT;
			cxt.fail$data((0, codegen_1$16._)`${data}.length ${op} ${schemaCode}`);
		}
	};
	exports.default = def$21;
}) });

//#endregion
//#region ../node_modules/ajv/dist/runtime/equal.js
var require_equal = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/runtime/equal.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const equal = require_fast_deep_equal();
	equal.code = "require(\"ajv/dist/runtime/equal\").default";
	exports.default = equal;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/validation/uniqueItems.js
var require_uniqueItems = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/validation/uniqueItems.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const dataType_1 = require_dataType();
	const codegen_1$15 = require_codegen();
	const util_1$17 = require_util();
	const equal_1$2 = require_equal();
	const def$20 = {
		keyword: "uniqueItems",
		type: "array",
		schemaType: "boolean",
		$data: true,
		error: {
			message: ({ params: { i, j } }) => (0, codegen_1$15.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
			params: ({ params: { i, j } }) => (0, codegen_1$15._)`{i: ${i}, j: ${j}}`
		},
		code(cxt) {
			const { gen, data, $data, schema: schema$1, parentSchema, schemaCode, it } = cxt;
			if (!$data && !schema$1) return;
			const valid = gen.let("valid");
			const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
			cxt.block$data(valid, validateUniqueItems, (0, codegen_1$15._)`${schemaCode} === false`);
			cxt.ok(valid);
			function validateUniqueItems() {
				const i = gen.let("i", (0, codegen_1$15._)`${data}.length`);
				const j = gen.let("j");
				cxt.setParams({
					i,
					j
				});
				gen.assign(valid, true);
				gen.if((0, codegen_1$15._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
			}
			function canOptimize() {
				return itemTypes.length > 0 && !itemTypes.some((t$1) => t$1 === "object" || t$1 === "array");
			}
			function loopN(i, j) {
				const item = gen.name("item");
				const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
				const indices = gen.const("indices", (0, codegen_1$15._)`{}`);
				gen.for((0, codegen_1$15._)`;${i}--;`, () => {
					gen.let(item, (0, codegen_1$15._)`${data}[${i}]`);
					gen.if(wrongType, (0, codegen_1$15._)`continue`);
					if (itemTypes.length > 1) gen.if((0, codegen_1$15._)`typeof ${item} == "string"`, (0, codegen_1$15._)`${item} += "_"`);
					gen.if((0, codegen_1$15._)`typeof ${indices}[${item}] == "number"`, () => {
						gen.assign(j, (0, codegen_1$15._)`${indices}[${item}]`);
						cxt.error();
						gen.assign(valid, false).break();
					}).code((0, codegen_1$15._)`${indices}[${item}] = ${i}`);
				});
			}
			function loopN2(i, j) {
				const eql = (0, util_1$17.useFunc)(gen, equal_1$2.default);
				const outer = gen.name("outer");
				gen.label(outer).for((0, codegen_1$15._)`;${i}--;`, () => gen.for((0, codegen_1$15._)`${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1$15._)`${eql}(${data}[${i}], ${data}[${j}])`, () => {
					cxt.error();
					gen.assign(valid, false).break(outer);
				})));
			}
		}
	};
	exports.default = def$20;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/validation/const.js
var require_const = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/validation/const.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$14 = require_codegen();
	const util_1$16 = require_util();
	const equal_1$1 = require_equal();
	const def$19 = {
		keyword: "const",
		$data: true,
		error: {
			message: "must be equal to constant",
			params: ({ schemaCode }) => (0, codegen_1$14._)`{allowedValue: ${schemaCode}}`
		},
		code(cxt) {
			const { gen, data, $data, schemaCode, schema: schema$1 } = cxt;
			if ($data || schema$1 && typeof schema$1 == "object") cxt.fail$data((0, codegen_1$14._)`!${(0, util_1$16.useFunc)(gen, equal_1$1.default)}(${data}, ${schemaCode})`);
			else cxt.fail((0, codegen_1$14._)`${schema$1} !== ${data}`);
		}
	};
	exports.default = def$19;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/validation/enum.js
var require_enum = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/validation/enum.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$13 = require_codegen();
	const util_1$15 = require_util();
	const equal_1 = require_equal();
	const def$18 = {
		keyword: "enum",
		schemaType: "array",
		$data: true,
		error: {
			message: "must be equal to one of the allowed values",
			params: ({ schemaCode }) => (0, codegen_1$13._)`{allowedValues: ${schemaCode}}`
		},
		code(cxt) {
			const { gen, data, $data, schema: schema$1, schemaCode, it } = cxt;
			if (!$data && schema$1.length === 0) throw new Error("enum must have non-empty array");
			const useLoop = schema$1.length >= it.opts.loopEnum;
			let eql;
			const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1$15.useFunc)(gen, equal_1.default);
			let valid;
			if (useLoop || $data) {
				valid = gen.let("valid");
				cxt.block$data(valid, loopEnum);
			} else {
				/* istanbul ignore if */
				if (!Array.isArray(schema$1)) throw new Error("ajv implementation error");
				const vSchema = gen.const("vSchema", schemaCode);
				valid = (0, codegen_1$13.or)(...schema$1.map((_x, i) => equalCode(vSchema, i)));
			}
			cxt.pass(valid);
			function loopEnum() {
				gen.assign(valid, false);
				gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1$13._)`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));
			}
			function equalCode(vSchema, i) {
				const sch = schema$1[i];
				return typeof sch === "object" && sch !== null ? (0, codegen_1$13._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1$13._)`${data} === ${sch}`;
			}
		}
	};
	exports.default = def$18;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/validation/index.js
var require_validation = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/validation/index.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const limitNumber_1 = require_limitNumber();
	const multipleOf_1 = require_multipleOf();
	const limitLength_1 = require_limitLength();
	const pattern_1 = require_pattern();
	const limitProperties_1 = require_limitProperties();
	const required_1 = require_required();
	const limitItems_1 = require_limitItems();
	const uniqueItems_1 = require_uniqueItems();
	const const_1 = require_const();
	const enum_1 = require_enum();
	const validation = [
		limitNumber_1.default,
		multipleOf_1.default,
		limitLength_1.default,
		pattern_1.default,
		limitProperties_1.default,
		required_1.default,
		limitItems_1.default,
		uniqueItems_1.default,
		{
			keyword: "type",
			schemaType: ["string", "array"]
		},
		{
			keyword: "nullable",
			schemaType: "boolean"
		},
		const_1.default,
		enum_1.default
	];
	exports.default = validation;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/applicator/additionalItems.js
var require_additionalItems = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/applicator/additionalItems.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$12 = require_codegen();
	const util_1$14 = require_util();
	const def$17 = {
		keyword: "additionalItems",
		type: "array",
		schemaType: ["boolean", "object"],
		before: "uniqueItems",
		error: {
			message: ({ params: { len } }) => (0, codegen_1$12.str)`must NOT have more than ${len} items`,
			params: ({ params: { len } }) => (0, codegen_1$12._)`{limit: ${len}}`
		},
		code(cxt) {
			const { parentSchema, it } = cxt;
			const { items } = parentSchema;
			if (!Array.isArray(items)) {
				(0, util_1$14.checkStrictMode)(it, "\"additionalItems\" is ignored when \"items\" is not an array of schemas");
				return;
			}
			validateAdditionalItems(cxt, items);
		}
	};
	function validateAdditionalItems(cxt, items) {
		const { gen, schema: schema$1, data, keyword, it } = cxt;
		it.items = true;
		const len = gen.const("len", (0, codegen_1$12._)`${data}.length`);
		if (schema$1 === false) {
			cxt.setParams({ len: items.length });
			cxt.pass((0, codegen_1$12._)`${len} <= ${items.length}`);
		} else if (typeof schema$1 == "object" && !(0, util_1$14.alwaysValidSchema)(it, schema$1)) {
			const valid = gen.var("valid", (0, codegen_1$12._)`${len} <= ${items.length}`);
			gen.if((0, codegen_1$12.not)(valid), () => validateItems(valid));
			cxt.ok(valid);
		}
		function validateItems(valid) {
			gen.forRange("i", items.length, len, (i) => {
				cxt.subschema({
					keyword,
					dataProp: i,
					dataPropType: util_1$14.Type.Num
				}, valid);
				if (!it.allErrors) gen.if((0, codegen_1$12.not)(valid), () => gen.break());
			});
		}
	}
	exports.validateAdditionalItems = validateAdditionalItems;
	exports.default = def$17;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/applicator/items.js
var require_items = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/applicator/items.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$11 = require_codegen();
	const util_1$13 = require_util();
	const code_1$5 = require_code();
	const def$16 = {
		keyword: "items",
		type: "array",
		schemaType: [
			"object",
			"array",
			"boolean"
		],
		before: "uniqueItems",
		code(cxt) {
			const { schema: schema$1, it } = cxt;
			if (Array.isArray(schema$1)) return validateTuple(cxt, "additionalItems", schema$1);
			it.items = true;
			if ((0, util_1$13.alwaysValidSchema)(it, schema$1)) return;
			cxt.ok((0, code_1$5.validateArray)(cxt));
		}
	};
	function validateTuple(cxt, extraItems, schArr = cxt.schema) {
		const { gen, parentSchema, data, keyword, it } = cxt;
		checkStrictTuple(parentSchema);
		if (it.opts.unevaluated && schArr.length && it.items !== true) it.items = util_1$13.mergeEvaluated.items(gen, schArr.length, it.items);
		const valid = gen.name("valid");
		const len = gen.const("len", (0, codegen_1$11._)`${data}.length`);
		schArr.forEach((sch, i) => {
			if ((0, util_1$13.alwaysValidSchema)(it, sch)) return;
			gen.if((0, codegen_1$11._)`${len} > ${i}`, () => cxt.subschema({
				keyword,
				schemaProp: i,
				dataProp: i
			}, valid));
			cxt.ok(valid);
		});
		function checkStrictTuple(sch) {
			const { opts, errSchemaPath } = it;
			const l = schArr.length;
			const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
			if (opts.strictTuples && !fullTuple) {
				const msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
				(0, util_1$13.checkStrictMode)(it, msg, opts.strictTuples);
			}
		}
	}
	exports.validateTuple = validateTuple;
	exports.default = def$16;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/applicator/prefixItems.js
var require_prefixItems = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/applicator/prefixItems.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const items_1$1 = require_items();
	const def$15 = {
		keyword: "prefixItems",
		type: "array",
		schemaType: ["array"],
		before: "uniqueItems",
		code: (cxt) => (0, items_1$1.validateTuple)(cxt, "items")
	};
	exports.default = def$15;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/applicator/items2020.js
var require_items2020 = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/applicator/items2020.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$10 = require_codegen();
	const util_1$12 = require_util();
	const code_1$4 = require_code();
	const additionalItems_1$1 = require_additionalItems();
	const def$14 = {
		keyword: "items",
		type: "array",
		schemaType: ["object", "boolean"],
		before: "uniqueItems",
		error: {
			message: ({ params: { len } }) => (0, codegen_1$10.str)`must NOT have more than ${len} items`,
			params: ({ params: { len } }) => (0, codegen_1$10._)`{limit: ${len}}`
		},
		code(cxt) {
			const { schema: schema$1, parentSchema, it } = cxt;
			const { prefixItems } = parentSchema;
			it.items = true;
			if ((0, util_1$12.alwaysValidSchema)(it, schema$1)) return;
			if (prefixItems) (0, additionalItems_1$1.validateAdditionalItems)(cxt, prefixItems);
			else cxt.ok((0, code_1$4.validateArray)(cxt));
		}
	};
	exports.default = def$14;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/applicator/contains.js
var require_contains = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/applicator/contains.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$9 = require_codegen();
	const util_1$11 = require_util();
	const def$13 = {
		keyword: "contains",
		type: "array",
		schemaType: ["object", "boolean"],
		before: "uniqueItems",
		trackErrors: true,
		error: {
			message: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1$9.str)`must contain at least ${min} valid item(s)` : (0, codegen_1$9.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
			params: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1$9._)`{minContains: ${min}}` : (0, codegen_1$9._)`{minContains: ${min}, maxContains: ${max}}`
		},
		code(cxt) {
			const { gen, schema: schema$1, parentSchema, data, it } = cxt;
			let min;
			let max;
			const { minContains, maxContains } = parentSchema;
			if (it.opts.next) {
				min = minContains === void 0 ? 1 : minContains;
				max = maxContains;
			} else min = 1;
			const len = gen.const("len", (0, codegen_1$9._)`${data}.length`);
			cxt.setParams({
				min,
				max
			});
			if (max === void 0 && min === 0) {
				(0, util_1$11.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
				return;
			}
			if (max !== void 0 && min > max) {
				(0, util_1$11.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
				cxt.fail();
				return;
			}
			if ((0, util_1$11.alwaysValidSchema)(it, schema$1)) {
				let cond = (0, codegen_1$9._)`${len} >= ${min}`;
				if (max !== void 0) cond = (0, codegen_1$9._)`${cond} && ${len} <= ${max}`;
				cxt.pass(cond);
				return;
			}
			it.items = true;
			const valid = gen.name("valid");
			if (max === void 0 && min === 1) validateItems(valid, () => gen.if(valid, () => gen.break()));
			else if (min === 0) {
				gen.let(valid, true);
				if (max !== void 0) gen.if((0, codegen_1$9._)`${data}.length > 0`, validateItemsWithCount);
			} else {
				gen.let(valid, false);
				validateItemsWithCount();
			}
			cxt.result(valid, () => cxt.reset());
			function validateItemsWithCount() {
				const schValid = gen.name("_valid");
				const count = gen.let("count", 0);
				validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
			}
			function validateItems(_valid, block) {
				gen.forRange("i", 0, len, (i) => {
					cxt.subschema({
						keyword: "contains",
						dataProp: i,
						dataPropType: util_1$11.Type.Num,
						compositeRule: true
					}, _valid);
					block();
				});
			}
			function checkLimits(count) {
				gen.code((0, codegen_1$9._)`${count}++`);
				if (max === void 0) gen.if((0, codegen_1$9._)`${count} >= ${min}`, () => gen.assign(valid, true).break());
				else {
					gen.if((0, codegen_1$9._)`${count} > ${max}`, () => gen.assign(valid, false).break());
					if (min === 1) gen.assign(valid, true);
					else gen.if((0, codegen_1$9._)`${count} >= ${min}`, () => gen.assign(valid, true));
				}
			}
		}
	};
	exports.default = def$13;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/applicator/dependencies.js
var require_dependencies = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/applicator/dependencies.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;
	const codegen_1$8 = require_codegen();
	const util_1$10 = require_util();
	const code_1$3 = require_code();
	exports.error = {
		message: ({ params: { property, depsCount, deps } }) => {
			const property_ies = depsCount === 1 ? "property" : "properties";
			return (0, codegen_1$8.str)`must have ${property_ies} ${deps} when property ${property} is present`;
		},
		params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1$8._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
	};
	const def$12 = {
		keyword: "dependencies",
		type: "object",
		schemaType: "object",
		error: exports.error,
		code(cxt) {
			const [propDeps, schDeps] = splitDependencies(cxt);
			validatePropertyDeps(cxt, propDeps);
			validateSchemaDeps(cxt, schDeps);
		}
	};
	function splitDependencies({ schema: schema$1 }) {
		const propertyDeps = {};
		const schemaDeps = {};
		for (const key in schema$1) {
			if (key === "__proto__") continue;
			const deps = Array.isArray(schema$1[key]) ? propertyDeps : schemaDeps;
			deps[key] = schema$1[key];
		}
		return [propertyDeps, schemaDeps];
	}
	function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
		const { gen, data, it } = cxt;
		if (Object.keys(propertyDeps).length === 0) return;
		const missing = gen.let("missing");
		for (const prop in propertyDeps) {
			const deps = propertyDeps[prop];
			if (deps.length === 0) continue;
			const hasProperty = (0, code_1$3.propertyInData)(gen, data, prop, it.opts.ownProperties);
			cxt.setParams({
				property: prop,
				depsCount: deps.length,
				deps: deps.join(", ")
			});
			if (it.allErrors) gen.if(hasProperty, () => {
				for (const depProp of deps) (0, code_1$3.checkReportMissingProp)(cxt, depProp);
			});
			else {
				gen.if((0, codegen_1$8._)`${hasProperty} && (${(0, code_1$3.checkMissingProp)(cxt, deps, missing)})`);
				(0, code_1$3.reportMissingProp)(cxt, missing);
				gen.else();
			}
		}
	}
	exports.validatePropertyDeps = validatePropertyDeps;
	function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
		const { gen, data, keyword, it } = cxt;
		const valid = gen.name("valid");
		for (const prop in schemaDeps) {
			if ((0, util_1$10.alwaysValidSchema)(it, schemaDeps[prop])) continue;
			gen.if((0, code_1$3.propertyInData)(gen, data, prop, it.opts.ownProperties), () => {
				const schCxt = cxt.subschema({
					keyword,
					schemaProp: prop
				}, valid);
				cxt.mergeValidEvaluated(schCxt, valid);
			}, () => gen.var(valid, true));
			cxt.ok(valid);
		}
	}
	exports.validateSchemaDeps = validateSchemaDeps;
	exports.default = def$12;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/applicator/propertyNames.js
var require_propertyNames = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/applicator/propertyNames.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$7 = require_codegen();
	const util_1$9 = require_util();
	const def$11 = {
		keyword: "propertyNames",
		type: "object",
		schemaType: ["object", "boolean"],
		error: {
			message: "property name must be valid",
			params: ({ params }) => (0, codegen_1$7._)`{propertyName: ${params.propertyName}}`
		},
		code(cxt) {
			const { gen, schema: schema$1, data, it } = cxt;
			if ((0, util_1$9.alwaysValidSchema)(it, schema$1)) return;
			const valid = gen.name("valid");
			gen.forIn("key", data, (key) => {
				cxt.setParams({ propertyName: key });
				cxt.subschema({
					keyword: "propertyNames",
					data: key,
					dataTypes: ["string"],
					propertyName: key,
					compositeRule: true
				}, valid);
				gen.if((0, codegen_1$7.not)(valid), () => {
					cxt.error(true);
					if (!it.allErrors) gen.break();
				});
			});
			cxt.ok(valid);
		}
	};
	exports.default = def$11;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js
var require_additionalProperties = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const code_1$2 = require_code();
	const codegen_1$6 = require_codegen();
	const names_1 = require_names();
	const util_1$8 = require_util();
	const def$10 = {
		keyword: "additionalProperties",
		type: ["object"],
		schemaType: ["boolean", "object"],
		allowUndefined: true,
		trackErrors: true,
		error: {
			message: "must NOT have additional properties",
			params: ({ params }) => (0, codegen_1$6._)`{additionalProperty: ${params.additionalProperty}}`
		},
		code(cxt) {
			const { gen, schema: schema$1, parentSchema, data, errsCount, it } = cxt;
			/* istanbul ignore if */
			if (!errsCount) throw new Error("ajv implementation error");
			const { allErrors, opts } = it;
			it.props = true;
			if (opts.removeAdditional !== "all" && (0, util_1$8.alwaysValidSchema)(it, schema$1)) return;
			const props = (0, code_1$2.allSchemaProperties)(parentSchema.properties);
			const patProps = (0, code_1$2.allSchemaProperties)(parentSchema.patternProperties);
			checkAdditionalProperties();
			cxt.ok((0, codegen_1$6._)`${errsCount} === ${names_1.default.errors}`);
			function checkAdditionalProperties() {
				gen.forIn("key", data, (key) => {
					if (!props.length && !patProps.length) additionalPropertyCode(key);
					else gen.if(isAdditional(key), () => additionalPropertyCode(key));
				});
			}
			function isAdditional(key) {
				let definedProp;
				if (props.length > 8) {
					const propsSchema = (0, util_1$8.schemaRefOrVal)(it, parentSchema.properties, "properties");
					definedProp = (0, code_1$2.isOwnProperty)(gen, propsSchema, key);
				} else if (props.length) definedProp = (0, codegen_1$6.or)(...props.map((p) => (0, codegen_1$6._)`${key} === ${p}`));
				else definedProp = codegen_1$6.nil;
				if (patProps.length) definedProp = (0, codegen_1$6.or)(definedProp, ...patProps.map((p) => (0, codegen_1$6._)`${(0, code_1$2.usePattern)(cxt, p)}.test(${key})`));
				return (0, codegen_1$6.not)(definedProp);
			}
			function deleteAdditional(key) {
				gen.code((0, codegen_1$6._)`delete ${data}[${key}]`);
			}
			function additionalPropertyCode(key) {
				if (opts.removeAdditional === "all" || opts.removeAdditional && schema$1 === false) {
					deleteAdditional(key);
					return;
				}
				if (schema$1 === false) {
					cxt.setParams({ additionalProperty: key });
					cxt.error();
					if (!allErrors) gen.break();
					return;
				}
				if (typeof schema$1 == "object" && !(0, util_1$8.alwaysValidSchema)(it, schema$1)) {
					const valid = gen.name("valid");
					if (opts.removeAdditional === "failing") {
						applyAdditionalSchema(key, valid, false);
						gen.if((0, codegen_1$6.not)(valid), () => {
							cxt.reset();
							deleteAdditional(key);
						});
					} else {
						applyAdditionalSchema(key, valid);
						if (!allErrors) gen.if((0, codegen_1$6.not)(valid), () => gen.break());
					}
				}
			}
			function applyAdditionalSchema(key, valid, errors$1) {
				const subschema = {
					keyword: "additionalProperties",
					dataProp: key,
					dataPropType: util_1$8.Type.Str
				};
				if (errors$1 === false) Object.assign(subschema, {
					compositeRule: true,
					createErrors: false,
					allErrors: false
				});
				cxt.subschema(subschema, valid);
			}
		}
	};
	exports.default = def$10;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/applicator/properties.js
var require_properties = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/applicator/properties.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const validate_1$1 = require_validate();
	const code_1$1 = require_code();
	const util_1$7 = require_util();
	const additionalProperties_1$1 = require_additionalProperties();
	const def$9 = {
		keyword: "properties",
		type: "object",
		schemaType: "object",
		code(cxt) {
			const { gen, schema: schema$1, parentSchema, data, it } = cxt;
			if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) additionalProperties_1$1.default.code(new validate_1$1.KeywordCxt(it, additionalProperties_1$1.default, "additionalProperties"));
			const allProps = (0, code_1$1.allSchemaProperties)(schema$1);
			for (const prop of allProps) it.definedProperties.add(prop);
			if (it.opts.unevaluated && allProps.length && it.props !== true) it.props = util_1$7.mergeEvaluated.props(gen, (0, util_1$7.toHash)(allProps), it.props);
			const properties = allProps.filter((p) => !(0, util_1$7.alwaysValidSchema)(it, schema$1[p]));
			if (properties.length === 0) return;
			const valid = gen.name("valid");
			for (const prop of properties) {
				if (hasDefault(prop)) applyPropertySchema(prop);
				else {
					gen.if((0, code_1$1.propertyInData)(gen, data, prop, it.opts.ownProperties));
					applyPropertySchema(prop);
					if (!it.allErrors) gen.else().var(valid, true);
					gen.endIf();
				}
				cxt.it.definedProperties.add(prop);
				cxt.ok(valid);
			}
			function hasDefault(prop) {
				return it.opts.useDefaults && !it.compositeRule && schema$1[prop].default !== void 0;
			}
			function applyPropertySchema(prop) {
				cxt.subschema({
					keyword: "properties",
					schemaProp: prop,
					dataProp: prop
				}, valid);
			}
		}
	};
	exports.default = def$9;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/applicator/patternProperties.js
var require_patternProperties = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/applicator/patternProperties.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const code_1 = require_code();
	const codegen_1$5 = require_codegen();
	const util_1$6 = require_util();
	const util_2 = require_util();
	const def$8 = {
		keyword: "patternProperties",
		type: "object",
		schemaType: "object",
		code(cxt) {
			const { gen, schema: schema$1, data, parentSchema, it } = cxt;
			const { opts } = it;
			const patterns = (0, code_1.allSchemaProperties)(schema$1);
			const alwaysValidPatterns = patterns.filter((p) => (0, util_1$6.alwaysValidSchema)(it, schema$1[p]));
			if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) return;
			const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
			const valid = gen.name("valid");
			if (it.props !== true && !(it.props instanceof codegen_1$5.Name)) it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
			const { props } = it;
			validatePatternProperties();
			function validatePatternProperties() {
				for (const pat of patterns) {
					if (checkProperties) checkMatchingProperties(pat);
					if (it.allErrors) validateProperties(pat);
					else {
						gen.var(valid, true);
						validateProperties(pat);
						gen.if(valid);
					}
				}
			}
			function checkMatchingProperties(pat) {
				for (const prop in checkProperties) if (new RegExp(pat).test(prop)) (0, util_1$6.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
			}
			function validateProperties(pat) {
				gen.forIn("key", data, (key) => {
					gen.if((0, codegen_1$5._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
						const alwaysValid = alwaysValidPatterns.includes(pat);
						if (!alwaysValid) cxt.subschema({
							keyword: "patternProperties",
							schemaProp: pat,
							dataProp: key,
							dataPropType: util_2.Type.Str
						}, valid);
						if (it.opts.unevaluated && props !== true) gen.assign((0, codegen_1$5._)`${props}[${key}]`, true);
						else if (!alwaysValid && !it.allErrors) gen.if((0, codegen_1$5.not)(valid), () => gen.break());
					});
				});
			}
		}
	};
	exports.default = def$8;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/applicator/not.js
var require_not = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/applicator/not.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const util_1$5 = require_util();
	const def$7 = {
		keyword: "not",
		schemaType: ["object", "boolean"],
		trackErrors: true,
		code(cxt) {
			const { gen, schema: schema$1, it } = cxt;
			if ((0, util_1$5.alwaysValidSchema)(it, schema$1)) {
				cxt.fail();
				return;
			}
			const valid = gen.name("valid");
			cxt.subschema({
				keyword: "not",
				compositeRule: true,
				createErrors: false,
				allErrors: false
			}, valid);
			cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
		},
		error: { message: "must NOT be valid" }
	};
	exports.default = def$7;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/applicator/anyOf.js
var require_anyOf = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/applicator/anyOf.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const def$6 = {
		keyword: "anyOf",
		schemaType: "array",
		trackErrors: true,
		code: require_code().validateUnion,
		error: { message: "must match a schema in anyOf" }
	};
	exports.default = def$6;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/applicator/oneOf.js
var require_oneOf = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/applicator/oneOf.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$4 = require_codegen();
	const util_1$4 = require_util();
	const def$5 = {
		keyword: "oneOf",
		schemaType: "array",
		trackErrors: true,
		error: {
			message: "must match exactly one schema in oneOf",
			params: ({ params }) => (0, codegen_1$4._)`{passingSchemas: ${params.passing}}`
		},
		code(cxt) {
			const { gen, schema: schema$1, parentSchema, it } = cxt;
			/* istanbul ignore if */
			if (!Array.isArray(schema$1)) throw new Error("ajv implementation error");
			if (it.opts.discriminator && parentSchema.discriminator) return;
			const schArr = schema$1;
			const valid = gen.let("valid", false);
			const passing = gen.let("passing", null);
			const schValid = gen.name("_valid");
			cxt.setParams({ passing });
			gen.block(validateOneOf);
			cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
			function validateOneOf() {
				schArr.forEach((sch, i) => {
					let schCxt;
					if ((0, util_1$4.alwaysValidSchema)(it, sch)) gen.var(schValid, true);
					else schCxt = cxt.subschema({
						keyword: "oneOf",
						schemaProp: i,
						compositeRule: true
					}, schValid);
					if (i > 0) gen.if((0, codegen_1$4._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1$4._)`[${passing}, ${i}]`).else();
					gen.if(schValid, () => {
						gen.assign(valid, true);
						gen.assign(passing, i);
						if (schCxt) cxt.mergeEvaluated(schCxt, codegen_1$4.Name);
					});
				});
			}
		}
	};
	exports.default = def$5;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/applicator/allOf.js
var require_allOf = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/applicator/allOf.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const util_1$3 = require_util();
	const def$4 = {
		keyword: "allOf",
		schemaType: "array",
		code(cxt) {
			const { gen, schema: schema$1, it } = cxt;
			/* istanbul ignore if */
			if (!Array.isArray(schema$1)) throw new Error("ajv implementation error");
			const valid = gen.name("valid");
			schema$1.forEach((sch, i) => {
				if ((0, util_1$3.alwaysValidSchema)(it, sch)) return;
				const schCxt = cxt.subschema({
					keyword: "allOf",
					schemaProp: i
				}, valid);
				cxt.ok(valid);
				cxt.mergeEvaluated(schCxt);
			});
		}
	};
	exports.default = def$4;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/applicator/if.js
var require_if = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/applicator/if.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$3 = require_codegen();
	const util_1$2 = require_util();
	const def$3 = {
		keyword: "if",
		schemaType: ["object", "boolean"],
		trackErrors: true,
		error: {
			message: ({ params }) => (0, codegen_1$3.str)`must match "${params.ifClause}" schema`,
			params: ({ params }) => (0, codegen_1$3._)`{failingKeyword: ${params.ifClause}}`
		},
		code(cxt) {
			const { gen, parentSchema, it } = cxt;
			if (parentSchema.then === void 0 && parentSchema.else === void 0) (0, util_1$2.checkStrictMode)(it, "\"if\" without \"then\" and \"else\" is ignored");
			const hasThen = hasSchema(it, "then");
			const hasElse = hasSchema(it, "else");
			if (!hasThen && !hasElse) return;
			const valid = gen.let("valid", true);
			const schValid = gen.name("_valid");
			validateIf();
			cxt.reset();
			if (hasThen && hasElse) {
				const ifClause = gen.let("ifClause");
				cxt.setParams({ ifClause });
				gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
			} else if (hasThen) gen.if(schValid, validateClause("then"));
			else gen.if((0, codegen_1$3.not)(schValid), validateClause("else"));
			cxt.pass(valid, () => cxt.error(true));
			function validateIf() {
				const schCxt = cxt.subschema({
					keyword: "if",
					compositeRule: true,
					createErrors: false,
					allErrors: false
				}, schValid);
				cxt.mergeEvaluated(schCxt);
			}
			function validateClause(keyword, ifClause) {
				return () => {
					const schCxt = cxt.subschema({ keyword }, schValid);
					gen.assign(valid, schValid);
					cxt.mergeValidEvaluated(schCxt, valid);
					if (ifClause) gen.assign(ifClause, (0, codegen_1$3._)`${keyword}`);
					else cxt.setParams({ ifClause: keyword });
				};
			}
		}
	};
	function hasSchema(it, keyword) {
		const schema$1 = it.schema[keyword];
		return schema$1 !== void 0 && !(0, util_1$2.alwaysValidSchema)(it, schema$1);
	}
	exports.default = def$3;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/applicator/thenElse.js
var require_thenElse = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/applicator/thenElse.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const util_1$1 = require_util();
	const def$2 = {
		keyword: ["then", "else"],
		schemaType: ["object", "boolean"],
		code({ keyword, parentSchema, it }) {
			if (parentSchema.if === void 0) (0, util_1$1.checkStrictMode)(it, `"${keyword}" without "if" is ignored`);
		}
	};
	exports.default = def$2;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/applicator/index.js
var require_applicator = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/applicator/index.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const additionalItems_1 = require_additionalItems();
	const prefixItems_1 = require_prefixItems();
	const items_1 = require_items();
	const items2020_1 = require_items2020();
	const contains_1 = require_contains();
	const dependencies_1 = require_dependencies();
	const propertyNames_1 = require_propertyNames();
	const additionalProperties_1 = require_additionalProperties();
	const properties_1 = require_properties();
	const patternProperties_1 = require_patternProperties();
	const not_1 = require_not();
	const anyOf_1 = require_anyOf();
	const oneOf_1 = require_oneOf();
	const allOf_1 = require_allOf();
	const if_1 = require_if();
	const thenElse_1 = require_thenElse();
	function getApplicator(draft2020 = false) {
		const applicator = [
			not_1.default,
			anyOf_1.default,
			oneOf_1.default,
			allOf_1.default,
			if_1.default,
			thenElse_1.default,
			propertyNames_1.default,
			additionalProperties_1.default,
			dependencies_1.default,
			properties_1.default,
			patternProperties_1.default
		];
		if (draft2020) applicator.push(prefixItems_1.default, items2020_1.default);
		else applicator.push(additionalItems_1.default, items_1.default);
		applicator.push(contains_1.default);
		return applicator;
	}
	exports.default = getApplicator;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/format/format.js
var require_format$1 = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/format/format.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$2 = require_codegen();
	const def$1 = {
		keyword: "format",
		type: ["number", "string"],
		schemaType: "string",
		$data: true,
		error: {
			message: ({ schemaCode }) => (0, codegen_1$2.str)`must match format "${schemaCode}"`,
			params: ({ schemaCode }) => (0, codegen_1$2._)`{format: ${schemaCode}}`
		},
		code(cxt, ruleType) {
			const { gen, data, $data, schema: schema$1, schemaCode, it } = cxt;
			const { opts, errSchemaPath, schemaEnv, self } = it;
			if (!opts.validateFormats) return;
			if ($data) validate$DataFormat();
			else validateFormat();
			function validate$DataFormat() {
				const fmts = gen.scopeValue("formats", {
					ref: self.formats,
					code: opts.code.formats
				});
				const fDef = gen.const("fDef", (0, codegen_1$2._)`${fmts}[${schemaCode}]`);
				const fType = gen.let("fType");
				const format$1 = gen.let("format");
				gen.if((0, codegen_1$2._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1$2._)`${fDef}.type || "string"`).assign(format$1, (0, codegen_1$2._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1$2._)`"string"`).assign(format$1, fDef));
				cxt.fail$data((0, codegen_1$2.or)(unknownFmt(), invalidFmt()));
				function unknownFmt() {
					if (opts.strictSchema === false) return codegen_1$2.nil;
					return (0, codegen_1$2._)`${schemaCode} && !${format$1}`;
				}
				function invalidFmt() {
					const callFormat = schemaEnv.$async ? (0, codegen_1$2._)`(${fDef}.async ? await ${format$1}(${data}) : ${format$1}(${data}))` : (0, codegen_1$2._)`${format$1}(${data})`;
					const validData = (0, codegen_1$2._)`(typeof ${format$1} == "function" ? ${callFormat} : ${format$1}.test(${data}))`;
					return (0, codegen_1$2._)`${format$1} && ${format$1} !== true && ${fType} === ${ruleType} && !${validData}`;
				}
			}
			function validateFormat() {
				const formatDef = self.formats[schema$1];
				if (!formatDef) {
					unknownFormat();
					return;
				}
				if (formatDef === true) return;
				const [fmtType, format$1, fmtRef] = getFormat(formatDef);
				if (fmtType === ruleType) cxt.pass(validCondition());
				function unknownFormat() {
					if (opts.strictSchema === false) {
						self.logger.warn(unknownMsg());
						return;
					}
					throw new Error(unknownMsg());
					function unknownMsg() {
						return `unknown format "${schema$1}" ignored in schema at path "${errSchemaPath}"`;
					}
				}
				function getFormat(fmtDef) {
					const code = fmtDef instanceof RegExp ? (0, codegen_1$2.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1$2._)`${opts.code.formats}${(0, codegen_1$2.getProperty)(schema$1)}` : void 0;
					const fmt = gen.scopeValue("formats", {
						key: schema$1,
						ref: fmtDef,
						code
					});
					if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) return [
						fmtDef.type || "string",
						fmtDef.validate,
						(0, codegen_1$2._)`${fmt}.validate`
					];
					return [
						"string",
						fmtDef,
						fmt
					];
				}
				function validCondition() {
					if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
						if (!schemaEnv.$async) throw new Error("async format in sync schema");
						return (0, codegen_1$2._)`await ${fmtRef}(${data})`;
					}
					return typeof format$1 == "function" ? (0, codegen_1$2._)`${fmtRef}(${data})` : (0, codegen_1$2._)`${fmtRef}.test(${data})`;
				}
			}
		}
	};
	exports.default = def$1;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/format/index.js
var require_format = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/format/index.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const format = [require_format$1().default];
	exports.default = format;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/metadata.js
var require_metadata = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/metadata.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.metadataVocabulary = [
		"title",
		"description",
		"default",
		"deprecated",
		"readOnly",
		"writeOnly",
		"examples"
	];
	exports.contentVocabulary = [
		"contentMediaType",
		"contentEncoding",
		"contentSchema"
	];
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/draft7.js
var require_draft7 = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/draft7.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const core_1$1 = require_core();
	const validation_1 = require_validation();
	const applicator_1 = require_applicator();
	const format_1 = require_format();
	const metadata_1 = require_metadata();
	const draft7Vocabularies = [
		core_1$1.default,
		validation_1.default,
		(0, applicator_1.default)(),
		format_1.default,
		metadata_1.metadataVocabulary,
		metadata_1.contentVocabulary
	];
	exports.default = draft7Vocabularies;
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/discriminator/types.js
var require_types = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/discriminator/types.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var DiscrError;
	(function(DiscrError$1) {
		DiscrError$1["Tag"] = "tag";
		DiscrError$1["Mapping"] = "mapping";
	})(DiscrError || (exports.DiscrError = DiscrError = {}));
}) });

//#endregion
//#region ../node_modules/ajv/dist/vocabularies/discriminator/index.js
var require_discriminator = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/vocabularies/discriminator/index.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$1 = require_codegen();
	const types_1 = require_types();
	const compile_1 = require_compile();
	const ref_error_1$1 = require_ref_error();
	const util_1 = require_util();
	const def = {
		keyword: "discriminator",
		type: "object",
		schemaType: "object",
		error: {
			message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
			params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1$1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
		},
		code(cxt) {
			const { gen, data, schema: schema$1, parentSchema, it } = cxt;
			const { oneOf } = parentSchema;
			if (!it.opts.discriminator) throw new Error("discriminator: requires discriminator option");
			const tagName = schema$1.propertyName;
			if (typeof tagName != "string") throw new Error("discriminator: requires propertyName");
			if (schema$1.mapping) throw new Error("discriminator: mapping is not supported");
			if (!oneOf) throw new Error("discriminator: requires oneOf keyword");
			const valid = gen.let("valid", false);
			const tag = gen.const("tag", (0, codegen_1$1._)`${data}${(0, codegen_1$1.getProperty)(tagName)}`);
			gen.if((0, codegen_1$1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, {
				discrError: types_1.DiscrError.Tag,
				tag,
				tagName
			}));
			cxt.ok(valid);
			function validateMapping() {
				const mapping = getMapping();
				gen.if(false);
				for (const tagValue in mapping) {
					gen.elseIf((0, codegen_1$1._)`${tag} === ${tagValue}`);
					gen.assign(valid, applyTagSchema(mapping[tagValue]));
				}
				gen.else();
				cxt.error(false, {
					discrError: types_1.DiscrError.Mapping,
					tag,
					tagName
				});
				gen.endIf();
			}
			function applyTagSchema(schemaProp) {
				const _valid = gen.name("valid");
				const schCxt = cxt.subschema({
					keyword: "oneOf",
					schemaProp
				}, _valid);
				cxt.mergeEvaluated(schCxt, codegen_1$1.Name);
				return _valid;
			}
			function getMapping() {
				var _a$1;
				const oneOfMapping = {};
				const topRequired = hasRequired(parentSchema);
				let tagRequired = true;
				for (let i = 0; i < oneOf.length; i++) {
					let sch = oneOf[i];
					if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
						const ref = sch.$ref;
						sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref);
						if (sch instanceof compile_1.SchemaEnv) sch = sch.schema;
						if (sch === void 0) throw new ref_error_1$1.default(it.opts.uriResolver, it.baseId, ref);
					}
					const propSch = (_a$1 = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a$1 === void 0 ? void 0 : _a$1[tagName];
					if (typeof propSch != "object") throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
					tagRequired = tagRequired && (topRequired || hasRequired(sch));
					addMappings(propSch, i);
				}
				if (!tagRequired) throw new Error(`discriminator: "${tagName}" must be required`);
				return oneOfMapping;
				function hasRequired({ required }) {
					return Array.isArray(required) && required.includes(tagName);
				}
				function addMappings(sch, i) {
					if (sch.const) addMapping(sch.const, i);
					else if (sch.enum) for (const tagValue of sch.enum) addMapping(tagValue, i);
					else throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
				}
				function addMapping(tagValue, i) {
					if (typeof tagValue != "string" || tagValue in oneOfMapping) throw new Error(`discriminator: "${tagName}" values must be unique strings`);
					oneOfMapping[tagValue] = i;
				}
			}
		}
	};
	exports.default = def;
}) });

//#endregion
//#region ../node_modules/ajv/dist/refs/json-schema-draft-07.json
var require_json_schema_draft_07 = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/refs/json-schema-draft-07.json": ((exports, module) => {
	module.exports = {
		"$schema": "http://json-schema.org/draft-07/schema#",
		"$id": "http://json-schema.org/draft-07/schema#",
		"title": "Core schema meta-schema",
		"definitions": {
			"schemaArray": {
				"type": "array",
				"minItems": 1,
				"items": { "$ref": "#" }
			},
			"nonNegativeInteger": {
				"type": "integer",
				"minimum": 0
			},
			"nonNegativeIntegerDefault0": { "allOf": [{ "$ref": "#/definitions/nonNegativeInteger" }, { "default": 0 }] },
			"simpleTypes": { "enum": [
				"array",
				"boolean",
				"integer",
				"null",
				"number",
				"object",
				"string"
			] },
			"stringArray": {
				"type": "array",
				"items": { "type": "string" },
				"uniqueItems": true,
				"default": []
			}
		},
		"type": ["object", "boolean"],
		"properties": {
			"$id": {
				"type": "string",
				"format": "uri-reference"
			},
			"$schema": {
				"type": "string",
				"format": "uri"
			},
			"$ref": {
				"type": "string",
				"format": "uri-reference"
			},
			"$comment": { "type": "string" },
			"title": { "type": "string" },
			"description": { "type": "string" },
			"default": true,
			"readOnly": {
				"type": "boolean",
				"default": false
			},
			"examples": {
				"type": "array",
				"items": true
			},
			"multipleOf": {
				"type": "number",
				"exclusiveMinimum": 0
			},
			"maximum": { "type": "number" },
			"exclusiveMaximum": { "type": "number" },
			"minimum": { "type": "number" },
			"exclusiveMinimum": { "type": "number" },
			"maxLength": { "$ref": "#/definitions/nonNegativeInteger" },
			"minLength": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },
			"pattern": {
				"type": "string",
				"format": "regex"
			},
			"additionalItems": { "$ref": "#" },
			"items": {
				"anyOf": [{ "$ref": "#" }, { "$ref": "#/definitions/schemaArray" }],
				"default": true
			},
			"maxItems": { "$ref": "#/definitions/nonNegativeInteger" },
			"minItems": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },
			"uniqueItems": {
				"type": "boolean",
				"default": false
			},
			"contains": { "$ref": "#" },
			"maxProperties": { "$ref": "#/definitions/nonNegativeInteger" },
			"minProperties": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },
			"required": { "$ref": "#/definitions/stringArray" },
			"additionalProperties": { "$ref": "#" },
			"definitions": {
				"type": "object",
				"additionalProperties": { "$ref": "#" },
				"default": {}
			},
			"properties": {
				"type": "object",
				"additionalProperties": { "$ref": "#" },
				"default": {}
			},
			"patternProperties": {
				"type": "object",
				"additionalProperties": { "$ref": "#" },
				"propertyNames": { "format": "regex" },
				"default": {}
			},
			"dependencies": {
				"type": "object",
				"additionalProperties": { "anyOf": [{ "$ref": "#" }, { "$ref": "#/definitions/stringArray" }] }
			},
			"propertyNames": { "$ref": "#" },
			"const": true,
			"enum": {
				"type": "array",
				"items": true,
				"minItems": 1,
				"uniqueItems": true
			},
			"type": { "anyOf": [{ "$ref": "#/definitions/simpleTypes" }, {
				"type": "array",
				"items": { "$ref": "#/definitions/simpleTypes" },
				"minItems": 1,
				"uniqueItems": true
			}] },
			"format": { "type": "string" },
			"contentMediaType": { "type": "string" },
			"contentEncoding": { "type": "string" },
			"if": { "$ref": "#" },
			"then": { "$ref": "#" },
			"else": { "$ref": "#" },
			"allOf": { "$ref": "#/definitions/schemaArray" },
			"anyOf": { "$ref": "#/definitions/schemaArray" },
			"oneOf": { "$ref": "#/definitions/schemaArray" },
			"not": { "$ref": "#" }
		},
		"default": true
	};
}) });

//#endregion
//#region ../node_modules/ajv/dist/ajv.js
var require_ajv = /* @__PURE__ */ __commonJS$2({ "../node_modules/ajv/dist/ajv.js": ((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = exports.Ajv = void 0;
	const core_1 = require_core$1();
	const draft7_1 = require_draft7();
	const discriminator_1 = require_discriminator();
	const draft7MetaSchema = require_json_schema_draft_07();
	const META_SUPPORT_DATA = ["/properties"];
	const META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
	var Ajv$1 = class extends core_1.default {
		_addVocabularies() {
			super._addVocabularies();
			draft7_1.default.forEach((v) => this.addVocabulary(v));
			if (this.opts.discriminator) this.addKeyword(discriminator_1.default);
		}
		_addDefaultMetaSchema() {
			super._addDefaultMetaSchema();
			if (!this.opts.meta) return;
			const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
			this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
			this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
		}
		defaultMeta() {
			return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
		}
	};
	exports.Ajv = Ajv$1;
	module.exports = exports = Ajv$1;
	module.exports.Ajv = Ajv$1;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Ajv$1;
	var validate_1 = require_validate();
	Object.defineProperty(exports, "KeywordCxt", {
		enumerable: true,
		get: function() {
			return validate_1.KeywordCxt;
		}
	});
	var codegen_1 = require_codegen();
	Object.defineProperty(exports, "_", {
		enumerable: true,
		get: function() {
			return codegen_1._;
		}
	});
	Object.defineProperty(exports, "str", {
		enumerable: true,
		get: function() {
			return codegen_1.str;
		}
	});
	Object.defineProperty(exports, "stringify", {
		enumerable: true,
		get: function() {
			return codegen_1.stringify;
		}
	});
	Object.defineProperty(exports, "nil", {
		enumerable: true,
		get: function() {
			return codegen_1.nil;
		}
	});
	Object.defineProperty(exports, "Name", {
		enumerable: true,
		get: function() {
			return codegen_1.Name;
		}
	});
	Object.defineProperty(exports, "CodeGen", {
		enumerable: true,
		get: function() {
			return codegen_1.CodeGen;
		}
	});
	var validation_error_1 = require_validation_error();
	Object.defineProperty(exports, "ValidationError", {
		enumerable: true,
		get: function() {
			return validation_error_1.default;
		}
	});
	var ref_error_1 = require_ref_error();
	Object.defineProperty(exports, "MissingRefError", {
		enumerable: true,
		get: function() {
			return ref_error_1.default;
		}
	});
}) });

//#endregion
//#region src/hash.ts
var import_ajv = /* @__PURE__ */ __toESM$2(require_ajv(), 1);
const FNV_OFFSET_1 = 14695981039346656037n;
const FNV_OFFSET_2 = 9521211207457086692n;
const FNV_PRIME = 1099511628211n;
const MASK_64 = (1n << 64n) - 1n;
const hash64 = (value, offset) => {
	let hash = offset;
	for (let i = 0; i < value.length; i += 1) {
		hash ^= BigInt(value.charCodeAt(i));
		hash = hash * FNV_PRIME & MASK_64;
	}
	return hash;
};
const toHex64 = (value) => value.toString(16).padStart(16, "0");
const hash128 = (...data) => {
	const input = JSON.stringify(data);
	const high = hash64(input, FNV_OFFSET_1);
	const low = hash64(input, FNV_OFFSET_2);
	return `${toHex64(high)}${toHex64(low)}`;
};

//#endregion
//#region src/notes.ts
const string = { type: "string" };
const number = { type: "number" };
const object = (properties, extra = {}) => ({
	type: "object",
	properties,
	required: Object.keys(properties),
	...extra
});
const tojson = (x) => JSON.stringify(x, null, 2);
const fromjson = (x) => JSON.parse(x);
const validate = (data, schema$1) => {
	const validate$1 = new import_ajv.default().compile(schema$1);
	if (validate$1(data)) return true;
	else throw new Error(validate$1.errors?.map((e) => e.message).join(", ") || "Invalid data");
};
function hashData({ schemaHash, data }) {
	if (schemaHash === "0" && tojson(data) != "{}") throw new Error("schema hash is 0 but data is not empty :" + tojson(data));
	return hash128(schemaHash, data);
}
function NoteData(title, schema$1, data) {
	return {
		schemaHash: hashData(schema$1),
		data: {
			...title ? { title } : {},
			...data
		}
	};
}
const top = {
	schemaHash: "0",
	data: {}
};
const script_schema = NoteData("script_schema", top, object({
	title: string,
	code: string
}));
const script_result_schema = NoteData("script_result_schema", top, object({
	title: string,
	script: "#" + hashData(script_schema),
	content: {}
}, { title: "script_result_schema" }));
const titled_schema = NoteData("titled_schema", top, object({ title: string }));
const has_titled_child = NoteData("has_titled_child", top, object({ "child": object({ title: string }) }));
const titled = NoteData("a titled", titled_schema, { title: "im child" });
const titled1 = NoteData("titled1", has_titled_child, { child: titled.data });
const titled2 = NoteData("titled2", has_titled_child, { child: `#${hashData(titled)}` });
const function_schema = NoteData("function schema", top, object({
	title: string,
	code: string
}, {
	title: "function_schema",
	required: ["code"]
}));
const server_function = NoteData("function schema", top, object({
	title: string,
	code: string
}, {
	title: "server_function",
	required: ["code"]
}));
const example_function = NoteData("example function", function_schema, {
	title: "example function",
	inputs: ["a", "b"],
	code: "return a + b"
});
const schemas = [
	script_schema,
	script_result_schema,
	NoteData("", top, string),
	NoteData("", top, number),
	titled_schema,
	has_titled_child,
	titled,
	titled1,
	titled2,
	function_schema,
	example_function,
	server_function
];
const isRef = (value) => typeof value == "string" && /^#([a-f0-9]{32})$/.exec(value);
const expandLinksSync = (value, resolve$2) => {
	if (typeof value === "string") {
		const match = isRef(value);
		if (!match) return value;
		const ref = match[1];
		return expandLinksSync(resolve$2(ref), resolve$2);
	}
	if (Array.isArray(value)) return value.map((v) => expandLinksSync(v, resolve$2));
	if (value && typeof value === "object") return Object.fromEntries(Object.entries(value).map(([k, v]) => [k, expandLinksSync(v, resolve$2)]));
	return value;
};
const normalizeRef = (ref) => ref[0] === "#" ? ref.slice(1) : ref;

//#endregion
//#region src/parser.ts
const keywords = new Set([
	"if",
	"else",
	"return",
	"let",
	"const",
	"for",
	"while",
	"in",
	"of",
	"break",
	"continue",
	"true",
	"false",
	"null"
]);
const isIdentStart = (c) => /[A-Za-z_$]/.test(c);
const isIdentPart = (c) => /[A-Za-z0-9_$]/.test(c);
const isDigit = (c) => /[0-9]/.test(c);
const tokenize = (src) => {
	const tokens = [];
	let i = 0;
	const push = (type, value, pos) => tokens.push({
		type,
		value,
		pos
	});
	const peek = () => src[i];
	const next = () => src[i++];
	while (i < src.length) {
		const c = peek();
		if (c === " " || c === "\n" || c === "\r" || c === "	") {
			i++;
			continue;
		}
		if (c === "/" && src[i + 1] === "/") {
			i += 2;
			while (i < src.length && src[i] !== "\n") i++;
			continue;
		}
		if (c === "/" && src[i + 1] === "*") {
			i += 2;
			while (i < src.length && !(src[i] === "*" && src[i + 1] === "/")) i++;
			i += 2;
			continue;
		}
		if (c === "'" || c === "\"") {
			const quote = next();
			let out = "";
			const start$1 = i - 1;
			while (i < src.length) {
				const ch = next();
				if (ch === "\\") {
					const esc = next();
					out += esc;
				} else if (ch === quote) break;
				else out += ch;
			}
			push("string", out, start$1);
			continue;
		}
		if (isDigit(c)) {
			const start$1 = i;
			let num = "";
			while (i < src.length && isDigit(peek())) num += next();
			if (peek() === ".") {
				num += next();
				while (i < src.length && isDigit(peek())) num += next();
			}
			push("number", num, start$1);
			continue;
		}
		if (isIdentStart(c)) {
			const start$1 = i;
			let id = "";
			while (i < src.length && isIdentPart(peek())) id += next();
			if (keywords.has(id)) push("keyword", id, start$1);
			else push("identifier", id, start$1);
			continue;
		}
		const start = i;
		const two = src.slice(i, i + 2);
		const three = src.slice(i, i + 3);
		if (three === "===" || three === "!==") {
			i += 3;
			push("operator", three, start);
			continue;
		}
		if (two === "&&" || two === "||" || two === "==" || two === "!=" || two === "<=" || two === ">=" || two === "=>" || two === "+=" || two === "-=" || two === "*=" || two === "/=" || two === "%=" || two === "++" || two === "--") {
			i += 2;
			push("operator", two, start);
			continue;
		}
		if ("+-*/%<>=!.,;:?(){}[]".includes(c)) {
			i++;
			push(".;,(){}[]".includes(c) ? "punct" : "operator", c, start);
			continue;
		}
		throw new Error(`Unexpected character '${c}' at ${i}`);
	}
	tokens.push({
		type: "eof",
		value: "",
		pos: i
	});
	return tokens;
};
const validateNoPrototype = (program) => {
	const errors$1 = [];
	const visitExpr = (e) => {
		switch (e.type) {
			case "MemberExpression":
				if (!e.computed && e.property.type === "Identifier" && e.property.name === "prototype") errors$1.push("prototype access");
				if (e.computed && e.property.type === "Literal" && e.property.value === "prototype") errors$1.push("prototype access");
				visitExpr(e.object);
				if (e.computed) visitExpr(e.property);
				return;
			case "CallExpression":
				visitExpr(e.callee);
				e.arguments.forEach(visitExpr);
				return;
			case "ArrayExpression":
				e.elements.forEach(visitExpr);
				return;
			case "ObjectExpression":
				e.properties.forEach((p) => visitExpr(p.value));
				return;
			case "AssignmentExpression":
				visitExpr(e.left);
				visitExpr(e.right);
				return;
			case "UpdateExpression":
				visitExpr(e.argument);
				return;
			case "BinaryExpression":
			case "LogicalExpression":
				visitExpr(e.left);
				visitExpr(e.right);
				return;
			case "UnaryExpression":
				visitExpr(e.argument);
				return;
			case "ConditionalExpression":
				visitExpr(e.test);
				visitExpr(e.consequent);
				visitExpr(e.alternate);
				return;
			case "ArrowFunctionExpression":
				if (e.body.type === "BlockStatement") visitStmt(e.body);
				else visitExpr(e.body);
				return;
			case "Identifier":
			case "Literal": return;
		}
	};
	const visitStmt = (s) => {
		switch (s.type) {
			case "BlockStatement":
				s.body.forEach(visitStmt);
				return;
			case "ExpressionStatement":
				visitExpr(s.expression);
				return;
			case "IfStatement":
				visitExpr(s.test);
				visitStmt(s.consequent);
				if (s.alternate) visitStmt(s.alternate);
				return;
			case "ReturnStatement":
				if (s.argument) visitExpr(s.argument);
				return;
			case "VariableDeclaration":
				s.declarations.forEach((d) => d.init && visitExpr(d.init));
				return;
			case "WhileStatement":
				visitExpr(s.test);
				visitStmt(s.body);
				return;
			case "ForStatement":
				if (Array.isArray(s.init)) s.init.forEach((d) => d.init && visitExpr(d.init));
				else if (s.init) visitExpr(s.init);
				if (s.test) visitExpr(s.test);
				if (s.update) visitExpr(s.update);
				visitStmt(s.body);
				return;
			case "ForInStatement":
			case "ForOfStatement":
				if (Array.isArray(s.left)) s.left.forEach((d) => d.init && visitExpr(d.init));
				else visitExpr(s.left);
				visitExpr(s.right);
				visitStmt(s.body);
				return;
			case "BreakStatement":
			case "ContinueStatement": return;
		}
	};
	program.body.forEach(visitStmt);
	return errors$1;
};
const renderLiteral = (v) => {
	if (v === null) return "null";
	if (typeof v === "string") return JSON.stringify(v);
	return String(v);
};
const renderExpr = (e) => {
	switch (e.type) {
		case "Identifier": return e.name;
		case "Literal": return renderLiteral(e.value);
		case "ArrayExpression": return `[${e.elements.map(renderExpr).join(", ")}]`;
		case "ObjectExpression": return `{${e.properties.map(renderProp).join(", ")}}`;
		case "CallExpression": {
			const calleeStr = renderExpr(e.callee);
			const needsParens = e.callee.type === "ArrowFunctionExpression";
			return `${needsParens ? "(" : ""}${calleeStr}${needsParens ? ")" : ""}(${e.arguments.map(renderExpr).join(", ")})`;
		}
		case "MemberExpression": return e.computed ? `${renderExpr(e.object)}[${renderExpr(e.property)}]` : `${renderExpr(e.object)}.${renderExpr(e.property)}`;
		case "AssignmentExpression": return `${renderExpr(e.left)} ${e.operator} ${renderExpr(e.right)}`;
		case "UpdateExpression": return e.prefix ? `${e.operator}${renderExpr(e.argument)}` : `${renderExpr(e.argument)}${e.operator}`;
		case "BinaryExpression":
		case "LogicalExpression": return `(${renderExpr(e.left)} ${e.operator} ${renderExpr(e.right)})`;
		case "UnaryExpression": return `(${e.operator}${renderExpr(e.argument)})`;
		case "ConditionalExpression": return `(${renderExpr(e.test)} ? ${renderExpr(e.consequent)} : ${renderExpr(e.alternate)})`;
		case "ArrowFunctionExpression": return renderArrow(e);
	}
};
const renderProp = (p) => {
	const key = p.key.type === "Identifier" ? p.key.name : renderLiteral(p.key.value);
	if (p.shorthand && p.value.type === "Identifier" && p.value.name === key) return key;
	return `${key}: ${renderExpr(p.value)}`;
};
const renderArrow = (e) => {
	const params = `(${e.params.map((p) => p.name).join(", ")})`;
	if (e.body.type === "BlockStatement") return `${params} => ${renderStmt(e.body, true)}`;
	return `${params} => { __burn(); return ${renderExpr(e.body)}; }`;
};
const renderStmt = (s, inFn = false) => {
	const burn = inFn ? "__burn();" : "";
	const renderLoopBody = (body) => {
		if (body.type === "BlockStatement") return `{__burn();${body.body.map((b) => renderStmt(b, inFn)).join("")}}`;
		return `{__burn();${renderStmt(body, inFn)}}`;
	};
	switch (s.type) {
		case "BlockStatement": return `{${s.body.map((b) => renderStmt(b, inFn)).join("")}}`;
		case "ExpressionStatement": return `${burn}${renderExpr(s.expression)};`;
		case "IfStatement": {
			const wrap = (stmt) => stmt.type === "BlockStatement" ? renderStmt(stmt, inFn) : `{${renderStmt(stmt, inFn)}}`;
			return `${burn}if (${renderExpr(s.test)}) ${wrap(s.consequent)}${s.alternate ? ` else ${wrap(s.alternate)}` : ""}`;
		}
		case "ReturnStatement": return `${burn}return${s.argument ? ` ${renderExpr(s.argument)}` : ""};`;
		case "VariableDeclaration": return `${burn}${s.kind} ${s.declarations.map(renderDecl).join(", ")};`;
		case "BreakStatement": return `${burn}break;`;
		case "ContinueStatement": return `${burn}continue;`;
		case "WhileStatement": return `${burn}while (${renderExpr(s.test)}) ${renderLoopBody(s.body)}`;
		case "ForStatement": return `${burn}for (${s.init == null ? "" : Array.isArray(s.init) ? `${s.initKind} ${s.init.map(renderDecl).join(", ")}` : renderExpr(s.init)}; ${s.test ? renderExpr(s.test) : ""}; ${s.update ? renderExpr(s.update) : ""}) ${renderLoopBody(s.body)}`;
		case "ForInStatement": return `${burn}for (${Array.isArray(s.left) ? `${s.leftKind} ${s.left.map(renderDecl).join(", ")}` : renderExpr(s.left)} in ${renderExpr(s.right)}) ${renderLoopBody(s.body)}`;
		case "ForOfStatement": return `${burn}for (${Array.isArray(s.left) ? `${s.leftKind} ${s.left.map(renderDecl).join(", ")}` : renderExpr(s.left)} of ${renderExpr(s.right)}) ${renderLoopBody(s.body)}`;
	}
};
const renderDecl = (d) => `${renderPattern(d.id)}${d.init ? ` = ${renderExpr(d.init)}` : ""}`;
const renderPattern = (p) => {
	if (p.type === "Identifier") return p.name;
	if (p.type === "ArrayPattern") return `[${p.elements.map((e) => e.name).join(", ")}]`;
	return `{${p.properties.map((e) => e.name).join(", ")}}`;
};
const renderRunnerWithFuelShared = (program, fuelRefName = "__fuel") => {
	return `${`const __burn = () => { if (--${fuelRefName}.value < 0) throw new Error("fuel exhausted"); };`}const __run = () => {${program.body.map((s) => renderStmt(s, true)).join("")}}; try { const ok = __run(); return { ok, fuel: ${fuelRefName}.value }; } catch (err) { return { err: String(err), fuel: ${fuelRefName}.value }; }`;
};
const stringifyError = (err) => {
	if (err instanceof Error) {
		const stack = err.stack || "";
		const prefix = `${err.name}: ${err.message}`;
		const cleanStack = stack.replace(/^[^\n]*\n?/, "").replace(/spacetimedb_module:(\d+):(\d+)/g, "<bundled:$1:$2>");
		return cleanStack ? `${prefix}\n${cleanStack}` : prefix;
	}
	if (typeof err === "object" && err !== null) try {
		return JSON.stringify(err);
	} catch {
		return String(err);
	}
	return String(err);
};
const runWithFuelShared = (src, fuelRef, env = {}, fuelRefName = "__fuel") => {
	try {
		const program = parse(src);
		if (validateNoPrototype(program).length) return {
			err: "prototype access",
			fuel: fuelRef.value
		};
		const code = renderRunnerWithFuelShared(program, fuelRefName);
		const fullEnv = {
			...env,
			[fuelRefName]: fuelRef
		};
		return new Function(...Object.keys(fullEnv), code)(...Object.values(fullEnv));
	} catch (err) {
		return {
			err: stringifyError(err),
			fuel: fuelRef.value
		};
	}
};
const parse = (src) => {
	const tokens = tokenize(src);
	let i = 0;
	const peek = () => tokens[i];
	const next = () => tokens[i++];
	const eat = (type, value) => {
		const t$1 = peek();
		if (t$1.type !== type || value !== void 0 && t$1.value !== value) throw new Error(`Expected ${value ?? type} at ${t$1.pos}`);
		return next();
	};
	const match = (type, value) => {
		const t$1 = peek();
		return t$1.type === type && (value === void 0 || t$1.value === value);
	};
	const parseProgram = () => {
		const body = [];
		while (!match("eof")) body.push(parseStatement());
		return {
			type: "Program",
			body
		};
	};
	const parseStatement = () => {
		if (match("punct", "{")) return parseBlock();
		if (match("keyword", "if")) return parseIf();
		if (match("keyword", "while")) return parseWhile();
		if (match("keyword", "for")) return parseFor();
		if (match("keyword", "break")) {
			next();
			if (match("punct", ";")) next();
			return { type: "BreakStatement" };
		}
		if (match("keyword", "continue")) {
			next();
			if (match("punct", ";")) next();
			return { type: "ContinueStatement" };
		}
		if (match("keyword", "return")) return parseReturn();
		if (match("keyword", "let") || match("keyword", "const")) return parseVarDecl();
		const expr = parseExpression();
		if (match("punct", ";")) next();
		return {
			type: "ExpressionStatement",
			expression: expr
		};
	};
	const parseBlock = () => {
		eat("punct", "{");
		const body = [];
		while (!match("punct", "}")) body.push(parseStatement());
		eat("punct", "}");
		return {
			type: "BlockStatement",
			body
		};
	};
	const parseIf = () => {
		eat("keyword", "if");
		eat("punct", "(");
		const test = parseExpression();
		eat("punct", ")");
		return {
			type: "IfStatement",
			test,
			consequent: parseStatement(),
			alternate: match("keyword", "else") ? (next(), parseStatement()) : null
		};
	};
	const parseReturn = () => {
		eat("keyword", "return");
		if (match("punct", ";")) {
			next();
			return {
				type: "ReturnStatement",
				argument: null
			};
		}
		const argument = match("punct", "}") ? null : parseExpression();
		if (match("punct", ";")) next();
		return {
			type: "ReturnStatement",
			argument
		};
	};
	const parseVarDeclCore = (consumeSemi) => {
		const kind = next().value;
		const declarations = [];
		do {
			const id = parsePattern();
			const init$1 = match("operator", "=") ? (next(), parseExpression()) : null;
			declarations.push({
				type: "VariableDeclarator",
				id,
				init: init$1
			});
			if (!match("punct", ",")) break;
			next();
		} while (true);
		if (consumeSemi && match("punct", ";")) next();
		return {
			kind,
			declarations
		};
	};
	const parseVarDecl = () => {
		const { kind, declarations } = parseVarDeclCore(true);
		return {
			type: "VariableDeclaration",
			kind,
			declarations
		};
	};
	const parseWhile = () => {
		eat("keyword", "while");
		eat("punct", "(");
		const test = parseExpression();
		eat("punct", ")");
		return {
			type: "WhileStatement",
			test,
			body: parseStatement()
		};
	};
	const parseFor = () => {
		eat("keyword", "for");
		eat("punct", "(");
		let init$1 = null;
		let initKind = null;
		if (!match("punct", ";")) if (match("keyword", "let") || match("keyword", "const")) {
			const parsed = parseVarDeclCore(false);
			init$1 = parsed.declarations;
			initKind = parsed.kind;
		} else init$1 = parseExpression();
		if (match("keyword", "in") || match("keyword", "of")) {
			const kind = next().value;
			const right = parseExpression();
			eat("punct", ")");
			const body$1 = parseStatement();
			if (!init$1) throw new Error(`Expected initializer before ${kind} at ${peek().pos}`);
			return kind === "in" ? {
				type: "ForInStatement",
				left: init$1,
				leftKind: initKind,
				right,
				body: body$1
			} : {
				type: "ForOfStatement",
				left: init$1,
				leftKind: initKind,
				right,
				body: body$1
			};
		}
		eat("punct", ";");
		const test = match("punct", ";") ? null : parseExpression();
		eat("punct", ";");
		const update = match("punct", ")") ? null : parseExpression();
		eat("punct", ")");
		const body = parseStatement();
		return {
			type: "ForStatement",
			init: init$1,
			initKind,
			test,
			update,
			body
		};
	};
	const parseExpression = () => parseAssignment();
	const parseAssignment = () => {
		const left = parseConditional();
		if (match("operator", "=") || match("operator", "+=") || match("operator", "-=") || match("operator", "*=") || match("operator", "/=") || match("operator", "%=")) return {
			type: "AssignmentExpression",
			operator: next().value,
			left,
			right: parseAssignment()
		};
		return left;
	};
	const parseConditional = () => {
		let test = parseLogicalOr();
		if (match("operator", "?")) {
			next();
			const consequent = parseExpression();
			eat("operator", ":");
			return {
				type: "ConditionalExpression",
				test,
				consequent,
				alternate: parseExpression()
			};
		}
		return test;
	};
	const parseLogicalOr = () => {
		let left = parseLogicalAnd();
		while (match("operator", "||")) {
			const op = next().value;
			const right = parseLogicalAnd();
			left = {
				type: "LogicalExpression",
				operator: op,
				left,
				right
			};
		}
		return left;
	};
	const parseLogicalAnd = () => {
		let left = parseEquality();
		while (match("operator", "&&")) {
			const op = next().value;
			const right = parseEquality();
			left = {
				type: "LogicalExpression",
				operator: op,
				left,
				right
			};
		}
		return left;
	};
	const parseEquality = () => {
		let left = parseRelational();
		while (match("operator", "==") || match("operator", "!=") || match("operator", "===") || match("operator", "!==")) {
			const op = next().value;
			const right = parseRelational();
			left = {
				type: "BinaryExpression",
				operator: op,
				left,
				right
			};
		}
		return left;
	};
	const parseRelational = () => {
		let left = parseAdditive();
		while (match("operator", "<") || match("operator", "<=") || match("operator", ">") || match("operator", ">=")) {
			const op = next().value;
			const right = parseAdditive();
			left = {
				type: "BinaryExpression",
				operator: op,
				left,
				right
			};
		}
		return left;
	};
	const parseAdditive = () => {
		let left = parseMultiplicative();
		while (match("operator", "+") || match("operator", "-")) {
			const op = next().value;
			const right = parseMultiplicative();
			left = {
				type: "BinaryExpression",
				operator: op,
				left,
				right
			};
		}
		return left;
	};
	const parseMultiplicative = () => {
		let left = parseUnary();
		while (match("operator", "*") || match("operator", "/") || match("operator", "%")) {
			const op = next().value;
			const right = parseUnary();
			left = {
				type: "BinaryExpression",
				operator: op,
				left,
				right
			};
		}
		return left;
	};
	const parseUnary = () => {
		if (match("operator", "++") || match("operator", "--")) return {
			type: "UpdateExpression",
			operator: next().value,
			argument: parseUnary(),
			prefix: true
		};
		if (match("operator", "!") || match("operator", "-") || match("operator", "+")) return {
			type: "UnaryExpression",
			operator: next().value,
			argument: parseUnary()
		};
		return parsePostfix();
	};
	const parsePostfix = () => {
		let expr = parseArrowOrPrimary();
		while (true) {
			if (match("operator", "++") || match("operator", "--")) {
				expr = {
					type: "UpdateExpression",
					operator: next().value,
					argument: expr,
					prefix: false
				};
				continue;
			}
			if (match("punct", "(")) {
				const args = parseArguments();
				expr = {
					type: "CallExpression",
					callee: expr,
					arguments: args
				};
				continue;
			}
			if (match("punct", ".")) {
				next();
				const prop = parseIdentifier();
				expr = {
					type: "MemberExpression",
					object: expr,
					property: prop,
					computed: false
				};
				continue;
			}
			if (match("punct", "[")) {
				next();
				const prop = parseExpression();
				eat("punct", "]");
				expr = {
					type: "MemberExpression",
					object: expr,
					property: prop,
					computed: true
				};
				continue;
			}
			break;
		}
		return expr;
	};
	const parseArrowOrPrimary = () => {
		if (match("identifier")) {
			const id = parseIdentifier();
			if (match("operator", "=>")) {
				next();
				const body = match("punct", "{") ? parseBlock() : parseExpression();
				return {
					type: "ArrowFunctionExpression",
					params: [id],
					body
				};
			}
			return id;
		}
		if (match("punct", "(")) {
			const start = i;
			next();
			const params = [];
			let isParams = true;
			if (!match("punct", ")")) do {
				if (!match("identifier")) {
					isParams = false;
					break;
				}
				params.push(parseIdentifier());
				if (!match("punct", ",")) break;
				next();
			} while (true);
			if (isParams && match("punct", ")")) {
				next();
				if (match("operator", "=>")) {
					next();
					return {
						type: "ArrowFunctionExpression",
						params,
						body: match("punct", "{") ? parseBlock() : parseExpression()
					};
				}
			}
			i = start;
			eat("punct", "(");
			const expr = parseExpression();
			eat("punct", ")");
			return expr;
		}
		return parsePrimary();
	};
	const parsePrimary = () => {
		if (match("number")) return {
			type: "Literal",
			value: Number(next().value)
		};
		if (match("string")) return {
			type: "Literal",
			value: next().value
		};
		if (match("keyword", "true")) {
			next();
			return {
				type: "Literal",
				value: true
			};
		}
		if (match("keyword", "false")) {
			next();
			return {
				type: "Literal",
				value: false
			};
		}
		if (match("keyword", "null")) {
			next();
			return {
				type: "Literal",
				value: null
			};
		}
		if (match("punct", "[")) return parseArray();
		if (match("punct", "{")) return parseObject();
		if (match("identifier")) return parseIdentifier();
		throw new Error(`Unexpected token ${peek().type} ${peek().value} at ${peek().pos}`);
	};
	const parseArray = () => {
		eat("punct", "[");
		const elements = [];
		if (!match("punct", "]")) do {
			elements.push(parseExpression());
			if (!match("punct", ",")) break;
			next();
		} while (true);
		eat("punct", "]");
		return {
			type: "ArrayExpression",
			elements
		};
	};
	const parseObject = () => {
		eat("punct", "{");
		const properties = [];
		if (!match("punct", "}")) do {
			let key;
			let shorthand = false;
			if (match("identifier")) key = parseIdentifier();
			else if (match("string")) key = {
				type: "Literal",
				value: next().value
			};
			else if (match("number")) key = {
				type: "Literal",
				value: Number(next().value)
			};
			else throw new Error(`Expected object key at ${peek().pos}`);
			let value;
			if (match("operator", ":")) {
				next();
				value = parseExpression();
			} else {
				if (key.type !== "Identifier") throw new Error(`Expected ':' after key at ${peek().pos}`);
				value = key;
				shorthand = true;
			}
			properties.push({
				type: "Property",
				key,
				value,
				shorthand
			});
			if (!match("punct", ",")) break;
			next();
		} while (true);
		eat("punct", "}");
		return {
			type: "ObjectExpression",
			properties
		};
	};
	const parseArguments = () => {
		eat("punct", "(");
		const args = [];
		if (!match("punct", ")")) do {
			args.push(parseExpression());
			if (!match("punct", ",")) break;
			next();
		} while (true);
		eat("punct", ")");
		return args;
	};
	const parseIdentifier = () => {
		return {
			type: "Identifier",
			name: eat("identifier").value
		};
	};
	const parsePattern = () => {
		if (match("punct", "[")) {
			eat("punct", "[");
			const elements = [];
			if (!match("punct", "]")) do {
				elements.push(parseIdentifier());
				if (!match("punct", ",")) break;
				next();
			} while (true);
			eat("punct", "]");
			return {
				type: "ArrayPattern",
				elements
			};
		}
		if (match("punct", "{")) {
			eat("punct", "{");
			const properties = [];
			if (!match("punct", "}")) do {
				properties.push(parseIdentifier());
				if (!match("punct", ",")) break;
				next();
			} while (true);
			eat("punct", "}");
			return {
				type: "ObjectPattern",
				properties
			};
		}
		return parseIdentifier();
	};
	return parseProgram();
};

//#endregion
//#region src/index.ts
const JsonNotes = table({
	name: "note",
	public: true
}, {
	hash: t.string().primaryKey(),
	schemaHash: t.string(),
	data: t.string()
});
const Store = table({
	name: "store",
	public: false
}, {
	key: t.string().primaryKey(),
	value: t.string()
});
const Links = table({
	name: "links",
	public: true
}, {
	to: t.string().primaryKey(),
	from: t.array(t.string())
});
const spacetimedb = schema(JsonNotes, Links, Store);
spacetimedb.view({
	name: "note_count",
	public: true
}, t.array(t.object("NoteCountRow", { count: t.u64() })), (ctx) => [{ count: ctx.db.note.count() }]);
spacetimedb.reducer("add_note", {
	schemaHash: t.string(),
	data: t.string()
}, (ctx, { schemaHash, data }) => {
	const schemaRow = ctx.db.note.hash.find(schemaHash);
	if (!schemaRow) throw new SenderError("Schema not found");
	try {
		const resolve$2 = (ref) => {
			const note = ctx.db.note.hash.find(normalizeRef(ref));
			if (!note) throw new SenderError("Note not found");
			return fromjson(note.data);
		};
		const parsed = fromjson(data);
		validate(expandLinksSync(parsed, resolve$2), expandLinksSync(fromjson(schemaRow.data), resolve$2));
		const hash = hashData({
			schemaHash,
			data: parsed
		});
		if (ctx.db.note.hash.find(hash)) return;
		ctx.db.note.insert({
			hash,
			schemaHash,
			data
		});
		const targets = new Set([schemaRow.hash]);
		const re = /#([a-f0-9]{32})/g;
		let match;
		while (match = re.exec(data)) targets.add(match[1]);
		for (const to of targets) {
			const existing = ctx.db.links.to.find(to);
			if (!existing) ctx.db.links.insert({
				to,
				from: [hash]
			});
			else if (!existing.from.some((x) => x === hash)) ctx.db.links.to.update({
				...existing,
				from: [...existing.from, hash]
			});
		}
		return;
	} catch (e) {
		throw new SenderError("INSERT ERROR: " + fromjson(schemaRow.data));
	}
});
const setup = spacetimedb.reducer("setup", {}, (ctx) => {
	try {
		ctx.db.note.insert({
			hash: hashData(top),
			schemaHash: top.schemaHash,
			data: tojson(top.data)
		});
	} catch {}
	for (const note of schemas) {
		const hash = hashData(note);
		if (ctx.db.note.hash.find(hash)) continue;
		ctx.db.note.insert({
			hash,
			schemaHash: note.schemaHash,
			data: tojson(note.data)
		});
	}
});
spacetimedb.init(setup);
spacetimedb.procedure("run_note_async", {
	hash: t.string(),
	arg: t.string()
}, t.string(), (ctx, { hash, arg }) => {
	const getNote = (ref) => ctx.withTx((c) => c.db.note.hash.find(normalizeRef(ref)));
	const fuelRef = { value: 1e4 };
	const fnSchemaHash = hashData(server_function);
	const call = (ref, arg$1) => {
		const fn = getNote(ref);
		if (fn == null) throw new SenderError("fn not found");
		if (fn.schemaHash != fnSchemaHash) throw new SenderError("not a server function");
		const keyFor = (key) => `${fn.hash}:${key}`;
		let ret = runWithFuelShared(`let args = ${arg$1}; ${fromjson(fn.data).code}`, fuelRef, {
			storage: {
				getItem: (key) => ctx.withTx((ctx$1) => ctx$1.db.store.key.find(keyFor(key))?.value ?? null),
				setItem: (key, value) => ctx.withTx((ctx$1) => {
					const k = keyFor(key);
					if (ctx$1.db.store.key.find(k)) ctx$1.db.store.key.update({
						key: k,
						value
					});
					else ctx$1.db.store.insert({
						key: k,
						value
					});
				})
			},
			call,
			hash: hash128
		});
		if ("err" in ret) throw new SenderError(String(ret.err));
		return ret.ok;
	};
	return tojson(call(hash, arg));
});

//#endregion
export { spacetimedb };
//# debugId=d3a52e70-cc12-4c33-8f60-df65fb3a4267
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVuZGxlLmpzIiwibmFtZXMiOlsiX19jcmVhdGUiLCJfX2RlZlByb3AiLCJfX2dldE93blByb3BEZXNjIiwiX19nZXRPd25Qcm9wTmFtZXMiLCJfX2dldFByb3RvT2YiLCJfX2hhc093blByb3AiLCJfX2NvbW1vbkpTIiwiX19jb3B5UHJvcHMiLCJfX3RvRVNNIiwic3RyIiwicGFyc2UiLCJpbml0IiwiRSIsIl8iLCJleHBvcnRzIiwiI3ZpZXciLCIjb2Zmc2V0IiwiI2Vuc3VyZSIsIiNidWZmZXIiLCIjZXhwYW5kQnVmZmVyIiwic3RyIiwiYW5kIiwiI2Zyb20iLCIjdG8iLCIjYm9keSIsIiNpbm5lciIsInVyaSIsIiNpZGVudGl0eSIsIiNzZW5kZXJBdXRoIiwiI3V1aWRDb3VudGVyIiwiI2ZpbmFsaXphdGlvblJlZ2lzdHJ5IiwiI2lkIiwiI2RldGFjaCIsIl9hIiwibmFtZXMiLCJjb2RlXzEiLCJfYSIsIl9iIiwiZGVmIiwiY29kZV8xIiwibmFtZXMiLCJfYSIsIl9iIiwiY29kZWdlbl8xIiwiY29kZV8xIiwic2NoZW1hIiwic3RyIiwiY29kZWdlbl8xIiwiY29kZWdlbl8xIiwidXRpbF8xIiwibmFtZXNfMSIsImVycm9yc18xIiwiY29kZWdlbl8xIiwibmFtZXNfMSIsInNjaGVtYSIsInNjaGVtYSIsIl9hIiwicnVsZXNfMSIsImFwcGxpY2FiaWxpdHlfMSIsImVycm9yc18xIiwiY29kZWdlbl8xIiwidXRpbF8xIiwic2NoZW1hIiwidCIsImNvZGVnZW5fMSIsInV0aWxfMSIsImNvZGVnZW5fMSIsInV0aWxfMSIsIm5hbWVzXzEiLCJ1dGlsXzIiLCJzY2hlbWEiLCJjb2RlZ2VuXzEiLCJuYW1lc18xIiwiY29kZV8xIiwiZXJyb3JzXzEiLCJkZWYiLCJzY2hlbWEiLCJfYSIsImVycm9ycyIsImNvZGVnZW5fMSIsInV0aWxfMSIsInNjaGVtYSIsImVxdWFsIiwidHJhdmVyc2UiLCJzY2hlbWEiLCJzdHIiLCJ1dGlsXzEiLCJlcXVhbCIsInNjaGVtYSIsIm5vcm1hbGl6ZSIsImRhdGFUeXBlXzEiLCJjb2RlZ2VuXzEiLCJuYW1lc18xIiwicmVzb2x2ZV8xIiwidXRpbF8xIiwic2NoZW1hIiwiVmFsaWRhdGlvbkVycm9yIiwidCIsImRlZiIsImVycm9ycyIsInJlc29sdmVfMSIsImNvZGVnZW5fMSIsInZhbGlkYXRpb25fZXJyb3JfMSIsIm5hbWVzXzEiLCJyZXNvbHZlXzEiLCJ1dGlsXzEiLCJ2YWxpZGF0ZV8xIiwiX2EiLCJzY2hlbWEiLCJ2YWxpZGF0ZSIsInJlc29sdmUiLCJpc1VVSUQiLCJpc0lQdjQiLCJub25TaW1wbGVEb21haW4iLCJub3JtYWxpemVJUHY2Iiwic3RyIiwicmVtb3ZlRG90U2VnbWVudHMiLCJub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyIsInJlY29tcG9zZUF1dGhvcml0eSIsImdldFNjaGVtZUhhbmRsZXIiLCJTQ0hFTUVTIiwidXJpIiwicGFyc2UiLCJlcXVhbCIsInZhbGlkYXRlXzEiLCJjb2RlZ2VuXzEiLCJ2YWxpZGF0aW9uX2Vycm9yXzEiLCJyZWZfZXJyb3JfMSIsImNvbXBpbGVfMSIsImRhdGFUeXBlXzEiLCJ1dGlsXzEiLCJzdHIiLCJfYSIsIl9iIiwiX2MiLCJvcHRpbWl6ZSIsIkFqdiIsInNjaGVtYSIsImRlZiIsInQiLCJmb3JtYXQiLCJlcnJvcnMiLCJrZXl3b3JkcyIsInNjaGVtYXMiLCJkZWYiLCJyZWZfZXJyb3JfMSIsImNvZGVfMSIsImNvZGVnZW5fMSIsIm5hbWVzXzEiLCJjb21waWxlXzEiLCJ1dGlsXzEiLCJkZWYiLCJfYSIsImNvZGVnZW5fMSIsImRlZiIsImNvZGVnZW5fMSIsImRlZiIsInN0ciIsImNvZGVnZW5fMSIsInV0aWxfMSIsImRlZiIsImNvZGVfMSIsImNvZGVnZW5fMSIsImRlZiIsInNjaGVtYSIsImNvZGVnZW5fMSIsImRlZiIsImNvZGVfMSIsImNvZGVnZW5fMSIsInV0aWxfMSIsImRlZiIsInNjaGVtYSIsImNvZGVnZW5fMSIsImRlZiIsImNvZGVnZW5fMSIsInV0aWxfMSIsImVxdWFsXzEiLCJkZWYiLCJzY2hlbWEiLCJ0IiwiY29kZWdlbl8xIiwidXRpbF8xIiwiZXF1YWxfMSIsImRlZiIsInNjaGVtYSIsImNvZGVnZW5fMSIsInV0aWxfMSIsImRlZiIsInNjaGVtYSIsImNvZGVnZW5fMSIsInV0aWxfMSIsImRlZiIsInNjaGVtYSIsImNvZGVnZW5fMSIsInV0aWxfMSIsImNvZGVfMSIsImRlZiIsInNjaGVtYSIsIml0ZW1zXzEiLCJkZWYiLCJjb2RlZ2VuXzEiLCJ1dGlsXzEiLCJjb2RlXzEiLCJhZGRpdGlvbmFsSXRlbXNfMSIsImRlZiIsInNjaGVtYSIsImNvZGVnZW5fMSIsInV0aWxfMSIsImRlZiIsInNjaGVtYSIsImNvZGVnZW5fMSIsInV0aWxfMSIsImNvZGVfMSIsImRlZiIsInNjaGVtYSIsImNvZGVnZW5fMSIsInV0aWxfMSIsImRlZiIsInNjaGVtYSIsImNvZGVfMSIsImNvZGVnZW5fMSIsInV0aWxfMSIsImRlZiIsInNjaGVtYSIsImVycm9ycyIsInZhbGlkYXRlXzEiLCJjb2RlXzEiLCJ1dGlsXzEiLCJhZGRpdGlvbmFsUHJvcGVydGllc18xIiwiZGVmIiwic2NoZW1hIiwiY29kZWdlbl8xIiwidXRpbF8xIiwiZGVmIiwic2NoZW1hIiwidXRpbF8xIiwiZGVmIiwic2NoZW1hIiwiZGVmIiwiY29kZWdlbl8xIiwidXRpbF8xIiwiZGVmIiwic2NoZW1hIiwidXRpbF8xIiwiZGVmIiwic2NoZW1hIiwiY29kZWdlbl8xIiwidXRpbF8xIiwiZGVmIiwic2NoZW1hIiwidXRpbF8xIiwiZGVmIiwiY29kZWdlbl8xIiwiZGVmIiwiZm9ybWF0Iiwic2NoZW1hIiwiY29yZV8xIiwiY29kZWdlbl8xIiwicmVmX2Vycm9yXzEiLCJzY2hlbWEiLCJfYSIsIkFqdiIsInZhbGlkYXRlIiwiQWp2Iiwic2NoZW1hIiwidG9wOiBOb3RlRGF0YSIsInNjaGVtYXMgOiBOb3RlRGF0YVtdIiwicmVzb2x2ZSIsInRva2VuczogVG9rZW5bXSIsInN0YXJ0IiwiZXJyb3JzOiBzdHJpbmdbXSIsImVycm9ycyIsInQiLCJib2R5OiBTdG10W10iLCJkZWNsYXJhdGlvbnM6IFZhckRlY2xbXSIsImluaXQiLCJpbml0OiBWYXJEZWNsW10gfCBFeHByIHwgbnVsbCIsImluaXRLaW5kOiBcImxldFwiIHwgXCJjb25zdFwiIHwgbnVsbCIsImJvZHkiLCJwYXJhbXM6IElkZW50aWZpZXJbXSIsImVsZW1lbnRzOiBFeHByW10iLCJwcm9wZXJ0aWVzOiBQcm9wZXJ0eVtdIiwia2V5OiBJZGVudGlmaWVyIHwgTGl0ZXJhbCIsInZhbHVlOiBFeHByIiwiYXJnczogRXhwcltdIiwiZWxlbWVudHM6IElkZW50aWZpZXJbXSIsInByb3BlcnRpZXM6IElkZW50aWZpZXJbXSIsInJlc29sdmUiLCJtYXRjaDogUmVnRXhwRXhlY0FycmF5IHwgbnVsbCIsImFyZyIsImN0eCJdLCJzb3VyY2VzIjpbIi4uL25vZGVfbW9kdWxlcy9oZWFkZXJzLXBvbHlmaWxsL2xpYi9pbmRleC5tanMiLCIuLi9ub2RlX21vZHVsZXMvc3BhY2V0aW1lZGIvZGlzdC9zZXJ2ZXIvaW5kZXgubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvY29kZWdlbi9jb2RlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvY29kZWdlbi9zY29wZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL2NvZGVnZW4vaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS91dGlsLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvbmFtZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS9lcnJvcnMuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS92YWxpZGF0ZS9ib29sU2NoZW1hLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvcnVsZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS92YWxpZGF0ZS9hcHBsaWNhYmlsaXR5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvdmFsaWRhdGUvZGF0YVR5cGUuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS92YWxpZGF0ZS9kZWZhdWx0cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvY29kZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3ZhbGlkYXRlL2tleXdvcmQuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS92YWxpZGF0ZS9zdWJzY2hlbWEuanMiLCIuLi9ub2RlX21vZHVsZXMvZmFzdC1kZWVwLWVxdWFsL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2pzb24tc2NoZW1hLXRyYXZlcnNlL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvcmVzb2x2ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3ZhbGlkYXRlL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3J1bnRpbWUvdmFsaWRhdGlvbl9lcnJvci5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3JlZl9lcnJvci5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3JlZnMvZGF0YS5qc29uIiwiLi4vbm9kZV9tb2R1bGVzL2Zhc3QtdXJpL2xpYi91dGlscy5qcyIsIi4uL25vZGVfbW9kdWxlcy9mYXN0LXVyaS9saWIvc2NoZW1lcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9mYXN0LXVyaS9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9ydW50aW1lL3VyaS5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb3JlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9jb3JlL2lkLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9jb3JlL3JlZi5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvY29yZS9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9saW1pdE51bWJlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9tdWx0aXBsZU9mLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3J1bnRpbWUvdWNzMmxlbmd0aC5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9saW1pdExlbmd0aC5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9wYXR0ZXJuLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL2xpbWl0UHJvcGVydGllcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9yZXF1aXJlZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9saW1pdEl0ZW1zLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3J1bnRpbWUvZXF1YWwuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vdW5pcXVlSXRlbXMuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vY29uc3QuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vZW51bS5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9hZGRpdGlvbmFsSXRlbXMuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvaXRlbXMuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvcHJlZml4SXRlbXMuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvaXRlbXMyMDIwLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2NvbnRhaW5zLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2RlcGVuZGVuY2llcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9wcm9wZXJ0eU5hbWVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2FkZGl0aW9uYWxQcm9wZXJ0aWVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL3Byb3BlcnRpZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvcGF0dGVyblByb3BlcnRpZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3Ivbm90LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2FueU9mLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL29uZU9mLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2FsbE9mLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2lmLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL3RoZW5FbHNlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9mb3JtYXQvZm9ybWF0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9mb3JtYXQvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL21ldGFkYXRhLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9kcmFmdDcuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2Rpc2NyaW1pbmF0b3IvdHlwZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2Rpc2NyaW1pbmF0b3IvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvcmVmcy9qc29uLXNjaGVtYS1kcmFmdC0wNy5qc29uIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2Fqdi5qcyIsInNyYy9oYXNoLnRzIiwic3JjL25vdGVzLnRzIiwic3JjL3BhcnNlci50cyIsInNyYy9pbmRleC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fY29tbW9uSlMgPSAoY2IsIG1vZCkgPT4gZnVuY3Rpb24gX19yZXF1aXJlKCkge1xuICByZXR1cm4gbW9kIHx8ICgwLCBjYltfX2dldE93blByb3BOYW1lcyhjYilbMF1dKSgobW9kID0geyBleHBvcnRzOiB7fSB9KS5leHBvcnRzLCBtb2QpLCBtb2QuZXhwb3J0cztcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0VTTSA9IChtb2QsIGlzTm9kZU1vZGUsIHRhcmdldCkgPT4gKHRhcmdldCA9IG1vZCAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZCkpIDoge30sIF9fY29weVByb3BzKFxuICAvLyBJZiB0aGUgaW1wb3J0ZXIgaXMgaW4gbm9kZSBjb21wYXRpYmlsaXR5IG1vZGUgb3IgdGhpcyBpcyBub3QgYW4gRVNNXG4gIC8vIGZpbGUgdGhhdCBoYXMgYmVlbiBjb252ZXJ0ZWQgdG8gYSBDb21tb25KUyBmaWxlIHVzaW5nIGEgQmFiZWwtXG4gIC8vIGNvbXBhdGlibGUgdHJhbnNmb3JtIChpLmUuIFwiX19lc01vZHVsZVwiIGhhcyBub3QgYmVlbiBzZXQpLCB0aGVuIHNldFxuICAvLyBcImRlZmF1bHRcIiB0byB0aGUgQ29tbW9uSlMgXCJtb2R1bGUuZXhwb3J0c1wiIGZvciBub2RlIGNvbXBhdGliaWxpdHkuXG4gIGlzTm9kZU1vZGUgfHwgIW1vZCB8fCAhbW9kLl9fZXNNb2R1bGUgPyBfX2RlZlByb3AodGFyZ2V0LCBcImRlZmF1bHRcIiwgeyB2YWx1ZTogbW9kLCBlbnVtZXJhYmxlOiB0cnVlIH0pIDogdGFyZ2V0LFxuICBtb2RcbikpO1xuXG4vLyBub2RlX21vZHVsZXMvc2V0LWNvb2tpZS1wYXJzZXIvbGliL3NldC1jb29raWUuanNcbnZhciByZXF1aXJlX3NldF9jb29raWUgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvc2V0LWNvb2tpZS1wYXJzZXIvbGliL3NldC1jb29raWUuanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgZGVmYXVsdFBhcnNlT3B0aW9ucyA9IHtcbiAgICAgIGRlY29kZVZhbHVlczogdHJ1ZSxcbiAgICAgIG1hcDogZmFsc2UsXG4gICAgICBzaWxlbnQ6IGZhbHNlXG4gICAgfTtcbiAgICBmdW5jdGlvbiBpc05vbkVtcHR5U3RyaW5nKHN0cikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBzdHIgPT09IFwic3RyaW5nXCIgJiYgISFzdHIudHJpbSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZVN0cmluZyhzZXRDb29raWVWYWx1ZSwgb3B0aW9ucykge1xuICAgICAgdmFyIHBhcnRzID0gc2V0Q29va2llVmFsdWUuc3BsaXQoXCI7XCIpLmZpbHRlcihpc05vbkVtcHR5U3RyaW5nKTtcbiAgICAgIHZhciBuYW1lVmFsdWVQYWlyU3RyID0gcGFydHMuc2hpZnQoKTtcbiAgICAgIHZhciBwYXJzZWQgPSBwYXJzZU5hbWVWYWx1ZVBhaXIobmFtZVZhbHVlUGFpclN0cik7XG4gICAgICB2YXIgbmFtZSA9IHBhcnNlZC5uYW1lO1xuICAgICAgdmFyIHZhbHVlID0gcGFyc2VkLnZhbHVlO1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0UGFyc2VPcHRpb25zLCBvcHRpb25zKSA6IGRlZmF1bHRQYXJzZU9wdGlvbnM7XG4gICAgICB0cnkge1xuICAgICAgICB2YWx1ZSA9IG9wdGlvbnMuZGVjb2RlVmFsdWVzID8gZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKSA6IHZhbHVlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwic2V0LWNvb2tpZS1wYXJzZXIgZW5jb3VudGVyZWQgYW4gZXJyb3Igd2hpbGUgZGVjb2RpbmcgYSBjb29raWUgd2l0aCB2YWx1ZSAnXCIgKyB2YWx1ZSArIFwiJy4gU2V0IG9wdGlvbnMuZGVjb2RlVmFsdWVzIHRvIGZhbHNlIHRvIGRpc2FibGUgdGhpcyBmZWF0dXJlLlwiLFxuICAgICAgICAgIGVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHZhciBjb29raWUgPSB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIHZhbHVlXG4gICAgICB9O1xuICAgICAgcGFydHMuZm9yRWFjaChmdW5jdGlvbihwYXJ0KSB7XG4gICAgICAgIHZhciBzaWRlcyA9IHBhcnQuc3BsaXQoXCI9XCIpO1xuICAgICAgICB2YXIga2V5ID0gc2lkZXMuc2hpZnQoKS50cmltTGVmdCgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHZhciB2YWx1ZTIgPSBzaWRlcy5qb2luKFwiPVwiKTtcbiAgICAgICAgaWYgKGtleSA9PT0gXCJleHBpcmVzXCIpIHtcbiAgICAgICAgICBjb29raWUuZXhwaXJlcyA9IG5ldyBEYXRlKHZhbHVlMik7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcIm1heC1hZ2VcIikge1xuICAgICAgICAgIGNvb2tpZS5tYXhBZ2UgPSBwYXJzZUludCh2YWx1ZTIsIDEwKTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09IFwic2VjdXJlXCIpIHtcbiAgICAgICAgICBjb29raWUuc2VjdXJlID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09IFwiaHR0cG9ubHlcIikge1xuICAgICAgICAgIGNvb2tpZS5odHRwT25seSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcInNhbWVzaXRlXCIpIHtcbiAgICAgICAgICBjb29raWUuc2FtZVNpdGUgPSB2YWx1ZTI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29va2llW2tleV0gPSB2YWx1ZTI7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNvb2tpZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VOYW1lVmFsdWVQYWlyKG5hbWVWYWx1ZVBhaXJTdHIpIHtcbiAgICAgIHZhciBuYW1lID0gXCJcIjtcbiAgICAgIHZhciB2YWx1ZSA9IFwiXCI7XG4gICAgICB2YXIgbmFtZVZhbHVlQXJyID0gbmFtZVZhbHVlUGFpclN0ci5zcGxpdChcIj1cIik7XG4gICAgICBpZiAobmFtZVZhbHVlQXJyLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgbmFtZSA9IG5hbWVWYWx1ZUFyci5zaGlmdCgpO1xuICAgICAgICB2YWx1ZSA9IG5hbWVWYWx1ZUFyci5qb2luKFwiPVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gbmFtZVZhbHVlUGFpclN0cjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IG5hbWUsIHZhbHVlIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyA/IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRQYXJzZU9wdGlvbnMsIG9wdGlvbnMpIDogZGVmYXVsdFBhcnNlT3B0aW9ucztcbiAgICAgIGlmICghaW5wdXQpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zLm1hcCkge1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpbnB1dC5oZWFkZXJzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQuaGVhZGVycy5nZXRTZXRDb29raWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIGlucHV0ID0gaW5wdXQuaGVhZGVycy5nZXRTZXRDb29raWUoKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dC5oZWFkZXJzW1wic2V0LWNvb2tpZVwiXSkge1xuICAgICAgICAgIGlucHV0ID0gaW5wdXQuaGVhZGVyc1tcInNldC1jb29raWVcIl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHNjaCA9IGlucHV0LmhlYWRlcnNbT2JqZWN0LmtleXMoaW5wdXQuaGVhZGVycykuZmluZChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gXCJzZXQtY29va2llXCI7XG4gICAgICAgICAgfSldO1xuICAgICAgICAgIGlmICghc2NoICYmIGlucHV0LmhlYWRlcnMuY29va2llICYmICFvcHRpb25zLnNpbGVudCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICBcIldhcm5pbmc6IHNldC1jb29raWUtcGFyc2VyIGFwcGVhcnMgdG8gaGF2ZSBiZWVuIGNhbGxlZCBvbiBhIHJlcXVlc3Qgb2JqZWN0LiBJdCBpcyBkZXNpZ25lZCB0byBwYXJzZSBTZXQtQ29va2llIGhlYWRlcnMgZnJvbSByZXNwb25zZXMsIG5vdCBDb29raWUgaGVhZGVycyBmcm9tIHJlcXVlc3RzLiBTZXQgdGhlIG9wdGlvbiB7c2lsZW50OiB0cnVlfSB0byBzdXBwcmVzcyB0aGlzIHdhcm5pbmcuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlucHV0ID0gc2NoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgIGlucHV0ID0gW2lucHV0XTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zID8gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFBhcnNlT3B0aW9ucywgb3B0aW9ucykgOiBkZWZhdWx0UGFyc2VPcHRpb25zO1xuICAgICAgaWYgKCFvcHRpb25zLm1hcCkge1xuICAgICAgICByZXR1cm4gaW5wdXQuZmlsdGVyKGlzTm9uRW1wdHlTdHJpbmcpLm1hcChmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VTdHJpbmcoc3RyLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY29va2llcyA9IHt9O1xuICAgICAgICByZXR1cm4gaW5wdXQuZmlsdGVyKGlzTm9uRW1wdHlTdHJpbmcpLnJlZHVjZShmdW5jdGlvbihjb29raWVzMiwgc3RyKSB7XG4gICAgICAgICAgdmFyIGNvb2tpZSA9IHBhcnNlU3RyaW5nKHN0ciwgb3B0aW9ucyk7XG4gICAgICAgICAgY29va2llczJbY29va2llLm5hbWVdID0gY29va2llO1xuICAgICAgICAgIHJldHVybiBjb29raWVzMjtcbiAgICAgICAgfSwgY29va2llcyk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNwbGl0Q29va2llc1N0cmluZzIoY29va2llc1N0cmluZykge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29va2llc1N0cmluZykpIHtcbiAgICAgICAgcmV0dXJuIGNvb2tpZXNTdHJpbmc7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGNvb2tpZXNTdHJpbmcgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIGNvb2tpZXNTdHJpbmdzID0gW107XG4gICAgICB2YXIgcG9zID0gMDtcbiAgICAgIHZhciBzdGFydDtcbiAgICAgIHZhciBjaDtcbiAgICAgIHZhciBsYXN0Q29tbWE7XG4gICAgICB2YXIgbmV4dFN0YXJ0O1xuICAgICAgdmFyIGNvb2tpZXNTZXBhcmF0b3JGb3VuZDtcbiAgICAgIGZ1bmN0aW9uIHNraXBXaGl0ZXNwYWNlKCkge1xuICAgICAgICB3aGlsZSAocG9zIDwgY29va2llc1N0cmluZy5sZW5ndGggJiYgL1xccy8udGVzdChjb29raWVzU3RyaW5nLmNoYXJBdChwb3MpKSkge1xuICAgICAgICAgIHBvcyArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3MgPCBjb29raWVzU3RyaW5nLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG5vdFNwZWNpYWxDaGFyKCkge1xuICAgICAgICBjaCA9IGNvb2tpZXNTdHJpbmcuY2hhckF0KHBvcyk7XG4gICAgICAgIHJldHVybiBjaCAhPT0gXCI9XCIgJiYgY2ggIT09IFwiO1wiICYmIGNoICE9PSBcIixcIjtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChwb3MgPCBjb29raWVzU3RyaW5nLmxlbmd0aCkge1xuICAgICAgICBzdGFydCA9IHBvcztcbiAgICAgICAgY29va2llc1NlcGFyYXRvckZvdW5kID0gZmFsc2U7XG4gICAgICAgIHdoaWxlIChza2lwV2hpdGVzcGFjZSgpKSB7XG4gICAgICAgICAgY2ggPSBjb29raWVzU3RyaW5nLmNoYXJBdChwb3MpO1xuICAgICAgICAgIGlmIChjaCA9PT0gXCIsXCIpIHtcbiAgICAgICAgICAgIGxhc3RDb21tYSA9IHBvcztcbiAgICAgICAgICAgIHBvcyArPSAxO1xuICAgICAgICAgICAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgICAgICAgICAgIG5leHRTdGFydCA9IHBvcztcbiAgICAgICAgICAgIHdoaWxlIChwb3MgPCBjb29raWVzU3RyaW5nLmxlbmd0aCAmJiBub3RTcGVjaWFsQ2hhcigpKSB7XG4gICAgICAgICAgICAgIHBvcyArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvcyA8IGNvb2tpZXNTdHJpbmcubGVuZ3RoICYmIGNvb2tpZXNTdHJpbmcuY2hhckF0KHBvcykgPT09IFwiPVwiKSB7XG4gICAgICAgICAgICAgIGNvb2tpZXNTZXBhcmF0b3JGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgIHBvcyA9IG5leHRTdGFydDtcbiAgICAgICAgICAgICAgY29va2llc1N0cmluZ3MucHVzaChjb29raWVzU3RyaW5nLnN1YnN0cmluZyhzdGFydCwgbGFzdENvbW1hKSk7XG4gICAgICAgICAgICAgIHN0YXJ0ID0gcG9zO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcG9zID0gbGFzdENvbW1hICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9zICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghY29va2llc1NlcGFyYXRvckZvdW5kIHx8IHBvcyA+PSBjb29raWVzU3RyaW5nLmxlbmd0aCkge1xuICAgICAgICAgIGNvb2tpZXNTdHJpbmdzLnB1c2goY29va2llc1N0cmluZy5zdWJzdHJpbmcoc3RhcnQsIGNvb2tpZXNTdHJpbmcubGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjb29raWVzU3RyaW5ncztcbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBwYXJzZTtcbiAgICBtb2R1bGUuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuICAgIG1vZHVsZS5leHBvcnRzLnBhcnNlU3RyaW5nID0gcGFyc2VTdHJpbmc7XG4gICAgbW9kdWxlLmV4cG9ydHMuc3BsaXRDb29raWVzU3RyaW5nID0gc3BsaXRDb29raWVzU3RyaW5nMjtcbiAgfVxufSk7XG5cbi8vIHNyYy9IZWFkZXJzLnRzXG52YXIgaW1wb3J0X3NldF9jb29raWVfcGFyc2VyID0gX190b0VTTShyZXF1aXJlX3NldF9jb29raWUoKSk7XG5cbi8vIHNyYy91dGlscy9ub3JtYWxpemVIZWFkZXJOYW1lLnRzXG52YXIgSEVBREVSU19JTlZBTElEX0NIQVJBQ1RFUlMgPSAvW15hLXowLTlcXC0jJCUmJyorLl5fYHx+XS9pO1xuZnVuY3Rpb24gbm9ybWFsaXplSGVhZGVyTmFtZShuYW1lKSB7XG4gIGlmIChIRUFERVJTX0lOVkFMSURfQ0hBUkFDVEVSUy50ZXN0KG5hbWUpIHx8IG5hbWUudHJpbSgpID09PSBcIlwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgY2hhcmFjdGVyIGluIGhlYWRlciBmaWVsZCBuYW1lXCIpO1xuICB9XG4gIHJldHVybiBuYW1lLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xufVxuXG4vLyBzcmMvdXRpbHMvbm9ybWFsaXplSGVhZGVyVmFsdWUudHNcbnZhciBjaGFyQ29kZXNUb1JlbW92ZSA9IFtcbiAgU3RyaW5nLmZyb21DaGFyQ29kZSgxMCksXG4gIFN0cmluZy5mcm9tQ2hhckNvZGUoMTMpLFxuICBTdHJpbmcuZnJvbUNoYXJDb2RlKDkpLFxuICBTdHJpbmcuZnJvbUNoYXJDb2RlKDMyKVxuXTtcbnZhciBIRUFERVJfVkFMVUVfUkVNT1ZFX1JFR0VYUCA9IG5ldyBSZWdFeHAoXG4gIGAoXlske2NoYXJDb2Rlc1RvUmVtb3ZlLmpvaW4oXCJcIil9XXwkWyR7Y2hhckNvZGVzVG9SZW1vdmUuam9pbihcIlwiKX1dKWAsXG4gIFwiZ1wiXG4pO1xuZnVuY3Rpb24gbm9ybWFsaXplSGVhZGVyVmFsdWUodmFsdWUpIHtcbiAgY29uc3QgbmV4dFZhbHVlID0gdmFsdWUucmVwbGFjZShIRUFERVJfVkFMVUVfUkVNT1ZFX1JFR0VYUCwgXCJcIik7XG4gIHJldHVybiBuZXh0VmFsdWU7XG59XG5cbi8vIHNyYy91dGlscy9pc1ZhbGlkSGVhZGVyTmFtZS50c1xuZnVuY3Rpb24gaXNWYWxpZEhlYWRlck5hbWUodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGFyYWN0ZXIgPSB2YWx1ZS5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjaGFyYWN0ZXIgPiAxMjcgfHwgIWlzVG9rZW4oY2hhcmFjdGVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGlzVG9rZW4odmFsdWUpIHtcbiAgcmV0dXJuICFbXG4gICAgMTI3LFxuICAgIDMyLFxuICAgIFwiKFwiLFxuICAgIFwiKVwiLFxuICAgIFwiPFwiLFxuICAgIFwiPlwiLFxuICAgIFwiQFwiLFxuICAgIFwiLFwiLFxuICAgIFwiO1wiLFxuICAgIFwiOlwiLFxuICAgIFwiXFxcXFwiLFxuICAgICdcIicsXG4gICAgXCIvXCIsXG4gICAgXCJbXCIsXG4gICAgXCJdXCIsXG4gICAgXCI/XCIsXG4gICAgXCI9XCIsXG4gICAgXCJ7XCIsXG4gICAgXCJ9XCJcbiAgXS5pbmNsdWRlcyh2YWx1ZSk7XG59XG5cbi8vIHNyYy91dGlscy9pc1ZhbGlkSGVhZGVyVmFsdWUudHNcbmZ1bmN0aW9uIGlzVmFsaWRIZWFkZXJWYWx1ZSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh2YWx1ZS50cmltKCkgIT09IHZhbHVlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGFyYWN0ZXIgPSB2YWx1ZS5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChcbiAgICAgIC8vIE5VTC5cbiAgICAgIGNoYXJhY3RlciA9PT0gMCB8fCAvLyBIVFRQIG5ld2xpbmUgYnl0ZXMuXG4gICAgICBjaGFyYWN0ZXIgPT09IDEwIHx8IGNoYXJhY3RlciA9PT0gMTNcbiAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIHNyYy9IZWFkZXJzLnRzXG52YXIgTk9STUFMSVpFRF9IRUFERVJTID0gU3ltYm9sKFwibm9ybWFsaXplZEhlYWRlcnNcIik7XG52YXIgUkFXX0hFQURFUl9OQU1FUyA9IFN5bWJvbChcInJhd0hlYWRlck5hbWVzXCIpO1xudmFyIEhFQURFUl9WQUxVRV9ERUxJTUlURVIgPSBcIiwgXCI7XG52YXIgX2EsIF9iLCBfYztcbnZhciBIZWFkZXJzID0gY2xhc3MgX0hlYWRlcnMge1xuICBjb25zdHJ1Y3Rvcihpbml0KSB7XG4gICAgLy8gTm9ybWFsaXplZCBoZWFkZXIge1wibmFtZVwiOlwiYSwgYlwifSBzdG9yYWdlLlxuICAgIHRoaXNbX2FdID0ge307XG4gICAgLy8gS2VlcHMgdGhlIG1hcHBpbmcgYmV0d2VlbiB0aGUgcmF3IGhlYWRlciBuYW1lXG4gICAgLy8gYW5kIHRoZSBub3JtYWxpemVkIGhlYWRlciBuYW1lIHRvIGVhc2UgdGhlIGxvb2t1cC5cbiAgICB0aGlzW19iXSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpc1tfY10gPSBcIkhlYWRlcnNcIjtcbiAgICBpZiAoW1wiSGVhZGVyc1wiLCBcIkhlYWRlcnNQb2x5ZmlsbFwiXS5pbmNsdWRlcyhpbml0Py5jb25zdHJ1Y3Rvci5uYW1lKSB8fCBpbml0IGluc3RhbmNlb2YgX0hlYWRlcnMgfHwgdHlwZW9mIGdsb2JhbFRoaXMuSGVhZGVycyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpbml0IGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5IZWFkZXJzKSB7XG4gICAgICBjb25zdCBpbml0aWFsSGVhZGVycyA9IGluaXQ7XG4gICAgICBpbml0aWFsSGVhZGVycy5mb3JFYWNoKCh2YWx1ZSwgbmFtZSkgPT4ge1xuICAgICAgICB0aGlzLmFwcGVuZChuYW1lLCB2YWx1ZSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaW5pdCkpIHtcbiAgICAgIGluaXQuZm9yRWFjaCgoW25hbWUsIHZhbHVlXSkgPT4ge1xuICAgICAgICB0aGlzLmFwcGVuZChcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUuam9pbihIRUFERVJfVkFMVUVfREVMSU1JVEVSKSA6IHZhbHVlXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGluaXQpIHtcbiAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGluaXQpLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBpbml0W25hbWVdO1xuICAgICAgICB0aGlzLmFwcGVuZChcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUuam9pbihIRUFERVJfVkFMVUVfREVMSU1JVEVSKSA6IHZhbHVlXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgWyhfYSA9IE5PUk1BTElaRURfSEVBREVSUywgX2IgPSBSQVdfSEVBREVSX05BTUVTLCBfYyA9IFN5bWJvbC50b1N0cmluZ1RhZywgU3ltYm9sLml0ZXJhdG9yKV0oKSB7XG4gICAgcmV0dXJuIHRoaXMuZW50cmllcygpO1xuICB9XG4gICprZXlzKCkge1xuICAgIGZvciAoY29uc3QgW25hbWVdIG9mIHRoaXMuZW50cmllcygpKSB7XG4gICAgICB5aWVsZCBuYW1lO1xuICAgIH1cbiAgfVxuICAqdmFsdWVzKCkge1xuICAgIGZvciAoY29uc3QgWywgdmFsdWVdIG9mIHRoaXMuZW50cmllcygpKSB7XG4gICAgICB5aWVsZCB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgKmVudHJpZXMoKSB7XG4gICAgbGV0IHNvcnRlZEtleXMgPSBPYmplY3Qua2V5cyh0aGlzW05PUk1BTElaRURfSEVBREVSU10pLnNvcnQoXG4gICAgICAoYSwgYikgPT4gYS5sb2NhbGVDb21wYXJlKGIpXG4gICAgKTtcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2Ygc29ydGVkS2V5cykge1xuICAgICAgaWYgKG5hbWUgPT09IFwic2V0LWNvb2tpZVwiKSB7XG4gICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdGhpcy5nZXRTZXRDb29raWUoKSkge1xuICAgICAgICAgIHlpZWxkIFtuYW1lLCB2YWx1ZV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHlpZWxkIFtuYW1lLCB0aGlzLmdldChuYW1lKV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgYm9vbGVhbiBzdGF0aW5nIHdoZXRoZXIgYSBgSGVhZGVyc2Agb2JqZWN0IGNvbnRhaW5zIGEgY2VydGFpbiBoZWFkZXIuXG4gICAqL1xuICBoYXMobmFtZSkge1xuICAgIGlmICghaXNWYWxpZEhlYWRlck5hbWUobmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgaGVhZGVyIG5hbWUgXCIke25hbWV9XCJgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNbTk9STUFMSVpFRF9IRUFERVJTXS5oYXNPd25Qcm9wZXJ0eShub3JtYWxpemVIZWFkZXJOYW1lKG5hbWUpKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIGBCeXRlU3RyaW5nYCBzZXF1ZW5jZSBvZiBhbGwgdGhlIHZhbHVlcyBvZiBhIGhlYWRlciB3aXRoIGEgZ2l2ZW4gbmFtZS5cbiAgICovXG4gIGdldChuYW1lKSB7XG4gICAgaWYgKCFpc1ZhbGlkSGVhZGVyTmFtZShuYW1lKSkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKGBJbnZhbGlkIGhlYWRlciBuYW1lIFwiJHtuYW1lfVwiYCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzW05PUk1BTElaRURfSEVBREVSU11bbm9ybWFsaXplSGVhZGVyTmFtZShuYW1lKV0gPz8gbnVsbDtcbiAgfVxuICAvKipcbiAgICogU2V0cyBhIG5ldyB2YWx1ZSBmb3IgYW4gZXhpc3RpbmcgaGVhZGVyIGluc2lkZSBhIGBIZWFkZXJzYCBvYmplY3QsIG9yIGFkZHMgdGhlIGhlYWRlciBpZiBpdCBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0LlxuICAgKi9cbiAgc2V0KG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKCFpc1ZhbGlkSGVhZGVyTmFtZShuYW1lKSB8fCAhaXNWYWxpZEhlYWRlclZhbHVlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBub3JtYWxpemVkTmFtZSA9IG5vcm1hbGl6ZUhlYWRlck5hbWUobmFtZSk7XG4gICAgY29uc3Qgbm9ybWFsaXplZFZhbHVlID0gbm9ybWFsaXplSGVhZGVyVmFsdWUodmFsdWUpO1xuICAgIHRoaXNbTk9STUFMSVpFRF9IRUFERVJTXVtub3JtYWxpemVkTmFtZV0gPSBub3JtYWxpemVIZWFkZXJWYWx1ZShub3JtYWxpemVkVmFsdWUpO1xuICAgIHRoaXNbUkFXX0hFQURFUl9OQU1FU10uc2V0KG5vcm1hbGl6ZWROYW1lLCBuYW1lKTtcbiAgfVxuICAvKipcbiAgICogQXBwZW5kcyBhIG5ldyB2YWx1ZSBvbnRvIGFuIGV4aXN0aW5nIGhlYWRlciBpbnNpZGUgYSBgSGVhZGVyc2Agb2JqZWN0LCBvciBhZGRzIHRoZSBoZWFkZXIgaWYgaXQgZG9lcyBub3QgYWxyZWFkeSBleGlzdC5cbiAgICovXG4gIGFwcGVuZChuYW1lLCB2YWx1ZSkge1xuICAgIGlmICghaXNWYWxpZEhlYWRlck5hbWUobmFtZSkgfHwgIWlzVmFsaWRIZWFkZXJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgbm9ybWFsaXplZE5hbWUgPSBub3JtYWxpemVIZWFkZXJOYW1lKG5hbWUpO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRWYWx1ZSA9IG5vcm1hbGl6ZUhlYWRlclZhbHVlKHZhbHVlKTtcbiAgICBsZXQgcmVzb2x2ZWRWYWx1ZSA9IHRoaXMuaGFzKG5vcm1hbGl6ZWROYW1lKSA/IGAke3RoaXMuZ2V0KG5vcm1hbGl6ZWROYW1lKX0sICR7bm9ybWFsaXplZFZhbHVlfWAgOiBub3JtYWxpemVkVmFsdWU7XG4gICAgdGhpcy5zZXQobmFtZSwgcmVzb2x2ZWRWYWx1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZXMgYSBoZWFkZXIgZnJvbSB0aGUgYEhlYWRlcnNgIG9iamVjdC5cbiAgICovXG4gIGRlbGV0ZShuYW1lKSB7XG4gICAgaWYgKCFpc1ZhbGlkSGVhZGVyTmFtZShuYW1lKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaGFzKG5hbWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5vcm1hbGl6ZWROYW1lID0gbm9ybWFsaXplSGVhZGVyTmFtZShuYW1lKTtcbiAgICBkZWxldGUgdGhpc1tOT1JNQUxJWkVEX0hFQURFUlNdW25vcm1hbGl6ZWROYW1lXTtcbiAgICB0aGlzW1JBV19IRUFERVJfTkFNRVNdLmRlbGV0ZShub3JtYWxpemVkTmFtZSk7XG4gIH1cbiAgLyoqXG4gICAqIFRyYXZlcnNlcyB0aGUgYEhlYWRlcnNgIG9iamVjdCxcbiAgICogY2FsbGluZyB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGVhY2ggaGVhZGVyLlxuICAgKi9cbiAgZm9yRWFjaChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgIGZvciAoY29uc3QgW25hbWUsIHZhbHVlXSBvZiB0aGlzLmVudHJpZXMoKSkge1xuICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB2YWx1ZSwgbmFtZSwgdGhpcyk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIHZhbHVlc1xuICAgKiBvZiBhbGwgU2V0LUNvb2tpZSBoZWFkZXJzIGFzc29jaWF0ZWRcbiAgICogd2l0aCBhIHJlc3BvbnNlXG4gICAqL1xuICBnZXRTZXRDb29raWUoKSB7XG4gICAgY29uc3Qgc2V0Q29va2llSGVhZGVyID0gdGhpcy5nZXQoXCJzZXQtY29va2llXCIpO1xuICAgIGlmIChzZXRDb29raWVIZWFkZXIgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgaWYgKHNldENvb2tpZUhlYWRlciA9PT0gXCJcIikge1xuICAgICAgcmV0dXJuIFtcIlwiXTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBpbXBvcnRfc2V0X2Nvb2tpZV9wYXJzZXIuc3BsaXRDb29raWVzU3RyaW5nKShzZXRDb29raWVIZWFkZXIpO1xuICB9XG59O1xuXG4vLyBzcmMvZ2V0UmF3SGVhZGVycy50c1xuZnVuY3Rpb24gZ2V0UmF3SGVhZGVycyhoZWFkZXJzKSB7XG4gIGNvbnN0IHJhd0hlYWRlcnMgPSB7fTtcbiAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIGhlYWRlcnMuZW50cmllcygpKSB7XG4gICAgcmF3SGVhZGVyc1toZWFkZXJzW1JBV19IRUFERVJfTkFNRVNdLmdldChuYW1lKV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gcmF3SGVhZGVycztcbn1cblxuLy8gc3JjL3RyYW5zZm9ybWVycy9oZWFkZXJzVG9MaXN0LnRzXG5mdW5jdGlvbiBoZWFkZXJzVG9MaXN0KGhlYWRlcnMpIHtcbiAgY29uc3QgaGVhZGVyc0xpc3QgPSBbXTtcbiAgaGVhZGVycy5mb3JFYWNoKCh2YWx1ZSwgbmFtZSkgPT4ge1xuICAgIGNvbnN0IHJlc29sdmVkVmFsdWUgPSB2YWx1ZS5pbmNsdWRlcyhcIixcIikgPyB2YWx1ZS5zcGxpdChcIixcIikubWFwKCh2YWx1ZTIpID0+IHZhbHVlMi50cmltKCkpIDogdmFsdWU7XG4gICAgaGVhZGVyc0xpc3QucHVzaChbbmFtZSwgcmVzb2x2ZWRWYWx1ZV0pO1xuICB9KTtcbiAgcmV0dXJuIGhlYWRlcnNMaXN0O1xufVxuXG4vLyBzcmMvdHJhbnNmb3JtZXJzL2hlYWRlcnNUb1N0cmluZy50c1xuZnVuY3Rpb24gaGVhZGVyc1RvU3RyaW5nKGhlYWRlcnMpIHtcbiAgY29uc3QgbGlzdCA9IGhlYWRlcnNUb0xpc3QoaGVhZGVycyk7XG4gIGNvbnN0IGxpbmVzID0gbGlzdC5tYXAoKFtuYW1lLCB2YWx1ZV0pID0+IHtcbiAgICBjb25zdCB2YWx1ZXMgPSBbXS5jb25jYXQodmFsdWUpO1xuICAgIHJldHVybiBgJHtuYW1lfTogJHt2YWx1ZXMuam9pbihcIiwgXCIpfWA7XG4gIH0pO1xuICByZXR1cm4gbGluZXMuam9pbihcIlxcclxcblwiKTtcbn1cblxuLy8gc3JjL3RyYW5zZm9ybWVycy9oZWFkZXJzVG9PYmplY3QudHNcbnZhciBzaW5nbGVWYWx1ZUhlYWRlcnMgPSBbXCJ1c2VyLWFnZW50XCJdO1xuZnVuY3Rpb24gaGVhZGVyc1RvT2JqZWN0KGhlYWRlcnMpIHtcbiAgY29uc3QgaGVhZGVyc09iamVjdCA9IHt9O1xuICBoZWFkZXJzLmZvckVhY2goKHZhbHVlLCBuYW1lKSA9PiB7XG4gICAgY29uc3QgaXNNdWx0aVZhbHVlID0gIXNpbmdsZVZhbHVlSGVhZGVycy5pbmNsdWRlcyhuYW1lLnRvTG93ZXJDYXNlKCkpICYmIHZhbHVlLmluY2x1ZGVzKFwiLFwiKTtcbiAgICBoZWFkZXJzT2JqZWN0W25hbWVdID0gaXNNdWx0aVZhbHVlID8gdmFsdWUuc3BsaXQoXCIsXCIpLm1hcCgocykgPT4gcy50cmltKCkpIDogdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gaGVhZGVyc09iamVjdDtcbn1cblxuLy8gc3JjL3RyYW5zZm9ybWVycy9zdHJpbmdUb0hlYWRlcnMudHNcbmZ1bmN0aW9uIHN0cmluZ1RvSGVhZGVycyhzdHIpIHtcbiAgY29uc3QgbGluZXMgPSBzdHIudHJpbSgpLnNwbGl0KC9bXFxyXFxuXSsvKTtcbiAgcmV0dXJuIGxpbmVzLnJlZHVjZSgoaGVhZGVycywgbGluZSkgPT4ge1xuICAgIGlmIChsaW5lLnRyaW0oKSA9PT0gXCJcIikge1xuICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxuICAgIGNvbnN0IHBhcnRzID0gbGluZS5zcGxpdChcIjogXCIpO1xuICAgIGNvbnN0IG5hbWUgPSBwYXJ0cy5zaGlmdCgpO1xuICAgIGNvbnN0IHZhbHVlID0gcGFydHMuam9pbihcIjogXCIpO1xuICAgIGhlYWRlcnMuYXBwZW5kKG5hbWUsIHZhbHVlKTtcbiAgICByZXR1cm4gaGVhZGVycztcbiAgfSwgbmV3IEhlYWRlcnMoKSk7XG59XG5cbi8vIHNyYy90cmFuc2Zvcm1lcnMvbGlzdFRvSGVhZGVycy50c1xuZnVuY3Rpb24gbGlzdFRvSGVhZGVycyhsaXN0KSB7XG4gIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuICBsaXN0LmZvckVhY2goKFtuYW1lLCB2YWx1ZV0pID0+IHtcbiAgICBjb25zdCB2YWx1ZXMgPSBbXS5jb25jYXQodmFsdWUpO1xuICAgIHZhbHVlcy5mb3JFYWNoKCh2YWx1ZTIpID0+IHtcbiAgICAgIGhlYWRlcnMuYXBwZW5kKG5hbWUsIHZhbHVlMik7XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gaGVhZGVycztcbn1cblxuLy8gc3JjL3RyYW5zZm9ybWVycy9yZWR1Y2VIZWFkZXJzT2JqZWN0LnRzXG5mdW5jdGlvbiByZWR1Y2VIZWFkZXJzT2JqZWN0KGhlYWRlcnMsIHJlZHVjZXIsIGluaXRpYWxTdGF0ZSkge1xuICByZXR1cm4gT2JqZWN0LmtleXMoaGVhZGVycykucmVkdWNlKChuZXh0SGVhZGVycywgbmFtZSkgPT4ge1xuICAgIHJldHVybiByZWR1Y2VyKG5leHRIZWFkZXJzLCBuYW1lLCBoZWFkZXJzW25hbWVdKTtcbiAgfSwgaW5pdGlhbFN0YXRlKTtcbn1cblxuLy8gc3JjL3RyYW5zZm9ybWVycy9vYmplY3RUb0hlYWRlcnMudHNcbmZ1bmN0aW9uIG9iamVjdFRvSGVhZGVycyhoZWFkZXJzT2JqZWN0KSB7XG4gIHJldHVybiByZWR1Y2VIZWFkZXJzT2JqZWN0KFxuICAgIGhlYWRlcnNPYmplY3QsXG4gICAgKGhlYWRlcnMsIG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZXMgPSBbXS5jb25jYXQodmFsdWUpLmZpbHRlcihCb29sZWFuKTtcbiAgICAgIHZhbHVlcy5mb3JFYWNoKCh2YWx1ZTIpID0+IHtcbiAgICAgICAgaGVhZGVycy5hcHBlbmQobmFtZSwgdmFsdWUyKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfSxcbiAgICBuZXcgSGVhZGVycygpXG4gICk7XG59XG5cbi8vIHNyYy90cmFuc2Zvcm1lcnMvZmxhdHRlbkhlYWRlcnNMaXN0LnRzXG5mdW5jdGlvbiBmbGF0dGVuSGVhZGVyc0xpc3QobGlzdCkge1xuICByZXR1cm4gbGlzdC5tYXAoKFtuYW1lLCB2YWx1ZXNdKSA9PiB7XG4gICAgcmV0dXJuIFtuYW1lLCBbXS5jb25jYXQodmFsdWVzKS5qb2luKFwiLCBcIildO1xuICB9KTtcbn1cblxuLy8gc3JjL3RyYW5zZm9ybWVycy9mbGF0dGVuSGVhZGVyc09iamVjdC50c1xuZnVuY3Rpb24gZmxhdHRlbkhlYWRlcnNPYmplY3QoaGVhZGVyc09iamVjdCkge1xuICByZXR1cm4gcmVkdWNlSGVhZGVyc09iamVjdChcbiAgICBoZWFkZXJzT2JqZWN0LFxuICAgIChoZWFkZXJzLCBuYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgaGVhZGVyc1tuYW1lXSA9IFtdLmNvbmNhdCh2YWx1ZSkuam9pbihcIiwgXCIpO1xuICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfSxcbiAgICB7fVxuICApO1xufVxuZXhwb3J0IHtcbiAgSGVhZGVycyxcbiAgZmxhdHRlbkhlYWRlcnNMaXN0LFxuICBmbGF0dGVuSGVhZGVyc09iamVjdCxcbiAgZ2V0UmF3SGVhZGVycyxcbiAgaGVhZGVyc1RvTGlzdCxcbiAgaGVhZGVyc1RvT2JqZWN0LFxuICBoZWFkZXJzVG9TdHJpbmcsXG4gIGxpc3RUb0hlYWRlcnMsXG4gIG9iamVjdFRvSGVhZGVycyxcbiAgcmVkdWNlSGVhZGVyc09iamVjdCxcbiAgc3RyaW5nVG9IZWFkZXJzXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCIsImltcG9ydCAqIGFzIF9zeXNjYWxsczFfMCBmcm9tICdzcGFjZXRpbWU6c3lzQDEuMCc7XG5pbXBvcnQgeyByZWdpc3Rlcl9ob29rcyB9IGZyb20gJ3NwYWNldGltZTpzeXNAMS4wJztcbmltcG9ydCB7IHJlZ2lzdGVyX2hvb2tzIGFzIHJlZ2lzdGVyX2hvb2tzJDEgfSBmcm9tICdzcGFjZXRpbWU6c3lzQDEuMSc7XG5pbXBvcnQgKiBhcyBfc3lzY2FsbHMxXzIgZnJvbSAnc3BhY2V0aW1lOnN5c0AxLjInO1xuaW1wb3J0IHsgcmVnaXN0ZXJfaG9va3MgYXMgcmVnaXN0ZXJfaG9va3MkMiB9IGZyb20gJ3NwYWNldGltZTpzeXNAMS4yJztcbmltcG9ydCB7IGhlYWRlcnNUb0xpc3QsIEhlYWRlcnMgfSBmcm9tICdoZWFkZXJzLXBvbHlmaWxsJztcblxudHlwZW9mIGdsb2JhbFRoaXMhPT1cInVuZGVmaW5lZFwiJiYoKGdsb2JhbFRoaXMuZ2xvYmFsPWdsb2JhbFRoaXMuZ2xvYmFsfHxnbG9iYWxUaGlzKSwoZ2xvYmFsVGhpcy53aW5kb3c9Z2xvYmFsVGhpcy53aW5kb3d8fGdsb2JhbFRoaXMpKTtcbnZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19rbm93blN5bWJvbCA9IChuYW1lLCBzeW1ib2wpID0+IChzeW1ib2wgPSBTeW1ib2xbbmFtZV0pID8gc3ltYm9sIDogU3ltYm9sLmZvcihcIlN5bWJvbC5cIiArIG5hbWUpO1xudmFyIF9fdHlwZUVycm9yID0gKG1zZykgPT4ge1xuICB0aHJvdyBUeXBlRXJyb3IobXNnKTtcbn07XG52YXIgX19jb21tb25KUyA9IChjYiwgbW9kKSA9PiBmdW5jdGlvbiBfX3JlcXVpcmUoKSB7XG4gIHJldHVybiBtb2QgfHwgKDAsIGNiW19fZ2V0T3duUHJvcE5hbWVzKGNiKVswXV0pKChtb2QgPSB7IGV4cG9ydHM6IHt9IH0pLmV4cG9ydHMsIG1vZCksIG1vZC5leHBvcnRzO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvRVNNID0gKG1vZCwgaXNOb2RlTW9kZSwgdGFyZ2V0KSA9PiAodGFyZ2V0ID0gbW9kICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kKSkgOiB7fSwgX19jb3B5UHJvcHMoXG4gIC8vIElmIHRoZSBpbXBvcnRlciBpcyBpbiBub2RlIGNvbXBhdGliaWxpdHkgbW9kZSBvciB0aGlzIGlzIG5vdCBhbiBFU01cbiAgLy8gZmlsZSB0aGF0IGhhcyBiZWVuIGNvbnZlcnRlZCB0byBhIENvbW1vbkpTIGZpbGUgdXNpbmcgYSBCYWJlbC1cbiAgLy8gY29tcGF0aWJsZSB0cmFuc2Zvcm0gKGkuZS4gXCJfX2VzTW9kdWxlXCIgaGFzIG5vdCBiZWVuIHNldCksIHRoZW4gc2V0XG4gIC8vIFwiZGVmYXVsdFwiIHRvIHRoZSBDb21tb25KUyBcIm1vZHVsZS5leHBvcnRzXCIgZm9yIG5vZGUgY29tcGF0aWJpbGl0eS5cbiAgX19kZWZQcm9wKHRhcmdldCwgXCJkZWZhdWx0XCIsIHsgdmFsdWU6IG1vZCwgZW51bWVyYWJsZTogdHJ1ZSB9KSAsXG4gIG1vZFxuKSk7XG52YXIgX191c2luZyA9IChzdGFjaywgdmFsdWUsIGFzeW5jKSA9PiB7XG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgX190eXBlRXJyb3IoXCJPYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgdmFyIGRpc3Bvc2UsIGlubmVyO1xuICAgIGlmIChkaXNwb3NlID09PSB2b2lkIDApIHtcbiAgICAgIGRpc3Bvc2UgPSB2YWx1ZVtfX2tub3duU3ltYm9sKFwiZGlzcG9zZVwiKV07XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZGlzcG9zZSAhPT0gXCJmdW5jdGlvblwiKSBfX3R5cGVFcnJvcihcIk9iamVjdCBub3QgZGlzcG9zYWJsZVwiKTtcbiAgICBpZiAoaW5uZXIpIGRpc3Bvc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlubmVyLmNhbGwodGhpcyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHN0YWNrLnB1c2goW2FzeW5jLCBkaXNwb3NlLCB2YWx1ZV0pO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn07XG52YXIgX19jYWxsRGlzcG9zZSA9IChzdGFjaywgZXJyb3IsIGhhc0Vycm9yKSA9PiB7XG4gIHZhciBFID0gdHlwZW9mIFN1cHByZXNzZWRFcnJvciA9PT0gXCJmdW5jdGlvblwiID8gU3VwcHJlc3NlZEVycm9yIDogZnVuY3Rpb24oZSwgcywgbSwgXykge1xuICAgIHJldHVybiBfID0gRXJyb3IobSksIF8ubmFtZSA9IFwiU3VwcHJlc3NlZEVycm9yXCIsIF8uZXJyb3IgPSBlLCBfLnN1cHByZXNzZWQgPSBzLCBfO1xuICB9O1xuICB2YXIgZmFpbCA9IChlKSA9PiBlcnJvciA9IGhhc0Vycm9yID8gbmV3IEUoZSwgZXJyb3IsIFwiQW4gZXJyb3Igd2FzIHN1cHByZXNzZWQgZHVyaW5nIGRpc3Bvc2FsXCIpIDogKGhhc0Vycm9yID0gdHJ1ZSwgZSk7XG4gIHZhciBuZXh0ID0gKGl0KSA9PiB7XG4gICAgd2hpbGUgKGl0ID0gc3RhY2sucG9wKCkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBpdFsxXSAmJiBpdFsxXS5jYWxsKGl0WzJdKTtcbiAgICAgICAgaWYgKGl0WzBdKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCkudGhlbihuZXh0LCAoZSkgPT4gKGZhaWwoZSksIG5leHQoKSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBmYWlsKGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaGFzRXJyb3IpIHRocm93IGVycm9yO1xuICB9O1xuICByZXR1cm4gbmV4dCgpO1xufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Jhc2U2NC1qc0AxLjUuMS9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzXG52YXIgcmVxdWlyZV9iYXNlNjRfanMgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYmFzZTY0LWpzQDEuNS4xL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanNcIihleHBvcnRzKSB7XG4gICAgZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aDtcbiAgICBleHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXk7XG4gICAgZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheTI7XG4gICAgdmFyIGxvb2t1cCA9IFtdO1xuICAgIHZhciByZXZMb29rdXAgPSBbXTtcbiAgICB2YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09IFwidW5kZWZpbmVkXCIgPyBVaW50OEFycmF5IDogQXJyYXk7XG4gICAgdmFyIGNvZGUgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIjtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBsb29rdXBbaV0gPSBjb2RlW2ldO1xuICAgICAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpO1xuICAgIH1cbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuO1xuICAgIHJldkxvb2t1cFtcIi1cIi5jaGFyQ29kZUF0KDApXSA9IDYyO1xuICAgIHJldkxvb2t1cFtcIl9cIi5jaGFyQ29kZUF0KDApXSA9IDYzO1xuICAgIGZ1bmN0aW9uIGdldExlbnMoYjY0KSB7XG4gICAgICB2YXIgbGVuMiA9IGI2NC5sZW5ndGg7XG4gICAgICBpZiAobGVuMiAlIDQgPiAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDRcIik7XG4gICAgICB9XG4gICAgICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZihcIj1cIik7XG4gICAgICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlbjI7XG4gICAgICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlbjIgPyAwIDogNCAtIHZhbGlkTGVuICUgNDtcbiAgICAgIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJ5dGVMZW5ndGgoYjY0KSB7XG4gICAgICB2YXIgbGVucyA9IGdldExlbnMoYjY0KTtcbiAgICAgIHZhciB2YWxpZExlbiA9IGxlbnNbMF07XG4gICAgICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXTtcbiAgICAgIHJldHVybiAodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQgLSBwbGFjZUhvbGRlcnNMZW47XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICAgICAgcmV0dXJuICh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCAtIHBsYWNlSG9sZGVyc0xlbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gdG9CeXRlQXJyYXkoYjY0KSB7XG4gICAgICB2YXIgdG1wO1xuICAgICAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NCk7XG4gICAgICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdO1xuICAgICAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV07XG4gICAgICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKTtcbiAgICAgIHZhciBjdXJCeXRlID0gMDtcbiAgICAgIHZhciBsZW4yID0gcGxhY2VIb2xkZXJzTGVuID4gMCA/IHZhbGlkTGVuIC0gNCA6IHZhbGlkTGVuO1xuICAgICAgdmFyIGkyO1xuICAgICAgZm9yIChpMiA9IDA7IGkyIDwgbGVuMjsgaTIgKz0gNCkge1xuICAgICAgICB0bXAgPSByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaTIpXSA8PCAxOCB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpMiArIDEpXSA8PCAxMiB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpMiArIDIpXSA8PCA2IHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkyICsgMyldO1xuICAgICAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCA+PiAxNiAmIDI1NTtcbiAgICAgICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgPj4gOCAmIDI1NTtcbiAgICAgICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAyNTU7XG4gICAgICB9XG4gICAgICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgICAgIHRtcCA9IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpMildIDw8IDIgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaTIgKyAxKV0gPj4gNDtcbiAgICAgICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAyNTU7XG4gICAgICB9XG4gICAgICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgICAgIHRtcCA9IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpMildIDw8IDEwIHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkyICsgMSldIDw8IDQgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaTIgKyAyKV0gPj4gMjtcbiAgICAgICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgPj4gOCAmIDI1NTtcbiAgICAgICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAyNTU7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQobnVtKSB7XG4gICAgICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDYzXSArIGxvb2t1cFtudW0gPj4gMTIgJiA2M10gKyBsb29rdXBbbnVtID4+IDYgJiA2M10gKyBsb29rdXBbbnVtICYgNjNdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbmNvZGVDaHVuayh1aW50OCwgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIHRtcDtcbiAgICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkyID0gc3RhcnQ7IGkyIDwgZW5kOyBpMiArPSAzKSB7XG4gICAgICAgIHRtcCA9ICh1aW50OFtpMl0gPDwgMTYgJiAxNjcxMTY4MCkgKyAodWludDhbaTIgKyAxXSA8PCA4ICYgNjUyODApICsgKHVpbnQ4W2kyICsgMl0gJiAyNTUpO1xuICAgICAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0cHV0LmpvaW4oXCJcIik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZyb21CeXRlQXJyYXkyKHVpbnQ4KSB7XG4gICAgICB2YXIgdG1wO1xuICAgICAgdmFyIGxlbjIgPSB1aW50OC5sZW5ndGg7XG4gICAgICB2YXIgZXh0cmFCeXRlcyA9IGxlbjIgJSAzO1xuICAgICAgdmFyIHBhcnRzID0gW107XG4gICAgICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MztcbiAgICAgIGZvciAodmFyIGkyID0gMCwgbGVuMjIgPSBsZW4yIC0gZXh0cmFCeXRlczsgaTIgPCBsZW4yMjsgaTIgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICAgICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaTIsIGkyICsgbWF4Q2h1bmtMZW5ndGggPiBsZW4yMiA/IGxlbjIyIDogaTIgKyBtYXhDaHVua0xlbmd0aCkpO1xuICAgICAgfVxuICAgICAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICAgICAgdG1wID0gdWludDhbbGVuMiAtIDFdO1xuICAgICAgICBwYXJ0cy5wdXNoKFxuICAgICAgICAgIGxvb2t1cFt0bXAgPj4gMl0gKyBsb29rdXBbdG1wIDw8IDQgJiA2M10gKyBcIj09XCJcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgICAgICB0bXAgPSAodWludDhbbGVuMiAtIDJdIDw8IDgpICsgdWludDhbbGVuMiAtIDFdO1xuICAgICAgICBwYXJ0cy5wdXNoKFxuICAgICAgICAgIGxvb2t1cFt0bXAgPj4gMTBdICsgbG9va3VwW3RtcCA+PiA0ICYgNjNdICsgbG9va3VwW3RtcCA8PCAyICYgNjNdICsgXCI9XCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJ0cy5qb2luKFwiXCIpO1xuICAgIH1cbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9mYXN0LXRleHQtZW5jb2RpbmdAMS4wLjYvbm9kZV9tb2R1bGVzL2Zhc3QtdGV4dC1lbmNvZGluZy90ZXh0Lm1pbi5qc1xudmFyIHJlcXVpcmVfdGV4dF9taW4gPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZmFzdC10ZXh0LWVuY29kaW5nQDEuMC42L25vZGVfbW9kdWxlcy9mYXN0LXRleHQtZW5jb2RpbmcvdGV4dC5taW4uanNcIihleHBvcnRzKSB7XG4gICAgKGZ1bmN0aW9uKHNjb3BlKSB7XG4gICAgICBmdW5jdGlvbiBCKHIsIGUpIHtcbiAgICAgICAgdmFyIGY7XG4gICAgICAgIHJldHVybiByIGluc3RhbmNlb2YgQnVmZmVyID8gZiA9IHIgOiBmID0gQnVmZmVyLmZyb20oci5idWZmZXIsIHIuYnl0ZU9mZnNldCwgci5ieXRlTGVuZ3RoKSwgZi50b1N0cmluZyhlKTtcbiAgICAgIH1cbiAgICAgIHZhciB3ID0gZnVuY3Rpb24ocikge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20ocik7XG4gICAgICB9O1xuICAgICAgZnVuY3Rpb24gaChyKSB7XG4gICAgICAgIGZvciAodmFyIGUgPSAwLCBmID0gTWF0aC5taW4oMjU2ICogMjU2LCByLmxlbmd0aCArIDEpLCBuID0gbmV3IFVpbnQxNkFycmF5KGYpLCBpID0gW10sIG8gPSAwOyA7ICkge1xuICAgICAgICAgIHZhciB0MiA9IGUgPCByLmxlbmd0aDtcbiAgICAgICAgICBpZiAoIXQyIHx8IG8gPj0gZiAtIDEpIHtcbiAgICAgICAgICAgIHZhciBzID0gbi5zdWJhcnJheSgwLCBvKSwgbSA9IHM7XG4gICAgICAgICAgICBpZiAoaS5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbSkpLCAhdDIpIHJldHVybiBpLmpvaW4oXCJcIik7XG4gICAgICAgICAgICByID0gci5zdWJhcnJheShlKSwgZSA9IDAsIG8gPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgYSA9IHJbZSsrXTtcbiAgICAgICAgICBpZiAoKGEgJiAxMjgpID09PSAwKSBuW28rK10gPSBhO1xuICAgICAgICAgIGVsc2UgaWYgKChhICYgMjI0KSA9PT0gMTkyKSB7XG4gICAgICAgICAgICB2YXIgZCA9IHJbZSsrXSAmIDYzO1xuICAgICAgICAgICAgbltvKytdID0gKGEgJiAzMSkgPDwgNiB8IGQ7XG4gICAgICAgICAgfSBlbHNlIGlmICgoYSAmIDI0MCkgPT09IDIyNCkge1xuICAgICAgICAgICAgdmFyIGQgPSByW2UrK10gJiA2MywgbCA9IHJbZSsrXSAmIDYzO1xuICAgICAgICAgICAgbltvKytdID0gKGEgJiAzMSkgPDwgMTIgfCBkIDw8IDYgfCBsO1xuICAgICAgICAgIH0gZWxzZSBpZiAoKGEgJiAyNDgpID09PSAyNDApIHtcbiAgICAgICAgICAgIHZhciBkID0gcltlKytdICYgNjMsIGwgPSByW2UrK10gJiA2MywgUiA9IHJbZSsrXSAmIDYzLCBjID0gKGEgJiA3KSA8PCAxOCB8IGQgPDwgMTIgfCBsIDw8IDYgfCBSO1xuICAgICAgICAgICAgYyA+IDY1NTM1ICYmIChjIC09IDY1NTM2LCBuW28rK10gPSBjID4+PiAxMCAmIDEwMjMgfCA1NTI5NiwgYyA9IDU2MzIwIHwgYyAmIDEwMjMpLCBuW28rK10gPSBjO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gRihyKSB7XG4gICAgICAgIGZvciAodmFyIGUgPSAwLCBmID0gci5sZW5ndGgsIG4gPSAwLCBpID0gTWF0aC5tYXgoMzIsIGYgKyAoZiA+Pj4gMSkgKyA3KSwgbyA9IG5ldyBVaW50OEFycmF5KGkgPj4+IDMgPDwgMyk7IGUgPCBmOyApIHtcbiAgICAgICAgICB2YXIgdDIgPSByLmNoYXJDb2RlQXQoZSsrKTtcbiAgICAgICAgICBpZiAodDIgPj0gNTUyOTYgJiYgdDIgPD0gNTYzMTkpIHtcbiAgICAgICAgICAgIGlmIChlIDwgZikge1xuICAgICAgICAgICAgICB2YXIgcyA9IHIuY2hhckNvZGVBdChlKTtcbiAgICAgICAgICAgICAgKHMgJiA2NDUxMikgPT09IDU2MzIwICYmICgrK2UsIHQyID0gKCh0MiAmIDEwMjMpIDw8IDEwKSArIChzICYgMTAyMykgKyA2NTUzNik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodDIgPj0gNTUyOTYgJiYgdDIgPD0gNTYzMTkpIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobiArIDQgPiBvLmxlbmd0aCkge1xuICAgICAgICAgICAgaSArPSA4LCBpICo9IDEgKyBlIC8gci5sZW5ndGggKiAyLCBpID0gaSA+Pj4gMyA8PCAzO1xuICAgICAgICAgICAgdmFyIG0gPSBuZXcgVWludDhBcnJheShpKTtcbiAgICAgICAgICAgIG0uc2V0KG8pLCBvID0gbTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCh0MiAmIDQyOTQ5NjcxNjgpID09PSAwKSB7XG4gICAgICAgICAgICBvW24rK10gPSB0MjtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoKHQyICYgNDI5NDk2NTI0OCkgPT09IDApIG9bbisrXSA9IHQyID4+PiA2ICYgMzEgfCAxOTI7XG4gICAgICAgICAgZWxzZSBpZiAoKHQyICYgNDI5NDkwMTc2MCkgPT09IDApIG9bbisrXSA9IHQyID4+PiAxMiAmIDE1IHwgMjI0LCBvW24rK10gPSB0MiA+Pj4gNiAmIDYzIHwgMTI4O1xuICAgICAgICAgIGVsc2UgaWYgKCh0MiAmIDQyOTI4NzAxNDQpID09PSAwKSBvW24rK10gPSB0MiA+Pj4gMTggJiA3IHwgMjQwLCBvW24rK10gPSB0MiA+Pj4gMTIgJiA2MyB8IDEyOCwgb1tuKytdID0gdDIgPj4+IDYgJiA2MyB8IDEyODtcbiAgICAgICAgICBlbHNlIGNvbnRpbnVlO1xuICAgICAgICAgIG9bbisrXSA9IHQyICYgNjMgfCAxMjg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG8uc2xpY2UgPyBvLnNsaWNlKDAsIG4pIDogby5zdWJhcnJheSgwLCBuKTtcbiAgICAgIH1cbiAgICAgIHZhciB1ID0gXCJGYWlsZWQgdG8gXCIsIHAgPSBmdW5jdGlvbihyLCBlLCBmKSB7XG4gICAgICAgIGlmIChyKSB0aHJvdyBuZXcgRXJyb3IoXCJcIi5jb25jYXQodSkuY29uY2F0KGUsIFwiOiB0aGUgJ1wiKS5jb25jYXQoZiwgXCInIG9wdGlvbiBpcyB1bnN1cHBvcnRlZC5cIikpO1xuICAgICAgfTtcbiAgICAgIHZhciB4ID0gdHlwZW9mIEJ1ZmZlciA9PSBcImZ1bmN0aW9uXCIgJiYgQnVmZmVyLmZyb207XG4gICAgICB2YXIgQSA9IHggPyB3IDogRjtcbiAgICAgIGZ1bmN0aW9uIHYoKSB7XG4gICAgICAgIHRoaXMuZW5jb2RpbmcgPSBcInV0Zi04XCI7XG4gICAgICB9XG4gICAgICB2LnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbihyLCBlKSB7XG4gICAgICAgIHJldHVybiBwKGUgJiYgZS5zdHJlYW0sIFwiZW5jb2RlXCIsIFwic3RyZWFtXCIpLCBBKHIpO1xuICAgICAgfTtcbiAgICAgIGZ1bmN0aW9uIFUocikge1xuICAgICAgICB2YXIgZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgZiA9IG5ldyBCbG9iKFtyXSwgeyB0eXBlOiBcInRleHQvcGxhaW47Y2hhcnNldD1VVEYtOFwiIH0pO1xuICAgICAgICAgIGUgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGYpO1xuICAgICAgICAgIHZhciBuID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgcmV0dXJuIG4ub3BlbihcIkdFVFwiLCBlLCBmYWxzZSksIG4uc2VuZCgpLCBuLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBlICYmIFVSTC5yZXZva2VPYmplY3RVUkwoZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBPID0gIXggJiYgdHlwZW9mIEJsb2IgPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBVUkwgPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09IFwiZnVuY3Rpb25cIiwgUyA9IFtcInV0Zi04XCIsIFwidXRmOFwiLCBcInVuaWNvZGUtMS0xLXV0Zi04XCJdLCBUID0gaDtcbiAgICAgIHggPyBUID0gQiA6IE8gJiYgKFQgPSBmdW5jdGlvbihyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIFUocik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXR1cm4gaChyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB2YXIgeSA9IFwiY29uc3RydWN0ICdUZXh0RGVjb2RlcidcIiwgRSA9IFwiXCIuY29uY2F0KHUsIFwiIFwiKS5jb25jYXQoeSwgXCI6IHRoZSBcIik7XG4gICAgICBmdW5jdGlvbiBnKHIsIGUpIHtcbiAgICAgICAgcChlICYmIGUuZmF0YWwsIHksIFwiZmF0YWxcIiksIHIgPSByIHx8IFwidXRmLThcIjtcbiAgICAgICAgdmFyIGY7XG4gICAgICAgIGlmICh4ID8gZiA9IEJ1ZmZlci5pc0VuY29kaW5nKHIpIDogZiA9IFMuaW5kZXhPZihyLnRvTG93ZXJDYXNlKCkpICE9PSAtMSwgIWYpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiXCIuY29uY2F0KEUsIFwiIGVuY29kaW5nIGxhYmVsIHByb3ZpZGVkICgnXCIpLmNvbmNhdChyLCBcIicpIGlzIGludmFsaWQuXCIpKTtcbiAgICAgICAgdGhpcy5lbmNvZGluZyA9IHIsIHRoaXMuZmF0YWwgPSBmYWxzZSwgdGhpcy5pZ25vcmVCT00gPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGcucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uKHIsIGUpIHtcbiAgICAgICAgcChlICYmIGUuc3RyZWFtLCBcImRlY29kZVwiLCBcInN0cmVhbVwiKTtcbiAgICAgICAgdmFyIGY7XG4gICAgICAgIHJldHVybiByIGluc3RhbmNlb2YgVWludDhBcnJheSA/IGYgPSByIDogci5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciA/IGYgPSBuZXcgVWludDhBcnJheShyLmJ1ZmZlcikgOiBmID0gbmV3IFVpbnQ4QXJyYXkociksIFQoZiwgdGhpcy5lbmNvZGluZyk7XG4gICAgICB9O1xuICAgICAgc2NvcGUuVGV4dEVuY29kZXIgPSBzY29wZS5UZXh0RW5jb2RlciB8fCB2O1xuICAgICAgc2NvcGUuVGV4dERlY29kZXIgPSBzY29wZS5UZXh0RGVjb2RlciB8fCBnO1xuICAgIH0pKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogZXhwb3J0cyk7XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vc3RhdHVzZXNAMi4wLjIvbm9kZV9tb2R1bGVzL3N0YXR1c2VzL2NvZGVzLmpzb25cbnZhciByZXF1aXJlX2NvZGVzID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3N0YXR1c2VzQDIuMC4yL25vZGVfbW9kdWxlcy9zdGF0dXNlcy9jb2Rlcy5qc29uXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICBcIjEwMFwiOiBcIkNvbnRpbnVlXCIsXG4gICAgICBcIjEwMVwiOiBcIlN3aXRjaGluZyBQcm90b2NvbHNcIixcbiAgICAgIFwiMTAyXCI6IFwiUHJvY2Vzc2luZ1wiLFxuICAgICAgXCIxMDNcIjogXCJFYXJseSBIaW50c1wiLFxuICAgICAgXCIyMDBcIjogXCJPS1wiLFxuICAgICAgXCIyMDFcIjogXCJDcmVhdGVkXCIsXG4gICAgICBcIjIwMlwiOiBcIkFjY2VwdGVkXCIsXG4gICAgICBcIjIwM1wiOiBcIk5vbi1BdXRob3JpdGF0aXZlIEluZm9ybWF0aW9uXCIsXG4gICAgICBcIjIwNFwiOiBcIk5vIENvbnRlbnRcIixcbiAgICAgIFwiMjA1XCI6IFwiUmVzZXQgQ29udGVudFwiLFxuICAgICAgXCIyMDZcIjogXCJQYXJ0aWFsIENvbnRlbnRcIixcbiAgICAgIFwiMjA3XCI6IFwiTXVsdGktU3RhdHVzXCIsXG4gICAgICBcIjIwOFwiOiBcIkFscmVhZHkgUmVwb3J0ZWRcIixcbiAgICAgIFwiMjI2XCI6IFwiSU0gVXNlZFwiLFxuICAgICAgXCIzMDBcIjogXCJNdWx0aXBsZSBDaG9pY2VzXCIsXG4gICAgICBcIjMwMVwiOiBcIk1vdmVkIFBlcm1hbmVudGx5XCIsXG4gICAgICBcIjMwMlwiOiBcIkZvdW5kXCIsXG4gICAgICBcIjMwM1wiOiBcIlNlZSBPdGhlclwiLFxuICAgICAgXCIzMDRcIjogXCJOb3QgTW9kaWZpZWRcIixcbiAgICAgIFwiMzA1XCI6IFwiVXNlIFByb3h5XCIsXG4gICAgICBcIjMwN1wiOiBcIlRlbXBvcmFyeSBSZWRpcmVjdFwiLFxuICAgICAgXCIzMDhcIjogXCJQZXJtYW5lbnQgUmVkaXJlY3RcIixcbiAgICAgIFwiNDAwXCI6IFwiQmFkIFJlcXVlc3RcIixcbiAgICAgIFwiNDAxXCI6IFwiVW5hdXRob3JpemVkXCIsXG4gICAgICBcIjQwMlwiOiBcIlBheW1lbnQgUmVxdWlyZWRcIixcbiAgICAgIFwiNDAzXCI6IFwiRm9yYmlkZGVuXCIsXG4gICAgICBcIjQwNFwiOiBcIk5vdCBGb3VuZFwiLFxuICAgICAgXCI0MDVcIjogXCJNZXRob2QgTm90IEFsbG93ZWRcIixcbiAgICAgIFwiNDA2XCI6IFwiTm90IEFjY2VwdGFibGVcIixcbiAgICAgIFwiNDA3XCI6IFwiUHJveHkgQXV0aGVudGljYXRpb24gUmVxdWlyZWRcIixcbiAgICAgIFwiNDA4XCI6IFwiUmVxdWVzdCBUaW1lb3V0XCIsXG4gICAgICBcIjQwOVwiOiBcIkNvbmZsaWN0XCIsXG4gICAgICBcIjQxMFwiOiBcIkdvbmVcIixcbiAgICAgIFwiNDExXCI6IFwiTGVuZ3RoIFJlcXVpcmVkXCIsXG4gICAgICBcIjQxMlwiOiBcIlByZWNvbmRpdGlvbiBGYWlsZWRcIixcbiAgICAgIFwiNDEzXCI6IFwiUGF5bG9hZCBUb28gTGFyZ2VcIixcbiAgICAgIFwiNDE0XCI6IFwiVVJJIFRvbyBMb25nXCIsXG4gICAgICBcIjQxNVwiOiBcIlVuc3VwcG9ydGVkIE1lZGlhIFR5cGVcIixcbiAgICAgIFwiNDE2XCI6IFwiUmFuZ2UgTm90IFNhdGlzZmlhYmxlXCIsXG4gICAgICBcIjQxN1wiOiBcIkV4cGVjdGF0aW9uIEZhaWxlZFwiLFxuICAgICAgXCI0MThcIjogXCJJJ20gYSBUZWFwb3RcIixcbiAgICAgIFwiNDIxXCI6IFwiTWlzZGlyZWN0ZWQgUmVxdWVzdFwiLFxuICAgICAgXCI0MjJcIjogXCJVbnByb2Nlc3NhYmxlIEVudGl0eVwiLFxuICAgICAgXCI0MjNcIjogXCJMb2NrZWRcIixcbiAgICAgIFwiNDI0XCI6IFwiRmFpbGVkIERlcGVuZGVuY3lcIixcbiAgICAgIFwiNDI1XCI6IFwiVG9vIEVhcmx5XCIsXG4gICAgICBcIjQyNlwiOiBcIlVwZ3JhZGUgUmVxdWlyZWRcIixcbiAgICAgIFwiNDI4XCI6IFwiUHJlY29uZGl0aW9uIFJlcXVpcmVkXCIsXG4gICAgICBcIjQyOVwiOiBcIlRvbyBNYW55IFJlcXVlc3RzXCIsXG4gICAgICBcIjQzMVwiOiBcIlJlcXVlc3QgSGVhZGVyIEZpZWxkcyBUb28gTGFyZ2VcIixcbiAgICAgIFwiNDUxXCI6IFwiVW5hdmFpbGFibGUgRm9yIExlZ2FsIFJlYXNvbnNcIixcbiAgICAgIFwiNTAwXCI6IFwiSW50ZXJuYWwgU2VydmVyIEVycm9yXCIsXG4gICAgICBcIjUwMVwiOiBcIk5vdCBJbXBsZW1lbnRlZFwiLFxuICAgICAgXCI1MDJcIjogXCJCYWQgR2F0ZXdheVwiLFxuICAgICAgXCI1MDNcIjogXCJTZXJ2aWNlIFVuYXZhaWxhYmxlXCIsXG4gICAgICBcIjUwNFwiOiBcIkdhdGV3YXkgVGltZW91dFwiLFxuICAgICAgXCI1MDVcIjogXCJIVFRQIFZlcnNpb24gTm90IFN1cHBvcnRlZFwiLFxuICAgICAgXCI1MDZcIjogXCJWYXJpYW50IEFsc28gTmVnb3RpYXRlc1wiLFxuICAgICAgXCI1MDdcIjogXCJJbnN1ZmZpY2llbnQgU3RvcmFnZVwiLFxuICAgICAgXCI1MDhcIjogXCJMb29wIERldGVjdGVkXCIsXG4gICAgICBcIjUwOVwiOiBcIkJhbmR3aWR0aCBMaW1pdCBFeGNlZWRlZFwiLFxuICAgICAgXCI1MTBcIjogXCJOb3QgRXh0ZW5kZWRcIixcbiAgICAgIFwiNTExXCI6IFwiTmV0d29yayBBdXRoZW50aWNhdGlvbiBSZXF1aXJlZFwiXG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9zdGF0dXNlc0AyLjAuMi9ub2RlX21vZHVsZXMvc3RhdHVzZXMvaW5kZXguanNcbnZhciByZXF1aXJlX3N0YXR1c2VzID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3N0YXR1c2VzQDIuMC4yL25vZGVfbW9kdWxlcy9zdGF0dXNlcy9pbmRleC5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIHZhciBjb2RlcyA9IHJlcXVpcmVfY29kZXMoKTtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHN0YXR1czI7XG4gICAgc3RhdHVzMi5tZXNzYWdlID0gY29kZXM7XG4gICAgc3RhdHVzMi5jb2RlID0gY3JlYXRlTWVzc2FnZVRvU3RhdHVzQ29kZU1hcChjb2Rlcyk7XG4gICAgc3RhdHVzMi5jb2RlcyA9IGNyZWF0ZVN0YXR1c0NvZGVMaXN0KGNvZGVzKTtcbiAgICBzdGF0dXMyLnJlZGlyZWN0ID0ge1xuICAgICAgMzAwOiB0cnVlLFxuICAgICAgMzAxOiB0cnVlLFxuICAgICAgMzAyOiB0cnVlLFxuICAgICAgMzAzOiB0cnVlLFxuICAgICAgMzA1OiB0cnVlLFxuICAgICAgMzA3OiB0cnVlLFxuICAgICAgMzA4OiB0cnVlXG4gICAgfTtcbiAgICBzdGF0dXMyLmVtcHR5ID0ge1xuICAgICAgMjA0OiB0cnVlLFxuICAgICAgMjA1OiB0cnVlLFxuICAgICAgMzA0OiB0cnVlXG4gICAgfTtcbiAgICBzdGF0dXMyLnJldHJ5ID0ge1xuICAgICAgNTAyOiB0cnVlLFxuICAgICAgNTAzOiB0cnVlLFxuICAgICAgNTA0OiB0cnVlXG4gICAgfTtcbiAgICBmdW5jdGlvbiBjcmVhdGVNZXNzYWdlVG9TdGF0dXNDb2RlTWFwKGNvZGVzMikge1xuICAgICAgdmFyIG1hcCA9IHt9O1xuICAgICAgT2JqZWN0LmtleXMoY29kZXMyKS5mb3JFYWNoKGZ1bmN0aW9uIGZvckVhY2hDb2RlKGNvZGUpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBjb2RlczJbY29kZV07XG4gICAgICAgIHZhciBzdGF0dXMzID0gTnVtYmVyKGNvZGUpO1xuICAgICAgICBtYXBbbWVzc2FnZS50b0xvd2VyQ2FzZSgpXSA9IHN0YXR1czM7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBtYXA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVN0YXR1c0NvZGVMaXN0KGNvZGVzMikge1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGNvZGVzMikubWFwKGZ1bmN0aW9uIG1hcENvZGUoY29kZSkge1xuICAgICAgICByZXR1cm4gTnVtYmVyKGNvZGUpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFN0YXR1c0NvZGUobWVzc2FnZSkge1xuICAgICAgdmFyIG1zZyA9IG1lc3NhZ2UudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHN0YXR1czIuY29kZSwgbXNnKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc3RhdHVzIG1lc3NhZ2U6IFwiJyArIG1lc3NhZ2UgKyAnXCInKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdGF0dXMyLmNvZGVbbXNnXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0U3RhdHVzTWVzc2FnZShjb2RlKSB7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzdGF0dXMyLm1lc3NhZ2UsIGNvZGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgc3RhdHVzIGNvZGU6IFwiICsgY29kZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RhdHVzMi5tZXNzYWdlW2NvZGVdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdGF0dXMyKGNvZGUpIHtcbiAgICAgIGlmICh0eXBlb2YgY29kZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gZ2V0U3RhdHVzTWVzc2FnZShjb2RlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgY29kZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY29kZSBtdXN0IGJlIGEgbnVtYmVyIG9yIHN0cmluZ1wiKTtcbiAgICAgIH1cbiAgICAgIHZhciBuID0gcGFyc2VJbnQoY29kZSwgMTApO1xuICAgICAgaWYgKCFpc05hTihuKSkge1xuICAgICAgICByZXR1cm4gZ2V0U3RhdHVzTWVzc2FnZShuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRTdGF0dXNDb2RlKGNvZGUpO1xuICAgIH1cbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvdGltZV9kdXJhdGlvbi50c1xudmFyIFRpbWVEdXJhdGlvbiA9IGNsYXNzIF9UaW1lRHVyYXRpb24ge1xuICBfX3RpbWVfZHVyYXRpb25fbWljcm9zX187XG4gIHN0YXRpYyBNSUNST1NfUEVSX01JTExJUyA9IDEwMDBuO1xuICAvKipcbiAgICogR2V0IHRoZSBhbGdlYnJhaWMgdHlwZSByZXByZXNlbnRhdGlvbiBvZiB0aGUge0BsaW5rIFRpbWVEdXJhdGlvbn0gdHlwZS5cbiAgICogQHJldHVybnMgVGhlIGFsZ2VicmFpYyB0eXBlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0eXBlLlxuICAgKi9cbiAgc3RhdGljIGdldEFsZ2VicmFpY1R5cGUoKSB7XG4gICAgcmV0dXJuIEFsZ2VicmFpY1R5cGUuUHJvZHVjdCh7XG4gICAgICBlbGVtZW50czogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJfX3RpbWVfZHVyYXRpb25fbWljcm9zX19cIixcbiAgICAgICAgICBhbGdlYnJhaWNUeXBlOiBBbGdlYnJhaWNUeXBlLkk2NFxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGlzVGltZUR1cmF0aW9uKGFsZ2VicmFpY1R5cGUpIHtcbiAgICBpZiAoYWxnZWJyYWljVHlwZS50YWcgIT09IFwiUHJvZHVjdFwiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGVsZW1lbnRzID0gYWxnZWJyYWljVHlwZS52YWx1ZS5lbGVtZW50cztcbiAgICBpZiAoZWxlbWVudHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IG1pY3Jvc0VsZW1lbnQgPSBlbGVtZW50c1swXTtcbiAgICByZXR1cm4gbWljcm9zRWxlbWVudC5uYW1lID09PSBcIl9fdGltZV9kdXJhdGlvbl9taWNyb3NfX1wiICYmIG1pY3Jvc0VsZW1lbnQuYWxnZWJyYWljVHlwZS50YWcgPT09IFwiSTY0XCI7XG4gIH1cbiAgZ2V0IG1pY3JvcygpIHtcbiAgICByZXR1cm4gdGhpcy5fX3RpbWVfZHVyYXRpb25fbWljcm9zX187XG4gIH1cbiAgZ2V0IG1pbGxpcygpIHtcbiAgICByZXR1cm4gTnVtYmVyKHRoaXMubWljcm9zIC8gX1RpbWVEdXJhdGlvbi5NSUNST1NfUEVSX01JTExJUyk7XG4gIH1cbiAgY29uc3RydWN0b3IobWljcm9zKSB7XG4gICAgdGhpcy5fX3RpbWVfZHVyYXRpb25fbWljcm9zX18gPSBtaWNyb3M7XG4gIH1cbiAgc3RhdGljIGZyb21NaWxsaXMobWlsbGlzKSB7XG4gICAgcmV0dXJuIG5ldyBfVGltZUR1cmF0aW9uKEJpZ0ludChtaWxsaXMpICogX1RpbWVEdXJhdGlvbi5NSUNST1NfUEVSX01JTExJUyk7XG4gIH1cbiAgLyoqIFRoaXMgb3V0cHV0cyB0aGUgc2FtZSBzdHJpbmcgZm9ybWF0IHRoYXQgd2UgdXNlIGluIHRoZSBob3N0IGFuZCBpbiBSdXN0IG1vZHVsZXMgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgY29uc3QgbWljcm9zID0gdGhpcy5taWNyb3M7XG4gICAgY29uc3Qgc2lnbiA9IG1pY3JvcyA8IDAgPyBcIi1cIiA6IFwiK1wiO1xuICAgIGNvbnN0IHBvcyA9IG1pY3JvcyA8IDAgPyAtbWljcm9zIDogbWljcm9zO1xuICAgIGNvbnN0IHNlY3MgPSBwb3MgLyAxMDAwMDAwbjtcbiAgICBjb25zdCBtaWNyb3NfcmVtYWluaW5nID0gcG9zICUgMTAwMDAwMG47XG4gICAgcmV0dXJuIGAke3NpZ259JHtzZWNzfS4ke1N0cmluZyhtaWNyb3NfcmVtYWluaW5nKS5wYWRTdGFydCg2LCBcIjBcIil9YDtcbiAgfVxufTtcblxuLy8gc3JjL2xpYi90aW1lc3RhbXAudHNcbnZhciBUaW1lc3RhbXAgPSBjbGFzcyBfVGltZXN0YW1wIHtcbiAgX190aW1lc3RhbXBfbWljcm9zX3NpbmNlX3VuaXhfZXBvY2hfXztcbiAgc3RhdGljIE1JQ1JPU19QRVJfTUlMTElTID0gMTAwMG47XG4gIGdldCBtaWNyb3NTaW5jZVVuaXhFcG9jaCgpIHtcbiAgICByZXR1cm4gdGhpcy5fX3RpbWVzdGFtcF9taWNyb3Nfc2luY2VfdW5peF9lcG9jaF9fO1xuICB9XG4gIGNvbnN0cnVjdG9yKG1pY3Jvcykge1xuICAgIHRoaXMuX190aW1lc3RhbXBfbWljcm9zX3NpbmNlX3VuaXhfZXBvY2hfXyA9IG1pY3JvcztcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBhbGdlYnJhaWMgdHlwZSByZXByZXNlbnRhdGlvbiBvZiB0aGUge0BsaW5rIFRpbWVzdGFtcH0gdHlwZS5cbiAgICogQHJldHVybnMgVGhlIGFsZ2VicmFpYyB0eXBlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0eXBlLlxuICAgKi9cbiAgc3RhdGljIGdldEFsZ2VicmFpY1R5cGUoKSB7XG4gICAgcmV0dXJuIEFsZ2VicmFpY1R5cGUuUHJvZHVjdCh7XG4gICAgICBlbGVtZW50czogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJfX3RpbWVzdGFtcF9taWNyb3Nfc2luY2VfdW5peF9lcG9jaF9fXCIsXG4gICAgICAgICAgYWxnZWJyYWljVHlwZTogQWxnZWJyYWljVHlwZS5JNjRcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBpc1RpbWVzdGFtcChhbGdlYnJhaWNUeXBlKSB7XG4gICAgaWYgKGFsZ2VicmFpY1R5cGUudGFnICE9PSBcIlByb2R1Y3RcIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBlbGVtZW50cyA9IGFsZ2VicmFpY1R5cGUudmFsdWUuZWxlbWVudHM7XG4gICAgaWYgKGVsZW1lbnRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBtaWNyb3NFbGVtZW50ID0gZWxlbWVudHNbMF07XG4gICAgcmV0dXJuIG1pY3Jvc0VsZW1lbnQubmFtZSA9PT0gXCJfX3RpbWVzdGFtcF9taWNyb3Nfc2luY2VfdW5peF9lcG9jaF9fXCIgJiYgbWljcm9zRWxlbWVudC5hbGdlYnJhaWNUeXBlLnRhZyA9PT0gXCJJNjRcIjtcbiAgfVxuICAvKipcbiAgICogVGhlIFVuaXggZXBvY2gsIHRoZSBtaWRuaWdodCBhdCB0aGUgYmVnaW5uaW5nIG9mIEphbnVhcnkgMSwgMTk3MCwgVVRDLlxuICAgKi9cbiAgc3RhdGljIFVOSVhfRVBPQ0ggPSBuZXcgX1RpbWVzdGFtcCgwbik7XG4gIC8qKlxuICAgKiBHZXQgYSBgVGltZXN0YW1wYCByZXByZXNlbnRpbmcgdGhlIGV4ZWN1dGlvbiBlbnZpcm9ubWVudCdzIGJlbGllZiBvZiB0aGUgY3VycmVudCBtb21lbnQgaW4gdGltZS5cbiAgICovXG4gIHN0YXRpYyBub3coKSB7XG4gICAgcmV0dXJuIF9UaW1lc3RhbXAuZnJvbURhdGUoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpO1xuICB9XG4gIC8qKiBDb252ZXJ0IHRvIG1pbGxpc2Vjb25kcyBzaW5jZSBVbml4IGVwb2NoLiAqL1xuICB0b01pbGxpcygpIHtcbiAgICByZXR1cm4gdGhpcy5taWNyb3NTaW5jZVVuaXhFcG9jaCAvIDEwMDBuO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSBgVGltZXN0YW1wYCByZXByZXNlbnRpbmcgdGhlIHNhbWUgcG9pbnQgaW4gdGltZSBhcyBgZGF0ZWAuXG4gICAqL1xuICBzdGF0aWMgZnJvbURhdGUoZGF0ZSkge1xuICAgIGNvbnN0IG1pbGxpcyA9IGRhdGUuZ2V0VGltZSgpO1xuICAgIGNvbnN0IG1pY3JvcyA9IEJpZ0ludChtaWxsaXMpICogX1RpbWVzdGFtcC5NSUNST1NfUEVSX01JTExJUztcbiAgICByZXR1cm4gbmV3IF9UaW1lc3RhbXAobWljcm9zKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGEgYERhdGVgIHJlcHJlc2VudGluZyBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIHBvaW50IGluIHRpbWUgYXMgYHRoaXNgLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCB0cnVuY2F0ZXMgdG8gbWlsbGlzZWNvbmQgcHJlY2lzaW9uLFxuICAgKiBhbmQgdGhyb3dzIGBSYW5nZUVycm9yYCBpZiB0aGUgYFRpbWVzdGFtcGAgaXMgb3V0c2lkZSB0aGUgcmFuZ2UgcmVwcmVzZW50YWJsZSBhcyBhIGBEYXRlYC5cbiAgICovXG4gIHRvRGF0ZSgpIHtcbiAgICBjb25zdCBtaWNyb3MgPSB0aGlzLl9fdGltZXN0YW1wX21pY3Jvc19zaW5jZV91bml4X2Vwb2NoX187XG4gICAgY29uc3QgbWlsbGlzID0gbWljcm9zIC8gX1RpbWVzdGFtcC5NSUNST1NfUEVSX01JTExJUztcbiAgICBpZiAobWlsbGlzID4gQmlnSW50KE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSB8fCBtaWxsaXMgPCBCaWdJbnQoTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIpKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcbiAgICAgICAgXCJUaW1lc3RhbXAgaXMgb3V0c2lkZSBvZiB0aGUgcmVwcmVzZW50YWJsZSByYW5nZSBvZiBKUydzIERhdGVcIlxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEYXRlKE51bWJlcihtaWxsaXMpKTtcbiAgfVxuICBzaW5jZShvdGhlcikge1xuICAgIHJldHVybiBuZXcgVGltZUR1cmF0aW9uKFxuICAgICAgdGhpcy5fX3RpbWVzdGFtcF9taWNyb3Nfc2luY2VfdW5peF9lcG9jaF9fIC0gb3RoZXIuX190aW1lc3RhbXBfbWljcm9zX3NpbmNlX3VuaXhfZXBvY2hfX1xuICAgICk7XG4gIH1cbn07XG5cbi8vIHNyYy9saWIvdXVpZC50c1xudmFyIFV1aWQgPSBjbGFzcyBfVXVpZCB7XG4gIF9fdXVpZF9fO1xuICAvKipcbiAgICogVGhlIG5pbCBVVUlEIChhbGwgemVyb3MpLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiBjb25zdCB1dWlkID0gVXVpZC5OSUw7XG4gICAqIGNvbnNvbGUuYXNzZXJ0KFxuICAgKiAgIHV1aWQudG9TdHJpbmcoKSA9PT0gXCIwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDBcIlxuICAgKiApO1xuICAgKiBgYGBcbiAgICovXG4gIHN0YXRpYyBOSUwgPSBuZXcgX1V1aWQoMG4pO1xuICBzdGF0aWMgTUFYX1VVSURfQklHSU5UID0gMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZm47XG4gIC8qKlxuICAgKiBUaGUgbWF4IFVVSUQgKGFsbCBvbmVzKS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogY29uc3QgdXVpZCA9IFV1aWQuTUFYO1xuICAgKiBjb25zb2xlLmFzc2VydChcbiAgICogICB1dWlkLnRvU3RyaW5nKCkgPT09IFwiZmZmZmZmZmYtZmZmZi1mZmZmLWZmZmYtZmZmZmZmZmZmZmZmXCJcbiAgICogKTtcbiAgICogYGBgXG4gICAqL1xuICBzdGF0aWMgTUFYID0gbmV3IF9VdWlkKF9VdWlkLk1BWF9VVUlEX0JJR0lOVCk7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBVVUlEIGZyb20gYSByYXcgMTI4LWJpdCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHUgLSBVbnNpZ25lZCAxMjgtYml0IGludGVnZXJcbiAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSB2YWx1ZSBpcyBvdXRzaWRlIHRoZSB2YWxpZCBVVUlEIHJhbmdlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih1KSB7XG4gICAgaWYgKHUgPCAwbiB8fCB1ID4gX1V1aWQuTUFYX1VVSURfQklHSU5UKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFVVSUQ6IG11c3QgYmUgYmV0d2VlbiAwIGFuZCBgTUFYX1VVSURfQklHSU5UYFwiKTtcbiAgICB9XG4gICAgdGhpcy5fX3V1aWRfXyA9IHU7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIFVVSUQgYHY0YCBmcm9tIGV4cGxpY2l0IHJhbmRvbSBieXRlcy5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgYXNzdW1lcyB0aGUgYnl0ZXMgYXJlIGFscmVhZHkgc3VmZmljaWVudGx5IHJhbmRvbS5cbiAgICogSXQgb25seSBzZXRzIHRoZSBhcHByb3ByaWF0ZSBiaXRzIGZvciB0aGUgVVVJRCB2ZXJzaW9uIGFuZCB2YXJpYW50LlxuICAgKlxuICAgKiBAcGFyYW0gYnl0ZXMgLSBFeGFjdGx5IDE2IHJhbmRvbSBieXRlc1xuICAgKiBAcmV0dXJucyBBIFVVSUQgYHY0YFxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgYGJ5dGVzLmxlbmd0aCAhPT0gMTZgXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIGNvbnN0IHJhbmRvbUJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICAgKiBjb25zdCB1dWlkID0gVXVpZC5mcm9tUmFuZG9tQnl0ZXNWNChyYW5kb21CeXRlcyk7XG4gICAqXG4gICAqIGNvbnNvbGUuYXNzZXJ0KFxuICAgKiAgIHV1aWQudG9TdHJpbmcoKSA9PT0gXCIwMDAwMDAwMC0wMDAwLTQwMDAtODAwMC0wMDAwMDAwMDAwMDBcIlxuICAgKiApO1xuICAgKiBgYGBcbiAgICovXG4gIHN0YXRpYyBmcm9tUmFuZG9tQnl0ZXNWNChieXRlcykge1xuICAgIGlmIChieXRlcy5sZW5ndGggIT09IDE2KSB0aHJvdyBuZXcgRXJyb3IoXCJVVUlEIHY0IHJlcXVpcmVzIDE2IGJ5dGVzXCIpO1xuICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KGJ5dGVzKTtcbiAgICBhcnJbNl0gPSBhcnJbNl0gJiAxNSB8IDY0O1xuICAgIGFycls4XSA9IGFycls4XSAmIDYzIHwgMTI4O1xuICAgIHJldHVybiBuZXcgX1V1aWQoX1V1aWQuYnl0ZXNUb0JpZ0ludChhcnIpKTtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGUgYSBVVUlEIGB2N2AgdXNpbmcgYSBtb25vdG9uaWMgY291bnRlciBmcm9tIGAwYCB0byBgMl4zMSAtIDFgLFxuICAgKiBhIHRpbWVzdGFtcCwgYW5kIDQgcmFuZG9tIGJ5dGVzLlxuICAgKlxuICAgKiBUaGUgY291bnRlciB3cmFwcyBhcm91bmQgb24gb3ZlcmZsb3cuXG4gICAqXG4gICAqIFRoZSBVVUlEIGB2N2AgaXMgc3RydWN0dXJlZCBhcyBmb2xsb3dzOlxuICAgKlxuICAgKiBgYGBhc2NpaVxuICAgKiDilIzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJBcbiAgICogfCBCMCAgfCBCMSAgfCBCMiAgfCBCMyAgfCBCNCAgfCBCNSAgICAgICAgICAgICAgfCAgICAgICAgIEI2ICAgICAgICB8XG4gICAqIOKUnOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUpFxuICAgKiB8ICAgICAgICAgICAgICAgICB1bml4X3RzX21zICAgICAgICAgICAgICAgICAgICB8ICAgICAgdmVyc2lvbiA3ICAgIHxcbiAgICog4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS04pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYXG4gICAqIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUrOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUrOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUrOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxuICAgKiB8IEI3ICAgICAgICAgICB8IEI4ICAgICAgfCBCOSAgfCBCMTAgfCBCMTEgIHwgQjEyIHwgQjEzIHwgQjE0IHwgQjE1IHxcbiAgICog4pSc4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkXG4gICAqIHwgY291bnRlcl9oaWdoIHwgdmFyaWFudCB8ICAgIGNvdW50ZXJfbG93ICAgfCAgICAgICAgcmFuZG9tICAgICAgICAgfFxuICAgKiDilJTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLTilIDilIDilIDilIDilIDilIDilIDilIDilIDilLTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJhcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSBjb3VudGVyIC0gTXV0YWJsZSBtb25vdG9uaWMgY291bnRlciAoMzEtYml0KVxuICAgKiBAcGFyYW0gbm93IC0gVGltZXN0YW1wIHNpbmNlIHRoZSBVbml4IGVwb2NoXG4gICAqIEBwYXJhbSByYW5kb21CeXRlcyAtIEV4YWN0bHkgNCByYW5kb20gYnl0ZXNcbiAgICogQHJldHVybnMgQSBVVUlEIGB2N2BcbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBgY291bnRlcmAgaXMgbmVnYXRpdmVcbiAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBgdGltZXN0YW1wYCBpcyBiZWZvcmUgdGhlIFVuaXggZXBvY2hcbiAgICogQHRocm93cyB7RXJyb3J9IElmIGByYW5kb21CeXRlcy5sZW5ndGggIT09IDRgXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIGNvbnN0IG5vdyA9IFRpbWVzdGFtcC5mcm9tTWlsbGlzKDFfNjg2XzAwMF8wMDBfMDAwbik7XG4gICAqIGNvbnN0IGNvdW50ZXIgPSB7IHZhbHVlOiAxIH07XG4gICAqIGNvbnN0IHJhbmRvbUJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAqXG4gICAqIGNvbnN0IHV1aWQgPSBVdWlkLmZyb21Db3VudGVyVjcoY291bnRlciwgbm93LCByYW5kb21CeXRlcyk7XG4gICAqXG4gICAqIGNvbnNvbGUuYXNzZXJ0KFxuICAgKiAgIHV1aWQudG9TdHJpbmcoKSA9PT0gXCIwMDAwNjQ3ZS01MTgwLTcwMDAtODAwMC0wMDAyMDAwMDAwMDBcIlxuICAgKiApO1xuICAgKiBgYGBcbiAgICovXG4gIHN0YXRpYyBmcm9tQ291bnRlclY3KGNvdW50ZXIsIG5vdywgcmFuZG9tQnl0ZXMpIHtcbiAgICBpZiAocmFuZG9tQnl0ZXMubGVuZ3RoICE9PSA0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgZnJvbUNvdW50ZXJWN2AgcmVxdWlyZXMgYHJhbmRvbUJ5dGVzLmxlbmd0aCA9PSA0YFwiKTtcbiAgICB9XG4gICAgaWYgKGNvdW50ZXIudmFsdWUgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgZnJvbUNvdW50ZXJWN2AgdXVpZCBgY291bnRlcmAgbXVzdCBiZSBub24tbmVnYXRpdmVcIik7XG4gICAgfVxuICAgIGlmIChub3cuX190aW1lc3RhbXBfbWljcm9zX3NpbmNlX3VuaXhfZXBvY2hfXyA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImBmcm9tQ291bnRlclY3YCBgdGltZXN0YW1wYCBiZWZvcmUgdW5peCBlcG9jaFwiKTtcbiAgICB9XG4gICAgY29uc3QgY291bnRlclZhbCA9IGNvdW50ZXIudmFsdWU7XG4gICAgY291bnRlci52YWx1ZSA9IGNvdW50ZXJWYWwgKyAxICYgMjE0NzQ4MzY0NztcbiAgICBjb25zdCB0c01zID0gbm93LnRvTWlsbGlzKCkgJiAweGZmZmZmZmZmZmZmZm47XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheSgxNik7XG4gICAgYnl0ZXNbMF0gPSBOdW1iZXIodHNNcyA+PiA0MG4gJiAweGZmbik7XG4gICAgYnl0ZXNbMV0gPSBOdW1iZXIodHNNcyA+PiAzMm4gJiAweGZmbik7XG4gICAgYnl0ZXNbMl0gPSBOdW1iZXIodHNNcyA+PiAyNG4gJiAweGZmbik7XG4gICAgYnl0ZXNbM10gPSBOdW1iZXIodHNNcyA+PiAxNm4gJiAweGZmbik7XG4gICAgYnl0ZXNbNF0gPSBOdW1iZXIodHNNcyA+PiA4biAmIDB4ZmZuKTtcbiAgICBieXRlc1s1XSA9IE51bWJlcih0c01zICYgMHhmZm4pO1xuICAgIGJ5dGVzWzddID0gY291bnRlclZhbCA+Pj4gMjMgJiAyNTU7XG4gICAgYnl0ZXNbOV0gPSBjb3VudGVyVmFsID4+PiAxNSAmIDI1NTtcbiAgICBieXRlc1sxMF0gPSBjb3VudGVyVmFsID4+PiA3ICYgMjU1O1xuICAgIGJ5dGVzWzExXSA9IChjb3VudGVyVmFsICYgMTI3KSA8PCAxICYgMjU1O1xuICAgIGJ5dGVzWzEyXSB8PSByYW5kb21CeXRlc1swXSAmIDEyNztcbiAgICBieXRlc1sxM10gPSByYW5kb21CeXRlc1sxXTtcbiAgICBieXRlc1sxNF0gPSByYW5kb21CeXRlc1syXTtcbiAgICBieXRlc1sxNV0gPSByYW5kb21CeXRlc1szXTtcbiAgICBieXRlc1s2XSA9IGJ5dGVzWzZdICYgMTUgfCAxMTI7XG4gICAgYnl0ZXNbOF0gPSBieXRlc1s4XSAmIDYzIHwgMTI4O1xuICAgIHJldHVybiBuZXcgX1V1aWQoX1V1aWQuYnl0ZXNUb0JpZ0ludChieXRlcykpO1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZSBhIFVVSUQgZnJvbSBhIHN0cmluZyByZXByZXNlbnRhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHMgLSBVVUlEIHN0cmluZ1xuICAgKiBAcmV0dXJucyBQYXJzZWQgVVVJRFxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHN0cmluZyBpcyBub3QgYSB2YWxpZCBVVUlEXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIGNvbnN0IHMgPSBcIjAxODg4ZDZlLTVjMDAtNzAwMC04MDAwLTAwMDAwMDAwMDAwMFwiO1xuICAgKiBjb25zdCB1dWlkID0gVXVpZC5wYXJzZShzKTtcbiAgICpcbiAgICogY29uc29sZS5hc3NlcnQodXVpZC50b1N0cmluZygpID09PSBzKTtcbiAgICogYGBgXG4gICAqL1xuICBzdGF0aWMgcGFyc2Uocykge1xuICAgIGNvbnN0IGhleCA9IHMucmVwbGFjZSgvLS9nLCBcIlwiKTtcbiAgICBpZiAoaGV4Lmxlbmd0aCAhPT0gMzIpIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaGV4IFVVSURcIik7XG4gICAgbGV0IHYgPSAwbjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDMyOyBpICs9IDIpIHtcbiAgICAgIHYgPSB2IDw8IDhuIHwgQmlnSW50KHBhcnNlSW50KGhleC5zbGljZShpLCBpICsgMiksIDE2KSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgX1V1aWQodik7XG4gIH1cbiAgLyoqIENvbnZlcnQgdG8gc3RyaW5nIChoeXBoZW5hdGVkIGZvcm0pLiAqL1xuICB0b1N0cmluZygpIHtcbiAgICBjb25zdCBieXRlcyA9IF9VdWlkLmJpZ0ludFRvQnl0ZXModGhpcy5fX3V1aWRfXyk7XG4gICAgY29uc3QgaGV4ID0gWy4uLmJ5dGVzXS5tYXAoKGIpID0+IGIudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKSkuam9pbihcIlwiKTtcbiAgICByZXR1cm4gaGV4LnNsaWNlKDAsIDgpICsgXCItXCIgKyBoZXguc2xpY2UoOCwgMTIpICsgXCItXCIgKyBoZXguc2xpY2UoMTIsIDE2KSArIFwiLVwiICsgaGV4LnNsaWNlKDE2LCAyMCkgKyBcIi1cIiArIGhleC5zbGljZSgyMCk7XG4gIH1cbiAgLyoqIENvbnZlcnQgdG8gYmlnaW50ICh1MTI4KS4gKi9cbiAgYXNCaWdJbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX191dWlkX187XG4gIH1cbiAgLyoqIFJldHVybiBhIGBVaW50OEFycmF5YCBvZiAxNiBieXRlcy4gKi9cbiAgdG9CeXRlcygpIHtcbiAgICByZXR1cm4gX1V1aWQuYmlnSW50VG9CeXRlcyh0aGlzLl9fdXVpZF9fKTtcbiAgfVxuICBzdGF0aWMgYnl0ZXNUb0JpZ0ludChieXRlcykge1xuICAgIGxldCByZXN1bHQgPSAwbjtcbiAgICBmb3IgKGNvbnN0IGIgb2YgYnl0ZXMpIHJlc3VsdCA9IHJlc3VsdCA8PCA4biB8IEJpZ0ludChiKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHN0YXRpYyBiaWdJbnRUb0J5dGVzKHZhbHVlKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheSgxNik7XG4gICAgZm9yIChsZXQgaSA9IDE1OyBpID49IDA7IGktLSkge1xuICAgICAgYnl0ZXNbaV0gPSBOdW1iZXIodmFsdWUgJiAweGZmbik7XG4gICAgICB2YWx1ZSA+Pj0gOG47XG4gICAgfVxuICAgIHJldHVybiBieXRlcztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdmVyc2lvbiBvZiB0aGlzIFVVSUQuXG4gICAqXG4gICAqIFRoaXMgcmVwcmVzZW50cyB0aGUgYWxnb3JpdGhtIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIHZhbHVlLlxuICAgKlxuICAgKiBAcmV0dXJucyBBIGBVdWlkVmVyc2lvbmBcbiAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSB2ZXJzaW9uIGZpZWxkIGlzIG5vdCByZWNvZ25pemVkXG4gICAqL1xuICBnZXRWZXJzaW9uKCkge1xuICAgIGNvbnN0IHZlcnNpb24gPSB0aGlzLnRvQnl0ZXMoKVs2XSA+PiA0ICYgMTU7XG4gICAgc3dpdGNoICh2ZXJzaW9uKSB7XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIHJldHVybiBcIlY0XCI7XG4gICAgICBjYXNlIDc6XG4gICAgICAgIHJldHVybiBcIlY3XCI7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAodGhpcyA9PSBfVXVpZC5OSUwpIHtcbiAgICAgICAgICByZXR1cm4gXCJOaWxcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcyA9PSBfVXVpZC5NQVgpIHtcbiAgICAgICAgICByZXR1cm4gXCJNYXhcIjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIFVVSUQgdmVyc2lvbjogJHt2ZXJzaW9ufWApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRXh0cmFjdCB0aGUgbW9ub3RvbmljIGNvdW50ZXIgZnJvbSBhIFVVSUR2Ny5cbiAgICpcbiAgICogSW50ZW5kZWQgZm9yIHRlc3RpbmcgYW5kIGRpYWdub3N0aWNzLlxuICAgKiBCZWhhdmlvciBpcyB1bmRlZmluZWQgaWYgY2FsbGVkIG9uIGEgbm9uLVY3IFVVSUQuXG4gICAqXG4gICAqIEByZXR1cm5zIDMxLWJpdCBjb3VudGVyIHZhbHVlXG4gICAqL1xuICBnZXRDb3VudGVyKCkge1xuICAgIGNvbnN0IGJ5dGVzID0gdGhpcy50b0J5dGVzKCk7XG4gICAgY29uc3QgaGlnaCA9IGJ5dGVzWzddO1xuICAgIGNvbnN0IG1pZDEgPSBieXRlc1s5XTtcbiAgICBjb25zdCBtaWQyID0gYnl0ZXNbMTBdO1xuICAgIGNvbnN0IGxvdyA9IGJ5dGVzWzExXSA+Pj4gMTtcbiAgICByZXR1cm4gaGlnaCA8PCAyMyB8IG1pZDEgPDwgMTUgfCBtaWQyIDw8IDcgfCBsb3cgfCAwO1xuICB9XG4gIGNvbXBhcmVUbyhvdGhlcikge1xuICAgIGlmICh0aGlzLl9fdXVpZF9fIDwgb3RoZXIuX191dWlkX18pIHJldHVybiAtMTtcbiAgICBpZiAodGhpcy5fX3V1aWRfXyA+IG90aGVyLl9fdXVpZF9fKSByZXR1cm4gMTtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBzdGF0aWMgZ2V0QWxnZWJyYWljVHlwZSgpIHtcbiAgICByZXR1cm4gQWxnZWJyYWljVHlwZS5Qcm9kdWN0KHtcbiAgICAgIGVsZW1lbnRzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcIl9fdXVpZF9fXCIsXG4gICAgICAgICAgYWxnZWJyYWljVHlwZTogQWxnZWJyYWljVHlwZS5VMTI4XG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9KTtcbiAgfVxufTtcblxuLy8gc3JjL2xpYi9iaW5hcnlfcmVhZGVyLnRzXG52YXIgQmluYXJ5UmVhZGVyID0gY2xhc3Mge1xuICAvKipcbiAgICogVGhlIERhdGFWaWV3IHVzZWQgdG8gcmVhZCB2YWx1ZXMgZnJvbSB0aGUgYmluYXJ5IGRhdGEuXG4gICAqXG4gICAqIE5vdGU6IFRoZSBEYXRhVmlldydzIGBieXRlT2Zmc2V0YCBpcyByZWxhdGl2ZSB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZVxuICAgKiB1bmRlcmx5aW5nIEFycmF5QnVmZmVyLCBub3QgdGhlIHN0YXJ0IG9mIHRoZSBwcm92aWRlZCBVaW50OEFycmF5IGlucHV0LlxuICAgKiBUaGlzIGBCaW5hcnlSZWFkZXJgJ3MgYCNvZmZzZXRgIGZpZWxkIGlzIHVzZWQgdG8gdHJhY2sgdGhlIGN1cnJlbnQgcmVhZCBwb3NpdGlvblxuICAgKiByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIHByb3ZpZGVkIFVpbnQ4QXJyYXkgaW5wdXQuXG4gICAqL1xuICAjdmlldztcbiAgLyoqXG4gICAqIFJlcHJlc2VudHMgdGhlIG9mZnNldCAoaW4gYnl0ZXMpIHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGUgRGF0YVZpZXdcbiAgICogYW5kIHByb3ZpZGVkIFVpbnQ4QXJyYXkgaW5wdXQuXG4gICAqXG4gICAqIE5vdGU6IFRoaXMgaXMgKm5vdCogdGhlIGFic29sdXRlIGJ5dGUgb2Zmc2V0IHdpdGhpbiB0aGUgdW5kZXJseWluZyBBcnJheUJ1ZmZlci5cbiAgICovXG4gICNvZmZzZXQgPSAwO1xuICBjb25zdHJ1Y3RvcihpbnB1dCkge1xuICAgIHRoaXMuI3ZpZXcgPSBuZXcgRGF0YVZpZXcoaW5wdXQuYnVmZmVyLCBpbnB1dC5ieXRlT2Zmc2V0LCBpbnB1dC5ieXRlTGVuZ3RoKTtcbiAgICB0aGlzLiNvZmZzZXQgPSAwO1xuICB9XG4gIGdldCBvZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI29mZnNldDtcbiAgfVxuICBnZXQgcmVtYWluaW5nKCkge1xuICAgIHJldHVybiB0aGlzLiN2aWV3LmJ5dGVMZW5ndGggLSB0aGlzLiNvZmZzZXQ7XG4gIH1cbiAgLyoqIEVuc3VyZSB3ZSBoYXZlIGF0IGxlYXN0IGBuYCBieXRlcyBsZWZ0IHRvIHJlYWQgKi9cbiAgI2Vuc3VyZShuKSB7XG4gICAgaWYgKHRoaXMuI29mZnNldCArIG4gPiB0aGlzLiN2aWV3LmJ5dGVMZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFxuICAgICAgICBgVHJpZWQgdG8gcmVhZCAke259IGJ5dGUocykgYXQgcmVsYXRpdmUgb2Zmc2V0ICR7dGhpcy4jb2Zmc2V0fSwgYnV0IG9ubHkgJHt0aGlzLnJlbWFpbmluZ30gYnl0ZShzKSByZW1haW5gXG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZWFkVUludDhBcnJheSgpIHtcbiAgICBjb25zdCBsZW5ndGggPSB0aGlzLnJlYWRVMzIoKTtcbiAgICB0aGlzLiNlbnN1cmUobGVuZ3RoKTtcbiAgICByZXR1cm4gdGhpcy5yZWFkQnl0ZXMobGVuZ3RoKTtcbiAgfVxuICByZWFkQm9vbCgpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI3ZpZXcuZ2V0VWludDgodGhpcy4jb2Zmc2V0KTtcbiAgICB0aGlzLiNvZmZzZXQgKz0gMTtcbiAgICByZXR1cm4gdmFsdWUgIT09IDA7XG4gIH1cbiAgcmVhZEJ5dGUoKSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLiN2aWV3LmdldFVpbnQ4KHRoaXMuI29mZnNldCk7XG4gICAgdGhpcy4jb2Zmc2V0ICs9IDE7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJlYWRCeXRlcyhsZW5ndGgpIHtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KFxuICAgICAgdGhpcy4jdmlldy5idWZmZXIsXG4gICAgICB0aGlzLiN2aWV3LmJ5dGVPZmZzZXQgKyB0aGlzLiNvZmZzZXQsXG4gICAgICBsZW5ndGhcbiAgICApO1xuICAgIHRoaXMuI29mZnNldCArPSBsZW5ndGg7XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG4gIHJlYWRJOCgpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI3ZpZXcuZ2V0SW50OCh0aGlzLiNvZmZzZXQpO1xuICAgIHRoaXMuI29mZnNldCArPSAxO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZWFkVTgoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhZEJ5dGUoKTtcbiAgfVxuICByZWFkSTE2KCkge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jdmlldy5nZXRJbnQxNih0aGlzLiNvZmZzZXQsIHRydWUpO1xuICAgIHRoaXMuI29mZnNldCArPSAyO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZWFkVTE2KCkge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jdmlldy5nZXRVaW50MTYodGhpcy4jb2Zmc2V0LCB0cnVlKTtcbiAgICB0aGlzLiNvZmZzZXQgKz0gMjtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmVhZEkzMigpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI3ZpZXcuZ2V0SW50MzIodGhpcy4jb2Zmc2V0LCB0cnVlKTtcbiAgICB0aGlzLiNvZmZzZXQgKz0gNDtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmVhZFUzMigpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI3ZpZXcuZ2V0VWludDMyKHRoaXMuI29mZnNldCwgdHJ1ZSk7XG4gICAgdGhpcy4jb2Zmc2V0ICs9IDQ7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJlYWRJNjQoKSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLiN2aWV3LmdldEJpZ0ludDY0KHRoaXMuI29mZnNldCwgdHJ1ZSk7XG4gICAgdGhpcy4jb2Zmc2V0ICs9IDg7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJlYWRVNjQoKSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLiN2aWV3LmdldEJpZ1VpbnQ2NCh0aGlzLiNvZmZzZXQsIHRydWUpO1xuICAgIHRoaXMuI29mZnNldCArPSA4O1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZWFkVTEyOCgpIHtcbiAgICBjb25zdCBsb3dlclBhcnQgPSB0aGlzLiN2aWV3LmdldEJpZ1VpbnQ2NCh0aGlzLiNvZmZzZXQsIHRydWUpO1xuICAgIGNvbnN0IHVwcGVyUGFydCA9IHRoaXMuI3ZpZXcuZ2V0QmlnVWludDY0KHRoaXMuI29mZnNldCArIDgsIHRydWUpO1xuICAgIHRoaXMuI29mZnNldCArPSAxNjtcbiAgICByZXR1cm4gKHVwcGVyUGFydCA8PCBCaWdJbnQoNjQpKSArIGxvd2VyUGFydDtcbiAgfVxuICByZWFkSTEyOCgpIHtcbiAgICBjb25zdCBsb3dlclBhcnQgPSB0aGlzLiN2aWV3LmdldEJpZ1VpbnQ2NCh0aGlzLiNvZmZzZXQsIHRydWUpO1xuICAgIGNvbnN0IHVwcGVyUGFydCA9IHRoaXMuI3ZpZXcuZ2V0QmlnSW50NjQodGhpcy4jb2Zmc2V0ICsgOCwgdHJ1ZSk7XG4gICAgdGhpcy4jb2Zmc2V0ICs9IDE2O1xuICAgIHJldHVybiAodXBwZXJQYXJ0IDw8IEJpZ0ludCg2NCkpICsgbG93ZXJQYXJ0O1xuICB9XG4gIHJlYWRVMjU2KCkge1xuICAgIGNvbnN0IHAwID0gdGhpcy4jdmlldy5nZXRCaWdVaW50NjQodGhpcy4jb2Zmc2V0LCB0cnVlKTtcbiAgICBjb25zdCBwMSA9IHRoaXMuI3ZpZXcuZ2V0QmlnVWludDY0KHRoaXMuI29mZnNldCArIDgsIHRydWUpO1xuICAgIGNvbnN0IHAyID0gdGhpcy4jdmlldy5nZXRCaWdVaW50NjQodGhpcy4jb2Zmc2V0ICsgMTYsIHRydWUpO1xuICAgIGNvbnN0IHAzID0gdGhpcy4jdmlldy5nZXRCaWdVaW50NjQodGhpcy4jb2Zmc2V0ICsgMjQsIHRydWUpO1xuICAgIHRoaXMuI29mZnNldCArPSAzMjtcbiAgICByZXR1cm4gKHAzIDw8IEJpZ0ludCgzICogNjQpKSArIChwMiA8PCBCaWdJbnQoMiAqIDY0KSkgKyAocDEgPDwgQmlnSW50KDEgKiA2NCkpICsgcDA7XG4gIH1cbiAgcmVhZEkyNTYoKSB7XG4gICAgY29uc3QgcDAgPSB0aGlzLiN2aWV3LmdldEJpZ1VpbnQ2NCh0aGlzLiNvZmZzZXQsIHRydWUpO1xuICAgIGNvbnN0IHAxID0gdGhpcy4jdmlldy5nZXRCaWdVaW50NjQodGhpcy4jb2Zmc2V0ICsgOCwgdHJ1ZSk7XG4gICAgY29uc3QgcDIgPSB0aGlzLiN2aWV3LmdldEJpZ1VpbnQ2NCh0aGlzLiNvZmZzZXQgKyAxNiwgdHJ1ZSk7XG4gICAgY29uc3QgcDMgPSB0aGlzLiN2aWV3LmdldEJpZ0ludDY0KHRoaXMuI29mZnNldCArIDI0LCB0cnVlKTtcbiAgICB0aGlzLiNvZmZzZXQgKz0gMzI7XG4gICAgcmV0dXJuIChwMyA8PCBCaWdJbnQoMyAqIDY0KSkgKyAocDIgPDwgQmlnSW50KDIgKiA2NCkpICsgKHAxIDw8IEJpZ0ludCgxICogNjQpKSArIHAwO1xuICB9XG4gIHJlYWRGMzIoKSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLiN2aWV3LmdldEZsb2F0MzIodGhpcy4jb2Zmc2V0LCB0cnVlKTtcbiAgICB0aGlzLiNvZmZzZXQgKz0gNDtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmVhZEY2NCgpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI3ZpZXcuZ2V0RmxvYXQ2NCh0aGlzLiNvZmZzZXQsIHRydWUpO1xuICAgIHRoaXMuI29mZnNldCArPSA4O1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZWFkU3RyaW5nKCkge1xuICAgIGNvbnN0IHVpbnQ4QXJyYXkgPSB0aGlzLnJlYWRVSW50OEFycmF5KCk7XG4gICAgcmV0dXJuIG5ldyBUZXh0RGVjb2RlcihcInV0Zi04XCIpLmRlY29kZSh1aW50OEFycmF5KTtcbiAgfVxufTtcblxuLy8gc3JjL2xpYi9iaW5hcnlfd3JpdGVyLnRzXG52YXIgaW1wb3J0X2Jhc2U2NF9qcyA9IF9fdG9FU00ocmVxdWlyZV9iYXNlNjRfanMoKSk7XG52YXIgQmluYXJ5V3JpdGVyID0gY2xhc3Mge1xuICAjYnVmZmVyO1xuICAjdmlldztcbiAgI29mZnNldCA9IDA7XG4gIGNvbnN0cnVjdG9yKHNpemUpIHtcbiAgICB0aGlzLiNidWZmZXIgPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgICB0aGlzLiN2aWV3ID0gbmV3IERhdGFWaWV3KHRoaXMuI2J1ZmZlci5idWZmZXIpO1xuICB9XG4gICNleHBhbmRCdWZmZXIoYWRkaXRpb25hbENhcGFjaXR5KSB7XG4gICAgY29uc3QgbWluQ2FwYWNpdHkgPSB0aGlzLiNvZmZzZXQgKyBhZGRpdGlvbmFsQ2FwYWNpdHkgKyAxO1xuICAgIGlmIChtaW5DYXBhY2l0eSA8PSB0aGlzLiNidWZmZXIubGVuZ3RoKSByZXR1cm47XG4gICAgbGV0IG5ld0NhcGFjaXR5ID0gdGhpcy4jYnVmZmVyLmxlbmd0aCAqIDI7XG4gICAgaWYgKG5ld0NhcGFjaXR5IDwgbWluQ2FwYWNpdHkpIG5ld0NhcGFjaXR5ID0gbWluQ2FwYWNpdHk7XG4gICAgY29uc3QgbmV3QnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkobmV3Q2FwYWNpdHkpO1xuICAgIG5ld0J1ZmZlci5zZXQodGhpcy4jYnVmZmVyKTtcbiAgICB0aGlzLiNidWZmZXIgPSBuZXdCdWZmZXI7XG4gICAgdGhpcy4jdmlldyA9IG5ldyBEYXRhVmlldyh0aGlzLiNidWZmZXIuYnVmZmVyKTtcbiAgfVxuICB0b0Jhc2U2NCgpIHtcbiAgICByZXR1cm4gKDAsIGltcG9ydF9iYXNlNjRfanMuZnJvbUJ5dGVBcnJheSkodGhpcy4jYnVmZmVyLnN1YmFycmF5KDAsIHRoaXMuI29mZnNldCkpO1xuICB9XG4gIGdldEJ1ZmZlcigpIHtcbiAgICByZXR1cm4gdGhpcy4jYnVmZmVyLnNsaWNlKDAsIHRoaXMuI29mZnNldCk7XG4gIH1cbiAgZ2V0IG9mZnNldCgpIHtcbiAgICByZXR1cm4gdGhpcy4jb2Zmc2V0O1xuICB9XG4gIHdyaXRlVUludDhBcnJheSh2YWx1ZSkge1xuICAgIGNvbnN0IGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICB0aGlzLiNleHBhbmRCdWZmZXIoNCArIGxlbmd0aCk7XG4gICAgdGhpcy53cml0ZVUzMihsZW5ndGgpO1xuICAgIHRoaXMuI2J1ZmZlci5zZXQodmFsdWUsIHRoaXMuI29mZnNldCk7XG4gICAgdGhpcy4jb2Zmc2V0ICs9IHZhbHVlLmxlbmd0aDtcbiAgfVxuICB3cml0ZUJvb2wodmFsdWUpIHtcbiAgICB0aGlzLiNleHBhbmRCdWZmZXIoMSk7XG4gICAgdGhpcy4jdmlldy5zZXRVaW50OCh0aGlzLiNvZmZzZXQsIHZhbHVlID8gMSA6IDApO1xuICAgIHRoaXMuI29mZnNldCArPSAxO1xuICB9XG4gIHdyaXRlQnl0ZSh2YWx1ZSkge1xuICAgIHRoaXMuI2V4cGFuZEJ1ZmZlcigxKTtcbiAgICB0aGlzLiN2aWV3LnNldFVpbnQ4KHRoaXMuI29mZnNldCwgdmFsdWUpO1xuICAgIHRoaXMuI29mZnNldCArPSAxO1xuICB9XG4gIHdyaXRlSTgodmFsdWUpIHtcbiAgICB0aGlzLiNleHBhbmRCdWZmZXIoMSk7XG4gICAgdGhpcy4jdmlldy5zZXRJbnQ4KHRoaXMuI29mZnNldCwgdmFsdWUpO1xuICAgIHRoaXMuI29mZnNldCArPSAxO1xuICB9XG4gIHdyaXRlVTgodmFsdWUpIHtcbiAgICB0aGlzLiNleHBhbmRCdWZmZXIoMSk7XG4gICAgdGhpcy4jdmlldy5zZXRVaW50OCh0aGlzLiNvZmZzZXQsIHZhbHVlKTtcbiAgICB0aGlzLiNvZmZzZXQgKz0gMTtcbiAgfVxuICB3cml0ZUkxNih2YWx1ZSkge1xuICAgIHRoaXMuI2V4cGFuZEJ1ZmZlcigyKTtcbiAgICB0aGlzLiN2aWV3LnNldEludDE2KHRoaXMuI29mZnNldCwgdmFsdWUsIHRydWUpO1xuICAgIHRoaXMuI29mZnNldCArPSAyO1xuICB9XG4gIHdyaXRlVTE2KHZhbHVlKSB7XG4gICAgdGhpcy4jZXhwYW5kQnVmZmVyKDIpO1xuICAgIHRoaXMuI3ZpZXcuc2V0VWludDE2KHRoaXMuI29mZnNldCwgdmFsdWUsIHRydWUpO1xuICAgIHRoaXMuI29mZnNldCArPSAyO1xuICB9XG4gIHdyaXRlSTMyKHZhbHVlKSB7XG4gICAgdGhpcy4jZXhwYW5kQnVmZmVyKDQpO1xuICAgIHRoaXMuI3ZpZXcuc2V0SW50MzIodGhpcy4jb2Zmc2V0LCB2YWx1ZSwgdHJ1ZSk7XG4gICAgdGhpcy4jb2Zmc2V0ICs9IDQ7XG4gIH1cbiAgd3JpdGVVMzIodmFsdWUpIHtcbiAgICB0aGlzLiNleHBhbmRCdWZmZXIoNCk7XG4gICAgdGhpcy4jdmlldy5zZXRVaW50MzIodGhpcy4jb2Zmc2V0LCB2YWx1ZSwgdHJ1ZSk7XG4gICAgdGhpcy4jb2Zmc2V0ICs9IDQ7XG4gIH1cbiAgd3JpdGVJNjQodmFsdWUpIHtcbiAgICB0aGlzLiNleHBhbmRCdWZmZXIoOCk7XG4gICAgdGhpcy4jdmlldy5zZXRCaWdJbnQ2NCh0aGlzLiNvZmZzZXQsIHZhbHVlLCB0cnVlKTtcbiAgICB0aGlzLiNvZmZzZXQgKz0gODtcbiAgfVxuICB3cml0ZVU2NCh2YWx1ZSkge1xuICAgIHRoaXMuI2V4cGFuZEJ1ZmZlcig4KTtcbiAgICB0aGlzLiN2aWV3LnNldEJpZ1VpbnQ2NCh0aGlzLiNvZmZzZXQsIHZhbHVlLCB0cnVlKTtcbiAgICB0aGlzLiNvZmZzZXQgKz0gODtcbiAgfVxuICB3cml0ZVUxMjgodmFsdWUpIHtcbiAgICB0aGlzLiNleHBhbmRCdWZmZXIoMTYpO1xuICAgIGNvbnN0IGxvd2VyUGFydCA9IHZhbHVlICYgQmlnSW50KFwiMHhGRkZGRkZGRkZGRkZGRkZGXCIpO1xuICAgIGNvbnN0IHVwcGVyUGFydCA9IHZhbHVlID4+IEJpZ0ludCg2NCk7XG4gICAgdGhpcy4jdmlldy5zZXRCaWdVaW50NjQodGhpcy4jb2Zmc2V0LCBsb3dlclBhcnQsIHRydWUpO1xuICAgIHRoaXMuI3ZpZXcuc2V0QmlnVWludDY0KHRoaXMuI29mZnNldCArIDgsIHVwcGVyUGFydCwgdHJ1ZSk7XG4gICAgdGhpcy4jb2Zmc2V0ICs9IDE2O1xuICB9XG4gIHdyaXRlSTEyOCh2YWx1ZSkge1xuICAgIHRoaXMuI2V4cGFuZEJ1ZmZlcigxNik7XG4gICAgY29uc3QgbG93ZXJQYXJ0ID0gdmFsdWUgJiBCaWdJbnQoXCIweEZGRkZGRkZGRkZGRkZGRkZcIik7XG4gICAgY29uc3QgdXBwZXJQYXJ0ID0gdmFsdWUgPj4gQmlnSW50KDY0KTtcbiAgICB0aGlzLiN2aWV3LnNldEJpZ0ludDY0KHRoaXMuI29mZnNldCwgbG93ZXJQYXJ0LCB0cnVlKTtcbiAgICB0aGlzLiN2aWV3LnNldEJpZ0ludDY0KHRoaXMuI29mZnNldCArIDgsIHVwcGVyUGFydCwgdHJ1ZSk7XG4gICAgdGhpcy4jb2Zmc2V0ICs9IDE2O1xuICB9XG4gIHdyaXRlVTI1Nih2YWx1ZSkge1xuICAgIHRoaXMuI2V4cGFuZEJ1ZmZlcigzMik7XG4gICAgY29uc3QgbG93XzY0X21hc2sgPSBCaWdJbnQoXCIweEZGRkZGRkZGRkZGRkZGRkZcIik7XG4gICAgY29uc3QgcDAgPSB2YWx1ZSAmIGxvd182NF9tYXNrO1xuICAgIGNvbnN0IHAxID0gdmFsdWUgPj4gQmlnSW50KDY0ICogMSkgJiBsb3dfNjRfbWFzaztcbiAgICBjb25zdCBwMiA9IHZhbHVlID4+IEJpZ0ludCg2NCAqIDIpICYgbG93XzY0X21hc2s7XG4gICAgY29uc3QgcDMgPSB2YWx1ZSA+PiBCaWdJbnQoNjQgKiAzKTtcbiAgICB0aGlzLiN2aWV3LnNldEJpZ1VpbnQ2NCh0aGlzLiNvZmZzZXQgKyA4ICogMCwgcDAsIHRydWUpO1xuICAgIHRoaXMuI3ZpZXcuc2V0QmlnVWludDY0KHRoaXMuI29mZnNldCArIDggKiAxLCBwMSwgdHJ1ZSk7XG4gICAgdGhpcy4jdmlldy5zZXRCaWdVaW50NjQodGhpcy4jb2Zmc2V0ICsgOCAqIDIsIHAyLCB0cnVlKTtcbiAgICB0aGlzLiN2aWV3LnNldEJpZ1VpbnQ2NCh0aGlzLiNvZmZzZXQgKyA4ICogMywgcDMsIHRydWUpO1xuICAgIHRoaXMuI29mZnNldCArPSAzMjtcbiAgfVxuICB3cml0ZUkyNTYodmFsdWUpIHtcbiAgICB0aGlzLiNleHBhbmRCdWZmZXIoMzIpO1xuICAgIGNvbnN0IGxvd182NF9tYXNrID0gQmlnSW50KFwiMHhGRkZGRkZGRkZGRkZGRkZGXCIpO1xuICAgIGNvbnN0IHAwID0gdmFsdWUgJiBsb3dfNjRfbWFzaztcbiAgICBjb25zdCBwMSA9IHZhbHVlID4+IEJpZ0ludCg2NCAqIDEpICYgbG93XzY0X21hc2s7XG4gICAgY29uc3QgcDIgPSB2YWx1ZSA+PiBCaWdJbnQoNjQgKiAyKSAmIGxvd182NF9tYXNrO1xuICAgIGNvbnN0IHAzID0gdmFsdWUgPj4gQmlnSW50KDY0ICogMyk7XG4gICAgdGhpcy4jdmlldy5zZXRCaWdVaW50NjQodGhpcy4jb2Zmc2V0ICsgOCAqIDAsIHAwLCB0cnVlKTtcbiAgICB0aGlzLiN2aWV3LnNldEJpZ1VpbnQ2NCh0aGlzLiNvZmZzZXQgKyA4ICogMSwgcDEsIHRydWUpO1xuICAgIHRoaXMuI3ZpZXcuc2V0QmlnVWludDY0KHRoaXMuI29mZnNldCArIDggKiAyLCBwMiwgdHJ1ZSk7XG4gICAgdGhpcy4jdmlldy5zZXRCaWdJbnQ2NCh0aGlzLiNvZmZzZXQgKyA4ICogMywgcDMsIHRydWUpO1xuICAgIHRoaXMuI29mZnNldCArPSAzMjtcbiAgfVxuICB3cml0ZUYzMih2YWx1ZSkge1xuICAgIHRoaXMuI2V4cGFuZEJ1ZmZlcig0KTtcbiAgICB0aGlzLiN2aWV3LnNldEZsb2F0MzIodGhpcy4jb2Zmc2V0LCB2YWx1ZSwgdHJ1ZSk7XG4gICAgdGhpcy4jb2Zmc2V0ICs9IDQ7XG4gIH1cbiAgd3JpdGVGNjQodmFsdWUpIHtcbiAgICB0aGlzLiNleHBhbmRCdWZmZXIoOCk7XG4gICAgdGhpcy4jdmlldy5zZXRGbG9hdDY0KHRoaXMuI29mZnNldCwgdmFsdWUsIHRydWUpO1xuICAgIHRoaXMuI29mZnNldCArPSA4O1xuICB9XG4gIHdyaXRlU3RyaW5nKHZhbHVlKSB7XG4gICAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgIGNvbnN0IGVuY29kZWRTdHJpbmcgPSBlbmNvZGVyLmVuY29kZSh2YWx1ZSk7XG4gICAgdGhpcy53cml0ZVUzMihlbmNvZGVkU3RyaW5nLmxlbmd0aCk7XG4gICAgdGhpcy4jZXhwYW5kQnVmZmVyKGVuY29kZWRTdHJpbmcubGVuZ3RoKTtcbiAgICB0aGlzLiNidWZmZXIuc2V0KGVuY29kZWRTdHJpbmcsIHRoaXMuI29mZnNldCk7XG4gICAgdGhpcy4jb2Zmc2V0ICs9IGVuY29kZWRTdHJpbmcubGVuZ3RoO1xuICB9XG59O1xuXG4vLyBzcmMvbGliL3V0aWwudHNcbmZ1bmN0aW9uIHRvUGFzY2FsQ2FzZShzKSB7XG4gIGNvbnN0IHN0ciA9IHMucmVwbGFjZSgvKFstX11bYS16XSkvZ2ksICgkMSkgPT4ge1xuICAgIHJldHVybiAkMS50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoXCItXCIsIFwiXCIpLnJlcGxhY2UoXCJfXCIsIFwiXCIpO1xuICB9KTtcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbn1cbmZ1bmN0aW9uIHVpbnQ4QXJyYXlUb0hleFN0cmluZyhhcnJheSkge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKGFycmF5LnJldmVyc2UoKSwgKHgpID0+IChcIjAwXCIgKyB4LnRvU3RyaW5nKDE2KSkuc2xpY2UoLTIpKS5qb2luKFwiXCIpO1xufVxuZnVuY3Rpb24gdWludDhBcnJheVRvVTEyOChhcnJheSkge1xuICBpZiAoYXJyYXkubGVuZ3RoICE9IDE2KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVaW50OEFycmF5IGlzIG5vdCAxNiBieXRlcyBsb25nOiAke2FycmF5fWApO1xuICB9XG4gIHJldHVybiBuZXcgQmluYXJ5UmVhZGVyKGFycmF5KS5yZWFkVTEyOCgpO1xufVxuZnVuY3Rpb24gdWludDhBcnJheVRvVTI1NihhcnJheSkge1xuICBpZiAoYXJyYXkubGVuZ3RoICE9IDMyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVaW50OEFycmF5IGlzIG5vdCAzMiBieXRlcyBsb25nOiBbJHthcnJheX1dYCk7XG4gIH1cbiAgcmV0dXJuIG5ldyBCaW5hcnlSZWFkZXIoYXJyYXkpLnJlYWRVMjU2KCk7XG59XG5mdW5jdGlvbiBoZXhTdHJpbmdUb1VpbnQ4QXJyYXkoc3RyKSB7XG4gIGlmIChzdHIuc3RhcnRzV2l0aChcIjB4XCIpKSB7XG4gICAgc3RyID0gc3RyLnNsaWNlKDIpO1xuICB9XG4gIGNvbnN0IG1hdGNoZXMgPSBzdHIubWF0Y2goLy57MSwyfS9nKSB8fCBbXTtcbiAgY29uc3QgZGF0YSA9IFVpbnQ4QXJyYXkuZnJvbShcbiAgICBtYXRjaGVzLm1hcCgoYnl0ZSkgPT4gcGFyc2VJbnQoYnl0ZSwgMTYpKVxuICApO1xuICByZXR1cm4gZGF0YS5yZXZlcnNlKCk7XG59XG5mdW5jdGlvbiBoZXhTdHJpbmdUb1UxMjgoc3RyKSB7XG4gIHJldHVybiB1aW50OEFycmF5VG9VMTI4KGhleFN0cmluZ1RvVWludDhBcnJheShzdHIpKTtcbn1cbmZ1bmN0aW9uIGhleFN0cmluZ1RvVTI1NihzdHIpIHtcbiAgcmV0dXJuIHVpbnQ4QXJyYXlUb1UyNTYoaGV4U3RyaW5nVG9VaW50OEFycmF5KHN0cikpO1xufVxuZnVuY3Rpb24gdTEyOFRvVWludDhBcnJheShkYXRhKSB7XG4gIGNvbnN0IHdyaXRlciA9IG5ldyBCaW5hcnlXcml0ZXIoMTYpO1xuICB3cml0ZXIud3JpdGVVMTI4KGRhdGEpO1xuICByZXR1cm4gd3JpdGVyLmdldEJ1ZmZlcigpO1xufVxuZnVuY3Rpb24gdTEyOFRvSGV4U3RyaW5nKGRhdGEpIHtcbiAgcmV0dXJuIHVpbnQ4QXJyYXlUb0hleFN0cmluZyh1MTI4VG9VaW50OEFycmF5KGRhdGEpKTtcbn1cbmZ1bmN0aW9uIHUyNTZUb1VpbnQ4QXJyYXkoZGF0YSkge1xuICBjb25zdCB3cml0ZXIgPSBuZXcgQmluYXJ5V3JpdGVyKDMyKTtcbiAgd3JpdGVyLndyaXRlVTI1NihkYXRhKTtcbiAgcmV0dXJuIHdyaXRlci5nZXRCdWZmZXIoKTtcbn1cbmZ1bmN0aW9uIHUyNTZUb0hleFN0cmluZyhkYXRhKSB7XG4gIHJldHVybiB1aW50OEFycmF5VG9IZXhTdHJpbmcodTI1NlRvVWludDhBcnJheShkYXRhKSk7XG59XG5mdW5jdGlvbiB0b0NhbWVsQ2FzZShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bLV9dKy9nLCBcIl9cIikucmVwbGFjZSgvXyhbYS16QS1aMC05XSkvZywgKF8sIGMpID0+IGMudG9VcHBlckNhc2UoKSk7XG59XG5mdW5jdGlvbiBic2F0bkJhc2VTaXplKHR5cGVzcGFjZSwgdHkpIHtcbiAgY29uc3QgYXNzdW1lZEFycmF5TGVuZ3RoID0gNDtcbiAgd2hpbGUgKHR5LnRhZyA9PT0gXCJSZWZcIikgdHkgPSB0eXBlc3BhY2UudHlwZXNbdHkudmFsdWVdO1xuICBpZiAodHkudGFnID09PSBcIlByb2R1Y3RcIikge1xuICAgIGxldCBzdW0gPSAwO1xuICAgIGZvciAoY29uc3QgeyBhbGdlYnJhaWNUeXBlOiBlbGVtIH0gb2YgdHkudmFsdWUuZWxlbWVudHMpIHtcbiAgICAgIHN1bSArPSBic2F0bkJhc2VTaXplKHR5cGVzcGFjZSwgZWxlbSk7XG4gICAgfVxuICAgIHJldHVybiBzdW07XG4gIH0gZWxzZSBpZiAodHkudGFnID09PSBcIlN1bVwiKSB7XG4gICAgbGV0IG1pbiA9IEluZmluaXR5O1xuICAgIGZvciAoY29uc3QgeyBhbGdlYnJhaWNUeXBlOiB2YXJpIH0gb2YgdHkudmFsdWUudmFyaWFudHMpIHtcbiAgICAgIGNvbnN0IHZTaXplID0gYnNhdG5CYXNlU2l6ZSh0eXBlc3BhY2UsIHZhcmkpO1xuICAgICAgaWYgKHZTaXplIDwgbWluKSBtaW4gPSB2U2l6ZTtcbiAgICB9XG4gICAgaWYgKG1pbiA9PT0gSW5maW5pdHkpIG1pbiA9IDA7XG4gICAgcmV0dXJuIDQgKyBtaW47XG4gIH0gZWxzZSBpZiAodHkudGFnID09IFwiQXJyYXlcIikge1xuICAgIHJldHVybiA0ICsgYXNzdW1lZEFycmF5TGVuZ3RoICogYnNhdG5CYXNlU2l6ZSh0eXBlc3BhY2UsIHR5LnZhbHVlKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIFN0cmluZzogNCArIGFzc3VtZWRBcnJheUxlbmd0aCxcbiAgICBTdW06IDEsXG4gICAgQm9vbDogMSxcbiAgICBJODogMSxcbiAgICBVODogMSxcbiAgICBJMTY6IDIsXG4gICAgVTE2OiAyLFxuICAgIEkzMjogNCxcbiAgICBVMzI6IDQsXG4gICAgRjMyOiA0LFxuICAgIEk2NDogOCxcbiAgICBVNjQ6IDgsXG4gICAgRjY0OiA4LFxuICAgIEkxMjg6IDE2LFxuICAgIFUxMjg6IDE2LFxuICAgIEkyNTY6IDMyLFxuICAgIFUyNTY6IDMyXG4gIH1bdHkudGFnXTtcbn1cblxuLy8gc3JjL2xpYi9jb25uZWN0aW9uX2lkLnRzXG52YXIgQ29ubmVjdGlvbklkID0gY2xhc3MgX0Nvbm5lY3Rpb25JZCB7XG4gIF9fY29ubmVjdGlvbl9pZF9fO1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBgQ29ubmVjdGlvbklkYC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICB0aGlzLl9fY29ubmVjdGlvbl9pZF9fID0gZGF0YTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBhbGdlYnJhaWMgdHlwZSByZXByZXNlbnRhdGlvbiBvZiB0aGUge0BsaW5rIENvbm5lY3Rpb25JZH0gdHlwZS5cbiAgICogQHJldHVybnMgVGhlIGFsZ2VicmFpYyB0eXBlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0eXBlLlxuICAgKi9cbiAgc3RhdGljIGdldEFsZ2VicmFpY1R5cGUoKSB7XG4gICAgcmV0dXJuIEFsZ2VicmFpY1R5cGUuUHJvZHVjdCh7XG4gICAgICBlbGVtZW50czogW1xuICAgICAgICB7IG5hbWU6IFwiX19jb25uZWN0aW9uX2lkX19cIiwgYWxnZWJyYWljVHlwZTogQWxnZWJyYWljVHlwZS5VMTI4IH1cbiAgICAgIF1cbiAgICB9KTtcbiAgfVxuICBpc1plcm8oKSB7XG4gICAgcmV0dXJuIHRoaXMuX19jb25uZWN0aW9uX2lkX18gPT09IEJpZ0ludCgwKTtcbiAgfVxuICBzdGF0aWMgbnVsbElmWmVybyhhZGRyKSB7XG4gICAgaWYgKGFkZHIuaXNaZXJvKCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYWRkcjtcbiAgICB9XG4gIH1cbiAgc3RhdGljIHJhbmRvbSgpIHtcbiAgICBmdW5jdGlvbiByYW5kb21VOCgpIHtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyNTUpO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0ID0gQmlnSW50KDApO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgICAgcmVzdWx0ID0gcmVzdWx0IDw8IEJpZ0ludCg4KSB8IEJpZ0ludChyYW5kb21VOCgpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBfQ29ubmVjdGlvbklkKHJlc3VsdCk7XG4gIH1cbiAgLyoqXG4gICAqIENvbXBhcmUgdHdvIGNvbm5lY3Rpb24gSURzIGZvciBlcXVhbGl0eS5cbiAgICovXG4gIGlzRXF1YWwob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fX2Nvbm5lY3Rpb25faWRfXyA9PSBvdGhlci5fX2Nvbm5lY3Rpb25faWRfXztcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgdHdvIGNvbm5lY3Rpb24gSURzIGFyZSBlcXVhbC5cbiAgICovXG4gIGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmlzRXF1YWwob3RoZXIpO1xuICB9XG4gIC8qKlxuICAgKiBQcmludCB0aGUgY29ubmVjdGlvbiBJRCBhcyBhIGhleGFkZWNpbWFsIHN0cmluZy5cbiAgICovXG4gIHRvSGV4U3RyaW5nKCkge1xuICAgIHJldHVybiB1MTI4VG9IZXhTdHJpbmcodGhpcy5fX2Nvbm5lY3Rpb25faWRfXyk7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnQgdGhlIGNvbm5lY3Rpb24gSUQgdG8gYSBVaW50OEFycmF5LlxuICAgKi9cbiAgdG9VaW50OEFycmF5KCkge1xuICAgIHJldHVybiB1MTI4VG9VaW50OEFycmF5KHRoaXMuX19jb25uZWN0aW9uX2lkX18pO1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZSBhIGNvbm5lY3Rpb24gSUQgZnJvbSBhIGhleGFkZWNpbWFsIHN0cmluZy5cbiAgICovXG4gIHN0YXRpYyBmcm9tU3RyaW5nKHN0cikge1xuICAgIHJldHVybiBuZXcgX0Nvbm5lY3Rpb25JZChoZXhTdHJpbmdUb1UxMjgoc3RyKSk7XG4gIH1cbiAgc3RhdGljIGZyb21TdHJpbmdPck51bGwoc3RyKSB7XG4gICAgY29uc3QgYWRkciA9IF9Db25uZWN0aW9uSWQuZnJvbVN0cmluZyhzdHIpO1xuICAgIGlmIChhZGRyLmlzWmVybygpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFkZHI7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvbGliL2lkZW50aXR5LnRzXG52YXIgSWRlbnRpdHkgPSBjbGFzcyBfSWRlbnRpdHkge1xuICBfX2lkZW50aXR5X187XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGBJZGVudGl0eWAuXG4gICAqXG4gICAqIGBkYXRhYCBjYW4gYmUgYSBoZXhhZGVjaW1hbCBzdHJpbmcgb3IgYSBgYmlnaW50YC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICB0aGlzLl9faWRlbnRpdHlfXyA9IHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiID8gaGV4U3RyaW5nVG9VMjU2KGRhdGEpIDogZGF0YTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBhbGdlYnJhaWMgdHlwZSByZXByZXNlbnRhdGlvbiBvZiB0aGUge0BsaW5rIElkZW50aXR5fSB0eXBlLlxuICAgKiBAcmV0dXJucyBUaGUgYWxnZWJyYWljIHR5cGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIHR5cGUuXG4gICAqL1xuICBzdGF0aWMgZ2V0QWxnZWJyYWljVHlwZSgpIHtcbiAgICByZXR1cm4gQWxnZWJyYWljVHlwZS5Qcm9kdWN0KHtcbiAgICAgIGVsZW1lbnRzOiBbeyBuYW1lOiBcIl9faWRlbnRpdHlfX1wiLCBhbGdlYnJhaWNUeXBlOiBBbGdlYnJhaWNUeXBlLlUyNTYgfV1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgdHdvIGlkZW50aXRpZXMgYXJlIGVxdWFsLlxuICAgKi9cbiAgaXNFcXVhbChvdGhlcikge1xuICAgIHJldHVybiB0aGlzLnRvSGV4U3RyaW5nKCkgPT09IG90aGVyLnRvSGV4U3RyaW5nKCk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIHR3byBpZGVudGl0aWVzIGFyZSBlcXVhbC5cbiAgICovXG4gIGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmlzRXF1YWwob3RoZXIpO1xuICB9XG4gIC8qKlxuICAgKiBQcmludCB0aGUgaWRlbnRpdHkgYXMgYSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gICAqL1xuICB0b0hleFN0cmluZygpIHtcbiAgICByZXR1cm4gdTI1NlRvSGV4U3RyaW5nKHRoaXMuX19pZGVudGl0eV9fKTtcbiAgfVxuICAvKipcbiAgICogQ29udmVydCB0aGUgYWRkcmVzcyB0byBhIFVpbnQ4QXJyYXkuXG4gICAqL1xuICB0b1VpbnQ4QXJyYXkoKSB7XG4gICAgcmV0dXJuIHUyNTZUb1VpbnQ4QXJyYXkodGhpcy5fX2lkZW50aXR5X18pO1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZSBhbiBJZGVudGl0eSBmcm9tIGEgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICAgKi9cbiAgc3RhdGljIGZyb21TdHJpbmcoc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBfSWRlbnRpdHkoc3RyKTtcbiAgfVxuICAvKipcbiAgICogWmVybyBpZGVudGl0eSAoMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwKVxuICAgKi9cbiAgc3RhdGljIHplcm8oKSB7XG4gICAgcmV0dXJuIG5ldyBfSWRlbnRpdHkoMG4pO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnRvSGV4U3RyaW5nKCk7XG4gIH1cbn07XG5cbi8vIHNyYy9saWIvYWxnZWJyYWljX3R5cGUudHNcbnZhciBBbGdlYnJhaWNUeXBlID0ge1xuICBSZWY6ICh2YWx1ZSkgPT4gKHsgdGFnOiBcIlJlZlwiLCB2YWx1ZSB9KSxcbiAgU3VtOiAodmFsdWUpID0+ICh7XG4gICAgdGFnOiBcIlN1bVwiLFxuICAgIHZhbHVlXG4gIH0pLFxuICBQcm9kdWN0OiAodmFsdWUpID0+ICh7XG4gICAgdGFnOiBcIlByb2R1Y3RcIixcbiAgICB2YWx1ZVxuICB9KSxcbiAgQXJyYXk6ICh2YWx1ZSkgPT4gKHtcbiAgICB0YWc6IFwiQXJyYXlcIixcbiAgICB2YWx1ZVxuICB9KSxcbiAgU3RyaW5nOiB7IHRhZzogXCJTdHJpbmdcIiB9LFxuICBCb29sOiB7IHRhZzogXCJCb29sXCIgfSxcbiAgSTg6IHsgdGFnOiBcIkk4XCIgfSxcbiAgVTg6IHsgdGFnOiBcIlU4XCIgfSxcbiAgSTE2OiB7IHRhZzogXCJJMTZcIiB9LFxuICBVMTY6IHsgdGFnOiBcIlUxNlwiIH0sXG4gIEkzMjogeyB0YWc6IFwiSTMyXCIgfSxcbiAgVTMyOiB7IHRhZzogXCJVMzJcIiB9LFxuICBJNjQ6IHsgdGFnOiBcIkk2NFwiIH0sXG4gIFU2NDogeyB0YWc6IFwiVTY0XCIgfSxcbiAgSTEyODogeyB0YWc6IFwiSTEyOFwiIH0sXG4gIFUxMjg6IHsgdGFnOiBcIlUxMjhcIiB9LFxuICBJMjU2OiB7IHRhZzogXCJJMjU2XCIgfSxcbiAgVTI1NjogeyB0YWc6IFwiVTI1NlwiIH0sXG4gIEYzMjogeyB0YWc6IFwiRjMyXCIgfSxcbiAgRjY0OiB7IHRhZzogXCJGNjRcIiB9LFxuICBzZXJpYWxpemVWYWx1ZSh3cml0ZXIsIHR5LCB2YWx1ZSwgdHlwZXNwYWNlKSB7XG4gICAgaWYgKHR5LnRhZyA9PT0gXCJSZWZcIikge1xuICAgICAgaWYgKCF0eXBlc3BhY2UpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBzZXJpYWxpemUgcmVmcyB3aXRob3V0IGEgdHlwZXNwYWNlXCIpO1xuICAgICAgd2hpbGUgKHR5LnRhZyA9PT0gXCJSZWZcIikgdHkgPSB0eXBlc3BhY2UudHlwZXNbdHkudmFsdWVdO1xuICAgIH1cbiAgICBzd2l0Y2ggKHR5LnRhZykge1xuICAgICAgY2FzZSBcIlByb2R1Y3RcIjpcbiAgICAgICAgUHJvZHVjdFR5cGUuc2VyaWFsaXplVmFsdWUod3JpdGVyLCB0eS52YWx1ZSwgdmFsdWUsIHR5cGVzcGFjZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIlN1bVwiOlxuICAgICAgICBTdW1UeXBlLnNlcmlhbGl6ZVZhbHVlKHdyaXRlciwgdHkudmFsdWUsIHZhbHVlLCB0eXBlc3BhY2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJBcnJheVwiOlxuICAgICAgICBpZiAodHkudmFsdWUudGFnID09PSBcIlU4XCIpIHtcbiAgICAgICAgICB3cml0ZXIud3JpdGVVSW50OEFycmF5KHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBlbGVtVHlwZSA9IHR5LnZhbHVlO1xuICAgICAgICAgIHdyaXRlci53cml0ZVUzMih2YWx1ZS5sZW5ndGgpO1xuICAgICAgICAgIGZvciAoY29uc3QgZWxlbSBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgQWxnZWJyYWljVHlwZS5zZXJpYWxpemVWYWx1ZSh3cml0ZXIsIGVsZW1UeXBlLCBlbGVtLCB0eXBlc3BhY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJCb29sXCI6XG4gICAgICAgIHdyaXRlci53cml0ZUJvb2wodmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJJOFwiOlxuICAgICAgICB3cml0ZXIud3JpdGVJOCh2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIlU4XCI6XG4gICAgICAgIHdyaXRlci53cml0ZVU4KHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiSTE2XCI6XG4gICAgICAgIHdyaXRlci53cml0ZUkxNih2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIlUxNlwiOlxuICAgICAgICB3cml0ZXIud3JpdGVVMTYodmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJJMzJcIjpcbiAgICAgICAgd3JpdGVyLndyaXRlSTMyKHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiVTMyXCI6XG4gICAgICAgIHdyaXRlci53cml0ZVUzMih2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkk2NFwiOlxuICAgICAgICB3cml0ZXIud3JpdGVJNjQodmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJVNjRcIjpcbiAgICAgICAgd3JpdGVyLndyaXRlVTY0KHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiSTEyOFwiOlxuICAgICAgICB3cml0ZXIud3JpdGVJMTI4KHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiVTEyOFwiOlxuICAgICAgICB3cml0ZXIud3JpdGVVMTI4KHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiSTI1NlwiOlxuICAgICAgICB3cml0ZXIud3JpdGVJMjU2KHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiVTI1NlwiOlxuICAgICAgICB3cml0ZXIud3JpdGVVMjU2KHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiRjMyXCI6XG4gICAgICAgIHdyaXRlci53cml0ZUYzMih2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkY2NFwiOlxuICAgICAgICB3cml0ZXIud3JpdGVGNjQodmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJTdHJpbmdcIjpcbiAgICAgICAgd3JpdGVyLndyaXRlU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9LFxuICBkZXNlcmlhbGl6ZVZhbHVlOiBmdW5jdGlvbihyZWFkZXIsIHR5LCB0eXBlc3BhY2UpIHtcbiAgICBpZiAodHkudGFnID09PSBcIlJlZlwiKSB7XG4gICAgICBpZiAoIXR5cGVzcGFjZSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGRlc2VyaWFsaXplIHJlZnMgd2l0aG91dCBhIHR5cGVzcGFjZVwiKTtcbiAgICAgIHdoaWxlICh0eS50YWcgPT09IFwiUmVmXCIpIHR5ID0gdHlwZXNwYWNlLnR5cGVzW3R5LnZhbHVlXTtcbiAgICB9XG4gICAgc3dpdGNoICh0eS50YWcpIHtcbiAgICAgIGNhc2UgXCJQcm9kdWN0XCI6XG4gICAgICAgIHJldHVybiBQcm9kdWN0VHlwZS5kZXNlcmlhbGl6ZVZhbHVlKHJlYWRlciwgdHkudmFsdWUsIHR5cGVzcGFjZSk7XG4gICAgICBjYXNlIFwiU3VtXCI6XG4gICAgICAgIHJldHVybiBTdW1UeXBlLmRlc2VyaWFsaXplVmFsdWUocmVhZGVyLCB0eS52YWx1ZSwgdHlwZXNwYWNlKTtcbiAgICAgIGNhc2UgXCJBcnJheVwiOlxuICAgICAgICBpZiAodHkudmFsdWUudGFnID09PSBcIlU4XCIpIHtcbiAgICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWRVSW50OEFycmF5KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgZWxlbVR5cGUgPSB0eS52YWx1ZTtcbiAgICAgICAgICBjb25zdCBsZW5ndGggPSByZWFkZXIucmVhZFUzMigpO1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgICAgICBBbGdlYnJhaWNUeXBlLmRlc2VyaWFsaXplVmFsdWUocmVhZGVyLCBlbGVtVHlwZSwgdHlwZXNwYWNlKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgY2FzZSBcIkJvb2xcIjpcbiAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkQm9vbCgpO1xuICAgICAgY2FzZSBcIkk4XCI6XG4gICAgICAgIHJldHVybiByZWFkZXIucmVhZEk4KCk7XG4gICAgICBjYXNlIFwiVThcIjpcbiAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkVTgoKTtcbiAgICAgIGNhc2UgXCJJMTZcIjpcbiAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkSTE2KCk7XG4gICAgICBjYXNlIFwiVTE2XCI6XG4gICAgICAgIHJldHVybiByZWFkZXIucmVhZFUxNigpO1xuICAgICAgY2FzZSBcIkkzMlwiOlxuICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWRJMzIoKTtcbiAgICAgIGNhc2UgXCJVMzJcIjpcbiAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkVTMyKCk7XG4gICAgICBjYXNlIFwiSTY0XCI6XG4gICAgICAgIHJldHVybiByZWFkZXIucmVhZEk2NCgpO1xuICAgICAgY2FzZSBcIlU2NFwiOlxuICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWRVNjQoKTtcbiAgICAgIGNhc2UgXCJJMTI4XCI6XG4gICAgICAgIHJldHVybiByZWFkZXIucmVhZEkxMjgoKTtcbiAgICAgIGNhc2UgXCJVMTI4XCI6XG4gICAgICAgIHJldHVybiByZWFkZXIucmVhZFUxMjgoKTtcbiAgICAgIGNhc2UgXCJJMjU2XCI6XG4gICAgICAgIHJldHVybiByZWFkZXIucmVhZEkyNTYoKTtcbiAgICAgIGNhc2UgXCJVMjU2XCI6XG4gICAgICAgIHJldHVybiByZWFkZXIucmVhZFUyNTYoKTtcbiAgICAgIGNhc2UgXCJGMzJcIjpcbiAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkRjMyKCk7XG4gICAgICBjYXNlIFwiRjY0XCI6XG4gICAgICAgIHJldHVybiByZWFkZXIucmVhZEY2NCgpO1xuICAgICAgY2FzZSBcIlN0cmluZ1wiOlxuICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWRTdHJpbmcoKTtcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgdmFsdWUgb2YgdGhlIGFsZ2VicmFpYyB0eXBlIGludG8gc29tZXRoaW5nIHRoYXQgY2FuIGJlIHVzZWQgYXMgYSBrZXkgaW4gYSBtYXAuXG4gICAqIFRoZXJlIGFyZSBubyBndWFyYW50ZWVzIGFib3V0IGJlaW5nIGFibGUgdG8gb3JkZXIgaXQuXG4gICAqIFRoaXMgaXMgb25seSBndWFyYW50ZWVkIHRvIGJlIGNvbXBhcmFibGUgdG8gb3RoZXIgdmFsdWVzIG9mIHRoZSBzYW1lIHR5cGUuXG4gICAqIEBwYXJhbSB2YWx1ZSBBIHZhbHVlIG9mIHRoZSBhbGdlYnJhaWMgdHlwZVxuICAgKiBAcmV0dXJucyBTb21ldGhpbmcgdGhhdCBjYW4gYmUgdXNlZCBhcyBhIGtleSBpbiBhIG1hcC5cbiAgICovXG4gIGludG9NYXBLZXk6IGZ1bmN0aW9uKHR5LCB2YWx1ZSkge1xuICAgIHN3aXRjaCAodHkudGFnKSB7XG4gICAgICBjYXNlIFwiVThcIjpcbiAgICAgIGNhc2UgXCJVMTZcIjpcbiAgICAgIGNhc2UgXCJVMzJcIjpcbiAgICAgIGNhc2UgXCJVNjRcIjpcbiAgICAgIGNhc2UgXCJVMTI4XCI6XG4gICAgICBjYXNlIFwiVTI1NlwiOlxuICAgICAgY2FzZSBcIkk4XCI6XG4gICAgICBjYXNlIFwiSTE2XCI6XG4gICAgICBjYXNlIFwiSTMyXCI6XG4gICAgICBjYXNlIFwiSTY0XCI6XG4gICAgICBjYXNlIFwiSTEyOFwiOlxuICAgICAgY2FzZSBcIkkyNTZcIjpcbiAgICAgIGNhc2UgXCJGMzJcIjpcbiAgICAgIGNhc2UgXCJGNjRcIjpcbiAgICAgIGNhc2UgXCJTdHJpbmdcIjpcbiAgICAgIGNhc2UgXCJCb29sXCI6XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIGNhc2UgXCJQcm9kdWN0XCI6XG4gICAgICAgIHJldHVybiBQcm9kdWN0VHlwZS5pbnRvTWFwS2V5KHR5LnZhbHVlLCB2YWx1ZSk7XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIGNvbnN0IHdyaXRlciA9IG5ldyBCaW5hcnlXcml0ZXIoMTApO1xuICAgICAgICBBbGdlYnJhaWNUeXBlLnNlcmlhbGl6ZVZhbHVlKHdyaXRlciwgdHksIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlci50b0Jhc2U2NCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbnZhciBQcm9kdWN0VHlwZSA9IHtcbiAgc2VyaWFsaXplVmFsdWUod3JpdGVyLCB0eSwgdmFsdWUsIHR5cGVzcGFjZSkge1xuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiB0eS5lbGVtZW50cykge1xuICAgICAgQWxnZWJyYWljVHlwZS5zZXJpYWxpemVWYWx1ZShcbiAgICAgICAgd3JpdGVyLFxuICAgICAgICBlbGVtZW50LmFsZ2VicmFpY1R5cGUsXG4gICAgICAgIHZhbHVlW2VsZW1lbnQubmFtZV0sXG4gICAgICAgIHR5cGVzcGFjZVxuICAgICAgKTtcbiAgICB9XG4gIH0sXG4gIGRlc2VyaWFsaXplVmFsdWUocmVhZGVyLCB0eSwgdHlwZXNwYWNlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgaWYgKHR5LmVsZW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgaWYgKHR5LmVsZW1lbnRzWzBdLm5hbWUgPT09IFwiX190aW1lX2R1cmF0aW9uX21pY3Jvc19fXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUaW1lRHVyYXRpb24ocmVhZGVyLnJlYWRJNjQoKSk7XG4gICAgICB9XG4gICAgICBpZiAodHkuZWxlbWVudHNbMF0ubmFtZSA9PT0gXCJfX3RpbWVzdGFtcF9taWNyb3Nfc2luY2VfdW5peF9lcG9jaF9fXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUaW1lc3RhbXAocmVhZGVyLnJlYWRJNjQoKSk7XG4gICAgICB9XG4gICAgICBpZiAodHkuZWxlbWVudHNbMF0ubmFtZSA9PT0gXCJfX2lkZW50aXR5X19cIikge1xuICAgICAgICByZXR1cm4gbmV3IElkZW50aXR5KHJlYWRlci5yZWFkVTI1NigpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eS5lbGVtZW50c1swXS5uYW1lID09PSBcIl9fY29ubmVjdGlvbl9pZF9fXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb25uZWN0aW9uSWQocmVhZGVyLnJlYWRVMTI4KCkpO1xuICAgICAgfVxuICAgICAgaWYgKHR5LmVsZW1lbnRzWzBdLm5hbWUgPT09IFwiX191dWlkX19cIikge1xuICAgICAgICByZXR1cm4gbmV3IFV1aWQocmVhZGVyLnJlYWRVMTI4KCkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdHkuZWxlbWVudHMpIHtcbiAgICAgIHJlc3VsdFtlbGVtZW50Lm5hbWVdID0gQWxnZWJyYWljVHlwZS5kZXNlcmlhbGl6ZVZhbHVlKFxuICAgICAgICByZWFkZXIsXG4gICAgICAgIGVsZW1lbnQuYWxnZWJyYWljVHlwZSxcbiAgICAgICAgdHlwZXNwYWNlXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuICBpbnRvTWFwS2V5KHR5LCB2YWx1ZSkge1xuICAgIGlmICh0eS5lbGVtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGlmICh0eS5lbGVtZW50c1swXS5uYW1lID09PSBcIl9fdGltZV9kdXJhdGlvbl9taWNyb3NfX1wiKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5fX3RpbWVfZHVyYXRpb25fbWljcm9zX187XG4gICAgICB9XG4gICAgICBpZiAodHkuZWxlbWVudHNbMF0ubmFtZSA9PT0gXCJfX3RpbWVzdGFtcF9taWNyb3Nfc2luY2VfdW5peF9lcG9jaF9fXCIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLl9fdGltZXN0YW1wX21pY3Jvc19zaW5jZV91bml4X2Vwb2NoX187XG4gICAgICB9XG4gICAgICBpZiAodHkuZWxlbWVudHNbMF0ubmFtZSA9PT0gXCJfX2lkZW50aXR5X19cIikge1xuICAgICAgICByZXR1cm4gdmFsdWUuX19pZGVudGl0eV9fO1xuICAgICAgfVxuICAgICAgaWYgKHR5LmVsZW1lbnRzWzBdLm5hbWUgPT09IFwiX19jb25uZWN0aW9uX2lkX19cIikge1xuICAgICAgICByZXR1cm4gdmFsdWUuX19jb25uZWN0aW9uX2lkX187XG4gICAgICB9XG4gICAgICBpZiAodHkuZWxlbWVudHNbMF0ubmFtZSA9PT0gXCJfX3V1aWRfX1wiKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5fX3V1aWRfXztcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgd3JpdGVyID0gbmV3IEJpbmFyeVdyaXRlcigxMCk7XG4gICAgQWxnZWJyYWljVHlwZS5zZXJpYWxpemVWYWx1ZSh3cml0ZXIsIEFsZ2VicmFpY1R5cGUuUHJvZHVjdCh0eSksIHZhbHVlKTtcbiAgICByZXR1cm4gd3JpdGVyLnRvQmFzZTY0KCk7XG4gIH1cbn07XG52YXIgU3VtVHlwZSA9IHtcbiAgc2VyaWFsaXplVmFsdWU6IGZ1bmN0aW9uKHdyaXRlciwgdHksIHZhbHVlLCB0eXBlc3BhY2UpIHtcbiAgICBpZiAodHkudmFyaWFudHMubGVuZ3RoID09IDIgJiYgdHkudmFyaWFudHNbMF0ubmFtZSA9PT0gXCJzb21lXCIgJiYgdHkudmFyaWFudHNbMV0ubmFtZSA9PT0gXCJub25lXCIpIHtcbiAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHdyaXRlci53cml0ZUJ5dGUoMCk7XG4gICAgICAgIEFsZ2VicmFpY1R5cGUuc2VyaWFsaXplVmFsdWUoXG4gICAgICAgICAgd3JpdGVyLFxuICAgICAgICAgIHR5LnZhcmlhbnRzWzBdLmFsZ2VicmFpY1R5cGUsXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgdHlwZXNwYWNlXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3cml0ZXIud3JpdGVCeXRlKDEpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHkudmFyaWFudHMubGVuZ3RoID09IDIgJiYgdHkudmFyaWFudHNbMF0ubmFtZSA9PT0gXCJva1wiICYmIHR5LnZhcmlhbnRzWzFdLm5hbWUgPT09IFwiZXJyXCIpIHtcbiAgICAgIGxldCB2YXJpYW50TmFtZTtcbiAgICAgIGxldCBpbm5lclZhbHVlO1xuICAgICAgbGV0IGluZGV4O1xuICAgICAgaWYgKFwib2tcIiBpbiB2YWx1ZSkge1xuICAgICAgICB2YXJpYW50TmFtZSA9IFwib2tcIjtcbiAgICAgICAgaW5uZXJWYWx1ZSA9IHZhbHVlLm9rO1xuICAgICAgICBpbmRleCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXJpYW50TmFtZSA9IFwiZXJyXCI7XG4gICAgICAgIGlubmVyVmFsdWUgPSB2YWx1ZS5lcnI7XG4gICAgICAgIGluZGV4ID0gMTtcbiAgICAgIH1cbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgdGhyb3cgYFJlc3VsdCBzZXJpYWxpemF0aW9uIGVycm9yOiB2YXJpYW50ICcke3ZhcmlhbnROYW1lfScgbm90IGZvdW5kIGluICR7SlNPTi5zdHJpbmdpZnkodHkpfWA7XG4gICAgICB9XG4gICAgICB3cml0ZXIud3JpdGVVOChpbmRleCk7XG4gICAgICBBbGdlYnJhaWNUeXBlLnNlcmlhbGl6ZVZhbHVlKFxuICAgICAgICB3cml0ZXIsXG4gICAgICAgIHR5LnZhcmlhbnRzW2luZGV4XS5hbGdlYnJhaWNUeXBlLFxuICAgICAgICBpbm5lclZhbHVlLFxuICAgICAgICB0eXBlc3BhY2VcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHZhcmlhbnQgPSB2YWx1ZVtcInRhZ1wiXTtcbiAgICAgIGNvbnN0IGluZGV4ID0gdHkudmFyaWFudHMuZmluZEluZGV4KCh2KSA9PiB2Lm5hbWUgPT09IHZhcmlhbnQpO1xuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICB0aHJvdyBgQ2FuJ3Qgc2VyaWFsaXplIGEgc3VtIHR5cGUsIGNvdWxkbid0IGZpbmQgJHt2YWx1ZS50YWd9IHRhZyAke0pTT04uc3RyaW5naWZ5KHZhbHVlKX0gaW4gdmFyaWFudHMgJHtKU09OLnN0cmluZ2lmeSh0eSl9YDtcbiAgICAgIH1cbiAgICAgIHdyaXRlci53cml0ZVU4KGluZGV4KTtcbiAgICAgIEFsZ2VicmFpY1R5cGUuc2VyaWFsaXplVmFsdWUoXG4gICAgICAgIHdyaXRlcixcbiAgICAgICAgdHkudmFyaWFudHNbaW5kZXhdLmFsZ2VicmFpY1R5cGUsXG4gICAgICAgIHZhbHVlW1widmFsdWVcIl0sXG4gICAgICAgIHR5cGVzcGFjZVxuICAgICAgKTtcbiAgICB9XG4gIH0sXG4gIGRlc2VyaWFsaXplVmFsdWU6IGZ1bmN0aW9uKHJlYWRlciwgdHksIHR5cGVzcGFjZSkge1xuICAgIGNvbnN0IHRhZyA9IHJlYWRlci5yZWFkVTgoKTtcbiAgICBpZiAodHkudmFyaWFudHMubGVuZ3RoID09IDIgJiYgdHkudmFyaWFudHNbMF0ubmFtZSA9PT0gXCJzb21lXCIgJiYgdHkudmFyaWFudHNbMV0ubmFtZSA9PT0gXCJub25lXCIpIHtcbiAgICAgIGlmICh0YWcgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEFsZ2VicmFpY1R5cGUuZGVzZXJpYWxpemVWYWx1ZShcbiAgICAgICAgICByZWFkZXIsXG4gICAgICAgICAgdHkudmFyaWFudHNbMF0uYWxnZWJyYWljVHlwZSxcbiAgICAgICAgICB0eXBlc3BhY2VcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAodGFnID09PSAxKSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBgQ2FuJ3QgZGVzZXJpYWxpemUgYW4gb3B0aW9uIHR5cGUsIGNvdWxkbid0IGZpbmQgJHt0YWd9IHRhZ2A7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eS52YXJpYW50cy5sZW5ndGggPT0gMiAmJiB0eS52YXJpYW50c1swXS5uYW1lID09PSBcIm9rXCIgJiYgdHkudmFyaWFudHNbMV0ubmFtZSA9PT0gXCJlcnJcIikge1xuICAgICAgaWYgKHRhZyA9PT0gMCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IEFsZ2VicmFpY1R5cGUuZGVzZXJpYWxpemVWYWx1ZShcbiAgICAgICAgICByZWFkZXIsXG4gICAgICAgICAgdHkudmFyaWFudHNbMF0uYWxnZWJyYWljVHlwZSxcbiAgICAgICAgICB0eXBlc3BhY2VcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHsgb2s6IHZhbHVlIH07XG4gICAgICB9IGVsc2UgaWYgKHRhZyA9PT0gMSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IEFsZ2VicmFpY1R5cGUuZGVzZXJpYWxpemVWYWx1ZShcbiAgICAgICAgICByZWFkZXIsXG4gICAgICAgICAgdHkudmFyaWFudHNbMV0uYWxnZWJyYWljVHlwZSxcbiAgICAgICAgICB0eXBlc3BhY2VcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHsgZXJyOiB2YWx1ZSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgYENhbid0IGRlc2VyaWFsaXplIGEgcmVzdWx0IHR5cGUsIGNvdWxkbid0IGZpbmQgJHt0YWd9IHRhZ2A7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHZhcmlhbnQgPSB0eS52YXJpYW50c1t0YWddO1xuICAgICAgY29uc3QgdmFsdWUgPSBBbGdlYnJhaWNUeXBlLmRlc2VyaWFsaXplVmFsdWUoXG4gICAgICAgIHJlYWRlcixcbiAgICAgICAgdmFyaWFudC5hbGdlYnJhaWNUeXBlLFxuICAgICAgICB0eXBlc3BhY2VcbiAgICAgICk7XG4gICAgICByZXR1cm4geyB0YWc6IHZhcmlhbnQubmFtZSwgdmFsdWUgfTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9saWIvb3B0aW9uLnRzXG52YXIgT3B0aW9uID0ge1xuICBnZXRBbGdlYnJhaWNUeXBlKGlubmVyVHlwZSkge1xuICAgIHJldHVybiBBbGdlYnJhaWNUeXBlLlN1bSh7XG4gICAgICB2YXJpYW50czogW1xuICAgICAgICB7IG5hbWU6IFwic29tZVwiLCBhbGdlYnJhaWNUeXBlOiBpbm5lclR5cGUgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwibm9uZVwiLFxuICAgICAgICAgIGFsZ2VicmFpY1R5cGU6IEFsZ2VicmFpY1R5cGUuUHJvZHVjdCh7IGVsZW1lbnRzOiBbXSB9KVxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIHNyYy9saWIvcmVzdWx0LnRzXG52YXIgUmVzdWx0ID0ge1xuICBnZXRBbGdlYnJhaWNUeXBlKG9rVHlwZSwgZXJyVHlwZSkge1xuICAgIHJldHVybiBBbGdlYnJhaWNUeXBlLlN1bSh7XG4gICAgICB2YXJpYW50czogW1xuICAgICAgICB7IG5hbWU6IFwib2tcIiwgYWxnZWJyYWljVHlwZTogb2tUeXBlIH0sXG4gICAgICAgIHsgbmFtZTogXCJlcnJcIiwgYWxnZWJyYWljVHlwZTogZXJyVHlwZSB9XG4gICAgICBdXG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIHNyYy9saWIvc2NoZWR1bGVfYXQudHNcbnZhciBTY2hlZHVsZUF0ID0ge1xuICBpbnRlcnZhbCh2YWx1ZSkge1xuICAgIHJldHVybiBJbnRlcnZhbCh2YWx1ZSk7XG4gIH0sXG4gIHRpbWUodmFsdWUpIHtcbiAgICByZXR1cm4gVGltZSh2YWx1ZSk7XG4gIH0sXG4gIGdldEFsZ2VicmFpY1R5cGUoKSB7XG4gICAgcmV0dXJuIEFsZ2VicmFpY1R5cGUuU3VtKHtcbiAgICAgIHZhcmlhbnRzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcIkludGVydmFsXCIsXG4gICAgICAgICAgYWxnZWJyYWljVHlwZTogVGltZUR1cmF0aW9uLmdldEFsZ2VicmFpY1R5cGUoKVxuICAgICAgICB9LFxuICAgICAgICB7IG5hbWU6IFwiVGltZVwiLCBhbGdlYnJhaWNUeXBlOiBUaW1lc3RhbXAuZ2V0QWxnZWJyYWljVHlwZSgpIH1cbiAgICAgIF1cbiAgICB9KTtcbiAgfSxcbiAgaXNTY2hlZHVsZUF0KGFsZ2VicmFpY1R5cGUpIHtcbiAgICBpZiAoYWxnZWJyYWljVHlwZS50YWcgIT09IFwiU3VtXCIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgdmFyaWFudHMgPSBhbGdlYnJhaWNUeXBlLnZhbHVlLnZhcmlhbnRzO1xuICAgIGlmICh2YXJpYW50cy5sZW5ndGggIT09IDIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgaW50ZXJ2YWxWYXJpYW50ID0gdmFyaWFudHMuZmluZCgodikgPT4gdi5uYW1lID09PSBcIkludGVydmFsXCIpO1xuICAgIGNvbnN0IHRpbWVWYXJpYW50ID0gdmFyaWFudHMuZmluZCgodikgPT4gdi5uYW1lID09PSBcIlRpbWVcIik7XG4gICAgaWYgKCFpbnRlcnZhbFZhcmlhbnQgfHwgIXRpbWVWYXJpYW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBUaW1lRHVyYXRpb24uaXNUaW1lRHVyYXRpb24oaW50ZXJ2YWxWYXJpYW50LmFsZ2VicmFpY1R5cGUpICYmIFRpbWVzdGFtcC5pc1RpbWVzdGFtcCh0aW1lVmFyaWFudC5hbGdlYnJhaWNUeXBlKTtcbiAgfVxufTtcbnZhciBJbnRlcnZhbCA9IChtaWNyb3MpID0+ICh7XG4gIHRhZzogXCJJbnRlcnZhbFwiLFxuICB2YWx1ZTogbmV3IFRpbWVEdXJhdGlvbihtaWNyb3MpXG59KTtcbnZhciBUaW1lID0gKG1pY3Jvc1NpbmNlVW5peEVwb2NoKSA9PiAoe1xuICB0YWc6IFwiVGltZVwiLFxuICB2YWx1ZTogbmV3IFRpbWVzdGFtcChtaWNyb3NTaW5jZVVuaXhFcG9jaClcbn0pO1xudmFyIHNjaGVkdWxlX2F0X2RlZmF1bHQgPSBTY2hlZHVsZUF0O1xuXG4vLyBzcmMvbGliL3R5cGVfdXRpbC50c1xuZnVuY3Rpb24gc2V0KHgsIHQyKSB7XG4gIHJldHVybiB7IC4uLngsIC4uLnQyIH07XG59XG5cbi8vIHNyYy9saWIvdHlwZV9idWlsZGVycy50c1xudmFyIFR5cGVCdWlsZGVyID0gY2xhc3Mge1xuICAvKipcbiAgICogVGhlIFR5cGVTY3JpcHQgcGhhbnRvbSB0eXBlLiBUaGlzIGlzIG5vdCBzdG9yZWQgYXQgcnVudGltZSxcbiAgICogYnV0IGlzIHZpc2libGUgdG8gdGhlIGNvbXBpbGVyXG4gICAqL1xuICB0eXBlO1xuICAvKipcbiAgICogVGhlIFNwYWNldGltZURCIGFsZ2VicmFpYyB0eXBlIChydW7igJF0aW1lIHZhbHVlKS4gSW4gYWRkaXRpb24gdG8gc3RvcmluZ1xuICAgKiB0aGUgcnVudGltZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgYEFsZ2VicmFpY1R5cGVgLCBpdCBhbHNvIGNhcHR1cmVzXG4gICAqIHRoZSBUeXBlU2NyaXB0IHR5cGUgaW5mb3JtYXRpb24gb2YgdGhlIGBBbGdlYnJhaWNUeXBlYC4gVGhhdCBpcyB0byBzYXlcbiAgICogdGhlIHZhbHVlIGlzIG5vdCBtZXJlbHkgYW4gYEFsZ2VicmFpY1R5cGVgLCBidXQgaXMgY29uc3RydWN0ZWQgdG8gYmVcbiAgICogdGhlIGNvcnJlc3BvbmRpbmcgY29uY3JldGUgYEFsZ2VicmFpY1R5cGVgIGZvciB0aGUgVHlwZVNjcmlwdCB0eXBlIGBUeXBlYC5cbiAgICpcbiAgICogZS5nLiBgc3RyaW5nYCBjb3JyZXNwb25kcyB0byBgQWxnZWJyYWljVHlwZS5TdHJpbmdgXG4gICAqL1xuICBhbGdlYnJhaWNUeXBlO1xuICBjb25zdHJ1Y3RvcihhbGdlYnJhaWNUeXBlKSB7XG4gICAgdGhpcy5hbGdlYnJhaWNUeXBlID0gYWxnZWJyYWljVHlwZTtcbiAgfVxuICBvcHRpb25hbCgpIHtcbiAgICByZXR1cm4gbmV3IE9wdGlvbkJ1aWxkZXIodGhpcyk7XG4gIH1cbiAgc2VyaWFsaXplKHdyaXRlciwgdmFsdWUpIHtcbiAgICBBbGdlYnJhaWNUeXBlLnNlcmlhbGl6ZVZhbHVlKHdyaXRlciwgdGhpcy5hbGdlYnJhaWNUeXBlLCB2YWx1ZSk7XG4gIH1cbiAgZGVzZXJpYWxpemUocmVhZGVyKSB7XG4gICAgcmV0dXJuIEFsZ2VicmFpY1R5cGUuZGVzZXJpYWxpemVWYWx1ZShyZWFkZXIsIHRoaXMuYWxnZWJyYWljVHlwZSk7XG4gIH1cbn07XG52YXIgVThCdWlsZGVyID0gY2xhc3MgZXh0ZW5kcyBUeXBlQnVpbGRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKEFsZ2VicmFpY1R5cGUuVTgpO1xuICB9XG4gIGluZGV4KGFsZ29yaXRobSA9IFwiYnRyZWVcIikge1xuICAgIHJldHVybiBuZXcgVThDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaW5kZXhUeXBlOiBhbGdvcml0aG0gfSlcbiAgICApO1xuICB9XG4gIHVuaXF1ZSgpIHtcbiAgICByZXR1cm4gbmV3IFU4Q29sdW1uQnVpbGRlcih0aGlzLCBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzVW5pcXVlOiB0cnVlIH0pKTtcbiAgfVxuICBwcmltYXJ5S2V5KCkge1xuICAgIHJldHVybiBuZXcgVThDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNQcmltYXJ5S2V5OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBhdXRvSW5jKCkge1xuICAgIHJldHVybiBuZXcgVThDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNBdXRvSW5jcmVtZW50OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBVOENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBkZWZhdWx0VmFsdWU6IHZhbHVlIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IFU4Q29sdW1uQnVpbGRlcih0aGlzLCBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IG5hbWUgfSkpO1xuICB9XG59O1xudmFyIFUxNkJ1aWxkZXIgPSBjbGFzcyBleHRlbmRzIFR5cGVCdWlsZGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoQWxnZWJyYWljVHlwZS5VMTYpO1xuICB9XG4gIGluZGV4KGFsZ29yaXRobSA9IFwiYnRyZWVcIikge1xuICAgIHJldHVybiBuZXcgVTE2Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGluZGV4VHlwZTogYWxnb3JpdGhtIH0pXG4gICAgKTtcbiAgfVxuICB1bmlxdWUoKSB7XG4gICAgcmV0dXJuIG5ldyBVMTZDb2x1bW5CdWlsZGVyKHRoaXMsIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNVbmlxdWU6IHRydWUgfSkpO1xuICB9XG4gIHByaW1hcnlLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBVMTZDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNQcmltYXJ5S2V5OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBhdXRvSW5jKCkge1xuICAgIHJldHVybiBuZXcgVTE2Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzQXV0b0luY3JlbWVudDogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgVTE2Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGRlZmF1bHRWYWx1ZTogdmFsdWUgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgVTE2Q29sdW1uQnVpbGRlcih0aGlzLCBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IG5hbWUgfSkpO1xuICB9XG59O1xudmFyIFUzMkJ1aWxkZXIgPSBjbGFzcyBleHRlbmRzIFR5cGVCdWlsZGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoQWxnZWJyYWljVHlwZS5VMzIpO1xuICB9XG4gIGluZGV4KGFsZ29yaXRobSA9IFwiYnRyZWVcIikge1xuICAgIHJldHVybiBuZXcgVTMyQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGluZGV4VHlwZTogYWxnb3JpdGhtIH0pXG4gICAgKTtcbiAgfVxuICB1bmlxdWUoKSB7XG4gICAgcmV0dXJuIG5ldyBVMzJDb2x1bW5CdWlsZGVyKHRoaXMsIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNVbmlxdWU6IHRydWUgfSkpO1xuICB9XG4gIHByaW1hcnlLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBVMzJDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNQcmltYXJ5S2V5OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBhdXRvSW5jKCkge1xuICAgIHJldHVybiBuZXcgVTMyQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzQXV0b0luY3JlbWVudDogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgVTMyQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGRlZmF1bHRWYWx1ZTogdmFsdWUgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgVTMyQ29sdW1uQnVpbGRlcih0aGlzLCBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IG5hbWUgfSkpO1xuICB9XG59O1xudmFyIFU2NEJ1aWxkZXIgPSBjbGFzcyBleHRlbmRzIFR5cGVCdWlsZGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoQWxnZWJyYWljVHlwZS5VNjQpO1xuICB9XG4gIGluZGV4KGFsZ29yaXRobSA9IFwiYnRyZWVcIikge1xuICAgIHJldHVybiBuZXcgVTY0Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGluZGV4VHlwZTogYWxnb3JpdGhtIH0pXG4gICAgKTtcbiAgfVxuICB1bmlxdWUoKSB7XG4gICAgcmV0dXJuIG5ldyBVNjRDb2x1bW5CdWlsZGVyKHRoaXMsIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNVbmlxdWU6IHRydWUgfSkpO1xuICB9XG4gIHByaW1hcnlLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBVNjRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNQcmltYXJ5S2V5OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBhdXRvSW5jKCkge1xuICAgIHJldHVybiBuZXcgVTY0Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzQXV0b0luY3JlbWVudDogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgVTY0Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGRlZmF1bHRWYWx1ZTogdmFsdWUgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgVTY0Q29sdW1uQnVpbGRlcih0aGlzLCBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IG5hbWUgfSkpO1xuICB9XG59O1xudmFyIFUxMjhCdWlsZGVyID0gY2xhc3MgZXh0ZW5kcyBUeXBlQnVpbGRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKEFsZ2VicmFpY1R5cGUuVTEyOCk7XG4gIH1cbiAgaW5kZXgoYWxnb3JpdGhtID0gXCJidHJlZVwiKSB7XG4gICAgcmV0dXJuIG5ldyBVMTI4Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGluZGV4VHlwZTogYWxnb3JpdGhtIH0pXG4gICAgKTtcbiAgfVxuICB1bmlxdWUoKSB7XG4gICAgcmV0dXJuIG5ldyBVMTI4Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzVW5pcXVlOiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBwcmltYXJ5S2V5KCkge1xuICAgIHJldHVybiBuZXcgVTEyOENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc1ByaW1hcnlLZXk6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGF1dG9JbmMoKSB7XG4gICAgcmV0dXJuIG5ldyBVMTI4Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzQXV0b0luY3JlbWVudDogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgVTEyOENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBkZWZhdWx0VmFsdWU6IHZhbHVlIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IFUxMjhDb2x1bW5CdWlsZGVyKHRoaXMsIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgbmFtZSB9KSk7XG4gIH1cbn07XG52YXIgVTI1NkJ1aWxkZXIgPSBjbGFzcyBleHRlbmRzIFR5cGVCdWlsZGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoQWxnZWJyYWljVHlwZS5VMjU2KTtcbiAgfVxuICBpbmRleChhbGdvcml0aG0gPSBcImJ0cmVlXCIpIHtcbiAgICByZXR1cm4gbmV3IFUyNTZDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaW5kZXhUeXBlOiBhbGdvcml0aG0gfSlcbiAgICApO1xuICB9XG4gIHVuaXF1ZSgpIHtcbiAgICByZXR1cm4gbmV3IFUyNTZDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNVbmlxdWU6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIHByaW1hcnlLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBVMjU2Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzUHJpbWFyeUtleTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgYXV0b0luYygpIHtcbiAgICByZXR1cm4gbmV3IFUyNTZDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNBdXRvSW5jcmVtZW50OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBVMjU2Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGRlZmF1bHRWYWx1ZTogdmFsdWUgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgVTI1NkNvbHVtbkJ1aWxkZXIodGhpcywgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBuYW1lIH0pKTtcbiAgfVxufTtcbnZhciBJOEJ1aWxkZXIgPSBjbGFzcyBleHRlbmRzIFR5cGVCdWlsZGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoQWxnZWJyYWljVHlwZS5JOCk7XG4gIH1cbiAgaW5kZXgoYWxnb3JpdGhtID0gXCJidHJlZVwiKSB7XG4gICAgcmV0dXJuIG5ldyBJOENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpbmRleFR5cGU6IGFsZ29yaXRobSB9KVxuICAgICk7XG4gIH1cbiAgdW5pcXVlKCkge1xuICAgIHJldHVybiBuZXcgSThDb2x1bW5CdWlsZGVyKHRoaXMsIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNVbmlxdWU6IHRydWUgfSkpO1xuICB9XG4gIHByaW1hcnlLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBJOENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc1ByaW1hcnlLZXk6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGF1dG9JbmMoKSB7XG4gICAgcmV0dXJuIG5ldyBJOENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc0F1dG9JbmNyZW1lbnQ6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IEk4Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGRlZmF1bHRWYWx1ZTogdmFsdWUgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgSThDb2x1bW5CdWlsZGVyKHRoaXMsIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgbmFtZSB9KSk7XG4gIH1cbn07XG52YXIgSTE2QnVpbGRlciA9IGNsYXNzIGV4dGVuZHMgVHlwZUJ1aWxkZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihBbGdlYnJhaWNUeXBlLkkxNik7XG4gIH1cbiAgaW5kZXgoYWxnb3JpdGhtID0gXCJidHJlZVwiKSB7XG4gICAgcmV0dXJuIG5ldyBJMTZDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaW5kZXhUeXBlOiBhbGdvcml0aG0gfSlcbiAgICApO1xuICB9XG4gIHVuaXF1ZSgpIHtcbiAgICByZXR1cm4gbmV3IEkxNkNvbHVtbkJ1aWxkZXIodGhpcywgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc1VuaXF1ZTogdHJ1ZSB9KSk7XG4gIH1cbiAgcHJpbWFyeUtleSgpIHtcbiAgICByZXR1cm4gbmV3IEkxNkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc1ByaW1hcnlLZXk6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGF1dG9JbmMoKSB7XG4gICAgcmV0dXJuIG5ldyBJMTZDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNBdXRvSW5jcmVtZW50OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBJMTZDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgZGVmYXVsdFZhbHVlOiB2YWx1ZSB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBJMTZDb2x1bW5CdWlsZGVyKHRoaXMsIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgbmFtZSB9KSk7XG4gIH1cbn07XG52YXIgSTMyQnVpbGRlciA9IGNsYXNzIGV4dGVuZHMgVHlwZUJ1aWxkZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihBbGdlYnJhaWNUeXBlLkkzMik7XG4gIH1cbiAgaW5kZXgoYWxnb3JpdGhtID0gXCJidHJlZVwiKSB7XG4gICAgcmV0dXJuIG5ldyBJMzJDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaW5kZXhUeXBlOiBhbGdvcml0aG0gfSlcbiAgICApO1xuICB9XG4gIHVuaXF1ZSgpIHtcbiAgICByZXR1cm4gbmV3IEkzMkNvbHVtbkJ1aWxkZXIodGhpcywgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc1VuaXF1ZTogdHJ1ZSB9KSk7XG4gIH1cbiAgcHJpbWFyeUtleSgpIHtcbiAgICByZXR1cm4gbmV3IEkzMkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc1ByaW1hcnlLZXk6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGF1dG9JbmMoKSB7XG4gICAgcmV0dXJuIG5ldyBJMzJDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNBdXRvSW5jcmVtZW50OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBJMzJDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgZGVmYXVsdFZhbHVlOiB2YWx1ZSB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBJMzJDb2x1bW5CdWlsZGVyKHRoaXMsIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgbmFtZSB9KSk7XG4gIH1cbn07XG52YXIgSTY0QnVpbGRlciA9IGNsYXNzIGV4dGVuZHMgVHlwZUJ1aWxkZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihBbGdlYnJhaWNUeXBlLkk2NCk7XG4gIH1cbiAgaW5kZXgoYWxnb3JpdGhtID0gXCJidHJlZVwiKSB7XG4gICAgcmV0dXJuIG5ldyBJNjRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaW5kZXhUeXBlOiBhbGdvcml0aG0gfSlcbiAgICApO1xuICB9XG4gIHVuaXF1ZSgpIHtcbiAgICByZXR1cm4gbmV3IEk2NENvbHVtbkJ1aWxkZXIodGhpcywgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc1VuaXF1ZTogdHJ1ZSB9KSk7XG4gIH1cbiAgcHJpbWFyeUtleSgpIHtcbiAgICByZXR1cm4gbmV3IEk2NENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc1ByaW1hcnlLZXk6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGF1dG9JbmMoKSB7XG4gICAgcmV0dXJuIG5ldyBJNjRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNBdXRvSW5jcmVtZW50OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBJNjRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgZGVmYXVsdFZhbHVlOiB2YWx1ZSB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBJNjRDb2x1bW5CdWlsZGVyKHRoaXMsIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgbmFtZSB9KSk7XG4gIH1cbn07XG52YXIgSTEyOEJ1aWxkZXIgPSBjbGFzcyBleHRlbmRzIFR5cGVCdWlsZGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoQWxnZWJyYWljVHlwZS5JMTI4KTtcbiAgfVxuICBpbmRleChhbGdvcml0aG0gPSBcImJ0cmVlXCIpIHtcbiAgICByZXR1cm4gbmV3IEkxMjhDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaW5kZXhUeXBlOiBhbGdvcml0aG0gfSlcbiAgICApO1xuICB9XG4gIHVuaXF1ZSgpIHtcbiAgICByZXR1cm4gbmV3IEkxMjhDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNVbmlxdWU6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIHByaW1hcnlLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBJMTI4Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzUHJpbWFyeUtleTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgYXV0b0luYygpIHtcbiAgICByZXR1cm4gbmV3IEkxMjhDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNBdXRvSW5jcmVtZW50OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBJMTI4Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGRlZmF1bHRWYWx1ZTogdmFsdWUgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgSTEyOENvbHVtbkJ1aWxkZXIodGhpcywgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBuYW1lIH0pKTtcbiAgfVxufTtcbnZhciBJMjU2QnVpbGRlciA9IGNsYXNzIGV4dGVuZHMgVHlwZUJ1aWxkZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihBbGdlYnJhaWNUeXBlLkkyNTYpO1xuICB9XG4gIGluZGV4KGFsZ29yaXRobSA9IFwiYnRyZWVcIikge1xuICAgIHJldHVybiBuZXcgSTI1NkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpbmRleFR5cGU6IGFsZ29yaXRobSB9KVxuICAgICk7XG4gIH1cbiAgdW5pcXVlKCkge1xuICAgIHJldHVybiBuZXcgSTI1NkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc1VuaXF1ZTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgcHJpbWFyeUtleSgpIHtcbiAgICByZXR1cm4gbmV3IEkyNTZDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNQcmltYXJ5S2V5OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBhdXRvSW5jKCkge1xuICAgIHJldHVybiBuZXcgSTI1NkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc0F1dG9JbmNyZW1lbnQ6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IEkyNTZDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgZGVmYXVsdFZhbHVlOiB2YWx1ZSB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBJMjU2Q29sdW1uQnVpbGRlcih0aGlzLCBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IG5hbWUgfSkpO1xuICB9XG59O1xudmFyIEYzMkJ1aWxkZXIgPSBjbGFzcyBleHRlbmRzIFR5cGVCdWlsZGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoQWxnZWJyYWljVHlwZS5GMzIpO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IEYzMkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBkZWZhdWx0VmFsdWU6IHZhbHVlIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IEYzMkNvbHVtbkJ1aWxkZXIodGhpcywgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBuYW1lIH0pKTtcbiAgfVxufTtcbnZhciBGNjRCdWlsZGVyID0gY2xhc3MgZXh0ZW5kcyBUeXBlQnVpbGRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKEFsZ2VicmFpY1R5cGUuRjY0KTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBGNjRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgZGVmYXVsdFZhbHVlOiB2YWx1ZSB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBGNjRDb2x1bW5CdWlsZGVyKHRoaXMsIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgbmFtZSB9KSk7XG4gIH1cbn07XG52YXIgQm9vbEJ1aWxkZXIgPSBjbGFzcyBleHRlbmRzIFR5cGVCdWlsZGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoQWxnZWJyYWljVHlwZS5Cb29sKTtcbiAgfVxuICBpbmRleChhbGdvcml0aG0gPSBcImJ0cmVlXCIpIHtcbiAgICByZXR1cm4gbmV3IEJvb2xDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaW5kZXhUeXBlOiBhbGdvcml0aG0gfSlcbiAgICApO1xuICB9XG4gIHVuaXF1ZSgpIHtcbiAgICByZXR1cm4gbmV3IEJvb2xDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNVbmlxdWU6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIHByaW1hcnlLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBCb29sQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzUHJpbWFyeUtleTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgQm9vbENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBkZWZhdWx0VmFsdWU6IHZhbHVlIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IEJvb2xDb2x1bW5CdWlsZGVyKHRoaXMsIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgbmFtZSB9KSk7XG4gIH1cbn07XG52YXIgU3RyaW5nQnVpbGRlciA9IGNsYXNzIGV4dGVuZHMgVHlwZUJ1aWxkZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihBbGdlYnJhaWNUeXBlLlN0cmluZyk7XG4gIH1cbiAgaW5kZXgoYWxnb3JpdGhtID0gXCJidHJlZVwiKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJpbmdDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaW5kZXhUeXBlOiBhbGdvcml0aG0gfSlcbiAgICApO1xuICB9XG4gIHVuaXF1ZSgpIHtcbiAgICByZXR1cm4gbmV3IFN0cmluZ0NvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc1VuaXF1ZTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgcHJpbWFyeUtleSgpIHtcbiAgICByZXR1cm4gbmV3IFN0cmluZ0NvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc1ByaW1hcnlLZXk6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IFN0cmluZ0NvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBkZWZhdWx0VmFsdWU6IHZhbHVlIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IFN0cmluZ0NvbHVtbkJ1aWxkZXIodGhpcywgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBuYW1lIH0pKTtcbiAgfVxufTtcbnZhciBBcnJheUJ1aWxkZXIgPSBjbGFzcyBleHRlbmRzIFR5cGVCdWlsZGVyIHtcbiAgZWxlbWVudDtcbiAgY29uc3RydWN0b3IoZWxlbWVudCkge1xuICAgIHN1cGVyKEFsZ2VicmFpY1R5cGUuQXJyYXkoZWxlbWVudC5hbGdlYnJhaWNUeXBlKSk7XG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBBcnJheUNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLmVsZW1lbnQsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGRlZmF1bHRWYWx1ZTogdmFsdWUgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgQXJyYXlDb2x1bW5CdWlsZGVyKHRoaXMuZWxlbWVudCwgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBuYW1lIH0pKTtcbiAgfVxufTtcbnZhciBCeXRlQXJyYXlCdWlsZGVyID0gY2xhc3MgZXh0ZW5kcyBUeXBlQnVpbGRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKEFsZ2VicmFpY1R5cGUuQXJyYXkoQWxnZWJyYWljVHlwZS5VOCkpO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IEJ5dGVBcnJheUNvbHVtbkJ1aWxkZXIoXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGRlZmF1bHRWYWx1ZTogdmFsdWUgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgQnl0ZUFycmF5Q29sdW1uQnVpbGRlcihzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IG5hbWUgfSkpO1xuICB9XG59O1xudmFyIE9wdGlvbkJ1aWxkZXIgPSBjbGFzcyBleHRlbmRzIFR5cGVCdWlsZGVyIHtcbiAgdmFsdWU7XG4gIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgc3VwZXIoT3B0aW9uLmdldEFsZ2VicmFpY1R5cGUodmFsdWUuYWxnZWJyYWljVHlwZSkpO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBPcHRpb25Db2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgZGVmYXVsdFZhbHVlOiB2YWx1ZSB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBPcHRpb25Db2x1bW5CdWlsZGVyKHRoaXMsIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgbmFtZSB9KSk7XG4gIH1cbn07XG52YXIgUHJvZHVjdEJ1aWxkZXIgPSBjbGFzcyBleHRlbmRzIFR5cGVCdWlsZGVyIHtcbiAgdHlwZU5hbWU7XG4gIGVsZW1lbnRzO1xuICBjb25zdHJ1Y3RvcihlbGVtZW50cywgbmFtZSkge1xuICAgIGZ1bmN0aW9uIGVsZW1lbnRzQXJyYXlGcm9tRWxlbWVudHNPYmoob2JqKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5tYXAoKGtleSkgPT4gKHtcbiAgICAgICAgbmFtZToga2V5LFxuICAgICAgICAvLyBMYXppbHkgcmVzb2x2ZSB0aGUgdW5kZXJseWluZyBvYmplY3QncyBhbGdlYnJhaWNUeXBlLlxuICAgICAgICAvLyBUaGlzIHdpbGwgY2FsbCBvYmpba2V5XS5hbGdlYnJhaWNUeXBlIG9ubHkgd2hlbiBzb21lb25lXG4gICAgICAgIC8vIGFjdHVhbGx5IHJlYWRzIHRoaXMgcHJvcGVydHkuXG4gICAgICAgIGdldCBhbGdlYnJhaWNUeXBlKCkge1xuICAgICAgICAgIHJldHVybiBvYmpba2V5XS5hbGdlYnJhaWNUeXBlO1xuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgfVxuICAgIHN1cGVyKFxuICAgICAgQWxnZWJyYWljVHlwZS5Qcm9kdWN0KHtcbiAgICAgICAgZWxlbWVudHM6IGVsZW1lbnRzQXJyYXlGcm9tRWxlbWVudHNPYmooZWxlbWVudHMpXG4gICAgICB9KVxuICAgICk7XG4gICAgdGhpcy50eXBlTmFtZSA9IG5hbWU7XG4gICAgdGhpcy5lbGVtZW50cyA9IGVsZW1lbnRzO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IFByb2R1Y3RDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgZGVmYXVsdFZhbHVlOiB2YWx1ZSB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9kdWN0Q29sdW1uQnVpbGRlcih0aGlzLCBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IG5hbWUgfSkpO1xuICB9XG59O1xudmFyIFJlc3VsdEJ1aWxkZXIgPSBjbGFzcyBleHRlbmRzIFR5cGVCdWlsZGVyIHtcbiAgb2s7XG4gIGVycjtcbiAgY29uc3RydWN0b3Iob2ssIGVycikge1xuICAgIHN1cGVyKFJlc3VsdC5nZXRBbGdlYnJhaWNUeXBlKG9rLmFsZ2VicmFpY1R5cGUsIGVyci5hbGdlYnJhaWNUeXBlKSk7XG4gICAgdGhpcy5vayA9IG9rO1xuICAgIHRoaXMuZXJyID0gZXJyO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IFJlc3VsdENvbHVtbkJ1aWxkZXIodGhpcywgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBkZWZhdWx0VmFsdWU6IHZhbHVlIH0pKTtcbiAgfVxufTtcbnZhciBVbml0QnVpbGRlciA9IGNsYXNzIGV4dGVuZHMgVHlwZUJ1aWxkZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcih7IHRhZzogXCJQcm9kdWN0XCIsIHZhbHVlOiB7IGVsZW1lbnRzOiBbXSB9IH0pO1xuICB9XG59O1xudmFyIFJvd0J1aWxkZXIgPSBjbGFzcyBleHRlbmRzIFR5cGVCdWlsZGVyIHtcbiAgcm93O1xuICB0eXBlTmFtZTtcbiAgY29uc3RydWN0b3Iocm93LCBuYW1lKSB7XG4gICAgY29uc3QgbWFwcGVkUm93ID0gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgT2JqZWN0LmVudHJpZXMocm93KS5tYXAoKFtjb2xOYW1lLCBidWlsZGVyXSkgPT4gW1xuICAgICAgICBjb2xOYW1lLFxuICAgICAgICBidWlsZGVyIGluc3RhbmNlb2YgQ29sdW1uQnVpbGRlciA/IGJ1aWxkZXIgOiBuZXcgQ29sdW1uQnVpbGRlcihidWlsZGVyLCB7fSlcbiAgICAgIF0pXG4gICAgKTtcbiAgICBjb25zdCBlbGVtZW50cyA9IE9iamVjdC5rZXlzKG1hcHBlZFJvdykubWFwKChuYW1lMikgPT4gKHtcbiAgICAgIG5hbWU6IG5hbWUyLFxuICAgICAgZ2V0IGFsZ2VicmFpY1R5cGUoKSB7XG4gICAgICAgIHJldHVybiBtYXBwZWRSb3dbbmFtZTJdLnR5cGVCdWlsZGVyLmFsZ2VicmFpY1R5cGU7XG4gICAgICB9XG4gICAgfSkpO1xuICAgIHN1cGVyKEFsZ2VicmFpY1R5cGUuUHJvZHVjdCh7IGVsZW1lbnRzIH0pKTtcbiAgICB0aGlzLnJvdyA9IG1hcHBlZFJvdztcbiAgICB0aGlzLnR5cGVOYW1lID0gbmFtZTtcbiAgfVxufTtcbnZhciBTdW1CdWlsZGVySW1wbCA9IGNsYXNzIGV4dGVuZHMgVHlwZUJ1aWxkZXIge1xuICB2YXJpYW50cztcbiAgdHlwZU5hbWU7XG4gIGNvbnN0cnVjdG9yKHZhcmlhbnRzLCBuYW1lKSB7XG4gICAgZnVuY3Rpb24gdmFyaWFudHNBcnJheUZyb21WYXJpYW50c09iaih2YXJpYW50czIpIHtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyh2YXJpYW50czIpLm1hcCgoa2V5KSA9PiAoe1xuICAgICAgICBuYW1lOiBrZXksXG4gICAgICAgIC8vIExhemlseSByZXNvbHZlIHRoZSB1bmRlcmx5aW5nIG9iamVjdCdzIGFsZ2VicmFpY1R5cGUuXG4gICAgICAgIC8vIFRoaXMgd2lsbCBjYWxsIG9ialtrZXldLmFsZ2VicmFpY1R5cGUgb25seSB3aGVuIHNvbWVvbmVcbiAgICAgICAgLy8gYWN0dWFsbHkgcmVhZHMgdGhpcyBwcm9wZXJ0eS5cbiAgICAgICAgZ2V0IGFsZ2VicmFpY1R5cGUoKSB7XG4gICAgICAgICAgcmV0dXJuIHZhcmlhbnRzMltrZXldLmFsZ2VicmFpY1R5cGU7XG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICB9XG4gICAgc3VwZXIoXG4gICAgICBBbGdlYnJhaWNUeXBlLlN1bSh7XG4gICAgICAgIHZhcmlhbnRzOiB2YXJpYW50c0FycmF5RnJvbVZhcmlhbnRzT2JqKHZhcmlhbnRzKVxuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMudmFyaWFudHMgPSB2YXJpYW50cztcbiAgICB0aGlzLnR5cGVOYW1lID0gbmFtZTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh2YXJpYW50cykpIHtcbiAgICAgIGNvbnN0IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhcmlhbnRzLCBrZXkpO1xuICAgICAgY29uc3QgaXNBY2Nlc3NvciA9ICEhZGVzYyAmJiAodHlwZW9mIGRlc2MuZ2V0ID09PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIGRlc2Muc2V0ID09PSBcImZ1bmN0aW9uXCIpO1xuICAgICAgbGV0IGlzVW5pdDIgPSBmYWxzZTtcbiAgICAgIGlmICghaXNBY2Nlc3Nvcikge1xuICAgICAgICBjb25zdCB2YXJpYW50ID0gdmFyaWFudHNba2V5XTtcbiAgICAgICAgaXNVbml0MiA9IHZhcmlhbnQgaW5zdGFuY2VvZiBVbml0QnVpbGRlcjtcbiAgICAgIH1cbiAgICAgIGlmIChpc1VuaXQyKSB7XG4gICAgICAgIGNvbnN0IGNvbnN0YW50ID0gdGhpcy5jcmVhdGUoa2V5KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwge1xuICAgICAgICAgIHZhbHVlOiBjb25zdGFudCxcbiAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZm4gPSAoKHZhbHVlKSA9PiB0aGlzLmNyZWF0ZShrZXksIHZhbHVlKSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBrZXksIHtcbiAgICAgICAgICB2YWx1ZTogZm4sXG4gICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY3JlYXRlKHRhZywgdmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHZvaWQgMCA/IHsgdGFnIH0gOiB7IHRhZywgdmFsdWUgfTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBTdW1Db2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgZGVmYXVsdFZhbHVlOiB2YWx1ZSB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBTdW1Db2x1bW5CdWlsZGVyKHRoaXMsIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgbmFtZSB9KSk7XG4gIH1cbn07XG52YXIgU3VtQnVpbGRlciA9IFN1bUJ1aWxkZXJJbXBsO1xudmFyIFNpbXBsZVN1bUJ1aWxkZXJJbXBsID0gY2xhc3MgZXh0ZW5kcyBTdW1CdWlsZGVySW1wbCB7XG4gIGluZGV4KGFsZ29yaXRobSA9IFwiYnRyZWVcIikge1xuICAgIHJldHVybiBuZXcgU2ltcGxlU3VtQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGluZGV4VHlwZTogYWxnb3JpdGhtIH0pXG4gICAgKTtcbiAgfVxuICBwcmltYXJ5S2V5KCkge1xuICAgIHJldHVybiBuZXcgU2ltcGxlU3VtQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzUHJpbWFyeUtleTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbn07XG52YXIgU2ltcGxlU3VtQnVpbGRlciA9IFNpbXBsZVN1bUJ1aWxkZXJJbXBsO1xudmFyIFNjaGVkdWxlQXRCdWlsZGVyID0gY2xhc3MgZXh0ZW5kcyBUeXBlQnVpbGRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKHNjaGVkdWxlX2F0X2RlZmF1bHQuZ2V0QWxnZWJyYWljVHlwZSgpKTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBTY2hlZHVsZUF0Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGRlZmF1bHRWYWx1ZTogdmFsdWUgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgU2NoZWR1bGVBdENvbHVtbkJ1aWxkZXIodGhpcywgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBuYW1lIH0pKTtcbiAgfVxufTtcbnZhciBJZGVudGl0eUJ1aWxkZXIgPSBjbGFzcyBleHRlbmRzIFR5cGVCdWlsZGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoSWRlbnRpdHkuZ2V0QWxnZWJyYWljVHlwZSgpKTtcbiAgfVxuICBpbmRleChhbGdvcml0aG0gPSBcImJ0cmVlXCIpIHtcbiAgICByZXR1cm4gbmV3IElkZW50aXR5Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGluZGV4VHlwZTogYWxnb3JpdGhtIH0pXG4gICAgKTtcbiAgfVxuICB1bmlxdWUoKSB7XG4gICAgcmV0dXJuIG5ldyBJZGVudGl0eUNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc1VuaXF1ZTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgcHJpbWFyeUtleSgpIHtcbiAgICByZXR1cm4gbmV3IElkZW50aXR5Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzUHJpbWFyeUtleTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgYXV0b0luYygpIHtcbiAgICByZXR1cm4gbmV3IElkZW50aXR5Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzQXV0b0luY3JlbWVudDogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgSWRlbnRpdHlDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgZGVmYXVsdFZhbHVlOiB2YWx1ZSB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBJZGVudGl0eUNvbHVtbkJ1aWxkZXIodGhpcywgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBuYW1lIH0pKTtcbiAgfVxufTtcbnZhciBDb25uZWN0aW9uSWRCdWlsZGVyID0gY2xhc3MgZXh0ZW5kcyBUeXBlQnVpbGRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKENvbm5lY3Rpb25JZC5nZXRBbGdlYnJhaWNUeXBlKCkpO1xuICB9XG4gIGluZGV4KGFsZ29yaXRobSA9IFwiYnRyZWVcIikge1xuICAgIHJldHVybiBuZXcgQ29ubmVjdGlvbklkQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGluZGV4VHlwZTogYWxnb3JpdGhtIH0pXG4gICAgKTtcbiAgfVxuICB1bmlxdWUoKSB7XG4gICAgcmV0dXJuIG5ldyBDb25uZWN0aW9uSWRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNVbmlxdWU6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIHByaW1hcnlLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBDb25uZWN0aW9uSWRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNQcmltYXJ5S2V5OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBhdXRvSW5jKCkge1xuICAgIHJldHVybiBuZXcgQ29ubmVjdGlvbklkQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzQXV0b0luY3JlbWVudDogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgQ29ubmVjdGlvbklkQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGRlZmF1bHRWYWx1ZTogdmFsdWUgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgQ29ubmVjdGlvbklkQ29sdW1uQnVpbGRlcih0aGlzLCBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IG5hbWUgfSkpO1xuICB9XG59O1xudmFyIFRpbWVzdGFtcEJ1aWxkZXIgPSBjbGFzcyBleHRlbmRzIFR5cGVCdWlsZGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoVGltZXN0YW1wLmdldEFsZ2VicmFpY1R5cGUoKSk7XG4gIH1cbiAgaW5kZXgoYWxnb3JpdGhtID0gXCJidHJlZVwiKSB7XG4gICAgcmV0dXJuIG5ldyBUaW1lc3RhbXBDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaW5kZXhUeXBlOiBhbGdvcml0aG0gfSlcbiAgICApO1xuICB9XG4gIHVuaXF1ZSgpIHtcbiAgICByZXR1cm4gbmV3IFRpbWVzdGFtcENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc1VuaXF1ZTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgcHJpbWFyeUtleSgpIHtcbiAgICByZXR1cm4gbmV3IFRpbWVzdGFtcENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc1ByaW1hcnlLZXk6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGF1dG9JbmMoKSB7XG4gICAgcmV0dXJuIG5ldyBUaW1lc3RhbXBDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgaXNBdXRvSW5jcmVtZW50OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBUaW1lc3RhbXBDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcyxcbiAgICAgIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgZGVmYXVsdFZhbHVlOiB2YWx1ZSB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBUaW1lc3RhbXBDb2x1bW5CdWlsZGVyKHRoaXMsIHNldChkZWZhdWx0TWV0YWRhdGEsIHsgbmFtZSB9KSk7XG4gIH1cbn07XG52YXIgVGltZUR1cmF0aW9uQnVpbGRlciA9IGNsYXNzIGV4dGVuZHMgVHlwZUJ1aWxkZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihUaW1lRHVyYXRpb24uZ2V0QWxnZWJyYWljVHlwZSgpKTtcbiAgfVxuICBpbmRleChhbGdvcml0aG0gPSBcImJ0cmVlXCIpIHtcbiAgICByZXR1cm4gbmV3IFRpbWVEdXJhdGlvbkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpbmRleFR5cGU6IGFsZ29yaXRobSB9KVxuICAgICk7XG4gIH1cbiAgdW5pcXVlKCkge1xuICAgIHJldHVybiBuZXcgVGltZUR1cmF0aW9uQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzVW5pcXVlOiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBwcmltYXJ5S2V5KCkge1xuICAgIHJldHVybiBuZXcgVGltZUR1cmF0aW9uQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzUHJpbWFyeUtleTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgYXV0b0luYygpIHtcbiAgICByZXR1cm4gbmV3IFRpbWVEdXJhdGlvbkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc0F1dG9JbmNyZW1lbnQ6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IFRpbWVEdXJhdGlvbkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBkZWZhdWx0VmFsdWU6IHZhbHVlIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IFRpbWVEdXJhdGlvbkNvbHVtbkJ1aWxkZXIodGhpcywgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBuYW1lIH0pKTtcbiAgfVxufTtcbnZhciBVdWlkQnVpbGRlciA9IGNsYXNzIGV4dGVuZHMgVHlwZUJ1aWxkZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihVdWlkLmdldEFsZ2VicmFpY1R5cGUoKSk7XG4gIH1cbiAgaW5kZXgoYWxnb3JpdGhtID0gXCJidHJlZVwiKSB7XG4gICAgcmV0dXJuIG5ldyBVdWlkQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGluZGV4VHlwZTogYWxnb3JpdGhtIH0pXG4gICAgKTtcbiAgfVxuICB1bmlxdWUoKSB7XG4gICAgcmV0dXJuIG5ldyBVdWlkQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzVW5pcXVlOiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBwcmltYXJ5S2V5KCkge1xuICAgIHJldHVybiBuZXcgVXVpZENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBpc1ByaW1hcnlLZXk6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGF1dG9JbmMoKSB7XG4gICAgcmV0dXJuIG5ldyBVdWlkQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMsXG4gICAgICBzZXQoZGVmYXVsdE1ldGFkYXRhLCB7IGlzQXV0b0luY3JlbWVudDogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgVXVpZENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLFxuICAgICAgc2V0KGRlZmF1bHRNZXRhZGF0YSwgeyBkZWZhdWx0VmFsdWU6IHZhbHVlIH0pXG4gICAgKTtcbiAgfVxufTtcbnZhciBkZWZhdWx0TWV0YWRhdGEgPSB7fTtcbnZhciBDb2x1bW5CdWlsZGVyID0gY2xhc3Mge1xuICB0eXBlQnVpbGRlcjtcbiAgY29sdW1uTWV0YWRhdGE7XG4gIGNvbnN0cnVjdG9yKHR5cGVCdWlsZGVyLCBtZXRhZGF0YSkge1xuICAgIHRoaXMudHlwZUJ1aWxkZXIgPSB0eXBlQnVpbGRlcjtcbiAgICB0aGlzLmNvbHVtbk1ldGFkYXRhID0gbWV0YWRhdGE7XG4gIH1cbiAgc2VyaWFsaXplKHdyaXRlciwgdmFsdWUpIHtcbiAgICBBbGdlYnJhaWNUeXBlLnNlcmlhbGl6ZVZhbHVlKHdyaXRlciwgdGhpcy50eXBlQnVpbGRlci5hbGdlYnJhaWNUeXBlLCB2YWx1ZSk7XG4gIH1cbiAgZGVzZXJpYWxpemUocmVhZGVyKSB7XG4gICAgcmV0dXJuIEFsZ2VicmFpY1R5cGUuZGVzZXJpYWxpemVWYWx1ZShcbiAgICAgIHJlYWRlcixcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIuYWxnZWJyYWljVHlwZVxuICAgICk7XG4gIH1cbn07XG52YXIgVThDb2x1bW5CdWlsZGVyID0gY2xhc3MgX1U4Q29sdW1uQnVpbGRlciBleHRlbmRzIENvbHVtbkJ1aWxkZXIge1xuICBpbmRleChhbGdvcml0aG0gPSBcImJ0cmVlXCIpIHtcbiAgICByZXR1cm4gbmV3IF9VOENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaW5kZXhUeXBlOiBhbGdvcml0aG0gfSlcbiAgICApO1xuICB9XG4gIHVuaXF1ZSgpIHtcbiAgICByZXR1cm4gbmV3IF9VOENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNVbmlxdWU6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIHByaW1hcnlLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBfVThDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzUHJpbWFyeUtleTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgYXV0b0luYygpIHtcbiAgICByZXR1cm4gbmV3IF9VOENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNBdXRvSW5jcmVtZW50OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBfVThDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7XG4gICAgICAgIGRlZmF1bHRWYWx1ZTogdmFsdWVcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IF9VOENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgbmFtZSB9KVxuICAgICk7XG4gIH1cbn07XG52YXIgVTE2Q29sdW1uQnVpbGRlciA9IGNsYXNzIF9VMTZDb2x1bW5CdWlsZGVyIGV4dGVuZHMgQ29sdW1uQnVpbGRlciB7XG4gIGluZGV4KGFsZ29yaXRobSA9IFwiYnRyZWVcIikge1xuICAgIHJldHVybiBuZXcgX1UxNkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaW5kZXhUeXBlOiBhbGdvcml0aG0gfSlcbiAgICApO1xuICB9XG4gIHVuaXF1ZSgpIHtcbiAgICByZXR1cm4gbmV3IF9VMTZDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzVW5pcXVlOiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBwcmltYXJ5S2V5KCkge1xuICAgIHJldHVybiBuZXcgX1UxNkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNQcmltYXJ5S2V5OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBhdXRvSW5jKCkge1xuICAgIHJldHVybiBuZXcgX1UxNkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNBdXRvSW5jcmVtZW50OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBfVTE2Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwge1xuICAgICAgICBkZWZhdWx0VmFsdWU6IHZhbHVlXG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBfVTE2Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBuYW1lIH0pXG4gICAgKTtcbiAgfVxufTtcbnZhciBVMzJDb2x1bW5CdWlsZGVyID0gY2xhc3MgX1UzMkNvbHVtbkJ1aWxkZXIgZXh0ZW5kcyBDb2x1bW5CdWlsZGVyIHtcbiAgaW5kZXgoYWxnb3JpdGhtID0gXCJidHJlZVwiKSB7XG4gICAgcmV0dXJuIG5ldyBfVTMyQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpbmRleFR5cGU6IGFsZ29yaXRobSB9KVxuICAgICk7XG4gIH1cbiAgdW5pcXVlKCkge1xuICAgIHJldHVybiBuZXcgX1UzMkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNVbmlxdWU6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIHByaW1hcnlLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBfVTMyQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc1ByaW1hcnlLZXk6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGF1dG9JbmMoKSB7XG4gICAgcmV0dXJuIG5ldyBfVTMyQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc0F1dG9JbmNyZW1lbnQ6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IF9VMzJDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7XG4gICAgICAgIGRlZmF1bHRWYWx1ZTogdmFsdWVcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IF9VMzJDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IG5hbWUgfSlcbiAgICApO1xuICB9XG59O1xudmFyIFU2NENvbHVtbkJ1aWxkZXIgPSBjbGFzcyBfVTY0Q29sdW1uQnVpbGRlciBleHRlbmRzIENvbHVtbkJ1aWxkZXIge1xuICBpbmRleChhbGdvcml0aG0gPSBcImJ0cmVlXCIpIHtcbiAgICByZXR1cm4gbmV3IF9VNjRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGluZGV4VHlwZTogYWxnb3JpdGhtIH0pXG4gICAgKTtcbiAgfVxuICB1bmlxdWUoKSB7XG4gICAgcmV0dXJuIG5ldyBfVTY0Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc1VuaXF1ZTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgcHJpbWFyeUtleSgpIHtcbiAgICByZXR1cm4gbmV3IF9VNjRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzUHJpbWFyeUtleTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgYXV0b0luYygpIHtcbiAgICByZXR1cm4gbmV3IF9VNjRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzQXV0b0luY3JlbWVudDogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgX1U2NENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHtcbiAgICAgICAgZGVmYXVsdFZhbHVlOiB2YWx1ZVxuICAgICAgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgX1U2NENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgbmFtZSB9KVxuICAgICk7XG4gIH1cbn07XG52YXIgVTEyOENvbHVtbkJ1aWxkZXIgPSBjbGFzcyBfVTEyOENvbHVtbkJ1aWxkZXIgZXh0ZW5kcyBDb2x1bW5CdWlsZGVyIHtcbiAgaW5kZXgoYWxnb3JpdGhtID0gXCJidHJlZVwiKSB7XG4gICAgcmV0dXJuIG5ldyBfVTEyOENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaW5kZXhUeXBlOiBhbGdvcml0aG0gfSlcbiAgICApO1xuICB9XG4gIHVuaXF1ZSgpIHtcbiAgICByZXR1cm4gbmV3IF9VMTI4Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc1VuaXF1ZTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgcHJpbWFyeUtleSgpIHtcbiAgICByZXR1cm4gbmV3IF9VMTI4Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc1ByaW1hcnlLZXk6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGF1dG9JbmMoKSB7XG4gICAgcmV0dXJuIG5ldyBfVTEyOENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNBdXRvSW5jcmVtZW50OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBfVTEyOENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHtcbiAgICAgICAgZGVmYXVsdFZhbHVlOiB2YWx1ZVxuICAgICAgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgX1UxMjhDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IG5hbWUgfSlcbiAgICApO1xuICB9XG59O1xudmFyIFUyNTZDb2x1bW5CdWlsZGVyID0gY2xhc3MgX1UyNTZDb2x1bW5CdWlsZGVyIGV4dGVuZHMgQ29sdW1uQnVpbGRlciB7XG4gIGluZGV4KGFsZ29yaXRobSA9IFwiYnRyZWVcIikge1xuICAgIHJldHVybiBuZXcgX1UyNTZDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGluZGV4VHlwZTogYWxnb3JpdGhtIH0pXG4gICAgKTtcbiAgfVxuICB1bmlxdWUoKSB7XG4gICAgcmV0dXJuIG5ldyBfVTI1NkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNVbmlxdWU6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIHByaW1hcnlLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBfVTI1NkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNQcmltYXJ5S2V5OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBhdXRvSW5jKCkge1xuICAgIHJldHVybiBuZXcgX1UyNTZDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzQXV0b0luY3JlbWVudDogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgX1UyNTZDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7XG4gICAgICAgIGRlZmF1bHRWYWx1ZTogdmFsdWVcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IF9VMjU2Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBuYW1lIH0pXG4gICAgKTtcbiAgfVxufTtcbnZhciBJOENvbHVtbkJ1aWxkZXIgPSBjbGFzcyBfSThDb2x1bW5CdWlsZGVyIGV4dGVuZHMgQ29sdW1uQnVpbGRlciB7XG4gIGluZGV4KGFsZ29yaXRobSA9IFwiYnRyZWVcIikge1xuICAgIHJldHVybiBuZXcgX0k4Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpbmRleFR5cGU6IGFsZ29yaXRobSB9KVxuICAgICk7XG4gIH1cbiAgdW5pcXVlKCkge1xuICAgIHJldHVybiBuZXcgX0k4Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc1VuaXF1ZTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgcHJpbWFyeUtleSgpIHtcbiAgICByZXR1cm4gbmV3IF9JOENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNQcmltYXJ5S2V5OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBhdXRvSW5jKCkge1xuICAgIHJldHVybiBuZXcgX0k4Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc0F1dG9JbmNyZW1lbnQ6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IF9JOENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHtcbiAgICAgICAgZGVmYXVsdFZhbHVlOiB2YWx1ZVxuICAgICAgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgX0k4Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBuYW1lIH0pXG4gICAgKTtcbiAgfVxufTtcbnZhciBJMTZDb2x1bW5CdWlsZGVyID0gY2xhc3MgX0kxNkNvbHVtbkJ1aWxkZXIgZXh0ZW5kcyBDb2x1bW5CdWlsZGVyIHtcbiAgaW5kZXgoYWxnb3JpdGhtID0gXCJidHJlZVwiKSB7XG4gICAgcmV0dXJuIG5ldyBfSTE2Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpbmRleFR5cGU6IGFsZ29yaXRobSB9KVxuICAgICk7XG4gIH1cbiAgdW5pcXVlKCkge1xuICAgIHJldHVybiBuZXcgX0kxNkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNVbmlxdWU6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIHByaW1hcnlLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBfSTE2Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc1ByaW1hcnlLZXk6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGF1dG9JbmMoKSB7XG4gICAgcmV0dXJuIG5ldyBfSTE2Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc0F1dG9JbmNyZW1lbnQ6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IF9JMTZDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7XG4gICAgICAgIGRlZmF1bHRWYWx1ZTogdmFsdWVcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IF9JMTZDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IG5hbWUgfSlcbiAgICApO1xuICB9XG59O1xudmFyIEkzMkNvbHVtbkJ1aWxkZXIgPSBjbGFzcyBfSTMyQ29sdW1uQnVpbGRlciBleHRlbmRzIENvbHVtbkJ1aWxkZXIge1xuICBpbmRleChhbGdvcml0aG0gPSBcImJ0cmVlXCIpIHtcbiAgICByZXR1cm4gbmV3IF9JMzJDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGluZGV4VHlwZTogYWxnb3JpdGhtIH0pXG4gICAgKTtcbiAgfVxuICB1bmlxdWUoKSB7XG4gICAgcmV0dXJuIG5ldyBfSTMyQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc1VuaXF1ZTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgcHJpbWFyeUtleSgpIHtcbiAgICByZXR1cm4gbmV3IF9JMzJDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzUHJpbWFyeUtleTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgYXV0b0luYygpIHtcbiAgICByZXR1cm4gbmV3IF9JMzJDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzQXV0b0luY3JlbWVudDogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgX0kzMkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHtcbiAgICAgICAgZGVmYXVsdFZhbHVlOiB2YWx1ZVxuICAgICAgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgX0kzMkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgbmFtZSB9KVxuICAgICk7XG4gIH1cbn07XG52YXIgSTY0Q29sdW1uQnVpbGRlciA9IGNsYXNzIF9JNjRDb2x1bW5CdWlsZGVyIGV4dGVuZHMgQ29sdW1uQnVpbGRlciB7XG4gIGluZGV4KGFsZ29yaXRobSA9IFwiYnRyZWVcIikge1xuICAgIHJldHVybiBuZXcgX0k2NENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaW5kZXhUeXBlOiBhbGdvcml0aG0gfSlcbiAgICApO1xuICB9XG4gIHVuaXF1ZSgpIHtcbiAgICByZXR1cm4gbmV3IF9JNjRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzVW5pcXVlOiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBwcmltYXJ5S2V5KCkge1xuICAgIHJldHVybiBuZXcgX0k2NENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNQcmltYXJ5S2V5OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBhdXRvSW5jKCkge1xuICAgIHJldHVybiBuZXcgX0k2NENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNBdXRvSW5jcmVtZW50OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBfSTY0Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwge1xuICAgICAgICBkZWZhdWx0VmFsdWU6IHZhbHVlXG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBfSTY0Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBuYW1lIH0pXG4gICAgKTtcbiAgfVxufTtcbnZhciBJMTI4Q29sdW1uQnVpbGRlciA9IGNsYXNzIF9JMTI4Q29sdW1uQnVpbGRlciBleHRlbmRzIENvbHVtbkJ1aWxkZXIge1xuICBpbmRleChhbGdvcml0aG0gPSBcImJ0cmVlXCIpIHtcbiAgICByZXR1cm4gbmV3IF9JMTI4Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpbmRleFR5cGU6IGFsZ29yaXRobSB9KVxuICAgICk7XG4gIH1cbiAgdW5pcXVlKCkge1xuICAgIHJldHVybiBuZXcgX0kxMjhDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzVW5pcXVlOiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBwcmltYXJ5S2V5KCkge1xuICAgIHJldHVybiBuZXcgX0kxMjhDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzUHJpbWFyeUtleTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgYXV0b0luYygpIHtcbiAgICByZXR1cm4gbmV3IF9JMTI4Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc0F1dG9JbmNyZW1lbnQ6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IF9JMTI4Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwge1xuICAgICAgICBkZWZhdWx0VmFsdWU6IHZhbHVlXG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBfSTEyOENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgbmFtZSB9KVxuICAgICk7XG4gIH1cbn07XG52YXIgSTI1NkNvbHVtbkJ1aWxkZXIgPSBjbGFzcyBfSTI1NkNvbHVtbkJ1aWxkZXIgZXh0ZW5kcyBDb2x1bW5CdWlsZGVyIHtcbiAgaW5kZXgoYWxnb3JpdGhtID0gXCJidHJlZVwiKSB7XG4gICAgcmV0dXJuIG5ldyBfSTI1NkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaW5kZXhUeXBlOiBhbGdvcml0aG0gfSlcbiAgICApO1xuICB9XG4gIHVuaXF1ZSgpIHtcbiAgICByZXR1cm4gbmV3IF9JMjU2Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc1VuaXF1ZTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgcHJpbWFyeUtleSgpIHtcbiAgICByZXR1cm4gbmV3IF9JMjU2Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc1ByaW1hcnlLZXk6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGF1dG9JbmMoKSB7XG4gICAgcmV0dXJuIG5ldyBfSTI1NkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNBdXRvSW5jcmVtZW50OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBfSTI1NkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHtcbiAgICAgICAgZGVmYXVsdFZhbHVlOiB2YWx1ZVxuICAgICAgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgX0kyNTZDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IG5hbWUgfSlcbiAgICApO1xuICB9XG59O1xudmFyIEYzMkNvbHVtbkJ1aWxkZXIgPSBjbGFzcyBfRjMyQ29sdW1uQnVpbGRlciBleHRlbmRzIENvbHVtbkJ1aWxkZXIge1xuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBfRjMyQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwge1xuICAgICAgICBkZWZhdWx0VmFsdWU6IHZhbHVlXG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBfRjMyQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBuYW1lIH0pXG4gICAgKTtcbiAgfVxufTtcbnZhciBGNjRDb2x1bW5CdWlsZGVyID0gY2xhc3MgX0Y2NENvbHVtbkJ1aWxkZXIgZXh0ZW5kcyBDb2x1bW5CdWlsZGVyIHtcbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgX0Y2NENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHtcbiAgICAgICAgZGVmYXVsdFZhbHVlOiB2YWx1ZVxuICAgICAgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgX0Y2NENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgbmFtZSB9KVxuICAgICk7XG4gIH1cbn07XG52YXIgQm9vbENvbHVtbkJ1aWxkZXIgPSBjbGFzcyBfQm9vbENvbHVtbkJ1aWxkZXIgZXh0ZW5kcyBDb2x1bW5CdWlsZGVyIHtcbiAgaW5kZXgoYWxnb3JpdGhtID0gXCJidHJlZVwiKSB7XG4gICAgcmV0dXJuIG5ldyBfQm9vbENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaW5kZXhUeXBlOiBhbGdvcml0aG0gfSlcbiAgICApO1xuICB9XG4gIHVuaXF1ZSgpIHtcbiAgICByZXR1cm4gbmV3IF9Cb29sQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc1VuaXF1ZTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgcHJpbWFyeUtleSgpIHtcbiAgICByZXR1cm4gbmV3IF9Cb29sQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc1ByaW1hcnlLZXk6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IF9Cb29sQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwge1xuICAgICAgICBkZWZhdWx0VmFsdWU6IHZhbHVlXG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBfQm9vbENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgbmFtZSB9KVxuICAgICk7XG4gIH1cbn07XG52YXIgU3RyaW5nQ29sdW1uQnVpbGRlciA9IGNsYXNzIF9TdHJpbmdDb2x1bW5CdWlsZGVyIGV4dGVuZHMgQ29sdW1uQnVpbGRlciB7XG4gIGluZGV4KGFsZ29yaXRobSA9IFwiYnRyZWVcIikge1xuICAgIHJldHVybiBuZXcgX1N0cmluZ0NvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaW5kZXhUeXBlOiBhbGdvcml0aG0gfSlcbiAgICApO1xuICB9XG4gIHVuaXF1ZSgpIHtcbiAgICByZXR1cm4gbmV3IF9TdHJpbmdDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzVW5pcXVlOiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBwcmltYXJ5S2V5KCkge1xuICAgIHJldHVybiBuZXcgX1N0cmluZ0NvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNQcmltYXJ5S2V5OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBfU3RyaW5nQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwge1xuICAgICAgICBkZWZhdWx0VmFsdWU6IHZhbHVlXG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBfU3RyaW5nQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBuYW1lIH0pXG4gICAgKTtcbiAgfVxufTtcbnZhciBBcnJheUNvbHVtbkJ1aWxkZXIgPSBjbGFzcyBfQXJyYXlDb2x1bW5CdWlsZGVyIGV4dGVuZHMgQ29sdW1uQnVpbGRlciB7XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IF9BcnJheUNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHtcbiAgICAgICAgZGVmYXVsdFZhbHVlOiB2YWx1ZVxuICAgICAgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgX0FycmF5Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBuYW1lIH0pXG4gICAgKTtcbiAgfVxufTtcbnZhciBCeXRlQXJyYXlDb2x1bW5CdWlsZGVyID0gY2xhc3MgX0J5dGVBcnJheUNvbHVtbkJ1aWxkZXIgZXh0ZW5kcyBDb2x1bW5CdWlsZGVyIHtcbiAgY29uc3RydWN0b3IobWV0YWRhdGEpIHtcbiAgICBzdXBlcihuZXcgVHlwZUJ1aWxkZXIoQWxnZWJyYWljVHlwZS5BcnJheShBbGdlYnJhaWNUeXBlLlU4KSksIG1ldGFkYXRhKTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBfQnl0ZUFycmF5Q29sdW1uQnVpbGRlcihcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGRlZmF1bHRWYWx1ZTogdmFsdWUgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgX0J5dGVBcnJheUNvbHVtbkJ1aWxkZXIoc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgbmFtZSB9KSk7XG4gIH1cbn07XG52YXIgT3B0aW9uQ29sdW1uQnVpbGRlciA9IGNsYXNzIF9PcHRpb25Db2x1bW5CdWlsZGVyIGV4dGVuZHMgQ29sdW1uQnVpbGRlciB7XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IF9PcHRpb25Db2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7XG4gICAgICAgIGRlZmF1bHRWYWx1ZTogdmFsdWVcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IF9PcHRpb25Db2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IG5hbWUgfSlcbiAgICApO1xuICB9XG59O1xudmFyIFJlc3VsdENvbHVtbkJ1aWxkZXIgPSBjbGFzcyBfUmVzdWx0Q29sdW1uQnVpbGRlciBleHRlbmRzIENvbHVtbkJ1aWxkZXIge1xuICBjb25zdHJ1Y3Rvcih0eXBlQnVpbGRlciwgbWV0YWRhdGEpIHtcbiAgICBzdXBlcih0eXBlQnVpbGRlciwgbWV0YWRhdGEpO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IF9SZXN1bHRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7XG4gICAgICAgIGRlZmF1bHRWYWx1ZTogdmFsdWVcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxufTtcbnZhciBQcm9kdWN0Q29sdW1uQnVpbGRlciA9IGNsYXNzIF9Qcm9kdWN0Q29sdW1uQnVpbGRlciBleHRlbmRzIENvbHVtbkJ1aWxkZXIge1xuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBfUHJvZHVjdENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgZGVmYXVsdFZhbHVlOiB2YWx1ZSB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBfUHJvZHVjdENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgbmFtZSB9KVxuICAgICk7XG4gIH1cbn07XG52YXIgU3VtQ29sdW1uQnVpbGRlciA9IGNsYXNzIF9TdW1Db2x1bW5CdWlsZGVyIGV4dGVuZHMgQ29sdW1uQnVpbGRlciB7XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IF9TdW1Db2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGRlZmF1bHRWYWx1ZTogdmFsdWUgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgX1N1bUNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgbmFtZSB9KVxuICAgICk7XG4gIH1cbn07XG52YXIgU2ltcGxlU3VtQ29sdW1uQnVpbGRlciA9IGNsYXNzIF9TaW1wbGVTdW1Db2x1bW5CdWlsZGVyIGV4dGVuZHMgU3VtQ29sdW1uQnVpbGRlciB7XG4gIGluZGV4KGFsZ29yaXRobSA9IFwiYnRyZWVcIikge1xuICAgIHJldHVybiBuZXcgX1NpbXBsZVN1bUNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaW5kZXhUeXBlOiBhbGdvcml0aG0gfSlcbiAgICApO1xuICB9XG4gIHByaW1hcnlLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBfU2ltcGxlU3VtQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc1ByaW1hcnlLZXk6IHRydWUgfSlcbiAgICApO1xuICB9XG59O1xudmFyIFNjaGVkdWxlQXRDb2x1bW5CdWlsZGVyID0gY2xhc3MgX1NjaGVkdWxlQXRDb2x1bW5CdWlsZGVyIGV4dGVuZHMgQ29sdW1uQnVpbGRlciB7XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IF9TY2hlZHVsZUF0Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBkZWZhdWx0VmFsdWU6IHZhbHVlIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IF9TY2hlZHVsZUF0Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBuYW1lIH0pXG4gICAgKTtcbiAgfVxufTtcbnZhciBJZGVudGl0eUNvbHVtbkJ1aWxkZXIgPSBjbGFzcyBfSWRlbnRpdHlDb2x1bW5CdWlsZGVyIGV4dGVuZHMgQ29sdW1uQnVpbGRlciB7XG4gIGluZGV4KGFsZ29yaXRobSA9IFwiYnRyZWVcIikge1xuICAgIHJldHVybiBuZXcgX0lkZW50aXR5Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpbmRleFR5cGU6IGFsZ29yaXRobSB9KVxuICAgICk7XG4gIH1cbiAgdW5pcXVlKCkge1xuICAgIHJldHVybiBuZXcgX0lkZW50aXR5Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc1VuaXF1ZTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgcHJpbWFyeUtleSgpIHtcbiAgICByZXR1cm4gbmV3IF9JZGVudGl0eUNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNQcmltYXJ5S2V5OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBfSWRlbnRpdHlDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGRlZmF1bHRWYWx1ZTogdmFsdWUgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgX0lkZW50aXR5Q29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBuYW1lIH0pXG4gICAgKTtcbiAgfVxufTtcbnZhciBDb25uZWN0aW9uSWRDb2x1bW5CdWlsZGVyID0gY2xhc3MgX0Nvbm5lY3Rpb25JZENvbHVtbkJ1aWxkZXIgZXh0ZW5kcyBDb2x1bW5CdWlsZGVyIHtcbiAgaW5kZXgoYWxnb3JpdGhtID0gXCJidHJlZVwiKSB7XG4gICAgcmV0dXJuIG5ldyBfQ29ubmVjdGlvbklkQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpbmRleFR5cGU6IGFsZ29yaXRobSB9KVxuICAgICk7XG4gIH1cbiAgdW5pcXVlKCkge1xuICAgIHJldHVybiBuZXcgX0Nvbm5lY3Rpb25JZENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNVbmlxdWU6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIHByaW1hcnlLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBfQ29ubmVjdGlvbklkQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc1ByaW1hcnlLZXk6IHRydWUgfSlcbiAgICApO1xuICB9XG4gIGRlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IF9Db25uZWN0aW9uSWRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGRlZmF1bHRWYWx1ZTogdmFsdWUgfSlcbiAgICApO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgX0Nvbm5lY3Rpb25JZENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgbmFtZSB9KVxuICAgICk7XG4gIH1cbn07XG52YXIgVGltZXN0YW1wQ29sdW1uQnVpbGRlciA9IGNsYXNzIF9UaW1lc3RhbXBDb2x1bW5CdWlsZGVyIGV4dGVuZHMgQ29sdW1uQnVpbGRlciB7XG4gIGluZGV4KGFsZ29yaXRobSA9IFwiYnRyZWVcIikge1xuICAgIHJldHVybiBuZXcgX1RpbWVzdGFtcENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaW5kZXhUeXBlOiBhbGdvcml0aG0gfSlcbiAgICApO1xuICB9XG4gIHVuaXF1ZSgpIHtcbiAgICByZXR1cm4gbmV3IF9UaW1lc3RhbXBDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzVW5pcXVlOiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBwcmltYXJ5S2V5KCkge1xuICAgIHJldHVybiBuZXcgX1RpbWVzdGFtcENvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgaXNQcmltYXJ5S2V5OiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBkZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBfVGltZXN0YW1wQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBkZWZhdWx0VmFsdWU6IHZhbHVlIH0pXG4gICAgKTtcbiAgfVxuICBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IF9UaW1lc3RhbXBDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IG5hbWUgfSlcbiAgICApO1xuICB9XG59O1xudmFyIFRpbWVEdXJhdGlvbkNvbHVtbkJ1aWxkZXIgPSBjbGFzcyBfVGltZUR1cmF0aW9uQ29sdW1uQnVpbGRlciBleHRlbmRzIENvbHVtbkJ1aWxkZXIge1xuICBpbmRleChhbGdvcml0aG0gPSBcImJ0cmVlXCIpIHtcbiAgICByZXR1cm4gbmV3IF9UaW1lRHVyYXRpb25Db2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGluZGV4VHlwZTogYWxnb3JpdGhtIH0pXG4gICAgKTtcbiAgfVxuICB1bmlxdWUoKSB7XG4gICAgcmV0dXJuIG5ldyBfVGltZUR1cmF0aW9uQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpc1VuaXF1ZTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgcHJpbWFyeUtleSgpIHtcbiAgICByZXR1cm4gbmV3IF9UaW1lRHVyYXRpb25Db2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzUHJpbWFyeUtleTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgX1RpbWVEdXJhdGlvbkNvbHVtbkJ1aWxkZXIoXG4gICAgICB0aGlzLnR5cGVCdWlsZGVyLFxuICAgICAgc2V0KHRoaXMuY29sdW1uTWV0YWRhdGEsIHsgZGVmYXVsdFZhbHVlOiB2YWx1ZSB9KVxuICAgICk7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBfVGltZUR1cmF0aW9uQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBuYW1lIH0pXG4gICAgKTtcbiAgfVxufTtcbnZhciBVdWlkQ29sdW1uQnVpbGRlciA9IGNsYXNzIF9VdWlkQ29sdW1uQnVpbGRlciBleHRlbmRzIENvbHVtbkJ1aWxkZXIge1xuICBpbmRleChhbGdvcml0aG0gPSBcImJ0cmVlXCIpIHtcbiAgICByZXR1cm4gbmV3IF9VdWlkQ29sdW1uQnVpbGRlcihcbiAgICAgIHRoaXMudHlwZUJ1aWxkZXIsXG4gICAgICBzZXQodGhpcy5jb2x1bW5NZXRhZGF0YSwgeyBpbmRleFR5cGU6IGFsZ29yaXRobSB9KVxuICAgICk7XG4gIH1cbiAgdW5pcXVlKCkge1xuICAgIHJldHVybiBuZXcgX1V1aWRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzVW5pcXVlOiB0cnVlIH0pXG4gICAgKTtcbiAgfVxuICBwcmltYXJ5S2V5KCkge1xuICAgIHJldHVybiBuZXcgX1V1aWRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGlzUHJpbWFyeUtleTogdHJ1ZSB9KVxuICAgICk7XG4gIH1cbiAgZGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgX1V1aWRDb2x1bW5CdWlsZGVyKFxuICAgICAgdGhpcy50eXBlQnVpbGRlcixcbiAgICAgIHNldCh0aGlzLmNvbHVtbk1ldGFkYXRhLCB7IGRlZmF1bHRWYWx1ZTogdmFsdWUgfSlcbiAgICApO1xuICB9XG59O1xudmFyIFJlZkJ1aWxkZXIgPSBjbGFzcyBleHRlbmRzIFR5cGVCdWlsZGVyIHtcbiAgcmVmO1xuICAvKiogVGhlIHBoYW50b20gdHlwZSBvZiB0aGUgcG9pbnRlZSBvZiB0aGlzIHJlZi4gKi9cbiAgX19zcGFjZXRpbWVUeXBlO1xuICBjb25zdHJ1Y3RvcihyZWYpIHtcbiAgICBzdXBlcihBbGdlYnJhaWNUeXBlLlJlZihyZWYpKTtcbiAgICB0aGlzLnJlZiA9IHJlZjtcbiAgfVxufTtcbnZhciBlbnVtSW1wbCA9ICgobmFtZU9yT2JqLCBtYXliZU9iaikgPT4ge1xuICBsZXQgb2JqID0gbmFtZU9yT2JqO1xuICBsZXQgbmFtZSA9IHZvaWQgMDtcbiAgaWYgKHR5cGVvZiBuYW1lT3JPYmogPT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAoIW1heWJlT2JqKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBcIldoZW4gcHJvdmlkaW5nIGEgbmFtZSwgeW91IG11c3QgYWxzbyBwcm92aWRlIHRoZSB2YXJpYW50cyBvYmplY3Qgb3IgYXJyYXkuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIG9iaiA9IG1heWJlT2JqO1xuICAgIG5hbWUgPSBuYW1lT3JPYmo7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgIGNvbnN0IHNpbXBsZVZhcmlhbnRzT2JqID0ge307XG4gICAgZm9yIChjb25zdCB2YXJpYW50IG9mIG9iaikge1xuICAgICAgc2ltcGxlVmFyaWFudHNPYmpbdmFyaWFudF0gPSBuZXcgVW5pdEJ1aWxkZXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTaW1wbGVTdW1CdWlsZGVySW1wbChzaW1wbGVWYXJpYW50c09iaiwgbmFtZSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBTdW1CdWlsZGVyKG9iaiwgbmFtZSk7XG59KTtcbnZhciB0ID0ge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBgQm9vbGAge0BsaW5rIEFsZ2VicmFpY1R5cGV9IHRvIGJlIHVzZWQgaW4gdGFibGUgZGVmaW5pdGlvbnNcbiAgICogUmVwcmVzZW50ZWQgYXMgYGJvb2xlYW5gIGluIFR5cGVTY3JpcHQuXG4gICAqIEByZXR1cm5zIEEgbmV3IHtAbGluayBCb29sQnVpbGRlcn0gaW5zdGFuY2VcbiAgICovXG4gIGJvb2w6ICgpID0+IG5ldyBCb29sQnVpbGRlcigpLFxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBgU3RyaW5nYCB7QGxpbmsgQWxnZWJyYWljVHlwZX0gdG8gYmUgdXNlZCBpbiB0YWJsZSBkZWZpbml0aW9uc1xuICAgKiBSZXByZXNlbnRlZCBhcyBgc3RyaW5nYCBpbiBUeXBlU2NyaXB0LlxuICAgKiBAcmV0dXJucyBBIG5ldyB7QGxpbmsgU3RyaW5nQnVpbGRlcn0gaW5zdGFuY2VcbiAgICovXG4gIHN0cmluZzogKCkgPT4gbmV3IFN0cmluZ0J1aWxkZXIoKSxcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYEY2NGAge0BsaW5rIEFsZ2VicmFpY1R5cGV9IHRvIGJlIHVzZWQgaW4gdGFibGUgZGVmaW5pdGlvbnNcbiAgICogUmVwcmVzZW50ZWQgYXMgYG51bWJlcmAgaW4gVHlwZVNjcmlwdC5cbiAgICogQHJldHVybnMgQSBuZXcge0BsaW5rIEY2NEJ1aWxkZXJ9IGluc3RhbmNlXG4gICAqL1xuICBudW1iZXI6ICgpID0+IG5ldyBGNjRCdWlsZGVyKCksXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGBJOGAge0BsaW5rIEFsZ2VicmFpY1R5cGV9IHRvIGJlIHVzZWQgaW4gdGFibGUgZGVmaW5pdGlvbnNcbiAgICogUmVwcmVzZW50ZWQgYXMgYG51bWJlcmAgaW4gVHlwZVNjcmlwdC5cbiAgICogQHJldHVybnMgQSBuZXcge0BsaW5rIEk4QnVpbGRlcn0gaW5zdGFuY2VcbiAgICovXG4gIGk4OiAoKSA9PiBuZXcgSThCdWlsZGVyKCksXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGBVOGAge0BsaW5rIEFsZ2VicmFpY1R5cGV9IHRvIGJlIHVzZWQgaW4gdGFibGUgZGVmaW5pdGlvbnNcbiAgICogUmVwcmVzZW50ZWQgYXMgYG51bWJlcmAgaW4gVHlwZVNjcmlwdC5cbiAgICogQHJldHVybnMgQSBuZXcge0BsaW5rIFU4QnVpbGRlcn0gaW5zdGFuY2VcbiAgICovXG4gIHU4OiAoKSA9PiBuZXcgVThCdWlsZGVyKCksXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGBJMTZgIHtAbGluayBBbGdlYnJhaWNUeXBlfSB0byBiZSB1c2VkIGluIHRhYmxlIGRlZmluaXRpb25zXG4gICAqIFJlcHJlc2VudGVkIGFzIGBudW1iZXJgIGluIFR5cGVTY3JpcHQuXG4gICAqIEByZXR1cm5zIEEgbmV3IHtAbGluayBJMTZCdWlsZGVyfSBpbnN0YW5jZVxuICAgKi9cbiAgaTE2OiAoKSA9PiBuZXcgSTE2QnVpbGRlcigpLFxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBgVTE2YCB7QGxpbmsgQWxnZWJyYWljVHlwZX0gdG8gYmUgdXNlZCBpbiB0YWJsZSBkZWZpbml0aW9uc1xuICAgKiBSZXByZXNlbnRlZCBhcyBgbnVtYmVyYCBpbiBUeXBlU2NyaXB0LlxuICAgKiBAcmV0dXJucyBBIG5ldyB7QGxpbmsgVTE2QnVpbGRlcn0gaW5zdGFuY2VcbiAgICovXG4gIHUxNjogKCkgPT4gbmV3IFUxNkJ1aWxkZXIoKSxcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYEkzMmAge0BsaW5rIEFsZ2VicmFpY1R5cGV9IHRvIGJlIHVzZWQgaW4gdGFibGUgZGVmaW5pdGlvbnNcbiAgICogUmVwcmVzZW50ZWQgYXMgYG51bWJlcmAgaW4gVHlwZVNjcmlwdC5cbiAgICogQHJldHVybnMgQSBuZXcge0BsaW5rIEkzMkJ1aWxkZXJ9IGluc3RhbmNlXG4gICAqL1xuICBpMzI6ICgpID0+IG5ldyBJMzJCdWlsZGVyKCksXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGBVMzJgIHtAbGluayBBbGdlYnJhaWNUeXBlfSB0byBiZSB1c2VkIGluIHRhYmxlIGRlZmluaXRpb25zXG4gICAqIFJlcHJlc2VudGVkIGFzIGBudW1iZXJgIGluIFR5cGVTY3JpcHQuXG4gICAqIEByZXR1cm5zIEEgbmV3IHtAbGluayBVMzJCdWlsZGVyfSBpbnN0YW5jZVxuICAgKi9cbiAgdTMyOiAoKSA9PiBuZXcgVTMyQnVpbGRlcigpLFxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBgSTY0YCB7QGxpbmsgQWxnZWJyYWljVHlwZX0gdG8gYmUgdXNlZCBpbiB0YWJsZSBkZWZpbml0aW9uc1xuICAgKiBSZXByZXNlbnRlZCBhcyBgYmlnaW50YCBpbiBUeXBlU2NyaXB0LlxuICAgKiBAcmV0dXJucyBBIG5ldyB7QGxpbmsgSTY0QnVpbGRlcn0gaW5zdGFuY2VcbiAgICovXG4gIGk2NDogKCkgPT4gbmV3IEk2NEJ1aWxkZXIoKSxcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYFU2NGAge0BsaW5rIEFsZ2VicmFpY1R5cGV9IHRvIGJlIHVzZWQgaW4gdGFibGUgZGVmaW5pdGlvbnNcbiAgICogUmVwcmVzZW50ZWQgYXMgYGJpZ2ludGAgaW4gVHlwZVNjcmlwdC5cbiAgICogQHJldHVybnMgQSBuZXcge0BsaW5rIFU2NEJ1aWxkZXJ9IGluc3RhbmNlXG4gICAqL1xuICB1NjQ6ICgpID0+IG5ldyBVNjRCdWlsZGVyKCksXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGBJMTI4YCB7QGxpbmsgQWxnZWJyYWljVHlwZX0gdG8gYmUgdXNlZCBpbiB0YWJsZSBkZWZpbml0aW9uc1xuICAgKiBSZXByZXNlbnRlZCBhcyBgYmlnaW50YCBpbiBUeXBlU2NyaXB0LlxuICAgKiBAcmV0dXJucyBBIG5ldyB7QGxpbmsgSTEyOEJ1aWxkZXJ9IGluc3RhbmNlXG4gICAqL1xuICBpMTI4OiAoKSA9PiBuZXcgSTEyOEJ1aWxkZXIoKSxcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYFUxMjhgIHtAbGluayBBbGdlYnJhaWNUeXBlfSB0byBiZSB1c2VkIGluIHRhYmxlIGRlZmluaXRpb25zXG4gICAqIFJlcHJlc2VudGVkIGFzIGBiaWdpbnRgIGluIFR5cGVTY3JpcHQuXG4gICAqIEByZXR1cm5zIEEgbmV3IHtAbGluayBVMTI4QnVpbGRlcn0gaW5zdGFuY2VcbiAgICovXG4gIHUxMjg6ICgpID0+IG5ldyBVMTI4QnVpbGRlcigpLFxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBgSTI1NmAge0BsaW5rIEFsZ2VicmFpY1R5cGV9IHRvIGJlIHVzZWQgaW4gdGFibGUgZGVmaW5pdGlvbnNcbiAgICogUmVwcmVzZW50ZWQgYXMgYGJpZ2ludGAgaW4gVHlwZVNjcmlwdC5cbiAgICogQHJldHVybnMgQSBuZXcge0BsaW5rIEkyNTZCdWlsZGVyfSBpbnN0YW5jZVxuICAgKi9cbiAgaTI1NjogKCkgPT4gbmV3IEkyNTZCdWlsZGVyKCksXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGBVMjU2YCB7QGxpbmsgQWxnZWJyYWljVHlwZX0gdG8gYmUgdXNlZCBpbiB0YWJsZSBkZWZpbml0aW9uc1xuICAgKiBSZXByZXNlbnRlZCBhcyBgYmlnaW50YCBpbiBUeXBlU2NyaXB0LlxuICAgKiBAcmV0dXJucyBBIG5ldyB7QGxpbmsgVTI1NkJ1aWxkZXJ9IGluc3RhbmNlXG4gICAqL1xuICB1MjU2OiAoKSA9PiBuZXcgVTI1NkJ1aWxkZXIoKSxcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYEYzMmAge0BsaW5rIEFsZ2VicmFpY1R5cGV9IHRvIGJlIHVzZWQgaW4gdGFibGUgZGVmaW5pdGlvbnNcbiAgICogUmVwcmVzZW50ZWQgYXMgYG51bWJlcmAgaW4gVHlwZVNjcmlwdC5cbiAgICogQHJldHVybnMgQSBuZXcge0BsaW5rIEYzMkJ1aWxkZXJ9IGluc3RhbmNlXG4gICAqL1xuICBmMzI6ICgpID0+IG5ldyBGMzJCdWlsZGVyKCksXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGBGNjRgIHtAbGluayBBbGdlYnJhaWNUeXBlfSB0byBiZSB1c2VkIGluIHRhYmxlIGRlZmluaXRpb25zXG4gICAqIFJlcHJlc2VudGVkIGFzIGBudW1iZXJgIGluIFR5cGVTY3JpcHQuXG4gICAqIEByZXR1cm5zIEEgbmV3IHtAbGluayBGNjRCdWlsZGVyfSBpbnN0YW5jZVxuICAgKi9cbiAgZjY0OiAoKSA9PiBuZXcgRjY0QnVpbGRlcigpLFxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBgUHJvZHVjdGAge0BsaW5rIEFsZ2VicmFpY1R5cGV9IHRvIGJlIHVzZWQgaW4gdGFibGUgZGVmaW5pdGlvbnMuIFByb2R1Y3QgdHlwZXMgaW4gU3BhY2V0aW1lREJcbiAgICogYXJlIGVzc2VudGlhbGx5IHRoZSBzYW1lIGFzIG9iamVjdHMgaW4gSmF2YVNjcmlwdC9UeXBlU2NyaXB0LlxuICAgKiBQcm9wZXJ0aWVzIG9mIHRoZSBvYmplY3QgbXVzdCBhbHNvIGJlIHtAbGluayBUeXBlQnVpbGRlcn1zLlxuICAgKiBSZXByZXNlbnRlZCBhcyBhbiBvYmplY3Qgd2l0aCBzcGVjaWZpYyBwcm9wZXJ0aWVzIGluIFR5cGVTY3JpcHQuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIChvcHRpb25hbCkgQSBkaXNwbGF5IG5hbWUgZm9yIHRoZSBwcm9kdWN0IHR5cGUuIElmIG9taXR0ZWQsIGFuIGFub255bW91cyBwcm9kdWN0IHR5cGUgaXMgY3JlYXRlZC5cbiAgICogQHBhcmFtIG9iaiBUaGUgb2JqZWN0IGRlZmluaW5nIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSB0eXBlLCB3aG9zZSBwcm9wZXJ0eVxuICAgKiB2YWx1ZXMgbXVzdCBiZSB7QGxpbmsgVHlwZUJ1aWxkZXJ9cy5cbiAgICogQHJldHVybnMgQSBuZXcge0BsaW5rIFByb2R1Y3RCdWlsZGVyfSBpbnN0YW5jZS5cbiAgICovXG4gIG9iamVjdDogKChuYW1lT3JPYmosIG1heWJlT2JqKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBuYW1lT3JPYmogPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGlmICghbWF5YmVPYmopIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIldoZW4gcHJvdmlkaW5nIGEgbmFtZSwgeW91IG11c3QgYWxzbyBwcm92aWRlIHRoZSBvYmplY3QuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgUHJvZHVjdEJ1aWxkZXIobWF5YmVPYmosIG5hbWVPck9iaik7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvZHVjdEJ1aWxkZXIobmFtZU9yT2JqLCB2b2lkIDApO1xuICB9KSxcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYFJvd2Age0BsaW5rIEFsZ2VicmFpY1R5cGV9IHRvIGJlIHVzZWQgaW4gdGFibGUgZGVmaW5pdGlvbnMuIFJvdyB0eXBlcyBpbiBTcGFjZXRpbWVEQlxuICAgKiBhcmUgc2ltaWxhciB0byBgUHJvZHVjdGAgdHlwZXMsIGJ1dCBhcmUgc3BlY2lmaWNhbGx5IHVzZWQgdG8gZGVmaW5lIHRoZSBzY2hlbWEgb2YgYSB0YWJsZSByb3cuXG4gICAqIFByb3BlcnRpZXMgb2YgdGhlIG9iamVjdCBtdXN0IGFsc28gYmUge0BsaW5rIFR5cGVCdWlsZGVyfSBvciB7QGxpbmsgQ29sdW1uQnVpbGRlcn1zLlxuICAgKlxuICAgKiBZb3UgY2FuIHJlcHJlc2VudCBhIGBSb3dgIGFzIGVpdGhlciBhIHtAbGluayBSb3dPYmp9IG9yIGFuIHtAbGluayBSb3dCdWlsZGVyfSB0eXBlIHdoZW5cbiAgICogZGVmaW5pbmcgYSB0YWJsZSBzY2hlbWEuXG4gICAqXG4gICAqIFRoZSB7QGxpbmsgUm93QnVpbGRlcn0gdHlwZSBpcyB1c2VmdWwgd2hlbiB5b3Ugd2FudCB0byBjcmVhdGUgYSB0eXBlIHdoaWNoIGNhbiBiZSB1c2VkIGFueXdoZXJlXG4gICAqIGEge0BsaW5rIFR5cGVCdWlsZGVyfSBpcyBhY2NlcHRlZCwgc3VjaCBhcyBpbiBuZXN0ZWQgb2JqZWN0cyBvciBhcnJheXMsIG9yIGFzIHRoZSBhcmd1bWVudFxuICAgKiB0byBhIHNjaGVkdWxlZCBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIG9iaiBUaGUgb2JqZWN0IGRlZmluaW5nIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSByb3csIHdob3NlIHByb3BlcnR5XG4gICAqIHZhbHVlcyBtdXN0IGJlIHtAbGluayBUeXBlQnVpbGRlcn1zIG9yIHtAbGluayBDb2x1bW5CdWlsZGVyfXMuXG4gICAqIEByZXR1cm5zIEEgbmV3IHtAbGluayBSb3dCdWlsZGVyfSBpbnN0YW5jZVxuICAgKi9cbiAgcm93OiAoKG5hbWVPck9iaiwgbWF5YmVPYmopID0+IHtcbiAgICBjb25zdCBbb2JqLCBuYW1lXSA9IHR5cGVvZiBuYW1lT3JPYmogPT09IFwic3RyaW5nXCIgPyBbbWF5YmVPYmosIG5hbWVPck9ial0gOiBbbmFtZU9yT2JqLCB2b2lkIDBdO1xuICAgIHJldHVybiBuZXcgUm93QnVpbGRlcihvYmosIG5hbWUpO1xuICB9KSxcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYEFycmF5YCB7QGxpbmsgQWxnZWJyYWljVHlwZX0gdG8gYmUgdXNlZCBpbiB0YWJsZSBkZWZpbml0aW9ucy5cbiAgICogUmVwcmVzZW50ZWQgYXMgYW4gYXJyYXkgaW4gVHlwZVNjcmlwdC5cbiAgICogQHBhcmFtIGVsZW1lbnQgVGhlIGVsZW1lbnQgdHlwZSBvZiB0aGUgYXJyYXksIHdoaWNoIG11c3QgYmUgYSBgVHlwZUJ1aWxkZXJgLlxuICAgKiBAcmV0dXJucyBBIG5ldyB7QGxpbmsgQXJyYXlCdWlsZGVyfSBpbnN0YW5jZVxuICAgKi9cbiAgYXJyYXkoZSkge1xuICAgIHJldHVybiBuZXcgQXJyYXlCdWlsZGVyKGUpO1xuICB9LFxuICBlbnVtOiBlbnVtSW1wbCxcbiAgLyoqXG4gICAqIFRoaXMgaXMgYSBzcGVjaWFsIGhlbHBlciBmdW5jdGlvbiBmb3IgY29udmVuaWVudGx5IGNyZWF0aW5nIHtAbGluayBQcm9kdWN0fSB0eXBlIGNvbHVtbnMgd2l0aCBubyBmaWVsZHMuXG4gICAqXG4gICAqIEByZXR1cm5zIEEgbmV3IHtAbGluayBQcm9kdWN0QnVpbGRlcn0gaW5zdGFuY2Ugd2l0aCBubyBmaWVsZHMuXG4gICAqL1xuICB1bml0KCkge1xuICAgIHJldHVybiBuZXcgVW5pdEJ1aWxkZXIoKTtcbiAgfSxcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBsYXppbHktZXZhbHVhdGVkIHtAbGluayBUeXBlQnVpbGRlcn0uIFRoaXMgaXMgdXNlZnVsIGZvciBjcmVhdGluZ1xuICAgKiByZWN1cnNpdmUgdHlwZXMsIHN1Y2ggYXMgYSB0cmVlIG9yIGxpbmtlZCBsaXN0LlxuICAgKiBAcGFyYW0gdGh1bmsgQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSB7QGxpbmsgVHlwZUJ1aWxkZXJ9LlxuICAgKiBAcmV0dXJucyBBIHByb3h5IHtAbGluayBUeXBlQnVpbGRlcn0gdGhhdCBldmFsdWF0ZXMgdGhlIHRodW5rIG9uIGZpcnN0IGFjY2Vzcy5cbiAgICovXG4gIGxhenkodGh1bmspIHtcbiAgICBsZXQgY2FjaGVkID0gbnVsbDtcbiAgICBjb25zdCBnZXQgPSAoKSA9PiBjYWNoZWQgPz89IHRodW5rKCk7XG4gICAgY29uc3QgcHJveHkgPSBuZXcgUHJveHkoe30sIHtcbiAgICAgIGdldChfdCwgcHJvcCwgcmVjdikge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBnZXQoKTtcbiAgICAgICAgY29uc3QgdmFsID0gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWN2KTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09IFwiZnVuY3Rpb25cIiA/IHZhbC5iaW5kKHRhcmdldCkgOiB2YWw7XG4gICAgICB9LFxuICAgICAgc2V0KF90LCBwcm9wLCB2YWx1ZSwgcmVjdikge1xuICAgICAgICByZXR1cm4gUmVmbGVjdC5zZXQoZ2V0KCksIHByb3AsIHZhbHVlLCByZWN2KTtcbiAgICAgIH0sXG4gICAgICBoYXMoX3QsIHByb3ApIHtcbiAgICAgICAgcmV0dXJuIHByb3AgaW4gZ2V0KCk7XG4gICAgICB9LFxuICAgICAgb3duS2V5cygpIHtcbiAgICAgICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyhnZXQoKSk7XG4gICAgICB9LFxuICAgICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKF90LCBwcm9wKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGdldCgpLCBwcm9wKTtcbiAgICAgIH0sXG4gICAgICBnZXRQcm90b3R5cGVPZigpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihnZXQoKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb3h5O1xuICB9LFxuICAvKipcbiAgICogVGhpcyBpcyBhIHNwZWNpYWwgaGVscGVyIGZ1bmN0aW9uIGZvciBjb252ZW5pZW50bHkgY3JlYXRpbmcge0BsaW5rIFNjaGVkdWxlQXR9IHR5cGUgY29sdW1ucy5cbiAgICogQHJldHVybnMgQSBuZXcgQ29sdW1uQnVpbGRlciBpbnN0YW5jZSB3aXRoIHRoZSB7QGxpbmsgU2NoZWR1bGVBdH0gdHlwZS5cbiAgICovXG4gIHNjaGVkdWxlQXQ6ICgpID0+IHtcbiAgICByZXR1cm4gbmV3IFNjaGVkdWxlQXRCdWlsZGVyKCk7XG4gIH0sXG4gIC8qKlxuICAgKiBUaGlzIGlzIGEgY29udmVuaWVuY2UgbWV0aG9kIGZvciBjcmVhdGluZyBhIGNvbHVtbiB3aXRoIHRoZSB7QGxpbmsgT3B0aW9ufSB0eXBlLlxuICAgKiBZb3UgY2FuIGNyZWF0ZSBhIGNvbHVtbiBvZiB0aGUgc2FtZSB0eXBlIGJ5IGNvbnN0cnVjdGluZyBhbiBlbnVtIHdpdGggYSBgc29tZWAgYW5kIGBub25lYCB2YXJpYW50LlxuICAgKiBAcGFyYW0gdmFsdWUgVGhlIHR5cGUgb2YgdGhlIHZhbHVlIGNvbnRhaW5lZCBpbiB0aGUgYHNvbWVgIHZhcmlhbnQgb2YgdGhlIGBPcHRpb25gLlxuICAgKiBAcmV0dXJucyBBIG5ldyB7QGxpbmsgT3B0aW9uQnVpbGRlcn0gaW5zdGFuY2Ugd2l0aCB0aGUge0BsaW5rIE9wdGlvbn0gdHlwZS5cbiAgICovXG4gIG9wdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgT3B0aW9uQnVpbGRlcih2YWx1ZSk7XG4gIH0sXG4gIC8qKlxuICAgKiBUaGlzIGlzIGEgY29udmVuaWVuY2UgbWV0aG9kIGZvciBjcmVhdGluZyBhIGNvbHVtbiB3aXRoIHRoZSB7QGxpbmsgUmVzdWx0fSB0eXBlLlxuICAgKiBZb3UgY2FuIGNyZWF0ZSBhIGNvbHVtbiBvZiB0aGUgc2FtZSB0eXBlIGJ5IGNvbnN0cnVjdGluZyBhbiBlbnVtIHdpdGggYW4gYG9rYCBhbmQgYGVycmAgdmFyaWFudC5cbiAgICogQHBhcmFtIG9rIFRoZSB0eXBlIG9mIHRoZSB2YWx1ZSBjb250YWluZWQgaW4gdGhlIGBva2AgdmFyaWFudCBvZiB0aGUgYFJlc3VsdGAuXG4gICAqIEBwYXJhbSBlcnIgVGhlIHR5cGUgb2YgdGhlIHZhbHVlIGNvbnRhaW5lZCBpbiB0aGUgYGVycmAgdmFyaWFudCBvZiB0aGUgYFJlc3VsdGAuXG4gICAqIEByZXR1cm5zIEEgbmV3IHtAbGluayBSZXN1bHRCdWlsZGVyfSBpbnN0YW5jZSB3aXRoIHRoZSB7QGxpbmsgUmVzdWx0fSB0eXBlLlxuICAgKi9cbiAgcmVzdWx0KG9rLCBlcnIpIHtcbiAgICByZXR1cm4gbmV3IFJlc3VsdEJ1aWxkZXIob2ssIGVycik7XG4gIH0sXG4gIC8qKlxuICAgKiBUaGlzIGlzIGEgY29udmVuaWVuY2UgbWV0aG9kIGZvciBjcmVhdGluZyBhIGNvbHVtbiB3aXRoIHRoZSB7QGxpbmsgSWRlbnRpdHl9IHR5cGUuXG4gICAqIFlvdSBjYW4gY3JlYXRlIGEgY29sdW1uIG9mIHRoZSBzYW1lIHR5cGUgYnkgY29uc3RydWN0aW5nIGFuIGBvYmplY3RgIHdpdGggYSBzaW5nbGUgYF9faWRlbnRpdHlfX2AgZWxlbWVudC5cbiAgICogQHJldHVybnMgQSBuZXcge0BsaW5rIFR5cGVCdWlsZGVyfSBpbnN0YW5jZSB3aXRoIHRoZSB7QGxpbmsgSWRlbnRpdHl9IHR5cGUuXG4gICAqL1xuICBpZGVudGl0eTogKCkgPT4ge1xuICAgIHJldHVybiBuZXcgSWRlbnRpdHlCdWlsZGVyKCk7XG4gIH0sXG4gIC8qKlxuICAgKiBUaGlzIGlzIGEgY29udmVuaWVuY2UgbWV0aG9kIGZvciBjcmVhdGluZyBhIGNvbHVtbiB3aXRoIHRoZSB7QGxpbmsgQ29ubmVjdGlvbklkfSB0eXBlLlxuICAgKiBZb3UgY2FuIGNyZWF0ZSBhIGNvbHVtbiBvZiB0aGUgc2FtZSB0eXBlIGJ5IGNvbnN0cnVjdGluZyBhbiBgb2JqZWN0YCB3aXRoIGEgc2luZ2xlIGBfX2Nvbm5lY3Rpb25faWRfX2AgZWxlbWVudC5cbiAgICogQHJldHVybnMgQSBuZXcge0BsaW5rIFR5cGVCdWlsZGVyfSBpbnN0YW5jZSB3aXRoIHRoZSB7QGxpbmsgQ29ubmVjdGlvbklkfSB0eXBlLlxuICAgKi9cbiAgY29ubmVjdGlvbklkOiAoKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBDb25uZWN0aW9uSWRCdWlsZGVyKCk7XG4gIH0sXG4gIC8qKlxuICAgKiBUaGlzIGlzIGEgY29udmVuaWVuY2UgbWV0aG9kIGZvciBjcmVhdGluZyBhIGNvbHVtbiB3aXRoIHRoZSB7QGxpbmsgVGltZXN0YW1wfSB0eXBlLlxuICAgKiBZb3UgY2FuIGNyZWF0ZSBhIGNvbHVtbiBvZiB0aGUgc2FtZSB0eXBlIGJ5IGNvbnN0cnVjdGluZyBhbiBgb2JqZWN0YCB3aXRoIGEgc2luZ2xlIGBfX3RpbWVzdGFtcF9taWNyb3Nfc2luY2VfdW5peF9lcG9jaF9fYCBlbGVtZW50LlxuICAgKiBAcmV0dXJucyBBIG5ldyB7QGxpbmsgVHlwZUJ1aWxkZXJ9IGluc3RhbmNlIHdpdGggdGhlIHtAbGluayBUaW1lc3RhbXB9IHR5cGUuXG4gICAqL1xuICB0aW1lc3RhbXA6ICgpID0+IHtcbiAgICByZXR1cm4gbmV3IFRpbWVzdGFtcEJ1aWxkZXIoKTtcbiAgfSxcbiAgLyoqXG4gICAqIFRoaXMgaXMgYSBjb252ZW5pZW5jZSBtZXRob2QgZm9yIGNyZWF0aW5nIGEgY29sdW1uIHdpdGggdGhlIHtAbGluayBUaW1lRHVyYXRpb259IHR5cGUuXG4gICAqIFlvdSBjYW4gY3JlYXRlIGEgY29sdW1uIG9mIHRoZSBzYW1lIHR5cGUgYnkgY29uc3RydWN0aW5nIGFuIGBvYmplY3RgIHdpdGggYSBzaW5nbGUgYF9fdGltZV9kdXJhdGlvbl9taWNyb3NfX2AgZWxlbWVudC5cbiAgICogQHJldHVybnMgQSBuZXcge0BsaW5rIFR5cGVCdWlsZGVyfSBpbnN0YW5jZSB3aXRoIHRoZSB7QGxpbmsgVGltZUR1cmF0aW9ufSB0eXBlLlxuICAgKi9cbiAgdGltZUR1cmF0aW9uOiAoKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBUaW1lRHVyYXRpb25CdWlsZGVyKCk7XG4gIH0sXG4gIC8qKlxuICAgKiBUaGlzIGlzIGEgY29udmVuaWVuY2UgbWV0aG9kIGZvciBjcmVhdGluZyBhIGNvbHVtbiB3aXRoIHRoZSB7QGxpbmsgVXVpZH0gdHlwZS5cbiAgICogWW91IGNhbiBjcmVhdGUgYSBjb2x1bW4gb2YgdGhlIHNhbWUgdHlwZSBieSBjb25zdHJ1Y3RpbmcgYW4gYG9iamVjdGAgd2l0aCBhIHNpbmdsZSBgX191dWlkX19gIGVsZW1lbnQuXG4gICAqIEByZXR1cm5zIEEgbmV3IHtAbGluayBUeXBlQnVpbGRlcn0gaW5zdGFuY2Ugd2l0aCB0aGUge0BsaW5rIFV1aWR9IHR5cGUuXG4gICAqL1xuICB1dWlkOiAoKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBVdWlkQnVpbGRlcigpO1xuICB9LFxuICAvKipcbiAgICogVGhpcyBpcyBhIGNvbnZlbmllbmNlIG1ldGhvZCBmb3IgY3JlYXRpbmcgYSBjb2x1bW4gd2l0aCB0aGUge0BsaW5rIEJ5dGVBcnJheX0gdHlwZS5cbiAgICogWW91IGNhbiBjcmVhdGUgYSBjb2x1bW4gb2YgdGhlIHNhbWUgdHlwZSBieSBjb25zdHJ1Y3RpbmcgYW4gYGFycmF5YCBvZiBgdThgLlxuICAgKiBUaGUgVHlwZVNjcmlwdCByZXByZXNlbnRhdGlvbiBpcyB7QGxpbmsgVWludDhBcnJheX0uXG4gICAqIEByZXR1cm5zIEEgbmV3IHtAbGluayBCeXRlQXJyYXlCdWlsZGVyfSBpbnN0YW5jZSB3aXRoIHRoZSB7QGxpbmsgQnl0ZUFycmF5fSB0eXBlLlxuICAgKi9cbiAgYnl0ZUFycmF5OiAoKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBCeXRlQXJyYXlCdWlsZGVyKCk7XG4gIH1cbn07XG5cbi8vIHNyYy9saWIvYXV0b2dlbi9saWZlY3ljbGVfdHlwZS50c1xudmFyIExpZmVjeWNsZSA9IHQuZW51bShcIkxpZmVjeWNsZVwiLCB7XG4gIEluaXQ6IHQudW5pdCgpLFxuICBPbkNvbm5lY3Q6IHQudW5pdCgpLFxuICBPbkRpc2Nvbm5lY3Q6IHQudW5pdCgpXG59KTtcbnZhciBsaWZlY3ljbGVfdHlwZV9kZWZhdWx0ID0gTGlmZWN5Y2xlO1xuXG4vLyBzcmMvbGliL3JlZHVjZXJzLnRzXG5mdW5jdGlvbiBwdXNoUmVkdWNlcihuYW1lLCBwYXJhbXMsIGZuLCBsaWZlY3ljbGUpIHtcbiAgaWYgKGV4aXN0aW5nUmVkdWNlcnMuaGFzKG5hbWUpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlcmUgaXMgYWxyZWFkeSBhIHJlZHVjZXIgd2l0aCB0aGUgbmFtZSAnJHtuYW1lfSdgKTtcbiAgfVxuICBleGlzdGluZ1JlZHVjZXJzLmFkZChuYW1lKTtcbiAgaWYgKCEocGFyYW1zIGluc3RhbmNlb2YgUm93QnVpbGRlcikpIHtcbiAgICBwYXJhbXMgPSBuZXcgUm93QnVpbGRlcihwYXJhbXMpO1xuICB9XG4gIGlmIChwYXJhbXMudHlwZU5hbWUgPT09IHZvaWQgMCkge1xuICAgIHBhcmFtcy50eXBlTmFtZSA9IHRvUGFzY2FsQ2FzZShuYW1lKTtcbiAgfVxuICBjb25zdCByZWYgPSByZWdpc3RlclR5cGVzUmVjdXJzaXZlbHkocGFyYW1zKTtcbiAgY29uc3QgcGFyYW1zVHlwZSA9IHJlc29sdmVUeXBlKE1PRFVMRV9ERUYudHlwZXNwYWNlLCByZWYpLnZhbHVlO1xuICBNT0RVTEVfREVGLnJlZHVjZXJzLnB1c2goe1xuICAgIG5hbWUsXG4gICAgcGFyYW1zOiBwYXJhbXNUeXBlLFxuICAgIGxpZmVjeWNsZVxuICAgIC8vIDwtIGxpZmVjeWNsZSBmbGFnIGxhbmRzIGhlcmVcbiAgfSk7XG4gIGlmICghZm4ubmFtZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwgXCJuYW1lXCIsIHsgdmFsdWU6IG5hbWUsIHdyaXRhYmxlOiBmYWxzZSB9KTtcbiAgfVxuICBSRURVQ0VSUy5wdXNoKGZuKTtcbn1cbnZhciBleGlzdGluZ1JlZHVjZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbnZhciBSRURVQ0VSUyA9IFtdO1xuZnVuY3Rpb24gcmVkdWNlcihuYW1lLCBwYXJhbXMsIGZuKSB7XG4gIHB1c2hSZWR1Y2VyKG5hbWUsIHBhcmFtcywgZm4pO1xufVxuZnVuY3Rpb24gaW5pdChuYW1lLCBwYXJhbXMsIGZuKSB7XG4gIHB1c2hSZWR1Y2VyKG5hbWUsIHBhcmFtcywgZm4sIGxpZmVjeWNsZV90eXBlX2RlZmF1bHQuSW5pdCk7XG59XG5mdW5jdGlvbiBjbGllbnRDb25uZWN0ZWQobmFtZSwgcGFyYW1zLCBmbikge1xuICBwdXNoUmVkdWNlcihuYW1lLCBwYXJhbXMsIGZuLCBsaWZlY3ljbGVfdHlwZV9kZWZhdWx0Lk9uQ29ubmVjdCk7XG59XG5mdW5jdGlvbiBjbGllbnREaXNjb25uZWN0ZWQobmFtZSwgcGFyYW1zLCBmbikge1xuICBwdXNoUmVkdWNlcihuYW1lLCBwYXJhbXMsIGZuLCBsaWZlY3ljbGVfdHlwZV9kZWZhdWx0Lk9uRGlzY29ubmVjdCk7XG59XG52YXIgUmVkdWNlcnMgPSBjbGFzcyB7XG4gIHJlZHVjZXJzVHlwZTtcbiAgY29uc3RydWN0b3IoaGFuZGxlcykge1xuICAgIHRoaXMucmVkdWNlcnNUeXBlID0gcmVkdWNlcnNUb1NjaGVtYShoYW5kbGVzKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHJlZHVjZXJzVG9TY2hlbWEocmVkdWNlcnMyKSB7XG4gIGNvbnN0IG1hcHBlZCA9IHJlZHVjZXJzMi5tYXAoKHIpID0+IHtcbiAgICBjb25zdCBwYXJhbXNSb3cgPSByLnBhcmFtcy5yb3c7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHIucmVkdWNlck5hbWUsXG4gICAgICAvLyBQcmVmZXIgdGhlIHNjaGVtYSdzIG93biBhY2Nlc3Nvck5hbWUgaWYgcHJlc2VudCBhdCBydW50aW1lOyBvdGhlcndpc2UgZGVyaXZlIGl0LlxuICAgICAgYWNjZXNzb3JOYW1lOiByLmFjY2Vzc29yTmFtZSxcbiAgICAgIHBhcmFtczogcGFyYW1zUm93LFxuICAgICAgcGFyYW1zVHlwZTogci5wYXJhbXNTcGFjZXRpbWVUeXBlXG4gICAgfTtcbiAgfSk7XG4gIGNvbnN0IHJlc3VsdCA9IHsgcmVkdWNlcnM6IG1hcHBlZCB9O1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcmVkdWNlcnMoLi4uYXJncykge1xuICBjb25zdCBoYW5kbGVzID0gYXJncy5sZW5ndGggPT09IDEgJiYgQXJyYXkuaXNBcnJheShhcmdzWzBdKSA/IGFyZ3NbMF0gOiBhcmdzO1xuICByZXR1cm4gbmV3IFJlZHVjZXJzKGhhbmRsZXMpO1xufVxuXG4vLyBzcmMvc2VydmVyL3F1ZXJ5LnRzXG52YXIgUXVlcnlCcmFuZCA9IFN5bWJvbChcIlF1ZXJ5QnJhbmRcIik7XG52YXIgaXNSb3dUeXBlZFF1ZXJ5ID0gKHZhbCkgPT4gISF2YWwgJiYgdHlwZW9mIHZhbCA9PT0gXCJvYmplY3RcIiAmJiBRdWVyeUJyYW5kIGluIHZhbDtcbmZ1bmN0aW9uIHRvU3FsKHEpIHtcbiAgcmV0dXJuIHEudG9TcWwoKTtcbn1cbnZhciBTZW1pam9pbkltcGwgPSBjbGFzcyBfU2VtaWpvaW5JbXBsIHtcbiAgY29uc3RydWN0b3Ioc291cmNlUXVlcnksIGZpbHRlclF1ZXJ5LCBqb2luQ29uZGl0aW9uKSB7XG4gICAgdGhpcy5zb3VyY2VRdWVyeSA9IHNvdXJjZVF1ZXJ5O1xuICAgIHRoaXMuZmlsdGVyUXVlcnkgPSBmaWx0ZXJRdWVyeTtcbiAgICB0aGlzLmpvaW5Db25kaXRpb24gPSBqb2luQ29uZGl0aW9uO1xuICAgIGlmIChzb3VyY2VRdWVyeS50YWJsZS5uYW1lID09PSBmaWx0ZXJRdWVyeS50YWJsZS5uYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2VtaWpvaW4gYSB0YWJsZSB0byBpdHNlbGZcIik7XG4gICAgfVxuICB9XG4gIFtRdWVyeUJyYW5kXSA9IHRydWU7XG4gIHR5cGUgPSBcInNlbWlqb2luXCI7XG4gIGJ1aWxkKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHdoZXJlKHByZWRpY2F0ZSkge1xuICAgIGNvbnN0IG5leHRTb3VyY2VRdWVyeSA9IHRoaXMuc291cmNlUXVlcnkud2hlcmUocHJlZGljYXRlKTtcbiAgICByZXR1cm4gbmV3IF9TZW1pam9pbkltcGwoXG4gICAgICBuZXh0U291cmNlUXVlcnksXG4gICAgICB0aGlzLmZpbHRlclF1ZXJ5LFxuICAgICAgdGhpcy5qb2luQ29uZGl0aW9uXG4gICAgKTtcbiAgfVxuICB0b1NxbCgpIHtcbiAgICBjb25zdCBsZWZ0ID0gdGhpcy5maWx0ZXJRdWVyeTtcbiAgICBjb25zdCByaWdodCA9IHRoaXMuc291cmNlUXVlcnk7XG4gICAgY29uc3QgbGVmdFRhYmxlID0gcXVvdGVJZGVudGlmaWVyKGxlZnQudGFibGUubmFtZSk7XG4gICAgY29uc3QgcmlnaHRUYWJsZSA9IHF1b3RlSWRlbnRpZmllcihyaWdodC50YWJsZS5uYW1lKTtcbiAgICBsZXQgc3FsID0gYFNFTEVDVCAke3JpZ2h0VGFibGV9LiogRlJPTSAke2xlZnRUYWJsZX0gSk9JTiAke3JpZ2h0VGFibGV9IE9OICR7Ym9vbGVhbkV4cHJUb1NxbCh0aGlzLmpvaW5Db25kaXRpb24pfWA7XG4gICAgY29uc3QgY2xhdXNlcyA9IFtdO1xuICAgIGlmIChsZWZ0LndoZXJlQ2xhdXNlKSB7XG4gICAgICBjbGF1c2VzLnB1c2goYm9vbGVhbkV4cHJUb1NxbChsZWZ0LndoZXJlQ2xhdXNlKSk7XG4gICAgfVxuICAgIGlmIChyaWdodC53aGVyZUNsYXVzZSkge1xuICAgICAgY2xhdXNlcy5wdXNoKGJvb2xlYW5FeHByVG9TcWwocmlnaHQud2hlcmVDbGF1c2UpKTtcbiAgICB9XG4gICAgaWYgKGNsYXVzZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3Qgd2hlcmVTcWwgPSBjbGF1c2VzLmxlbmd0aCA9PT0gMSA/IGNsYXVzZXNbMF0gOiBjbGF1c2VzLm1hcCh3cmFwSW5QYXJlbnMpLmpvaW4oXCIgQU5EIFwiKTtcbiAgICAgIHNxbCArPSBgIFdIRVJFICR7d2hlcmVTcWx9YDtcbiAgICB9XG4gICAgcmV0dXJuIHNxbDtcbiAgfVxufTtcbnZhciBGcm9tQnVpbGRlciA9IGNsYXNzIF9Gcm9tQnVpbGRlciB7XG4gIGNvbnN0cnVjdG9yKHRhYmxlMiwgd2hlcmVDbGF1c2UpIHtcbiAgICB0aGlzLnRhYmxlID0gdGFibGUyO1xuICAgIHRoaXMud2hlcmVDbGF1c2UgPSB3aGVyZUNsYXVzZTtcbiAgfVxuICBbUXVlcnlCcmFuZF0gPSB0cnVlO1xuICB3aGVyZShwcmVkaWNhdGUpIHtcbiAgICBjb25zdCBuZXdDb25kaXRpb24gPSBwcmVkaWNhdGUodGhpcy50YWJsZS5jb2xzKTtcbiAgICBjb25zdCBuZXh0V2hlcmUgPSB0aGlzLndoZXJlQ2xhdXNlID8gYW5kKHRoaXMud2hlcmVDbGF1c2UsIG5ld0NvbmRpdGlvbikgOiBuZXdDb25kaXRpb247XG4gICAgcmV0dXJuIG5ldyBfRnJvbUJ1aWxkZXIodGhpcy50YWJsZSwgbmV4dFdoZXJlKTtcbiAgfVxuICByaWdodFNlbWlqb2luKHJpZ2h0LCBvbikge1xuICAgIGNvbnN0IHNvdXJjZVF1ZXJ5ID0gbmV3IF9Gcm9tQnVpbGRlcihyaWdodCk7XG4gICAgY29uc3Qgam9pbkNvbmRpdGlvbiA9IG9uKFxuICAgICAgdGhpcy50YWJsZS5pbmRleGVkQ29scyxcbiAgICAgIHJpZ2h0LmluZGV4ZWRDb2xzXG4gICAgKTtcbiAgICByZXR1cm4gbmV3IFNlbWlqb2luSW1wbChzb3VyY2VRdWVyeSwgdGhpcywgam9pbkNvbmRpdGlvbik7XG4gIH1cbiAgbGVmdFNlbWlqb2luKHJpZ2h0LCBvbikge1xuICAgIGNvbnN0IGZpbHRlclF1ZXJ5ID0gbmV3IF9Gcm9tQnVpbGRlcihyaWdodCk7XG4gICAgY29uc3Qgam9pbkNvbmRpdGlvbiA9IG9uKFxuICAgICAgdGhpcy50YWJsZS5pbmRleGVkQ29scyxcbiAgICAgIHJpZ2h0LmluZGV4ZWRDb2xzXG4gICAgKTtcbiAgICByZXR1cm4gbmV3IFNlbWlqb2luSW1wbCh0aGlzLCBmaWx0ZXJRdWVyeSwgam9pbkNvbmRpdGlvbik7XG4gIH1cbiAgdG9TcWwoKSB7XG4gICAgcmV0dXJuIHJlbmRlclNlbGVjdFNxbFdpdGhKb2lucyh0aGlzLnRhYmxlLCB0aGlzLndoZXJlQ2xhdXNlKTtcbiAgfVxuICBidWlsZCgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcbnZhciBUYWJsZVJlZkltcGwgPSBjbGFzcyB7XG4gIHR5cGUgPSBcInRhYmxlXCI7XG4gIG5hbWU7XG4gIGNvbHM7XG4gIGluZGV4ZWRDb2xzO1xuICB0YWJsZURlZjtcbiAgY29uc3RydWN0b3IodGFibGVEZWYpIHtcbiAgICB0aGlzLm5hbWUgPSB0YWJsZURlZi5uYW1lO1xuICAgIHRoaXMuY29scyA9IGNyZWF0ZVJvd0V4cHIodGFibGVEZWYpO1xuICAgIHRoaXMuaW5kZXhlZENvbHMgPSB0aGlzLmNvbHM7XG4gICAgdGhpcy50YWJsZURlZiA9IHRhYmxlRGVmO1xuICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gIH1cbiAgYXNGcm9tKCkge1xuICAgIHJldHVybiBuZXcgRnJvbUJ1aWxkZXIodGhpcyk7XG4gIH1cbiAgcmlnaHRTZW1pam9pbihvdGhlciwgb24pIHtcbiAgICByZXR1cm4gdGhpcy5hc0Zyb20oKS5yaWdodFNlbWlqb2luKG90aGVyLCBvbik7XG4gIH1cbiAgbGVmdFNlbWlqb2luKG90aGVyLCBvbikge1xuICAgIHJldHVybiB0aGlzLmFzRnJvbSgpLmxlZnRTZW1pam9pbihvdGhlciwgb24pO1xuICB9XG4gIGJ1aWxkKCkge1xuICAgIHJldHVybiB0aGlzLmFzRnJvbSgpLmJ1aWxkKCk7XG4gIH1cbiAgdG9TcWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXNGcm9tKCkudG9TcWwoKTtcbiAgfVxuICB3aGVyZShwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5hc0Zyb20oKS53aGVyZShwcmVkaWNhdGUpO1xuICB9XG59O1xuZnVuY3Rpb24gY3JlYXRlVGFibGVSZWZGcm9tRGVmKHRhYmxlRGVmKSB7XG4gIHJldHVybiBuZXcgVGFibGVSZWZJbXBsKHRhYmxlRGVmKTtcbn1cbmZ1bmN0aW9uIG1ha2VRdWVyeUJ1aWxkZXIoc2NoZW1hMikge1xuICBjb25zdCBxYiA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBmb3IgKGNvbnN0IHRhYmxlMiBvZiBzY2hlbWEyLnRhYmxlcykge1xuICAgIGNvbnN0IHJlZiA9IGNyZWF0ZVRhYmxlUmVmRnJvbURlZihcbiAgICAgIHRhYmxlMlxuICAgICk7XG4gICAgcWJbdGFibGUyLm5hbWVdID0gcmVmO1xuICB9XG4gIHJldHVybiBPYmplY3QuZnJlZXplKHFiKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJvd0V4cHIodGFibGVEZWYpIHtcbiAgY29uc3Qgcm93ID0ge307XG4gIGZvciAoY29uc3QgY29sdW1uTmFtZSBvZiBPYmplY3Qua2V5cyh0YWJsZURlZi5jb2x1bW5zKSkge1xuICAgIGNvbnN0IGNvbHVtbkJ1aWxkZXIgPSB0YWJsZURlZi5jb2x1bW5zW2NvbHVtbk5hbWVdO1xuICAgIGNvbnN0IGNvbHVtbiA9IG5ldyBDb2x1bW5FeHByZXNzaW9uKFxuICAgICAgdGFibGVEZWYubmFtZSxcbiAgICAgIGNvbHVtbk5hbWUsXG4gICAgICBjb2x1bW5CdWlsZGVyLnR5cGVCdWlsZGVyLmFsZ2VicmFpY1R5cGVcbiAgICApO1xuICAgIHJvd1tjb2x1bW5OYW1lXSA9IE9iamVjdC5mcmVlemUoY29sdW1uKTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShyb3cpO1xufVxuZnVuY3Rpb24gcmVuZGVyU2VsZWN0U3FsV2l0aEpvaW5zKHRhYmxlMiwgd2hlcmUsIGV4dHJhQ2xhdXNlcyA9IFtdKSB7XG4gIGNvbnN0IHF1b3RlZFRhYmxlID0gcXVvdGVJZGVudGlmaWVyKHRhYmxlMi5uYW1lKTtcbiAgY29uc3Qgc3FsID0gYFNFTEVDVCAqIEZST00gJHtxdW90ZWRUYWJsZX1gO1xuICBjb25zdCBjbGF1c2VzID0gW107XG4gIGlmICh3aGVyZSkgY2xhdXNlcy5wdXNoKGJvb2xlYW5FeHByVG9TcWwod2hlcmUpKTtcbiAgY2xhdXNlcy5wdXNoKC4uLmV4dHJhQ2xhdXNlcyk7XG4gIGlmIChjbGF1c2VzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHNxbDtcbiAgY29uc3Qgd2hlcmVTcWwgPSBjbGF1c2VzLmxlbmd0aCA9PT0gMSA/IGNsYXVzZXNbMF0gOiBjbGF1c2VzLm1hcCh3cmFwSW5QYXJlbnMpLmpvaW4oXCIgQU5EIFwiKTtcbiAgcmV0dXJuIGAke3NxbH0gV0hFUkUgJHt3aGVyZVNxbH1gO1xufVxudmFyIENvbHVtbkV4cHJlc3Npb24gPSBjbGFzcyB7XG4gIHR5cGUgPSBcImNvbHVtblwiO1xuICBjb2x1bW47XG4gIHRhYmxlO1xuICAvLyBwaGFudG9tOiBhY3R1YWwgcnVudGltZSB2YWx1ZSBpcyB1bmRlZmluZWRcbiAgdHNWYWx1ZVR5cGU7XG4gIHNwYWNldGltZVR5cGU7XG4gIGNvbnN0cnVjdG9yKHRhYmxlMiwgY29sdW1uLCBzcGFjZXRpbWVUeXBlKSB7XG4gICAgdGhpcy50YWJsZSA9IHRhYmxlMjtcbiAgICB0aGlzLmNvbHVtbiA9IGNvbHVtbjtcbiAgICB0aGlzLnNwYWNldGltZVR5cGUgPSBzcGFjZXRpbWVUeXBlO1xuICB9XG4gIC8vIFRoZXNlIHR5cGVzIGNvdWxkIGJlIHRpZ2h0ZWQsIGJ1dCBzaW5jZSB3ZSBkZWNsYXJlIHRoZSBvdmVybG9hZHMgYWJvdmUsIGl0IGRvZXNuJ3Qgd2Vha2VuIHRoZSBBUEkgc3VyZmFjZS5cbiAgZXEoeCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImVxXCIsXG4gICAgICBsZWZ0OiB0aGlzLFxuICAgICAgcmlnaHQ6IG5vcm1hbGl6ZVZhbHVlKHgpXG4gICAgfTtcbiAgfVxuICAvLyBUaGVzZSB0eXBlcyBjb3VsZCBiZSB0aWdodGVkLCBidXQgc2luY2Ugd2UgZGVjbGFyZSB0aGUgb3ZlcmxvYWRzIGFib3ZlLCBpdCBkb2Vzbid0IHdlYWtlbiB0aGUgQVBJIHN1cmZhY2UuXG4gIGx0KHgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJsdFwiLFxuICAgICAgbGVmdDogdGhpcyxcbiAgICAgIHJpZ2h0OiBub3JtYWxpemVWYWx1ZSh4KVxuICAgIH07XG4gIH1cbiAgLy8gVGhlc2UgdHlwZXMgY291bGQgYmUgdGlnaHRlZCwgYnV0IHNpbmNlIHdlIGRlY2xhcmUgdGhlIG92ZXJsb2FkcyBhYm92ZSwgaXQgZG9lc24ndCB3ZWFrZW4gdGhlIEFQSSBzdXJmYWNlLlxuICBsdGUoeCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImx0ZVwiLFxuICAgICAgbGVmdDogdGhpcyxcbiAgICAgIHJpZ2h0OiBub3JtYWxpemVWYWx1ZSh4KVxuICAgIH07XG4gIH1cbiAgLy8gVGhlc2UgdHlwZXMgY291bGQgYmUgdGlnaHRlZCwgYnV0IHNpbmNlIHdlIGRlY2xhcmUgdGhlIG92ZXJsb2FkcyBhYm92ZSwgaXQgZG9lc24ndCB3ZWFrZW4gdGhlIEFQSSBzdXJmYWNlLlxuICBndCh4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZ3RcIixcbiAgICAgIGxlZnQ6IHRoaXMsXG4gICAgICByaWdodDogbm9ybWFsaXplVmFsdWUoeClcbiAgICB9O1xuICB9XG4gIC8vIFRoZXNlIHR5cGVzIGNvdWxkIGJlIHRpZ2h0ZWQsIGJ1dCBzaW5jZSB3ZSBkZWNsYXJlIHRoZSBvdmVybG9hZHMgYWJvdmUsIGl0IGRvZXNuJ3Qgd2Vha2VuIHRoZSBBUEkgc3VyZmFjZS5cbiAgZ3RlKHgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJndGVcIixcbiAgICAgIGxlZnQ6IHRoaXMsXG4gICAgICByaWdodDogbm9ybWFsaXplVmFsdWUoeClcbiAgICB9O1xuICB9XG59O1xuZnVuY3Rpb24gbGl0ZXJhbCh2YWx1ZSkge1xuICByZXR1cm4geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWUgfTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVZhbHVlKHZhbCkge1xuICBpZiAodmFsLnR5cGUgPT09IFwibGl0ZXJhbFwiKVxuICAgIHJldHVybiB2YWw7XG4gIGlmICh0eXBlb2YgdmFsID09PSBcIm9iamVjdFwiICYmIHZhbCAhPSBudWxsICYmIFwidHlwZVwiIGluIHZhbCAmJiB2YWwudHlwZSA9PT0gXCJjb2x1bW5cIikge1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgcmV0dXJuIGxpdGVyYWwodmFsKTtcbn1cbmZ1bmN0aW9uIG5vdChjbGF1c2UpIHtcbiAgcmV0dXJuIHsgdHlwZTogXCJub3RcIiwgY2xhdXNlIH07XG59XG5mdW5jdGlvbiBhbmQoLi4uY2xhdXNlcykge1xuICByZXR1cm4geyB0eXBlOiBcImFuZFwiLCBjbGF1c2VzIH07XG59XG5mdW5jdGlvbiBvciguLi5jbGF1c2VzKSB7XG4gIHJldHVybiB7IHR5cGU6IFwib3JcIiwgY2xhdXNlcyB9O1xufVxuZnVuY3Rpb24gYm9vbGVhbkV4cHJUb1NxbChleHByLCB0YWJsZUFsaWFzKSB7XG4gIHN3aXRjaCAoZXhwci50eXBlKSB7XG4gICAgY2FzZSBcImVxXCI6XG4gICAgICByZXR1cm4gYCR7dmFsdWVFeHByVG9TcWwoZXhwci5sZWZ0KX0gPSAke3ZhbHVlRXhwclRvU3FsKGV4cHIucmlnaHQpfWA7XG4gICAgY2FzZSBcIm5lXCI6XG4gICAgICByZXR1cm4gYCR7dmFsdWVFeHByVG9TcWwoZXhwci5sZWZ0KX0gPD4gJHt2YWx1ZUV4cHJUb1NxbChleHByLnJpZ2h0KX1gO1xuICAgIGNhc2UgXCJndFwiOlxuICAgICAgcmV0dXJuIGAke3ZhbHVlRXhwclRvU3FsKGV4cHIubGVmdCl9ID4gJHt2YWx1ZUV4cHJUb1NxbChleHByLnJpZ2h0KX1gO1xuICAgIGNhc2UgXCJndGVcIjpcbiAgICAgIHJldHVybiBgJHt2YWx1ZUV4cHJUb1NxbChleHByLmxlZnQpfSA+PSAke3ZhbHVlRXhwclRvU3FsKGV4cHIucmlnaHQpfWA7XG4gICAgY2FzZSBcImx0XCI6XG4gICAgICByZXR1cm4gYCR7dmFsdWVFeHByVG9TcWwoZXhwci5sZWZ0KX0gPCAke3ZhbHVlRXhwclRvU3FsKGV4cHIucmlnaHQpfWA7XG4gICAgY2FzZSBcImx0ZVwiOlxuICAgICAgcmV0dXJuIGAke3ZhbHVlRXhwclRvU3FsKGV4cHIubGVmdCl9IDw9ICR7dmFsdWVFeHByVG9TcWwoZXhwci5yaWdodCl9YDtcbiAgICBjYXNlIFwiYW5kXCI6XG4gICAgICByZXR1cm4gZXhwci5jbGF1c2VzLm1hcCgoYykgPT4gYm9vbGVhbkV4cHJUb1NxbChjKSkubWFwKHdyYXBJblBhcmVucykuam9pbihcIiBBTkQgXCIpO1xuICAgIGNhc2UgXCJvclwiOlxuICAgICAgcmV0dXJuIGV4cHIuY2xhdXNlcy5tYXAoKGMpID0+IGJvb2xlYW5FeHByVG9TcWwoYykpLm1hcCh3cmFwSW5QYXJlbnMpLmpvaW4oXCIgT1IgXCIpO1xuICAgIGNhc2UgXCJub3RcIjpcbiAgICAgIHJldHVybiBgTk9UICR7d3JhcEluUGFyZW5zKGJvb2xlYW5FeHByVG9TcWwoZXhwci5jbGF1c2UpKX1gO1xuICB9XG59XG5mdW5jdGlvbiB3cmFwSW5QYXJlbnMoc3FsKSB7XG4gIHJldHVybiBgKCR7c3FsfSlgO1xufVxuZnVuY3Rpb24gdmFsdWVFeHByVG9TcWwoZXhwciwgdGFibGVBbGlhcykge1xuICBpZiAoaXNMaXRlcmFsRXhwcihleHByKSkge1xuICAgIHJldHVybiBsaXRlcmFsVmFsdWVUb1NxbChleHByLnZhbHVlKTtcbiAgfVxuICBjb25zdCB0YWJsZTIgPSBleHByLnRhYmxlO1xuICByZXR1cm4gYCR7cXVvdGVJZGVudGlmaWVyKHRhYmxlMil9LiR7cXVvdGVJZGVudGlmaWVyKGV4cHIuY29sdW1uKX1gO1xufVxuZnVuY3Rpb24gbGl0ZXJhbFZhbHVlVG9TcWwodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gXCJOVUxMXCI7XG4gIH1cbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgSWRlbnRpdHkgfHwgdmFsdWUgaW5zdGFuY2VvZiBDb25uZWN0aW9uSWQpIHtcbiAgICByZXR1cm4gYDB4JHt2YWx1ZS50b0hleFN0cmluZygpfWA7XG4gIH1cbiAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgY2FzZSBcImJpZ2ludFwiOlxuICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgIHJldHVybiB2YWx1ZSA/IFwiVFJVRVwiIDogXCJGQUxTRVwiO1xuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgIHJldHVybiBgJyR7dmFsdWUucmVwbGFjZSgvJy9nLCBcIicnXCIpfSdgO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gYCcke0pTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC8nL2csIFwiJydcIil9J2A7XG4gIH1cbn1cbmZ1bmN0aW9uIHF1b3RlSWRlbnRpZmllcihuYW1lKSB7XG4gIHJldHVybiBgXCIke25hbWUucmVwbGFjZSgvXCIvZywgJ1wiXCInKX1cImA7XG59XG5mdW5jdGlvbiBpc0xpdGVyYWxFeHByKGV4cHIpIHtcbiAgcmV0dXJuIGV4cHIudHlwZSA9PT0gXCJsaXRlcmFsXCI7XG59XG5cbi8vIHNyYy9saWIvdmlld3MudHNcbmZ1bmN0aW9uIGRlZmluZVZpZXcob3B0cywgYW5vbiwgcGFyYW1zLCByZXQsIGZuKSB7XG4gIGNvbnN0IHBhcmFtc0J1aWxkZXIgPSBuZXcgUm93QnVpbGRlcihwYXJhbXMsIHRvUGFzY2FsQ2FzZShvcHRzLm5hbWUpKTtcbiAgbGV0IHJldHVyblR5cGUgPSByZWdpc3RlclR5cGVzUmVjdXJzaXZlbHkocmV0KS5hbGdlYnJhaWNUeXBlO1xuICBjb25zdCB7IHZhbHVlOiBwYXJhbVR5cGUgfSA9IHJlc29sdmVUeXBlKFxuICAgIE1PRFVMRV9ERUYudHlwZXNwYWNlLFxuICAgIHJlZ2lzdGVyVHlwZXNSZWN1cnNpdmVseShwYXJhbXNCdWlsZGVyKVxuICApO1xuICBNT0RVTEVfREVGLm1pc2NFeHBvcnRzLnB1c2goe1xuICAgIHRhZzogXCJWaWV3XCIsXG4gICAgdmFsdWU6IHtcbiAgICAgIG5hbWU6IG9wdHMubmFtZSxcbiAgICAgIGluZGV4OiAoYW5vbiA/IEFOT05fVklFV1MgOiBWSUVXUykubGVuZ3RoLFxuICAgICAgaXNQdWJsaWM6IG9wdHMucHVibGljLFxuICAgICAgaXNBbm9ueW1vdXM6IGFub24sXG4gICAgICBwYXJhbXM6IHBhcmFtVHlwZSxcbiAgICAgIHJldHVyblR5cGVcbiAgICB9XG4gIH0pO1xuICBpZiAocmV0dXJuVHlwZS50YWcgPT0gXCJTdW1cIikge1xuICAgIGNvbnN0IG9yaWdpbmFsRm4gPSBmbjtcbiAgICBmbiA9ICgoY3R4LCBhcmdzKSA9PiB7XG4gICAgICBjb25zdCByZXQyID0gb3JpZ2luYWxGbihjdHgsIGFyZ3MpO1xuICAgICAgcmV0dXJuIHJldDIgPT0gbnVsbCA/IFtdIDogW3JldDJdO1xuICAgIH0pO1xuICAgIHJldHVyblR5cGUgPSBBbGdlYnJhaWNUeXBlLkFycmF5KFxuICAgICAgcmV0dXJuVHlwZS52YWx1ZS52YXJpYW50c1swXS5hbGdlYnJhaWNUeXBlXG4gICAgKTtcbiAgfVxuICAoYW5vbiA/IEFOT05fVklFV1MgOiBWSUVXUykucHVzaCh7XG4gICAgZm4sXG4gICAgcGFyYW1zOiBwYXJhbVR5cGUsXG4gICAgcmV0dXJuVHlwZSxcbiAgICByZXR1cm5UeXBlQmFzZVNpemU6IGJzYXRuQmFzZVNpemUoTU9EVUxFX0RFRi50eXBlc3BhY2UsIHJldHVyblR5cGUpXG4gIH0pO1xufVxudmFyIFZJRVdTID0gW107XG52YXIgQU5PTl9WSUVXUyA9IFtdO1xuXG4vLyBzcmMvbGliL3Byb2NlZHVyZXMudHNcbmZ1bmN0aW9uIHByb2NlZHVyZShuYW1lLCBwYXJhbXMsIHJldCwgZm4pIHtcbiAgY29uc3QgcGFyYW1zVHlwZSA9IHtcbiAgICBlbGVtZW50czogT2JqZWN0LmVudHJpZXMocGFyYW1zKS5tYXAoKFtuLCBjXSkgPT4gKHtcbiAgICAgIG5hbWU6IG4sXG4gICAgICBhbGdlYnJhaWNUeXBlOiByZWdpc3RlclR5cGVzUmVjdXJzaXZlbHkoXG4gICAgICAgIFwidHlwZUJ1aWxkZXJcIiBpbiBjID8gYy50eXBlQnVpbGRlciA6IGNcbiAgICAgICkuYWxnZWJyYWljVHlwZVxuICAgIH0pKVxuICB9O1xuICBjb25zdCByZXR1cm5UeXBlID0gcmVnaXN0ZXJUeXBlc1JlY3Vyc2l2ZWx5KHJldCkuYWxnZWJyYWljVHlwZTtcbiAgTU9EVUxFX0RFRi5taXNjRXhwb3J0cy5wdXNoKHtcbiAgICB0YWc6IFwiUHJvY2VkdXJlXCIsXG4gICAgdmFsdWU6IHtcbiAgICAgIG5hbWUsXG4gICAgICBwYXJhbXM6IHBhcmFtc1R5cGUsXG4gICAgICByZXR1cm5UeXBlXG4gICAgfVxuICB9KTtcbiAgUFJPQ0VEVVJFUy5wdXNoKHtcbiAgICBmbixcbiAgICBwYXJhbXNUeXBlLFxuICAgIHJldHVyblR5cGUsXG4gICAgcmV0dXJuVHlwZUJhc2VTaXplOiBic2F0bkJhc2VTaXplKE1PRFVMRV9ERUYudHlwZXNwYWNlLCByZXR1cm5UeXBlKVxuICB9KTtcbn1cbnZhciBQUk9DRURVUkVTID0gW107XG5cbi8vIHNyYy9saWIvc2NoZW1hLnRzXG52YXIgUkVHSVNURVJFRF9TQ0hFTUEgPSBudWxsO1xuZnVuY3Rpb24gZ2V0UmVnaXN0ZXJlZFNjaGVtYSgpIHtcbiAgaWYgKFJFR0lTVEVSRURfU0NIRU1BID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTY2hlbWEgaGFzIG5vdCBiZWVuIHJlZ2lzdGVyZWQgeWV0LiBDYWxsIHNjaGVtYSgpIGZpcnN0LlwiKTtcbiAgfVxuICByZXR1cm4gUkVHSVNURVJFRF9TQ0hFTUE7XG59XG5mdW5jdGlvbiB0YWJsZXNUb1NjaGVtYSh0YWJsZXMpIHtcbiAgcmV0dXJuIHsgdGFibGVzOiB0YWJsZXMubWFwKHRhYmxlVG9TY2hlbWEpIH07XG59XG5mdW5jdGlvbiB0YWJsZVRvU2NoZW1hKHNjaGVtYTIpIHtcbiAgY29uc3QgZ2V0Q29sTmFtZSA9IChpKSA9PiBzY2hlbWEyLnJvd1R5cGUuYWxnZWJyYWljVHlwZS52YWx1ZS5lbGVtZW50c1tpXS5uYW1lO1xuICByZXR1cm4ge1xuICAgIG5hbWU6IHNjaGVtYTIudGFibGVOYW1lLFxuICAgIGFjY2Vzc29yTmFtZTogdG9DYW1lbENhc2Uoc2NoZW1hMi50YWJsZU5hbWUpLFxuICAgIGNvbHVtbnM6IHNjaGVtYTIucm93VHlwZS5yb3csXG4gICAgLy8gdHlwZWQgYXMgVFtpXVsncm93VHlwZSddWydyb3cnXSB1bmRlciBUYWJsZXNUb1NjaGVtYTxUPlxuICAgIHJvd1R5cGU6IHNjaGVtYTIucm93U3BhY2V0aW1lVHlwZSxcbiAgICBjb25zdHJhaW50czogc2NoZW1hMi50YWJsZURlZi5jb25zdHJhaW50cy5tYXAoKGMpID0+ICh7XG4gICAgICBuYW1lOiBjLm5hbWUsXG4gICAgICBjb25zdHJhaW50OiBcInVuaXF1ZVwiLFxuICAgICAgY29sdW1uczogYy5kYXRhLnZhbHVlLmNvbHVtbnMubWFwKGdldENvbE5hbWUpXG4gICAgfSkpLFxuICAgIC8vIFRPRE86IGhvcnJpYmxlIGhvcnJpYmxlIGhvcnJpYmxlLiB3ZSBzbXVnZ2xlIHRoaXMgYEFycmF5PFVudHlwZWRJbmRleD5gXG4gICAgLy8gYnkgY2FzdGluZyBpdCB0byBhbiBgQXJyYXk8SW5kZXhPcHRzPmAgYXMgYFRhYmxlVG9TY2hlbWFgIGV4cGVjdHMuXG4gICAgLy8gVGhpcyBpcyB0aGVuIHVzZWQgaW4gYFRhYmxlQ2FjaGVJbXBsLmNvbnN0cnVjdG9yYCBhbmQgd2hvIGtub3dzIHdoZXJlIGVsc2UuXG4gICAgLy8gV2Ugc2hvdWxkIHN0b3AgbHlpbmcgYWJvdXQgb3VyIHR5cGVzLlxuICAgIGluZGV4ZXM6IHNjaGVtYTIudGFibGVEZWYuaW5kZXhlcy5tYXAoKGlkeCkgPT4ge1xuICAgICAgY29uc3QgY29sdW1uSWRzID0gaWR4LmFsZ29yaXRobS50YWcgPT09IFwiRGlyZWN0XCIgPyBbaWR4LmFsZ29yaXRobS52YWx1ZV0gOiBpZHguYWxnb3JpdGhtLnZhbHVlO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogaWR4LmFjY2Vzc29yTmFtZSxcbiAgICAgICAgdW5pcXVlOiBzY2hlbWEyLnRhYmxlRGVmLmNvbnN0cmFpbnRzLnNvbWUoXG4gICAgICAgICAgKGMpID0+IGMuZGF0YS52YWx1ZS5jb2x1bW5zLmV2ZXJ5KChjb2wpID0+IGNvbHVtbklkcy5pbmNsdWRlcyhjb2wpKVxuICAgICAgICApLFxuICAgICAgICBhbGdvcml0aG06IGlkeC5hbGdvcml0aG0udGFnLnRvTG93ZXJDYXNlKCksXG4gICAgICAgIGNvbHVtbnM6IGNvbHVtbklkcy5tYXAoZ2V0Q29sTmFtZSlcbiAgICAgIH07XG4gICAgfSlcbiAgfTtcbn1cbnZhciBNT0RVTEVfREVGID0ge1xuICB0eXBlc3BhY2U6IHsgdHlwZXM6IFtdIH0sXG4gIHRhYmxlczogW10sXG4gIHJlZHVjZXJzOiBbXSxcbiAgdHlwZXM6IFtdLFxuICBtaXNjRXhwb3J0czogW10sXG4gIHJvd0xldmVsU2VjdXJpdHk6IFtdXG59O1xudmFyIENPTVBPVU5EX1RZUEVTID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbmZ1bmN0aW9uIHJlc29sdmVUeXBlKHR5cGVzcGFjZSwgdHlwZUJ1aWxkZXIpIHtcbiAgbGV0IHR5ID0gdHlwZUJ1aWxkZXIuYWxnZWJyYWljVHlwZTtcbiAgd2hpbGUgKHR5LnRhZyA9PT0gXCJSZWZcIikge1xuICAgIHR5ID0gdHlwZXNwYWNlLnR5cGVzW3R5LnZhbHVlXTtcbiAgfVxuICByZXR1cm4gdHk7XG59XG5mdW5jdGlvbiByZWdpc3RlclR5cGVzUmVjdXJzaXZlbHkodHlwZUJ1aWxkZXIpIHtcbiAgaWYgKHR5cGVCdWlsZGVyIGluc3RhbmNlb2YgUHJvZHVjdEJ1aWxkZXIgJiYgIWlzVW5pdCh0eXBlQnVpbGRlcikgfHwgdHlwZUJ1aWxkZXIgaW5zdGFuY2VvZiBTdW1CdWlsZGVyIHx8IHR5cGVCdWlsZGVyIGluc3RhbmNlb2YgUm93QnVpbGRlcikge1xuICAgIHJldHVybiByZWdpc3RlckNvbXBvdW5kVHlwZVJlY3Vyc2l2ZWx5KHR5cGVCdWlsZGVyKTtcbiAgfSBlbHNlIGlmICh0eXBlQnVpbGRlciBpbnN0YW5jZW9mIE9wdGlvbkJ1aWxkZXIpIHtcbiAgICByZXR1cm4gbmV3IE9wdGlvbkJ1aWxkZXIoXG4gICAgICByZWdpc3RlclR5cGVzUmVjdXJzaXZlbHkodHlwZUJ1aWxkZXIudmFsdWUpXG4gICAgKTtcbiAgfSBlbHNlIGlmICh0eXBlQnVpbGRlciBpbnN0YW5jZW9mIFJlc3VsdEJ1aWxkZXIpIHtcbiAgICByZXR1cm4gbmV3IFJlc3VsdEJ1aWxkZXIoXG4gICAgICByZWdpc3RlclR5cGVzUmVjdXJzaXZlbHkodHlwZUJ1aWxkZXIub2spLFxuICAgICAgcmVnaXN0ZXJUeXBlc1JlY3Vyc2l2ZWx5KHR5cGVCdWlsZGVyLmVycilcbiAgICApO1xuICB9IGVsc2UgaWYgKHR5cGVCdWlsZGVyIGluc3RhbmNlb2YgQXJyYXlCdWlsZGVyKSB7XG4gICAgcmV0dXJuIG5ldyBBcnJheUJ1aWxkZXIoXG4gICAgICByZWdpc3RlclR5cGVzUmVjdXJzaXZlbHkodHlwZUJ1aWxkZXIuZWxlbWVudClcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0eXBlQnVpbGRlcjtcbiAgfVxufVxuZnVuY3Rpb24gcmVnaXN0ZXJDb21wb3VuZFR5cGVSZWN1cnNpdmVseSh0eXBlQnVpbGRlcikge1xuICBjb25zdCB0eSA9IHR5cGVCdWlsZGVyLmFsZ2VicmFpY1R5cGU7XG4gIGNvbnN0IG5hbWUgPSB0eXBlQnVpbGRlci50eXBlTmFtZTtcbiAgaWYgKG5hbWUgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBNaXNzaW5nIHR5cGUgbmFtZSBmb3IgJHt0eXBlQnVpbGRlci5jb25zdHJ1Y3Rvci5uYW1lID8/IFwiVHlwZUJ1aWxkZXJcIn0gJHtKU09OLnN0cmluZ2lmeSh0eXBlQnVpbGRlcil9YFxuICAgICk7XG4gIH1cbiAgbGV0IHIgPSBDT01QT1VORF9UWVBFUy5nZXQodHkpO1xuICBpZiAociAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgY29uc3QgbmV3VHkgPSB0eXBlQnVpbGRlciBpbnN0YW5jZW9mIFJvd0J1aWxkZXIgfHwgdHlwZUJ1aWxkZXIgaW5zdGFuY2VvZiBQcm9kdWN0QnVpbGRlciA/IHtcbiAgICB0YWc6IFwiUHJvZHVjdFwiLFxuICAgIHZhbHVlOiB7IGVsZW1lbnRzOiBbXSB9XG4gIH0gOiB7IHRhZzogXCJTdW1cIiwgdmFsdWU6IHsgdmFyaWFudHM6IFtdIH0gfTtcbiAgciA9IG5ldyBSZWZCdWlsZGVyKE1PRFVMRV9ERUYudHlwZXNwYWNlLnR5cGVzLmxlbmd0aCk7XG4gIE1PRFVMRV9ERUYudHlwZXNwYWNlLnR5cGVzLnB1c2gobmV3VHkpO1xuICBDT01QT1VORF9UWVBFUy5zZXQodHksIHIpO1xuICBpZiAodHlwZUJ1aWxkZXIgaW5zdGFuY2VvZiBSb3dCdWlsZGVyKSB7XG4gICAgZm9yIChjb25zdCBbbmFtZTIsIGVsZW1dIG9mIE9iamVjdC5lbnRyaWVzKHR5cGVCdWlsZGVyLnJvdykpIHtcbiAgICAgIG5ld1R5LnZhbHVlLmVsZW1lbnRzLnB1c2goe1xuICAgICAgICBuYW1lOiBuYW1lMixcbiAgICAgICAgYWxnZWJyYWljVHlwZTogcmVnaXN0ZXJUeXBlc1JlY3Vyc2l2ZWx5KGVsZW0udHlwZUJ1aWxkZXIpLmFsZ2VicmFpY1R5cGVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlQnVpbGRlciBpbnN0YW5jZW9mIFByb2R1Y3RCdWlsZGVyKSB7XG4gICAgZm9yIChjb25zdCBbbmFtZTIsIGVsZW1dIG9mIE9iamVjdC5lbnRyaWVzKHR5cGVCdWlsZGVyLmVsZW1lbnRzKSkge1xuICAgICAgbmV3VHkudmFsdWUuZWxlbWVudHMucHVzaCh7XG4gICAgICAgIG5hbWU6IG5hbWUyLFxuICAgICAgICBhbGdlYnJhaWNUeXBlOiByZWdpc3RlclR5cGVzUmVjdXJzaXZlbHkoZWxlbSkuYWxnZWJyYWljVHlwZVxuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVCdWlsZGVyIGluc3RhbmNlb2YgU3VtQnVpbGRlcikge1xuICAgIGZvciAoY29uc3QgW25hbWUyLCB2YXJpYW50XSBvZiBPYmplY3QuZW50cmllcyh0eXBlQnVpbGRlci52YXJpYW50cykpIHtcbiAgICAgIG5ld1R5LnZhbHVlLnZhcmlhbnRzLnB1c2goe1xuICAgICAgICBuYW1lOiBuYW1lMixcbiAgICAgICAgYWxnZWJyYWljVHlwZTogcmVnaXN0ZXJUeXBlc1JlY3Vyc2l2ZWx5KHZhcmlhbnQpLmFsZ2VicmFpY1R5cGVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBNT0RVTEVfREVGLnR5cGVzLnB1c2goe1xuICAgIG5hbWU6IHNwbGl0TmFtZShuYW1lKSxcbiAgICB0eTogci5yZWYsXG4gICAgY3VzdG9tT3JkZXJpbmc6IHRydWVcbiAgfSk7XG4gIHJldHVybiByO1xufVxuZnVuY3Rpb24gaXNVbml0KHR5cGVCdWlsZGVyKSB7XG4gIHJldHVybiB0eXBlQnVpbGRlci50eXBlTmFtZSA9PSBudWxsICYmIHR5cGVCdWlsZGVyLmFsZ2VicmFpY1R5cGUudmFsdWUuZWxlbWVudHMubGVuZ3RoID09PSAwO1xufVxuZnVuY3Rpb24gc3BsaXROYW1lKG5hbWUpIHtcbiAgY29uc3Qgc2NvcGUgPSBuYW1lLnNwbGl0KFwiLlwiKTtcbiAgcmV0dXJuIHsgbmFtZTogc2NvcGUucG9wKCksIHNjb3BlIH07XG59XG52YXIgU2NoZW1hID0gY2xhc3Mge1xuICB0YWJsZXNEZWY7XG4gIHR5cGVzcGFjZTtcbiAgc2NoZW1hVHlwZTtcbiAgY29uc3RydWN0b3IodGFibGVzLCB0eXBlc3BhY2UsIGhhbmRsZXMpIHtcbiAgICB0aGlzLnRhYmxlc0RlZiA9IHsgdGFibGVzIH07XG4gICAgdGhpcy50eXBlc3BhY2UgPSB0eXBlc3BhY2U7XG4gICAgdGhpcy5zY2hlbWFUeXBlID0gdGFibGVzVG9TY2hlbWEoaGFuZGxlcyk7XG4gIH1cbiAgcmVkdWNlcihuYW1lLCBwYXJhbXNPckZuLCBmbikge1xuICAgIGlmICh0eXBlb2YgcGFyYW1zT3JGbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZWR1Y2VyKG5hbWUsIHt9LCBwYXJhbXNPckZuKTtcbiAgICAgIHJldHVybiBwYXJhbXNPckZuO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWR1Y2VyKG5hbWUsIHBhcmFtc09yRm4sIGZuKTtcbiAgICAgIHJldHVybiBmbjtcbiAgICB9XG4gIH1cbiAgaW5pdChuYW1lT3JGbiwgbWF5YmVGbikge1xuICAgIGNvbnN0IFtuYW1lLCBmbl0gPSB0eXBlb2YgbmFtZU9yRm4gPT09IFwic3RyaW5nXCIgPyBbbmFtZU9yRm4sIG1heWJlRm5dIDogW1wiaW5pdFwiLCBuYW1lT3JGbl07XG4gICAgaW5pdChuYW1lLCB7fSwgZm4pO1xuICB9XG4gIGNsaWVudENvbm5lY3RlZChuYW1lT3JGbiwgbWF5YmVGbikge1xuICAgIGNvbnN0IFtuYW1lLCBmbl0gPSB0eXBlb2YgbmFtZU9yRm4gPT09IFwic3RyaW5nXCIgPyBbbmFtZU9yRm4sIG1heWJlRm5dIDogW1wib25fY29ubmVjdFwiLCBuYW1lT3JGbl07XG4gICAgY2xpZW50Q29ubmVjdGVkKG5hbWUsIHt9LCBmbik7XG4gIH1cbiAgY2xpZW50RGlzY29ubmVjdGVkKG5hbWVPckZuLCBtYXliZUZuKSB7XG4gICAgY29uc3QgW25hbWUsIGZuXSA9IHR5cGVvZiBuYW1lT3JGbiA9PT0gXCJzdHJpbmdcIiA/IFtuYW1lT3JGbiwgbWF5YmVGbl0gOiBbXCJvbl9kaXNjb25uZWN0XCIsIG5hbWVPckZuXTtcbiAgICBjbGllbnREaXNjb25uZWN0ZWQobmFtZSwge30sIGZuKTtcbiAgfVxuICB2aWV3KG9wdHMsIHJldCwgZm4pIHtcbiAgICBkZWZpbmVWaWV3KG9wdHMsIGZhbHNlLCB7fSwgcmV0LCBmbik7XG4gIH1cbiAgLy8gVE9ETzogcmUtZW5hYmxlIG9uY2UgcGFyYW1ldGVyaXplZCB2aWV3cyBhcmUgc3VwcG9ydGVkIGluIFNRTFxuICAvLyB2aWV3PFJldCBleHRlbmRzIFZpZXdSZXR1cm5UeXBlQnVpbGRlcj4oXG4gIC8vICAgb3B0czogVmlld09wdHMsXG4gIC8vICAgcmV0OiBSZXQsXG4gIC8vICAgZm46IFZpZXdGbjxTLCB7fSwgUmV0PlxuICAvLyApOiB2b2lkO1xuICAvLyB2aWV3PFBhcmFtcyBleHRlbmRzIFBhcmFtc09iaiwgUmV0IGV4dGVuZHMgVmlld1JldHVyblR5cGVCdWlsZGVyPihcbiAgLy8gICBvcHRzOiBWaWV3T3B0cyxcbiAgLy8gICBwYXJhbXM6IFBhcmFtcyxcbiAgLy8gICByZXQ6IFJldCxcbiAgLy8gICBmbjogVmlld0ZuPFMsIHt9LCBSZXQ+XG4gIC8vICk6IHZvaWQ7XG4gIC8vIHZpZXc8UGFyYW1zIGV4dGVuZHMgUGFyYW1zT2JqLCBSZXQgZXh0ZW5kcyBWaWV3UmV0dXJuVHlwZUJ1aWxkZXI+KFxuICAvLyAgIG9wdHM6IFZpZXdPcHRzLFxuICAvLyAgIHBhcmFtc09yUmV0OiBSZXQgfCBQYXJhbXMsXG4gIC8vICAgcmV0T3JGbjogVmlld0ZuPFMsIHt9LCBSZXQ+IHwgUmV0LFxuICAvLyAgIG1heWJlRm4/OiBWaWV3Rm48UywgUGFyYW1zLCBSZXQ+XG4gIC8vICk6IHZvaWQge1xuICAvLyAgIGlmICh0eXBlb2YgcmV0T3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyAgICAgZGVmaW5lVmlldyhuYW1lLCBmYWxzZSwge30sIHBhcmFtc09yUmV0IGFzIFJldCwgcmV0T3JGbik7XG4gIC8vICAgfSBlbHNlIHtcbiAgLy8gICAgIGRlZmluZVZpZXcobmFtZSwgZmFsc2UsIHBhcmFtc09yUmV0IGFzIFBhcmFtcywgcmV0T3JGbiwgbWF5YmVGbiEpO1xuICAvLyAgIH1cbiAgLy8gfVxuICBhbm9ueW1vdXNWaWV3KG9wdHMsIHJldCwgZm4pIHtcbiAgICBkZWZpbmVWaWV3KG9wdHMsIHRydWUsIHt9LCByZXQsIGZuKTtcbiAgfVxuICBwcm9jZWR1cmUobmFtZSwgcGFyYW1zT3JSZXQsIHJldE9yRm4sIG1heWJlRm4pIHtcbiAgICBpZiAodHlwZW9mIHJldE9yRm4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcHJvY2VkdXJlKG5hbWUsIHt9LCBwYXJhbXNPclJldCwgcmV0T3JGbik7XG4gICAgICByZXR1cm4gcmV0T3JGbjtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvY2VkdXJlKG5hbWUsIHBhcmFtc09yUmV0LCByZXRPckZuLCBtYXliZUZuKTtcbiAgICAgIHJldHVybiBtYXliZUZuO1xuICAgIH1cbiAgfVxuICBjbGllbnRWaXNpYmlsaXR5RmlsdGVyID0ge1xuICAgIHNxbChmaWx0ZXIpIHtcbiAgICAgIE1PRFVMRV9ERUYucm93TGV2ZWxTZWN1cml0eS5wdXNoKHsgc3FsOiBmaWx0ZXIgfSk7XG4gICAgfVxuICB9O1xufTtcbmZ1bmN0aW9uIHNjaGVtYSguLi5hcmdzKSB7XG4gIGNvbnN0IGhhbmRsZXMgPSBhcmdzLmxlbmd0aCA9PT0gMSAmJiBBcnJheS5pc0FycmF5KGFyZ3NbMF0pID8gYXJnc1swXSA6IGFyZ3M7XG4gIGNvbnN0IHRhYmxlRGVmcyA9IGhhbmRsZXMubWFwKChoKSA9PiBoLnRhYmxlRGVmKTtcbiAgTU9EVUxFX0RFRi50YWJsZXMucHVzaCguLi50YWJsZURlZnMpO1xuICBSRUdJU1RFUkVEX1NDSEVNQSA9IHtcbiAgICB0YWJsZXM6IGhhbmRsZXMubWFwKChoYW5kbGUpID0+ICh7XG4gICAgICBuYW1lOiBoYW5kbGUudGFibGVOYW1lLFxuICAgICAgYWNjZXNzb3JOYW1lOiBoYW5kbGUudGFibGVOYW1lLFxuICAgICAgY29sdW1uczogaGFuZGxlLnJvd1R5cGUucm93LFxuICAgICAgcm93VHlwZTogaGFuZGxlLnJvd1NwYWNldGltZVR5cGUsXG4gICAgICBpbmRleGVzOiBoYW5kbGUuaWR4cyxcbiAgICAgIGNvbnN0cmFpbnRzOiBoYW5kbGUuY29uc3RyYWludHNcbiAgICB9KSlcbiAgfTtcbiAgcmV0dXJuIG5ldyBTY2hlbWEodGFibGVEZWZzLCBNT0RVTEVfREVGLnR5cGVzcGFjZSwgaGFuZGxlcyk7XG59XG5cbi8vIHNyYy9saWIvYXV0b2dlbi9yYXdfaW5kZXhfYWxnb3JpdGhtX3R5cGUudHNcbnZhciBSYXdJbmRleEFsZ29yaXRobSA9IHQuZW51bShcIlJhd0luZGV4QWxnb3JpdGhtXCIsIHtcbiAgQlRyZWU6IHQuYXJyYXkodC51MTYoKSksXG4gIEhhc2g6IHQuYXJyYXkodC51MTYoKSksXG4gIERpcmVjdDogdC51MTYoKVxufSk7XG52YXIgcmF3X2luZGV4X2FsZ29yaXRobV90eXBlX2RlZmF1bHQgPSBSYXdJbmRleEFsZ29yaXRobTtcblxuLy8gc3JjL2xpYi90YWJsZS50c1xuZnVuY3Rpb24gdGFibGUob3B0cywgcm93KSB7XG4gIGNvbnN0IHtcbiAgICBuYW1lLFxuICAgIHB1YmxpYzogaXNQdWJsaWMgPSBmYWxzZSxcbiAgICBpbmRleGVzOiB1c2VySW5kZXhlcyA9IFtdLFxuICAgIHNjaGVkdWxlZFxuICB9ID0gb3B0cztcbiAgY29uc3QgY29sSWRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgY29sTmFtZUxpc3QgPSBbXTtcbiAgaWYgKCEocm93IGluc3RhbmNlb2YgUm93QnVpbGRlcikpIHtcbiAgICByb3cgPSBuZXcgUm93QnVpbGRlcihyb3cpO1xuICB9XG4gIGlmIChyb3cudHlwZU5hbWUgPT09IHZvaWQgMCkge1xuICAgIHJvdy50eXBlTmFtZSA9IHRvUGFzY2FsQ2FzZShuYW1lKTtcbiAgfVxuICBjb25zdCByb3dUeXBlUmVmID0gcmVnaXN0ZXJUeXBlc1JlY3Vyc2l2ZWx5KHJvdyk7XG4gIHJvdy5hbGdlYnJhaWNUeXBlLnZhbHVlLmVsZW1lbnRzLmZvckVhY2goKGVsZW0sIGkpID0+IHtcbiAgICBjb2xJZHMuc2V0KGVsZW0ubmFtZSwgaSk7XG4gICAgY29sTmFtZUxpc3QucHVzaChlbGVtLm5hbWUpO1xuICB9KTtcbiAgY29uc3QgcGsgPSBbXTtcbiAgY29uc3QgaW5kZXhlcyA9IFtdO1xuICBjb25zdCBjb25zdHJhaW50cyA9IFtdO1xuICBjb25zdCBzZXF1ZW5jZXMgPSBbXTtcbiAgbGV0IHNjaGVkdWxlQXRDb2w7XG4gIGZvciAoY29uc3QgW25hbWUyLCBidWlsZGVyXSBvZiBPYmplY3QuZW50cmllcyhyb3cucm93KSkge1xuICAgIGNvbnN0IG1ldGEgPSBidWlsZGVyLmNvbHVtbk1ldGFkYXRhO1xuICAgIGlmIChtZXRhLmlzUHJpbWFyeUtleSkge1xuICAgICAgcGsucHVzaChjb2xJZHMuZ2V0KG5hbWUyKSk7XG4gICAgfVxuICAgIGNvbnN0IGlzVW5pcXVlID0gbWV0YS5pc1VuaXF1ZSB8fCBtZXRhLmlzUHJpbWFyeUtleTtcbiAgICBpZiAobWV0YS5pbmRleFR5cGUgfHwgaXNVbmlxdWUpIHtcbiAgICAgIGNvbnN0IGFsZ28gPSBtZXRhLmluZGV4VHlwZSA/PyBcImJ0cmVlXCI7XG4gICAgICBjb25zdCBpZCA9IGNvbElkcy5nZXQobmFtZTIpO1xuICAgICAgbGV0IGFsZ29yaXRobTtcbiAgICAgIHN3aXRjaCAoYWxnbykge1xuICAgICAgICBjYXNlIFwiYnRyZWVcIjpcbiAgICAgICAgICBhbGdvcml0aG0gPSByYXdfaW5kZXhfYWxnb3JpdGhtX3R5cGVfZGVmYXVsdC5CVHJlZShbaWRdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRpcmVjdFwiOlxuICAgICAgICAgIGFsZ29yaXRobSA9IHJhd19pbmRleF9hbGdvcml0aG1fdHlwZV9kZWZhdWx0LkRpcmVjdChpZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpbmRleGVzLnB1c2goe1xuICAgICAgICBuYW1lOiB2b2lkIDAsXG4gICAgICAgIC8vIFVubmFtZWQgaW5kZXhlcyB3aWxsIGJlIGFzc2lnbmVkIGEgZ2xvYmFsbHkgdW5pcXVlIG5hbWVcbiAgICAgICAgYWNjZXNzb3JOYW1lOiBuYW1lMixcbiAgICAgICAgLy8gVGhlIG5hbWUgb2YgdGhpcyBjb2x1bW4gd2lsbCBiZSB1c2VkIGFzIHRoZSBhY2Nlc3NvciBuYW1lXG4gICAgICAgIGFsZ29yaXRobVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChpc1VuaXF1ZSkge1xuICAgICAgY29uc3RyYWludHMucHVzaCh7XG4gICAgICAgIG5hbWU6IHZvaWQgMCxcbiAgICAgICAgZGF0YTogeyB0YWc6IFwiVW5pcXVlXCIsIHZhbHVlOiB7IGNvbHVtbnM6IFtjb2xJZHMuZ2V0KG5hbWUyKV0gfSB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKG1ldGEuaXNBdXRvSW5jcmVtZW50KSB7XG4gICAgICBzZXF1ZW5jZXMucHVzaCh7XG4gICAgICAgIG5hbWU6IHZvaWQgMCxcbiAgICAgICAgc3RhcnQ6IHZvaWQgMCxcbiAgICAgICAgbWluVmFsdWU6IHZvaWQgMCxcbiAgICAgICAgbWF4VmFsdWU6IHZvaWQgMCxcbiAgICAgICAgY29sdW1uOiBjb2xJZHMuZ2V0KG5hbWUyKSxcbiAgICAgICAgaW5jcmVtZW50OiAxblxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzY2hlZHVsZWQpIHtcbiAgICAgIGNvbnN0IGFsZ2VicmFpY1R5cGUgPSBidWlsZGVyLnR5cGVCdWlsZGVyLmFsZ2VicmFpY1R5cGU7XG4gICAgICBpZiAoc2NoZWR1bGVfYXRfZGVmYXVsdC5pc1NjaGVkdWxlQXQoYWxnZWJyYWljVHlwZSkpIHtcbiAgICAgICAgc2NoZWR1bGVBdENvbCA9IGNvbElkcy5nZXQobmFtZTIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IGluZGV4T3B0cyBvZiB1c2VySW5kZXhlcyA/PyBbXSkge1xuICAgIGxldCBhbGdvcml0aG07XG4gICAgc3dpdGNoIChpbmRleE9wdHMuYWxnb3JpdGhtKSB7XG4gICAgICBjYXNlIFwiYnRyZWVcIjpcbiAgICAgICAgYWxnb3JpdGhtID0ge1xuICAgICAgICAgIHRhZzogXCJCVHJlZVwiLFxuICAgICAgICAgIHZhbHVlOiBpbmRleE9wdHMuY29sdW1ucy5tYXAoKGMpID0+IGNvbElkcy5nZXQoYykpXG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImRpcmVjdFwiOlxuICAgICAgICBhbGdvcml0aG0gPSB7IHRhZzogXCJEaXJlY3RcIiwgdmFsdWU6IGNvbElkcy5nZXQoaW5kZXhPcHRzLmNvbHVtbikgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGluZGV4ZXMucHVzaCh7IG5hbWU6IHZvaWQgMCwgYWNjZXNzb3JOYW1lOiBpbmRleE9wdHMubmFtZSwgYWxnb3JpdGhtIH0pO1xuICB9XG4gIGZvciAoY29uc3QgY29uc3RyYWludE9wdHMgb2Ygb3B0cy5jb25zdHJhaW50cyA/PyBbXSkge1xuICAgIGlmIChjb25zdHJhaW50T3B0cy5jb25zdHJhaW50ID09PSBcInVuaXF1ZVwiKSB7XG4gICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICB0YWc6IFwiVW5pcXVlXCIsXG4gICAgICAgIHZhbHVlOiB7IGNvbHVtbnM6IGNvbnN0cmFpbnRPcHRzLmNvbHVtbnMubWFwKChjKSA9PiBjb2xJZHMuZ2V0KGMpKSB9XG4gICAgICB9O1xuICAgICAgY29uc3RyYWludHMucHVzaCh7IG5hbWU6IGNvbnN0cmFpbnRPcHRzLm5hbWUsIGRhdGEgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBpbmRleCBvZiBpbmRleGVzKSB7XG4gICAgY29uc3QgY29scyA9IGluZGV4LmFsZ29yaXRobS50YWcgPT09IFwiRGlyZWN0XCIgPyBbaW5kZXguYWxnb3JpdGhtLnZhbHVlXSA6IGluZGV4LmFsZ29yaXRobS52YWx1ZTtcbiAgICBjb25zdCBjb2xTID0gY29scy5tYXAoKGkpID0+IGNvbE5hbWVMaXN0W2ldKS5qb2luKFwiX1wiKTtcbiAgICBpbmRleC5uYW1lID0gYCR7bmFtZX1fJHtjb2xTfV9pZHhfJHtpbmRleC5hbGdvcml0aG0udGFnLnRvTG93ZXJDYXNlKCl9YDtcbiAgfVxuICBjb25zdCB0YWJsZURlZiA9IHtcbiAgICBuYW1lLFxuICAgIHByb2R1Y3RUeXBlUmVmOiByb3dUeXBlUmVmLnJlZixcbiAgICBwcmltYXJ5S2V5OiBwayxcbiAgICBpbmRleGVzLFxuICAgIGNvbnN0cmFpbnRzLFxuICAgIHNlcXVlbmNlcyxcbiAgICBzY2hlZHVsZTogc2NoZWR1bGVkICYmIHNjaGVkdWxlQXRDb2wgIT09IHZvaWQgMCA/IHtcbiAgICAgIG5hbWU6IHZvaWQgMCxcbiAgICAgIHJlZHVjZXJOYW1lOiBzY2hlZHVsZWQsXG4gICAgICBzY2hlZHVsZWRBdENvbHVtbjogc2NoZWR1bGVBdENvbFxuICAgIH0gOiB2b2lkIDAsXG4gICAgdGFibGVUeXBlOiB7IHRhZzogXCJVc2VyXCIgfSxcbiAgICB0YWJsZUFjY2VzczogeyB0YWc6IGlzUHVibGljID8gXCJQdWJsaWNcIiA6IFwiUHJpdmF0ZVwiIH1cbiAgfTtcbiAgY29uc3QgcHJvZHVjdFR5cGUgPSByb3cuYWxnZWJyYWljVHlwZS52YWx1ZTtcbiAgcmV0dXJuIHtcbiAgICByb3dUeXBlOiByb3csXG4gICAgdGFibGVOYW1lOiBuYW1lLFxuICAgIHJvd1NwYWNldGltZVR5cGU6IHByb2R1Y3RUeXBlLFxuICAgIHRhYmxlRGVmLFxuICAgIGlkeHM6IHt9LFxuICAgIGNvbnN0cmFpbnRzXG4gIH07XG59XG5cbi8vIHNyYy9zZXJ2ZXIvZXJyb3JzLnRzXG52YXIgU3BhY2V0aW1lSG9zdEVycm9yID0gY2xhc3MgX1NwYWNldGltZUhvc3RFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29kZTtcbiAgbWVzc2FnZTtcbiAgY29uc3RydWN0b3IoY29kZSwgbWVzc2FnZSkge1xuICAgIHN1cGVyKCk7XG4gICAgY29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyk7XG4gICAgbGV0IGNscztcbiAgICBpZiAoZXJyb3JQcm90b3lwZXMuaGFzKHByb3RvKSkge1xuICAgICAgY2xzID0gcHJvdG8uY29uc3RydWN0b3I7XG4gICAgICBpZiAoY29kZSAhPT0gY2xzLkNPREUpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGludmFsaWQgZXJyb3IgY29kZSBmb3IgJHtjbHMubmFtZX1gKTtcbiAgICB9IGVsc2UgaWYgKHByb3RvID09PSBfU3BhY2V0aW1lSG9zdEVycm9yLnByb3RvdHlwZSkge1xuICAgICAgY2xzID0gZXJybm9Ub0NsYXNzLmdldChjb2RlKTtcbiAgICAgIGlmICghY2xzKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgdW5rbm93biBlcnJvciBjb2RlICR7Y29kZX1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbm5vdCBzdWJjbGFzcyBTcGFjZXRpbWVFcnJvclwiKTtcbiAgICB9XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIGNscy5wcm90b3R5cGUpO1xuICAgIHRoaXMuY29kZSA9IGNscy5DT0RFO1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgPz8gY2xzLk1FU1NBR0U7XG4gIH1cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIGVycm5vVG9DbGFzcy5nZXQodGhpcy5jb2RlKT8ubmFtZSA/PyBcIlNwYWNldGltZUhvc3RFcnJvclwiO1xuICB9XG59O1xudmFyIFNlbmRlckVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgfVxuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gXCJTZW5kZXJFcnJvclwiO1xuICB9XG59O1xudmFyIGVycm9yRGF0YSA9IHtcbiAgLyoqXG4gICAqIEEgZ2VuZXJpYyBlcnJvciBjbGFzcyBmb3IgdW5rbm93biBlcnJvciBjb2Rlcy5cbiAgICovXG4gIEhvc3RDYWxsRmFpbHVyZTogWzEsIFwiQUJJIGNhbGxlZCBieSBob3N0IHJldHVybmVkIGFuIGVycm9yXCJdLFxuICAvKipcbiAgICogRXJyb3IgaW5kaWNhdGluZyB0aGF0IGFuIEFCSSBjYWxsIHdhcyBtYWRlIG91dHNpZGUgb2YgYSB0cmFuc2FjdGlvbi5cbiAgICovXG4gIE5vdEluVHJhbnNhY3Rpb246IFsyLCBcIkFCSSBjYWxsIGNhbiBvbmx5IGJlIG1hZGUgd2hpbGUgaW4gYSB0cmFuc2FjdGlvblwiXSxcbiAgLyoqXG4gICAqIEVycm9yIGluZGljYXRpbmcgdGhhdCBCU0FUTiBkZWNvZGluZyBmYWlsZWQuXG4gICAqIFRoaXMgdHlwaWNhbGx5IG1lYW5zIHRoYXQgdGhlIGRhdGEgY291bGQgbm90IGJlIGRlY29kZWQgdG8gdGhlIGV4cGVjdGVkIHR5cGUuXG4gICAqL1xuICBCc2F0bkRlY29kZUVycm9yOiBbMywgXCJDb3VsZG4ndCBkZWNvZGUgdGhlIEJTQVROIHRvIHRoZSBleHBlY3RlZCB0eXBlXCJdLFxuICAvKipcbiAgICogRXJyb3IgaW5kaWNhdGluZyB0aGF0IGEgc3BlY2lmaWVkIHRhYmxlIGRvZXMgbm90IGV4aXN0LlxuICAgKi9cbiAgTm9TdWNoVGFibGU6IFs0LCBcIk5vIHN1Y2ggdGFibGVcIl0sXG4gIC8qKlxuICAgKiBFcnJvciBpbmRpY2F0aW5nIHRoYXQgYSBzcGVjaWZpZWQgaW5kZXggZG9lcyBub3QgZXhpc3QuXG4gICAqL1xuICBOb1N1Y2hJbmRleDogWzUsIFwiTm8gc3VjaCBpbmRleFwiXSxcbiAgLyoqXG4gICAqIEVycm9yIGluZGljYXRpbmcgdGhhdCBhIHNwZWNpZmllZCByb3cgaXRlcmF0b3IgaXMgbm90IHZhbGlkLlxuICAgKi9cbiAgTm9TdWNoSXRlcjogWzYsIFwiVGhlIHByb3ZpZGVkIHJvdyBpdGVyYXRvciBpcyBub3QgdmFsaWRcIl0sXG4gIC8qKlxuICAgKiBFcnJvciBpbmRpY2F0aW5nIHRoYXQgYSBzcGVjaWZpZWQgY29uc29sZSB0aW1lciBkb2VzIG5vdCBleGlzdC5cbiAgICovXG4gIE5vU3VjaENvbnNvbGVUaW1lcjogWzcsIFwiVGhlIHByb3ZpZGVkIGNvbnNvbGUgdGltZXIgZG9lcyBub3QgZXhpc3RcIl0sXG4gIC8qKlxuICAgKiBFcnJvciBpbmRpY2F0aW5nIHRoYXQgYSBzcGVjaWZpZWQgYnl0ZXMgc291cmNlIG9yIHNpbmsgaXMgbm90IHZhbGlkLlxuICAgKi9cbiAgTm9TdWNoQnl0ZXM6IFs4LCBcIlRoZSBwcm92aWRlZCBieXRlcyBzb3VyY2Ugb3Igc2luayBpcyBub3QgdmFsaWRcIl0sXG4gIC8qKlxuICAgKiBFcnJvciBpbmRpY2F0aW5nIHRoYXQgYSBwcm92aWRlZCBzaW5rIGhhcyBubyBtb3JlIHNwYWNlIGxlZnQuXG4gICAqL1xuICBOb1NwYWNlOiBbOSwgXCJUaGUgcHJvdmlkZWQgc2luayBoYXMgbm8gbW9yZSBzcGFjZSBsZWZ0XCJdLFxuICAvKipcbiAgICogRXJyb3IgaW5kaWNhdGluZyB0aGF0IHRoZXJlIGlzIG5vIG1vcmUgc3BhY2UgaW4gdGhlIGRhdGFiYXNlLlxuICAgKi9cbiAgQnVmZmVyVG9vU21hbGw6IFtcbiAgICAxMSxcbiAgICBcIlRoZSBwcm92aWRlZCBidWZmZXIgaXMgbm90IGxhcmdlIGVub3VnaCB0byBzdG9yZSB0aGUgZGF0YVwiXG4gIF0sXG4gIC8qKlxuICAgKiBFcnJvciBpbmRpY2F0aW5nIHRoYXQgYSB2YWx1ZSB3aXRoIGEgZ2l2ZW4gdW5pcXVlIGlkZW50aWZpZXIgYWxyZWFkeSBleGlzdHMuXG4gICAqL1xuICBVbmlxdWVBbHJlYWR5RXhpc3RzOiBbXG4gICAgMTIsXG4gICAgXCJWYWx1ZSB3aXRoIGdpdmVuIHVuaXF1ZSBpZGVudGlmaWVyIGFscmVhZHkgZXhpc3RzXCJcbiAgXSxcbiAgLyoqXG4gICAqIEVycm9yIGluZGljYXRpbmcgdGhhdCB0aGUgc3BlY2lmaWVkIGRlbGF5IGluIHNjaGVkdWxpbmcgYSByb3cgd2FzIHRvbyBsb25nLlxuICAgKi9cbiAgU2NoZWR1bGVBdERlbGF5VG9vTG9uZzogW1xuICAgIDEzLFxuICAgIFwiU3BlY2lmaWVkIGRlbGF5IGluIHNjaGVkdWxpbmcgcm93IHdhcyB0b28gbG9uZ1wiXG4gIF0sXG4gIC8qKlxuICAgKiBFcnJvciBpbmRpY2F0aW5nIHRoYXQgYW4gaW5kZXggd2FzIG5vdCB1bmlxdWUgd2hlbiBpdCB3YXMgZXhwZWN0ZWQgdG8gYmUuXG4gICAqL1xuICBJbmRleE5vdFVuaXF1ZTogWzE0LCBcIlRoZSBpbmRleCB3YXMgbm90IHVuaXF1ZVwiXSxcbiAgLyoqXG4gICAqIEVycm9yIGluZGljYXRpbmcgdGhhdCBhbiBpbmRleCB3YXMgbm90IHVuaXF1ZSB3aGVuIGl0IHdhcyBleHBlY3RlZCB0byBiZS5cbiAgICovXG4gIE5vU3VjaFJvdzogWzE1LCBcIlRoZSByb3cgd2FzIG5vdCBmb3VuZCwgZS5nLiwgaW4gYW4gdXBkYXRlIGNhbGxcIl0sXG4gIC8qKlxuICAgKiBFcnJvciBpbmRpY2F0aW5nIHRoYXQgYW4gYXV0by1pbmNyZW1lbnQgc2VxdWVuY2UgaGFzIG92ZXJmbG93ZWQuXG4gICAqL1xuICBBdXRvSW5jT3ZlcmZsb3c6IFsxNiwgXCJUaGUgYXV0by1pbmNyZW1lbnQgc2VxdWVuY2Ugb3ZlcmZsb3dlZFwiXSxcbiAgV291bGRCbG9ja1RyYW5zYWN0aW9uOiBbXG4gICAgMTcsXG4gICAgXCJBdHRlbXB0ZWQgYXN5bmMgb3IgYmxvY2tpbmcgb3Agd2hpbGUgaG9sZGluZyBvcGVuIGEgdHJhbnNhY3Rpb25cIlxuICBdLFxuICBUcmFuc2FjdGlvbk5vdEFub255bW91czogW1xuICAgIDE4LFxuICAgIFwiTm90IGluIGFuIGFub255bW91cyB0cmFuc2FjdGlvbi4gQ2FsbGVkIGJ5IGEgcmVkdWNlcj9cIlxuICBdLFxuICBUcmFuc2FjdGlvbklzUmVhZE9ubHk6IFtcbiAgICAxOSxcbiAgICBcIkFCSSBjYWxsIGNhbiBvbmx5IGJlIG1hZGUgd2hpbGUgd2l0aGluIGEgbXV0YWJsZSB0cmFuc2FjdGlvblwiXG4gIF0sXG4gIFRyYW5zYWN0aW9uSXNNdXQ6IFtcbiAgICAyMCxcbiAgICBcIkFCSSBjYWxsIGNhbiBvbmx5IGJlIG1hZGUgd2hpbGUgd2l0aGluIGEgcmVhZC1vbmx5IHRyYW5zYWN0aW9uXCJcbiAgXSxcbiAgSHR0cEVycm9yOiBbMjEsIFwiVGhlIEhUVFAgcmVxdWVzdCBmYWlsZWRcIl1cbn07XG5mdW5jdGlvbiBtYXBFbnRyaWVzKHgsIGYpIHtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBPYmplY3QuZW50cmllcyh4KS5tYXAoKFtrLCB2XSkgPT4gW2ssIGYoaywgdildKVxuICApO1xufVxudmFyIGVycm9ycyA9IE9iamVjdC5mcmVlemUoXG4gIG1hcEVudHJpZXMoXG4gICAgZXJyb3JEYXRhLFxuICAgIChuYW1lLCBbY29kZSwgbWVzc2FnZV0pID0+IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgIGNsYXNzIGV4dGVuZHMgU3BhY2V0aW1lSG9zdEVycm9yIHtcbiAgICAgICAgc3RhdGljIENPREUgPSBjb2RlO1xuICAgICAgICBzdGF0aWMgTUVTU0FHRSA9IG1lc3NhZ2U7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgIHN1cGVyKGNvZGUpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJuYW1lXCIsXG4gICAgICB7IHZhbHVlOiBuYW1lLCB3cml0YWJsZTogZmFsc2UgfVxuICAgIClcbiAgKVxuKTtcbnZhciBlcnJvclByb3RveXBlcyA9IG5ldyBTZXQoT2JqZWN0LnZhbHVlcyhlcnJvcnMpLm1hcCgoY2xzKSA9PiBjbHMucHJvdG90eXBlKSk7XG52YXIgZXJybm9Ub0NsYXNzID0gbmV3IE1hcChcbiAgT2JqZWN0LnZhbHVlcyhlcnJvcnMpLm1hcCgoY2xzKSA9PiBbY2xzLkNPREUsIGNsc10pXG4pO1xuXG4vLyBzcmMvc2VydmVyL3BvbHlmaWxscy50c1xuX190b0VTTShyZXF1aXJlX3RleHRfbWluKCkpO1xuXG4vLyBzcmMvbGliL2F1dG9nZW4vc3VtX3R5cGVfdmFyaWFudF90eXBlLnRzXG52YXIgc3VtX3R5cGVfdmFyaWFudF90eXBlX2RlZmF1bHQgPSB0Lm9iamVjdChcIlN1bVR5cGVWYXJpYW50XCIsIHtcbiAgbmFtZTogdC5vcHRpb24odC5zdHJpbmcoKSksXG4gIGdldCBhbGdlYnJhaWNUeXBlKCkge1xuICAgIHJldHVybiBhbGdlYnJhaWNfdHlwZV90eXBlX2RlZmF1bHQ7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL2F1dG9nZW4vc3VtX3R5cGVfdHlwZS50c1xudmFyIHN1bV90eXBlX3R5cGVfZGVmYXVsdCA9IHQub2JqZWN0KFwiU3VtVHlwZVwiLCB7XG4gIGdldCB2YXJpYW50cygpIHtcbiAgICByZXR1cm4gdC5hcnJheShzdW1fdHlwZV92YXJpYW50X3R5cGVfZGVmYXVsdCk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL2F1dG9nZW4vcHJvZHVjdF90eXBlX2VsZW1lbnRfdHlwZS50c1xudmFyIHByb2R1Y3RfdHlwZV9lbGVtZW50X3R5cGVfZGVmYXVsdCA9IHQub2JqZWN0KFwiUHJvZHVjdFR5cGVFbGVtZW50XCIsIHtcbiAgbmFtZTogdC5vcHRpb24odC5zdHJpbmcoKSksXG4gIGdldCBhbGdlYnJhaWNUeXBlKCkge1xuICAgIHJldHVybiBhbGdlYnJhaWNfdHlwZV90eXBlX2RlZmF1bHQ7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL2F1dG9nZW4vcHJvZHVjdF90eXBlX3R5cGUudHNcbnZhciBwcm9kdWN0X3R5cGVfdHlwZV9kZWZhdWx0ID0gdC5vYmplY3QoXCJQcm9kdWN0VHlwZVwiLCB7XG4gIGdldCBlbGVtZW50cygpIHtcbiAgICByZXR1cm4gdC5hcnJheShwcm9kdWN0X3R5cGVfZWxlbWVudF90eXBlX2RlZmF1bHQpO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9hdXRvZ2VuL2FsZ2VicmFpY190eXBlX3R5cGUudHNcbnZhciBBbGdlYnJhaWNUeXBlMiA9IHQuZW51bShcIkFsZ2VicmFpY1R5cGVcIiwge1xuICBSZWY6IHQudTMyKCksXG4gIGdldCBTdW0oKSB7XG4gICAgcmV0dXJuIHN1bV90eXBlX3R5cGVfZGVmYXVsdDtcbiAgfSxcbiAgZ2V0IFByb2R1Y3QoKSB7XG4gICAgcmV0dXJuIHByb2R1Y3RfdHlwZV90eXBlX2RlZmF1bHQ7XG4gIH0sXG4gIGdldCBBcnJheSgpIHtcbiAgICByZXR1cm4gQWxnZWJyYWljVHlwZTI7XG4gIH0sXG4gIFN0cmluZzogdC51bml0KCksXG4gIEJvb2w6IHQudW5pdCgpLFxuICBJODogdC51bml0KCksXG4gIFU4OiB0LnVuaXQoKSxcbiAgSTE2OiB0LnVuaXQoKSxcbiAgVTE2OiB0LnVuaXQoKSxcbiAgSTMyOiB0LnVuaXQoKSxcbiAgVTMyOiB0LnVuaXQoKSxcbiAgSTY0OiB0LnVuaXQoKSxcbiAgVTY0OiB0LnVuaXQoKSxcbiAgSTEyODogdC51bml0KCksXG4gIFUxMjg6IHQudW5pdCgpLFxuICBJMjU2OiB0LnVuaXQoKSxcbiAgVTI1NjogdC51bml0KCksXG4gIEYzMjogdC51bml0KCksXG4gIEY2NDogdC51bml0KClcbn0pO1xudmFyIGFsZ2VicmFpY190eXBlX3R5cGVfZGVmYXVsdCA9IEFsZ2VicmFpY1R5cGUyO1xuXG4vLyBzcmMvbGliL2F1dG9nZW4vdHlwZXNwYWNlX3R5cGUudHNcbnZhciB0eXBlc3BhY2VfdHlwZV9kZWZhdWx0ID0gdC5vYmplY3QoXCJUeXBlc3BhY2VcIiwge1xuICBnZXQgdHlwZXMoKSB7XG4gICAgcmV0dXJuIHQuYXJyYXkoYWxnZWJyYWljX3R5cGVfdHlwZV9kZWZhdWx0KTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvYXV0b2dlbi9yYXdfY29sdW1uX2RlZl92XzhfdHlwZS50c1xudmFyIHJhd19jb2x1bW5fZGVmX3ZfOF90eXBlX2RlZmF1bHQgPSB0Lm9iamVjdChcIlJhd0NvbHVtbkRlZlY4XCIsIHtcbiAgY29sTmFtZTogdC5zdHJpbmcoKSxcbiAgZ2V0IGNvbFR5cGUoKSB7XG4gICAgcmV0dXJuIGFsZ2VicmFpY190eXBlX3R5cGVfZGVmYXVsdDtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvYXV0b2dlbi9pbmRleF90eXBlX3R5cGUudHNcbnZhciBJbmRleFR5cGUgPSB0LmVudW0oXCJJbmRleFR5cGVcIiwge1xuICBCVHJlZTogdC51bml0KCksXG4gIEhhc2g6IHQudW5pdCgpXG59KTtcbnZhciBpbmRleF90eXBlX3R5cGVfZGVmYXVsdCA9IEluZGV4VHlwZTtcblxuLy8gc3JjL2xpYi9hdXRvZ2VuL3Jhd19pbmRleF9kZWZfdl84X3R5cGUudHNcbnZhciByYXdfaW5kZXhfZGVmX3ZfOF90eXBlX2RlZmF1bHQgPSB0Lm9iamVjdChcIlJhd0luZGV4RGVmVjhcIiwge1xuICBpbmRleE5hbWU6IHQuc3RyaW5nKCksXG4gIGlzVW5pcXVlOiB0LmJvb2woKSxcbiAgZ2V0IGluZGV4VHlwZSgpIHtcbiAgICByZXR1cm4gaW5kZXhfdHlwZV90eXBlX2RlZmF1bHQ7XG4gIH0sXG4gIGNvbHVtbnM6IHQuYXJyYXkodC51MTYoKSlcbn0pO1xuXG4vLyBzcmMvbGliL2F1dG9nZW4vcmF3X2NvbnN0cmFpbnRfZGVmX3ZfOF90eXBlLnRzXG52YXIgcmF3X2NvbnN0cmFpbnRfZGVmX3ZfOF90eXBlX2RlZmF1bHQgPSB0Lm9iamVjdChcIlJhd0NvbnN0cmFpbnREZWZWOFwiLCB7XG4gIGNvbnN0cmFpbnROYW1lOiB0LnN0cmluZygpLFxuICBjb25zdHJhaW50czogdC51OCgpLFxuICBjb2x1bW5zOiB0LmFycmF5KHQudTE2KCkpXG59KTtcblxuLy8gc3JjL2xpYi9hdXRvZ2VuL3Jhd19zZXF1ZW5jZV9kZWZfdl84X3R5cGUudHNcbnZhciByYXdfc2VxdWVuY2VfZGVmX3ZfOF90eXBlX2RlZmF1bHQgPSB0Lm9iamVjdChcIlJhd1NlcXVlbmNlRGVmVjhcIiwge1xuICBzZXF1ZW5jZU5hbWU6IHQuc3RyaW5nKCksXG4gIGNvbFBvczogdC51MTYoKSxcbiAgaW5jcmVtZW50OiB0LmkxMjgoKSxcbiAgc3RhcnQ6IHQub3B0aW9uKHQuaTEyOCgpKSxcbiAgbWluVmFsdWU6IHQub3B0aW9uKHQuaTEyOCgpKSxcbiAgbWF4VmFsdWU6IHQub3B0aW9uKHQuaTEyOCgpKSxcbiAgYWxsb2NhdGVkOiB0LmkxMjgoKVxufSk7XG5cbi8vIHNyYy9saWIvYXV0b2dlbi9yYXdfdGFibGVfZGVmX3ZfOF90eXBlLnRzXG52YXIgcmF3X3RhYmxlX2RlZl92XzhfdHlwZV9kZWZhdWx0ID0gdC5vYmplY3QoXCJSYXdUYWJsZURlZlY4XCIsIHtcbiAgdGFibGVOYW1lOiB0LnN0cmluZygpLFxuICBnZXQgY29sdW1ucygpIHtcbiAgICByZXR1cm4gdC5hcnJheShyYXdfY29sdW1uX2RlZl92XzhfdHlwZV9kZWZhdWx0KTtcbiAgfSxcbiAgZ2V0IGluZGV4ZXMoKSB7XG4gICAgcmV0dXJuIHQuYXJyYXkocmF3X2luZGV4X2RlZl92XzhfdHlwZV9kZWZhdWx0KTtcbiAgfSxcbiAgZ2V0IGNvbnN0cmFpbnRzKCkge1xuICAgIHJldHVybiB0LmFycmF5KHJhd19jb25zdHJhaW50X2RlZl92XzhfdHlwZV9kZWZhdWx0KTtcbiAgfSxcbiAgZ2V0IHNlcXVlbmNlcygpIHtcbiAgICByZXR1cm4gdC5hcnJheShyYXdfc2VxdWVuY2VfZGVmX3ZfOF90eXBlX2RlZmF1bHQpO1xuICB9LFxuICB0YWJsZVR5cGU6IHQuc3RyaW5nKCksXG4gIHRhYmxlQWNjZXNzOiB0LnN0cmluZygpLFxuICBzY2hlZHVsZWQ6IHQub3B0aW9uKHQuc3RyaW5nKCkpXG59KTtcblxuLy8gc3JjL2xpYi9hdXRvZ2VuL3RhYmxlX2Rlc2NfdHlwZS50c1xudmFyIHRhYmxlX2Rlc2NfdHlwZV9kZWZhdWx0ID0gdC5vYmplY3QoXCJUYWJsZURlc2NcIiwge1xuICBnZXQgc2NoZW1hKCkge1xuICAgIHJldHVybiByYXdfdGFibGVfZGVmX3ZfOF90eXBlX2RlZmF1bHQ7XG4gIH0sXG4gIGRhdGE6IHQudTMyKClcbn0pO1xuXG4vLyBzcmMvbGliL2F1dG9nZW4vcmVkdWNlcl9kZWZfdHlwZS50c1xudmFyIHJlZHVjZXJfZGVmX3R5cGVfZGVmYXVsdCA9IHQub2JqZWN0KFwiUmVkdWNlckRlZlwiLCB7XG4gIG5hbWU6IHQuc3RyaW5nKCksXG4gIGdldCBhcmdzKCkge1xuICAgIHJldHVybiB0LmFycmF5KHByb2R1Y3RfdHlwZV9lbGVtZW50X3R5cGVfZGVmYXVsdCk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL2F1dG9nZW4vdHlwZV9hbGlhc190eXBlLnRzXG52YXIgdHlwZV9hbGlhc190eXBlX2RlZmF1bHQgPSB0Lm9iamVjdChcIlR5cGVBbGlhc1wiLCB7XG4gIG5hbWU6IHQuc3RyaW5nKCksXG4gIHR5OiB0LnUzMigpXG59KTtcblxuLy8gc3JjL2xpYi9hdXRvZ2VuL21pc2NfbW9kdWxlX2V4cG9ydF90eXBlLnRzXG52YXIgTWlzY01vZHVsZUV4cG9ydCA9IHQuZW51bShcIk1pc2NNb2R1bGVFeHBvcnRcIiwge1xuICBnZXQgVHlwZUFsaWFzKCkge1xuICAgIHJldHVybiB0eXBlX2FsaWFzX3R5cGVfZGVmYXVsdDtcbiAgfVxufSk7XG52YXIgbWlzY19tb2R1bGVfZXhwb3J0X3R5cGVfZGVmYXVsdCA9IE1pc2NNb2R1bGVFeHBvcnQ7XG5cbi8vIHNyYy9saWIvYXV0b2dlbi9yYXdfbW9kdWxlX2RlZl92XzhfdHlwZS50c1xudmFyIHJhd19tb2R1bGVfZGVmX3ZfOF90eXBlX2RlZmF1bHQgPSB0Lm9iamVjdChcIlJhd01vZHVsZURlZlY4XCIsIHtcbiAgZ2V0IHR5cGVzcGFjZSgpIHtcbiAgICByZXR1cm4gdHlwZXNwYWNlX3R5cGVfZGVmYXVsdDtcbiAgfSxcbiAgZ2V0IHRhYmxlcygpIHtcbiAgICByZXR1cm4gdC5hcnJheSh0YWJsZV9kZXNjX3R5cGVfZGVmYXVsdCk7XG4gIH0sXG4gIGdldCByZWR1Y2VycygpIHtcbiAgICByZXR1cm4gdC5hcnJheShyZWR1Y2VyX2RlZl90eXBlX2RlZmF1bHQpO1xuICB9LFxuICBnZXQgbWlzY0V4cG9ydHMoKSB7XG4gICAgcmV0dXJuIHQuYXJyYXkobWlzY19tb2R1bGVfZXhwb3J0X3R5cGVfZGVmYXVsdCk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL2F1dG9nZW4vcmF3X2luZGV4X2RlZl92XzlfdHlwZS50c1xudmFyIHJhd19pbmRleF9kZWZfdl85X3R5cGVfZGVmYXVsdCA9IHQub2JqZWN0KFwiUmF3SW5kZXhEZWZWOVwiLCB7XG4gIG5hbWU6IHQub3B0aW9uKHQuc3RyaW5nKCkpLFxuICBhY2Nlc3Nvck5hbWU6IHQub3B0aW9uKHQuc3RyaW5nKCkpLFxuICBnZXQgYWxnb3JpdGhtKCkge1xuICAgIHJldHVybiByYXdfaW5kZXhfYWxnb3JpdGhtX3R5cGVfZGVmYXVsdDtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvYXV0b2dlbi9yYXdfdW5pcXVlX2NvbnN0cmFpbnRfZGF0YV92XzlfdHlwZS50c1xudmFyIHJhd191bmlxdWVfY29uc3RyYWludF9kYXRhX3ZfOV90eXBlX2RlZmF1bHQgPSB0Lm9iamVjdChcIlJhd1VuaXF1ZUNvbnN0cmFpbnREYXRhVjlcIiwge1xuICBjb2x1bW5zOiB0LmFycmF5KHQudTE2KCkpXG59KTtcblxuLy8gc3JjL2xpYi9hdXRvZ2VuL3Jhd19jb25zdHJhaW50X2RhdGFfdl85X3R5cGUudHNcbnZhciBSYXdDb25zdHJhaW50RGF0YVY5ID0gdC5lbnVtKFwiUmF3Q29uc3RyYWludERhdGFWOVwiLCB7XG4gIGdldCBVbmlxdWUoKSB7XG4gICAgcmV0dXJuIHJhd191bmlxdWVfY29uc3RyYWludF9kYXRhX3ZfOV90eXBlX2RlZmF1bHQ7XG4gIH1cbn0pO1xudmFyIHJhd19jb25zdHJhaW50X2RhdGFfdl85X3R5cGVfZGVmYXVsdCA9IFJhd0NvbnN0cmFpbnREYXRhVjk7XG5cbi8vIHNyYy9saWIvYXV0b2dlbi9yYXdfY29uc3RyYWludF9kZWZfdl85X3R5cGUudHNcbnZhciByYXdfY29uc3RyYWludF9kZWZfdl85X3R5cGVfZGVmYXVsdCA9IHQub2JqZWN0KFwiUmF3Q29uc3RyYWludERlZlY5XCIsIHtcbiAgbmFtZTogdC5vcHRpb24odC5zdHJpbmcoKSksXG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiByYXdfY29uc3RyYWludF9kYXRhX3ZfOV90eXBlX2RlZmF1bHQ7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL2F1dG9nZW4vcmF3X3NlcXVlbmNlX2RlZl92XzlfdHlwZS50c1xudmFyIHJhd19zZXF1ZW5jZV9kZWZfdl85X3R5cGVfZGVmYXVsdCA9IHQub2JqZWN0KFwiUmF3U2VxdWVuY2VEZWZWOVwiLCB7XG4gIG5hbWU6IHQub3B0aW9uKHQuc3RyaW5nKCkpLFxuICBjb2x1bW46IHQudTE2KCksXG4gIHN0YXJ0OiB0Lm9wdGlvbih0LmkxMjgoKSksXG4gIG1pblZhbHVlOiB0Lm9wdGlvbih0LmkxMjgoKSksXG4gIG1heFZhbHVlOiB0Lm9wdGlvbih0LmkxMjgoKSksXG4gIGluY3JlbWVudDogdC5pMTI4KClcbn0pO1xuXG4vLyBzcmMvbGliL2F1dG9nZW4vcmF3X3NjaGVkdWxlX2RlZl92XzlfdHlwZS50c1xudmFyIHJhd19zY2hlZHVsZV9kZWZfdl85X3R5cGVfZGVmYXVsdCA9IHQub2JqZWN0KFwiUmF3U2NoZWR1bGVEZWZWOVwiLCB7XG4gIG5hbWU6IHQub3B0aW9uKHQuc3RyaW5nKCkpLFxuICByZWR1Y2VyTmFtZTogdC5zdHJpbmcoKSxcbiAgc2NoZWR1bGVkQXRDb2x1bW46IHQudTE2KClcbn0pO1xuXG4vLyBzcmMvbGliL2F1dG9nZW4vdGFibGVfdHlwZV90eXBlLnRzXG52YXIgVGFibGVUeXBlID0gdC5lbnVtKFwiVGFibGVUeXBlXCIsIHtcbiAgU3lzdGVtOiB0LnVuaXQoKSxcbiAgVXNlcjogdC51bml0KClcbn0pO1xudmFyIHRhYmxlX3R5cGVfdHlwZV9kZWZhdWx0ID0gVGFibGVUeXBlO1xuXG4vLyBzcmMvbGliL2F1dG9nZW4vdGFibGVfYWNjZXNzX3R5cGUudHNcbnZhciBUYWJsZUFjY2VzcyA9IHQuZW51bShcIlRhYmxlQWNjZXNzXCIsIHtcbiAgUHVibGljOiB0LnVuaXQoKSxcbiAgUHJpdmF0ZTogdC51bml0KClcbn0pO1xudmFyIHRhYmxlX2FjY2Vzc190eXBlX2RlZmF1bHQgPSBUYWJsZUFjY2VzcztcblxuLy8gc3JjL2xpYi9hdXRvZ2VuL3Jhd190YWJsZV9kZWZfdl85X3R5cGUudHNcbnZhciByYXdfdGFibGVfZGVmX3ZfOV90eXBlX2RlZmF1bHQgPSB0Lm9iamVjdChcIlJhd1RhYmxlRGVmVjlcIiwge1xuICBuYW1lOiB0LnN0cmluZygpLFxuICBwcm9kdWN0VHlwZVJlZjogdC51MzIoKSxcbiAgcHJpbWFyeUtleTogdC5hcnJheSh0LnUxNigpKSxcbiAgZ2V0IGluZGV4ZXMoKSB7XG4gICAgcmV0dXJuIHQuYXJyYXkocmF3X2luZGV4X2RlZl92XzlfdHlwZV9kZWZhdWx0KTtcbiAgfSxcbiAgZ2V0IGNvbnN0cmFpbnRzKCkge1xuICAgIHJldHVybiB0LmFycmF5KHJhd19jb25zdHJhaW50X2RlZl92XzlfdHlwZV9kZWZhdWx0KTtcbiAgfSxcbiAgZ2V0IHNlcXVlbmNlcygpIHtcbiAgICByZXR1cm4gdC5hcnJheShyYXdfc2VxdWVuY2VfZGVmX3ZfOV90eXBlX2RlZmF1bHQpO1xuICB9LFxuICBnZXQgc2NoZWR1bGUoKSB7XG4gICAgcmV0dXJuIHQub3B0aW9uKHJhd19zY2hlZHVsZV9kZWZfdl85X3R5cGVfZGVmYXVsdCk7XG4gIH0sXG4gIGdldCB0YWJsZVR5cGUoKSB7XG4gICAgcmV0dXJuIHRhYmxlX3R5cGVfdHlwZV9kZWZhdWx0O1xuICB9LFxuICBnZXQgdGFibGVBY2Nlc3MoKSB7XG4gICAgcmV0dXJuIHRhYmxlX2FjY2Vzc190eXBlX2RlZmF1bHQ7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL2F1dG9nZW4vcmF3X3JlZHVjZXJfZGVmX3ZfOV90eXBlLnRzXG52YXIgcmF3X3JlZHVjZXJfZGVmX3ZfOV90eXBlX2RlZmF1bHQgPSB0Lm9iamVjdChcIlJhd1JlZHVjZXJEZWZWOVwiLCB7XG4gIG5hbWU6IHQuc3RyaW5nKCksXG4gIGdldCBwYXJhbXMoKSB7XG4gICAgcmV0dXJuIHByb2R1Y3RfdHlwZV90eXBlX2RlZmF1bHQ7XG4gIH0sXG4gIGdldCBsaWZlY3ljbGUoKSB7XG4gICAgcmV0dXJuIHQub3B0aW9uKGxpZmVjeWNsZV90eXBlX2RlZmF1bHQpO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9hdXRvZ2VuL3Jhd19zY29wZWRfdHlwZV9uYW1lX3ZfOV90eXBlLnRzXG52YXIgcmF3X3Njb3BlZF90eXBlX25hbWVfdl85X3R5cGVfZGVmYXVsdCA9IHQub2JqZWN0KFwiUmF3U2NvcGVkVHlwZU5hbWVWOVwiLCB7XG4gIHNjb3BlOiB0LmFycmF5KHQuc3RyaW5nKCkpLFxuICBuYW1lOiB0LnN0cmluZygpXG59KTtcblxuLy8gc3JjL2xpYi9hdXRvZ2VuL3Jhd190eXBlX2RlZl92XzlfdHlwZS50c1xudmFyIHJhd190eXBlX2RlZl92XzlfdHlwZV9kZWZhdWx0ID0gdC5vYmplY3QoXCJSYXdUeXBlRGVmVjlcIiwge1xuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gcmF3X3Njb3BlZF90eXBlX25hbWVfdl85X3R5cGVfZGVmYXVsdDtcbiAgfSxcbiAgdHk6IHQudTMyKCksXG4gIGN1c3RvbU9yZGVyaW5nOiB0LmJvb2woKVxufSk7XG5cbi8vIHNyYy9saWIvYXV0b2dlbi9yYXdfY29sdW1uX2RlZmF1bHRfdmFsdWVfdl85X3R5cGUudHNcbnZhciByYXdfY29sdW1uX2RlZmF1bHRfdmFsdWVfdl85X3R5cGVfZGVmYXVsdCA9IHQub2JqZWN0KFwiUmF3Q29sdW1uRGVmYXVsdFZhbHVlVjlcIiwge1xuICB0YWJsZTogdC5zdHJpbmcoKSxcbiAgY29sSWQ6IHQudTE2KCksXG4gIHZhbHVlOiB0LmJ5dGVBcnJheSgpXG59KTtcblxuLy8gc3JjL2xpYi9hdXRvZ2VuL3Jhd19wcm9jZWR1cmVfZGVmX3ZfOV90eXBlLnRzXG52YXIgcmF3X3Byb2NlZHVyZV9kZWZfdl85X3R5cGVfZGVmYXVsdCA9IHQub2JqZWN0KFwiUmF3UHJvY2VkdXJlRGVmVjlcIiwge1xuICBuYW1lOiB0LnN0cmluZygpLFxuICBnZXQgcGFyYW1zKCkge1xuICAgIHJldHVybiBwcm9kdWN0X3R5cGVfdHlwZV9kZWZhdWx0O1xuICB9LFxuICBnZXQgcmV0dXJuVHlwZSgpIHtcbiAgICByZXR1cm4gYWxnZWJyYWljX3R5cGVfdHlwZV9kZWZhdWx0O1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9hdXRvZ2VuL3Jhd192aWV3X2RlZl92XzlfdHlwZS50c1xudmFyIHJhd192aWV3X2RlZl92XzlfdHlwZV9kZWZhdWx0ID0gdC5vYmplY3QoXCJSYXdWaWV3RGVmVjlcIiwge1xuICBuYW1lOiB0LnN0cmluZygpLFxuICBpbmRleDogdC51MzIoKSxcbiAgaXNQdWJsaWM6IHQuYm9vbCgpLFxuICBpc0Fub255bW91czogdC5ib29sKCksXG4gIGdldCBwYXJhbXMoKSB7XG4gICAgcmV0dXJuIHByb2R1Y3RfdHlwZV90eXBlX2RlZmF1bHQ7XG4gIH0sXG4gIGdldCByZXR1cm5UeXBlKCkge1xuICAgIHJldHVybiBhbGdlYnJhaWNfdHlwZV90eXBlX2RlZmF1bHQ7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL2F1dG9nZW4vcmF3X21pc2NfbW9kdWxlX2V4cG9ydF92XzlfdHlwZS50c1xudmFyIFJhd01pc2NNb2R1bGVFeHBvcnRWOSA9IHQuZW51bShcIlJhd01pc2NNb2R1bGVFeHBvcnRWOVwiLCB7XG4gIGdldCBDb2x1bW5EZWZhdWx0VmFsdWUoKSB7XG4gICAgcmV0dXJuIHJhd19jb2x1bW5fZGVmYXVsdF92YWx1ZV92XzlfdHlwZV9kZWZhdWx0O1xuICB9LFxuICBnZXQgUHJvY2VkdXJlKCkge1xuICAgIHJldHVybiByYXdfcHJvY2VkdXJlX2RlZl92XzlfdHlwZV9kZWZhdWx0O1xuICB9LFxuICBnZXQgVmlldygpIHtcbiAgICByZXR1cm4gcmF3X3ZpZXdfZGVmX3ZfOV90eXBlX2RlZmF1bHQ7XG4gIH1cbn0pO1xudmFyIHJhd19taXNjX21vZHVsZV9leHBvcnRfdl85X3R5cGVfZGVmYXVsdCA9IFJhd01pc2NNb2R1bGVFeHBvcnRWOTtcblxuLy8gc3JjL2xpYi9hdXRvZ2VuL3Jhd19yb3dfbGV2ZWxfc2VjdXJpdHlfZGVmX3ZfOV90eXBlLnRzXG52YXIgcmF3X3Jvd19sZXZlbF9zZWN1cml0eV9kZWZfdl85X3R5cGVfZGVmYXVsdCA9IHQub2JqZWN0KFwiUmF3Um93TGV2ZWxTZWN1cml0eURlZlY5XCIsIHtcbiAgc3FsOiB0LnN0cmluZygpXG59KTtcblxuLy8gc3JjL2xpYi9hdXRvZ2VuL3Jhd19tb2R1bGVfZGVmX3ZfOV90eXBlLnRzXG52YXIgcmF3X21vZHVsZV9kZWZfdl85X3R5cGVfZGVmYXVsdCA9IHQub2JqZWN0KFwiUmF3TW9kdWxlRGVmVjlcIiwge1xuICBnZXQgdHlwZXNwYWNlKCkge1xuICAgIHJldHVybiB0eXBlc3BhY2VfdHlwZV9kZWZhdWx0O1xuICB9LFxuICBnZXQgdGFibGVzKCkge1xuICAgIHJldHVybiB0LmFycmF5KHJhd190YWJsZV9kZWZfdl85X3R5cGVfZGVmYXVsdCk7XG4gIH0sXG4gIGdldCByZWR1Y2VycygpIHtcbiAgICByZXR1cm4gdC5hcnJheShyYXdfcmVkdWNlcl9kZWZfdl85X3R5cGVfZGVmYXVsdCk7XG4gIH0sXG4gIGdldCB0eXBlcygpIHtcbiAgICByZXR1cm4gdC5hcnJheShyYXdfdHlwZV9kZWZfdl85X3R5cGVfZGVmYXVsdCk7XG4gIH0sXG4gIGdldCBtaXNjRXhwb3J0cygpIHtcbiAgICByZXR1cm4gdC5hcnJheShyYXdfbWlzY19tb2R1bGVfZXhwb3J0X3ZfOV90eXBlX2RlZmF1bHQpO1xuICB9LFxuICBnZXQgcm93TGV2ZWxTZWN1cml0eSgpIHtcbiAgICByZXR1cm4gdC5hcnJheShyYXdfcm93X2xldmVsX3NlY3VyaXR5X2RlZl92XzlfdHlwZV9kZWZhdWx0KTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvYXV0b2dlbi9yYXdfbW9kdWxlX2RlZl90eXBlLnRzXG52YXIgUmF3TW9kdWxlRGVmID0gdC5lbnVtKFwiUmF3TW9kdWxlRGVmXCIsIHtcbiAgZ2V0IFY4QmFja0NvbXBhdCgpIHtcbiAgICByZXR1cm4gcmF3X21vZHVsZV9kZWZfdl84X3R5cGVfZGVmYXVsdDtcbiAgfSxcbiAgZ2V0IFY5KCkge1xuICAgIHJldHVybiByYXdfbW9kdWxlX2RlZl92XzlfdHlwZV9kZWZhdWx0O1xuICB9XG59KTtcbnZhciByYXdfbW9kdWxlX2RlZl90eXBlX2RlZmF1bHQgPSBSYXdNb2R1bGVEZWY7XG5cbi8vIHNyYy9zZXJ2ZXIvcmFuZ2UudHNcbnZhciBSYW5nZSA9IGNsYXNzIHtcbiAgI2Zyb207XG4gICN0bztcbiAgY29uc3RydWN0b3IoZnJvbSwgdG8pIHtcbiAgICB0aGlzLiNmcm9tID0gZnJvbSA/PyB7IHRhZzogXCJ1bmJvdW5kZWRcIiB9O1xuICAgIHRoaXMuI3RvID0gdG8gPz8geyB0YWc6IFwidW5ib3VuZGVkXCIgfTtcbiAgfVxuICBnZXQgZnJvbSgpIHtcbiAgICByZXR1cm4gdGhpcy4jZnJvbTtcbiAgfVxuICBnZXQgdG8oKSB7XG4gICAgcmV0dXJuIHRoaXMuI3RvO1xuICB9XG59O1xuXG4vLyBzcmMvc2VydmVyL2h0dHBfaW50ZXJuYWwudHNcbnZhciBpbXBvcnRfc3RhdHVzZXMgPSBfX3RvRVNNKHJlcXVpcmVfc3RhdHVzZXMoKSk7XG5cbi8vIHNyYy9saWIvYXV0b2dlbi9odHRwX2hlYWRlcl9wYWlyX3R5cGUudHNcbnZhciBodHRwX2hlYWRlcl9wYWlyX3R5cGVfZGVmYXVsdCA9IHQub2JqZWN0KFwiSHR0cEhlYWRlclBhaXJcIiwge1xuICBuYW1lOiB0LnN0cmluZygpLFxuICB2YWx1ZTogdC5ieXRlQXJyYXkoKVxufSk7XG5cbi8vIHNyYy9saWIvYXV0b2dlbi9odHRwX2hlYWRlcnNfdHlwZS50c1xudmFyIGh0dHBfaGVhZGVyc190eXBlX2RlZmF1bHQgPSB0Lm9iamVjdChcIkh0dHBIZWFkZXJzXCIsIHtcbiAgZ2V0IGVudHJpZXMoKSB7XG4gICAgcmV0dXJuIHQuYXJyYXkoaHR0cF9oZWFkZXJfcGFpcl90eXBlX2RlZmF1bHQpO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9hdXRvZ2VuL2h0dHBfbWV0aG9kX3R5cGUudHNcbnZhciBIdHRwTWV0aG9kID0gdC5lbnVtKFwiSHR0cE1ldGhvZFwiLCB7XG4gIEdldDogdC51bml0KCksXG4gIEhlYWQ6IHQudW5pdCgpLFxuICBQb3N0OiB0LnVuaXQoKSxcbiAgUHV0OiB0LnVuaXQoKSxcbiAgRGVsZXRlOiB0LnVuaXQoKSxcbiAgQ29ubmVjdDogdC51bml0KCksXG4gIE9wdGlvbnM6IHQudW5pdCgpLFxuICBUcmFjZTogdC51bml0KCksXG4gIFBhdGNoOiB0LnVuaXQoKSxcbiAgRXh0ZW5zaW9uOiB0LnN0cmluZygpXG59KTtcbnZhciBodHRwX21ldGhvZF90eXBlX2RlZmF1bHQgPSBIdHRwTWV0aG9kO1xuXG4vLyBzcmMvbGliL2F1dG9nZW4vaHR0cF92ZXJzaW9uX3R5cGUudHNcbnZhciBIdHRwVmVyc2lvbiA9IHQuZW51bShcIkh0dHBWZXJzaW9uXCIsIHtcbiAgSHR0cDA5OiB0LnVuaXQoKSxcbiAgSHR0cDEwOiB0LnVuaXQoKSxcbiAgSHR0cDExOiB0LnVuaXQoKSxcbiAgSHR0cDI6IHQudW5pdCgpLFxuICBIdHRwMzogdC51bml0KClcbn0pO1xudmFyIGh0dHBfdmVyc2lvbl90eXBlX2RlZmF1bHQgPSBIdHRwVmVyc2lvbjtcblxuLy8gc3JjL2xpYi9hdXRvZ2VuL2h0dHBfcmVxdWVzdF90eXBlLnRzXG52YXIgaHR0cF9yZXF1ZXN0X3R5cGVfZGVmYXVsdCA9IHQub2JqZWN0KFwiSHR0cFJlcXVlc3RcIiwge1xuICBnZXQgbWV0aG9kKCkge1xuICAgIHJldHVybiBodHRwX21ldGhvZF90eXBlX2RlZmF1bHQ7XG4gIH0sXG4gIGdldCBoZWFkZXJzKCkge1xuICAgIHJldHVybiBodHRwX2hlYWRlcnNfdHlwZV9kZWZhdWx0O1xuICB9LFxuICB0aW1lb3V0OiB0Lm9wdGlvbih0LnRpbWVEdXJhdGlvbigpKSxcbiAgdXJpOiB0LnN0cmluZygpLFxuICBnZXQgdmVyc2lvbigpIHtcbiAgICByZXR1cm4gaHR0cF92ZXJzaW9uX3R5cGVfZGVmYXVsdDtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvYXV0b2dlbi9odHRwX3Jlc3BvbnNlX3R5cGUudHNcbnZhciBodHRwX3Jlc3BvbnNlX3R5cGVfZGVmYXVsdCA9IHQub2JqZWN0KFwiSHR0cFJlc3BvbnNlXCIsIHtcbiAgZ2V0IGhlYWRlcnMoKSB7XG4gICAgcmV0dXJuIGh0dHBfaGVhZGVyc190eXBlX2RlZmF1bHQ7XG4gIH0sXG4gIGdldCB2ZXJzaW9uKCkge1xuICAgIHJldHVybiBodHRwX3ZlcnNpb25fdHlwZV9kZWZhdWx0O1xuICB9LFxuICBjb2RlOiB0LnUxNigpXG59KTtcblxuLy8gc3JjL3NlcnZlci9odHRwX2ludGVybmFsLnRzXG52YXIgeyBmcmVlemUgfSA9IE9iamVjdDtcbnZhciB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xudmFyIHRleHREZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKFxuICBcInV0Zi04XCJcbiAgLyogeyBmYXRhbDogdHJ1ZSB9ICovXG4pO1xudmFyIG1ha2VSZXNwb25zZSA9IFN5bWJvbChcIm1ha2VSZXNwb25zZVwiKTtcbnZhciBTeW5jUmVzcG9uc2UgPSBjbGFzcyBfU3luY1Jlc3BvbnNlIHtcbiAgI2JvZHk7XG4gICNpbm5lcjtcbiAgY29uc3RydWN0b3IoYm9keSwgaW5pdDIpIHtcbiAgICBpZiAoYm9keSA9PSBudWxsKSB7XG4gICAgICB0aGlzLiNib2R5ID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBib2R5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aGlzLiNib2R5ID0gYm9keTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jYm9keSA9IG5ldyBVaW50OEFycmF5KGJvZHkpLmJ1ZmZlcjtcbiAgICB9XG4gICAgdGhpcy4jaW5uZXIgPSB7XG4gICAgICBoZWFkZXJzOiBuZXcgSGVhZGVycyhpbml0Mj8uaGVhZGVycyksXG4gICAgICBzdGF0dXM6IGluaXQyPy5zdGF0dXMgPz8gMjAwLFxuICAgICAgc3RhdHVzVGV4dDogaW5pdDI/LnN0YXR1c1RleHQgPz8gXCJcIixcbiAgICAgIHR5cGU6IFwiZGVmYXVsdFwiLFxuICAgICAgdXJsOiBudWxsLFxuICAgICAgYWJvcnRlZDogZmFsc2VcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBbbWFrZVJlc3BvbnNlXShib2R5LCBpbm5lcikge1xuICAgIGNvbnN0IG1lID0gbmV3IF9TeW5jUmVzcG9uc2UoYm9keSk7XG4gICAgbWUuI2lubmVyID0gaW5uZXI7XG4gICAgcmV0dXJuIG1lO1xuICB9XG4gIGdldCBoZWFkZXJzKCkge1xuICAgIHJldHVybiB0aGlzLiNpbm5lci5oZWFkZXJzO1xuICB9XG4gIGdldCBzdGF0dXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2lubmVyLnN0YXR1cztcbiAgfVxuICBnZXQgc3RhdHVzVGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy4jaW5uZXIuc3RhdHVzVGV4dDtcbiAgfVxuICBnZXQgb2soKSB7XG4gICAgcmV0dXJuIDIwMCA8PSB0aGlzLiNpbm5lci5zdGF0dXMgJiYgdGhpcy4jaW5uZXIuc3RhdHVzIDw9IDI5OTtcbiAgfVxuICBnZXQgdXJsKCkge1xuICAgIHJldHVybiB0aGlzLiNpbm5lci51cmwgPz8gXCJcIjtcbiAgfVxuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jaW5uZXIudHlwZTtcbiAgfVxuICBhcnJheUJ1ZmZlcigpIHtcbiAgICByZXR1cm4gdGhpcy5ieXRlcygpLmJ1ZmZlcjtcbiAgfVxuICBieXRlcygpIHtcbiAgICBpZiAodGhpcy4jYm9keSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLiNib2R5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gdGV4dEVuY29kZXIuZW5jb2RlKHRoaXMuI2JvZHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodGhpcy4jYm9keSk7XG4gICAgfVxuICB9XG4gIGpzb24oKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UodGhpcy50ZXh0KCkpO1xuICB9XG4gIHRleHQoKSB7XG4gICAgaWYgKHRoaXMuI2JvZHkgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy4jYm9keSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIHRoaXMuI2JvZHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0ZXh0RGVjb2Rlci5kZWNvZGUodGhpcy4jYm9keSk7XG4gICAgfVxuICB9XG59O1xudmFyIHJlcXVlc3RCYXNlU2l6ZSA9IGJzYXRuQmFzZVNpemUoeyB0eXBlczogW10gfSwgaHR0cF9yZXF1ZXN0X3R5cGVfZGVmYXVsdC5hbGdlYnJhaWNUeXBlKTtcbnZhciBtZXRob2RzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICBbXCJHRVRcIiwgeyB0YWc6IFwiR2V0XCIgfV0sXG4gIFtcIkhFQURcIiwgeyB0YWc6IFwiSGVhZFwiIH1dLFxuICBbXCJQT1NUXCIsIHsgdGFnOiBcIlBvc3RcIiB9XSxcbiAgW1wiUFVUXCIsIHsgdGFnOiBcIlB1dFwiIH1dLFxuICBbXCJERUxFVEVcIiwgeyB0YWc6IFwiRGVsZXRlXCIgfV0sXG4gIFtcIkNPTk5FQ1RcIiwgeyB0YWc6IFwiQ29ubmVjdFwiIH1dLFxuICBbXCJPUFRJT05TXCIsIHsgdGFnOiBcIk9wdGlvbnNcIiB9XSxcbiAgW1wiVFJBQ0VcIiwgeyB0YWc6IFwiVHJhY2VcIiB9XSxcbiAgW1wiUEFUQ0hcIiwgeyB0YWc6IFwiUGF0Y2hcIiB9XVxuXSk7XG5mdW5jdGlvbiBmZXRjaCh1cmwsIGluaXQyID0ge30pIHtcbiAgY29uc3QgbWV0aG9kID0gbWV0aG9kcy5nZXQoaW5pdDIubWV0aG9kPy50b1VwcGVyQ2FzZSgpID8/IFwiR0VUXCIpID8/IHtcbiAgICB0YWc6IFwiRXh0ZW5zaW9uXCIsXG4gICAgdmFsdWU6IGluaXQyLm1ldGhvZFxuICB9O1xuICBjb25zdCBoZWFkZXJzID0ge1xuICAgIC8vIGFueXMgYmVjYXVzZSB0aGUgdHlwaW5ncyBhcmUgd29ua3kgLSBzZWUgY29tbWVudCBpbiBTeW5jUmVzcG9uc2UuY29uc3RydWN0b3JcbiAgICBlbnRyaWVzOiBoZWFkZXJzVG9MaXN0KG5ldyBIZWFkZXJzKGluaXQyLmhlYWRlcnMpKS5mbGF0TWFwKChbaywgdl0pID0+IEFycmF5LmlzQXJyYXkodikgPyB2Lm1hcCgodjIpID0+IFtrLCB2Ml0pIDogW1trLCB2XV0pLm1hcCgoW25hbWUsIHZhbHVlXSkgPT4gKHsgbmFtZSwgdmFsdWU6IHRleHRFbmNvZGVyLmVuY29kZSh2YWx1ZSkgfSkpXG4gIH07XG4gIGNvbnN0IHVyaSA9IFwiXCIgKyB1cmw7XG4gIGNvbnN0IHJlcXVlc3QgPSBmcmVlemUoe1xuICAgIG1ldGhvZCxcbiAgICBoZWFkZXJzLFxuICAgIHRpbWVvdXQ6IGluaXQyLnRpbWVvdXQsXG4gICAgdXJpLFxuICAgIHZlcnNpb246IHsgdGFnOiBcIkh0dHAxMVwiIH1cbiAgfSk7XG4gIGNvbnN0IHJlcXVlc3RCdWYgPSBuZXcgQmluYXJ5V3JpdGVyKHJlcXVlc3RCYXNlU2l6ZSk7XG4gIGh0dHBfcmVxdWVzdF90eXBlX2RlZmF1bHQuc2VyaWFsaXplKHJlcXVlc3RCdWYsIHJlcXVlc3QpO1xuICBjb25zdCBib2R5ID0gaW5pdDIuYm9keSA9PSBudWxsID8gbmV3IFVpbnQ4QXJyYXkoKSA6IHR5cGVvZiBpbml0Mi5ib2R5ID09PSBcInN0cmluZ1wiID8gaW5pdDIuYm9keSA6IG5ldyBVaW50OEFycmF5KGluaXQyLmJvZHkpO1xuICBjb25zdCBbcmVzcG9uc2VCdWYsIHJlc3BvbnNlQm9keV0gPSBzeXMucHJvY2VkdXJlX2h0dHBfcmVxdWVzdChcbiAgICByZXF1ZXN0QnVmLmdldEJ1ZmZlcigpLFxuICAgIGJvZHlcbiAgKTtcbiAgY29uc3QgcmVzcG9uc2UgPSBodHRwX3Jlc3BvbnNlX3R5cGVfZGVmYXVsdC5kZXNlcmlhbGl6ZShuZXcgQmluYXJ5UmVhZGVyKHJlc3BvbnNlQnVmKSk7XG4gIHJldHVybiBTeW5jUmVzcG9uc2VbbWFrZVJlc3BvbnNlXShyZXNwb25zZUJvZHksIHtcbiAgICB0eXBlOiBcImJhc2ljXCIsXG4gICAgdXJsOiB1cmksXG4gICAgc3RhdHVzOiByZXNwb25zZS5jb2RlLFxuICAgIHN0YXR1c1RleHQ6ICgwLCBpbXBvcnRfc3RhdHVzZXMuZGVmYXVsdCkocmVzcG9uc2UuY29kZSksXG4gICAgaGVhZGVyczogbmV3IEhlYWRlcnMoKSxcbiAgICBhYm9ydGVkOiBmYWxzZVxuICB9KTtcbn1cbmZyZWV6ZShmZXRjaCk7XG52YXIgaHR0cENsaWVudCA9IGZyZWV6ZSh7IGZldGNoIH0pO1xuXG4vLyBzcmMvc2VydmVyL3Byb2NlZHVyZXMudHNcbnZhciB7IGZyZWV6ZTogZnJlZXplMiB9ID0gT2JqZWN0O1xuZnVuY3Rpb24gY2FsbFByb2NlZHVyZShpZCwgc2VuZGVyLCBjb25uZWN0aW9uSWQsIHRpbWVzdGFtcCwgYXJnc0J1Zikge1xuICBjb25zdCB7IGZuLCBwYXJhbXNUeXBlLCByZXR1cm5UeXBlLCByZXR1cm5UeXBlQmFzZVNpemUgfSA9IFBST0NFRFVSRVNbaWRdO1xuICBjb25zdCBhcmdzID0gUHJvZHVjdFR5cGUuZGVzZXJpYWxpemVWYWx1ZShcbiAgICBuZXcgQmluYXJ5UmVhZGVyKGFyZ3NCdWYpLFxuICAgIHBhcmFtc1R5cGUsXG4gICAgTU9EVUxFX0RFRi50eXBlc3BhY2VcbiAgKTtcbiAgY29uc3QgY3R4ID0ge1xuICAgIHNlbmRlcixcbiAgICB0aW1lc3RhbXAsXG4gICAgY29ubmVjdGlvbklkLFxuICAgIGh0dHA6IGh0dHBDbGllbnQsXG4gICAgLy8gKipOb3RlOioqIG11c3QgYmUgMC4uPXUzMjo6TUFYXG4gICAgY291bnRlcl91dWlkOiB7IHZhbHVlOiBOdW1iZXIoMCkgfSxcbiAgICBnZXQgaWRlbnRpdHkoKSB7XG4gICAgICByZXR1cm4gbmV3IElkZW50aXR5KHN5cy5pZGVudGl0eSgpLl9faWRlbnRpdHlfXyk7XG4gICAgfSxcbiAgICB3aXRoVHgoYm9keSkge1xuICAgICAgY29uc3QgcnVuID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB0aW1lc3RhbXAyID0gc3lzLnByb2NlZHVyZV9zdGFydF9tdXRfdHgoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBjdHgyID0gbmV3IFJlZHVjZXJDdHhJbXBsKFxuICAgICAgICAgICAgc2VuZGVyLFxuICAgICAgICAgICAgbmV3IFRpbWVzdGFtcCh0aW1lc3RhbXAyKSxcbiAgICAgICAgICAgIGNvbm5lY3Rpb25JZFxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIGJvZHkoY3R4Mik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBzeXMucHJvY2VkdXJlX2Fib3J0X211dF90eCgpO1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBsZXQgcmVzID0gcnVuKCk7XG4gICAgICB0cnkge1xuICAgICAgICBzeXMucHJvY2VkdXJlX2NvbW1pdF9tdXRfdHgoKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgfVxuICAgICAgY29uc29sZS53YXJuKFwiY29tbWl0dGluZyBhbm9ueW1vdXMgdHJhbnNhY3Rpb24gZmFpbGVkXCIpO1xuICAgICAgcmVzID0gcnVuKCk7XG4gICAgICB0cnkge1xuICAgICAgICBzeXMucHJvY2VkdXJlX2NvbW1pdF9tdXRfdHgoKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJhbnNhY3Rpb24gcmV0cnkgZmFpbGVkIGFnYWluXCIsIHsgY2F1c2U6IGUgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgcmFuZG9tIHtAbGluayBVdWlkfSBgdjRgIHVzaW5nIHRoZSB7QGxpbmsgY3J5cHRvfSBSTkcuXG4gICAgICpcbiAgICAgKiBXQVJOOiBVbnRpbCB3ZSB1c2UgYSBzcGFjZXRpbWUgUk5HIHRoaXMgbWFrZSBjYWxscyBub24tZGV0ZXJtaW5pc3RpYy5cbiAgICAgKi9cbiAgICBuZXdVdWlkVjQoKSB7XG4gICAgICBjb25zdCBieXRlcyA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoMTYpKTtcbiAgICAgIHJldHVybiBVdWlkLmZyb21SYW5kb21CeXRlc1Y0KGJ5dGVzKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBzb3J0YWJsZSB7QGxpbmsgVXVpZH0gYHY3YCB1c2luZyB0aGUge0BsaW5rIGNyeXB0b30gUk5HLCBjb3VudGVyLFxuICAgICAqIGFuZCB0aGUgdGltZXN0YW1wLlxuICAgICAqXG4gICAgICogV0FSTjogVW50aWwgd2UgdXNlIGEgc3BhY2V0aW1lIFJORyB0aGlzIG1ha2UgY2FsbHMgbm9uLWRldGVybWluaXN0aWMuXG4gICAgICovXG4gICAgbmV3VXVpZFY3KCkge1xuICAgICAgY29uc3QgYnl0ZXMgPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KDEwKSk7XG4gICAgICByZXR1cm4gVXVpZC5mcm9tQ291bnRlclY3KHRoaXMuY291bnRlcl91dWlkLCB0aGlzLnRpbWVzdGFtcCwgYnl0ZXMpO1xuICAgIH1cbiAgfTtcbiAgZnJlZXplMihjdHgpO1xuICBjb25zdCByZXQgPSBjYWxsVXNlckZ1bmN0aW9uKGZuLCBjdHgsIGFyZ3MpO1xuICBjb25zdCByZXRCdWYgPSBuZXcgQmluYXJ5V3JpdGVyKHJldHVyblR5cGVCYXNlU2l6ZSk7XG4gIEFsZ2VicmFpY1R5cGUuc2VyaWFsaXplVmFsdWUocmV0QnVmLCByZXR1cm5UeXBlLCByZXQsIE1PRFVMRV9ERUYudHlwZXNwYWNlKTtcbiAgcmV0dXJuIHJldEJ1Zi5nZXRCdWZmZXIoKTtcbn1cblxuLy8gc3JjL2xpYi9hdXRvZ2VuL3ZpZXdfcmVzdWx0X2hlYWRlcl90eXBlLnRzXG52YXIgVmlld1Jlc3VsdEhlYWRlciA9IHQuZW51bShcIlZpZXdSZXN1bHRIZWFkZXJcIiwge1xuICBSb3dEYXRhOiB0LnVuaXQoKSxcbiAgUmF3U3FsOiB0LnN0cmluZygpXG59KTtcbnZhciB2aWV3X3Jlc3VsdF9oZWFkZXJfdHlwZV9kZWZhdWx0ID0gVmlld1Jlc3VsdEhlYWRlcjtcblxuLy8gc3JjL3NlcnZlci9ydW50aW1lLnRzXG52YXIgeyBmcmVlemU6IGZyZWV6ZTMgfSA9IE9iamVjdDtcbnZhciBzeXMgPSBmcmVlemUzKHdyYXBTeXNjYWxscyhfc3lzY2FsbHMxXzAsIF9zeXNjYWxsczFfMikpO1xuZnVuY3Rpb24gcGFyc2VKc29uT2JqZWN0KGpzb24pIHtcbiAgbGV0IHZhbHVlO1xuICB0cnkge1xuICAgIHZhbHVlID0gSlNPTi5wYXJzZShqc29uKTtcbiAgfSBjYXRjaCB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBKU09OOiBmYWlsZWQgdG8gcGFyc2Ugc3RyaW5nXCIpO1xuICB9XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBhIEpTT04gb2JqZWN0IGF0IHRoZSB0b3AgbGV2ZWxcIik7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxudmFyIEp3dENsYWltc0ltcGwgPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IEp3dENsYWltcyBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHJhd1BheWxvYWQgVGhlIEpXVCBwYXlsb2FkIGFzIGEgcmF3IEpTT04gc3RyaW5nLlxuICAgKiBAcGFyYW0gaWRlbnRpdHkgVGhlIGlkZW50aXR5IGZvciB0aGlzIEpXVC4gV2UgYXJlIG9ubHkgdGFraW5nIHRoaXMgYmVjYXVzZSB3ZSBkb24ndCBoYXZlIGEgYmxha2UzIGltcGxlbWVudGF0aW9uICh3aGljaCB3ZSBuZWVkIHRvIGNvbXB1dGUgaXQpLlxuICAgKi9cbiAgY29uc3RydWN0b3IocmF3UGF5bG9hZCwgaWRlbnRpdHkpIHtcbiAgICB0aGlzLnJhd1BheWxvYWQgPSByYXdQYXlsb2FkO1xuICAgIHRoaXMuZnVsbFBheWxvYWQgPSBwYXJzZUpzb25PYmplY3QocmF3UGF5bG9hZCk7XG4gICAgdGhpcy5faWRlbnRpdHkgPSBpZGVudGl0eTtcbiAgfVxuICBmdWxsUGF5bG9hZDtcbiAgX2lkZW50aXR5O1xuICBnZXQgaWRlbnRpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lkZW50aXR5O1xuICB9XG4gIGdldCBzdWJqZWN0KCkge1xuICAgIHJldHVybiB0aGlzLmZ1bGxQYXlsb2FkW1wic3ViXCJdO1xuICB9XG4gIGdldCBpc3N1ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZnVsbFBheWxvYWRbXCJpc3NcIl07XG4gIH1cbiAgZ2V0IGF1ZGllbmNlKCkge1xuICAgIGNvbnN0IGF1ZCA9IHRoaXMuZnVsbFBheWxvYWRbXCJhdWRcIl07XG4gICAgaWYgKGF1ZCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiB0eXBlb2YgYXVkID09PSBcInN0cmluZ1wiID8gW2F1ZF0gOiBhdWQ7XG4gIH1cbn07XG52YXIgQXV0aEN0eEltcGwgPSBjbGFzcyBfQXV0aEN0eEltcGwge1xuICBpc0ludGVybmFsO1xuICAvLyBTb3VyY2Ugb2YgdGhlIEpXVCBwYXlsb2FkIHN0cmluZywgaWYgdGhlcmUgaXMgb25lLlxuICBfand0U291cmNlO1xuICAvLyBXaGV0aGVyIHdlIGhhdmUgaW5pdGlhbGl6ZWQgdGhlIEpXVCBjbGFpbXMuXG4gIF9pbml0aWFsaXplZEpXVCA9IGZhbHNlO1xuICBfand0Q2xhaW1zO1xuICBfc2VuZGVySWRlbnRpdHk7XG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICB0aGlzLmlzSW50ZXJuYWwgPSBvcHRzLmlzSW50ZXJuYWw7XG4gICAgdGhpcy5fand0U291cmNlID0gb3B0cy5qd3RTb3VyY2U7XG4gICAgdGhpcy5fc2VuZGVySWRlbnRpdHkgPSBvcHRzLnNlbmRlcklkZW50aXR5O1xuICB9XG4gIF9pbml0aWFsaXplSldUKCkge1xuICAgIGlmICh0aGlzLl9pbml0aWFsaXplZEpXVCkgcmV0dXJuO1xuICAgIHRoaXMuX2luaXRpYWxpemVkSldUID0gdHJ1ZTtcbiAgICBjb25zdCB0b2tlbiA9IHRoaXMuX2p3dFNvdXJjZSgpO1xuICAgIGlmICghdG9rZW4pIHtcbiAgICAgIHRoaXMuX2p3dENsYWltcyA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2p3dENsYWltcyA9IG5ldyBKd3RDbGFpbXNJbXBsKHRva2VuLCB0aGlzLl9zZW5kZXJJZGVudGl0eSk7XG4gICAgfVxuICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gIH1cbiAgLyoqIExhemlseSBjb21wdXRlIHdoZXRoZXIgYSBKV1QgZXhpc3RzIGFuZCBpcyBwYXJzZWFibGUuICovXG4gIGdldCBoYXNKV1QoKSB7XG4gICAgdGhpcy5faW5pdGlhbGl6ZUpXVCgpO1xuICAgIHJldHVybiB0aGlzLl9qd3RDbGFpbXMgIT09IG51bGw7XG4gIH1cbiAgLyoqIExhemlseSBwYXJzZSB0aGUgSnd0Q2xhaW1zIG9ubHkgd2hlbiBhY2Nlc3NlZC4gKi9cbiAgZ2V0IGp3dCgpIHtcbiAgICB0aGlzLl9pbml0aWFsaXplSldUKCk7XG4gICAgcmV0dXJuIHRoaXMuX2p3dENsYWltcztcbiAgfVxuICAvKiogQ3JlYXRlIGEgY29udGV4dCByZXByZXNlbnRpbmcgaW50ZXJuYWwgKG5vbi11c2VyKSByZXF1ZXN0cy4gKi9cbiAgc3RhdGljIGludGVybmFsKCkge1xuICAgIHJldHVybiBuZXcgX0F1dGhDdHhJbXBsKHtcbiAgICAgIGlzSW50ZXJuYWw6IHRydWUsXG4gICAgICBqd3RTb3VyY2U6ICgpID0+IG51bGwsXG4gICAgICBzZW5kZXJJZGVudGl0eTogSWRlbnRpdHkuemVybygpXG4gICAgfSk7XG4gIH1cbiAgLyoqIElmIHRoZXJlIGlzIGEgY29ubmVjdGlvbiBpZCwgbG9vayB1cCB0aGUgSldUIHBheWxvYWQgZnJvbSB0aGUgc3lzdGVtIHRhYmxlcy4gKi9cbiAgc3RhdGljIGZyb21TeXN0ZW1UYWJsZXMoY29ubmVjdGlvbklkLCBzZW5kZXIpIHtcbiAgICBpZiAoY29ubmVjdGlvbklkID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbmV3IF9BdXRoQ3R4SW1wbCh7XG4gICAgICAgIGlzSW50ZXJuYWw6IGZhbHNlLFxuICAgICAgICBqd3RTb3VyY2U6ICgpID0+IG51bGwsXG4gICAgICAgIHNlbmRlcklkZW50aXR5OiBzZW5kZXJcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IF9BdXRoQ3R4SW1wbCh7XG4gICAgICBpc0ludGVybmFsOiBmYWxzZSxcbiAgICAgIGp3dFNvdXJjZTogKCkgPT4ge1xuICAgICAgICBjb25zdCBwYXlsb2FkQnVmID0gc3lzLmdldF9qd3RfcGF5bG9hZChjb25uZWN0aW9uSWQuX19jb25uZWN0aW9uX2lkX18pO1xuICAgICAgICBpZiAocGF5bG9hZEJ1Zi5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuICAgICAgICBjb25zdCBwYXlsb2FkU3RyID0gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKHBheWxvYWRCdWYpO1xuICAgICAgICByZXR1cm4gcGF5bG9hZFN0cjtcbiAgICAgIH0sXG4gICAgICBzZW5kZXJJZGVudGl0eTogc2VuZGVyXG4gICAgfSk7XG4gIH1cbn07XG52YXIgUmVkdWNlckN0eEltcGwgPSBjbGFzcyBSZWR1Y2VyQ3R4IHtcbiAgI2lkZW50aXR5O1xuICAjc2VuZGVyQXV0aDtcbiAgI3V1aWRDb3VudGVyO1xuICBzZW5kZXI7XG4gIHRpbWVzdGFtcDtcbiAgY29ubmVjdGlvbklkO1xuICBkYjtcbiAgY29uc3RydWN0b3Ioc2VuZGVyLCB0aW1lc3RhbXAsIGNvbm5lY3Rpb25JZCkge1xuICAgIE9iamVjdC5zZWFsKHRoaXMpO1xuICAgIHRoaXMuc2VuZGVyID0gc2VuZGVyO1xuICAgIHRoaXMudGltZXN0YW1wID0gdGltZXN0YW1wO1xuICAgIHRoaXMuY29ubmVjdGlvbklkID0gY29ubmVjdGlvbklkO1xuICAgIHRoaXMuZGIgPSBnZXREYlZpZXcoKTtcbiAgfVxuICBnZXQgaWRlbnRpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2lkZW50aXR5ID8/PSBuZXcgSWRlbnRpdHkoc3lzLmlkZW50aXR5KCkuX19pZGVudGl0eV9fKTtcbiAgfVxuICBnZXQgc2VuZGVyQXV0aCgpIHtcbiAgICByZXR1cm4gdGhpcy4jc2VuZGVyQXV0aCA/Pz0gQXV0aEN0eEltcGwuZnJvbVN5c3RlbVRhYmxlcyhcbiAgICAgIHRoaXMuY29ubmVjdGlvbklkLFxuICAgICAgdGhpcy5zZW5kZXJcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgcmFuZG9tIHtAbGluayBVdWlkfSBgdjRgIHVzaW5nIHRoZSB7QGxpbmsgY3J5cHRvfSBSTkcuXG4gICAqXG4gICAqIFdBUk46IFVudGlsIHdlIHVzZSBhIHNwYWNldGltZSBSTkcgdGhpcyBtYWtlIGNhbGxzIG5vbi1kZXRlcm1pbmlzdGljLlxuICAgKi9cbiAgbmV3VXVpZFY0KCkge1xuICAgIGNvbnN0IGJ5dGVzID0gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheSgxNikpO1xuICAgIHJldHVybiBVdWlkLmZyb21SYW5kb21CeXRlc1Y0KGJ5dGVzKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHNvcnRhYmxlIHtAbGluayBVdWlkfSBgdjdgIHVzaW5nIHRoZSB7QGxpbmsgY3J5cHRvfSBSTkcsIGNvdW50ZXIsXG4gICAqIGFuZCB0aGUgdGltZXN0YW1wLlxuICAgKlxuICAgKiBXQVJOOiBVbnRpbCB3ZSB1c2UgYSBzcGFjZXRpbWUgUk5HIHRoaXMgbWFrZSBjYWxscyBub24tZGV0ZXJtaW5pc3RpYy5cbiAgICovXG4gIG5ld1V1aWRWNygpIHtcbiAgICBjb25zdCBieXRlcyA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoNCkpO1xuICAgIGNvbnN0IGNvdW50ZXIgPSB0aGlzLiN1dWlkQ291bnRlciA/Pz0geyB2YWx1ZTogMCB9O1xuICAgIHJldHVybiBVdWlkLmZyb21Db3VudGVyVjcoY291bnRlciwgdGhpcy50aW1lc3RhbXAsIGJ5dGVzKTtcbiAgfVxufTtcbnZhciBjYWxsVXNlckZ1bmN0aW9uID0gZnVuY3Rpb24gX19zcGFjZXRpbWVkYl9lbmRfc2hvcnRfYmFja3RyYWNlKGZuLCAuLi5hcmdzKSB7XG4gIHJldHVybiBmbiguLi5hcmdzKTtcbn07XG52YXIgaG9va3MgPSB7XG4gIF9fZGVzY3JpYmVfbW9kdWxlX18oKSB7XG4gICAgY29uc3Qgd3JpdGVyID0gbmV3IEJpbmFyeVdyaXRlcigxMjgpO1xuICAgIEFsZ2VicmFpY1R5cGUuc2VyaWFsaXplVmFsdWUoXG4gICAgICB3cml0ZXIsXG4gICAgICByYXdfbW9kdWxlX2RlZl90eXBlX2RlZmF1bHQuYWxnZWJyYWljVHlwZSxcbiAgICAgIHJhd19tb2R1bGVfZGVmX3R5cGVfZGVmYXVsdC5WOShNT0RVTEVfREVGKVxuICAgICk7XG4gICAgcmV0dXJuIHdyaXRlci5nZXRCdWZmZXIoKTtcbiAgfSxcbiAgX19jYWxsX3JlZHVjZXJfXyhyZWR1Y2VySWQsIHNlbmRlciwgY29ubklkLCB0aW1lc3RhbXAsIGFyZ3NCdWYpIHtcbiAgICBjb25zdCBhcmdzVHlwZSA9IEFsZ2VicmFpY1R5cGUuUHJvZHVjdChcbiAgICAgIE1PRFVMRV9ERUYucmVkdWNlcnNbcmVkdWNlcklkXS5wYXJhbXNcbiAgICApO1xuICAgIGNvbnN0IGFyZ3MgPSBBbGdlYnJhaWNUeXBlLmRlc2VyaWFsaXplVmFsdWUoXG4gICAgICBuZXcgQmluYXJ5UmVhZGVyKGFyZ3NCdWYpLFxuICAgICAgYXJnc1R5cGUsXG4gICAgICBNT0RVTEVfREVGLnR5cGVzcGFjZVxuICAgICk7XG4gICAgY29uc3Qgc2VuZGVySWRlbnRpdHkgPSBuZXcgSWRlbnRpdHkoc2VuZGVyKTtcbiAgICBjb25zdCBjdHggPSBuZXcgUmVkdWNlckN0eEltcGwoXG4gICAgICBzZW5kZXJJZGVudGl0eSxcbiAgICAgIG5ldyBUaW1lc3RhbXAodGltZXN0YW1wKSxcbiAgICAgIENvbm5lY3Rpb25JZC5udWxsSWZaZXJvKG5ldyBDb25uZWN0aW9uSWQoY29ubklkKSlcbiAgICApO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gY2FsbFVzZXJGdW5jdGlvbihSRURVQ0VSU1tyZWR1Y2VySWRdLCBjdHgsIGFyZ3MpID8/IHsgdGFnOiBcIm9rXCIgfTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIFNlbmRlckVycm9yKSB7XG4gICAgICAgIHJldHVybiB7IHRhZzogXCJlcnJcIiwgdmFsdWU6IGUubWVzc2FnZSB9O1xuICAgICAgfVxuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cbn07XG52YXIgaG9va3NfdjFfMSA9IHtcbiAgX19jYWxsX3ZpZXdfXyhpZCwgc2VuZGVyLCBhcmdzQnVmKSB7XG4gICAgY29uc3QgeyBmbiwgcGFyYW1zLCByZXR1cm5UeXBlLCByZXR1cm5UeXBlQmFzZVNpemUgfSA9IFZJRVdTW2lkXTtcbiAgICBjb25zdCBjdHggPSBmcmVlemUzKHtcbiAgICAgIHNlbmRlcjogbmV3IElkZW50aXR5KHNlbmRlciksXG4gICAgICAvLyB0aGlzIGlzIHRoZSBub24tcmVhZG9ubHkgRGJWaWV3LCBidXQgdGhlIHR5cGluZyBmb3IgdGhlIHVzZXIgd2lsbCBiZVxuICAgICAgLy8gdGhlIHJlYWRvbmx5IG9uZSwgYW5kIGlmIHRoZXkgZG8gY2FsbCBtdXRhdGluZyBmdW5jdGlvbnMgaXQgd2lsbCBmYWlsXG4gICAgICAvLyBhdCBydW50aW1lXG4gICAgICBkYjogZ2V0RGJWaWV3KCksXG4gICAgICBmcm9tOiBtYWtlUXVlcnlCdWlsZGVyKGdldFJlZ2lzdGVyZWRTY2hlbWEoKSlcbiAgICB9KTtcbiAgICBjb25zdCBhcmdzID0gUHJvZHVjdFR5cGUuZGVzZXJpYWxpemVWYWx1ZShcbiAgICAgIG5ldyBCaW5hcnlSZWFkZXIoYXJnc0J1ZiksXG4gICAgICBwYXJhbXMsXG4gICAgICBNT0RVTEVfREVGLnR5cGVzcGFjZVxuICAgICk7XG4gICAgY29uc3QgcmV0ID0gY2FsbFVzZXJGdW5jdGlvbihmbiwgY3R4LCBhcmdzKTtcbiAgICBjb25zdCByZXRCdWYgPSBuZXcgQmluYXJ5V3JpdGVyKHJldHVyblR5cGVCYXNlU2l6ZSk7XG4gICAgaWYgKGlzUm93VHlwZWRRdWVyeShyZXQpKSB7XG4gICAgICBjb25zdCBxdWVyeSA9IHRvU3FsKHJldCk7XG4gICAgICBjb25zdCB2ID0gdmlld19yZXN1bHRfaGVhZGVyX3R5cGVfZGVmYXVsdC5SYXdTcWwocXVlcnkpO1xuICAgICAgQWxnZWJyYWljVHlwZS5zZXJpYWxpemVWYWx1ZShcbiAgICAgICAgcmV0QnVmLFxuICAgICAgICB2aWV3X3Jlc3VsdF9oZWFkZXJfdHlwZV9kZWZhdWx0LmFsZ2VicmFpY1R5cGUsXG4gICAgICAgIHYsXG4gICAgICAgIE1PRFVMRV9ERUYudHlwZXNwYWNlXG4gICAgICApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YTogcmV0QnVmLmdldEJ1ZmZlcigpXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBBbGdlYnJhaWNUeXBlLnNlcmlhbGl6ZVZhbHVlKFxuICAgICAgICByZXRCdWYsXG4gICAgICAgIHZpZXdfcmVzdWx0X2hlYWRlcl90eXBlX2RlZmF1bHQuYWxnZWJyYWljVHlwZSxcbiAgICAgICAgdmlld19yZXN1bHRfaGVhZGVyX3R5cGVfZGVmYXVsdC5Sb3dEYXRhLFxuICAgICAgICBNT0RVTEVfREVGLnR5cGVzcGFjZVxuICAgICAgKTtcbiAgICAgIEFsZ2VicmFpY1R5cGUuc2VyaWFsaXplVmFsdWUoXG4gICAgICAgIHJldEJ1ZixcbiAgICAgICAgcmV0dXJuVHlwZSxcbiAgICAgICAgcmV0LFxuICAgICAgICBNT0RVTEVfREVGLnR5cGVzcGFjZVxuICAgICAgKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IHJldEJ1Zi5nZXRCdWZmZXIoKVxuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gIF9fY2FsbF92aWV3X2Fub25fXyhpZCwgYXJnc0J1Zikge1xuICAgIGNvbnN0IHsgZm4sIHBhcmFtcywgcmV0dXJuVHlwZSwgcmV0dXJuVHlwZUJhc2VTaXplIH0gPSBBTk9OX1ZJRVdTW2lkXTtcbiAgICBjb25zdCBjdHggPSBmcmVlemUzKHtcbiAgICAgIC8vIHRoaXMgaXMgdGhlIG5vbi1yZWFkb25seSBEYlZpZXcsIGJ1dCB0aGUgdHlwaW5nIGZvciB0aGUgdXNlciB3aWxsIGJlXG4gICAgICAvLyB0aGUgcmVhZG9ubHkgb25lLCBhbmQgaWYgdGhleSBkbyBjYWxsIG11dGF0aW5nIGZ1bmN0aW9ucyBpdCB3aWxsIGZhaWxcbiAgICAgIC8vIGF0IHJ1bnRpbWVcbiAgICAgIGRiOiBnZXREYlZpZXcoKSxcbiAgICAgIGZyb206IG1ha2VRdWVyeUJ1aWxkZXIoZ2V0UmVnaXN0ZXJlZFNjaGVtYSgpKVxuICAgIH0pO1xuICAgIGNvbnN0IGFyZ3MgPSBQcm9kdWN0VHlwZS5kZXNlcmlhbGl6ZVZhbHVlKFxuICAgICAgbmV3IEJpbmFyeVJlYWRlcihhcmdzQnVmKSxcbiAgICAgIHBhcmFtcyxcbiAgICAgIE1PRFVMRV9ERUYudHlwZXNwYWNlXG4gICAgKTtcbiAgICBjb25zdCByZXQgPSBjYWxsVXNlckZ1bmN0aW9uKGZuLCBjdHgsIGFyZ3MpO1xuICAgIGNvbnN0IHJldEJ1ZiA9IG5ldyBCaW5hcnlXcml0ZXIocmV0dXJuVHlwZUJhc2VTaXplKTtcbiAgICBpZiAoaXNSb3dUeXBlZFF1ZXJ5KHJldCkpIHtcbiAgICAgIGNvbnN0IHF1ZXJ5ID0gdG9TcWwocmV0KTtcbiAgICAgIGNvbnN0IHYgPSB2aWV3X3Jlc3VsdF9oZWFkZXJfdHlwZV9kZWZhdWx0LlJhd1NxbChxdWVyeSk7XG4gICAgICBBbGdlYnJhaWNUeXBlLnNlcmlhbGl6ZVZhbHVlKFxuICAgICAgICByZXRCdWYsXG4gICAgICAgIHZpZXdfcmVzdWx0X2hlYWRlcl90eXBlX2RlZmF1bHQuYWxnZWJyYWljVHlwZSxcbiAgICAgICAgdixcbiAgICAgICAgTU9EVUxFX0RFRi50eXBlc3BhY2VcbiAgICAgICk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiByZXRCdWYuZ2V0QnVmZmVyKClcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIEFsZ2VicmFpY1R5cGUuc2VyaWFsaXplVmFsdWUoXG4gICAgICAgIHJldEJ1ZixcbiAgICAgICAgdmlld19yZXN1bHRfaGVhZGVyX3R5cGVfZGVmYXVsdC5hbGdlYnJhaWNUeXBlLFxuICAgICAgICB2aWV3X3Jlc3VsdF9oZWFkZXJfdHlwZV9kZWZhdWx0LlJvd0RhdGEsXG4gICAgICAgIE1PRFVMRV9ERUYudHlwZXNwYWNlXG4gICAgICApO1xuICAgICAgQWxnZWJyYWljVHlwZS5zZXJpYWxpemVWYWx1ZShcbiAgICAgICAgcmV0QnVmLFxuICAgICAgICByZXR1cm5UeXBlLFxuICAgICAgICByZXQsXG4gICAgICAgIE1PRFVMRV9ERUYudHlwZXNwYWNlXG4gICAgICApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YTogcmV0QnVmLmdldEJ1ZmZlcigpXG4gICAgICB9O1xuICAgIH1cbiAgfVxufTtcbnZhciBob29rc192MV8yID0ge1xuICBfX2NhbGxfcHJvY2VkdXJlX18oaWQsIHNlbmRlciwgY29ubmVjdGlvbl9pZCwgdGltZXN0YW1wLCBhcmdzKSB7XG4gICAgcmV0dXJuIGNhbGxQcm9jZWR1cmUoXG4gICAgICBpZCxcbiAgICAgIG5ldyBJZGVudGl0eShzZW5kZXIpLFxuICAgICAgQ29ubmVjdGlvbklkLm51bGxJZlplcm8obmV3IENvbm5lY3Rpb25JZChjb25uZWN0aW9uX2lkKSksXG4gICAgICBuZXcgVGltZXN0YW1wKHRpbWVzdGFtcCksXG4gICAgICBhcmdzXG4gICAgKTtcbiAgfVxufTtcbnZhciBEQl9WSUVXID0gbnVsbDtcbmZ1bmN0aW9uIGdldERiVmlldygpIHtcbiAgREJfVklFVyA/Pz0gbWFrZURiVmlldyhNT0RVTEVfREVGKTtcbiAgcmV0dXJuIERCX1ZJRVc7XG59XG5mdW5jdGlvbiBtYWtlRGJWaWV3KG1vZHVsZURlZikge1xuICByZXR1cm4gZnJlZXplMyhcbiAgICBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICBtb2R1bGVEZWYudGFibGVzLm1hcCgodGFibGUyKSA9PiBbXG4gICAgICAgIHRvQ2FtZWxDYXNlKHRhYmxlMi5uYW1lKSxcbiAgICAgICAgbWFrZVRhYmxlVmlldyhtb2R1bGVEZWYudHlwZXNwYWNlLCB0YWJsZTIpXG4gICAgICBdKVxuICAgIClcbiAgKTtcbn1cbmZ1bmN0aW9uIG1ha2VUYWJsZVZpZXcodHlwZXNwYWNlLCB0YWJsZTIpIHtcbiAgY29uc3QgdGFibGVfaWQgPSBzeXMudGFibGVfaWRfZnJvbV9uYW1lKHRhYmxlMi5uYW1lKTtcbiAgY29uc3Qgcm93VHlwZSA9IHR5cGVzcGFjZS50eXBlc1t0YWJsZTIucHJvZHVjdFR5cGVSZWZdO1xuICBpZiAocm93VHlwZS50YWcgIT09IFwiUHJvZHVjdFwiKSB7XG4gICAgdGhyb3cgXCJpbXBvc3NpYmxlXCI7XG4gIH1cbiAgY29uc3QgYmFzZVNpemUgPSBic2F0bkJhc2VTaXplKHR5cGVzcGFjZSwgcm93VHlwZSk7XG4gIGNvbnN0IHNlcXVlbmNlcyA9IHRhYmxlMi5zZXF1ZW5jZXMubWFwKChzZXEpID0+IHtcbiAgICBjb25zdCBjb2wgPSByb3dUeXBlLnZhbHVlLmVsZW1lbnRzW3NlcS5jb2x1bW5dO1xuICAgIGNvbnN0IGNvbFR5cGUgPSBjb2wuYWxnZWJyYWljVHlwZTtcbiAgICBsZXQgc2VxdWVuY2VUcmlnZ2VyO1xuICAgIHN3aXRjaCAoY29sVHlwZS50YWcpIHtcbiAgICAgIGNhc2UgXCJVOFwiOlxuICAgICAgY2FzZSBcIkk4XCI6XG4gICAgICBjYXNlIFwiVTE2XCI6XG4gICAgICBjYXNlIFwiSTE2XCI6XG4gICAgICBjYXNlIFwiVTMyXCI6XG4gICAgICBjYXNlIFwiSTMyXCI6XG4gICAgICAgIHNlcXVlbmNlVHJpZ2dlciA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIlU2NFwiOlxuICAgICAgY2FzZSBcIkk2NFwiOlxuICAgICAgY2FzZSBcIlUxMjhcIjpcbiAgICAgIGNhc2UgXCJJMTI4XCI6XG4gICAgICBjYXNlIFwiVTI1NlwiOlxuICAgICAgY2FzZSBcIkkyNTZcIjpcbiAgICAgICAgc2VxdWVuY2VUcmlnZ2VyID0gMG47XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgc2VxdWVuY2UgdHlwZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbE5hbWU6IGNvbC5uYW1lLFxuICAgICAgc2VxdWVuY2VUcmlnZ2VyLFxuICAgICAgcmVhZDogKHJlYWRlcikgPT4gQWxnZWJyYWljVHlwZS5kZXNlcmlhbGl6ZVZhbHVlKHJlYWRlciwgY29sVHlwZSwgdHlwZXNwYWNlKVxuICAgIH07XG4gIH0pO1xuICBjb25zdCBoYXNBdXRvSW5jcmVtZW50ID0gc2VxdWVuY2VzLmxlbmd0aCA+IDA7XG4gIGNvbnN0IGl0ZXIgPSAoKSA9PiB0YWJsZUl0ZXJhdG9yKHN5cy5kYXRhc3RvcmVfdGFibGVfc2Nhbl9ic2F0bih0YWJsZV9pZCksIHJvd1R5cGUpO1xuICBjb25zdCBpbnRlZ3JhdGVHZW5lcmF0ZWRDb2x1bW5zID0gaGFzQXV0b0luY3JlbWVudCA/IChyb3csIHJldF9idWYpID0+IHtcbiAgICBjb25zdCByZWFkZXIgPSBuZXcgQmluYXJ5UmVhZGVyKHJldF9idWYpO1xuICAgIGZvciAoY29uc3QgeyBjb2xOYW1lLCByZWFkLCBzZXF1ZW5jZVRyaWdnZXIgfSBvZiBzZXF1ZW5jZXMpIHtcbiAgICAgIGlmIChyb3dbY29sTmFtZV0gPT09IHNlcXVlbmNlVHJpZ2dlcikge1xuICAgICAgICByb3dbY29sTmFtZV0gPSByZWFkKHJlYWRlcik7XG4gICAgICB9XG4gICAgfVxuICB9IDogbnVsbDtcbiAgY29uc3QgdGFibGVNZXRob2RzID0ge1xuICAgIGNvdW50OiAoKSA9PiBzeXMuZGF0YXN0b3JlX3RhYmxlX3Jvd19jb3VudCh0YWJsZV9pZCksXG4gICAgaXRlcixcbiAgICBbU3ltYm9sLml0ZXJhdG9yXTogKCkgPT4gaXRlcigpLFxuICAgIGluc2VydDogKHJvdykgPT4ge1xuICAgICAgY29uc3Qgd3JpdGVyID0gbmV3IEJpbmFyeVdyaXRlcihiYXNlU2l6ZSk7XG4gICAgICBBbGdlYnJhaWNUeXBlLnNlcmlhbGl6ZVZhbHVlKHdyaXRlciwgcm93VHlwZSwgcm93LCB0eXBlc3BhY2UpO1xuICAgICAgY29uc3QgcmV0X2J1ZiA9IHN5cy5kYXRhc3RvcmVfaW5zZXJ0X2JzYXRuKHRhYmxlX2lkLCB3cml0ZXIuZ2V0QnVmZmVyKCkpO1xuICAgICAgY29uc3QgcmV0ID0geyAuLi5yb3cgfTtcbiAgICAgIGludGVncmF0ZUdlbmVyYXRlZENvbHVtbnM/LihyZXQsIHJldF9idWYpO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9LFxuICAgIGRlbGV0ZTogKHJvdykgPT4ge1xuICAgICAgY29uc3Qgd3JpdGVyID0gbmV3IEJpbmFyeVdyaXRlcig0ICsgYmFzZVNpemUpO1xuICAgICAgd3JpdGVyLndyaXRlVTMyKDEpO1xuICAgICAgQWxnZWJyYWljVHlwZS5zZXJpYWxpemVWYWx1ZSh3cml0ZXIsIHJvd1R5cGUsIHJvdywgdHlwZXNwYWNlKTtcbiAgICAgIGNvbnN0IGNvdW50ID0gc3lzLmRhdGFzdG9yZV9kZWxldGVfYWxsX2J5X2VxX2JzYXRuKFxuICAgICAgICB0YWJsZV9pZCxcbiAgICAgICAgd3JpdGVyLmdldEJ1ZmZlcigpXG4gICAgICApO1xuICAgICAgcmV0dXJuIGNvdW50ID4gMDtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHRhYmxlVmlldyA9IE9iamVjdC5hc3NpZ24oXG4gICAgLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgdGFibGVNZXRob2RzXG4gICk7XG4gIGZvciAoY29uc3QgaW5kZXhEZWYgb2YgdGFibGUyLmluZGV4ZXMpIHtcbiAgICBjb25zdCBpbmRleF9pZCA9IHN5cy5pbmRleF9pZF9mcm9tX25hbWUoaW5kZXhEZWYubmFtZSk7XG4gICAgbGV0IGNvbHVtbl9pZHM7XG4gICAgc3dpdGNoIChpbmRleERlZi5hbGdvcml0aG0udGFnKSB7XG4gICAgICBjYXNlIFwiQlRyZWVcIjpcbiAgICAgICAgY29sdW1uX2lkcyA9IGluZGV4RGVmLmFsZ29yaXRobS52YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiSGFzaFwiOlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbXBvc3NpYmxlXCIpO1xuICAgICAgY2FzZSBcIkRpcmVjdFwiOlxuICAgICAgICBjb2x1bW5faWRzID0gW2luZGV4RGVmLmFsZ29yaXRobS52YWx1ZV07XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCBudW1Db2x1bW5zID0gY29sdW1uX2lkcy5sZW5ndGg7XG4gICAgY29uc3QgY29sdW1uU2V0ID0gbmV3IFNldChjb2x1bW5faWRzKTtcbiAgICBjb25zdCBpc1VuaXF1ZSA9IHRhYmxlMi5jb25zdHJhaW50cy5maWx0ZXIoKHgpID0+IHguZGF0YS50YWcgPT09IFwiVW5pcXVlXCIpLnNvbWUoKHgpID0+IGNvbHVtblNldC5pc1N1YnNldE9mKG5ldyBTZXQoeC5kYXRhLnZhbHVlLmNvbHVtbnMpKSk7XG4gICAgY29uc3QgaW5kZXhUeXBlID0gQWxnZWJyYWljVHlwZS5Qcm9kdWN0KHtcbiAgICAgIGVsZW1lbnRzOiBjb2x1bW5faWRzLm1hcCgoaWQpID0+IHJvd1R5cGUudmFsdWUuZWxlbWVudHNbaWRdKVxuICAgIH0pO1xuICAgIGNvbnN0IGJhc2VTaXplMiA9IGJzYXRuQmFzZVNpemUodHlwZXNwYWNlLCBpbmRleFR5cGUpO1xuICAgIGNvbnN0IHNlcmlhbGl6ZVByZWZpeCA9ICh3cml0ZXIsIHByZWZpeCwgcHJlZml4X2VsZW1zKSA9PiB7XG4gICAgICBpZiAocHJlZml4X2VsZW1zID4gbnVtQ29sdW1ucyAtIDEpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJ0b28gbWFueSBlbGVtZW50cyBpbiBwcmVmaXhcIik7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZWZpeF9lbGVtczsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGVsZW1UeXBlID0gaW5kZXhUeXBlLnZhbHVlLmVsZW1lbnRzW2ldLmFsZ2VicmFpY1R5cGU7XG4gICAgICAgIEFsZ2VicmFpY1R5cGUuc2VyaWFsaXplVmFsdWUod3JpdGVyLCBlbGVtVHlwZSwgcHJlZml4W2ldLCB0eXBlc3BhY2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9O1xuICAgIGxldCBpbmRleDtcbiAgICBpZiAoaXNVbmlxdWUpIHtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZUJvdW5kID0gKGNvbFZhbCkgPT4ge1xuICAgICAgICBpZiAoY29sVmFsLmxlbmd0aCAhPT0gbnVtQ29sdW1ucylcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwid3JvbmcgbnVtYmVyIG9mIGVsZW1lbnRzXCIpO1xuICAgICAgICBjb25zdCB3cml0ZXIgPSBuZXcgQmluYXJ5V3JpdGVyKGJhc2VTaXplMiArIDEpO1xuICAgICAgICBjb25zdCBwcmVmaXhfZWxlbXMgPSBudW1Db2x1bW5zIC0gMTtcbiAgICAgICAgc2VyaWFsaXplUHJlZml4KHdyaXRlciwgY29sVmFsLCBwcmVmaXhfZWxlbXMpO1xuICAgICAgICBjb25zdCByc3RhcnRPZmZzZXQgPSB3cml0ZXIub2Zmc2V0O1xuICAgICAgICB3cml0ZXIud3JpdGVVOCgwKTtcbiAgICAgICAgQWxnZWJyYWljVHlwZS5zZXJpYWxpemVWYWx1ZShcbiAgICAgICAgICB3cml0ZXIsXG4gICAgICAgICAgaW5kZXhUeXBlLnZhbHVlLmVsZW1lbnRzW251bUNvbHVtbnMgLSAxXS5hbGdlYnJhaWNUeXBlLFxuICAgICAgICAgIGNvbFZhbFtudW1Db2x1bW5zIC0gMV0sXG4gICAgICAgICAgdHlwZXNwYWNlXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHdyaXRlci5nZXRCdWZmZXIoKTtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gYnVmZmVyLnNsaWNlKDAsIHJzdGFydE9mZnNldCk7XG4gICAgICAgIGNvbnN0IHJzdGFydCA9IGJ1ZmZlci5zbGljZShyc3RhcnRPZmZzZXQpO1xuICAgICAgICByZXR1cm4gW3ByZWZpeCwgcHJlZml4X2VsZW1zLCByc3RhcnQsIHJzdGFydF07XG4gICAgICB9O1xuICAgICAgaW5kZXggPSB7XG4gICAgICAgIGZpbmQ6IChjb2xWYWwpID0+IHtcbiAgICAgICAgICBpZiAobnVtQ29sdW1ucyA9PT0gMSkgY29sVmFsID0gW2NvbFZhbF07XG4gICAgICAgICAgY29uc3QgYXJncyA9IHNlcmlhbGl6ZUJvdW5kKGNvbFZhbCk7XG4gICAgICAgICAgY29uc3QgaXRlcjIgPSB0YWJsZUl0ZXJhdG9yKFxuICAgICAgICAgICAgc3lzLmRhdGFzdG9yZV9pbmRleF9zY2FuX3JhbmdlX2JzYXRuKGluZGV4X2lkLCAuLi5hcmdzKSxcbiAgICAgICAgICAgIHJvd1R5cGVcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGl0ZXIyLm5leHQoKTtcbiAgICAgICAgICBpZiAoZG9uZSkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgaWYgKCFpdGVyMi5uZXh0KCkuZG9uZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgXCJgZGF0YXN0b3JlX2luZGV4X3NjYW5fcmFuZ2VfYnNhdG5gIG9uIHVuaXF1ZSBmaWVsZCBjYW5ub3QgcmV0dXJuID4xIHJvd3NcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGRlbGV0ZTogKGNvbFZhbCkgPT4ge1xuICAgICAgICAgIGlmIChudW1Db2x1bW5zID09PSAxKSBjb2xWYWwgPSBbY29sVmFsXTtcbiAgICAgICAgICBjb25zdCBhcmdzID0gc2VyaWFsaXplQm91bmQoY29sVmFsKTtcbiAgICAgICAgICBjb25zdCBudW0gPSBzeXMuZGF0YXN0b3JlX2RlbGV0ZV9ieV9pbmRleF9zY2FuX3JhbmdlX2JzYXRuKFxuICAgICAgICAgICAgaW5kZXhfaWQsXG4gICAgICAgICAgICAuLi5hcmdzXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gbnVtID4gMDtcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlOiAocm93KSA9PiB7XG4gICAgICAgICAgY29uc3Qgd3JpdGVyID0gbmV3IEJpbmFyeVdyaXRlcihiYXNlU2l6ZTIpO1xuICAgICAgICAgIEFsZ2VicmFpY1R5cGUuc2VyaWFsaXplVmFsdWUod3JpdGVyLCByb3dUeXBlLCByb3csIHR5cGVzcGFjZSk7XG4gICAgICAgICAgY29uc3QgcmV0X2J1ZiA9IHN5cy5kYXRhc3RvcmVfdXBkYXRlX2JzYXRuKFxuICAgICAgICAgICAgdGFibGVfaWQsXG4gICAgICAgICAgICBpbmRleF9pZCxcbiAgICAgICAgICAgIHdyaXRlci5nZXRCdWZmZXIoKVxuICAgICAgICAgICk7XG4gICAgICAgICAgaW50ZWdyYXRlR2VuZXJhdGVkQ29sdW1ucz8uKHJvdywgcmV0X2J1Zik7XG4gICAgICAgICAgcmV0dXJuIHJvdztcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc2VyaWFsaXplUmFuZ2UgPSAocmFuZ2UpID0+IHtcbiAgICAgICAgaWYgKHJhbmdlLmxlbmd0aCA+IG51bUNvbHVtbnMpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJ0b28gbWFueSBlbGVtZW50c1wiKTtcbiAgICAgICAgY29uc3Qgd3JpdGVyID0gbmV3IEJpbmFyeVdyaXRlcihiYXNlU2l6ZTIgKyAxKTtcbiAgICAgICAgY29uc3QgcHJlZml4X2VsZW1zID0gcmFuZ2UubGVuZ3RoIC0gMTtcbiAgICAgICAgc2VyaWFsaXplUHJlZml4KHdyaXRlciwgcmFuZ2UsIHByZWZpeF9lbGVtcyk7XG4gICAgICAgIGNvbnN0IHJzdGFydE9mZnNldCA9IHdyaXRlci5vZmZzZXQ7XG4gICAgICAgIGNvbnN0IHRlcm0gPSByYW5nZVtyYW5nZS5sZW5ndGggLSAxXTtcbiAgICAgICAgY29uc3QgdGVybVR5cGUgPSBpbmRleFR5cGUudmFsdWUuZWxlbWVudHNbcmFuZ2UubGVuZ3RoIC0gMV0uYWxnZWJyYWljVHlwZTtcbiAgICAgICAgbGV0IHJzdGFydCwgcmVuZDtcbiAgICAgICAgaWYgKHRlcm0gaW5zdGFuY2VvZiBSYW5nZSkge1xuICAgICAgICAgIGNvbnN0IHdyaXRlQm91bmQgPSAoYm91bmQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRhZ3MgPSB7IGluY2x1ZGVkOiAwLCBleGNsdWRlZDogMSwgdW5ib3VuZGVkOiAyIH07XG4gICAgICAgICAgICB3cml0ZXIud3JpdGVVOCh0YWdzW2JvdW5kLnRhZ10pO1xuICAgICAgICAgICAgaWYgKGJvdW5kLnRhZyAhPT0gXCJ1bmJvdW5kZWRcIilcbiAgICAgICAgICAgICAgQWxnZWJyYWljVHlwZS5zZXJpYWxpemVWYWx1ZShcbiAgICAgICAgICAgICAgICB3cml0ZXIsXG4gICAgICAgICAgICAgICAgdGVybVR5cGUsXG4gICAgICAgICAgICAgICAgYm91bmQudmFsdWUsXG4gICAgICAgICAgICAgICAgdHlwZXNwYWNlXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB3cml0ZUJvdW5kKHRlcm0uZnJvbSk7XG4gICAgICAgICAgY29uc3QgcmVuZE9mZnNldCA9IHdyaXRlci5vZmZzZXQ7XG4gICAgICAgICAgd3JpdGVCb3VuZCh0ZXJtLnRvKTtcbiAgICAgICAgICByc3RhcnQgPSB3cml0ZXIuZ2V0QnVmZmVyKCkuc2xpY2UocnN0YXJ0T2Zmc2V0LCByZW5kT2Zmc2V0KTtcbiAgICAgICAgICByZW5kID0gd3JpdGVyLmdldEJ1ZmZlcigpLnNsaWNlKHJlbmRPZmZzZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdyaXRlci53cml0ZVU4KDApO1xuICAgICAgICAgIEFsZ2VicmFpY1R5cGUuc2VyaWFsaXplVmFsdWUod3JpdGVyLCB0ZXJtVHlwZSwgdGVybSwgdHlwZXNwYWNlKTtcbiAgICAgICAgICByc3RhcnQgPSByZW5kID0gd3JpdGVyLmdldEJ1ZmZlcigpLnNsaWNlKHJzdGFydE9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnVmZmVyID0gd3JpdGVyLmdldEJ1ZmZlcigpO1xuICAgICAgICBjb25zdCBwcmVmaXggPSBidWZmZXIuc2xpY2UoMCwgcnN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIFtwcmVmaXgsIHByZWZpeF9lbGVtcywgcnN0YXJ0LCByZW5kXTtcbiAgICAgIH07XG4gICAgICBpbmRleCA9IHtcbiAgICAgICAgZmlsdGVyOiAocmFuZ2UpID0+IHtcbiAgICAgICAgICBpZiAobnVtQ29sdW1ucyA9PT0gMSkgcmFuZ2UgPSBbcmFuZ2VdO1xuICAgICAgICAgIGNvbnN0IGFyZ3MgPSBzZXJpYWxpemVSYW5nZShyYW5nZSk7XG4gICAgICAgICAgcmV0dXJuIHRhYmxlSXRlcmF0b3IoXG4gICAgICAgICAgICBzeXMuZGF0YXN0b3JlX2luZGV4X3NjYW5fcmFuZ2VfYnNhdG4oaW5kZXhfaWQsIC4uLmFyZ3MpLFxuICAgICAgICAgICAgcm93VHlwZVxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIGRlbGV0ZTogKHJhbmdlKSA9PiB7XG4gICAgICAgICAgaWYgKG51bUNvbHVtbnMgPT09IDEpIHJhbmdlID0gW3JhbmdlXTtcbiAgICAgICAgICBjb25zdCBhcmdzID0gc2VyaWFsaXplUmFuZ2UocmFuZ2UpO1xuICAgICAgICAgIHJldHVybiBzeXMuZGF0YXN0b3JlX2RlbGV0ZV9ieV9pbmRleF9zY2FuX3JhbmdlX2JzYXRuKFxuICAgICAgICAgICAgaW5kZXhfaWQsXG4gICAgICAgICAgICAuLi5hcmdzXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5oYXNPd24odGFibGVWaWV3LCBpbmRleERlZi5hY2Nlc3Nvck5hbWUpKSB7XG4gICAgICBmcmVlemUzKE9iamVjdC5hc3NpZ24odGFibGVWaWV3W2luZGV4RGVmLmFjY2Vzc29yTmFtZV0sIGluZGV4KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhYmxlVmlld1tpbmRleERlZi5hY2Nlc3Nvck5hbWVdID0gZnJlZXplMyhpbmRleCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBmcmVlemUzKHRhYmxlVmlldyk7XG59XG5mdW5jdGlvbiBoYXNPd24obywgaykge1xuICByZXR1cm4gT2JqZWN0Lmhhc093bihvLCBrKTtcbn1cbmZ1bmN0aW9uKiB0YWJsZUl0ZXJhdG9yKGlkLCB0eSkge1xuICB2YXIgX3N0YWNrID0gW107XG4gIHRyeSB7XG4gICAgY29uc3QgaXRlciA9IF9fdXNpbmcoX3N0YWNrLCBuZXcgSXRlcmF0b3JIYW5kbGUoaWQpKTtcbiAgICBjb25zdCB7IHR5cGVzcGFjZSB9ID0gTU9EVUxFX0RFRjtcbiAgICBsZXQgYnVmO1xuICAgIHdoaWxlICgoYnVmID0gYWR2YW5jZUl0ZXIoaXRlcikpICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBCaW5hcnlSZWFkZXIoYnVmKTtcbiAgICAgIHdoaWxlIChyZWFkZXIucmVtYWluaW5nID4gMCkge1xuICAgICAgICB5aWVsZCBBbGdlYnJhaWNUeXBlLmRlc2VyaWFsaXplVmFsdWUocmVhZGVyLCB0eSwgdHlwZXNwYWNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICB2YXIgX2Vycm9yID0gXywgX2hhc0Vycm9yID0gdHJ1ZTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfX2NhbGxEaXNwb3NlKF9zdGFjaywgX2Vycm9yLCBfaGFzRXJyb3IpO1xuICB9XG59XG5mdW5jdGlvbiBhZHZhbmNlSXRlcihpdGVyKSB7XG4gIGxldCBidWZfbWF4X2xlbiA9IDY1NTM2O1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gaXRlci5hZHZhbmNlKGJ1Zl9tYXhfbGVuKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZSAmJiB0eXBlb2YgZSA9PT0gXCJvYmplY3RcIiAmJiBoYXNPd24oZSwgXCJfX2J1ZmZlcl90b29fc21hbGxfX1wiKSkge1xuICAgICAgICBidWZfbWF4X2xlbiA9IGUuX19idWZmZXJfdG9vX3NtYWxsX187XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cbn1cbnZhciBJdGVyYXRvckhhbmRsZSA9IGNsYXNzIF9JdGVyYXRvckhhbmRsZSB7XG4gICNpZDtcbiAgc3RhdGljICNmaW5hbGl6YXRpb25SZWdpc3RyeSA9IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShcbiAgICBzeXMucm93X2l0ZXJfYnNhdG5fY2xvc2VcbiAgKTtcbiAgY29uc3RydWN0b3IoaWQpIHtcbiAgICB0aGlzLiNpZCA9IGlkO1xuICAgIF9JdGVyYXRvckhhbmRsZS4jZmluYWxpemF0aW9uUmVnaXN0cnkucmVnaXN0ZXIodGhpcywgaWQsIHRoaXMpO1xuICB9XG4gIC8qKiBVbnJlZ2lzdGVyIHRoaXMgb2JqZWN0IHdpdGggdGhlIGZpbmFsaXphdGlvbiByZWdpc3RyeSBhbmQgcmV0dXJuIHRoZSBpZCAqL1xuICAjZGV0YWNoKCkge1xuICAgIGNvbnN0IGlkID0gdGhpcy4jaWQ7XG4gICAgdGhpcy4jaWQgPSAtMTtcbiAgICBfSXRlcmF0b3JIYW5kbGUuI2ZpbmFsaXphdGlvblJlZ2lzdHJ5LnVucmVnaXN0ZXIodGhpcyk7XG4gICAgcmV0dXJuIGlkO1xuICB9XG4gIC8qKiBDYWxsIGByb3dfaXRlcl9ic2F0bl9hZHZhbmNlYCwgcmV0dXJuaW5nIG51bGwgaWYgdGhpcyBpdGVyYXRvciB3YXMgYWxyZWFkeSBleGhhdXN0ZWQuICovXG4gIGFkdmFuY2UoYnVmX21heF9sZW4pIHtcbiAgICBpZiAodGhpcy4jaWQgPT09IC0xKSByZXR1cm4gbnVsbDtcbiAgICBjb25zdCB7IDA6IGRvbmUsIDE6IGJ1ZiB9ID0gc3lzLnJvd19pdGVyX2JzYXRuX2FkdmFuY2UoXG4gICAgICB0aGlzLiNpZCxcbiAgICAgIGJ1Zl9tYXhfbGVuXG4gICAgKTtcbiAgICBpZiAoZG9uZSkgdGhpcy4jZGV0YWNoKCk7XG4gICAgcmV0dXJuIGJ1ZjtcbiAgfVxuICBbU3ltYm9sLmRpc3Bvc2VdKCkge1xuICAgIGlmICh0aGlzLiNpZCA+PSAwKSB7XG4gICAgICBjb25zdCBpZCA9IHRoaXMuI2RldGFjaCgpO1xuICAgICAgc3lzLnJvd19pdGVyX2JzYXRuX2Nsb3NlKGlkKTtcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiB3cmFwU3lzY2FsbHMoLi4ubW9kdWxlcykge1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIG1vZHVsZXMuZmxhdE1hcChPYmplY3QuZW50cmllcykubWFwKChbaywgdl0pID0+IFtrLCB3cmFwU3lzY2FsbCh2KV0pXG4gICk7XG59XG5mdW5jdGlvbiB3cmFwU3lzY2FsbChmdW5jKSB7XG4gIGNvbnN0IG5hbWUgPSBmdW5jLm5hbWU7XG4gIHJldHVybiB7XG4gICAgW25hbWVdKC4uLmFyZ3MpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBmdW5jKC4uLmFyZ3MpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZSAhPT0gbnVsbCAmJiB0eXBlb2YgZSA9PT0gXCJvYmplY3RcIiAmJiBoYXNPd24oZSwgXCJfX2NvZGVfZXJyb3JfX1wiKSAmJiB0eXBlb2YgZS5fX2NvZGVfZXJyb3JfXyA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGhhc093bihlLCBcIl9fZXJyb3JfbWVzc2FnZV9fXCIpICYmIHR5cGVvZiBlLl9fZXJyb3JfbWVzc2FnZV9fID09PSBcInN0cmluZ1wiID8gZS5fX2Vycm9yX21lc3NhZ2VfXyA6IHZvaWQgMDtcbiAgICAgICAgICB0aHJvdyBuZXcgU3BhY2V0aW1lSG9zdEVycm9yKGUuX19jb2RlX2Vycm9yX18sIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuICB9W25hbWVdO1xufVxuZnVuY3Rpb24gZm10TG9nKC4uLmRhdGEpIHtcbiAgcmV0dXJuIGRhdGEuam9pbihcIiBcIik7XG59XG52YXIgY29uc29sZV9sZXZlbF9lcnJvciA9IDA7XG52YXIgY29uc29sZV9sZXZlbF93YXJuID0gMTtcbnZhciBjb25zb2xlX2xldmVsX2luZm8gPSAyO1xudmFyIGNvbnNvbGVfbGV2ZWxfZGVidWcgPSAzO1xudmFyIGNvbnNvbGVfbGV2ZWxfdHJhY2UgPSA0O1xudmFyIHRpbWVyTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbnZhciBjb25zb2xlMiA9IHtcbiAgLy8gQHRzLWV4cGVjdC1lcnJvciB3ZSB3YW50IGEgYmxhbmsgcHJvdG90eXBlLCBidXQgdHlwZXNjcmlwdCBjb21wbGFpbnNcbiAgX19wcm90b19fOiB7fSxcbiAgW1N5bWJvbC50b1N0cmluZ1RhZ106IFwiY29uc29sZVwiLFxuICBhc3NlcnQ6IChjb25kaXRpb24gPSBmYWxzZSwgLi4uZGF0YSkgPT4ge1xuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICBzeXMuY29uc29sZV9sb2coY29uc29sZV9sZXZlbF9lcnJvciwgZm10TG9nKC4uLmRhdGEpKTtcbiAgICB9XG4gIH0sXG4gIGNsZWFyOiAoKSA9PiB7XG4gIH0sXG4gIGRlYnVnOiAoLi4uZGF0YSkgPT4ge1xuICAgIHN5cy5jb25zb2xlX2xvZyhjb25zb2xlX2xldmVsX2RlYnVnLCBmbXRMb2coLi4uZGF0YSkpO1xuICB9LFxuICBlcnJvcjogKC4uLmRhdGEpID0+IHtcbiAgICBzeXMuY29uc29sZV9sb2coY29uc29sZV9sZXZlbF9lcnJvciwgZm10TG9nKC4uLmRhdGEpKTtcbiAgfSxcbiAgaW5mbzogKC4uLmRhdGEpID0+IHtcbiAgICBzeXMuY29uc29sZV9sb2coY29uc29sZV9sZXZlbF9pbmZvLCBmbXRMb2coLi4uZGF0YSkpO1xuICB9LFxuICBsb2c6ICguLi5kYXRhKSA9PiB7XG4gICAgc3lzLmNvbnNvbGVfbG9nKGNvbnNvbGVfbGV2ZWxfaW5mbywgZm10TG9nKC4uLmRhdGEpKTtcbiAgfSxcbiAgdGFibGU6ICh0YWJ1bGFyRGF0YSwgX3Byb3BlcnRpZXMpID0+IHtcbiAgICBzeXMuY29uc29sZV9sb2coY29uc29sZV9sZXZlbF9pbmZvLCBmbXRMb2codGFidWxhckRhdGEpKTtcbiAgfSxcbiAgdHJhY2U6ICguLi5kYXRhKSA9PiB7XG4gICAgc3lzLmNvbnNvbGVfbG9nKGNvbnNvbGVfbGV2ZWxfdHJhY2UsIGZtdExvZyguLi5kYXRhKSk7XG4gIH0sXG4gIHdhcm46ICguLi5kYXRhKSA9PiB7XG4gICAgc3lzLmNvbnNvbGVfbG9nKGNvbnNvbGVfbGV2ZWxfd2FybiwgZm10TG9nKC4uLmRhdGEpKTtcbiAgfSxcbiAgZGlyOiAoX2l0ZW0sIF9vcHRpb25zKSA9PiB7XG4gIH0sXG4gIGRpcnhtbDogKC4uLl9kYXRhKSA9PiB7XG4gIH0sXG4gIC8vIENvdW50aW5nXG4gIGNvdW50OiAoX2xhYmVsID0gXCJkZWZhdWx0XCIpID0+IHtcbiAgfSxcbiAgY291bnRSZXNldDogKF9sYWJlbCA9IFwiZGVmYXVsdFwiKSA9PiB7XG4gIH0sXG4gIC8vIEdyb3VwaW5nXG4gIGdyb3VwOiAoLi4uX2RhdGEpID0+IHtcbiAgfSxcbiAgZ3JvdXBDb2xsYXBzZWQ6ICguLi5fZGF0YSkgPT4ge1xuICB9LFxuICBncm91cEVuZDogKCkgPT4ge1xuICB9LFxuICAvLyBUaW1pbmdcbiAgdGltZTogKGxhYmVsID0gXCJkZWZhdWx0XCIpID0+IHtcbiAgICBpZiAodGltZXJNYXAuaGFzKGxhYmVsKSkge1xuICAgICAgc3lzLmNvbnNvbGVfbG9nKGNvbnNvbGVfbGV2ZWxfd2FybiwgYFRpbWVyICcke2xhYmVsfScgYWxyZWFkeSBleGlzdHMuYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRpbWVyTWFwLnNldChsYWJlbCwgc3lzLmNvbnNvbGVfdGltZXJfc3RhcnQobGFiZWwpKTtcbiAgfSxcbiAgdGltZUxvZzogKGxhYmVsID0gXCJkZWZhdWx0XCIsIC4uLmRhdGEpID0+IHtcbiAgICBzeXMuY29uc29sZV9sb2coY29uc29sZV9sZXZlbF9pbmZvLCBmbXRMb2cobGFiZWwsIC4uLmRhdGEpKTtcbiAgfSxcbiAgdGltZUVuZDogKGxhYmVsID0gXCJkZWZhdWx0XCIpID0+IHtcbiAgICBjb25zdCBzcGFuSWQgPSB0aW1lck1hcC5nZXQobGFiZWwpO1xuICAgIGlmIChzcGFuSWQgPT09IHZvaWQgMCkge1xuICAgICAgc3lzLmNvbnNvbGVfbG9nKGNvbnNvbGVfbGV2ZWxfd2FybiwgYFRpbWVyICcke2xhYmVsfScgZG9lcyBub3QgZXhpc3QuYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN5cy5jb25zb2xlX3RpbWVyX2VuZChzcGFuSWQpO1xuICAgIHRpbWVyTWFwLmRlbGV0ZShsYWJlbCk7XG4gIH0sXG4gIC8vIEFkZGl0aW9uYWwgY29uc29sZSBtZXRob2RzIHRvIHNhdGlzZnkgdGhlIENvbnNvbGUgaW50ZXJmYWNlXG4gIHRpbWVTdGFtcDogKCkgPT4ge1xuICB9LFxuICBwcm9maWxlOiAoKSA9PiB7XG4gIH0sXG4gIHByb2ZpbGVFbmQ6ICgpID0+IHtcbiAgfVxufTtcbmNvbnNvbGUyLkNvbnNvbGUgPSBjb25zb2xlMjtcbmdsb2JhbFRoaXMuY29uc29sZSA9IGNvbnNvbGUyO1xuXG4vLyBzcmMvc2VydmVyL3JlZ2lzdGVyX2hvb2tzLnRzXG5yZWdpc3Rlcl9ob29rcyhob29rcyk7XG5yZWdpc3Rlcl9ob29rcyQxKGhvb2tzX3YxXzEpO1xucmVnaXN0ZXJfaG9va3MkMihob29rc192MV8yKTtcbi8qISBCdW5kbGVkIGxpY2Vuc2UgaW5mb3JtYXRpb246XG5cbnN0YXR1c2VzL2luZGV4LmpzOlxuICAoKiFcbiAgICogc3RhdHVzZXNcbiAgICogQ29weXJpZ2h0KGMpIDIwMTQgSm9uYXRoYW4gT25nXG4gICAqIENvcHlyaWdodChjKSAyMDE2IERvdWdsYXMgQ2hyaXN0b3BoZXIgV2lsc29uXG4gICAqIE1JVCBMaWNlbnNlZFxuICAgKilcbiovXG5cbmV4cG9ydCB7IEFycmF5QnVpbGRlciwgQXJyYXlDb2x1bW5CdWlsZGVyLCBCb29sQnVpbGRlciwgQm9vbENvbHVtbkJ1aWxkZXIsIEJ5dGVBcnJheUJ1aWxkZXIsIEJ5dGVBcnJheUNvbHVtbkJ1aWxkZXIsIENvbHVtbkJ1aWxkZXIsIENvbm5lY3Rpb25JZEJ1aWxkZXIsIENvbm5lY3Rpb25JZENvbHVtbkJ1aWxkZXIsIEYzMkJ1aWxkZXIsIEYzMkNvbHVtbkJ1aWxkZXIsIEY2NEJ1aWxkZXIsIEY2NENvbHVtbkJ1aWxkZXIsIEkxMjhCdWlsZGVyLCBJMTI4Q29sdW1uQnVpbGRlciwgSTE2QnVpbGRlciwgSTE2Q29sdW1uQnVpbGRlciwgSTI1NkJ1aWxkZXIsIEkyNTZDb2x1bW5CdWlsZGVyLCBJMzJCdWlsZGVyLCBJMzJDb2x1bW5CdWlsZGVyLCBJNjRCdWlsZGVyLCBJNjRDb2x1bW5CdWlsZGVyLCBJOEJ1aWxkZXIsIEk4Q29sdW1uQnVpbGRlciwgSWRlbnRpdHlCdWlsZGVyLCBJZGVudGl0eUNvbHVtbkJ1aWxkZXIsIE9wdGlvbkJ1aWxkZXIsIE9wdGlvbkNvbHVtbkJ1aWxkZXIsIFByb2R1Y3RCdWlsZGVyLCBQcm9kdWN0Q29sdW1uQnVpbGRlciwgUmVmQnVpbGRlciwgUmVzdWx0QnVpbGRlciwgUmVzdWx0Q29sdW1uQnVpbGRlciwgUm93QnVpbGRlciwgU2NoZWR1bGVBdEJ1aWxkZXIsIFNjaGVkdWxlQXRDb2x1bW5CdWlsZGVyLCBTZW5kZXJFcnJvciwgU2ltcGxlU3VtQnVpbGRlciwgU2ltcGxlU3VtQ29sdW1uQnVpbGRlciwgU3BhY2V0aW1lSG9zdEVycm9yLCBTdHJpbmdCdWlsZGVyLCBTdHJpbmdDb2x1bW5CdWlsZGVyLCBTdW1CdWlsZGVyLCBTdW1Db2x1bW5CdWlsZGVyLCBUaW1lRHVyYXRpb25CdWlsZGVyLCBUaW1lRHVyYXRpb25Db2x1bW5CdWlsZGVyLCBUaW1lc3RhbXBCdWlsZGVyLCBUaW1lc3RhbXBDb2x1bW5CdWlsZGVyLCBUeXBlQnVpbGRlciwgVTEyOEJ1aWxkZXIsIFUxMjhDb2x1bW5CdWlsZGVyLCBVMTZCdWlsZGVyLCBVMTZDb2x1bW5CdWlsZGVyLCBVMjU2QnVpbGRlciwgVTI1NkNvbHVtbkJ1aWxkZXIsIFUzMkJ1aWxkZXIsIFUzMkNvbHVtbkJ1aWxkZXIsIFU2NEJ1aWxkZXIsIFU2NENvbHVtbkJ1aWxkZXIsIFU4QnVpbGRlciwgVThDb2x1bW5CdWlsZGVyLCBVdWlkQnVpbGRlciwgVXVpZENvbHVtbkJ1aWxkZXIsIGFuZCwgZXJyb3JzLCBub3QsIG9yLCByZWR1Y2Vycywgc2NoZW1hLCB0LCB0YWJsZSwgdG9DYW1lbENhc2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVnZXhwQ29kZSA9IGV4cG9ydHMuZ2V0RXNtRXhwb3J0TmFtZSA9IGV4cG9ydHMuZ2V0UHJvcGVydHkgPSBleHBvcnRzLnNhZmVTdHJpbmdpZnkgPSBleHBvcnRzLnN0cmluZ2lmeSA9IGV4cG9ydHMuc3RyQ29uY2F0ID0gZXhwb3J0cy5hZGRDb2RlQXJnID0gZXhwb3J0cy5zdHIgPSBleHBvcnRzLl8gPSBleHBvcnRzLm5pbCA9IGV4cG9ydHMuX0NvZGUgPSBleHBvcnRzLk5hbWUgPSBleHBvcnRzLklERU5USUZJRVIgPSBleHBvcnRzLl9Db2RlT3JOYW1lID0gdm9pZCAwO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHRyYW5lb3VzLWNsYXNzXG5jbGFzcyBfQ29kZU9yTmFtZSB7XG59XG5leHBvcnRzLl9Db2RlT3JOYW1lID0gX0NvZGVPck5hbWU7XG5leHBvcnRzLklERU5USUZJRVIgPSAvXlthLXokX11bYS16JF8wLTldKiQvaTtcbmNsYXNzIE5hbWUgZXh0ZW5kcyBfQ29kZU9yTmFtZSB7XG4gICAgY29uc3RydWN0b3Iocykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBpZiAoIWV4cG9ydHMuSURFTlRJRklFUi50ZXN0KHMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29kZUdlbjogbmFtZSBtdXN0IGJlIGEgdmFsaWQgaWRlbnRpZmllclwiKTtcbiAgICAgICAgdGhpcy5zdHIgPSBzO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyO1xuICAgIH1cbiAgICBlbXB0eVN0cigpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIHJldHVybiB7IFt0aGlzLnN0cl06IDEgfTtcbiAgICB9XG59XG5leHBvcnRzLk5hbWUgPSBOYW1lO1xuY2xhc3MgX0NvZGUgZXh0ZW5kcyBfQ29kZU9yTmFtZSB7XG4gICAgY29uc3RydWN0b3IoY29kZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9pdGVtcyA9IHR5cGVvZiBjb2RlID09PSBcInN0cmluZ1wiID8gW2NvZGVdIDogY29kZTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cjtcbiAgICB9XG4gICAgZW1wdHlTdHIoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pdGVtcy5sZW5ndGggPiAxKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5faXRlbXNbMF07XG4gICAgICAgIHJldHVybiBpdGVtID09PSBcIlwiIHx8IGl0ZW0gPT09ICdcIlwiJztcbiAgICB9XG4gICAgZ2V0IHN0cigpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IHRoaXMuX3N0cikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKHRoaXMuX3N0ciA9IHRoaXMuX2l0ZW1zLnJlZHVjZSgocywgYykgPT4gYCR7c30ke2N9YCwgXCJcIikpKTtcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gdGhpcy5fbmFtZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICh0aGlzLl9uYW1lcyA9IHRoaXMuX2l0ZW1zLnJlZHVjZSgobmFtZXMsIGMpID0+IHtcbiAgICAgICAgICAgIGlmIChjIGluc3RhbmNlb2YgTmFtZSlcbiAgICAgICAgICAgICAgICBuYW1lc1tjLnN0cl0gPSAobmFtZXNbYy5zdHJdIHx8IDApICsgMTtcbiAgICAgICAgICAgIHJldHVybiBuYW1lcztcbiAgICAgICAgfSwge30pKSk7XG4gICAgfVxufVxuZXhwb3J0cy5fQ29kZSA9IF9Db2RlO1xuZXhwb3J0cy5uaWwgPSBuZXcgX0NvZGUoXCJcIik7XG5mdW5jdGlvbiBfKHN0cnMsIC4uLmFyZ3MpIHtcbiAgICBjb25zdCBjb2RlID0gW3N0cnNbMF1dO1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGFkZENvZGVBcmcoY29kZSwgYXJnc1tpXSk7XG4gICAgICAgIGNvZGUucHVzaChzdHJzWysraV0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IF9Db2RlKGNvZGUpO1xufVxuZXhwb3J0cy5fID0gXztcbmNvbnN0IHBsdXMgPSBuZXcgX0NvZGUoXCIrXCIpO1xuZnVuY3Rpb24gc3RyKHN0cnMsIC4uLmFyZ3MpIHtcbiAgICBjb25zdCBleHByID0gW3NhZmVTdHJpbmdpZnkoc3Ryc1swXSldO1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGV4cHIucHVzaChwbHVzKTtcbiAgICAgICAgYWRkQ29kZUFyZyhleHByLCBhcmdzW2ldKTtcbiAgICAgICAgZXhwci5wdXNoKHBsdXMsIHNhZmVTdHJpbmdpZnkoc3Ryc1srK2ldKSk7XG4gICAgfVxuICAgIG9wdGltaXplKGV4cHIpO1xuICAgIHJldHVybiBuZXcgX0NvZGUoZXhwcik7XG59XG5leHBvcnRzLnN0ciA9IHN0cjtcbmZ1bmN0aW9uIGFkZENvZGVBcmcoY29kZSwgYXJnKSB7XG4gICAgaWYgKGFyZyBpbnN0YW5jZW9mIF9Db2RlKVxuICAgICAgICBjb2RlLnB1c2goLi4uYXJnLl9pdGVtcyk7XG4gICAgZWxzZSBpZiAoYXJnIGluc3RhbmNlb2YgTmFtZSlcbiAgICAgICAgY29kZS5wdXNoKGFyZyk7XG4gICAgZWxzZVxuICAgICAgICBjb2RlLnB1c2goaW50ZXJwb2xhdGUoYXJnKSk7XG59XG5leHBvcnRzLmFkZENvZGVBcmcgPSBhZGRDb2RlQXJnO1xuZnVuY3Rpb24gb3B0aW1pemUoZXhwcikge1xuICAgIGxldCBpID0gMTtcbiAgICB3aGlsZSAoaSA8IGV4cHIubGVuZ3RoIC0gMSkge1xuICAgICAgICBpZiAoZXhwcltpXSA9PT0gcGx1cykge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gbWVyZ2VFeHBySXRlbXMoZXhwcltpIC0gMV0sIGV4cHJbaSArIDFdKTtcbiAgICAgICAgICAgIGlmIChyZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGV4cHIuc3BsaWNlKGkgLSAxLCAzLCByZXMpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhwcltpKytdID0gXCIrXCI7XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1lcmdlRXhwckl0ZW1zKGEsIGIpIHtcbiAgICBpZiAoYiA9PT0gJ1wiXCInKVxuICAgICAgICByZXR1cm4gYTtcbiAgICBpZiAoYSA9PT0gJ1wiXCInKVxuICAgICAgICByZXR1cm4gYjtcbiAgICBpZiAodHlwZW9mIGEgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoYiBpbnN0YW5jZW9mIE5hbWUgfHwgYVthLmxlbmd0aCAtIDFdICE9PSAnXCInKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodHlwZW9mIGIgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHJldHVybiBgJHthLnNsaWNlKDAsIC0xKX0ke2J9XCJgO1xuICAgICAgICBpZiAoYlswXSA9PT0gJ1wiJylcbiAgICAgICAgICAgIHJldHVybiBhLnNsaWNlKDAsIC0xKSArIGIuc2xpY2UoMSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBiID09IFwic3RyaW5nXCIgJiYgYlswXSA9PT0gJ1wiJyAmJiAhKGEgaW5zdGFuY2VvZiBOYW1lKSlcbiAgICAgICAgcmV0dXJuIGBcIiR7YX0ke2Iuc2xpY2UoMSl9YDtcbiAgICByZXR1cm47XG59XG5mdW5jdGlvbiBzdHJDb25jYXQoYzEsIGMyKSB7XG4gICAgcmV0dXJuIGMyLmVtcHR5U3RyKCkgPyBjMSA6IGMxLmVtcHR5U3RyKCkgPyBjMiA6IHN0ciBgJHtjMX0ke2MyfWA7XG59XG5leHBvcnRzLnN0ckNvbmNhdCA9IHN0ckNvbmNhdDtcbi8vIFRPRE8gZG8gbm90IGFsbG93IGFycmF5cyBoZXJlXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZSh4KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB4ID09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHggPT0gXCJib29sZWFuXCIgfHwgeCA9PT0gbnVsbFxuICAgICAgICA/IHhcbiAgICAgICAgOiBzYWZlU3RyaW5naWZ5KEFycmF5LmlzQXJyYXkoeCkgPyB4LmpvaW4oXCIsXCIpIDogeCk7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnkoeCkge1xuICAgIHJldHVybiBuZXcgX0NvZGUoc2FmZVN0cmluZ2lmeSh4KSk7XG59XG5leHBvcnRzLnN0cmluZ2lmeSA9IHN0cmluZ2lmeTtcbmZ1bmN0aW9uIHNhZmVTdHJpbmdpZnkoeCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh4KVxuICAgICAgICAucmVwbGFjZSgvXFx1MjAyOC9nLCBcIlxcXFx1MjAyOFwiKVxuICAgICAgICAucmVwbGFjZSgvXFx1MjAyOS9nLCBcIlxcXFx1MjAyOVwiKTtcbn1cbmV4cG9ydHMuc2FmZVN0cmluZ2lmeSA9IHNhZmVTdHJpbmdpZnk7XG5mdW5jdGlvbiBnZXRQcm9wZXJ0eShrZXkpIHtcbiAgICByZXR1cm4gdHlwZW9mIGtleSA9PSBcInN0cmluZ1wiICYmIGV4cG9ydHMuSURFTlRJRklFUi50ZXN0KGtleSkgPyBuZXcgX0NvZGUoYC4ke2tleX1gKSA6IF8gYFske2tleX1dYDtcbn1cbmV4cG9ydHMuZ2V0UHJvcGVydHkgPSBnZXRQcm9wZXJ0eTtcbi8vRG9lcyBiZXN0IGVmZm9ydCB0byBmb3JtYXQgdGhlIG5hbWUgcHJvcGVybHlcbmZ1bmN0aW9uIGdldEVzbUV4cG9ydE5hbWUoa2V5KSB7XG4gICAgaWYgKHR5cGVvZiBrZXkgPT0gXCJzdHJpbmdcIiAmJiBleHBvcnRzLklERU5USUZJRVIudGVzdChrZXkpKSB7XG4gICAgICAgIHJldHVybiBuZXcgX0NvZGUoYCR7a2V5fWApO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvZGVHZW46IGludmFsaWQgZXhwb3J0IG5hbWU6ICR7a2V5fSwgdXNlIGV4cGxpY2l0ICRpZCBuYW1lIG1hcHBpbmdgKTtcbn1cbmV4cG9ydHMuZ2V0RXNtRXhwb3J0TmFtZSA9IGdldEVzbUV4cG9ydE5hbWU7XG5mdW5jdGlvbiByZWdleHBDb2RlKHJ4KSB7XG4gICAgcmV0dXJuIG5ldyBfQ29kZShyeC50b1N0cmluZygpKTtcbn1cbmV4cG9ydHMucmVnZXhwQ29kZSA9IHJlZ2V4cENvZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2RlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5WYWx1ZVNjb3BlID0gZXhwb3J0cy5WYWx1ZVNjb3BlTmFtZSA9IGV4cG9ydHMuU2NvcGUgPSBleHBvcnRzLnZhcktpbmRzID0gZXhwb3J0cy5Vc2VkVmFsdWVTdGF0ZSA9IHZvaWQgMDtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuL2NvZGVcIik7XG5jbGFzcyBWYWx1ZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICAgICAgc3VwZXIoYENvZGVHZW46IFwiY29kZVwiIGZvciAke25hbWV9IG5vdCBkZWZpbmVkYCk7XG4gICAgICAgIHRoaXMudmFsdWUgPSBuYW1lLnZhbHVlO1xuICAgIH1cbn1cbnZhciBVc2VkVmFsdWVTdGF0ZTtcbihmdW5jdGlvbiAoVXNlZFZhbHVlU3RhdGUpIHtcbiAgICBVc2VkVmFsdWVTdGF0ZVtVc2VkVmFsdWVTdGF0ZVtcIlN0YXJ0ZWRcIl0gPSAwXSA9IFwiU3RhcnRlZFwiO1xuICAgIFVzZWRWYWx1ZVN0YXRlW1VzZWRWYWx1ZVN0YXRlW1wiQ29tcGxldGVkXCJdID0gMV0gPSBcIkNvbXBsZXRlZFwiO1xufSkoVXNlZFZhbHVlU3RhdGUgfHwgKGV4cG9ydHMuVXNlZFZhbHVlU3RhdGUgPSBVc2VkVmFsdWVTdGF0ZSA9IHt9KSk7XG5leHBvcnRzLnZhcktpbmRzID0ge1xuICAgIGNvbnN0OiBuZXcgY29kZV8xLk5hbWUoXCJjb25zdFwiKSxcbiAgICBsZXQ6IG5ldyBjb2RlXzEuTmFtZShcImxldFwiKSxcbiAgICB2YXI6IG5ldyBjb2RlXzEuTmFtZShcInZhclwiKSxcbn07XG5jbGFzcyBTY29wZSB7XG4gICAgY29uc3RydWN0b3IoeyBwcmVmaXhlcywgcGFyZW50IH0gPSB7fSkge1xuICAgICAgICB0aGlzLl9uYW1lcyA9IHt9O1xuICAgICAgICB0aGlzLl9wcmVmaXhlcyA9IHByZWZpeGVzO1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgfVxuICAgIHRvTmFtZShuYW1lT3JQcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIG5hbWVPclByZWZpeCBpbnN0YW5jZW9mIGNvZGVfMS5OYW1lID8gbmFtZU9yUHJlZml4IDogdGhpcy5uYW1lKG5hbWVPclByZWZpeCk7XG4gICAgfVxuICAgIG5hbWUocHJlZml4KSB7XG4gICAgICAgIHJldHVybiBuZXcgY29kZV8xLk5hbWUodGhpcy5fbmV3TmFtZShwcmVmaXgpKTtcbiAgICB9XG4gICAgX25ld05hbWUocHJlZml4KSB7XG4gICAgICAgIGNvbnN0IG5nID0gdGhpcy5fbmFtZXNbcHJlZml4XSB8fCB0aGlzLl9uYW1lR3JvdXAocHJlZml4KTtcbiAgICAgICAgcmV0dXJuIGAke3ByZWZpeH0ke25nLmluZGV4Kyt9YDtcbiAgICB9XG4gICAgX25hbWVHcm91cChwcmVmaXgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKCgoX2IgPSAoX2EgPSB0aGlzLl9wYXJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5fcHJlZml4ZXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5oYXMocHJlZml4KSkgfHwgKHRoaXMuX3ByZWZpeGVzICYmICF0aGlzLl9wcmVmaXhlcy5oYXMocHJlZml4KSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29kZUdlbjogcHJlZml4IFwiJHtwcmVmaXh9XCIgaXMgbm90IGFsbG93ZWQgaW4gdGhpcyBzY29wZWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodGhpcy5fbmFtZXNbcHJlZml4XSA9IHsgcHJlZml4LCBpbmRleDogMCB9KTtcbiAgICB9XG59XG5leHBvcnRzLlNjb3BlID0gU2NvcGU7XG5jbGFzcyBWYWx1ZVNjb3BlTmFtZSBleHRlbmRzIGNvZGVfMS5OYW1lIHtcbiAgICBjb25zdHJ1Y3RvcihwcmVmaXgsIG5hbWVTdHIpIHtcbiAgICAgICAgc3VwZXIobmFtZVN0cik7XG4gICAgICAgIHRoaXMucHJlZml4ID0gcHJlZml4O1xuICAgIH1cbiAgICBzZXRWYWx1ZSh2YWx1ZSwgeyBwcm9wZXJ0eSwgaXRlbUluZGV4IH0pIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnNjb3BlUGF0aCA9ICgwLCBjb2RlXzEuXykgYC4ke25ldyBjb2RlXzEuTmFtZShwcm9wZXJ0eSl9WyR7aXRlbUluZGV4fV1gO1xuICAgIH1cbn1cbmV4cG9ydHMuVmFsdWVTY29wZU5hbWUgPSBWYWx1ZVNjb3BlTmFtZTtcbmNvbnN0IGxpbmUgPSAoMCwgY29kZV8xLl8pIGBcXG5gO1xuY2xhc3MgVmFsdWVTY29wZSBleHRlbmRzIFNjb3BlIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHN1cGVyKG9wdHMpO1xuICAgICAgICB0aGlzLl92YWx1ZXMgPSB7fTtcbiAgICAgICAgdGhpcy5fc2NvcGUgPSBvcHRzLnNjb3BlO1xuICAgICAgICB0aGlzLm9wdHMgPSB7IC4uLm9wdHMsIF9uOiBvcHRzLmxpbmVzID8gbGluZSA6IGNvZGVfMS5uaWwgfTtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2NvcGU7XG4gICAgfVxuICAgIG5hbWUocHJlZml4KSB7XG4gICAgICAgIHJldHVybiBuZXcgVmFsdWVTY29wZU5hbWUocHJlZml4LCB0aGlzLl9uZXdOYW1lKHByZWZpeCkpO1xuICAgIH1cbiAgICB2YWx1ZShuYW1lT3JQcmVmaXgsIHZhbHVlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHZhbHVlLnJlZiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29kZUdlbjogcmVmIG11c3QgYmUgcGFzc2VkIGluIHZhbHVlXCIpO1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy50b05hbWUobmFtZU9yUHJlZml4KTtcbiAgICAgICAgY29uc3QgeyBwcmVmaXggfSA9IG5hbWU7XG4gICAgICAgIGNvbnN0IHZhbHVlS2V5ID0gKF9hID0gdmFsdWUua2V5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB2YWx1ZS5yZWY7XG4gICAgICAgIGxldCB2cyA9IHRoaXMuX3ZhbHVlc1twcmVmaXhdO1xuICAgICAgICBpZiAodnMpIHtcbiAgICAgICAgICAgIGNvbnN0IF9uYW1lID0gdnMuZ2V0KHZhbHVlS2V5KTtcbiAgICAgICAgICAgIGlmIChfbmFtZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gX25hbWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2cyA9IHRoaXMuX3ZhbHVlc1twcmVmaXhdID0gbmV3IE1hcCgpO1xuICAgICAgICB9XG4gICAgICAgIHZzLnNldCh2YWx1ZUtleSwgbmFtZSk7XG4gICAgICAgIGNvbnN0IHMgPSB0aGlzLl9zY29wZVtwcmVmaXhdIHx8ICh0aGlzLl9zY29wZVtwcmVmaXhdID0gW10pO1xuICAgICAgICBjb25zdCBpdGVtSW5kZXggPSBzLmxlbmd0aDtcbiAgICAgICAgc1tpdGVtSW5kZXhdID0gdmFsdWUucmVmO1xuICAgICAgICBuYW1lLnNldFZhbHVlKHZhbHVlLCB7IHByb3BlcnR5OiBwcmVmaXgsIGl0ZW1JbmRleCB9KTtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuICAgIGdldFZhbHVlKHByZWZpeCwga2V5T3JSZWYpIHtcbiAgICAgICAgY29uc3QgdnMgPSB0aGlzLl92YWx1ZXNbcHJlZml4XTtcbiAgICAgICAgaWYgKCF2cylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcmV0dXJuIHZzLmdldChrZXlPclJlZik7XG4gICAgfVxuICAgIHNjb3BlUmVmcyhzY29wZU5hbWUsIHZhbHVlcyA9IHRoaXMuX3ZhbHVlcykge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVkdWNlVmFsdWVzKHZhbHVlcywgKG5hbWUpID0+IHtcbiAgICAgICAgICAgIGlmIChuYW1lLnNjb3BlUGF0aCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29kZUdlbjogbmFtZSBcIiR7bmFtZX1cIiBoYXMgbm8gdmFsdWVgKTtcbiAgICAgICAgICAgIHJldHVybiAoMCwgY29kZV8xLl8pIGAke3Njb3BlTmFtZX0ke25hbWUuc2NvcGVQYXRofWA7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzY29wZUNvZGUodmFsdWVzID0gdGhpcy5fdmFsdWVzLCB1c2VkVmFsdWVzLCBnZXRDb2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWR1Y2VWYWx1ZXModmFsdWVzLCAobmFtZSkgPT4ge1xuICAgICAgICAgICAgaWYgKG5hbWUudmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvZGVHZW46IG5hbWUgXCIke25hbWV9XCIgaGFzIG5vIHZhbHVlYCk7XG4gICAgICAgICAgICByZXR1cm4gbmFtZS52YWx1ZS5jb2RlO1xuICAgICAgICB9LCB1c2VkVmFsdWVzLCBnZXRDb2RlKTtcbiAgICB9XG4gICAgX3JlZHVjZVZhbHVlcyh2YWx1ZXMsIHZhbHVlQ29kZSwgdXNlZFZhbHVlcyA9IHt9LCBnZXRDb2RlKSB7XG4gICAgICAgIGxldCBjb2RlID0gY29kZV8xLm5pbDtcbiAgICAgICAgZm9yIChjb25zdCBwcmVmaXggaW4gdmFsdWVzKSB7XG4gICAgICAgICAgICBjb25zdCB2cyA9IHZhbHVlc1twcmVmaXhdO1xuICAgICAgICAgICAgaWYgKCF2cylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNvbnN0IG5hbWVTZXQgPSAodXNlZFZhbHVlc1twcmVmaXhdID0gdXNlZFZhbHVlc1twcmVmaXhdIHx8IG5ldyBNYXAoKSk7XG4gICAgICAgICAgICB2cy5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWVTZXQuaGFzKG5hbWUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgbmFtZVNldC5zZXQobmFtZSwgVXNlZFZhbHVlU3RhdGUuU3RhcnRlZCk7XG4gICAgICAgICAgICAgICAgbGV0IGMgPSB2YWx1ZUNvZGUobmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVmID0gdGhpcy5vcHRzLmVzNSA/IGV4cG9ydHMudmFyS2luZHMudmFyIDogZXhwb3J0cy52YXJLaW5kcy5jb25zdDtcbiAgICAgICAgICAgICAgICAgICAgY29kZSA9ICgwLCBjb2RlXzEuXykgYCR7Y29kZX0ke2RlZn0gJHtuYW1lfSA9ICR7Y307JHt0aGlzLm9wdHMuX259YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKGMgPSBnZXRDb2RlID09PSBudWxsIHx8IGdldENvZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdldENvZGUobmFtZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGUgPSAoMCwgY29kZV8xLl8pIGAke2NvZGV9JHtjfSR7dGhpcy5vcHRzLl9ufWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmFtZVNldC5zZXQobmFtZSwgVXNlZFZhbHVlU3RhdGUuQ29tcGxldGVkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2RlO1xuICAgIH1cbn1cbmV4cG9ydHMuVmFsdWVTY29wZSA9IFZhbHVlU2NvcGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY29wZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMub3IgPSBleHBvcnRzLmFuZCA9IGV4cG9ydHMubm90ID0gZXhwb3J0cy5Db2RlR2VuID0gZXhwb3J0cy5vcGVyYXRvcnMgPSBleHBvcnRzLnZhcktpbmRzID0gZXhwb3J0cy5WYWx1ZVNjb3BlTmFtZSA9IGV4cG9ydHMuVmFsdWVTY29wZSA9IGV4cG9ydHMuU2NvcGUgPSBleHBvcnRzLk5hbWUgPSBleHBvcnRzLnJlZ2V4cENvZGUgPSBleHBvcnRzLnN0cmluZ2lmeSA9IGV4cG9ydHMuZ2V0UHJvcGVydHkgPSBleHBvcnRzLm5pbCA9IGV4cG9ydHMuc3RyQ29uY2F0ID0gZXhwb3J0cy5zdHIgPSBleHBvcnRzLl8gPSB2b2lkIDA7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi9jb2RlXCIpO1xuY29uc3Qgc2NvcGVfMSA9IHJlcXVpcmUoXCIuL3Njb3BlXCIpO1xudmFyIGNvZGVfMiA9IHJlcXVpcmUoXCIuL2NvZGVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlXzIuXzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0clwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZV8yLnN0cjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0ckNvbmNhdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZV8yLnN0ckNvbmNhdDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm5pbFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZV8yLm5pbDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldFByb3BlcnR5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlXzIuZ2V0UHJvcGVydHk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdHJpbmdpZnlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVfMi5zdHJpbmdpZnk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZWdleHBDb2RlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlXzIucmVnZXhwQ29kZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5hbWVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVfMi5OYW1lOyB9IH0pO1xudmFyIHNjb3BlXzIgPSByZXF1aXJlKFwiLi9zY29wZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNjb3BlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzY29wZV8yLlNjb3BlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVmFsdWVTY29wZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2NvcGVfMi5WYWx1ZVNjb3BlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVmFsdWVTY29wZU5hbWVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNjb3BlXzIuVmFsdWVTY29wZU5hbWU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2YXJLaW5kc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2NvcGVfMi52YXJLaW5kczsgfSB9KTtcbmV4cG9ydHMub3BlcmF0b3JzID0ge1xuICAgIEdUOiBuZXcgY29kZV8xLl9Db2RlKFwiPlwiKSxcbiAgICBHVEU6IG5ldyBjb2RlXzEuX0NvZGUoXCI+PVwiKSxcbiAgICBMVDogbmV3IGNvZGVfMS5fQ29kZShcIjxcIiksXG4gICAgTFRFOiBuZXcgY29kZV8xLl9Db2RlKFwiPD1cIiksXG4gICAgRVE6IG5ldyBjb2RlXzEuX0NvZGUoXCI9PT1cIiksXG4gICAgTkVROiBuZXcgY29kZV8xLl9Db2RlKFwiIT09XCIpLFxuICAgIE5PVDogbmV3IGNvZGVfMS5fQ29kZShcIiFcIiksXG4gICAgT1I6IG5ldyBjb2RlXzEuX0NvZGUoXCJ8fFwiKSxcbiAgICBBTkQ6IG5ldyBjb2RlXzEuX0NvZGUoXCImJlwiKSxcbiAgICBBREQ6IG5ldyBjb2RlXzEuX0NvZGUoXCIrXCIpLFxufTtcbmNsYXNzIE5vZGUge1xuICAgIG9wdGltaXplTm9kZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5hbWVzKF9uYW1lcywgX2NvbnN0YW50cykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5jbGFzcyBEZWYgZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3Rvcih2YXJLaW5kLCBuYW1lLCByaHMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy52YXJLaW5kID0gdmFyS2luZDtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5yaHMgPSByaHM7XG4gICAgfVxuICAgIHJlbmRlcih7IGVzNSwgX24gfSkge1xuICAgICAgICBjb25zdCB2YXJLaW5kID0gZXM1ID8gc2NvcGVfMS52YXJLaW5kcy52YXIgOiB0aGlzLnZhcktpbmQ7XG4gICAgICAgIGNvbnN0IHJocyA9IHRoaXMucmhzID09PSB1bmRlZmluZWQgPyBcIlwiIDogYCA9ICR7dGhpcy5yaHN9YDtcbiAgICAgICAgcmV0dXJuIGAke3ZhcktpbmR9ICR7dGhpcy5uYW1lfSR7cmhzfTtgICsgX247XG4gICAgfVxuICAgIG9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykge1xuICAgICAgICBpZiAoIW5hbWVzW3RoaXMubmFtZS5zdHJdKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5yaHMpXG4gICAgICAgICAgICB0aGlzLnJocyA9IG9wdGltaXplRXhwcih0aGlzLnJocywgbmFtZXMsIGNvbnN0YW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJocyBpbnN0YW5jZW9mIGNvZGVfMS5fQ29kZU9yTmFtZSA/IHRoaXMucmhzLm5hbWVzIDoge307XG4gICAgfVxufVxuY2xhc3MgQXNzaWduIGV4dGVuZHMgTm9kZSB7XG4gICAgY29uc3RydWN0b3IobGhzLCByaHMsIHNpZGVFZmZlY3RzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubGhzID0gbGhzO1xuICAgICAgICB0aGlzLnJocyA9IHJocztcbiAgICAgICAgdGhpcy5zaWRlRWZmZWN0cyA9IHNpZGVFZmZlY3RzO1xuICAgIH1cbiAgICByZW5kZXIoeyBfbiB9KSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmxoc30gPSAke3RoaXMucmhzfTtgICsgX247XG4gICAgfVxuICAgIG9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykge1xuICAgICAgICBpZiAodGhpcy5saHMgaW5zdGFuY2VvZiBjb2RlXzEuTmFtZSAmJiAhbmFtZXNbdGhpcy5saHMuc3RyXSAmJiAhdGhpcy5zaWRlRWZmZWN0cylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5yaHMgPSBvcHRpbWl6ZUV4cHIodGhpcy5yaHMsIG5hbWVzLCBjb25zdGFudHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICBjb25zdCBuYW1lcyA9IHRoaXMubGhzIGluc3RhbmNlb2YgY29kZV8xLk5hbWUgPyB7fSA6IHsgLi4udGhpcy5saHMubmFtZXMgfTtcbiAgICAgICAgcmV0dXJuIGFkZEV4cHJOYW1lcyhuYW1lcywgdGhpcy5yaHMpO1xuICAgIH1cbn1cbmNsYXNzIEFzc2lnbk9wIGV4dGVuZHMgQXNzaWduIHtcbiAgICBjb25zdHJ1Y3RvcihsaHMsIG9wLCByaHMsIHNpZGVFZmZlY3RzKSB7XG4gICAgICAgIHN1cGVyKGxocywgcmhzLCBzaWRlRWZmZWN0cyk7XG4gICAgICAgIHRoaXMub3AgPSBvcDtcbiAgICB9XG4gICAgcmVuZGVyKHsgX24gfSkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5saHN9ICR7dGhpcy5vcH09ICR7dGhpcy5yaHN9O2AgKyBfbjtcbiAgICB9XG59XG5jbGFzcyBMYWJlbCBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKGxhYmVsKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubGFiZWwgPSBsYWJlbDtcbiAgICAgICAgdGhpcy5uYW1lcyA9IHt9O1xuICAgIH1cbiAgICByZW5kZXIoeyBfbiB9KSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmxhYmVsfTpgICsgX247XG4gICAgfVxufVxuY2xhc3MgQnJlYWsgZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihsYWJlbCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmxhYmVsID0gbGFiZWw7XG4gICAgICAgIHRoaXMubmFtZXMgPSB7fTtcbiAgICB9XG4gICAgcmVuZGVyKHsgX24gfSkge1xuICAgICAgICBjb25zdCBsYWJlbCA9IHRoaXMubGFiZWwgPyBgICR7dGhpcy5sYWJlbH1gIDogXCJcIjtcbiAgICAgICAgcmV0dXJuIGBicmVhayR7bGFiZWx9O2AgKyBfbjtcbiAgICB9XG59XG5jbGFzcyBUaHJvdyBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKGVycm9yKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICB9XG4gICAgcmVuZGVyKHsgX24gfSkge1xuICAgICAgICByZXR1cm4gYHRocm93ICR7dGhpcy5lcnJvcn07YCArIF9uO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVycm9yLm5hbWVzO1xuICAgIH1cbn1cbmNsYXNzIEFueUNvZGUgZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb2RlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgfVxuICAgIHJlbmRlcih7IF9uIH0pIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuY29kZX07YCArIF9uO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5vZGVzKCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5jb2RlfWAgPyB0aGlzIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpIHtcbiAgICAgICAgdGhpcy5jb2RlID0gb3B0aW1pemVFeHByKHRoaXMuY29kZSwgbmFtZXMsIGNvbnN0YW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvZGUgaW5zdGFuY2VvZiBjb2RlXzEuX0NvZGVPck5hbWUgPyB0aGlzLmNvZGUubmFtZXMgOiB7fTtcbiAgICB9XG59XG5jbGFzcyBQYXJlbnROb2RlIGV4dGVuZHMgTm9kZSB7XG4gICAgY29uc3RydWN0b3Iobm9kZXMgPSBbXSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm5vZGVzID0gbm9kZXM7XG4gICAgfVxuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzLnJlZHVjZSgoY29kZSwgbikgPT4gY29kZSArIG4ucmVuZGVyKG9wdHMpLCBcIlwiKTtcbiAgICB9XG4gICAgb3B0aW1pemVOb2RlcygpIHtcbiAgICAgICAgY29uc3QgeyBub2RlcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGkgPSBub2Rlcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBub2Rlc1tpXS5vcHRpbWl6ZU5vZGVzKCk7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShuKSlcbiAgICAgICAgICAgICAgICBub2Rlcy5zcGxpY2UoaSwgMSwgLi4ubik7XG4gICAgICAgICAgICBlbHNlIGlmIChuKVxuICAgICAgICAgICAgICAgIG5vZGVzW2ldID0gbjtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBub2Rlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGVzLmxlbmd0aCA+IDAgPyB0aGlzIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpIHtcbiAgICAgICAgY29uc3QgeyBub2RlcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGkgPSBub2Rlcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIC8vIGl0ZXJhdGluZyBiYWNrd2FyZHMgaW1wcm92ZXMgMS1wYXNzIG9wdGltaXphdGlvblxuICAgICAgICAgICAgY29uc3QgbiA9IG5vZGVzW2ldO1xuICAgICAgICAgICAgaWYgKG4ub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHN1YnRyYWN0TmFtZXMobmFtZXMsIG4ubmFtZXMpO1xuICAgICAgICAgICAgbm9kZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2Rlcy5sZW5ndGggPiAwID8gdGhpcyA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2Rlcy5yZWR1Y2UoKG5hbWVzLCBuKSA9PiBhZGROYW1lcyhuYW1lcywgbi5uYW1lcyksIHt9KTtcbiAgICB9XG59XG5jbGFzcyBCbG9ja05vZGUgZXh0ZW5kcyBQYXJlbnROb2RlIHtcbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICByZXR1cm4gXCJ7XCIgKyBvcHRzLl9uICsgc3VwZXIucmVuZGVyKG9wdHMpICsgXCJ9XCIgKyBvcHRzLl9uO1xuICAgIH1cbn1cbmNsYXNzIFJvb3QgZXh0ZW5kcyBQYXJlbnROb2RlIHtcbn1cbmNsYXNzIEVsc2UgZXh0ZW5kcyBCbG9ja05vZGUge1xufVxuRWxzZS5raW5kID0gXCJlbHNlXCI7XG5jbGFzcyBJZiBleHRlbmRzIEJsb2NrTm9kZSB7XG4gICAgY29uc3RydWN0b3IoY29uZGl0aW9uLCBub2Rlcykge1xuICAgICAgICBzdXBlcihub2Rlcyk7XG4gICAgICAgIHRoaXMuY29uZGl0aW9uID0gY29uZGl0aW9uO1xuICAgIH1cbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICBsZXQgY29kZSA9IGBpZigke3RoaXMuY29uZGl0aW9ufSlgICsgc3VwZXIucmVuZGVyKG9wdHMpO1xuICAgICAgICBpZiAodGhpcy5lbHNlKVxuICAgICAgICAgICAgY29kZSArPSBcImVsc2UgXCIgKyB0aGlzLmVsc2UucmVuZGVyKG9wdHMpO1xuICAgICAgICByZXR1cm4gY29kZTtcbiAgICB9XG4gICAgb3B0aW1pemVOb2RlcygpIHtcbiAgICAgICAgc3VwZXIub3B0aW1pemVOb2RlcygpO1xuICAgICAgICBjb25zdCBjb25kID0gdGhpcy5jb25kaXRpb247XG4gICAgICAgIGlmIChjb25kID09PSB0cnVlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubm9kZXM7IC8vIGVsc2UgaXMgaWdub3JlZCBoZXJlXG4gICAgICAgIGxldCBlID0gdGhpcy5lbHNlO1xuICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgY29uc3QgbnMgPSBlLm9wdGltaXplTm9kZXMoKTtcbiAgICAgICAgICAgIGUgPSB0aGlzLmVsc2UgPSBBcnJheS5pc0FycmF5KG5zKSA/IG5ldyBFbHNlKG5zKSA6IG5zO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICBpZiAoY29uZCA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBJZiA/IGUgOiBlLm5vZGVzO1xuICAgICAgICAgICAgaWYgKHRoaXMubm9kZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJZihub3QoY29uZCksIGUgaW5zdGFuY2VvZiBJZiA/IFtlXSA6IGUubm9kZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25kID09PSBmYWxzZSB8fCAhdGhpcy5ub2Rlcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgb3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5lbHNlID0gKF9hID0gdGhpcy5lbHNlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKTtcbiAgICAgICAgaWYgKCEoc3VwZXIub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSB8fCB0aGlzLmVsc2UpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmNvbmRpdGlvbiA9IG9wdGltaXplRXhwcih0aGlzLmNvbmRpdGlvbiwgbmFtZXMsIGNvbnN0YW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIGNvbnN0IG5hbWVzID0gc3VwZXIubmFtZXM7XG4gICAgICAgIGFkZEV4cHJOYW1lcyhuYW1lcywgdGhpcy5jb25kaXRpb24pO1xuICAgICAgICBpZiAodGhpcy5lbHNlKVxuICAgICAgICAgICAgYWRkTmFtZXMobmFtZXMsIHRoaXMuZWxzZS5uYW1lcyk7XG4gICAgICAgIHJldHVybiBuYW1lcztcbiAgICB9XG59XG5JZi5raW5kID0gXCJpZlwiO1xuY2xhc3MgRm9yIGV4dGVuZHMgQmxvY2tOb2RlIHtcbn1cbkZvci5raW5kID0gXCJmb3JcIjtcbmNsYXNzIEZvckxvb3AgZXh0ZW5kcyBGb3Ige1xuICAgIGNvbnN0cnVjdG9yKGl0ZXJhdGlvbikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLml0ZXJhdGlvbiA9IGl0ZXJhdGlvbjtcbiAgICB9XG4gICAgcmVuZGVyKG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIGBmb3IoJHt0aGlzLml0ZXJhdGlvbn0pYCArIHN1cGVyLnJlbmRlcihvcHRzKTtcbiAgICB9XG4gICAgb3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSB7XG4gICAgICAgIGlmICghc3VwZXIub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5pdGVyYXRpb24gPSBvcHRpbWl6ZUV4cHIodGhpcy5pdGVyYXRpb24sIG5hbWVzLCBjb25zdGFudHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICByZXR1cm4gYWRkTmFtZXMoc3VwZXIubmFtZXMsIHRoaXMuaXRlcmF0aW9uLm5hbWVzKTtcbiAgICB9XG59XG5jbGFzcyBGb3JSYW5nZSBleHRlbmRzIEZvciB7XG4gICAgY29uc3RydWN0b3IodmFyS2luZCwgbmFtZSwgZnJvbSwgdG8pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy52YXJLaW5kID0gdmFyS2luZDtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgIH1cbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICBjb25zdCB2YXJLaW5kID0gb3B0cy5lczUgPyBzY29wZV8xLnZhcktpbmRzLnZhciA6IHRoaXMudmFyS2luZDtcbiAgICAgICAgY29uc3QgeyBuYW1lLCBmcm9tLCB0byB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGBmb3IoJHt2YXJLaW5kfSAke25hbWV9PSR7ZnJvbX07ICR7bmFtZX08JHt0b307ICR7bmFtZX0rKylgICsgc3VwZXIucmVuZGVyKG9wdHMpO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIGNvbnN0IG5hbWVzID0gYWRkRXhwck5hbWVzKHN1cGVyLm5hbWVzLCB0aGlzLmZyb20pO1xuICAgICAgICByZXR1cm4gYWRkRXhwck5hbWVzKG5hbWVzLCB0aGlzLnRvKTtcbiAgICB9XG59XG5jbGFzcyBGb3JJdGVyIGV4dGVuZHMgRm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihsb29wLCB2YXJLaW5kLCBuYW1lLCBpdGVyYWJsZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmxvb3AgPSBsb29wO1xuICAgICAgICB0aGlzLnZhcktpbmQgPSB2YXJLaW5kO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLml0ZXJhYmxlID0gaXRlcmFibGU7XG4gICAgfVxuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIHJldHVybiBgZm9yKCR7dGhpcy52YXJLaW5kfSAke3RoaXMubmFtZX0gJHt0aGlzLmxvb3B9ICR7dGhpcy5pdGVyYWJsZX0pYCArIHN1cGVyLnJlbmRlcihvcHRzKTtcbiAgICB9XG4gICAgb3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSB7XG4gICAgICAgIGlmICghc3VwZXIub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5pdGVyYWJsZSA9IG9wdGltaXplRXhwcih0aGlzLml0ZXJhYmxlLCBuYW1lcywgY29uc3RhbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIGFkZE5hbWVzKHN1cGVyLm5hbWVzLCB0aGlzLml0ZXJhYmxlLm5hbWVzKTtcbiAgICB9XG59XG5jbGFzcyBGdW5jIGV4dGVuZHMgQmxvY2tOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBhcmdzLCBhc3luYykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgICAgICB0aGlzLmFzeW5jID0gYXN5bmM7XG4gICAgfVxuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIGNvbnN0IF9hc3luYyA9IHRoaXMuYXN5bmMgPyBcImFzeW5jIFwiIDogXCJcIjtcbiAgICAgICAgcmV0dXJuIGAke19hc3luY31mdW5jdGlvbiAke3RoaXMubmFtZX0oJHt0aGlzLmFyZ3N9KWAgKyBzdXBlci5yZW5kZXIob3B0cyk7XG4gICAgfVxufVxuRnVuYy5raW5kID0gXCJmdW5jXCI7XG5jbGFzcyBSZXR1cm4gZXh0ZW5kcyBQYXJlbnROb2RlIHtcbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICByZXR1cm4gXCJyZXR1cm4gXCIgKyBzdXBlci5yZW5kZXIob3B0cyk7XG4gICAgfVxufVxuUmV0dXJuLmtpbmQgPSBcInJldHVyblwiO1xuY2xhc3MgVHJ5IGV4dGVuZHMgQmxvY2tOb2RlIHtcbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICBsZXQgY29kZSA9IFwidHJ5XCIgKyBzdXBlci5yZW5kZXIob3B0cyk7XG4gICAgICAgIGlmICh0aGlzLmNhdGNoKVxuICAgICAgICAgICAgY29kZSArPSB0aGlzLmNhdGNoLnJlbmRlcihvcHRzKTtcbiAgICAgICAgaWYgKHRoaXMuZmluYWxseSlcbiAgICAgICAgICAgIGNvZGUgKz0gdGhpcy5maW5hbGx5LnJlbmRlcihvcHRzKTtcbiAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgfVxuICAgIG9wdGltaXplTm9kZXMoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHN1cGVyLm9wdGltaXplTm9kZXMoKTtcbiAgICAgICAgKF9hID0gdGhpcy5jYXRjaCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9wdGltaXplTm9kZXMoKTtcbiAgICAgICAgKF9iID0gdGhpcy5maW5hbGx5KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iub3B0aW1pemVOb2RlcygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgb3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHN1cGVyLm9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cyk7XG4gICAgICAgIChfYSA9IHRoaXMuY2F0Y2gpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpO1xuICAgICAgICAoX2IgPSB0aGlzLmZpbmFsbHkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICBjb25zdCBuYW1lcyA9IHN1cGVyLm5hbWVzO1xuICAgICAgICBpZiAodGhpcy5jYXRjaClcbiAgICAgICAgICAgIGFkZE5hbWVzKG5hbWVzLCB0aGlzLmNhdGNoLm5hbWVzKTtcbiAgICAgICAgaWYgKHRoaXMuZmluYWxseSlcbiAgICAgICAgICAgIGFkZE5hbWVzKG5hbWVzLCB0aGlzLmZpbmFsbHkubmFtZXMpO1xuICAgICAgICByZXR1cm4gbmFtZXM7XG4gICAgfVxufVxuY2xhc3MgQ2F0Y2ggZXh0ZW5kcyBCbG9ja05vZGUge1xuICAgIGNvbnN0cnVjdG9yKGVycm9yKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICB9XG4gICAgcmVuZGVyKG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIGBjYXRjaCgke3RoaXMuZXJyb3J9KWAgKyBzdXBlci5yZW5kZXIob3B0cyk7XG4gICAgfVxufVxuQ2F0Y2gua2luZCA9IFwiY2F0Y2hcIjtcbmNsYXNzIEZpbmFsbHkgZXh0ZW5kcyBCbG9ja05vZGUge1xuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIHJldHVybiBcImZpbmFsbHlcIiArIHN1cGVyLnJlbmRlcihvcHRzKTtcbiAgICB9XG59XG5GaW5hbGx5LmtpbmQgPSBcImZpbmFsbHlcIjtcbmNsYXNzIENvZGVHZW4ge1xuICAgIGNvbnN0cnVjdG9yKGV4dFNjb3BlLCBvcHRzID0ge30pIHtcbiAgICAgICAgdGhpcy5fdmFsdWVzID0ge307XG4gICAgICAgIHRoaXMuX2Jsb2NrU3RhcnRzID0gW107XG4gICAgICAgIHRoaXMuX2NvbnN0YW50cyA9IHt9O1xuICAgICAgICB0aGlzLm9wdHMgPSB7IC4uLm9wdHMsIF9uOiBvcHRzLmxpbmVzID8gXCJcXG5cIiA6IFwiXCIgfTtcbiAgICAgICAgdGhpcy5fZXh0U2NvcGUgPSBleHRTY29wZTtcbiAgICAgICAgdGhpcy5fc2NvcGUgPSBuZXcgc2NvcGVfMS5TY29wZSh7IHBhcmVudDogZXh0U2NvcGUgfSk7XG4gICAgICAgIHRoaXMuX25vZGVzID0gW25ldyBSb290KCldO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3QucmVuZGVyKHRoaXMub3B0cyk7XG4gICAgfVxuICAgIC8vIHJldHVybnMgdW5pcXVlIG5hbWUgaW4gdGhlIGludGVybmFsIHNjb3BlXG4gICAgbmFtZShwcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Njb3BlLm5hbWUocHJlZml4KTtcbiAgICB9XG4gICAgLy8gcmVzZXJ2ZXMgdW5pcXVlIG5hbWUgaW4gdGhlIGV4dGVybmFsIHNjb3BlXG4gICAgc2NvcGVOYW1lKHByZWZpeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXh0U2NvcGUubmFtZShwcmVmaXgpO1xuICAgIH1cbiAgICAvLyByZXNlcnZlcyB1bmlxdWUgbmFtZSBpbiB0aGUgZXh0ZXJuYWwgc2NvcGUgYW5kIGFzc2lnbnMgdmFsdWUgdG8gaXRcbiAgICBzY29wZVZhbHVlKHByZWZpeE9yTmFtZSwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuX2V4dFNjb3BlLnZhbHVlKHByZWZpeE9yTmFtZSwgdmFsdWUpO1xuICAgICAgICBjb25zdCB2cyA9IHRoaXMuX3ZhbHVlc1tuYW1lLnByZWZpeF0gfHwgKHRoaXMuX3ZhbHVlc1tuYW1lLnByZWZpeF0gPSBuZXcgU2V0KCkpO1xuICAgICAgICB2cy5hZGQobmFtZSk7XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbiAgICBnZXRTY29wZVZhbHVlKHByZWZpeCwga2V5T3JSZWYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4dFNjb3BlLmdldFZhbHVlKHByZWZpeCwga2V5T3JSZWYpO1xuICAgIH1cbiAgICAvLyByZXR1cm4gY29kZSB0aGF0IGFzc2lnbnMgdmFsdWVzIGluIHRoZSBleHRlcm5hbCBzY29wZSB0byB0aGUgbmFtZXMgdGhhdCBhcmUgdXNlZCBpbnRlcm5hbGx5XG4gICAgLy8gKHNhbWUgbmFtZXMgdGhhdCB3ZXJlIHJldHVybmVkIGJ5IGdlbi5zY29wZU5hbWUgb3IgZ2VuLnNjb3BlVmFsdWUpXG4gICAgc2NvcGVSZWZzKHNjb3BlTmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXh0U2NvcGUuc2NvcGVSZWZzKHNjb3BlTmFtZSwgdGhpcy5fdmFsdWVzKTtcbiAgICB9XG4gICAgc2NvcGVDb2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXh0U2NvcGUuc2NvcGVDb2RlKHRoaXMuX3ZhbHVlcyk7XG4gICAgfVxuICAgIF9kZWYodmFyS2luZCwgbmFtZU9yUHJlZml4LCByaHMsIGNvbnN0YW50KSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLl9zY29wZS50b05hbWUobmFtZU9yUHJlZml4KTtcbiAgICAgICAgaWYgKHJocyAhPT0gdW5kZWZpbmVkICYmIGNvbnN0YW50KVxuICAgICAgICAgICAgdGhpcy5fY29uc3RhbnRzW25hbWUuc3RyXSA9IHJocztcbiAgICAgICAgdGhpcy5fbGVhZk5vZGUobmV3IERlZih2YXJLaW5kLCBuYW1lLCByaHMpKTtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuICAgIC8vIGBjb25zdGAgZGVjbGFyYXRpb24gKGB2YXJgIGluIGVzNSBtb2RlKVxuICAgIGNvbnN0KG5hbWVPclByZWZpeCwgcmhzLCBfY29uc3RhbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZihzY29wZV8xLnZhcktpbmRzLmNvbnN0LCBuYW1lT3JQcmVmaXgsIHJocywgX2NvbnN0YW50KTtcbiAgICB9XG4gICAgLy8gYGxldGAgZGVjbGFyYXRpb24gd2l0aCBvcHRpb25hbCBhc3NpZ25tZW50IChgdmFyYCBpbiBlczUgbW9kZSlcbiAgICBsZXQobmFtZU9yUHJlZml4LCByaHMsIF9jb25zdGFudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmKHNjb3BlXzEudmFyS2luZHMubGV0LCBuYW1lT3JQcmVmaXgsIHJocywgX2NvbnN0YW50KTtcbiAgICB9XG4gICAgLy8gYHZhcmAgZGVjbGFyYXRpb24gd2l0aCBvcHRpb25hbCBhc3NpZ25tZW50XG4gICAgdmFyKG5hbWVPclByZWZpeCwgcmhzLCBfY29uc3RhbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZihzY29wZV8xLnZhcktpbmRzLnZhciwgbmFtZU9yUHJlZml4LCByaHMsIF9jb25zdGFudCk7XG4gICAgfVxuICAgIC8vIGFzc2lnbm1lbnQgY29kZVxuICAgIGFzc2lnbihsaHMsIHJocywgc2lkZUVmZmVjdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlYWZOb2RlKG5ldyBBc3NpZ24obGhzLCByaHMsIHNpZGVFZmZlY3RzKSk7XG4gICAgfVxuICAgIC8vIGArPWAgY29kZVxuICAgIGFkZChsaHMsIHJocykge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVhZk5vZGUobmV3IEFzc2lnbk9wKGxocywgZXhwb3J0cy5vcGVyYXRvcnMuQURELCByaHMpKTtcbiAgICB9XG4gICAgLy8gYXBwZW5kcyBwYXNzZWQgU2FmZUV4cHIgdG8gY29kZSBvciBleGVjdXRlcyBCbG9ja1xuICAgIGNvZGUoYykge1xuICAgICAgICBpZiAodHlwZW9mIGMgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgYygpO1xuICAgICAgICBlbHNlIGlmIChjICE9PSBjb2RlXzEubmlsKVxuICAgICAgICAgICAgdGhpcy5fbGVhZk5vZGUobmV3IEFueUNvZGUoYykpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gcmV0dXJucyBjb2RlIGZvciBvYmplY3QgbGl0ZXJhbCBmb3IgdGhlIHBhc3NlZCBhcmd1bWVudCBsaXN0IG9mIGtleS12YWx1ZSBwYWlyc1xuICAgIG9iamVjdCguLi5rZXlWYWx1ZXMpIHtcbiAgICAgICAgY29uc3QgY29kZSA9IFtcIntcIl07XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGtleVZhbHVlcykge1xuICAgICAgICAgICAgaWYgKGNvZGUubGVuZ3RoID4gMSlcbiAgICAgICAgICAgICAgICBjb2RlLnB1c2goXCIsXCIpO1xuICAgICAgICAgICAgY29kZS5wdXNoKGtleSk7XG4gICAgICAgICAgICBpZiAoa2V5ICE9PSB2YWx1ZSB8fCB0aGlzLm9wdHMuZXM1KSB7XG4gICAgICAgICAgICAgICAgY29kZS5wdXNoKFwiOlwiKTtcbiAgICAgICAgICAgICAgICAoMCwgY29kZV8xLmFkZENvZGVBcmcpKGNvZGUsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb2RlLnB1c2goXCJ9XCIpO1xuICAgICAgICByZXR1cm4gbmV3IGNvZGVfMS5fQ29kZShjb2RlKTtcbiAgICB9XG4gICAgLy8gYGlmYCBjbGF1c2UgKG9yIHN0YXRlbWVudCBpZiBgdGhlbkJvZHlgIGFuZCwgb3B0aW9uYWxseSwgYGVsc2VCb2R5YCBhcmUgcGFzc2VkKVxuICAgIGlmKGNvbmRpdGlvbiwgdGhlbkJvZHksIGVsc2VCb2R5KSB7XG4gICAgICAgIHRoaXMuX2Jsb2NrTm9kZShuZXcgSWYoY29uZGl0aW9uKSk7XG4gICAgICAgIGlmICh0aGVuQm9keSAmJiBlbHNlQm9keSkge1xuICAgICAgICAgICAgdGhpcy5jb2RlKHRoZW5Cb2R5KS5lbHNlKCkuY29kZShlbHNlQm9keSkuZW5kSWYoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGVuQm9keSkge1xuICAgICAgICAgICAgdGhpcy5jb2RlKHRoZW5Cb2R5KS5lbmRJZigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsc2VCb2R5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvZGVHZW46IFwiZWxzZVwiIGJvZHkgd2l0aG91dCBcInRoZW5cIiBib2R5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIGBlbHNlIGlmYCBjbGF1c2UgLSBpbnZhbGlkIHdpdGhvdXQgYGlmYCBvciBhZnRlciBgZWxzZWAgY2xhdXNlc1xuICAgIGVsc2VJZihjb25kaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Vsc2VOb2RlKG5ldyBJZihjb25kaXRpb24pKTtcbiAgICB9XG4gICAgLy8gYGVsc2VgIGNsYXVzZSAtIG9ubHkgdmFsaWQgYWZ0ZXIgYGlmYCBvciBgZWxzZSBpZmAgY2xhdXNlc1xuICAgIGVsc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbHNlTm9kZShuZXcgRWxzZSgpKTtcbiAgICB9XG4gICAgLy8gZW5kIGBpZmAgc3RhdGVtZW50IChuZWVkZWQgaWYgZ2VuLmlmIHdhcyB1c2VkIG9ubHkgd2l0aCBjb25kaXRpb24pXG4gICAgZW5kSWYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmRCbG9ja05vZGUoSWYsIEVsc2UpO1xuICAgIH1cbiAgICBfZm9yKG5vZGUsIGZvckJvZHkpIHtcbiAgICAgICAgdGhpcy5fYmxvY2tOb2RlKG5vZGUpO1xuICAgICAgICBpZiAoZm9yQm9keSlcbiAgICAgICAgICAgIHRoaXMuY29kZShmb3JCb2R5KS5lbmRGb3IoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIGEgZ2VuZXJpYyBgZm9yYCBjbGF1c2UgKG9yIHN0YXRlbWVudCBpZiBgZm9yQm9keWAgaXMgcGFzc2VkKVxuICAgIGZvcihpdGVyYXRpb24sIGZvckJvZHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZvcihuZXcgRm9yTG9vcChpdGVyYXRpb24pLCBmb3JCb2R5KTtcbiAgICB9XG4gICAgLy8gYGZvcmAgc3RhdGVtZW50IGZvciBhIHJhbmdlIG9mIHZhbHVlc1xuICAgIGZvclJhbmdlKG5hbWVPclByZWZpeCwgZnJvbSwgdG8sIGZvckJvZHksIHZhcktpbmQgPSB0aGlzLm9wdHMuZXM1ID8gc2NvcGVfMS52YXJLaW5kcy52YXIgOiBzY29wZV8xLnZhcktpbmRzLmxldCkge1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5fc2NvcGUudG9OYW1lKG5hbWVPclByZWZpeCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9mb3IobmV3IEZvclJhbmdlKHZhcktpbmQsIG5hbWUsIGZyb20sIHRvKSwgKCkgPT4gZm9yQm9keShuYW1lKSk7XG4gICAgfVxuICAgIC8vIGBmb3Itb2ZgIHN0YXRlbWVudCAoaW4gZXM1IG1vZGUgcmVwbGFjZSB3aXRoIGEgbm9ybWFsIGZvciBsb29wKVxuICAgIGZvck9mKG5hbWVPclByZWZpeCwgaXRlcmFibGUsIGZvckJvZHksIHZhcktpbmQgPSBzY29wZV8xLnZhcktpbmRzLmNvbnN0KSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLl9zY29wZS50b05hbWUobmFtZU9yUHJlZml4KTtcbiAgICAgICAgaWYgKHRoaXMub3B0cy5lczUpIHtcbiAgICAgICAgICAgIGNvbnN0IGFyciA9IGl0ZXJhYmxlIGluc3RhbmNlb2YgY29kZV8xLk5hbWUgPyBpdGVyYWJsZSA6IHRoaXMudmFyKFwiX2FyclwiLCBpdGVyYWJsZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JSYW5nZShcIl9pXCIsIDAsICgwLCBjb2RlXzEuXykgYCR7YXJyfS5sZW5ndGhgLCAoaSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudmFyKG5hbWUsICgwLCBjb2RlXzEuXykgYCR7YXJyfVske2l9XWApO1xuICAgICAgICAgICAgICAgIGZvckJvZHkobmFtZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZm9yKG5ldyBGb3JJdGVyKFwib2ZcIiwgdmFyS2luZCwgbmFtZSwgaXRlcmFibGUpLCAoKSA9PiBmb3JCb2R5KG5hbWUpKTtcbiAgICB9XG4gICAgLy8gYGZvci1pbmAgc3RhdGVtZW50LlxuICAgIC8vIFdpdGggb3B0aW9uIGBvd25Qcm9wZXJ0aWVzYCByZXBsYWNlZCB3aXRoIGEgYGZvci1vZmAgbG9vcCBmb3Igb2JqZWN0IGtleXNcbiAgICBmb3JJbihuYW1lT3JQcmVmaXgsIG9iaiwgZm9yQm9keSwgdmFyS2luZCA9IHRoaXMub3B0cy5lczUgPyBzY29wZV8xLnZhcktpbmRzLnZhciA6IHNjb3BlXzEudmFyS2luZHMuY29uc3QpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0cy5vd25Qcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JPZihuYW1lT3JQcmVmaXgsICgwLCBjb2RlXzEuXykgYE9iamVjdC5rZXlzKCR7b2JqfSlgLCBmb3JCb2R5KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5fc2NvcGUudG9OYW1lKG5hbWVPclByZWZpeCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9mb3IobmV3IEZvckl0ZXIoXCJpblwiLCB2YXJLaW5kLCBuYW1lLCBvYmopLCAoKSA9PiBmb3JCb2R5KG5hbWUpKTtcbiAgICB9XG4gICAgLy8gZW5kIGBmb3JgIGxvb3BcbiAgICBlbmRGb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmRCbG9ja05vZGUoRm9yKTtcbiAgICB9XG4gICAgLy8gYGxhYmVsYCBzdGF0ZW1lbnRcbiAgICBsYWJlbChsYWJlbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVhZk5vZGUobmV3IExhYmVsKGxhYmVsKSk7XG4gICAgfVxuICAgIC8vIGBicmVha2Agc3RhdGVtZW50XG4gICAgYnJlYWsobGFiZWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlYWZOb2RlKG5ldyBCcmVhayhsYWJlbCkpO1xuICAgIH1cbiAgICAvLyBgcmV0dXJuYCBzdGF0ZW1lbnRcbiAgICByZXR1cm4odmFsdWUpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5ldyBSZXR1cm4oKTtcbiAgICAgICAgdGhpcy5fYmxvY2tOb2RlKG5vZGUpO1xuICAgICAgICB0aGlzLmNvZGUodmFsdWUpO1xuICAgICAgICBpZiAobm9kZS5ub2Rlcy5sZW5ndGggIT09IDEpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvZGVHZW46IFwicmV0dXJuXCIgc2hvdWxkIGhhdmUgb25lIG5vZGUnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuZEJsb2NrTm9kZShSZXR1cm4pO1xuICAgIH1cbiAgICAvLyBgdHJ5YCBzdGF0ZW1lbnRcbiAgICB0cnkodHJ5Qm9keSwgY2F0Y2hDb2RlLCBmaW5hbGx5Q29kZSkge1xuICAgICAgICBpZiAoIWNhdGNoQ29kZSAmJiAhZmluYWxseUNvZGUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvZGVHZW46IFwidHJ5XCIgd2l0aG91dCBcImNhdGNoXCIgYW5kIFwiZmluYWxseVwiJyk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBuZXcgVHJ5KCk7XG4gICAgICAgIHRoaXMuX2Jsb2NrTm9kZShub2RlKTtcbiAgICAgICAgdGhpcy5jb2RlKHRyeUJvZHkpO1xuICAgICAgICBpZiAoY2F0Y2hDb2RlKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMubmFtZShcImVcIik7XG4gICAgICAgICAgICB0aGlzLl9jdXJyTm9kZSA9IG5vZGUuY2F0Y2ggPSBuZXcgQ2F0Y2goZXJyb3IpO1xuICAgICAgICAgICAgY2F0Y2hDb2RlKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmluYWxseUNvZGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJOb2RlID0gbm9kZS5maW5hbGx5ID0gbmV3IEZpbmFsbHkoKTtcbiAgICAgICAgICAgIHRoaXMuY29kZShmaW5hbGx5Q29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuZEJsb2NrTm9kZShDYXRjaCwgRmluYWxseSk7XG4gICAgfVxuICAgIC8vIGB0aHJvd2Agc3RhdGVtZW50XG4gICAgdGhyb3coZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlYWZOb2RlKG5ldyBUaHJvdyhlcnJvcikpO1xuICAgIH1cbiAgICAvLyBzdGFydCBzZWxmLWJhbGFuY2luZyBibG9ja1xuICAgIGJsb2NrKGJvZHksIG5vZGVDb3VudCkge1xuICAgICAgICB0aGlzLl9ibG9ja1N0YXJ0cy5wdXNoKHRoaXMuX25vZGVzLmxlbmd0aCk7XG4gICAgICAgIGlmIChib2R5KVxuICAgICAgICAgICAgdGhpcy5jb2RlKGJvZHkpLmVuZEJsb2NrKG5vZGVDb3VudCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBlbmQgdGhlIGN1cnJlbnQgc2VsZi1iYWxhbmNpbmcgYmxvY2tcbiAgICBlbmRCbG9jayhub2RlQ291bnQpIHtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5fYmxvY2tTdGFydHMucG9wKCk7XG4gICAgICAgIGlmIChsZW4gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvZGVHZW46IG5vdCBpbiBzZWxmLWJhbGFuY2luZyBibG9ja1wiKTtcbiAgICAgICAgY29uc3QgdG9DbG9zZSA9IHRoaXMuX25vZGVzLmxlbmd0aCAtIGxlbjtcbiAgICAgICAgaWYgKHRvQ2xvc2UgPCAwIHx8IChub2RlQ291bnQgIT09IHVuZGVmaW5lZCAmJiB0b0Nsb3NlICE9PSBub2RlQ291bnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvZGVHZW46IHdyb25nIG51bWJlciBvZiBub2RlczogJHt0b0Nsb3NlfSB2cyAke25vZGVDb3VudH0gZXhwZWN0ZWRgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9ub2Rlcy5sZW5ndGggPSBsZW47XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBgZnVuY3Rpb25gIGhlYWRpbmcgKG9yIGRlZmluaXRpb24gaWYgZnVuY0JvZHkgaXMgcGFzc2VkKVxuICAgIGZ1bmMobmFtZSwgYXJncyA9IGNvZGVfMS5uaWwsIGFzeW5jLCBmdW5jQm9keSkge1xuICAgICAgICB0aGlzLl9ibG9ja05vZGUobmV3IEZ1bmMobmFtZSwgYXJncywgYXN5bmMpKTtcbiAgICAgICAgaWYgKGZ1bmNCb2R5KVxuICAgICAgICAgICAgdGhpcy5jb2RlKGZ1bmNCb2R5KS5lbmRGdW5jKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBlbmQgZnVuY3Rpb24gZGVmaW5pdGlvblxuICAgIGVuZEZ1bmMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmRCbG9ja05vZGUoRnVuYyk7XG4gICAgfVxuICAgIG9wdGltaXplKG4gPSAxKSB7XG4gICAgICAgIHdoaWxlIChuLS0gPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9yb290Lm9wdGltaXplTm9kZXMoKTtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3Qub3B0aW1pemVOYW1lcyh0aGlzLl9yb290Lm5hbWVzLCB0aGlzLl9jb25zdGFudHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9sZWFmTm9kZShub2RlKSB7XG4gICAgICAgIHRoaXMuX2N1cnJOb2RlLm5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBfYmxvY2tOb2RlKG5vZGUpIHtcbiAgICAgICAgdGhpcy5fY3Vyck5vZGUubm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgdGhpcy5fbm9kZXMucHVzaChub2RlKTtcbiAgICB9XG4gICAgX2VuZEJsb2NrTm9kZShOMSwgTjIpIHtcbiAgICAgICAgY29uc3QgbiA9IHRoaXMuX2N1cnJOb2RlO1xuICAgICAgICBpZiAobiBpbnN0YW5jZW9mIE4xIHx8IChOMiAmJiBuIGluc3RhbmNlb2YgTjIpKSB7XG4gICAgICAgICAgICB0aGlzLl9ub2Rlcy5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29kZUdlbjogbm90IGluIGJsb2NrIFwiJHtOMiA/IGAke04xLmtpbmR9LyR7TjIua2luZH1gIDogTjEua2luZH1cImApO1xuICAgIH1cbiAgICBfZWxzZU5vZGUobm9kZSkge1xuICAgICAgICBjb25zdCBuID0gdGhpcy5fY3Vyck5vZGU7XG4gICAgICAgIGlmICghKG4gaW5zdGFuY2VvZiBJZikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29kZUdlbjogXCJlbHNlXCIgd2l0aG91dCBcImlmXCInKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jdXJyTm9kZSA9IG4uZWxzZSA9IG5vZGU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgX3Jvb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ub2Rlc1swXTtcbiAgICB9XG4gICAgZ2V0IF9jdXJyTm9kZSgpIHtcbiAgICAgICAgY29uc3QgbnMgPSB0aGlzLl9ub2RlcztcbiAgICAgICAgcmV0dXJuIG5zW25zLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICBzZXQgX2N1cnJOb2RlKG5vZGUpIHtcbiAgICAgICAgY29uc3QgbnMgPSB0aGlzLl9ub2RlcztcbiAgICAgICAgbnNbbnMubGVuZ3RoIC0gMV0gPSBub2RlO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29kZUdlbiA9IENvZGVHZW47XG5mdW5jdGlvbiBhZGROYW1lcyhuYW1lcywgZnJvbSkge1xuICAgIGZvciAoY29uc3QgbiBpbiBmcm9tKVxuICAgICAgICBuYW1lc1tuXSA9IChuYW1lc1tuXSB8fCAwKSArIChmcm9tW25dIHx8IDApO1xuICAgIHJldHVybiBuYW1lcztcbn1cbmZ1bmN0aW9uIGFkZEV4cHJOYW1lcyhuYW1lcywgZnJvbSkge1xuICAgIHJldHVybiBmcm9tIGluc3RhbmNlb2YgY29kZV8xLl9Db2RlT3JOYW1lID8gYWRkTmFtZXMobmFtZXMsIGZyb20ubmFtZXMpIDogbmFtZXM7XG59XG5mdW5jdGlvbiBvcHRpbWl6ZUV4cHIoZXhwciwgbmFtZXMsIGNvbnN0YW50cykge1xuICAgIGlmIChleHByIGluc3RhbmNlb2YgY29kZV8xLk5hbWUpXG4gICAgICAgIHJldHVybiByZXBsYWNlTmFtZShleHByKTtcbiAgICBpZiAoIWNhbk9wdGltaXplKGV4cHIpKVxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICByZXR1cm4gbmV3IGNvZGVfMS5fQ29kZShleHByLl9pdGVtcy5yZWR1Y2UoKGl0ZW1zLCBjKSA9PiB7XG4gICAgICAgIGlmIChjIGluc3RhbmNlb2YgY29kZV8xLk5hbWUpXG4gICAgICAgICAgICBjID0gcmVwbGFjZU5hbWUoYyk7XG4gICAgICAgIGlmIChjIGluc3RhbmNlb2YgY29kZV8xLl9Db2RlKVxuICAgICAgICAgICAgaXRlbXMucHVzaCguLi5jLl9pdGVtcyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goYyk7XG4gICAgICAgIHJldHVybiBpdGVtcztcbiAgICB9LCBbXSkpO1xuICAgIGZ1bmN0aW9uIHJlcGxhY2VOYW1lKG4pIHtcbiAgICAgICAgY29uc3QgYyA9IGNvbnN0YW50c1tuLnN0cl07XG4gICAgICAgIGlmIChjID09PSB1bmRlZmluZWQgfHwgbmFtZXNbbi5zdHJdICE9PSAxKVxuICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIGRlbGV0ZSBuYW1lc1tuLnN0cl07XG4gICAgICAgIHJldHVybiBjO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjYW5PcHRpbWl6ZShlKSB7XG4gICAgICAgIHJldHVybiAoZSBpbnN0YW5jZW9mIGNvZGVfMS5fQ29kZSAmJlxuICAgICAgICAgICAgZS5faXRlbXMuc29tZSgoYykgPT4gYyBpbnN0YW5jZW9mIGNvZGVfMS5OYW1lICYmIG5hbWVzW2Muc3RyXSA9PT0gMSAmJiBjb25zdGFudHNbYy5zdHJdICE9PSB1bmRlZmluZWQpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzdWJ0cmFjdE5hbWVzKG5hbWVzLCBmcm9tKSB7XG4gICAgZm9yIChjb25zdCBuIGluIGZyb20pXG4gICAgICAgIG5hbWVzW25dID0gKG5hbWVzW25dIHx8IDApIC0gKGZyb21bbl0gfHwgMCk7XG59XG5mdW5jdGlvbiBub3QoeCkge1xuICAgIHJldHVybiB0eXBlb2YgeCA9PSBcImJvb2xlYW5cIiB8fCB0eXBlb2YgeCA9PSBcIm51bWJlclwiIHx8IHggPT09IG51bGwgPyAheCA6ICgwLCBjb2RlXzEuXykgYCEke3Bhcih4KX1gO1xufVxuZXhwb3J0cy5ub3QgPSBub3Q7XG5jb25zdCBhbmRDb2RlID0gbWFwcGVuZChleHBvcnRzLm9wZXJhdG9ycy5BTkQpO1xuLy8gYm9vbGVhbiBBTkQgKCYmKSBleHByZXNzaW9uIHdpdGggdGhlIHBhc3NlZCBhcmd1bWVudHNcbmZ1bmN0aW9uIGFuZCguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGFyZ3MucmVkdWNlKGFuZENvZGUpO1xufVxuZXhwb3J0cy5hbmQgPSBhbmQ7XG5jb25zdCBvckNvZGUgPSBtYXBwZW5kKGV4cG9ydHMub3BlcmF0b3JzLk9SKTtcbi8vIGJvb2xlYW4gT1IgKHx8KSBleHByZXNzaW9uIHdpdGggdGhlIHBhc3NlZCBhcmd1bWVudHNcbmZ1bmN0aW9uIG9yKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gYXJncy5yZWR1Y2Uob3JDb2RlKTtcbn1cbmV4cG9ydHMub3IgPSBvcjtcbmZ1bmN0aW9uIG1hcHBlbmQob3ApIHtcbiAgICByZXR1cm4gKHgsIHkpID0+ICh4ID09PSBjb2RlXzEubmlsID8geSA6IHkgPT09IGNvZGVfMS5uaWwgPyB4IDogKDAsIGNvZGVfMS5fKSBgJHtwYXIoeCl9ICR7b3B9ICR7cGFyKHkpfWApO1xufVxuZnVuY3Rpb24gcGFyKHgpIHtcbiAgICByZXR1cm4geCBpbnN0YW5jZW9mIGNvZGVfMS5OYW1lID8geCA6ICgwLCBjb2RlXzEuXykgYCgke3h9KWA7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY2hlY2tTdHJpY3RNb2RlID0gZXhwb3J0cy5nZXRFcnJvclBhdGggPSBleHBvcnRzLlR5cGUgPSBleHBvcnRzLnVzZUZ1bmMgPSBleHBvcnRzLnNldEV2YWx1YXRlZCA9IGV4cG9ydHMuZXZhbHVhdGVkUHJvcHNUb05hbWUgPSBleHBvcnRzLm1lcmdlRXZhbHVhdGVkID0gZXhwb3J0cy5lYWNoSXRlbSA9IGV4cG9ydHMudW5lc2NhcGVKc29uUG9pbnRlciA9IGV4cG9ydHMuZXNjYXBlSnNvblBvaW50ZXIgPSBleHBvcnRzLmVzY2FwZUZyYWdtZW50ID0gZXhwb3J0cy51bmVzY2FwZUZyYWdtZW50ID0gZXhwb3J0cy5zY2hlbWFSZWZPclZhbCA9IGV4cG9ydHMuc2NoZW1hSGFzUnVsZXNCdXRSZWYgPSBleHBvcnRzLnNjaGVtYUhhc1J1bGVzID0gZXhwb3J0cy5jaGVja1Vua25vd25SdWxlcyA9IGV4cG9ydHMuYWx3YXlzVmFsaWRTY2hlbWEgPSBleHBvcnRzLnRvSGFzaCA9IHZvaWQgMDtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuL2NvZGVnZW5cIik7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi9jb2RlZ2VuL2NvZGVcIik7XG4vLyBUT0RPIHJlZmFjdG9yIHRvIHVzZSBTZXRcbmZ1bmN0aW9uIHRvSGFzaChhcnIpIHtcbiAgICBjb25zdCBoYXNoID0ge307XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGFycilcbiAgICAgICAgaGFzaFtpdGVtXSA9IHRydWU7XG4gICAgcmV0dXJuIGhhc2g7XG59XG5leHBvcnRzLnRvSGFzaCA9IHRvSGFzaDtcbmZ1bmN0aW9uIGFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2hlbWEpIHtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIilcbiAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICBpZiAoT2JqZWN0LmtleXMoc2NoZW1hKS5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGNoZWNrVW5rbm93blJ1bGVzKGl0LCBzY2hlbWEpO1xuICAgIHJldHVybiAhc2NoZW1hSGFzUnVsZXMoc2NoZW1hLCBpdC5zZWxmLlJVTEVTLmFsbCk7XG59XG5leHBvcnRzLmFsd2F5c1ZhbGlkU2NoZW1hID0gYWx3YXlzVmFsaWRTY2hlbWE7XG5mdW5jdGlvbiBjaGVja1Vua25vd25SdWxlcyhpdCwgc2NoZW1hID0gaXQuc2NoZW1hKSB7XG4gICAgY29uc3QgeyBvcHRzLCBzZWxmIH0gPSBpdDtcbiAgICBpZiAoIW9wdHMuc3RyaWN0U2NoZW1hKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT09IFwiYm9vbGVhblwiKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgcnVsZXMgPSBzZWxmLlJVTEVTLmtleXdvcmRzO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSkge1xuICAgICAgICBpZiAoIXJ1bGVzW2tleV0pXG4gICAgICAgICAgICBjaGVja1N0cmljdE1vZGUoaXQsIGB1bmtub3duIGtleXdvcmQ6IFwiJHtrZXl9XCJgKTtcbiAgICB9XG59XG5leHBvcnRzLmNoZWNrVW5rbm93blJ1bGVzID0gY2hlY2tVbmtub3duUnVsZXM7XG5mdW5jdGlvbiBzY2hlbWFIYXNSdWxlcyhzY2hlbWEsIHJ1bGVzKSB7XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpXG4gICAgICAgIHJldHVybiAhc2NoZW1hO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSlcbiAgICAgICAgaWYgKHJ1bGVzW2tleV0pXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLnNjaGVtYUhhc1J1bGVzID0gc2NoZW1hSGFzUnVsZXM7XG5mdW5jdGlvbiBzY2hlbWFIYXNSdWxlc0J1dFJlZihzY2hlbWEsIFJVTEVTKSB7XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpXG4gICAgICAgIHJldHVybiAhc2NoZW1hO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSlcbiAgICAgICAgaWYgKGtleSAhPT0gXCIkcmVmXCIgJiYgUlVMRVMuYWxsW2tleV0pXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLnNjaGVtYUhhc1J1bGVzQnV0UmVmID0gc2NoZW1hSGFzUnVsZXNCdXRSZWY7XG5mdW5jdGlvbiBzY2hlbWFSZWZPclZhbCh7IHRvcFNjaGVtYVJlZiwgc2NoZW1hUGF0aCB9LCBzY2hlbWEsIGtleXdvcmQsICRkYXRhKSB7XG4gICAgaWYgKCEkZGF0YSkge1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcIm51bWJlclwiIHx8IHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpXG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuXykgYCR7c2NoZW1hfWA7XG4gICAgfVxuICAgIHJldHVybiAoMCwgY29kZWdlbl8xLl8pIGAke3RvcFNjaGVtYVJlZn0ke3NjaGVtYVBhdGh9JHsoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KShrZXl3b3JkKX1gO1xufVxuZXhwb3J0cy5zY2hlbWFSZWZPclZhbCA9IHNjaGVtYVJlZk9yVmFsO1xuZnVuY3Rpb24gdW5lc2NhcGVGcmFnbWVudChzdHIpIHtcbiAgICByZXR1cm4gdW5lc2NhcGVKc29uUG9pbnRlcihkZWNvZGVVUklDb21wb25lbnQoc3RyKSk7XG59XG5leHBvcnRzLnVuZXNjYXBlRnJhZ21lbnQgPSB1bmVzY2FwZUZyYWdtZW50O1xuZnVuY3Rpb24gZXNjYXBlRnJhZ21lbnQoc3RyKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChlc2NhcGVKc29uUG9pbnRlcihzdHIpKTtcbn1cbmV4cG9ydHMuZXNjYXBlRnJhZ21lbnQgPSBlc2NhcGVGcmFnbWVudDtcbmZ1bmN0aW9uIGVzY2FwZUpzb25Qb2ludGVyKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyID09IFwibnVtYmVyXCIpXG4gICAgICAgIHJldHVybiBgJHtzdHJ9YDtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL34vZywgXCJ+MFwiKS5yZXBsYWNlKC9cXC8vZywgXCJ+MVwiKTtcbn1cbmV4cG9ydHMuZXNjYXBlSnNvblBvaW50ZXIgPSBlc2NhcGVKc29uUG9pbnRlcjtcbmZ1bmN0aW9uIHVuZXNjYXBlSnNvblBvaW50ZXIoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9+MS9nLCBcIi9cIikucmVwbGFjZSgvfjAvZywgXCJ+XCIpO1xufVxuZXhwb3J0cy51bmVzY2FwZUpzb25Qb2ludGVyID0gdW5lc2NhcGVKc29uUG9pbnRlcjtcbmZ1bmN0aW9uIGVhY2hJdGVtKHhzLCBmKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoeHMpKSB7XG4gICAgICAgIGZvciAoY29uc3QgeCBvZiB4cylcbiAgICAgICAgICAgIGYoeCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmKHhzKTtcbiAgICB9XG59XG5leHBvcnRzLmVhY2hJdGVtID0gZWFjaEl0ZW07XG5mdW5jdGlvbiBtYWtlTWVyZ2VFdmFsdWF0ZWQoeyBtZXJnZU5hbWVzLCBtZXJnZVRvTmFtZSwgbWVyZ2VWYWx1ZXMsIHJlc3VsdFRvTmFtZSwgfSkge1xuICAgIHJldHVybiAoZ2VuLCBmcm9tLCB0bywgdG9OYW1lKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcyA9IHRvID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gZnJvbVxuICAgICAgICAgICAgOiB0byBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lXG4gICAgICAgICAgICAgICAgPyAoZnJvbSBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lID8gbWVyZ2VOYW1lcyhnZW4sIGZyb20sIHRvKSA6IG1lcmdlVG9OYW1lKGdlbiwgZnJvbSwgdG8pLCB0bylcbiAgICAgICAgICAgICAgICA6IGZyb20gaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZVxuICAgICAgICAgICAgICAgICAgICA/IChtZXJnZVRvTmFtZShnZW4sIHRvLCBmcm9tKSwgZnJvbSlcbiAgICAgICAgICAgICAgICAgICAgOiBtZXJnZVZhbHVlcyhmcm9tLCB0byk7XG4gICAgICAgIHJldHVybiB0b05hbWUgPT09IGNvZGVnZW5fMS5OYW1lICYmICEocmVzIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUpID8gcmVzdWx0VG9OYW1lKGdlbiwgcmVzKSA6IHJlcztcbiAgICB9O1xufVxuZXhwb3J0cy5tZXJnZUV2YWx1YXRlZCA9IHtcbiAgICBwcm9wczogbWFrZU1lcmdlRXZhbHVhdGVkKHtcbiAgICAgICAgbWVyZ2VOYW1lczogKGdlbiwgZnJvbSwgdG8pID0+IGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke3RvfSAhPT0gdHJ1ZSAmJiAke2Zyb219ICE9PSB1bmRlZmluZWRgLCAoKSA9PiB7XG4gICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtmcm9tfSA9PT0gdHJ1ZWAsICgpID0+IGdlbi5hc3NpZ24odG8sIHRydWUpLCAoKSA9PiBnZW4uYXNzaWduKHRvLCAoMCwgY29kZWdlbl8xLl8pIGAke3RvfSB8fCB7fWApLmNvZGUoKDAsIGNvZGVnZW5fMS5fKSBgT2JqZWN0LmFzc2lnbigke3RvfSwgJHtmcm9tfSlgKSk7XG4gICAgICAgIH0pLFxuICAgICAgICBtZXJnZVRvTmFtZTogKGdlbiwgZnJvbSwgdG8pID0+IGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke3RvfSAhPT0gdHJ1ZWAsICgpID0+IHtcbiAgICAgICAgICAgIGlmIChmcm9tID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih0bywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHRvLCAoMCwgY29kZWdlbl8xLl8pIGAke3RvfSB8fCB7fWApO1xuICAgICAgICAgICAgICAgIHNldEV2YWx1YXRlZChnZW4sIHRvLCBmcm9tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIG1lcmdlVmFsdWVzOiAoZnJvbSwgdG8pID0+IChmcm9tID09PSB0cnVlID8gdHJ1ZSA6IHsgLi4uZnJvbSwgLi4udG8gfSksXG4gICAgICAgIHJlc3VsdFRvTmFtZTogZXZhbHVhdGVkUHJvcHNUb05hbWUsXG4gICAgfSksXG4gICAgaXRlbXM6IG1ha2VNZXJnZUV2YWx1YXRlZCh7XG4gICAgICAgIG1lcmdlTmFtZXM6IChnZW4sIGZyb20sIHRvKSA9PiBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHt0b30gIT09IHRydWUgJiYgJHtmcm9tfSAhPT0gdW5kZWZpbmVkYCwgKCkgPT4gZ2VuLmFzc2lnbih0bywgKDAsIGNvZGVnZW5fMS5fKSBgJHtmcm9tfSA9PT0gdHJ1ZSA/IHRydWUgOiAke3RvfSA+ICR7ZnJvbX0gPyAke3RvfSA6ICR7ZnJvbX1gKSksXG4gICAgICAgIG1lcmdlVG9OYW1lOiAoZ2VuLCBmcm9tLCB0bykgPT4gZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7dG99ICE9PSB0cnVlYCwgKCkgPT4gZ2VuLmFzc2lnbih0bywgZnJvbSA9PT0gdHJ1ZSA/IHRydWUgOiAoMCwgY29kZWdlbl8xLl8pIGAke3RvfSA+ICR7ZnJvbX0gPyAke3RvfSA6ICR7ZnJvbX1gKSksXG4gICAgICAgIG1lcmdlVmFsdWVzOiAoZnJvbSwgdG8pID0+IChmcm9tID09PSB0cnVlID8gdHJ1ZSA6IE1hdGgubWF4KGZyb20sIHRvKSksXG4gICAgICAgIHJlc3VsdFRvTmFtZTogKGdlbiwgaXRlbXMpID0+IGdlbi52YXIoXCJpdGVtc1wiLCBpdGVtcyksXG4gICAgfSksXG59O1xuZnVuY3Rpb24gZXZhbHVhdGVkUHJvcHNUb05hbWUoZ2VuLCBwcykge1xuICAgIGlmIChwcyA9PT0gdHJ1ZSlcbiAgICAgICAgcmV0dXJuIGdlbi52YXIoXCJwcm9wc1wiLCB0cnVlKTtcbiAgICBjb25zdCBwcm9wcyA9IGdlbi52YXIoXCJwcm9wc1wiLCAoMCwgY29kZWdlbl8xLl8pIGB7fWApO1xuICAgIGlmIChwcyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICBzZXRFdmFsdWF0ZWQoZ2VuLCBwcm9wcywgcHMpO1xuICAgIHJldHVybiBwcm9wcztcbn1cbmV4cG9ydHMuZXZhbHVhdGVkUHJvcHNUb05hbWUgPSBldmFsdWF0ZWRQcm9wc1RvTmFtZTtcbmZ1bmN0aW9uIHNldEV2YWx1YXRlZChnZW4sIHByb3BzLCBwcykge1xuICAgIE9iamVjdC5rZXlzKHBzKS5mb3JFYWNoKChwKSA9PiBnZW4uYXNzaWduKCgwLCBjb2RlZ2VuXzEuXykgYCR7cHJvcHN9JHsoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KShwKX1gLCB0cnVlKSk7XG59XG5leHBvcnRzLnNldEV2YWx1YXRlZCA9IHNldEV2YWx1YXRlZDtcbmNvbnN0IHNuaXBwZXRzID0ge307XG5mdW5jdGlvbiB1c2VGdW5jKGdlbiwgZikge1xuICAgIHJldHVybiBnZW4uc2NvcGVWYWx1ZShcImZ1bmNcIiwge1xuICAgICAgICByZWY6IGYsXG4gICAgICAgIGNvZGU6IHNuaXBwZXRzW2YuY29kZV0gfHwgKHNuaXBwZXRzW2YuY29kZV0gPSBuZXcgY29kZV8xLl9Db2RlKGYuY29kZSkpLFxuICAgIH0pO1xufVxuZXhwb3J0cy51c2VGdW5jID0gdXNlRnVuYztcbnZhciBUeXBlO1xuKGZ1bmN0aW9uIChUeXBlKSB7XG4gICAgVHlwZVtUeXBlW1wiTnVtXCJdID0gMF0gPSBcIk51bVwiO1xuICAgIFR5cGVbVHlwZVtcIlN0clwiXSA9IDFdID0gXCJTdHJcIjtcbn0pKFR5cGUgfHwgKGV4cG9ydHMuVHlwZSA9IFR5cGUgPSB7fSkpO1xuZnVuY3Rpb24gZ2V0RXJyb3JQYXRoKGRhdGFQcm9wLCBkYXRhUHJvcFR5cGUsIGpzUHJvcGVydHlTeW50YXgpIHtcbiAgICAvLyBsZXQgcGF0aFxuICAgIGlmIChkYXRhUHJvcCBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lKSB7XG4gICAgICAgIGNvbnN0IGlzTnVtYmVyID0gZGF0YVByb3BUeXBlID09PSBUeXBlLk51bTtcbiAgICAgICAgcmV0dXJuIGpzUHJvcGVydHlTeW50YXhcbiAgICAgICAgICAgID8gaXNOdW1iZXJcbiAgICAgICAgICAgICAgICA/ICgwLCBjb2RlZ2VuXzEuXykgYFwiW1wiICsgJHtkYXRhUHJvcH0gKyBcIl1cImBcbiAgICAgICAgICAgICAgICA6ICgwLCBjb2RlZ2VuXzEuXykgYFwiWydcIiArICR7ZGF0YVByb3B9ICsgXCInXVwiYFxuICAgICAgICAgICAgOiBpc051bWJlclxuICAgICAgICAgICAgICAgID8gKDAsIGNvZGVnZW5fMS5fKSBgXCIvXCIgKyAke2RhdGFQcm9wfWBcbiAgICAgICAgICAgICAgICA6ICgwLCBjb2RlZ2VuXzEuXykgYFwiL1wiICsgJHtkYXRhUHJvcH0ucmVwbGFjZSgvfi9nLCBcIn4wXCIpLnJlcGxhY2UoL1xcXFwvL2csIFwifjFcIilgOyAvLyBUT0RPIG1heWJlIHVzZSBnbG9iYWwgZXNjYXBlUG9pbnRlclxuICAgIH1cbiAgICByZXR1cm4ganNQcm9wZXJ0eVN5bnRheCA/ICgwLCBjb2RlZ2VuXzEuZ2V0UHJvcGVydHkpKGRhdGFQcm9wKS50b1N0cmluZygpIDogXCIvXCIgKyBlc2NhcGVKc29uUG9pbnRlcihkYXRhUHJvcCk7XG59XG5leHBvcnRzLmdldEVycm9yUGF0aCA9IGdldEVycm9yUGF0aDtcbmZ1bmN0aW9uIGNoZWNrU3RyaWN0TW9kZShpdCwgbXNnLCBtb2RlID0gaXQub3B0cy5zdHJpY3RTY2hlbWEpIHtcbiAgICBpZiAoIW1vZGUpXG4gICAgICAgIHJldHVybjtcbiAgICBtc2cgPSBgc3RyaWN0IG1vZGU6ICR7bXNnfWA7XG4gICAgaWYgKG1vZGUgPT09IHRydWUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIGl0LnNlbGYubG9nZ2VyLndhcm4obXNnKTtcbn1cbmV4cG9ydHMuY2hlY2tTdHJpY3RNb2RlID0gY2hlY2tTdHJpY3RNb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuL2NvZGVnZW5cIik7XG5jb25zdCBuYW1lcyA9IHtcbiAgICAvLyB2YWxpZGF0aW9uIGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgIGRhdGE6IG5ldyBjb2RlZ2VuXzEuTmFtZShcImRhdGFcIiksIC8vIGRhdGEgcGFzc2VkIHRvIHZhbGlkYXRpb24gZnVuY3Rpb25cbiAgICAvLyBhcmdzIHBhc3NlZCBmcm9tIHJlZmVyZW5jaW5nIHNjaGVtYVxuICAgIHZhbEN4dDogbmV3IGNvZGVnZW5fMS5OYW1lKFwidmFsQ3h0XCIpLCAvLyB2YWxpZGF0aW9uL2RhdGEgY29udGV4dCAtIHNob3VsZCBub3QgYmUgdXNlZCBkaXJlY3RseSwgaXQgaXMgZGVzdHJ1Y3R1cmVkIHRvIHRoZSBuYW1lcyBiZWxvd1xuICAgIGluc3RhbmNlUGF0aDogbmV3IGNvZGVnZW5fMS5OYW1lKFwiaW5zdGFuY2VQYXRoXCIpLFxuICAgIHBhcmVudERhdGE6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInBhcmVudERhdGFcIiksXG4gICAgcGFyZW50RGF0YVByb3BlcnR5OiBuZXcgY29kZWdlbl8xLk5hbWUoXCJwYXJlbnREYXRhUHJvcGVydHlcIiksXG4gICAgcm9vdERhdGE6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInJvb3REYXRhXCIpLCAvLyByb290IGRhdGEgLSBzYW1lIGFzIHRoZSBkYXRhIHBhc3NlZCB0byB0aGUgZmlyc3QvdG9wIHZhbGlkYXRpb24gZnVuY3Rpb25cbiAgICBkeW5hbWljQW5jaG9yczogbmV3IGNvZGVnZW5fMS5OYW1lKFwiZHluYW1pY0FuY2hvcnNcIiksIC8vIHVzZWQgdG8gc3VwcG9ydCByZWN1cnNpdmVSZWYgYW5kIGR5bmFtaWNSZWZcbiAgICAvLyBmdW5jdGlvbiBzY29wZWQgdmFyaWFibGVzXG4gICAgdkVycm9yczogbmV3IGNvZGVnZW5fMS5OYW1lKFwidkVycm9yc1wiKSwgLy8gbnVsbCBvciBhcnJheSBvZiB2YWxpZGF0aW9uIGVycm9yc1xuICAgIGVycm9yczogbmV3IGNvZGVnZW5fMS5OYW1lKFwiZXJyb3JzXCIpLCAvLyBjb3VudGVyIG9mIHZhbGlkYXRpb24gZXJyb3JzXG4gICAgdGhpczogbmV3IGNvZGVnZW5fMS5OYW1lKFwidGhpc1wiKSxcbiAgICAvLyBcImdsb2JhbHNcIlxuICAgIHNlbGY6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInNlbGZcIiksXG4gICAgc2NvcGU6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInNjb3BlXCIpLFxuICAgIC8vIEpURCBzZXJpYWxpemUvcGFyc2UgbmFtZSBmb3IgSlNPTiBzdHJpbmcgYW5kIHBvc2l0aW9uXG4gICAganNvbjogbmV3IGNvZGVnZW5fMS5OYW1lKFwianNvblwiKSxcbiAgICBqc29uUG9zOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJqc29uUG9zXCIpLFxuICAgIGpzb25MZW46IG5ldyBjb2RlZ2VuXzEuTmFtZShcImpzb25MZW5cIiksXG4gICAganNvblBhcnQ6IG5ldyBjb2RlZ2VuXzEuTmFtZShcImpzb25QYXJ0XCIpLFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IG5hbWVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmFtZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmV4dGVuZEVycm9ycyA9IGV4cG9ydHMucmVzZXRFcnJvcnNDb3VudCA9IGV4cG9ydHMucmVwb3J0RXh0cmFFcnJvciA9IGV4cG9ydHMucmVwb3J0RXJyb3IgPSBleHBvcnRzLmtleXdvcmQkRGF0YUVycm9yID0gZXhwb3J0cy5rZXl3b3JkRXJyb3IgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbmNvbnN0IG5hbWVzXzEgPSByZXF1aXJlKFwiLi9uYW1lc1wiKTtcbmV4cG9ydHMua2V5d29yZEVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IGtleXdvcmQgfSkgPT4gKDAsIGNvZGVnZW5fMS5zdHIpIGBtdXN0IHBhc3MgXCIke2tleXdvcmR9XCIga2V5d29yZCB2YWxpZGF0aW9uYCxcbn07XG5leHBvcnRzLmtleXdvcmQkRGF0YUVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IGtleXdvcmQsIHNjaGVtYVR5cGUgfSkgPT4gc2NoZW1hVHlwZVxuICAgICAgICA/ICgwLCBjb2RlZ2VuXzEuc3RyKSBgXCIke2tleXdvcmR9XCIga2V5d29yZCBtdXN0IGJlICR7c2NoZW1hVHlwZX0gKCRkYXRhKWBcbiAgICAgICAgOiAoMCwgY29kZWdlbl8xLnN0cikgYFwiJHtrZXl3b3JkfVwiIGtleXdvcmQgaXMgaW52YWxpZCAoJGRhdGEpYCxcbn07XG5mdW5jdGlvbiByZXBvcnRFcnJvcihjeHQsIGVycm9yID0gZXhwb3J0cy5rZXl3b3JkRXJyb3IsIGVycm9yUGF0aHMsIG92ZXJyaWRlQWxsRXJyb3JzKSB7XG4gICAgY29uc3QgeyBpdCB9ID0gY3h0O1xuICAgIGNvbnN0IHsgZ2VuLCBjb21wb3NpdGVSdWxlLCBhbGxFcnJvcnMgfSA9IGl0O1xuICAgIGNvbnN0IGVyck9iaiA9IGVycm9yT2JqZWN0Q29kZShjeHQsIGVycm9yLCBlcnJvclBhdGhzKTtcbiAgICBpZiAob3ZlcnJpZGVBbGxFcnJvcnMgIT09IG51bGwgJiYgb3ZlcnJpZGVBbGxFcnJvcnMgIT09IHZvaWQgMCA/IG92ZXJyaWRlQWxsRXJyb3JzIDogKGNvbXBvc2l0ZVJ1bGUgfHwgYWxsRXJyb3JzKSkge1xuICAgICAgICBhZGRFcnJvcihnZW4sIGVyck9iaik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm5FcnJvcnMoaXQsICgwLCBjb2RlZ2VuXzEuXykgYFske2Vyck9ian1dYCk7XG4gICAgfVxufVxuZXhwb3J0cy5yZXBvcnRFcnJvciA9IHJlcG9ydEVycm9yO1xuZnVuY3Rpb24gcmVwb3J0RXh0cmFFcnJvcihjeHQsIGVycm9yID0gZXhwb3J0cy5rZXl3b3JkRXJyb3IsIGVycm9yUGF0aHMpIHtcbiAgICBjb25zdCB7IGl0IH0gPSBjeHQ7XG4gICAgY29uc3QgeyBnZW4sIGNvbXBvc2l0ZVJ1bGUsIGFsbEVycm9ycyB9ID0gaXQ7XG4gICAgY29uc3QgZXJyT2JqID0gZXJyb3JPYmplY3RDb2RlKGN4dCwgZXJyb3IsIGVycm9yUGF0aHMpO1xuICAgIGFkZEVycm9yKGdlbiwgZXJyT2JqKTtcbiAgICBpZiAoIShjb21wb3NpdGVSdWxlIHx8IGFsbEVycm9ycykpIHtcbiAgICAgICAgcmV0dXJuRXJyb3JzKGl0LCBuYW1lc18xLmRlZmF1bHQudkVycm9ycyk7XG4gICAgfVxufVxuZXhwb3J0cy5yZXBvcnRFeHRyYUVycm9yID0gcmVwb3J0RXh0cmFFcnJvcjtcbmZ1bmN0aW9uIHJlc2V0RXJyb3JzQ291bnQoZ2VuLCBlcnJzQ291bnQpIHtcbiAgICBnZW4uYXNzaWduKG5hbWVzXzEuZGVmYXVsdC5lcnJvcnMsIGVycnNDb3VudCk7XG4gICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9ICE9PSBudWxsYCwgKCkgPT4gZ2VuLmlmKGVycnNDb3VudCwgKCkgPT4gZ2VuLmFzc2lnbigoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfS5sZW5ndGhgLCBlcnJzQ291bnQpLCAoKSA9PiBnZW4uYXNzaWduKG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzLCBudWxsKSkpO1xufVxuZXhwb3J0cy5yZXNldEVycm9yc0NvdW50ID0gcmVzZXRFcnJvcnNDb3VudDtcbmZ1bmN0aW9uIGV4dGVuZEVycm9ycyh7IGdlbiwga2V5d29yZCwgc2NoZW1hVmFsdWUsIGRhdGEsIGVycnNDb3VudCwgaXQsIH0pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoZXJyc0NvdW50ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImFqdiBpbXBsZW1lbnRhdGlvbiBlcnJvclwiKTtcbiAgICBjb25zdCBlcnIgPSBnZW4ubmFtZShcImVyclwiKTtcbiAgICBnZW4uZm9yUmFuZ2UoXCJpXCIsIGVycnNDb3VudCwgbmFtZXNfMS5kZWZhdWx0LmVycm9ycywgKGkpID0+IHtcbiAgICAgICAgZ2VuLmNvbnN0KGVyciwgKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc31bJHtpfV1gKTtcbiAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZXJyfS5pbnN0YW5jZVBhdGggPT09IHVuZGVmaW5lZGAsICgpID0+IGdlbi5hc3NpZ24oKDAsIGNvZGVnZW5fMS5fKSBgJHtlcnJ9Lmluc3RhbmNlUGF0aGAsICgwLCBjb2RlZ2VuXzEuc3RyQ29uY2F0KShuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRoLCBpdC5lcnJvclBhdGgpKSk7XG4gICAgICAgIGdlbi5hc3NpZ24oKDAsIGNvZGVnZW5fMS5fKSBgJHtlcnJ9LnNjaGVtYVBhdGhgLCAoMCwgY29kZWdlbl8xLnN0cikgYCR7aXQuZXJyU2NoZW1hUGF0aH0vJHtrZXl3b3JkfWApO1xuICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgICAgICBnZW4uYXNzaWduKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZXJyfS5zY2hlbWFgLCBzY2hlbWFWYWx1ZSk7XG4gICAgICAgICAgICBnZW4uYXNzaWduKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZXJyfS5kYXRhYCwgZGF0YSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuZXh0ZW5kRXJyb3JzID0gZXh0ZW5kRXJyb3JzO1xuZnVuY3Rpb24gYWRkRXJyb3IoZ2VuLCBlcnJPYmopIHtcbiAgICBjb25zdCBlcnIgPSBnZW4uY29uc3QoXCJlcnJcIiwgZXJyT2JqKTtcbiAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30gPT09IG51bGxgLCAoKSA9PiBnZW4uYXNzaWduKG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzLCAoMCwgY29kZWdlbl8xLl8pIGBbJHtlcnJ9XWApLCAoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfS5wdXNoKCR7ZXJyfSlgKTtcbiAgICBnZW4uY29kZSgoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC5lcnJvcnN9KytgKTtcbn1cbmZ1bmN0aW9uIHJldHVybkVycm9ycyhpdCwgZXJycykge1xuICAgIGNvbnN0IHsgZ2VuLCB2YWxpZGF0ZU5hbWUsIHNjaGVtYUVudiB9ID0gaXQ7XG4gICAgaWYgKHNjaGVtYUVudi4kYXN5bmMpIHtcbiAgICAgICAgZ2VuLnRocm93KCgwLCBjb2RlZ2VuXzEuXykgYG5ldyAke2l0LlZhbGlkYXRpb25FcnJvcn0oJHtlcnJzfSlgKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdlbi5hc3NpZ24oKDAsIGNvZGVnZW5fMS5fKSBgJHt2YWxpZGF0ZU5hbWV9LmVycm9yc2AsIGVycnMpO1xuICAgICAgICBnZW4ucmV0dXJuKGZhbHNlKTtcbiAgICB9XG59XG5jb25zdCBFID0ge1xuICAgIGtleXdvcmQ6IG5ldyBjb2RlZ2VuXzEuTmFtZShcImtleXdvcmRcIiksXG4gICAgc2NoZW1hUGF0aDogbmV3IGNvZGVnZW5fMS5OYW1lKFwic2NoZW1hUGF0aFwiKSwgLy8gYWxzbyB1c2VkIGluIEpURCBlcnJvcnNcbiAgICBwYXJhbXM6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInBhcmFtc1wiKSxcbiAgICBwcm9wZXJ0eU5hbWU6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInByb3BlcnR5TmFtZVwiKSxcbiAgICBtZXNzYWdlOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJtZXNzYWdlXCIpLFxuICAgIHNjaGVtYTogbmV3IGNvZGVnZW5fMS5OYW1lKFwic2NoZW1hXCIpLFxuICAgIHBhcmVudFNjaGVtYTogbmV3IGNvZGVnZW5fMS5OYW1lKFwicGFyZW50U2NoZW1hXCIpLFxufTtcbmZ1bmN0aW9uIGVycm9yT2JqZWN0Q29kZShjeHQsIGVycm9yLCBlcnJvclBhdGhzKSB7XG4gICAgY29uc3QgeyBjcmVhdGVFcnJvcnMgfSA9IGN4dC5pdDtcbiAgICBpZiAoY3JlYXRlRXJyb3JzID09PSBmYWxzZSlcbiAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuXykgYHt9YDtcbiAgICByZXR1cm4gZXJyb3JPYmplY3QoY3h0LCBlcnJvciwgZXJyb3JQYXRocyk7XG59XG5mdW5jdGlvbiBlcnJvck9iamVjdChjeHQsIGVycm9yLCBlcnJvclBhdGhzID0ge30pIHtcbiAgICBjb25zdCB7IGdlbiwgaXQgfSA9IGN4dDtcbiAgICBjb25zdCBrZXlWYWx1ZXMgPSBbXG4gICAgICAgIGVycm9ySW5zdGFuY2VQYXRoKGl0LCBlcnJvclBhdGhzKSxcbiAgICAgICAgZXJyb3JTY2hlbWFQYXRoKGN4dCwgZXJyb3JQYXRocyksXG4gICAgXTtcbiAgICBleHRyYUVycm9yUHJvcHMoY3h0LCBlcnJvciwga2V5VmFsdWVzKTtcbiAgICByZXR1cm4gZ2VuLm9iamVjdCguLi5rZXlWYWx1ZXMpO1xufVxuZnVuY3Rpb24gZXJyb3JJbnN0YW5jZVBhdGgoeyBlcnJvclBhdGggfSwgeyBpbnN0YW5jZVBhdGggfSkge1xuICAgIGNvbnN0IGluc3RQYXRoID0gaW5zdGFuY2VQYXRoXG4gICAgICAgID8gKDAsIGNvZGVnZW5fMS5zdHIpIGAke2Vycm9yUGF0aH0keygwLCB1dGlsXzEuZ2V0RXJyb3JQYXRoKShpbnN0YW5jZVBhdGgsIHV0aWxfMS5UeXBlLlN0cil9YFxuICAgICAgICA6IGVycm9yUGF0aDtcbiAgICByZXR1cm4gW25hbWVzXzEuZGVmYXVsdC5pbnN0YW5jZVBhdGgsICgwLCBjb2RlZ2VuXzEuc3RyQ29uY2F0KShuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRoLCBpbnN0UGF0aCldO1xufVxuZnVuY3Rpb24gZXJyb3JTY2hlbWFQYXRoKHsga2V5d29yZCwgaXQ6IHsgZXJyU2NoZW1hUGF0aCB9IH0sIHsgc2NoZW1hUGF0aCwgcGFyZW50U2NoZW1hIH0pIHtcbiAgICBsZXQgc2NoUGF0aCA9IHBhcmVudFNjaGVtYSA/IGVyclNjaGVtYVBhdGggOiAoMCwgY29kZWdlbl8xLnN0cikgYCR7ZXJyU2NoZW1hUGF0aH0vJHtrZXl3b3JkfWA7XG4gICAgaWYgKHNjaGVtYVBhdGgpIHtcbiAgICAgICAgc2NoUGF0aCA9ICgwLCBjb2RlZ2VuXzEuc3RyKSBgJHtzY2hQYXRofSR7KDAsIHV0aWxfMS5nZXRFcnJvclBhdGgpKHNjaGVtYVBhdGgsIHV0aWxfMS5UeXBlLlN0cil9YDtcbiAgICB9XG4gICAgcmV0dXJuIFtFLnNjaGVtYVBhdGgsIHNjaFBhdGhdO1xufVxuZnVuY3Rpb24gZXh0cmFFcnJvclByb3BzKGN4dCwgeyBwYXJhbXMsIG1lc3NhZ2UgfSwga2V5VmFsdWVzKSB7XG4gICAgY29uc3QgeyBrZXl3b3JkLCBkYXRhLCBzY2hlbWFWYWx1ZSwgaXQgfSA9IGN4dDtcbiAgICBjb25zdCB7IG9wdHMsIHByb3BlcnR5TmFtZSwgdG9wU2NoZW1hUmVmLCBzY2hlbWFQYXRoIH0gPSBpdDtcbiAgICBrZXlWYWx1ZXMucHVzaChbRS5rZXl3b3JkLCBrZXl3b3JkXSwgW0UucGFyYW1zLCB0eXBlb2YgcGFyYW1zID09IFwiZnVuY3Rpb25cIiA/IHBhcmFtcyhjeHQpIDogcGFyYW1zIHx8ICgwLCBjb2RlZ2VuXzEuXykgYHt9YF0pO1xuICAgIGlmIChvcHRzLm1lc3NhZ2VzKSB7XG4gICAgICAgIGtleVZhbHVlcy5wdXNoKFtFLm1lc3NhZ2UsIHR5cGVvZiBtZXNzYWdlID09IFwiZnVuY3Rpb25cIiA/IG1lc3NhZ2UoY3h0KSA6IG1lc3NhZ2VdKTtcbiAgICB9XG4gICAgaWYgKG9wdHMudmVyYm9zZSkge1xuICAgICAgICBrZXlWYWx1ZXMucHVzaChbRS5zY2hlbWEsIHNjaGVtYVZhbHVlXSwgW0UucGFyZW50U2NoZW1hLCAoMCwgY29kZWdlbl8xLl8pIGAke3RvcFNjaGVtYVJlZn0ke3NjaGVtYVBhdGh9YF0sIFtuYW1lc18xLmRlZmF1bHQuZGF0YSwgZGF0YV0pO1xuICAgIH1cbiAgICBpZiAocHJvcGVydHlOYW1lKVxuICAgICAgICBrZXlWYWx1ZXMucHVzaChbRS5wcm9wZXJ0eU5hbWUsIHByb3BlcnR5TmFtZV0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ib29sT3JFbXB0eVNjaGVtYSA9IGV4cG9ydHMudG9wQm9vbE9yRW1wdHlTY2hlbWEgPSB2b2lkIDA7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuLi9lcnJvcnNcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vY29kZWdlblwiKTtcbmNvbnN0IG5hbWVzXzEgPSByZXF1aXJlKFwiLi4vbmFtZXNcIik7XG5jb25zdCBib29sRXJyb3IgPSB7XG4gICAgbWVzc2FnZTogXCJib29sZWFuIHNjaGVtYSBpcyBmYWxzZVwiLFxufTtcbmZ1bmN0aW9uIHRvcEJvb2xPckVtcHR5U2NoZW1hKGl0KSB7XG4gICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgdmFsaWRhdGVOYW1lIH0gPSBpdDtcbiAgICBpZiAoc2NoZW1hID09PSBmYWxzZSkge1xuICAgICAgICBmYWxzZVNjaGVtYUVycm9yKGl0LCBmYWxzZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIiAmJiBzY2hlbWEuJGFzeW5jID09PSB0cnVlKSB7XG4gICAgICAgIGdlbi5yZXR1cm4obmFtZXNfMS5kZWZhdWx0LmRhdGEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2VuLmFzc2lnbigoMCwgY29kZWdlbl8xLl8pIGAke3ZhbGlkYXRlTmFtZX0uZXJyb3JzYCwgbnVsbCk7XG4gICAgICAgIGdlbi5yZXR1cm4odHJ1ZSk7XG4gICAgfVxufVxuZXhwb3J0cy50b3BCb29sT3JFbXB0eVNjaGVtYSA9IHRvcEJvb2xPckVtcHR5U2NoZW1hO1xuZnVuY3Rpb24gYm9vbE9yRW1wdHlTY2hlbWEoaXQsIHZhbGlkKSB7XG4gICAgY29uc3QgeyBnZW4sIHNjaGVtYSB9ID0gaXQ7XG4gICAgaWYgKHNjaGVtYSA9PT0gZmFsc2UpIHtcbiAgICAgICAgZ2VuLnZhcih2YWxpZCwgZmFsc2UpOyAvLyBUT0RPIHZhclxuICAgICAgICBmYWxzZVNjaGVtYUVycm9yKGl0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdlbi52YXIodmFsaWQsIHRydWUpOyAvLyBUT0RPIHZhclxuICAgIH1cbn1cbmV4cG9ydHMuYm9vbE9yRW1wdHlTY2hlbWEgPSBib29sT3JFbXB0eVNjaGVtYTtcbmZ1bmN0aW9uIGZhbHNlU2NoZW1hRXJyb3IoaXQsIG92ZXJyaWRlQWxsRXJyb3JzKSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEgfSA9IGl0O1xuICAgIC8vIFRPRE8gbWF5YmUgc29tZSBvdGhlciBpbnRlcmZhY2Ugc2hvdWxkIGJlIHVzZWQgZm9yIG5vbi1rZXl3b3JkIHZhbGlkYXRpb24gZXJyb3JzLi4uXG4gICAgY29uc3QgY3h0ID0ge1xuICAgICAgICBnZW4sXG4gICAgICAgIGtleXdvcmQ6IFwiZmFsc2Ugc2NoZW1hXCIsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIHNjaGVtYTogZmFsc2UsXG4gICAgICAgIHNjaGVtYUNvZGU6IGZhbHNlLFxuICAgICAgICBzY2hlbWFWYWx1ZTogZmFsc2UsXG4gICAgICAgIHBhcmFtczoge30sXG4gICAgICAgIGl0LFxuICAgIH07XG4gICAgKDAsIGVycm9yc18xLnJlcG9ydEVycm9yKShjeHQsIGJvb2xFcnJvciwgdW5kZWZpbmVkLCBvdmVycmlkZUFsbEVycm9ycyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ib29sU2NoZW1hLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRSdWxlcyA9IGV4cG9ydHMuaXNKU09OVHlwZSA9IHZvaWQgMDtcbmNvbnN0IF9qc29uVHlwZXMgPSBbXCJzdHJpbmdcIiwgXCJudW1iZXJcIiwgXCJpbnRlZ2VyXCIsIFwiYm9vbGVhblwiLCBcIm51bGxcIiwgXCJvYmplY3RcIiwgXCJhcnJheVwiXTtcbmNvbnN0IGpzb25UeXBlcyA9IG5ldyBTZXQoX2pzb25UeXBlcyk7XG5mdW5jdGlvbiBpc0pTT05UeXBlKHgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHggPT0gXCJzdHJpbmdcIiAmJiBqc29uVHlwZXMuaGFzKHgpO1xufVxuZXhwb3J0cy5pc0pTT05UeXBlID0gaXNKU09OVHlwZTtcbmZ1bmN0aW9uIGdldFJ1bGVzKCkge1xuICAgIGNvbnN0IGdyb3VwcyA9IHtcbiAgICAgICAgbnVtYmVyOiB7IHR5cGU6IFwibnVtYmVyXCIsIHJ1bGVzOiBbXSB9LFxuICAgICAgICBzdHJpbmc6IHsgdHlwZTogXCJzdHJpbmdcIiwgcnVsZXM6IFtdIH0sXG4gICAgICAgIGFycmF5OiB7IHR5cGU6IFwiYXJyYXlcIiwgcnVsZXM6IFtdIH0sXG4gICAgICAgIG9iamVjdDogeyB0eXBlOiBcIm9iamVjdFwiLCBydWxlczogW10gfSxcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGVzOiB7IC4uLmdyb3VwcywgaW50ZWdlcjogdHJ1ZSwgYm9vbGVhbjogdHJ1ZSwgbnVsbDogdHJ1ZSB9LFxuICAgICAgICBydWxlczogW3sgcnVsZXM6IFtdIH0sIGdyb3Vwcy5udW1iZXIsIGdyb3Vwcy5zdHJpbmcsIGdyb3Vwcy5hcnJheSwgZ3JvdXBzLm9iamVjdF0sXG4gICAgICAgIHBvc3Q6IHsgcnVsZXM6IFtdIH0sXG4gICAgICAgIGFsbDoge30sXG4gICAgICAgIGtleXdvcmRzOiB7fSxcbiAgICB9O1xufVxuZXhwb3J0cy5nZXRSdWxlcyA9IGdldFJ1bGVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cnVsZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNob3VsZFVzZVJ1bGUgPSBleHBvcnRzLnNob3VsZFVzZUdyb3VwID0gZXhwb3J0cy5zY2hlbWFIYXNSdWxlc0ZvclR5cGUgPSB2b2lkIDA7XG5mdW5jdGlvbiBzY2hlbWFIYXNSdWxlc0ZvclR5cGUoeyBzY2hlbWEsIHNlbGYgfSwgdHlwZSkge1xuICAgIGNvbnN0IGdyb3VwID0gc2VsZi5SVUxFUy50eXBlc1t0eXBlXTtcbiAgICByZXR1cm4gZ3JvdXAgJiYgZ3JvdXAgIT09IHRydWUgJiYgc2hvdWxkVXNlR3JvdXAoc2NoZW1hLCBncm91cCk7XG59XG5leHBvcnRzLnNjaGVtYUhhc1J1bGVzRm9yVHlwZSA9IHNjaGVtYUhhc1J1bGVzRm9yVHlwZTtcbmZ1bmN0aW9uIHNob3VsZFVzZUdyb3VwKHNjaGVtYSwgZ3JvdXApIHtcbiAgICByZXR1cm4gZ3JvdXAucnVsZXMuc29tZSgocnVsZSkgPT4gc2hvdWxkVXNlUnVsZShzY2hlbWEsIHJ1bGUpKTtcbn1cbmV4cG9ydHMuc2hvdWxkVXNlR3JvdXAgPSBzaG91bGRVc2VHcm91cDtcbmZ1bmN0aW9uIHNob3VsZFVzZVJ1bGUoc2NoZW1hLCBydWxlKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoc2NoZW1hW3J1bGUua2V5d29yZF0gIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAoKF9hID0gcnVsZS5kZWZpbml0aW9uLmltcGxlbWVudHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zb21lKChrd2QpID0+IHNjaGVtYVtrd2RdICE9PSB1bmRlZmluZWQpKSk7XG59XG5leHBvcnRzLnNob3VsZFVzZVJ1bGUgPSBzaG91bGRVc2VSdWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwbGljYWJpbGl0eS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVwb3J0VHlwZUVycm9yID0gZXhwb3J0cy5jaGVja0RhdGFUeXBlcyA9IGV4cG9ydHMuY2hlY2tEYXRhVHlwZSA9IGV4cG9ydHMuY29lcmNlQW5kQ2hlY2tEYXRhVHlwZSA9IGV4cG9ydHMuZ2V0SlNPTlR5cGVzID0gZXhwb3J0cy5nZXRTY2hlbWFUeXBlcyA9IGV4cG9ydHMuRGF0YVR5cGUgPSB2b2lkIDA7XG5jb25zdCBydWxlc18xID0gcmVxdWlyZShcIi4uL3J1bGVzXCIpO1xuY29uc3QgYXBwbGljYWJpbGl0eV8xID0gcmVxdWlyZShcIi4vYXBwbGljYWJpbGl0eVwiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgRGF0YVR5cGU7XG4oZnVuY3Rpb24gKERhdGFUeXBlKSB7XG4gICAgRGF0YVR5cGVbRGF0YVR5cGVbXCJDb3JyZWN0XCJdID0gMF0gPSBcIkNvcnJlY3RcIjtcbiAgICBEYXRhVHlwZVtEYXRhVHlwZVtcIldyb25nXCJdID0gMV0gPSBcIldyb25nXCI7XG59KShEYXRhVHlwZSB8fCAoZXhwb3J0cy5EYXRhVHlwZSA9IERhdGFUeXBlID0ge30pKTtcbmZ1bmN0aW9uIGdldFNjaGVtYVR5cGVzKHNjaGVtYSkge1xuICAgIGNvbnN0IHR5cGVzID0gZ2V0SlNPTlR5cGVzKHNjaGVtYS50eXBlKTtcbiAgICBjb25zdCBoYXNOdWxsID0gdHlwZXMuaW5jbHVkZXMoXCJudWxsXCIpO1xuICAgIGlmIChoYXNOdWxsKSB7XG4gICAgICAgIGlmIChzY2hlbWEubnVsbGFibGUgPT09IGZhbHNlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHlwZTogbnVsbCBjb250cmFkaWN0cyBudWxsYWJsZTogZmFsc2VcIik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoIXR5cGVzLmxlbmd0aCAmJiBzY2hlbWEubnVsbGFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIm51bGxhYmxlXCIgY2Fubm90IGJlIHVzZWQgd2l0aG91dCBcInR5cGVcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWEubnVsbGFibGUgPT09IHRydWUpXG4gICAgICAgICAgICB0eXBlcy5wdXNoKFwibnVsbFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVzO1xufVxuZXhwb3J0cy5nZXRTY2hlbWFUeXBlcyA9IGdldFNjaGVtYVR5cGVzO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZWR1bmRhbnQtdHlwZS1jb25zdGl0dWVudHNcbmZ1bmN0aW9uIGdldEpTT05UeXBlcyh0cykge1xuICAgIGNvbnN0IHR5cGVzID0gQXJyYXkuaXNBcnJheSh0cykgPyB0cyA6IHRzID8gW3RzXSA6IFtdO1xuICAgIGlmICh0eXBlcy5ldmVyeShydWxlc18xLmlzSlNPTlR5cGUpKVxuICAgICAgICByZXR1cm4gdHlwZXM7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidHlwZSBtdXN0IGJlIEpTT05UeXBlIG9yIEpTT05UeXBlW106IFwiICsgdHlwZXMuam9pbihcIixcIikpO1xufVxuZXhwb3J0cy5nZXRKU09OVHlwZXMgPSBnZXRKU09OVHlwZXM7XG5mdW5jdGlvbiBjb2VyY2VBbmRDaGVja0RhdGFUeXBlKGl0LCB0eXBlcykge1xuICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBvcHRzIH0gPSBpdDtcbiAgICBjb25zdCBjb2VyY2VUbyA9IGNvZXJjZVRvVHlwZXModHlwZXMsIG9wdHMuY29lcmNlVHlwZXMpO1xuICAgIGNvbnN0IGNoZWNrVHlwZXMgPSB0eXBlcy5sZW5ndGggPiAwICYmXG4gICAgICAgICEoY29lcmNlVG8ubGVuZ3RoID09PSAwICYmIHR5cGVzLmxlbmd0aCA9PT0gMSAmJiAoMCwgYXBwbGljYWJpbGl0eV8xLnNjaGVtYUhhc1J1bGVzRm9yVHlwZSkoaXQsIHR5cGVzWzBdKSk7XG4gICAgaWYgKGNoZWNrVHlwZXMpIHtcbiAgICAgICAgY29uc3Qgd3JvbmdUeXBlID0gY2hlY2tEYXRhVHlwZXModHlwZXMsIGRhdGEsIG9wdHMuc3RyaWN0TnVtYmVycywgRGF0YVR5cGUuV3JvbmcpO1xuICAgICAgICBnZW4uaWYod3JvbmdUeXBlLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoY29lcmNlVG8ubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGNvZXJjZURhdGEoaXQsIHR5cGVzLCBjb2VyY2VUbyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmVwb3J0VHlwZUVycm9yKGl0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjaGVja1R5cGVzO1xufVxuZXhwb3J0cy5jb2VyY2VBbmRDaGVja0RhdGFUeXBlID0gY29lcmNlQW5kQ2hlY2tEYXRhVHlwZTtcbmNvbnN0IENPRVJDSUJMRSA9IG5ldyBTZXQoW1wic3RyaW5nXCIsIFwibnVtYmVyXCIsIFwiaW50ZWdlclwiLCBcImJvb2xlYW5cIiwgXCJudWxsXCJdKTtcbmZ1bmN0aW9uIGNvZXJjZVRvVHlwZXModHlwZXMsIGNvZXJjZVR5cGVzKSB7XG4gICAgcmV0dXJuIGNvZXJjZVR5cGVzXG4gICAgICAgID8gdHlwZXMuZmlsdGVyKCh0KSA9PiBDT0VSQ0lCTEUuaGFzKHQpIHx8IChjb2VyY2VUeXBlcyA9PT0gXCJhcnJheVwiICYmIHQgPT09IFwiYXJyYXlcIikpXG4gICAgICAgIDogW107XG59XG5mdW5jdGlvbiBjb2VyY2VEYXRhKGl0LCB0eXBlcywgY29lcmNlVG8pIHtcbiAgICBjb25zdCB7IGdlbiwgZGF0YSwgb3B0cyB9ID0gaXQ7XG4gICAgY29uc3QgZGF0YVR5cGUgPSBnZW4ubGV0KFwiZGF0YVR5cGVcIiwgKDAsIGNvZGVnZW5fMS5fKSBgdHlwZW9mICR7ZGF0YX1gKTtcbiAgICBjb25zdCBjb2VyY2VkID0gZ2VuLmxldChcImNvZXJjZWRcIiwgKDAsIGNvZGVnZW5fMS5fKSBgdW5kZWZpbmVkYCk7XG4gICAgaWYgKG9wdHMuY29lcmNlVHlwZXMgPT09IFwiYXJyYXlcIikge1xuICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhVHlwZX0gPT0gJ29iamVjdCcgJiYgQXJyYXkuaXNBcnJheSgke2RhdGF9KSAmJiAke2RhdGF9Lmxlbmd0aCA9PSAxYCwgKCkgPT4gZ2VuXG4gICAgICAgICAgICAuYXNzaWduKGRhdGEsICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX1bMF1gKVxuICAgICAgICAgICAgLmFzc2lnbihkYXRhVHlwZSwgKDAsIGNvZGVnZW5fMS5fKSBgdHlwZW9mICR7ZGF0YX1gKVxuICAgICAgICAgICAgLmlmKGNoZWNrRGF0YVR5cGVzKHR5cGVzLCBkYXRhLCBvcHRzLnN0cmljdE51bWJlcnMpLCAoKSA9PiBnZW4uYXNzaWduKGNvZXJjZWQsIGRhdGEpKSk7XG4gICAgfVxuICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke2NvZXJjZWR9ICE9PSB1bmRlZmluZWRgKTtcbiAgICBmb3IgKGNvbnN0IHQgb2YgY29lcmNlVG8pIHtcbiAgICAgICAgaWYgKENPRVJDSUJMRS5oYXModCkgfHwgKHQgPT09IFwiYXJyYXlcIiAmJiBvcHRzLmNvZXJjZVR5cGVzID09PSBcImFycmF5XCIpKSB7XG4gICAgICAgICAgICBjb2VyY2VTcGVjaWZpY1R5cGUodCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2VuLmVsc2UoKTtcbiAgICByZXBvcnRUeXBlRXJyb3IoaXQpO1xuICAgIGdlbi5lbmRJZigpO1xuICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke2NvZXJjZWR9ICE9PSB1bmRlZmluZWRgLCAoKSA9PiB7XG4gICAgICAgIGdlbi5hc3NpZ24oZGF0YSwgY29lcmNlZCk7XG4gICAgICAgIGFzc2lnblBhcmVudERhdGEoaXQsIGNvZXJjZWQpO1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGNvZXJjZVNwZWNpZmljVHlwZSh0KSB7XG4gICAgICAgIHN3aXRjaCAodCkge1xuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgICAgICAgICAuZWxzZUlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YVR5cGV9ID09IFwibnVtYmVyXCIgfHwgJHtkYXRhVHlwZX0gPT0gXCJib29sZWFuXCJgKVxuICAgICAgICAgICAgICAgICAgICAuYXNzaWduKGNvZXJjZWQsICgwLCBjb2RlZ2VuXzEuXykgYFwiXCIgKyAke2RhdGF9YClcbiAgICAgICAgICAgICAgICAgICAgLmVsc2VJZigoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9ID09PSBudWxsYClcbiAgICAgICAgICAgICAgICAgICAgLmFzc2lnbihjb2VyY2VkLCAoMCwgY29kZWdlbl8xLl8pIGBcIlwiYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgICAgICAgICAuZWxzZUlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YVR5cGV9ID09IFwiYm9vbGVhblwiIHx8ICR7ZGF0YX0gPT09IG51bGxcbiAgICAgICAgICAgICAgfHwgKCR7ZGF0YVR5cGV9ID09IFwic3RyaW5nXCIgJiYgJHtkYXRhfSAmJiAke2RhdGF9ID09ICske2RhdGF9KWApXG4gICAgICAgICAgICAgICAgICAgIC5hc3NpZ24oY29lcmNlZCwgKDAsIGNvZGVnZW5fMS5fKSBgKyR7ZGF0YX1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIFwiaW50ZWdlclwiOlxuICAgICAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgICAgICAgICAuZWxzZUlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YVR5cGV9ID09PSBcImJvb2xlYW5cIiB8fCAke2RhdGF9ID09PSBudWxsXG4gICAgICAgICAgICAgIHx8ICgke2RhdGFUeXBlfSA9PT0gXCJzdHJpbmdcIiAmJiAke2RhdGF9ICYmICR7ZGF0YX0gPT0gKyR7ZGF0YX0gJiYgISgke2RhdGF9ICUgMSkpYClcbiAgICAgICAgICAgICAgICAgICAgLmFzc2lnbihjb2VyY2VkLCAoMCwgY29kZWdlbl8xLl8pIGArJHtkYXRhfWApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICAgICAgZ2VuXG4gICAgICAgICAgICAgICAgICAgIC5lbHNlSWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfSA9PT0gXCJmYWxzZVwiIHx8ICR7ZGF0YX0gPT09IDAgfHwgJHtkYXRhfSA9PT0gbnVsbGApXG4gICAgICAgICAgICAgICAgICAgIC5hc3NpZ24oY29lcmNlZCwgZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIC5lbHNlSWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfSA9PT0gXCJ0cnVlXCIgfHwgJHtkYXRhfSA9PT0gMWApXG4gICAgICAgICAgICAgICAgICAgIC5hc3NpZ24oY29lcmNlZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBcIm51bGxcIjpcbiAgICAgICAgICAgICAgICBnZW4uZWxzZUlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0gPT09IFwiXCIgfHwgJHtkYXRhfSA9PT0gMCB8fCAke2RhdGF9ID09PSBmYWxzZWApO1xuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24oY29lcmNlZCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBcImFycmF5XCI6XG4gICAgICAgICAgICAgICAgZ2VuXG4gICAgICAgICAgICAgICAgICAgIC5lbHNlSWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhVHlwZX0gPT09IFwic3RyaW5nXCIgfHwgJHtkYXRhVHlwZX0gPT09IFwibnVtYmVyXCJcbiAgICAgICAgICAgICAgfHwgJHtkYXRhVHlwZX0gPT09IFwiYm9vbGVhblwiIHx8ICR7ZGF0YX0gPT09IG51bGxgKVxuICAgICAgICAgICAgICAgICAgICAuYXNzaWduKGNvZXJjZWQsICgwLCBjb2RlZ2VuXzEuXykgYFske2RhdGF9XWApO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gYXNzaWduUGFyZW50RGF0YSh7IGdlbiwgcGFyZW50RGF0YSwgcGFyZW50RGF0YVByb3BlcnR5IH0sIGV4cHIpIHtcbiAgICAvLyBUT0RPIHVzZSBnZW4ucHJvcGVydHlcbiAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtwYXJlbnREYXRhfSAhPT0gdW5kZWZpbmVkYCwgKCkgPT4gZ2VuLmFzc2lnbigoMCwgY29kZWdlbl8xLl8pIGAke3BhcmVudERhdGF9WyR7cGFyZW50RGF0YVByb3BlcnR5fV1gLCBleHByKSk7XG59XG5mdW5jdGlvbiBjaGVja0RhdGFUeXBlKGRhdGFUeXBlLCBkYXRhLCBzdHJpY3ROdW1zLCBjb3JyZWN0ID0gRGF0YVR5cGUuQ29ycmVjdCkge1xuICAgIGNvbnN0IEVRID0gY29ycmVjdCA9PT0gRGF0YVR5cGUuQ29ycmVjdCA/IGNvZGVnZW5fMS5vcGVyYXRvcnMuRVEgOiBjb2RlZ2VuXzEub3BlcmF0b3JzLk5FUTtcbiAgICBsZXQgY29uZDtcbiAgICBzd2l0Y2ggKGRhdGFUeXBlKSB7XG4gICAgICAgIGNhc2UgXCJudWxsXCI6XG4gICAgICAgICAgICByZXR1cm4gKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfSAke0VRfSBudWxsYDtcbiAgICAgICAgY2FzZSBcImFycmF5XCI6XG4gICAgICAgICAgICBjb25kID0gKDAsIGNvZGVnZW5fMS5fKSBgQXJyYXkuaXNBcnJheSgke2RhdGF9KWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgY29uZCA9ICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0gJiYgdHlwZW9mICR7ZGF0YX0gPT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheSgke2RhdGF9KWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImludGVnZXJcIjpcbiAgICAgICAgICAgIGNvbmQgPSBudW1Db25kKCgwLCBjb2RlZ2VuXzEuXykgYCEoJHtkYXRhfSAlIDEpICYmICFpc05hTigke2RhdGF9KWApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIGNvbmQgPSBudW1Db25kKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLl8pIGB0eXBlb2YgJHtkYXRhfSAke0VRfSAke2RhdGFUeXBlfWA7XG4gICAgfVxuICAgIHJldHVybiBjb3JyZWN0ID09PSBEYXRhVHlwZS5Db3JyZWN0ID8gY29uZCA6ICgwLCBjb2RlZ2VuXzEubm90KShjb25kKTtcbiAgICBmdW5jdGlvbiBudW1Db25kKF9jb25kID0gY29kZWdlbl8xLm5pbCkge1xuICAgICAgICByZXR1cm4gKDAsIGNvZGVnZW5fMS5hbmQpKCgwLCBjb2RlZ2VuXzEuXykgYHR5cGVvZiAke2RhdGF9ID09IFwibnVtYmVyXCJgLCBfY29uZCwgc3RyaWN0TnVtcyA/ICgwLCBjb2RlZ2VuXzEuXykgYGlzRmluaXRlKCR7ZGF0YX0pYCA6IGNvZGVnZW5fMS5uaWwpO1xuICAgIH1cbn1cbmV4cG9ydHMuY2hlY2tEYXRhVHlwZSA9IGNoZWNrRGF0YVR5cGU7XG5mdW5jdGlvbiBjaGVja0RhdGFUeXBlcyhkYXRhVHlwZXMsIGRhdGEsIHN0cmljdE51bXMsIGNvcnJlY3QpIHtcbiAgICBpZiAoZGF0YVR5cGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gY2hlY2tEYXRhVHlwZShkYXRhVHlwZXNbMF0sIGRhdGEsIHN0cmljdE51bXMsIGNvcnJlY3QpO1xuICAgIH1cbiAgICBsZXQgY29uZDtcbiAgICBjb25zdCB0eXBlcyA9ICgwLCB1dGlsXzEudG9IYXNoKShkYXRhVHlwZXMpO1xuICAgIGlmICh0eXBlcy5hcnJheSAmJiB0eXBlcy5vYmplY3QpIHtcbiAgICAgICAgY29uc3Qgbm90T2JqID0gKDAsIGNvZGVnZW5fMS5fKSBgdHlwZW9mICR7ZGF0YX0gIT0gXCJvYmplY3RcImA7XG4gICAgICAgIGNvbmQgPSB0eXBlcy5udWxsID8gbm90T2JqIDogKDAsIGNvZGVnZW5fMS5fKSBgISR7ZGF0YX0gfHwgJHtub3RPYmp9YDtcbiAgICAgICAgZGVsZXRlIHR5cGVzLm51bGw7XG4gICAgICAgIGRlbGV0ZSB0eXBlcy5hcnJheTtcbiAgICAgICAgZGVsZXRlIHR5cGVzLm9iamVjdDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbmQgPSBjb2RlZ2VuXzEubmlsO1xuICAgIH1cbiAgICBpZiAodHlwZXMubnVtYmVyKVxuICAgICAgICBkZWxldGUgdHlwZXMuaW50ZWdlcjtcbiAgICBmb3IgKGNvbnN0IHQgaW4gdHlwZXMpXG4gICAgICAgIGNvbmQgPSAoMCwgY29kZWdlbl8xLmFuZCkoY29uZCwgY2hlY2tEYXRhVHlwZSh0LCBkYXRhLCBzdHJpY3ROdW1zLCBjb3JyZWN0KSk7XG4gICAgcmV0dXJuIGNvbmQ7XG59XG5leHBvcnRzLmNoZWNrRGF0YVR5cGVzID0gY2hlY2tEYXRhVHlwZXM7XG5jb25zdCB0eXBlRXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsgc2NoZW1hIH0pID0+IGBtdXN0IGJlICR7c2NoZW1hfWAsXG4gICAgcGFyYW1zOiAoeyBzY2hlbWEsIHNjaGVtYVZhbHVlIH0pID0+IHR5cGVvZiBzY2hlbWEgPT0gXCJzdHJpbmdcIiA/ICgwLCBjb2RlZ2VuXzEuXykgYHt0eXBlOiAke3NjaGVtYX19YCA6ICgwLCBjb2RlZ2VuXzEuXykgYHt0eXBlOiAke3NjaGVtYVZhbHVlfX1gLFxufTtcbmZ1bmN0aW9uIHJlcG9ydFR5cGVFcnJvcihpdCkge1xuICAgIGNvbnN0IGN4dCA9IGdldFR5cGVFcnJvckNvbnRleHQoaXQpO1xuICAgICgwLCBlcnJvcnNfMS5yZXBvcnRFcnJvcikoY3h0LCB0eXBlRXJyb3IpO1xufVxuZXhwb3J0cy5yZXBvcnRUeXBlRXJyb3IgPSByZXBvcnRUeXBlRXJyb3I7XG5mdW5jdGlvbiBnZXRUeXBlRXJyb3JDb250ZXh0KGl0KSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEsIHNjaGVtYSB9ID0gaXQ7XG4gICAgY29uc3Qgc2NoZW1hQ29kZSA9ICgwLCB1dGlsXzEuc2NoZW1hUmVmT3JWYWwpKGl0LCBzY2hlbWEsIFwidHlwZVwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBnZW4sXG4gICAgICAgIGtleXdvcmQ6IFwidHlwZVwiLFxuICAgICAgICBkYXRhLFxuICAgICAgICBzY2hlbWE6IHNjaGVtYS50eXBlLFxuICAgICAgICBzY2hlbWFDb2RlLFxuICAgICAgICBzY2hlbWFWYWx1ZTogc2NoZW1hQ29kZSxcbiAgICAgICAgcGFyZW50U2NoZW1hOiBzY2hlbWEsXG4gICAgICAgIHBhcmFtczoge30sXG4gICAgICAgIGl0LFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhVHlwZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYXNzaWduRGVmYXVsdHMgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuZnVuY3Rpb24gYXNzaWduRGVmYXVsdHMoaXQsIHR5KSB7XG4gICAgY29uc3QgeyBwcm9wZXJ0aWVzLCBpdGVtcyB9ID0gaXQuc2NoZW1hO1xuICAgIGlmICh0eSA9PT0gXCJvYmplY3RcIiAmJiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGFzc2lnbkRlZmF1bHQoaXQsIGtleSwgcHJvcGVydGllc1trZXldLmRlZmF1bHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5ID09PSBcImFycmF5XCIgJiYgQXJyYXkuaXNBcnJheShpdGVtcykpIHtcbiAgICAgICAgaXRlbXMuZm9yRWFjaCgoc2NoLCBpKSA9PiBhc3NpZ25EZWZhdWx0KGl0LCBpLCBzY2guZGVmYXVsdCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuYXNzaWduRGVmYXVsdHMgPSBhc3NpZ25EZWZhdWx0cztcbmZ1bmN0aW9uIGFzc2lnbkRlZmF1bHQoaXQsIHByb3AsIGRlZmF1bHRWYWx1ZSkge1xuICAgIGNvbnN0IHsgZ2VuLCBjb21wb3NpdGVSdWxlLCBkYXRhLCBvcHRzIH0gPSBpdDtcbiAgICBpZiAoZGVmYXVsdFZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCBjaGlsZERhdGEgPSAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9JHsoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KShwcm9wKX1gO1xuICAgIGlmIChjb21wb3NpdGVSdWxlKSB7XG4gICAgICAgICgwLCB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKShpdCwgYGRlZmF1bHQgaXMgaWdub3JlZCBmb3I6ICR7Y2hpbGREYXRhfWApO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBjb25kaXRpb24gPSAoMCwgY29kZWdlbl8xLl8pIGAke2NoaWxkRGF0YX0gPT09IHVuZGVmaW5lZGA7XG4gICAgaWYgKG9wdHMudXNlRGVmYXVsdHMgPT09IFwiZW1wdHlcIikge1xuICAgICAgICBjb25kaXRpb24gPSAoMCwgY29kZWdlbl8xLl8pIGAke2NvbmRpdGlvbn0gfHwgJHtjaGlsZERhdGF9ID09PSBudWxsIHx8ICR7Y2hpbGREYXRhfSA9PT0gXCJcImA7XG4gICAgfVxuICAgIC8vIGAke2NoaWxkRGF0YX0gPT09IHVuZGVmaW5lZGAgK1xuICAgIC8vIChvcHRzLnVzZURlZmF1bHRzID09PSBcImVtcHR5XCIgPyBgIHx8ICR7Y2hpbGREYXRhfSA9PT0gbnVsbCB8fCAke2NoaWxkRGF0YX0gPT09IFwiXCJgIDogXCJcIilcbiAgICBnZW4uaWYoY29uZGl0aW9uLCAoMCwgY29kZWdlbl8xLl8pIGAke2NoaWxkRGF0YX0gPSAkeygwLCBjb2RlZ2VuXzEuc3RyaW5naWZ5KShkZWZhdWx0VmFsdWUpfWApO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmYXVsdHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlVW5pb24gPSBleHBvcnRzLnZhbGlkYXRlQXJyYXkgPSBleHBvcnRzLnVzZVBhdHRlcm4gPSBleHBvcnRzLmNhbGxWYWxpZGF0ZUNvZGUgPSBleHBvcnRzLnNjaGVtYVByb3BlcnRpZXMgPSBleHBvcnRzLmFsbFNjaGVtYVByb3BlcnRpZXMgPSBleHBvcnRzLm5vUHJvcGVydHlJbkRhdGEgPSBleHBvcnRzLnByb3BlcnR5SW5EYXRhID0gZXhwb3J0cy5pc093blByb3BlcnR5ID0gZXhwb3J0cy5oYXNQcm9wRnVuYyA9IGV4cG9ydHMucmVwb3J0TWlzc2luZ1Byb3AgPSBleHBvcnRzLmNoZWNrTWlzc2luZ1Byb3AgPSBleHBvcnRzLmNoZWNrUmVwb3J0TWlzc2luZ1Byb3AgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IG5hbWVzXzEgPSByZXF1aXJlKFwiLi4vY29tcGlsZS9uYW1lc1wiKTtcbmNvbnN0IHV0aWxfMiA9IHJlcXVpcmUoXCIuLi9jb21waWxlL3V0aWxcIik7XG5mdW5jdGlvbiBjaGVja1JlcG9ydE1pc3NpbmdQcm9wKGN4dCwgcHJvcCkge1xuICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBpdCB9ID0gY3h0O1xuICAgIGdlbi5pZihub1Byb3BlcnR5SW5EYXRhKGdlbiwgZGF0YSwgcHJvcCwgaXQub3B0cy5vd25Qcm9wZXJ0aWVzKSwgKCkgPT4ge1xuICAgICAgICBjeHQuc2V0UGFyYW1zKHsgbWlzc2luZ1Byb3BlcnR5OiAoMCwgY29kZWdlbl8xLl8pIGAke3Byb3B9YCB9LCB0cnVlKTtcbiAgICAgICAgY3h0LmVycm9yKCk7XG4gICAgfSk7XG59XG5leHBvcnRzLmNoZWNrUmVwb3J0TWlzc2luZ1Byb3AgPSBjaGVja1JlcG9ydE1pc3NpbmdQcm9wO1xuZnVuY3Rpb24gY2hlY2tNaXNzaW5nUHJvcCh7IGdlbiwgZGF0YSwgaXQ6IHsgb3B0cyB9IH0sIHByb3BlcnRpZXMsIG1pc3NpbmcpIHtcbiAgICByZXR1cm4gKDAsIGNvZGVnZW5fMS5vcikoLi4ucHJvcGVydGllcy5tYXAoKHByb3ApID0+ICgwLCBjb2RlZ2VuXzEuYW5kKShub1Byb3BlcnR5SW5EYXRhKGdlbiwgZGF0YSwgcHJvcCwgb3B0cy5vd25Qcm9wZXJ0aWVzKSwgKDAsIGNvZGVnZW5fMS5fKSBgJHttaXNzaW5nfSA9ICR7cHJvcH1gKSkpO1xufVxuZXhwb3J0cy5jaGVja01pc3NpbmdQcm9wID0gY2hlY2tNaXNzaW5nUHJvcDtcbmZ1bmN0aW9uIHJlcG9ydE1pc3NpbmdQcm9wKGN4dCwgbWlzc2luZykge1xuICAgIGN4dC5zZXRQYXJhbXMoeyBtaXNzaW5nUHJvcGVydHk6IG1pc3NpbmcgfSwgdHJ1ZSk7XG4gICAgY3h0LmVycm9yKCk7XG59XG5leHBvcnRzLnJlcG9ydE1pc3NpbmdQcm9wID0gcmVwb3J0TWlzc2luZ1Byb3A7XG5mdW5jdGlvbiBoYXNQcm9wRnVuYyhnZW4pIHtcbiAgICByZXR1cm4gZ2VuLnNjb3BlVmFsdWUoXCJmdW5jXCIsIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZFxuICAgICAgICByZWY6IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXG4gICAgICAgIGNvZGU6ICgwLCBjb2RlZ2VuXzEuXykgYE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlgLFxuICAgIH0pO1xufVxuZXhwb3J0cy5oYXNQcm9wRnVuYyA9IGhhc1Byb3BGdW5jO1xuZnVuY3Rpb24gaXNPd25Qcm9wZXJ0eShnZW4sIGRhdGEsIHByb3BlcnR5KSB7XG4gICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuXykgYCR7aGFzUHJvcEZ1bmMoZ2VuKX0uY2FsbCgke2RhdGF9LCAke3Byb3BlcnR5fSlgO1xufVxuZXhwb3J0cy5pc093blByb3BlcnR5ID0gaXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIHByb3BlcnR5SW5EYXRhKGdlbiwgZGF0YSwgcHJvcGVydHksIG93blByb3BlcnRpZXMpIHtcbiAgICBjb25zdCBjb25kID0gKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfSR7KDAsIGNvZGVnZW5fMS5nZXRQcm9wZXJ0eSkocHJvcGVydHkpfSAhPT0gdW5kZWZpbmVkYDtcbiAgICByZXR1cm4gb3duUHJvcGVydGllcyA/ICgwLCBjb2RlZ2VuXzEuXykgYCR7Y29uZH0gJiYgJHtpc093blByb3BlcnR5KGdlbiwgZGF0YSwgcHJvcGVydHkpfWAgOiBjb25kO1xufVxuZXhwb3J0cy5wcm9wZXJ0eUluRGF0YSA9IHByb3BlcnR5SW5EYXRhO1xuZnVuY3Rpb24gbm9Qcm9wZXJ0eUluRGF0YShnZW4sIGRhdGEsIHByb3BlcnR5LCBvd25Qcm9wZXJ0aWVzKSB7XG4gICAgY29uc3QgY29uZCA9ICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0keygwLCBjb2RlZ2VuXzEuZ2V0UHJvcGVydHkpKHByb3BlcnR5KX0gPT09IHVuZGVmaW5lZGA7XG4gICAgcmV0dXJuIG93blByb3BlcnRpZXMgPyAoMCwgY29kZWdlbl8xLm9yKShjb25kLCAoMCwgY29kZWdlbl8xLm5vdCkoaXNPd25Qcm9wZXJ0eShnZW4sIGRhdGEsIHByb3BlcnR5KSkpIDogY29uZDtcbn1cbmV4cG9ydHMubm9Qcm9wZXJ0eUluRGF0YSA9IG5vUHJvcGVydHlJbkRhdGE7XG5mdW5jdGlvbiBhbGxTY2hlbWFQcm9wZXJ0aWVzKHNjaGVtYU1hcCkge1xuICAgIHJldHVybiBzY2hlbWFNYXAgPyBPYmplY3Qua2V5cyhzY2hlbWFNYXApLmZpbHRlcigocCkgPT4gcCAhPT0gXCJfX3Byb3RvX19cIikgOiBbXTtcbn1cbmV4cG9ydHMuYWxsU2NoZW1hUHJvcGVydGllcyA9IGFsbFNjaGVtYVByb3BlcnRpZXM7XG5mdW5jdGlvbiBzY2hlbWFQcm9wZXJ0aWVzKGl0LCBzY2hlbWFNYXApIHtcbiAgICByZXR1cm4gYWxsU2NoZW1hUHJvcGVydGllcyhzY2hlbWFNYXApLmZpbHRlcigocCkgPT4gISgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2hlbWFNYXBbcF0pKTtcbn1cbmV4cG9ydHMuc2NoZW1hUHJvcGVydGllcyA9IHNjaGVtYVByb3BlcnRpZXM7XG5mdW5jdGlvbiBjYWxsVmFsaWRhdGVDb2RlKHsgc2NoZW1hQ29kZSwgZGF0YSwgaXQ6IHsgZ2VuLCB0b3BTY2hlbWFSZWYsIHNjaGVtYVBhdGgsIGVycm9yUGF0aCB9LCBpdCB9LCBmdW5jLCBjb250ZXh0LCBwYXNzU2NoZW1hKSB7XG4gICAgY29uc3QgZGF0YUFuZFNjaGVtYSA9IHBhc3NTY2hlbWEgPyAoMCwgY29kZWdlbl8xLl8pIGAke3NjaGVtYUNvZGV9LCAke2RhdGF9LCAke3RvcFNjaGVtYVJlZn0ke3NjaGVtYVBhdGh9YCA6IGRhdGE7XG4gICAgY29uc3QgdmFsQ3h0ID0gW1xuICAgICAgICBbbmFtZXNfMS5kZWZhdWx0Lmluc3RhbmNlUGF0aCwgKDAsIGNvZGVnZW5fMS5zdHJDb25jYXQpKG5hbWVzXzEuZGVmYXVsdC5pbnN0YW5jZVBhdGgsIGVycm9yUGF0aCldLFxuICAgICAgICBbbmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGEsIGl0LnBhcmVudERhdGFdLFxuICAgICAgICBbbmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGFQcm9wZXJ0eSwgaXQucGFyZW50RGF0YVByb3BlcnR5XSxcbiAgICAgICAgW25hbWVzXzEuZGVmYXVsdC5yb290RGF0YSwgbmFtZXNfMS5kZWZhdWx0LnJvb3REYXRhXSxcbiAgICBdO1xuICAgIGlmIChpdC5vcHRzLmR5bmFtaWNSZWYpXG4gICAgICAgIHZhbEN4dC5wdXNoKFtuYW1lc18xLmRlZmF1bHQuZHluYW1pY0FuY2hvcnMsIG5hbWVzXzEuZGVmYXVsdC5keW5hbWljQW5jaG9yc10pO1xuICAgIGNvbnN0IGFyZ3MgPSAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGFBbmRTY2hlbWF9LCAke2dlbi5vYmplY3QoLi4udmFsQ3h0KX1gO1xuICAgIHJldHVybiBjb250ZXh0ICE9PSBjb2RlZ2VuXzEubmlsID8gKDAsIGNvZGVnZW5fMS5fKSBgJHtmdW5jfS5jYWxsKCR7Y29udGV4dH0sICR7YXJnc30pYCA6ICgwLCBjb2RlZ2VuXzEuXykgYCR7ZnVuY30oJHthcmdzfSlgO1xufVxuZXhwb3J0cy5jYWxsVmFsaWRhdGVDb2RlID0gY2FsbFZhbGlkYXRlQ29kZTtcbmNvbnN0IG5ld1JlZ0V4cCA9ICgwLCBjb2RlZ2VuXzEuXykgYG5ldyBSZWdFeHBgO1xuZnVuY3Rpb24gdXNlUGF0dGVybih7IGdlbiwgaXQ6IHsgb3B0cyB9IH0sIHBhdHRlcm4pIHtcbiAgICBjb25zdCB1ID0gb3B0cy51bmljb2RlUmVnRXhwID8gXCJ1XCIgOiBcIlwiO1xuICAgIGNvbnN0IHsgcmVnRXhwIH0gPSBvcHRzLmNvZGU7XG4gICAgY29uc3QgcnggPSByZWdFeHAocGF0dGVybiwgdSk7XG4gICAgcmV0dXJuIGdlbi5zY29wZVZhbHVlKFwicGF0dGVyblwiLCB7XG4gICAgICAgIGtleTogcngudG9TdHJpbmcoKSxcbiAgICAgICAgcmVmOiByeCxcbiAgICAgICAgY29kZTogKDAsIGNvZGVnZW5fMS5fKSBgJHtyZWdFeHAuY29kZSA9PT0gXCJuZXcgUmVnRXhwXCIgPyBuZXdSZWdFeHAgOiAoMCwgdXRpbF8yLnVzZUZ1bmMpKGdlbiwgcmVnRXhwKX0oJHtwYXR0ZXJufSwgJHt1fSlgLFxuICAgIH0pO1xufVxuZXhwb3J0cy51c2VQYXR0ZXJuID0gdXNlUGF0dGVybjtcbmZ1bmN0aW9uIHZhbGlkYXRlQXJyYXkoY3h0KSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEsIGtleXdvcmQsIGl0IH0gPSBjeHQ7XG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgIGlmIChpdC5hbGxFcnJvcnMpIHtcbiAgICAgICAgY29uc3QgdmFsaWRBcnIgPSBnZW4ubGV0KFwidmFsaWRcIiwgdHJ1ZSk7XG4gICAgICAgIHZhbGlkYXRlSXRlbXMoKCkgPT4gZ2VuLmFzc2lnbih2YWxpZEFyciwgZmFsc2UpKTtcbiAgICAgICAgcmV0dXJuIHZhbGlkQXJyO1xuICAgIH1cbiAgICBnZW4udmFyKHZhbGlkLCB0cnVlKTtcbiAgICB2YWxpZGF0ZUl0ZW1zKCgpID0+IGdlbi5icmVhaygpKTtcbiAgICByZXR1cm4gdmFsaWQ7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVJdGVtcyhub3RWYWxpZCkge1xuICAgICAgICBjb25zdCBsZW4gPSBnZW4uY29uc3QoXCJsZW5cIiwgKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfS5sZW5ndGhgKTtcbiAgICAgICAgZ2VuLmZvclJhbmdlKFwiaVwiLCAwLCBsZW4sIChpKSA9PiB7XG4gICAgICAgICAgICBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgICAgICBrZXl3b3JkLFxuICAgICAgICAgICAgICAgIGRhdGFQcm9wOiBpLFxuICAgICAgICAgICAgICAgIGRhdGFQcm9wVHlwZTogdXRpbF8xLlR5cGUuTnVtLFxuICAgICAgICAgICAgfSwgdmFsaWQpO1xuICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEubm90KSh2YWxpZCksIG5vdFZhbGlkKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZUFycmF5ID0gdmFsaWRhdGVBcnJheTtcbmZ1bmN0aW9uIHZhbGlkYXRlVW5pb24oY3h0KSB7XG4gICAgY29uc3QgeyBnZW4sIHNjaGVtYSwga2V5d29yZCwgaXQgfSA9IGN4dDtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgIGNvbnN0IGFsd2F5c1ZhbGlkID0gc2NoZW1hLnNvbWUoKHNjaCkgPT4gKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaCkpO1xuICAgIGlmIChhbHdheXNWYWxpZCAmJiAhaXQub3B0cy51bmV2YWx1YXRlZClcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIsIGZhbHNlKTtcbiAgICBjb25zdCBzY2hWYWxpZCA9IGdlbi5uYW1lKFwiX3ZhbGlkXCIpO1xuICAgIGdlbi5ibG9jaygoKSA9PiBzY2hlbWEuZm9yRWFjaCgoX3NjaCwgaSkgPT4ge1xuICAgICAgICBjb25zdCBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgIGtleXdvcmQsXG4gICAgICAgICAgICBzY2hlbWFQcm9wOiBpLFxuICAgICAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICAgICAgfSwgc2NoVmFsaWQpO1xuICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCAoMCwgY29kZWdlbl8xLl8pIGAke3ZhbGlkfSB8fCAke3NjaFZhbGlkfWApO1xuICAgICAgICBjb25zdCBtZXJnZWQgPSBjeHQubWVyZ2VWYWxpZEV2YWx1YXRlZChzY2hDeHQsIHNjaFZhbGlkKTtcbiAgICAgICAgLy8gY2FuIHNob3J0LWNpcmN1aXQgaWYgYHVuZXZhbHVhdGVkUHJvcGVydGllcy9JdGVtc2Agbm90IHN1cHBvcnRlZCAob3B0cy51bmV2YWx1YXRlZCAhPT0gdHJ1ZSlcbiAgICAgICAgLy8gb3IgaWYgYWxsIHByb3BlcnRpZXMgYW5kIGl0ZW1zIHdlcmUgZXZhbHVhdGVkIChpdC5wcm9wcyA9PT0gdHJ1ZSAmJiBpdC5pdGVtcyA9PT0gdHJ1ZSlcbiAgICAgICAgaWYgKCFtZXJnZWQpXG4gICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5ub3QpKHZhbGlkKSk7XG4gICAgfSkpO1xuICAgIGN4dC5yZXN1bHQodmFsaWQsICgpID0+IGN4dC5yZXNldCgpLCAoKSA9PiBjeHQuZXJyb3IodHJ1ZSkpO1xufVxuZXhwb3J0cy52YWxpZGF0ZVVuaW9uID0gdmFsaWRhdGVVbmlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvZGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlS2V5d29yZFVzYWdlID0gZXhwb3J0cy52YWxpZFNjaGVtYVR5cGUgPSBleHBvcnRzLmZ1bmNLZXl3b3JkQ29kZSA9IGV4cG9ydHMubWFjcm9LZXl3b3JkQ29kZSA9IHZvaWQgMDtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi9jb2RlZ2VuXCIpO1xuY29uc3QgbmFtZXNfMSA9IHJlcXVpcmUoXCIuLi9uYW1lc1wiKTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi8uLi92b2NhYnVsYXJpZXMvY29kZVwiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbmZ1bmN0aW9uIG1hY3JvS2V5d29yZENvZGUoY3h0LCBkZWYpIHtcbiAgICBjb25zdCB7IGdlbiwga2V5d29yZCwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgY29uc3QgbWFjcm9TY2hlbWEgPSBkZWYubWFjcm8uY2FsbChpdC5zZWxmLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgaXQpO1xuICAgIGNvbnN0IHNjaGVtYVJlZiA9IHVzZUtleXdvcmQoZ2VuLCBrZXl3b3JkLCBtYWNyb1NjaGVtYSk7XG4gICAgaWYgKGl0Lm9wdHMudmFsaWRhdGVTY2hlbWEgIT09IGZhbHNlKVxuICAgICAgICBpdC5zZWxmLnZhbGlkYXRlU2NoZW1hKG1hY3JvU2NoZW1hLCB0cnVlKTtcbiAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgIHNjaGVtYTogbWFjcm9TY2hlbWEsXG4gICAgICAgIHNjaGVtYVBhdGg6IGNvZGVnZW5fMS5uaWwsXG4gICAgICAgIGVyclNjaGVtYVBhdGg6IGAke2l0LmVyclNjaGVtYVBhdGh9LyR7a2V5d29yZH1gLFxuICAgICAgICB0b3BTY2hlbWFSZWY6IHNjaGVtYVJlZixcbiAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICB9LCB2YWxpZCk7XG4gICAgY3h0LnBhc3ModmFsaWQsICgpID0+IGN4dC5lcnJvcih0cnVlKSk7XG59XG5leHBvcnRzLm1hY3JvS2V5d29yZENvZGUgPSBtYWNyb0tleXdvcmRDb2RlO1xuZnVuY3Rpb24gZnVuY0tleXdvcmRDb2RlKGN4dCwgZGVmKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHsgZ2VuLCBrZXl3b3JkLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgJGRhdGEsIGl0IH0gPSBjeHQ7XG4gICAgY2hlY2tBc3luY0tleXdvcmQoaXQsIGRlZik7XG4gICAgY29uc3QgdmFsaWRhdGUgPSAhJGRhdGEgJiYgZGVmLmNvbXBpbGUgPyBkZWYuY29tcGlsZS5jYWxsKGl0LnNlbGYsIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBpdCkgOiBkZWYudmFsaWRhdGU7XG4gICAgY29uc3QgdmFsaWRhdGVSZWYgPSB1c2VLZXl3b3JkKGdlbiwga2V5d29yZCwgdmFsaWRhdGUpO1xuICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIpO1xuICAgIGN4dC5ibG9jayRkYXRhKHZhbGlkLCB2YWxpZGF0ZUtleXdvcmQpO1xuICAgIGN4dC5vaygoX2EgPSBkZWYudmFsaWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHZhbGlkKTtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUtleXdvcmQoKSB7XG4gICAgICAgIGlmIChkZWYuZXJyb3JzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYXNzaWduVmFsaWQoKTtcbiAgICAgICAgICAgIGlmIChkZWYubW9kaWZ5aW5nKVxuICAgICAgICAgICAgICAgIG1vZGlmeURhdGEoY3h0KTtcbiAgICAgICAgICAgIHJlcG9ydEVycnMoKCkgPT4gY3h0LmVycm9yKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcnVsZUVycnMgPSBkZWYuYXN5bmMgPyB2YWxpZGF0ZUFzeW5jKCkgOiB2YWxpZGF0ZVN5bmMoKTtcbiAgICAgICAgICAgIGlmIChkZWYubW9kaWZ5aW5nKVxuICAgICAgICAgICAgICAgIG1vZGlmeURhdGEoY3h0KTtcbiAgICAgICAgICAgIHJlcG9ydEVycnMoKCkgPT4gYWRkRXJycyhjeHQsIHJ1bGVFcnJzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVBc3luYygpIHtcbiAgICAgICAgY29uc3QgcnVsZUVycnMgPSBnZW4ubGV0KFwicnVsZUVycnNcIiwgbnVsbCk7XG4gICAgICAgIGdlbi50cnkoKCkgPT4gYXNzaWduVmFsaWQoKDAsIGNvZGVnZW5fMS5fKSBgYXdhaXQgYCksIChlKSA9PiBnZW4uYXNzaWduKHZhbGlkLCBmYWxzZSkuaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtlfSBpbnN0YW5jZW9mICR7aXQuVmFsaWRhdGlvbkVycm9yfWAsICgpID0+IGdlbi5hc3NpZ24ocnVsZUVycnMsICgwLCBjb2RlZ2VuXzEuXykgYCR7ZX0uZXJyb3JzYCksICgpID0+IGdlbi50aHJvdyhlKSkpO1xuICAgICAgICByZXR1cm4gcnVsZUVycnM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlU3luYygpIHtcbiAgICAgICAgY29uc3QgdmFsaWRhdGVFcnJzID0gKDAsIGNvZGVnZW5fMS5fKSBgJHt2YWxpZGF0ZVJlZn0uZXJyb3JzYDtcbiAgICAgICAgZ2VuLmFzc2lnbih2YWxpZGF0ZUVycnMsIG51bGwpO1xuICAgICAgICBhc3NpZ25WYWxpZChjb2RlZ2VuXzEubmlsKTtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlRXJycztcbiAgICB9XG4gICAgZnVuY3Rpb24gYXNzaWduVmFsaWQoX2F3YWl0ID0gZGVmLmFzeW5jID8gKDAsIGNvZGVnZW5fMS5fKSBgYXdhaXQgYCA6IGNvZGVnZW5fMS5uaWwpIHtcbiAgICAgICAgY29uc3QgcGFzc0N4dCA9IGl0Lm9wdHMucGFzc0NvbnRleHQgPyBuYW1lc18xLmRlZmF1bHQudGhpcyA6IG5hbWVzXzEuZGVmYXVsdC5zZWxmO1xuICAgICAgICBjb25zdCBwYXNzU2NoZW1hID0gISgoXCJjb21waWxlXCIgaW4gZGVmICYmICEkZGF0YSkgfHwgZGVmLnNjaGVtYSA9PT0gZmFsc2UpO1xuICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCAoMCwgY29kZWdlbl8xLl8pIGAke19hd2FpdH0keygwLCBjb2RlXzEuY2FsbFZhbGlkYXRlQ29kZSkoY3h0LCB2YWxpZGF0ZVJlZiwgcGFzc0N4dCwgcGFzc1NjaGVtYSl9YCwgZGVmLm1vZGlmeWluZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcG9ydEVycnMoZXJyb3JzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEubm90KSgoX2EgPSBkZWYudmFsaWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHZhbGlkKSwgZXJyb3JzKTtcbiAgICB9XG59XG5leHBvcnRzLmZ1bmNLZXl3b3JkQ29kZSA9IGZ1bmNLZXl3b3JkQ29kZTtcbmZ1bmN0aW9uIG1vZGlmeURhdGEoY3h0KSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEsIGl0IH0gPSBjeHQ7XG4gICAgZ2VuLmlmKGl0LnBhcmVudERhdGEsICgpID0+IGdlbi5hc3NpZ24oZGF0YSwgKDAsIGNvZGVnZW5fMS5fKSBgJHtpdC5wYXJlbnREYXRhfVske2l0LnBhcmVudERhdGFQcm9wZXJ0eX1dYCkpO1xufVxuZnVuY3Rpb24gYWRkRXJycyhjeHQsIGVycnMpIHtcbiAgICBjb25zdCB7IGdlbiB9ID0gY3h0O1xuICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGBBcnJheS5pc0FycmF5KCR7ZXJyc30pYCwgKCkgPT4ge1xuICAgICAgICBnZW5cbiAgICAgICAgICAgIC5hc3NpZ24obmFtZXNfMS5kZWZhdWx0LnZFcnJvcnMsICgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9ID09PSBudWxsID8gJHtlcnJzfSA6ICR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9LmNvbmNhdCgke2VycnN9KWApXG4gICAgICAgICAgICAuYXNzaWduKG5hbWVzXzEuZGVmYXVsdC5lcnJvcnMsICgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9Lmxlbmd0aGApO1xuICAgICAgICAoMCwgZXJyb3JzXzEuZXh0ZW5kRXJyb3JzKShjeHQpO1xuICAgIH0sICgpID0+IGN4dC5lcnJvcigpKTtcbn1cbmZ1bmN0aW9uIGNoZWNrQXN5bmNLZXl3b3JkKHsgc2NoZW1hRW52IH0sIGRlZikge1xuICAgIGlmIChkZWYuYXN5bmMgJiYgIXNjaGVtYUVudi4kYXN5bmMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImFzeW5jIGtleXdvcmQgaW4gc3luYyBzY2hlbWFcIik7XG59XG5mdW5jdGlvbiB1c2VLZXl3b3JkKGdlbiwga2V5d29yZCwgcmVzdWx0KSB7XG4gICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGtleXdvcmQgXCIke2tleXdvcmR9XCIgZmFpbGVkIHRvIGNvbXBpbGVgKTtcbiAgICByZXR1cm4gZ2VuLnNjb3BlVmFsdWUoXCJrZXl3b3JkXCIsIHR5cGVvZiByZXN1bHQgPT0gXCJmdW5jdGlvblwiID8geyByZWY6IHJlc3VsdCB9IDogeyByZWY6IHJlc3VsdCwgY29kZTogKDAsIGNvZGVnZW5fMS5zdHJpbmdpZnkpKHJlc3VsdCkgfSk7XG59XG5mdW5jdGlvbiB2YWxpZFNjaGVtYVR5cGUoc2NoZW1hLCBzY2hlbWFUeXBlLCBhbGxvd1VuZGVmaW5lZCA9IGZhbHNlKSB7XG4gICAgLy8gVE9ETyBhZGQgdGVzdHNcbiAgICByZXR1cm4gKCFzY2hlbWFUeXBlLmxlbmd0aCB8fFxuICAgICAgICBzY2hlbWFUeXBlLnNvbWUoKHN0KSA9PiBzdCA9PT0gXCJhcnJheVwiXG4gICAgICAgICAgICA/IEFycmF5LmlzQXJyYXkoc2NoZW1hKVxuICAgICAgICAgICAgOiBzdCA9PT0gXCJvYmplY3RcIlxuICAgICAgICAgICAgICAgID8gc2NoZW1hICYmIHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShzY2hlbWEpXG4gICAgICAgICAgICAgICAgOiB0eXBlb2Ygc2NoZW1hID09IHN0IHx8IChhbGxvd1VuZGVmaW5lZCAmJiB0eXBlb2Ygc2NoZW1hID09IFwidW5kZWZpbmVkXCIpKSk7XG59XG5leHBvcnRzLnZhbGlkU2NoZW1hVHlwZSA9IHZhbGlkU2NoZW1hVHlwZTtcbmZ1bmN0aW9uIHZhbGlkYXRlS2V5d29yZFVzYWdlKHsgc2NoZW1hLCBvcHRzLCBzZWxmLCBlcnJTY2hlbWFQYXRoIH0sIGRlZiwga2V5d29yZCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChBcnJheS5pc0FycmF5KGRlZi5rZXl3b3JkKSA/ICFkZWYua2V5d29yZC5pbmNsdWRlcyhrZXl3b3JkKSA6IGRlZi5rZXl3b3JkICE9PSBrZXl3b3JkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImFqdiBpbXBsZW1lbnRhdGlvbiBlcnJvclwiKTtcbiAgICB9XG4gICAgY29uc3QgZGVwcyA9IGRlZi5kZXBlbmRlbmNpZXM7XG4gICAgaWYgKGRlcHMgPT09IG51bGwgfHwgZGVwcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVwcy5zb21lKChrd2QpID0+ICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2NoZW1hLCBrd2QpKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHBhcmVudCBzY2hlbWEgbXVzdCBoYXZlIGRlcGVuZGVuY2llcyBvZiAke2tleXdvcmR9OiAke2RlcHMuam9pbihcIixcIil9YCk7XG4gICAgfVxuICAgIGlmIChkZWYudmFsaWRhdGVTY2hlbWEpIHtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBkZWYudmFsaWRhdGVTY2hlbWEoc2NoZW1hW2tleXdvcmRdKTtcbiAgICAgICAgaWYgKCF2YWxpZCkge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gYGtleXdvcmQgXCIke2tleXdvcmR9XCIgdmFsdWUgaXMgaW52YWxpZCBhdCBwYXRoIFwiJHtlcnJTY2hlbWFQYXRofVwiOiBgICtcbiAgICAgICAgICAgICAgICBzZWxmLmVycm9yc1RleHQoZGVmLnZhbGlkYXRlU2NoZW1hLmVycm9ycyk7XG4gICAgICAgICAgICBpZiAob3B0cy52YWxpZGF0ZVNjaGVtYSA9PT0gXCJsb2dcIilcbiAgICAgICAgICAgICAgICBzZWxmLmxvZ2dlci5lcnJvcihtc2cpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZUtleXdvcmRVc2FnZSA9IHZhbGlkYXRlS2V5d29yZFVzYWdlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9a2V5d29yZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZXh0ZW5kU3Vic2NoZW1hTW9kZSA9IGV4cG9ydHMuZXh0ZW5kU3Vic2NoZW1hRGF0YSA9IGV4cG9ydHMuZ2V0U3Vic2NoZW1hID0gdm9pZCAwO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmZ1bmN0aW9uIGdldFN1YnNjaGVtYShpdCwgeyBrZXl3b3JkLCBzY2hlbWFQcm9wLCBzY2hlbWEsIHNjaGVtYVBhdGgsIGVyclNjaGVtYVBhdGgsIHRvcFNjaGVtYVJlZiB9KSB7XG4gICAgaWYgKGtleXdvcmQgIT09IHVuZGVmaW5lZCAmJiBzY2hlbWEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JvdGggXCJrZXl3b3JkXCIgYW5kIFwic2NoZW1hXCIgcGFzc2VkLCBvbmx5IG9uZSBhbGxvd2VkJyk7XG4gICAgfVxuICAgIGlmIChrZXl3b3JkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3Qgc2NoID0gaXQuc2NoZW1hW2tleXdvcmRdO1xuICAgICAgICByZXR1cm4gc2NoZW1hUHJvcCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBzY2hlbWE6IHNjaCxcbiAgICAgICAgICAgICAgICBzY2hlbWFQYXRoOiAoMCwgY29kZWdlbl8xLl8pIGAke2l0LnNjaGVtYVBhdGh9JHsoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KShrZXl3b3JkKX1gLFxuICAgICAgICAgICAgICAgIGVyclNjaGVtYVBhdGg6IGAke2l0LmVyclNjaGVtYVBhdGh9LyR7a2V5d29yZH1gLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgc2NoZW1hOiBzY2hbc2NoZW1hUHJvcF0sXG4gICAgICAgICAgICAgICAgc2NoZW1hUGF0aDogKDAsIGNvZGVnZW5fMS5fKSBgJHtpdC5zY2hlbWFQYXRofSR7KDAsIGNvZGVnZW5fMS5nZXRQcm9wZXJ0eSkoa2V5d29yZCl9JHsoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KShzY2hlbWFQcm9wKX1gLFxuICAgICAgICAgICAgICAgIGVyclNjaGVtYVBhdGg6IGAke2l0LmVyclNjaGVtYVBhdGh9LyR7a2V5d29yZH0vJHsoMCwgdXRpbF8xLmVzY2FwZUZyYWdtZW50KShzY2hlbWFQcm9wKX1gLFxuICAgICAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChzY2hlbWFQYXRoID09PSB1bmRlZmluZWQgfHwgZXJyU2NoZW1hUGF0aCA9PT0gdW5kZWZpbmVkIHx8IHRvcFNjaGVtYVJlZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wic2NoZW1hUGF0aFwiLCBcImVyclNjaGVtYVBhdGhcIiBhbmQgXCJ0b3BTY2hlbWFSZWZcIiBhcmUgcmVxdWlyZWQgd2l0aCBcInNjaGVtYVwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNjaGVtYSxcbiAgICAgICAgICAgIHNjaGVtYVBhdGgsXG4gICAgICAgICAgICB0b3BTY2hlbWFSZWYsXG4gICAgICAgICAgICBlcnJTY2hlbWFQYXRoLFxuICAgICAgICB9O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2VpdGhlciBcImtleXdvcmRcIiBvciBcInNjaGVtYVwiIG11c3QgYmUgcGFzc2VkJyk7XG59XG5leHBvcnRzLmdldFN1YnNjaGVtYSA9IGdldFN1YnNjaGVtYTtcbmZ1bmN0aW9uIGV4dGVuZFN1YnNjaGVtYURhdGEoc3Vic2NoZW1hLCBpdCwgeyBkYXRhUHJvcCwgZGF0YVByb3BUeXBlOiBkcFR5cGUsIGRhdGEsIGRhdGFUeXBlcywgcHJvcGVydHlOYW1lIH0pIHtcbiAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkICYmIGRhdGFQcm9wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdib3RoIFwiZGF0YVwiIGFuZCBcImRhdGFQcm9wXCIgcGFzc2VkLCBvbmx5IG9uZSBhbGxvd2VkJyk7XG4gICAgfVxuICAgIGNvbnN0IHsgZ2VuIH0gPSBpdDtcbiAgICBpZiAoZGF0YVByb3AgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCB7IGVycm9yUGF0aCwgZGF0YVBhdGhBcnIsIG9wdHMgfSA9IGl0O1xuICAgICAgICBjb25zdCBuZXh0RGF0YSA9IGdlbi5sZXQoXCJkYXRhXCIsICgwLCBjb2RlZ2VuXzEuXykgYCR7aXQuZGF0YX0keygwLCBjb2RlZ2VuXzEuZ2V0UHJvcGVydHkpKGRhdGFQcm9wKX1gLCB0cnVlKTtcbiAgICAgICAgZGF0YUNvbnRleHRQcm9wcyhuZXh0RGF0YSk7XG4gICAgICAgIHN1YnNjaGVtYS5lcnJvclBhdGggPSAoMCwgY29kZWdlbl8xLnN0cikgYCR7ZXJyb3JQYXRofSR7KDAsIHV0aWxfMS5nZXRFcnJvclBhdGgpKGRhdGFQcm9wLCBkcFR5cGUsIG9wdHMuanNQcm9wZXJ0eVN5bnRheCl9YDtcbiAgICAgICAgc3Vic2NoZW1hLnBhcmVudERhdGFQcm9wZXJ0eSA9ICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YVByb3B9YDtcbiAgICAgICAgc3Vic2NoZW1hLmRhdGFQYXRoQXJyID0gWy4uLmRhdGFQYXRoQXJyLCBzdWJzY2hlbWEucGFyZW50RGF0YVByb3BlcnR5XTtcbiAgICB9XG4gICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBuZXh0RGF0YSA9IGRhdGEgaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSA/IGRhdGEgOiBnZW4ubGV0KFwiZGF0YVwiLCBkYXRhLCB0cnVlKTsgLy8gcmVwbGFjZWFibGUgaWYgdXNlZCBvbmNlP1xuICAgICAgICBkYXRhQ29udGV4dFByb3BzKG5leHREYXRhKTtcbiAgICAgICAgaWYgKHByb3BlcnR5TmFtZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgc3Vic2NoZW1hLnByb3BlcnR5TmFtZSA9IHByb3BlcnR5TmFtZTtcbiAgICAgICAgLy8gVE9ETyBzb21ldGhpbmcgaXMgcG9zc2libHkgd3JvbmcgaGVyZSB3aXRoIG5vdCBjaGFuZ2luZyBwYXJlbnREYXRhUHJvcGVydHkgYW5kIG5vdCBhcHBlbmRpbmcgZGF0YVBhdGhBcnJcbiAgICB9XG4gICAgaWYgKGRhdGFUeXBlcylcbiAgICAgICAgc3Vic2NoZW1hLmRhdGFUeXBlcyA9IGRhdGFUeXBlcztcbiAgICBmdW5jdGlvbiBkYXRhQ29udGV4dFByb3BzKF9uZXh0RGF0YSkge1xuICAgICAgICBzdWJzY2hlbWEuZGF0YSA9IF9uZXh0RGF0YTtcbiAgICAgICAgc3Vic2NoZW1hLmRhdGFMZXZlbCA9IGl0LmRhdGFMZXZlbCArIDE7XG4gICAgICAgIHN1YnNjaGVtYS5kYXRhVHlwZXMgPSBbXTtcbiAgICAgICAgaXQuZGVmaW5lZFByb3BlcnRpZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHN1YnNjaGVtYS5wYXJlbnREYXRhID0gaXQuZGF0YTtcbiAgICAgICAgc3Vic2NoZW1hLmRhdGFOYW1lcyA9IFsuLi5pdC5kYXRhTmFtZXMsIF9uZXh0RGF0YV07XG4gICAgfVxufVxuZXhwb3J0cy5leHRlbmRTdWJzY2hlbWFEYXRhID0gZXh0ZW5kU3Vic2NoZW1hRGF0YTtcbmZ1bmN0aW9uIGV4dGVuZFN1YnNjaGVtYU1vZGUoc3Vic2NoZW1hLCB7IGp0ZERpc2NyaW1pbmF0b3IsIGp0ZE1ldGFkYXRhLCBjb21wb3NpdGVSdWxlLCBjcmVhdGVFcnJvcnMsIGFsbEVycm9ycyB9KSB7XG4gICAgaWYgKGNvbXBvc2l0ZVJ1bGUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgc3Vic2NoZW1hLmNvbXBvc2l0ZVJ1bGUgPSBjb21wb3NpdGVSdWxlO1xuICAgIGlmIChjcmVhdGVFcnJvcnMgIT09IHVuZGVmaW5lZClcbiAgICAgICAgc3Vic2NoZW1hLmNyZWF0ZUVycm9ycyA9IGNyZWF0ZUVycm9ycztcbiAgICBpZiAoYWxsRXJyb3JzICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHN1YnNjaGVtYS5hbGxFcnJvcnMgPSBhbGxFcnJvcnM7XG4gICAgc3Vic2NoZW1hLmp0ZERpc2NyaW1pbmF0b3IgPSBqdGREaXNjcmltaW5hdG9yOyAvLyBub3QgaW5oZXJpdGVkXG4gICAgc3Vic2NoZW1hLmp0ZE1ldGFkYXRhID0ganRkTWV0YWRhdGE7IC8vIG5vdCBpbmhlcml0ZWRcbn1cbmV4cG9ydHMuZXh0ZW5kU3Vic2NoZW1hTW9kZSA9IGV4dGVuZFN1YnNjaGVtYU1vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdWJzY2hlbWEuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBkbyBub3QgZWRpdCAuanMgZmlsZXMgZGlyZWN0bHkgLSBlZGl0IHNyYy9pbmRleC5qc3RcblxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXF1YWwoYSwgYikge1xuICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWU7XG5cbiAgaWYgKGEgJiYgYiAmJiB0eXBlb2YgYSA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgYiA9PSAnb2JqZWN0Jykge1xuICAgIGlmIChhLmNvbnN0cnVjdG9yICE9PSBiLmNvbnN0cnVjdG9yKSByZXR1cm4gZmFsc2U7XG5cbiAgICB2YXIgbGVuZ3RoLCBpLCBrZXlzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggIT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOylcbiAgICAgICAgaWYgKCFlcXVhbChhW2ldLCBiW2ldKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG5cblxuICAgIGlmIChhLmNvbnN0cnVjdG9yID09PSBSZWdFeHApIHJldHVybiBhLnNvdXJjZSA9PT0gYi5zb3VyY2UgJiYgYS5mbGFncyA9PT0gYi5mbGFncztcbiAgICBpZiAoYS52YWx1ZU9mICE9PSBPYmplY3QucHJvdG90eXBlLnZhbHVlT2YpIHJldHVybiBhLnZhbHVlT2YoKSA9PT0gYi52YWx1ZU9mKCk7XG4gICAgaWYgKGEudG9TdHJpbmcgIT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpIHJldHVybiBhLnRvU3RyaW5nKCkgPT09IGIudG9TdHJpbmcoKTtcblxuICAgIGtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoICE9PSBPYmplY3Qua2V5cyhiKS5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOylcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIGtleXNbaV0pKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoIWVxdWFsKGFba2V5XSwgYltrZXldKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gdHJ1ZSBpZiBib3RoIE5hTiwgZmFsc2Ugb3RoZXJ3aXNlXG4gIHJldHVybiBhIT09YSAmJiBiIT09Yjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB0cmF2ZXJzZSA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNjaGVtYSwgb3B0cywgY2IpIHtcbiAgLy8gTGVnYWN5IHN1cHBvcnQgZm9yIHYwLjMuMSBhbmQgZWFybGllci5cbiAgaWYgKHR5cGVvZiBvcHRzID09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG5cbiAgY2IgPSBvcHRzLmNiIHx8IGNiO1xuICB2YXIgcHJlID0gKHR5cGVvZiBjYiA9PSAnZnVuY3Rpb24nKSA/IGNiIDogY2IucHJlIHx8IGZ1bmN0aW9uKCkge307XG4gIHZhciBwb3N0ID0gY2IucG9zdCB8fCBmdW5jdGlvbigpIHt9O1xuXG4gIF90cmF2ZXJzZShvcHRzLCBwcmUsIHBvc3QsIHNjaGVtYSwgJycsIHNjaGVtYSk7XG59O1xuXG5cbnRyYXZlcnNlLmtleXdvcmRzID0ge1xuICBhZGRpdGlvbmFsSXRlbXM6IHRydWUsXG4gIGl0ZW1zOiB0cnVlLFxuICBjb250YWluczogdHJ1ZSxcbiAgYWRkaXRpb25hbFByb3BlcnRpZXM6IHRydWUsXG4gIHByb3BlcnR5TmFtZXM6IHRydWUsXG4gIG5vdDogdHJ1ZSxcbiAgaWY6IHRydWUsXG4gIHRoZW46IHRydWUsXG4gIGVsc2U6IHRydWVcbn07XG5cbnRyYXZlcnNlLmFycmF5S2V5d29yZHMgPSB7XG4gIGl0ZW1zOiB0cnVlLFxuICBhbGxPZjogdHJ1ZSxcbiAgYW55T2Y6IHRydWUsXG4gIG9uZU9mOiB0cnVlXG59O1xuXG50cmF2ZXJzZS5wcm9wc0tleXdvcmRzID0ge1xuICAkZGVmczogdHJ1ZSxcbiAgZGVmaW5pdGlvbnM6IHRydWUsXG4gIHByb3BlcnRpZXM6IHRydWUsXG4gIHBhdHRlcm5Qcm9wZXJ0aWVzOiB0cnVlLFxuICBkZXBlbmRlbmNpZXM6IHRydWVcbn07XG5cbnRyYXZlcnNlLnNraXBLZXl3b3JkcyA9IHtcbiAgZGVmYXVsdDogdHJ1ZSxcbiAgZW51bTogdHJ1ZSxcbiAgY29uc3Q6IHRydWUsXG4gIHJlcXVpcmVkOiB0cnVlLFxuICBtYXhpbXVtOiB0cnVlLFxuICBtaW5pbXVtOiB0cnVlLFxuICBleGNsdXNpdmVNYXhpbXVtOiB0cnVlLFxuICBleGNsdXNpdmVNaW5pbXVtOiB0cnVlLFxuICBtdWx0aXBsZU9mOiB0cnVlLFxuICBtYXhMZW5ndGg6IHRydWUsXG4gIG1pbkxlbmd0aDogdHJ1ZSxcbiAgcGF0dGVybjogdHJ1ZSxcbiAgZm9ybWF0OiB0cnVlLFxuICBtYXhJdGVtczogdHJ1ZSxcbiAgbWluSXRlbXM6IHRydWUsXG4gIHVuaXF1ZUl0ZW1zOiB0cnVlLFxuICBtYXhQcm9wZXJ0aWVzOiB0cnVlLFxuICBtaW5Qcm9wZXJ0aWVzOiB0cnVlXG59O1xuXG5cbmZ1bmN0aW9uIF90cmF2ZXJzZShvcHRzLCBwcmUsIHBvc3QsIHNjaGVtYSwganNvblB0ciwgcm9vdFNjaGVtYSwgcGFyZW50SnNvblB0ciwgcGFyZW50S2V5d29yZCwgcGFyZW50U2NoZW1hLCBrZXlJbmRleCkge1xuICBpZiAoc2NoZW1hICYmIHR5cGVvZiBzY2hlbWEgPT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoc2NoZW1hKSkge1xuICAgIHByZShzY2hlbWEsIGpzb25QdHIsIHJvb3RTY2hlbWEsIHBhcmVudEpzb25QdHIsIHBhcmVudEtleXdvcmQsIHBhcmVudFNjaGVtYSwga2V5SW5kZXgpO1xuICAgIGZvciAodmFyIGtleSBpbiBzY2hlbWEpIHtcbiAgICAgIHZhciBzY2ggPSBzY2hlbWFba2V5XTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaCkpIHtcbiAgICAgICAgaWYgKGtleSBpbiB0cmF2ZXJzZS5hcnJheUtleXdvcmRzKSB7XG4gICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHNjaC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIF90cmF2ZXJzZShvcHRzLCBwcmUsIHBvc3QsIHNjaFtpXSwganNvblB0ciArICcvJyArIGtleSArICcvJyArIGksIHJvb3RTY2hlbWEsIGpzb25QdHIsIGtleSwgc2NoZW1hLCBpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChrZXkgaW4gdHJhdmVyc2UucHJvcHNLZXl3b3Jkcykge1xuICAgICAgICBpZiAoc2NoICYmIHR5cGVvZiBzY2ggPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIHNjaClcbiAgICAgICAgICAgIF90cmF2ZXJzZShvcHRzLCBwcmUsIHBvc3QsIHNjaFtwcm9wXSwganNvblB0ciArICcvJyArIGtleSArICcvJyArIGVzY2FwZUpzb25QdHIocHJvcCksIHJvb3RTY2hlbWEsIGpzb25QdHIsIGtleSwgc2NoZW1hLCBwcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChrZXkgaW4gdHJhdmVyc2Uua2V5d29yZHMgfHwgKG9wdHMuYWxsS2V5cyAmJiAhKGtleSBpbiB0cmF2ZXJzZS5za2lwS2V5d29yZHMpKSkge1xuICAgICAgICBfdHJhdmVyc2Uob3B0cywgcHJlLCBwb3N0LCBzY2gsIGpzb25QdHIgKyAnLycgKyBrZXksIHJvb3RTY2hlbWEsIGpzb25QdHIsIGtleSwgc2NoZW1hKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcG9zdChzY2hlbWEsIGpzb25QdHIsIHJvb3RTY2hlbWEsIHBhcmVudEpzb25QdHIsIHBhcmVudEtleXdvcmQsIHBhcmVudFNjaGVtYSwga2V5SW5kZXgpO1xuICB9XG59XG5cblxuZnVuY3Rpb24gZXNjYXBlSnNvblB0cihzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9+L2csICd+MCcpLnJlcGxhY2UoL1xcLy9nLCAnfjEnKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRTY2hlbWFSZWZzID0gZXhwb3J0cy5yZXNvbHZlVXJsID0gZXhwb3J0cy5ub3JtYWxpemVJZCA9IGV4cG9ydHMuX2dldEZ1bGxQYXRoID0gZXhwb3J0cy5nZXRGdWxsUGF0aCA9IGV4cG9ydHMuaW5saW5lUmVmID0gdm9pZCAwO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbmNvbnN0IGVxdWFsID0gcmVxdWlyZShcImZhc3QtZGVlcC1lcXVhbFwiKTtcbmNvbnN0IHRyYXZlcnNlID0gcmVxdWlyZShcImpzb24tc2NoZW1hLXRyYXZlcnNlXCIpO1xuLy8gVE9ETyByZWZhY3RvciB0byB1c2Uga2V5d29yZCBkZWZpbml0aW9uc1xuY29uc3QgU0lNUExFX0lOTElORUQgPSBuZXcgU2V0KFtcbiAgICBcInR5cGVcIixcbiAgICBcImZvcm1hdFwiLFxuICAgIFwicGF0dGVyblwiLFxuICAgIFwibWF4TGVuZ3RoXCIsXG4gICAgXCJtaW5MZW5ndGhcIixcbiAgICBcIm1heFByb3BlcnRpZXNcIixcbiAgICBcIm1pblByb3BlcnRpZXNcIixcbiAgICBcIm1heEl0ZW1zXCIsXG4gICAgXCJtaW5JdGVtc1wiLFxuICAgIFwibWF4aW11bVwiLFxuICAgIFwibWluaW11bVwiLFxuICAgIFwidW5pcXVlSXRlbXNcIixcbiAgICBcIm11bHRpcGxlT2ZcIixcbiAgICBcInJlcXVpcmVkXCIsXG4gICAgXCJlbnVtXCIsXG4gICAgXCJjb25zdFwiLFxuXSk7XG5mdW5jdGlvbiBpbmxpbmVSZWYoc2NoZW1hLCBsaW1pdCA9IHRydWUpIHtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKGxpbWl0ID09PSB0cnVlKVxuICAgICAgICByZXR1cm4gIWhhc1JlZihzY2hlbWEpO1xuICAgIGlmICghbGltaXQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gY291bnRLZXlzKHNjaGVtYSkgPD0gbGltaXQ7XG59XG5leHBvcnRzLmlubGluZVJlZiA9IGlubGluZVJlZjtcbmNvbnN0IFJFRl9LRVlXT1JEUyA9IG5ldyBTZXQoW1xuICAgIFwiJHJlZlwiLFxuICAgIFwiJHJlY3Vyc2l2ZVJlZlwiLFxuICAgIFwiJHJlY3Vyc2l2ZUFuY2hvclwiLFxuICAgIFwiJGR5bmFtaWNSZWZcIixcbiAgICBcIiRkeW5hbWljQW5jaG9yXCIsXG5dKTtcbmZ1bmN0aW9uIGhhc1JlZihzY2hlbWEpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIHtcbiAgICAgICAgaWYgKFJFRl9LRVlXT1JEUy5oYXMoa2V5KSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjb25zdCBzY2ggPSBzY2hlbWFba2V5XTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoKSAmJiBzY2guc29tZShoYXNSZWYpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoID09IFwib2JqZWN0XCIgJiYgaGFzUmVmKHNjaCkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY291bnRLZXlzKHNjaGVtYSkge1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSB7XG4gICAgICAgIGlmIChrZXkgPT09IFwiJHJlZlwiKVxuICAgICAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgICBjb3VudCsrO1xuICAgICAgICBpZiAoU0lNUExFX0lOTElORUQuaGFzKGtleSkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWFba2V5XSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAoMCwgdXRpbF8xLmVhY2hJdGVtKShzY2hlbWFba2V5XSwgKHNjaCkgPT4gKGNvdW50ICs9IGNvdW50S2V5cyhzY2gpKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvdW50ID09PSBJbmZpbml0eSlcbiAgICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICB9XG4gICAgcmV0dXJuIGNvdW50O1xufVxuZnVuY3Rpb24gZ2V0RnVsbFBhdGgocmVzb2x2ZXIsIGlkID0gXCJcIiwgbm9ybWFsaXplKSB7XG4gICAgaWYgKG5vcm1hbGl6ZSAhPT0gZmFsc2UpXG4gICAgICAgIGlkID0gbm9ybWFsaXplSWQoaWQpO1xuICAgIGNvbnN0IHAgPSByZXNvbHZlci5wYXJzZShpZCk7XG4gICAgcmV0dXJuIF9nZXRGdWxsUGF0aChyZXNvbHZlciwgcCk7XG59XG5leHBvcnRzLmdldEZ1bGxQYXRoID0gZ2V0RnVsbFBhdGg7XG5mdW5jdGlvbiBfZ2V0RnVsbFBhdGgocmVzb2x2ZXIsIHApIHtcbiAgICBjb25zdCBzZXJpYWxpemVkID0gcmVzb2x2ZXIuc2VyaWFsaXplKHApO1xuICAgIHJldHVybiBzZXJpYWxpemVkLnNwbGl0KFwiI1wiKVswXSArIFwiI1wiO1xufVxuZXhwb3J0cy5fZ2V0RnVsbFBhdGggPSBfZ2V0RnVsbFBhdGg7XG5jb25zdCBUUkFJTElOR19TTEFTSF9IQVNIID0gLyNcXC8/JC87XG5mdW5jdGlvbiBub3JtYWxpemVJZChpZCkge1xuICAgIHJldHVybiBpZCA/IGlkLnJlcGxhY2UoVFJBSUxJTkdfU0xBU0hfSEFTSCwgXCJcIikgOiBcIlwiO1xufVxuZXhwb3J0cy5ub3JtYWxpemVJZCA9IG5vcm1hbGl6ZUlkO1xuZnVuY3Rpb24gcmVzb2x2ZVVybChyZXNvbHZlciwgYmFzZUlkLCBpZCkge1xuICAgIGlkID0gbm9ybWFsaXplSWQoaWQpO1xuICAgIHJldHVybiByZXNvbHZlci5yZXNvbHZlKGJhc2VJZCwgaWQpO1xufVxuZXhwb3J0cy5yZXNvbHZlVXJsID0gcmVzb2x2ZVVybDtcbmNvbnN0IEFOQ0hPUiA9IC9eW2Etel9dWy1hLXowLTkuX10qJC9pO1xuZnVuY3Rpb24gZ2V0U2NoZW1hUmVmcyhzY2hlbWEsIGJhc2VJZCkge1xuICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKVxuICAgICAgICByZXR1cm4ge307XG4gICAgY29uc3QgeyBzY2hlbWFJZCwgdXJpUmVzb2x2ZXIgfSA9IHRoaXMub3B0cztcbiAgICBjb25zdCBzY2hJZCA9IG5vcm1hbGl6ZUlkKHNjaGVtYVtzY2hlbWFJZF0gfHwgYmFzZUlkKTtcbiAgICBjb25zdCBiYXNlSWRzID0geyBcIlwiOiBzY2hJZCB9O1xuICAgIGNvbnN0IHBhdGhQcmVmaXggPSBnZXRGdWxsUGF0aCh1cmlSZXNvbHZlciwgc2NoSWQsIGZhbHNlKTtcbiAgICBjb25zdCBsb2NhbFJlZnMgPSB7fTtcbiAgICBjb25zdCBzY2hlbWFSZWZzID0gbmV3IFNldCgpO1xuICAgIHRyYXZlcnNlKHNjaGVtYSwgeyBhbGxLZXlzOiB0cnVlIH0sIChzY2gsIGpzb25QdHIsIF8sIHBhcmVudEpzb25QdHIpID0+IHtcbiAgICAgICAgaWYgKHBhcmVudEpzb25QdHIgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgZnVsbFBhdGggPSBwYXRoUHJlZml4ICsganNvblB0cjtcbiAgICAgICAgbGV0IGlubmVyQmFzZUlkID0gYmFzZUlkc1twYXJlbnRKc29uUHRyXTtcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hbc2NoZW1hSWRdID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICBpbm5lckJhc2VJZCA9IGFkZFJlZi5jYWxsKHRoaXMsIHNjaFtzY2hlbWFJZF0pO1xuICAgICAgICBhZGRBbmNob3IuY2FsbCh0aGlzLCBzY2guJGFuY2hvcik7XG4gICAgICAgIGFkZEFuY2hvci5jYWxsKHRoaXMsIHNjaC4kZHluYW1pY0FuY2hvcik7XG4gICAgICAgIGJhc2VJZHNbanNvblB0cl0gPSBpbm5lckJhc2VJZDtcbiAgICAgICAgZnVuY3Rpb24gYWRkUmVmKHJlZikge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZFxuICAgICAgICAgICAgY29uc3QgX3Jlc29sdmUgPSB0aGlzLm9wdHMudXJpUmVzb2x2ZXIucmVzb2x2ZTtcbiAgICAgICAgICAgIHJlZiA9IG5vcm1hbGl6ZUlkKGlubmVyQmFzZUlkID8gX3Jlc29sdmUoaW5uZXJCYXNlSWQsIHJlZikgOiByZWYpO1xuICAgICAgICAgICAgaWYgKHNjaGVtYVJlZnMuaGFzKHJlZikpXG4gICAgICAgICAgICAgICAgdGhyb3cgYW1iaWd1b3MocmVmKTtcbiAgICAgICAgICAgIHNjaGVtYVJlZnMuYWRkKHJlZik7XG4gICAgICAgICAgICBsZXQgc2NoT3JSZWYgPSB0aGlzLnJlZnNbcmVmXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoT3JSZWYgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICBzY2hPclJlZiA9IHRoaXMucmVmc1tzY2hPclJlZl07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNjaE9yUmVmID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBjaGVja0FtYmlndW9zUmVmKHNjaCwgc2NoT3JSZWYuc2NoZW1hLCByZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVmICE9PSBub3JtYWxpemVJZChmdWxsUGF0aCkpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVmWzBdID09PSBcIiNcIikge1xuICAgICAgICAgICAgICAgICAgICBjaGVja0FtYmlndW9zUmVmKHNjaCwgbG9jYWxSZWZzW3JlZl0sIHJlZik7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsUmVmc1tyZWZdID0gc2NoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWZzW3JlZl0gPSBmdWxsUGF0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVmO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFkZEFuY2hvcihhbmNob3IpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYW5jaG9yID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFOQ0hPUi50ZXN0KGFuY2hvcikpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBhbmNob3IgXCIke2FuY2hvcn1cImApO1xuICAgICAgICAgICAgICAgIGFkZFJlZi5jYWxsKHRoaXMsIGAjJHthbmNob3J9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbG9jYWxSZWZzO1xuICAgIGZ1bmN0aW9uIGNoZWNrQW1iaWd1b3NSZWYoc2NoMSwgc2NoMiwgcmVmKSB7XG4gICAgICAgIGlmIChzY2gyICE9PSB1bmRlZmluZWQgJiYgIWVxdWFsKHNjaDEsIHNjaDIpKVxuICAgICAgICAgICAgdGhyb3cgYW1iaWd1b3MocmVmKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYW1iaWd1b3MocmVmKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoYHJlZmVyZW5jZSBcIiR7cmVmfVwiIHJlc29sdmVzIHRvIG1vcmUgdGhhbiBvbmUgc2NoZW1hYCk7XG4gICAgfVxufVxuZXhwb3J0cy5nZXRTY2hlbWFSZWZzID0gZ2V0U2NoZW1hUmVmcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldERhdGEgPSBleHBvcnRzLktleXdvcmRDeHQgPSBleHBvcnRzLnZhbGlkYXRlRnVuY3Rpb25Db2RlID0gdm9pZCAwO1xuY29uc3QgYm9vbFNjaGVtYV8xID0gcmVxdWlyZShcIi4vYm9vbFNjaGVtYVwiKTtcbmNvbnN0IGRhdGFUeXBlXzEgPSByZXF1aXJlKFwiLi9kYXRhVHlwZVwiKTtcbmNvbnN0IGFwcGxpY2FiaWxpdHlfMSA9IHJlcXVpcmUoXCIuL2FwcGxpY2FiaWxpdHlcIik7XG5jb25zdCBkYXRhVHlwZV8yID0gcmVxdWlyZShcIi4vZGF0YVR5cGVcIik7XG5jb25zdCBkZWZhdWx0c18xID0gcmVxdWlyZShcIi4vZGVmYXVsdHNcIik7XG5jb25zdCBrZXl3b3JkXzEgPSByZXF1aXJlKFwiLi9rZXl3b3JkXCIpO1xuY29uc3Qgc3Vic2NoZW1hXzEgPSByZXF1aXJlKFwiLi9zdWJzY2hlbWFcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vY29kZWdlblwiKTtcbmNvbnN0IG5hbWVzXzEgPSByZXF1aXJlKFwiLi4vbmFtZXNcIik7XG5jb25zdCByZXNvbHZlXzEgPSByZXF1aXJlKFwiLi4vcmVzb2x2ZVwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xuLy8gc2NoZW1hIGNvbXBpbGF0aW9uIC0gZ2VuZXJhdGVzIHZhbGlkYXRpb24gZnVuY3Rpb24sIHN1YnNjaGVtYUNvZGUgKGJlbG93KSBpcyB1c2VkIGZvciBzdWJzY2hlbWFzXG5mdW5jdGlvbiB2YWxpZGF0ZUZ1bmN0aW9uQ29kZShpdCkge1xuICAgIGlmIChpc1NjaGVtYU9iaihpdCkpIHtcbiAgICAgICAgY2hlY2tLZXl3b3JkcyhpdCk7XG4gICAgICAgIGlmIChzY2hlbWFDeHRIYXNSdWxlcyhpdCkpIHtcbiAgICAgICAgICAgIHRvcFNjaGVtYU9iakNvZGUoaXQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhbGlkYXRlRnVuY3Rpb24oaXQsICgpID0+ICgwLCBib29sU2NoZW1hXzEudG9wQm9vbE9yRW1wdHlTY2hlbWEpKGl0KSk7XG59XG5leHBvcnRzLnZhbGlkYXRlRnVuY3Rpb25Db2RlID0gdmFsaWRhdGVGdW5jdGlvbkNvZGU7XG5mdW5jdGlvbiB2YWxpZGF0ZUZ1bmN0aW9uKHsgZ2VuLCB2YWxpZGF0ZU5hbWUsIHNjaGVtYSwgc2NoZW1hRW52LCBvcHRzIH0sIGJvZHkpIHtcbiAgICBpZiAob3B0cy5jb2RlLmVzNSkge1xuICAgICAgICBnZW4uZnVuYyh2YWxpZGF0ZU5hbWUsICgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LmRhdGF9LCAke25hbWVzXzEuZGVmYXVsdC52YWxDeHR9YCwgc2NoZW1hRW52LiRhc3luYywgKCkgPT4ge1xuICAgICAgICAgICAgZ2VuLmNvZGUoKDAsIGNvZGVnZW5fMS5fKSBgXCJ1c2Ugc3RyaWN0XCI7ICR7ZnVuY1NvdXJjZVVybChzY2hlbWEsIG9wdHMpfWApO1xuICAgICAgICAgICAgZGVzdHJ1Y3R1cmVWYWxDeHRFUzUoZ2VuLCBvcHRzKTtcbiAgICAgICAgICAgIGdlbi5jb2RlKGJvZHkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdlbi5mdW5jKHZhbGlkYXRlTmFtZSwgKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQuZGF0YX0sICR7ZGVzdHJ1Y3R1cmVWYWxDeHQob3B0cyl9YCwgc2NoZW1hRW52LiRhc3luYywgKCkgPT4gZ2VuLmNvZGUoZnVuY1NvdXJjZVVybChzY2hlbWEsIG9wdHMpKS5jb2RlKGJvZHkpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkZXN0cnVjdHVyZVZhbEN4dChvcHRzKSB7XG4gICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuXykgYHske25hbWVzXzEuZGVmYXVsdC5pbnN0YW5jZVBhdGh9PVwiXCIsICR7bmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGF9LCAke25hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhUHJvcGVydHl9LCAke25hbWVzXzEuZGVmYXVsdC5yb290RGF0YX09JHtuYW1lc18xLmRlZmF1bHQuZGF0YX0ke29wdHMuZHluYW1pY1JlZiA/ICgwLCBjb2RlZ2VuXzEuXykgYCwgJHtuYW1lc18xLmRlZmF1bHQuZHluYW1pY0FuY2hvcnN9PXt9YCA6IGNvZGVnZW5fMS5uaWx9fT17fWA7XG59XG5mdW5jdGlvbiBkZXN0cnVjdHVyZVZhbEN4dEVTNShnZW4sIG9wdHMpIHtcbiAgICBnZW4uaWYobmFtZXNfMS5kZWZhdWx0LnZhbEN4dCwgKCkgPT4ge1xuICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5pbnN0YW5jZVBhdGgsICgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LnZhbEN4dH0uJHtuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRofWApO1xuICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhLCAoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC52YWxDeHR9LiR7bmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGF9YCk7XG4gICAgICAgIGdlbi52YXIobmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGFQcm9wZXJ0eSwgKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQudmFsQ3h0fS4ke25hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhUHJvcGVydHl9YCk7XG4gICAgICAgIGdlbi52YXIobmFtZXNfMS5kZWZhdWx0LnJvb3REYXRhLCAoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC52YWxDeHR9LiR7bmFtZXNfMS5kZWZhdWx0LnJvb3REYXRhfWApO1xuICAgICAgICBpZiAob3B0cy5keW5hbWljUmVmKVxuICAgICAgICAgICAgZ2VuLnZhcihuYW1lc18xLmRlZmF1bHQuZHluYW1pY0FuY2hvcnMsICgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LnZhbEN4dH0uJHtuYW1lc18xLmRlZmF1bHQuZHluYW1pY0FuY2hvcnN9YCk7XG4gICAgfSwgKCkgPT4ge1xuICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5pbnN0YW5jZVBhdGgsICgwLCBjb2RlZ2VuXzEuXykgYFwiXCJgKTtcbiAgICAgICAgZ2VuLnZhcihuYW1lc18xLmRlZmF1bHQucGFyZW50RGF0YSwgKDAsIGNvZGVnZW5fMS5fKSBgdW5kZWZpbmVkYCk7XG4gICAgICAgIGdlbi52YXIobmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGFQcm9wZXJ0eSwgKDAsIGNvZGVnZW5fMS5fKSBgdW5kZWZpbmVkYCk7XG4gICAgICAgIGdlbi52YXIobmFtZXNfMS5kZWZhdWx0LnJvb3REYXRhLCBuYW1lc18xLmRlZmF1bHQuZGF0YSk7XG4gICAgICAgIGlmIChvcHRzLmR5bmFtaWNSZWYpXG4gICAgICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5keW5hbWljQW5jaG9ycywgKDAsIGNvZGVnZW5fMS5fKSBge31gKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHRvcFNjaGVtYU9iakNvZGUoaXQpIHtcbiAgICBjb25zdCB7IHNjaGVtYSwgb3B0cywgZ2VuIH0gPSBpdDtcbiAgICB2YWxpZGF0ZUZ1bmN0aW9uKGl0LCAoKSA9PiB7XG4gICAgICAgIGlmIChvcHRzLiRjb21tZW50ICYmIHNjaGVtYS4kY29tbWVudClcbiAgICAgICAgICAgIGNvbW1lbnRLZXl3b3JkKGl0KTtcbiAgICAgICAgY2hlY2tOb0RlZmF1bHQoaXQpO1xuICAgICAgICBnZW4ubGV0KG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzLCBudWxsKTtcbiAgICAgICAgZ2VuLmxldChuYW1lc18xLmRlZmF1bHQuZXJyb3JzLCAwKTtcbiAgICAgICAgaWYgKG9wdHMudW5ldmFsdWF0ZWQpXG4gICAgICAgICAgICByZXNldEV2YWx1YXRlZChpdCk7XG4gICAgICAgIHR5cGVBbmRLZXl3b3JkcyhpdCk7XG4gICAgICAgIHJldHVyblJlc3VsdHMoaXQpO1xuICAgIH0pO1xuICAgIHJldHVybjtcbn1cbmZ1bmN0aW9uIHJlc2V0RXZhbHVhdGVkKGl0KSB7XG4gICAgLy8gVE9ETyBtYXliZSBzb21lIGhvb2sgdG8gZXhlY3V0ZSBpdCBpbiB0aGUgZW5kIHRvIGNoZWNrIHdoZXRoZXIgcHJvcHMvaXRlbXMgYXJlIE5hbWUsIGFzIGluIGFzc2lnbkV2YWx1YXRlZFxuICAgIGNvbnN0IHsgZ2VuLCB2YWxpZGF0ZU5hbWUgfSA9IGl0O1xuICAgIGl0LmV2YWx1YXRlZCA9IGdlbi5jb25zdChcImV2YWx1YXRlZFwiLCAoMCwgY29kZWdlbl8xLl8pIGAke3ZhbGlkYXRlTmFtZX0uZXZhbHVhdGVkYCk7XG4gICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7aXQuZXZhbHVhdGVkfS5keW5hbWljUHJvcHNgLCAoKSA9PiBnZW4uYXNzaWduKCgwLCBjb2RlZ2VuXzEuXykgYCR7aXQuZXZhbHVhdGVkfS5wcm9wc2AsICgwLCBjb2RlZ2VuXzEuXykgYHVuZGVmaW5lZGApKTtcbiAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtpdC5ldmFsdWF0ZWR9LmR5bmFtaWNJdGVtc2AsICgpID0+IGdlbi5hc3NpZ24oKDAsIGNvZGVnZW5fMS5fKSBgJHtpdC5ldmFsdWF0ZWR9Lml0ZW1zYCwgKDAsIGNvZGVnZW5fMS5fKSBgdW5kZWZpbmVkYCkpO1xufVxuZnVuY3Rpb24gZnVuY1NvdXJjZVVybChzY2hlbWEsIG9wdHMpIHtcbiAgICBjb25zdCBzY2hJZCA9IHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIiAmJiBzY2hlbWFbb3B0cy5zY2hlbWFJZF07XG4gICAgcmV0dXJuIHNjaElkICYmIChvcHRzLmNvZGUuc291cmNlIHx8IG9wdHMuY29kZS5wcm9jZXNzKSA/ICgwLCBjb2RlZ2VuXzEuXykgYC8qIyBzb3VyY2VVUkw9JHtzY2hJZH0gKi9gIDogY29kZWdlbl8xLm5pbDtcbn1cbi8vIHNjaGVtYSBjb21waWxhdGlvbiAtIHRoaXMgZnVuY3Rpb24gaXMgdXNlZCByZWN1cnNpdmVseSB0byBnZW5lcmF0ZSBjb2RlIGZvciBzdWItc2NoZW1hc1xuZnVuY3Rpb24gc3Vic2NoZW1hQ29kZShpdCwgdmFsaWQpIHtcbiAgICBpZiAoaXNTY2hlbWFPYmooaXQpKSB7XG4gICAgICAgIGNoZWNrS2V5d29yZHMoaXQpO1xuICAgICAgICBpZiAoc2NoZW1hQ3h0SGFzUnVsZXMoaXQpKSB7XG4gICAgICAgICAgICBzdWJTY2hlbWFPYmpDb2RlKGl0LCB2YWxpZCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgKDAsIGJvb2xTY2hlbWFfMS5ib29sT3JFbXB0eVNjaGVtYSkoaXQsIHZhbGlkKTtcbn1cbmZ1bmN0aW9uIHNjaGVtYUN4dEhhc1J1bGVzKHsgc2NoZW1hLCBzZWxmIH0pIHtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIilcbiAgICAgICAgcmV0dXJuICFzY2hlbWE7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKVxuICAgICAgICBpZiAoc2VsZi5SVUxFUy5hbGxba2V5XSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzU2NoZW1hT2JqKGl0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBpdC5zY2hlbWEgIT0gXCJib29sZWFuXCI7XG59XG5mdW5jdGlvbiBzdWJTY2hlbWFPYmpDb2RlKGl0LCB2YWxpZCkge1xuICAgIGNvbnN0IHsgc2NoZW1hLCBnZW4sIG9wdHMgfSA9IGl0O1xuICAgIGlmIChvcHRzLiRjb21tZW50ICYmIHNjaGVtYS4kY29tbWVudClcbiAgICAgICAgY29tbWVudEtleXdvcmQoaXQpO1xuICAgIHVwZGF0ZUNvbnRleHQoaXQpO1xuICAgIGNoZWNrQXN5bmNTY2hlbWEoaXQpO1xuICAgIGNvbnN0IGVycnNDb3VudCA9IGdlbi5jb25zdChcIl9lcnJzXCIsIG5hbWVzXzEuZGVmYXVsdC5lcnJvcnMpO1xuICAgIHR5cGVBbmRLZXl3b3JkcyhpdCwgZXJyc0NvdW50KTtcbiAgICAvLyBUT0RPIHZhclxuICAgIGdlbi52YXIodmFsaWQsICgwLCBjb2RlZ2VuXzEuXykgYCR7ZXJyc0NvdW50fSA9PT0gJHtuYW1lc18xLmRlZmF1bHQuZXJyb3JzfWApO1xufVxuZnVuY3Rpb24gY2hlY2tLZXl3b3JkcyhpdCkge1xuICAgICgwLCB1dGlsXzEuY2hlY2tVbmtub3duUnVsZXMpKGl0KTtcbiAgICBjaGVja1JlZnNBbmRLZXl3b3JkcyhpdCk7XG59XG5mdW5jdGlvbiB0eXBlQW5kS2V5d29yZHMoaXQsIGVycnNDb3VudCkge1xuICAgIGlmIChpdC5vcHRzLmp0ZClcbiAgICAgICAgcmV0dXJuIHNjaGVtYUtleXdvcmRzKGl0LCBbXSwgZmFsc2UsIGVycnNDb3VudCk7XG4gICAgY29uc3QgdHlwZXMgPSAoMCwgZGF0YVR5cGVfMS5nZXRTY2hlbWFUeXBlcykoaXQuc2NoZW1hKTtcbiAgICBjb25zdCBjaGVja2VkVHlwZXMgPSAoMCwgZGF0YVR5cGVfMS5jb2VyY2VBbmRDaGVja0RhdGFUeXBlKShpdCwgdHlwZXMpO1xuICAgIHNjaGVtYUtleXdvcmRzKGl0LCB0eXBlcywgIWNoZWNrZWRUeXBlcywgZXJyc0NvdW50KTtcbn1cbmZ1bmN0aW9uIGNoZWNrUmVmc0FuZEtleXdvcmRzKGl0KSB7XG4gICAgY29uc3QgeyBzY2hlbWEsIGVyclNjaGVtYVBhdGgsIG9wdHMsIHNlbGYgfSA9IGl0O1xuICAgIGlmIChzY2hlbWEuJHJlZiAmJiBvcHRzLmlnbm9yZUtleXdvcmRzV2l0aFJlZiAmJiAoMCwgdXRpbF8xLnNjaGVtYUhhc1J1bGVzQnV0UmVmKShzY2hlbWEsIHNlbGYuUlVMRVMpKSB7XG4gICAgICAgIHNlbGYubG9nZ2VyLndhcm4oYCRyZWY6IGtleXdvcmRzIGlnbm9yZWQgaW4gc2NoZW1hIGF0IHBhdGggXCIke2VyclNjaGVtYVBhdGh9XCJgKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja05vRGVmYXVsdChpdCkge1xuICAgIGNvbnN0IHsgc2NoZW1hLCBvcHRzIH0gPSBpdDtcbiAgICBpZiAoc2NoZW1hLmRlZmF1bHQgIT09IHVuZGVmaW5lZCAmJiBvcHRzLnVzZURlZmF1bHRzICYmIG9wdHMuc3RyaWN0U2NoZW1hKSB7XG4gICAgICAgICgwLCB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKShpdCwgXCJkZWZhdWx0IGlzIGlnbm9yZWQgaW4gdGhlIHNjaGVtYSByb290XCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZUNvbnRleHQoaXQpIHtcbiAgICBjb25zdCBzY2hJZCA9IGl0LnNjaGVtYVtpdC5vcHRzLnNjaGVtYUlkXTtcbiAgICBpZiAoc2NoSWQpXG4gICAgICAgIGl0LmJhc2VJZCA9ICgwLCByZXNvbHZlXzEucmVzb2x2ZVVybCkoaXQub3B0cy51cmlSZXNvbHZlciwgaXQuYmFzZUlkLCBzY2hJZCk7XG59XG5mdW5jdGlvbiBjaGVja0FzeW5jU2NoZW1hKGl0KSB7XG4gICAgaWYgKGl0LnNjaGVtYS4kYXN5bmMgJiYgIWl0LnNjaGVtYUVudi4kYXN5bmMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImFzeW5jIHNjaGVtYSBpbiBzeW5jIHNjaGVtYVwiKTtcbn1cbmZ1bmN0aW9uIGNvbW1lbnRLZXl3b3JkKHsgZ2VuLCBzY2hlbWFFbnYsIHNjaGVtYSwgZXJyU2NoZW1hUGF0aCwgb3B0cyB9KSB7XG4gICAgY29uc3QgbXNnID0gc2NoZW1hLiRjb21tZW50O1xuICAgIGlmIChvcHRzLiRjb21tZW50ID09PSB0cnVlKSB7XG4gICAgICAgIGdlbi5jb2RlKCgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LnNlbGZ9LmxvZ2dlci5sb2coJHttc2d9KWApO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Ygb3B0cy4kY29tbWVudCA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29uc3Qgc2NoZW1hUGF0aCA9ICgwLCBjb2RlZ2VuXzEuc3RyKSBgJHtlcnJTY2hlbWFQYXRofS8kY29tbWVudGA7XG4gICAgICAgIGNvbnN0IHJvb3ROYW1lID0gZ2VuLnNjb3BlVmFsdWUoXCJyb290XCIsIHsgcmVmOiBzY2hlbWFFbnYucm9vdCB9KTtcbiAgICAgICAgZ2VuLmNvZGUoKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQuc2VsZn0ub3B0cy4kY29tbWVudCgke21zZ30sICR7c2NoZW1hUGF0aH0sICR7cm9vdE5hbWV9LnNjaGVtYSlgKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZXR1cm5SZXN1bHRzKGl0KSB7XG4gICAgY29uc3QgeyBnZW4sIHNjaGVtYUVudiwgdmFsaWRhdGVOYW1lLCBWYWxpZGF0aW9uRXJyb3IsIG9wdHMgfSA9IGl0O1xuICAgIGlmIChzY2hlbWFFbnYuJGFzeW5jKSB7XG4gICAgICAgIC8vIFRPRE8gYXNzaWduIHVuZXZhbHVhdGVkXG4gICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC5lcnJvcnN9ID09PSAwYCwgKCkgPT4gZ2VuLnJldHVybihuYW1lc18xLmRlZmF1bHQuZGF0YSksICgpID0+IGdlbi50aHJvdygoMCwgY29kZWdlbl8xLl8pIGBuZXcgJHtWYWxpZGF0aW9uRXJyb3J9KCR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9KWApKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdlbi5hc3NpZ24oKDAsIGNvZGVnZW5fMS5fKSBgJHt2YWxpZGF0ZU5hbWV9LmVycm9yc2AsIG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzKTtcbiAgICAgICAgaWYgKG9wdHMudW5ldmFsdWF0ZWQpXG4gICAgICAgICAgICBhc3NpZ25FdmFsdWF0ZWQoaXQpO1xuICAgICAgICBnZW4ucmV0dXJuKCgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LmVycm9yc30gPT09IDBgKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhc3NpZ25FdmFsdWF0ZWQoeyBnZW4sIGV2YWx1YXRlZCwgcHJvcHMsIGl0ZW1zIH0pIHtcbiAgICBpZiAocHJvcHMgaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSlcbiAgICAgICAgZ2VuLmFzc2lnbigoMCwgY29kZWdlbl8xLl8pIGAke2V2YWx1YXRlZH0ucHJvcHNgLCBwcm9wcyk7XG4gICAgaWYgKGl0ZW1zIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUpXG4gICAgICAgIGdlbi5hc3NpZ24oKDAsIGNvZGVnZW5fMS5fKSBgJHtldmFsdWF0ZWR9Lml0ZW1zYCwgaXRlbXMpO1xufVxuZnVuY3Rpb24gc2NoZW1hS2V5d29yZHMoaXQsIHR5cGVzLCB0eXBlRXJyb3JzLCBlcnJzQ291bnQpIHtcbiAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBkYXRhLCBhbGxFcnJvcnMsIG9wdHMsIHNlbGYgfSA9IGl0O1xuICAgIGNvbnN0IHsgUlVMRVMgfSA9IHNlbGY7XG4gICAgaWYgKHNjaGVtYS4kcmVmICYmIChvcHRzLmlnbm9yZUtleXdvcmRzV2l0aFJlZiB8fCAhKDAsIHV0aWxfMS5zY2hlbWFIYXNSdWxlc0J1dFJlZikoc2NoZW1hLCBSVUxFUykpKSB7XG4gICAgICAgIGdlbi5ibG9jaygoKSA9PiBrZXl3b3JkQ29kZShpdCwgXCIkcmVmXCIsIFJVTEVTLmFsbC4kcmVmLmRlZmluaXRpb24pKTsgLy8gVE9ETyB0eXBlY2FzdFxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghb3B0cy5qdGQpXG4gICAgICAgIGNoZWNrU3RyaWN0VHlwZXMoaXQsIHR5cGVzKTtcbiAgICBnZW4uYmxvY2soKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIFJVTEVTLnJ1bGVzKVxuICAgICAgICAgICAgZ3JvdXBLZXl3b3Jkcyhncm91cCk7XG4gICAgICAgIGdyb3VwS2V5d29yZHMoUlVMRVMucG9zdCk7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gZ3JvdXBLZXl3b3Jkcyhncm91cCkge1xuICAgICAgICBpZiAoISgwLCBhcHBsaWNhYmlsaXR5XzEuc2hvdWxkVXNlR3JvdXApKHNjaGVtYSwgZ3JvdXApKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoZ3JvdXAudHlwZSkge1xuICAgICAgICAgICAgZ2VuLmlmKCgwLCBkYXRhVHlwZV8yLmNoZWNrRGF0YVR5cGUpKGdyb3VwLnR5cGUsIGRhdGEsIG9wdHMuc3RyaWN0TnVtYmVycykpO1xuICAgICAgICAgICAgaXRlcmF0ZUtleXdvcmRzKGl0LCBncm91cCk7XG4gICAgICAgICAgICBpZiAodHlwZXMubGVuZ3RoID09PSAxICYmIHR5cGVzWzBdID09PSBncm91cC50eXBlICYmIHR5cGVFcnJvcnMpIHtcbiAgICAgICAgICAgICAgICBnZW4uZWxzZSgpO1xuICAgICAgICAgICAgICAgICgwLCBkYXRhVHlwZV8yLnJlcG9ydFR5cGVFcnJvcikoaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2VuLmVuZElmKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpdGVyYXRlS2V5d29yZHMoaXQsIGdyb3VwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPIG1ha2UgaXQgXCJva1wiIGNhbGw/XG4gICAgICAgIGlmICghYWxsRXJyb3JzKVxuICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LmVycm9yc30gPT09ICR7ZXJyc0NvdW50IHx8IDB9YCk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXRlcmF0ZUtleXdvcmRzKGl0LCBncm91cCkge1xuICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIG9wdHM6IHsgdXNlRGVmYXVsdHMgfSwgfSA9IGl0O1xuICAgIGlmICh1c2VEZWZhdWx0cylcbiAgICAgICAgKDAsIGRlZmF1bHRzXzEuYXNzaWduRGVmYXVsdHMpKGl0LCBncm91cC50eXBlKTtcbiAgICBnZW4uYmxvY2soKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IHJ1bGUgb2YgZ3JvdXAucnVsZXMpIHtcbiAgICAgICAgICAgIGlmICgoMCwgYXBwbGljYWJpbGl0eV8xLnNob3VsZFVzZVJ1bGUpKHNjaGVtYSwgcnVsZSkpIHtcbiAgICAgICAgICAgICAgICBrZXl3b3JkQ29kZShpdCwgcnVsZS5rZXl3b3JkLCBydWxlLmRlZmluaXRpb24sIGdyb3VwLnR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBjaGVja1N0cmljdFR5cGVzKGl0LCB0eXBlcykge1xuICAgIGlmIChpdC5zY2hlbWFFbnYubWV0YSB8fCAhaXQub3B0cy5zdHJpY3RUeXBlcylcbiAgICAgICAgcmV0dXJuO1xuICAgIGNoZWNrQ29udGV4dFR5cGVzKGl0LCB0eXBlcyk7XG4gICAgaWYgKCFpdC5vcHRzLmFsbG93VW5pb25UeXBlcylcbiAgICAgICAgY2hlY2tNdWx0aXBsZVR5cGVzKGl0LCB0eXBlcyk7XG4gICAgY2hlY2tLZXl3b3JkVHlwZXMoaXQsIGl0LmRhdGFUeXBlcyk7XG59XG5mdW5jdGlvbiBjaGVja0NvbnRleHRUeXBlcyhpdCwgdHlwZXMpIHtcbiAgICBpZiAoIXR5cGVzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICghaXQuZGF0YVR5cGVzLmxlbmd0aCkge1xuICAgICAgICBpdC5kYXRhVHlwZXMgPSB0eXBlcztcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0eXBlcy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICAgIGlmICghaW5jbHVkZXNUeXBlKGl0LmRhdGFUeXBlcywgdCkpIHtcbiAgICAgICAgICAgIHN0cmljdFR5cGVzRXJyb3IoaXQsIGB0eXBlIFwiJHt0fVwiIG5vdCBhbGxvd2VkIGJ5IGNvbnRleHQgXCIke2l0LmRhdGFUeXBlcy5qb2luKFwiLFwiKX1cImApO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgbmFycm93U2NoZW1hVHlwZXMoaXQsIHR5cGVzKTtcbn1cbmZ1bmN0aW9uIGNoZWNrTXVsdGlwbGVUeXBlcyhpdCwgdHMpIHtcbiAgICBpZiAodHMubGVuZ3RoID4gMSAmJiAhKHRzLmxlbmd0aCA9PT0gMiAmJiB0cy5pbmNsdWRlcyhcIm51bGxcIikpKSB7XG4gICAgICAgIHN0cmljdFR5cGVzRXJyb3IoaXQsIFwidXNlIGFsbG93VW5pb25UeXBlcyB0byBhbGxvdyB1bmlvbiB0eXBlIGtleXdvcmRcIik7XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tLZXl3b3JkVHlwZXMoaXQsIHRzKSB7XG4gICAgY29uc3QgcnVsZXMgPSBpdC5zZWxmLlJVTEVTLmFsbDtcbiAgICBmb3IgKGNvbnN0IGtleXdvcmQgaW4gcnVsZXMpIHtcbiAgICAgICAgY29uc3QgcnVsZSA9IHJ1bGVzW2tleXdvcmRdO1xuICAgICAgICBpZiAodHlwZW9mIHJ1bGUgPT0gXCJvYmplY3RcIiAmJiAoMCwgYXBwbGljYWJpbGl0eV8xLnNob3VsZFVzZVJ1bGUpKGl0LnNjaGVtYSwgcnVsZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdHlwZSB9ID0gcnVsZS5kZWZpbml0aW9uO1xuICAgICAgICAgICAgaWYgKHR5cGUubGVuZ3RoICYmICF0eXBlLnNvbWUoKHQpID0+IGhhc0FwcGxpY2FibGVUeXBlKHRzLCB0KSkpIHtcbiAgICAgICAgICAgICAgICBzdHJpY3RUeXBlc0Vycm9yKGl0LCBgbWlzc2luZyB0eXBlIFwiJHt0eXBlLmpvaW4oXCIsXCIpfVwiIGZvciBrZXl3b3JkIFwiJHtrZXl3b3JkfVwiYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBoYXNBcHBsaWNhYmxlVHlwZShzY2hUcywga3dkVCkge1xuICAgIHJldHVybiBzY2hUcy5pbmNsdWRlcyhrd2RUKSB8fCAoa3dkVCA9PT0gXCJudW1iZXJcIiAmJiBzY2hUcy5pbmNsdWRlcyhcImludGVnZXJcIikpO1xufVxuZnVuY3Rpb24gaW5jbHVkZXNUeXBlKHRzLCB0KSB7XG4gICAgcmV0dXJuIHRzLmluY2x1ZGVzKHQpIHx8ICh0ID09PSBcImludGVnZXJcIiAmJiB0cy5pbmNsdWRlcyhcIm51bWJlclwiKSk7XG59XG5mdW5jdGlvbiBuYXJyb3dTY2hlbWFUeXBlcyhpdCwgd2l0aFR5cGVzKSB7XG4gICAgY29uc3QgdHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHQgb2YgaXQuZGF0YVR5cGVzKSB7XG4gICAgICAgIGlmIChpbmNsdWRlc1R5cGUod2l0aFR5cGVzLCB0KSlcbiAgICAgICAgICAgIHRzLnB1c2godCk7XG4gICAgICAgIGVsc2UgaWYgKHdpdGhUeXBlcy5pbmNsdWRlcyhcImludGVnZXJcIikgJiYgdCA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRzLnB1c2goXCJpbnRlZ2VyXCIpO1xuICAgIH1cbiAgICBpdC5kYXRhVHlwZXMgPSB0cztcbn1cbmZ1bmN0aW9uIHN0cmljdFR5cGVzRXJyb3IoaXQsIG1zZykge1xuICAgIGNvbnN0IHNjaGVtYVBhdGggPSBpdC5zY2hlbWFFbnYuYmFzZUlkICsgaXQuZXJyU2NoZW1hUGF0aDtcbiAgICBtc2cgKz0gYCBhdCBcIiR7c2NoZW1hUGF0aH1cIiAoc3RyaWN0VHlwZXMpYDtcbiAgICAoMCwgdXRpbF8xLmNoZWNrU3RyaWN0TW9kZSkoaXQsIG1zZywgaXQub3B0cy5zdHJpY3RUeXBlcyk7XG59XG5jbGFzcyBLZXl3b3JkQ3h0IHtcbiAgICBjb25zdHJ1Y3RvcihpdCwgZGVmLCBrZXl3b3JkKSB7XG4gICAgICAgICgwLCBrZXl3b3JkXzEudmFsaWRhdGVLZXl3b3JkVXNhZ2UpKGl0LCBkZWYsIGtleXdvcmQpO1xuICAgICAgICB0aGlzLmdlbiA9IGl0LmdlbjtcbiAgICAgICAgdGhpcy5hbGxFcnJvcnMgPSBpdC5hbGxFcnJvcnM7XG4gICAgICAgIHRoaXMua2V5d29yZCA9IGtleXdvcmQ7XG4gICAgICAgIHRoaXMuZGF0YSA9IGl0LmRhdGE7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gaXQuc2NoZW1hW2tleXdvcmRdO1xuICAgICAgICB0aGlzLiRkYXRhID0gZGVmLiRkYXRhICYmIGl0Lm9wdHMuJGRhdGEgJiYgdGhpcy5zY2hlbWEgJiYgdGhpcy5zY2hlbWEuJGRhdGE7XG4gICAgICAgIHRoaXMuc2NoZW1hVmFsdWUgPSAoMCwgdXRpbF8xLnNjaGVtYVJlZk9yVmFsKShpdCwgdGhpcy5zY2hlbWEsIGtleXdvcmQsIHRoaXMuJGRhdGEpO1xuICAgICAgICB0aGlzLnNjaGVtYVR5cGUgPSBkZWYuc2NoZW1hVHlwZTtcbiAgICAgICAgdGhpcy5wYXJlbnRTY2hlbWEgPSBpdC5zY2hlbWE7XG4gICAgICAgIHRoaXMucGFyYW1zID0ge307XG4gICAgICAgIHRoaXMuaXQgPSBpdDtcbiAgICAgICAgdGhpcy5kZWYgPSBkZWY7XG4gICAgICAgIGlmICh0aGlzLiRkYXRhKSB7XG4gICAgICAgICAgICB0aGlzLnNjaGVtYUNvZGUgPSBpdC5nZW4uY29uc3QoXCJ2U2NoZW1hXCIsIGdldERhdGEodGhpcy4kZGF0YSwgaXQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2NoZW1hQ29kZSA9IHRoaXMuc2NoZW1hVmFsdWU7XG4gICAgICAgICAgICBpZiAoISgwLCBrZXl3b3JkXzEudmFsaWRTY2hlbWFUeXBlKSh0aGlzLnNjaGVtYSwgZGVmLnNjaGVtYVR5cGUsIGRlZi5hbGxvd1VuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7a2V5d29yZH0gdmFsdWUgbXVzdCBiZSAke0pTT04uc3RyaW5naWZ5KGRlZi5zY2hlbWFUeXBlKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJjb2RlXCIgaW4gZGVmID8gZGVmLnRyYWNrRXJyb3JzIDogZGVmLmVycm9ycyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyc0NvdW50ID0gaXQuZ2VuLmNvbnN0KFwiX2VycnNcIiwgbmFtZXNfMS5kZWZhdWx0LmVycm9ycyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0KGNvbmRpdGlvbiwgc3VjY2Vzc0FjdGlvbiwgZmFpbEFjdGlvbikge1xuICAgICAgICB0aGlzLmZhaWxSZXN1bHQoKDAsIGNvZGVnZW5fMS5ub3QpKGNvbmRpdGlvbiksIHN1Y2Nlc3NBY3Rpb24sIGZhaWxBY3Rpb24pO1xuICAgIH1cbiAgICBmYWlsUmVzdWx0KGNvbmRpdGlvbiwgc3VjY2Vzc0FjdGlvbiwgZmFpbEFjdGlvbikge1xuICAgICAgICB0aGlzLmdlbi5pZihjb25kaXRpb24pO1xuICAgICAgICBpZiAoZmFpbEFjdGlvbilcbiAgICAgICAgICAgIGZhaWxBY3Rpb24oKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5lcnJvcigpO1xuICAgICAgICBpZiAoc3VjY2Vzc0FjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5nZW4uZWxzZSgpO1xuICAgICAgICAgICAgc3VjY2Vzc0FjdGlvbigpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgIHRoaXMuZ2VuLmVuZElmKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hbGxFcnJvcnMpXG4gICAgICAgICAgICAgICAgdGhpcy5nZW4uZW5kSWYoKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLmdlbi5lbHNlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGFzcyhjb25kaXRpb24sIGZhaWxBY3Rpb24pIHtcbiAgICAgICAgdGhpcy5mYWlsUmVzdWx0KCgwLCBjb2RlZ2VuXzEubm90KShjb25kaXRpb24pLCB1bmRlZmluZWQsIGZhaWxBY3Rpb24pO1xuICAgIH1cbiAgICBmYWlsKGNvbmRpdGlvbikge1xuICAgICAgICBpZiAoY29uZGl0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5hbGxFcnJvcnMpXG4gICAgICAgICAgICAgICAgdGhpcy5nZW4uaWYoZmFsc2UpOyAvLyB0aGlzIGJyYW5jaCB3aWxsIGJlIHJlbW92ZWQgYnkgZ2VuLm9wdGltaXplXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nZW4uaWYoY29uZGl0aW9uKTtcbiAgICAgICAgdGhpcy5lcnJvcigpO1xuICAgICAgICBpZiAodGhpcy5hbGxFcnJvcnMpXG4gICAgICAgICAgICB0aGlzLmdlbi5lbmRJZigpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmdlbi5lbHNlKCk7XG4gICAgfVxuICAgIGZhaWwkZGF0YShjb25kaXRpb24pIHtcbiAgICAgICAgaWYgKCF0aGlzLiRkYXRhKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmFpbChjb25kaXRpb24pO1xuICAgICAgICBjb25zdCB7IHNjaGVtYUNvZGUgfSA9IHRoaXM7XG4gICAgICAgIHRoaXMuZmFpbCgoMCwgY29kZWdlbl8xLl8pIGAke3NjaGVtYUNvZGV9ICE9PSB1bmRlZmluZWQgJiYgKCR7KDAsIGNvZGVnZW5fMS5vcikodGhpcy5pbnZhbGlkJGRhdGEoKSwgY29uZGl0aW9uKX0pYCk7XG4gICAgfVxuICAgIGVycm9yKGFwcGVuZCwgZXJyb3JQYXJhbXMsIGVycm9yUGF0aHMpIHtcbiAgICAgICAgaWYgKGVycm9yUGFyYW1zKSB7XG4gICAgICAgICAgICB0aGlzLnNldFBhcmFtcyhlcnJvclBhcmFtcyk7XG4gICAgICAgICAgICB0aGlzLl9lcnJvcihhcHBlbmQsIGVycm9yUGF0aHMpO1xuICAgICAgICAgICAgdGhpcy5zZXRQYXJhbXMoe30pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Vycm9yKGFwcGVuZCwgZXJyb3JQYXRocyk7XG4gICAgfVxuICAgIF9lcnJvcihhcHBlbmQsIGVycm9yUGF0aHMpIHtcbiAgICAgICAgO1xuICAgICAgICAoYXBwZW5kID8gZXJyb3JzXzEucmVwb3J0RXh0cmFFcnJvciA6IGVycm9yc18xLnJlcG9ydEVycm9yKSh0aGlzLCB0aGlzLmRlZi5lcnJvciwgZXJyb3JQYXRocyk7XG4gICAgfVxuICAgICRkYXRhRXJyb3IoKSB7XG4gICAgICAgICgwLCBlcnJvcnNfMS5yZXBvcnRFcnJvcikodGhpcywgdGhpcy5kZWYuJGRhdGFFcnJvciB8fCBlcnJvcnNfMS5rZXl3b3JkJERhdGFFcnJvcik7XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgICAgICBpZiAodGhpcy5lcnJzQ291bnQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYWRkIFwidHJhY2tFcnJvcnNcIiB0byBrZXl3b3JkIGRlZmluaXRpb24nKTtcbiAgICAgICAgKDAsIGVycm9yc18xLnJlc2V0RXJyb3JzQ291bnQpKHRoaXMuZ2VuLCB0aGlzLmVycnNDb3VudCk7XG4gICAgfVxuICAgIG9rKGNvbmQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFsbEVycm9ycylcbiAgICAgICAgICAgIHRoaXMuZ2VuLmlmKGNvbmQpO1xuICAgIH1cbiAgICBzZXRQYXJhbXMob2JqLCBhc3NpZ24pIHtcbiAgICAgICAgaWYgKGFzc2lnbilcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5wYXJhbXMsIG9iaik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMucGFyYW1zID0gb2JqO1xuICAgIH1cbiAgICBibG9jayRkYXRhKHZhbGlkLCBjb2RlQmxvY2ssICRkYXRhVmFsaWQgPSBjb2RlZ2VuXzEubmlsKSB7XG4gICAgICAgIHRoaXMuZ2VuLmJsb2NrKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2skZGF0YSh2YWxpZCwgJGRhdGFWYWxpZCk7XG4gICAgICAgICAgICBjb2RlQmxvY2soKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNoZWNrJGRhdGEodmFsaWQgPSBjb2RlZ2VuXzEubmlsLCAkZGF0YVZhbGlkID0gY29kZWdlbl8xLm5pbCkge1xuICAgICAgICBpZiAoIXRoaXMuJGRhdGEpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWFDb2RlLCBzY2hlbWFUeXBlLCBkZWYgfSA9IHRoaXM7XG4gICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLm9yKSgoMCwgY29kZWdlbl8xLl8pIGAke3NjaGVtYUNvZGV9ID09PSB1bmRlZmluZWRgLCAkZGF0YVZhbGlkKSk7XG4gICAgICAgIGlmICh2YWxpZCAhPT0gY29kZWdlbl8xLm5pbClcbiAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIHRydWUpO1xuICAgICAgICBpZiAoc2NoZW1hVHlwZS5sZW5ndGggfHwgZGVmLnZhbGlkYXRlU2NoZW1hKSB7XG4gICAgICAgICAgICBnZW4uZWxzZUlmKHRoaXMuaW52YWxpZCRkYXRhKCkpO1xuICAgICAgICAgICAgdGhpcy4kZGF0YUVycm9yKCk7XG4gICAgICAgICAgICBpZiAodmFsaWQgIT09IGNvZGVnZW5fMS5uaWwpXG4gICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGdlbi5lbHNlKCk7XG4gICAgfVxuICAgIGludmFsaWQkZGF0YSgpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYUNvZGUsIHNjaGVtYVR5cGUsIGRlZiwgaXQgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLm9yKSh3cm9uZyREYXRhVHlwZSgpLCBpbnZhbGlkJERhdGFTY2hlbWEoKSk7XG4gICAgICAgIGZ1bmN0aW9uIHdyb25nJERhdGFUeXBlKCkge1xuICAgICAgICAgICAgaWYgKHNjaGVtYVR5cGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgaWYgKCEoc2NoZW1hQ29kZSBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0ID0gQXJyYXkuaXNBcnJheShzY2hlbWFUeXBlKSA/IHNjaGVtYVR5cGUgOiBbc2NoZW1hVHlwZV07XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuXykgYCR7KDAsIGRhdGFUeXBlXzIuY2hlY2tEYXRhVHlwZXMpKHN0LCBzY2hlbWFDb2RlLCBpdC5vcHRzLnN0cmljdE51bWJlcnMsIGRhdGFUeXBlXzIuRGF0YVR5cGUuV3JvbmcpfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29kZWdlbl8xLm5pbDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpbnZhbGlkJERhdGFTY2hlbWEoKSB7XG4gICAgICAgICAgICBpZiAoZGVmLnZhbGlkYXRlU2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsaWRhdGVTY2hlbWFSZWYgPSBnZW4uc2NvcGVWYWx1ZShcInZhbGlkYXRlJGRhdGFcIiwgeyByZWY6IGRlZi52YWxpZGF0ZVNjaGVtYSB9KTsgLy8gVE9ETyB2YWx1ZS5jb2RlIGZvciBzdGFuZGFsb25lXG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuXykgYCEke3ZhbGlkYXRlU2NoZW1hUmVmfSgke3NjaGVtYUNvZGV9KWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29kZWdlbl8xLm5pbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdWJzY2hlbWEoYXBwbCwgdmFsaWQpIHtcbiAgICAgICAgY29uc3Qgc3Vic2NoZW1hID0gKDAsIHN1YnNjaGVtYV8xLmdldFN1YnNjaGVtYSkodGhpcy5pdCwgYXBwbCk7XG4gICAgICAgICgwLCBzdWJzY2hlbWFfMS5leHRlbmRTdWJzY2hlbWFEYXRhKShzdWJzY2hlbWEsIHRoaXMuaXQsIGFwcGwpO1xuICAgICAgICAoMCwgc3Vic2NoZW1hXzEuZXh0ZW5kU3Vic2NoZW1hTW9kZSkoc3Vic2NoZW1hLCBhcHBsKTtcbiAgICAgICAgY29uc3QgbmV4dENvbnRleHQgPSB7IC4uLnRoaXMuaXQsIC4uLnN1YnNjaGVtYSwgaXRlbXM6IHVuZGVmaW5lZCwgcHJvcHM6IHVuZGVmaW5lZCB9O1xuICAgICAgICBzdWJzY2hlbWFDb2RlKG5leHRDb250ZXh0LCB2YWxpZCk7XG4gICAgICAgIHJldHVybiBuZXh0Q29udGV4dDtcbiAgICB9XG4gICAgbWVyZ2VFdmFsdWF0ZWQoc2NoZW1hQ3h0LCB0b05hbWUpIHtcbiAgICAgICAgY29uc3QgeyBpdCwgZ2VuIH0gPSB0aGlzO1xuICAgICAgICBpZiAoIWl0Lm9wdHMudW5ldmFsdWF0ZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChpdC5wcm9wcyAhPT0gdHJ1ZSAmJiBzY2hlbWFDeHQucHJvcHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaXQucHJvcHMgPSB1dGlsXzEubWVyZ2VFdmFsdWF0ZWQucHJvcHMoZ2VuLCBzY2hlbWFDeHQucHJvcHMsIGl0LnByb3BzLCB0b05hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdC5pdGVtcyAhPT0gdHJ1ZSAmJiBzY2hlbWFDeHQuaXRlbXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaXQuaXRlbXMgPSB1dGlsXzEubWVyZ2VFdmFsdWF0ZWQuaXRlbXMoZ2VuLCBzY2hlbWFDeHQuaXRlbXMsIGl0Lml0ZW1zLCB0b05hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1lcmdlVmFsaWRFdmFsdWF0ZWQoc2NoZW1hQ3h0LCB2YWxpZCkge1xuICAgICAgICBjb25zdCB7IGl0LCBnZW4gfSA9IHRoaXM7XG4gICAgICAgIGlmIChpdC5vcHRzLnVuZXZhbHVhdGVkICYmIChpdC5wcm9wcyAhPT0gdHJ1ZSB8fCBpdC5pdGVtcyAhPT0gdHJ1ZSkpIHtcbiAgICAgICAgICAgIGdlbi5pZih2YWxpZCwgKCkgPT4gdGhpcy5tZXJnZUV2YWx1YXRlZChzY2hlbWFDeHQsIGNvZGVnZW5fMS5OYW1lKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuS2V5d29yZEN4dCA9IEtleXdvcmRDeHQ7XG5mdW5jdGlvbiBrZXl3b3JkQ29kZShpdCwga2V5d29yZCwgZGVmLCBydWxlVHlwZSkge1xuICAgIGNvbnN0IGN4dCA9IG5ldyBLZXl3b3JkQ3h0KGl0LCBkZWYsIGtleXdvcmQpO1xuICAgIGlmIChcImNvZGVcIiBpbiBkZWYpIHtcbiAgICAgICAgZGVmLmNvZGUoY3h0LCBydWxlVHlwZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGN4dC4kZGF0YSAmJiBkZWYudmFsaWRhdGUpIHtcbiAgICAgICAgKDAsIGtleXdvcmRfMS5mdW5jS2V5d29yZENvZGUpKGN4dCwgZGVmKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoXCJtYWNyb1wiIGluIGRlZikge1xuICAgICAgICAoMCwga2V5d29yZF8xLm1hY3JvS2V5d29yZENvZGUpKGN4dCwgZGVmKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGVmLmNvbXBpbGUgfHwgZGVmLnZhbGlkYXRlKSB7XG4gICAgICAgICgwLCBrZXl3b3JkXzEuZnVuY0tleXdvcmRDb2RlKShjeHQsIGRlZik7XG4gICAgfVxufVxuY29uc3QgSlNPTl9QT0lOVEVSID0gL15cXC8oPzpbXn5dfH4wfH4xKSokLztcbmNvbnN0IFJFTEFUSVZFX0pTT05fUE9JTlRFUiA9IC9eKFswLTldKykoI3xcXC8oPzpbXn5dfH4wfH4xKSopPyQvO1xuZnVuY3Rpb24gZ2V0RGF0YSgkZGF0YSwgeyBkYXRhTGV2ZWwsIGRhdGFOYW1lcywgZGF0YVBhdGhBcnIgfSkge1xuICAgIGxldCBqc29uUG9pbnRlcjtcbiAgICBsZXQgZGF0YTtcbiAgICBpZiAoJGRhdGEgPT09IFwiXCIpXG4gICAgICAgIHJldHVybiBuYW1lc18xLmRlZmF1bHQucm9vdERhdGE7XG4gICAgaWYgKCRkYXRhWzBdID09PSBcIi9cIikge1xuICAgICAgICBpZiAoIUpTT05fUE9JTlRFUi50ZXN0KCRkYXRhKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBKU09OLXBvaW50ZXI6ICR7JGRhdGF9YCk7XG4gICAgICAgIGpzb25Qb2ludGVyID0gJGRhdGE7XG4gICAgICAgIGRhdGEgPSBuYW1lc18xLmRlZmF1bHQucm9vdERhdGE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBtYXRjaGVzID0gUkVMQVRJVkVfSlNPTl9QT0lOVEVSLmV4ZWMoJGRhdGEpO1xuICAgICAgICBpZiAoIW1hdGNoZXMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgSlNPTi1wb2ludGVyOiAkeyRkYXRhfWApO1xuICAgICAgICBjb25zdCB1cCA9ICttYXRjaGVzWzFdO1xuICAgICAgICBqc29uUG9pbnRlciA9IG1hdGNoZXNbMl07XG4gICAgICAgIGlmIChqc29uUG9pbnRlciA9PT0gXCIjXCIpIHtcbiAgICAgICAgICAgIGlmICh1cCA+PSBkYXRhTGV2ZWwpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTXNnKFwicHJvcGVydHkvaW5kZXhcIiwgdXApKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhUGF0aEFycltkYXRhTGV2ZWwgLSB1cF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwID4gZGF0YUxldmVsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTXNnKFwiZGF0YVwiLCB1cCkpO1xuICAgICAgICBkYXRhID0gZGF0YU5hbWVzW2RhdGFMZXZlbCAtIHVwXTtcbiAgICAgICAgaWYgKCFqc29uUG9pbnRlcilcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBsZXQgZXhwciA9IGRhdGE7XG4gICAgY29uc3Qgc2VnbWVudHMgPSBqc29uUG9pbnRlci5zcGxpdChcIi9cIik7XG4gICAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgICAgIGlmIChzZWdtZW50KSB7XG4gICAgICAgICAgICBkYXRhID0gKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfSR7KDAsIGNvZGVnZW5fMS5nZXRQcm9wZXJ0eSkoKDAsIHV0aWxfMS51bmVzY2FwZUpzb25Qb2ludGVyKShzZWdtZW50KSl9YDtcbiAgICAgICAgICAgIGV4cHIgPSAoMCwgY29kZWdlbl8xLl8pIGAke2V4cHJ9ICYmICR7ZGF0YX1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBleHByO1xuICAgIGZ1bmN0aW9uIGVycm9yTXNnKHBvaW50ZXJUeXBlLCB1cCkge1xuICAgICAgICByZXR1cm4gYENhbm5vdCBhY2Nlc3MgJHtwb2ludGVyVHlwZX0gJHt1cH0gbGV2ZWxzIHVwLCBjdXJyZW50IGxldmVsIGlzICR7ZGF0YUxldmVsfWA7XG4gICAgfVxufVxuZXhwb3J0cy5nZXREYXRhID0gZ2V0RGF0YTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgVmFsaWRhdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGVycm9ycykge1xuICAgICAgICBzdXBlcihcInZhbGlkYXRpb24gZmFpbGVkXCIpO1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICAgICAgdGhpcy5hanYgPSB0aGlzLnZhbGlkYXRpb24gPSB0cnVlO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFZhbGlkYXRpb25FcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZhbGlkYXRpb25fZXJyb3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCByZXNvbHZlXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZlXCIpO1xuY2xhc3MgTWlzc2luZ1JlZkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHJlc29sdmVyLCBiYXNlSWQsIHJlZiwgbXNnKSB7XG4gICAgICAgIHN1cGVyKG1zZyB8fCBgY2FuJ3QgcmVzb2x2ZSByZWZlcmVuY2UgJHtyZWZ9IGZyb20gaWQgJHtiYXNlSWR9YCk7XG4gICAgICAgIHRoaXMubWlzc2luZ1JlZiA9ICgwLCByZXNvbHZlXzEucmVzb2x2ZVVybCkocmVzb2x2ZXIsIGJhc2VJZCwgcmVmKTtcbiAgICAgICAgdGhpcy5taXNzaW5nU2NoZW1hID0gKDAsIHJlc29sdmVfMS5ub3JtYWxpemVJZCkoKDAsIHJlc29sdmVfMS5nZXRGdWxsUGF0aCkocmVzb2x2ZXIsIHRoaXMubWlzc2luZ1JlZikpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IE1pc3NpbmdSZWZFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZl9lcnJvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVzb2x2ZVNjaGVtYSA9IGV4cG9ydHMuZ2V0Q29tcGlsaW5nU2NoZW1hID0gZXhwb3J0cy5yZXNvbHZlUmVmID0gZXhwb3J0cy5jb21waWxlU2NoZW1hID0gZXhwb3J0cy5TY2hlbWFFbnYgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi9jb2RlZ2VuXCIpO1xuY29uc3QgdmFsaWRhdGlvbl9lcnJvcl8xID0gcmVxdWlyZShcIi4uL3J1bnRpbWUvdmFsaWRhdGlvbl9lcnJvclwiKTtcbmNvbnN0IG5hbWVzXzEgPSByZXF1aXJlKFwiLi9uYW1lc1wiKTtcbmNvbnN0IHJlc29sdmVfMSA9IHJlcXVpcmUoXCIuL3Jlc29sdmVcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuY29uc3QgdmFsaWRhdGVfMSA9IHJlcXVpcmUoXCIuL3ZhbGlkYXRlXCIpO1xuY2xhc3MgU2NoZW1hRW52IHtcbiAgICBjb25zdHJ1Y3RvcihlbnYpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLnJlZnMgPSB7fTtcbiAgICAgICAgdGhpcy5keW5hbWljQW5jaG9ycyA9IHt9O1xuICAgICAgICBsZXQgc2NoZW1hO1xuICAgICAgICBpZiAodHlwZW9mIGVudi5zY2hlbWEgPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgIHNjaGVtYSA9IGVudi5zY2hlbWE7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gZW52LnNjaGVtYTtcbiAgICAgICAgdGhpcy5zY2hlbWFJZCA9IGVudi5zY2hlbWFJZDtcbiAgICAgICAgdGhpcy5yb290ID0gZW52LnJvb3QgfHwgdGhpcztcbiAgICAgICAgdGhpcy5iYXNlSWQgPSAoX2EgPSBlbnYuYmFzZUlkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoMCwgcmVzb2x2ZV8xLm5vcm1hbGl6ZUlkKShzY2hlbWEgPT09IG51bGwgfHwgc2NoZW1hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY2hlbWFbZW52LnNjaGVtYUlkIHx8IFwiJGlkXCJdKTtcbiAgICAgICAgdGhpcy5zY2hlbWFQYXRoID0gZW52LnNjaGVtYVBhdGg7XG4gICAgICAgIHRoaXMubG9jYWxSZWZzID0gZW52LmxvY2FsUmVmcztcbiAgICAgICAgdGhpcy5tZXRhID0gZW52Lm1ldGE7XG4gICAgICAgIHRoaXMuJGFzeW5jID0gc2NoZW1hID09PSBudWxsIHx8IHNjaGVtYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2NoZW1hLiRhc3luYztcbiAgICAgICAgdGhpcy5yZWZzID0ge307XG4gICAgfVxufVxuZXhwb3J0cy5TY2hlbWFFbnYgPSBTY2hlbWFFbnY7XG4vLyBsZXQgY29kZVNpemUgPSAwXG4vLyBsZXQgbm9kZUNvdW50ID0gMFxuLy8gQ29tcGlsZXMgc2NoZW1hIGluIFNjaGVtYUVudlxuZnVuY3Rpb24gY29tcGlsZVNjaGVtYShzY2gpIHtcbiAgICAvLyBUT0RPIHJlZmFjdG9yIC0gcmVtb3ZlIGNvbXBpbGF0aW9uc1xuICAgIGNvbnN0IF9zY2ggPSBnZXRDb21waWxpbmdTY2hlbWEuY2FsbCh0aGlzLCBzY2gpO1xuICAgIGlmIChfc2NoKVxuICAgICAgICByZXR1cm4gX3NjaDtcbiAgICBjb25zdCByb290SWQgPSAoMCwgcmVzb2x2ZV8xLmdldEZ1bGxQYXRoKSh0aGlzLm9wdHMudXJpUmVzb2x2ZXIsIHNjaC5yb290LmJhc2VJZCk7IC8vIFRPRE8gaWYgZ2V0RnVsbFBhdGggcmVtb3ZlZCAxIHRlc3RzIGZhaWxzXG4gICAgY29uc3QgeyBlczUsIGxpbmVzIH0gPSB0aGlzLm9wdHMuY29kZTtcbiAgICBjb25zdCB7IG93blByb3BlcnRpZXMgfSA9IHRoaXMub3B0cztcbiAgICBjb25zdCBnZW4gPSBuZXcgY29kZWdlbl8xLkNvZGVHZW4odGhpcy5zY29wZSwgeyBlczUsIGxpbmVzLCBvd25Qcm9wZXJ0aWVzIH0pO1xuICAgIGxldCBfVmFsaWRhdGlvbkVycm9yO1xuICAgIGlmIChzY2guJGFzeW5jKSB7XG4gICAgICAgIF9WYWxpZGF0aW9uRXJyb3IgPSBnZW4uc2NvcGVWYWx1ZShcIkVycm9yXCIsIHtcbiAgICAgICAgICAgIHJlZjogdmFsaWRhdGlvbl9lcnJvcl8xLmRlZmF1bHQsXG4gICAgICAgICAgICBjb2RlOiAoMCwgY29kZWdlbl8xLl8pIGByZXF1aXJlKFwiYWp2L2Rpc3QvcnVudGltZS92YWxpZGF0aW9uX2Vycm9yXCIpLmRlZmF1bHRgLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgdmFsaWRhdGVOYW1lID0gZ2VuLnNjb3BlTmFtZShcInZhbGlkYXRlXCIpO1xuICAgIHNjaC52YWxpZGF0ZU5hbWUgPSB2YWxpZGF0ZU5hbWU7XG4gICAgY29uc3Qgc2NoZW1hQ3h0ID0ge1xuICAgICAgICBnZW4sXG4gICAgICAgIGFsbEVycm9yczogdGhpcy5vcHRzLmFsbEVycm9ycyxcbiAgICAgICAgZGF0YTogbmFtZXNfMS5kZWZhdWx0LmRhdGEsXG4gICAgICAgIHBhcmVudERhdGE6IG5hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhLFxuICAgICAgICBwYXJlbnREYXRhUHJvcGVydHk6IG5hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhUHJvcGVydHksXG4gICAgICAgIGRhdGFOYW1lczogW25hbWVzXzEuZGVmYXVsdC5kYXRhXSxcbiAgICAgICAgZGF0YVBhdGhBcnI6IFtjb2RlZ2VuXzEubmlsXSwgLy8gVE9ETyBjYW4gaXRzIGxlbmd0aCBiZSB1c2VkIGFzIGRhdGFMZXZlbCBpZiBuaWwgaXMgcmVtb3ZlZD9cbiAgICAgICAgZGF0YUxldmVsOiAwLFxuICAgICAgICBkYXRhVHlwZXM6IFtdLFxuICAgICAgICBkZWZpbmVkUHJvcGVydGllczogbmV3IFNldCgpLFxuICAgICAgICB0b3BTY2hlbWFSZWY6IGdlbi5zY29wZVZhbHVlKFwic2NoZW1hXCIsIHRoaXMub3B0cy5jb2RlLnNvdXJjZSA9PT0gdHJ1ZVxuICAgICAgICAgICAgPyB7IHJlZjogc2NoLnNjaGVtYSwgY29kZTogKDAsIGNvZGVnZW5fMS5zdHJpbmdpZnkpKHNjaC5zY2hlbWEpIH1cbiAgICAgICAgICAgIDogeyByZWY6IHNjaC5zY2hlbWEgfSksXG4gICAgICAgIHZhbGlkYXRlTmFtZSxcbiAgICAgICAgVmFsaWRhdGlvbkVycm9yOiBfVmFsaWRhdGlvbkVycm9yLFxuICAgICAgICBzY2hlbWE6IHNjaC5zY2hlbWEsXG4gICAgICAgIHNjaGVtYUVudjogc2NoLFxuICAgICAgICByb290SWQsXG4gICAgICAgIGJhc2VJZDogc2NoLmJhc2VJZCB8fCByb290SWQsXG4gICAgICAgIHNjaGVtYVBhdGg6IGNvZGVnZW5fMS5uaWwsXG4gICAgICAgIGVyclNjaGVtYVBhdGg6IHNjaC5zY2hlbWFQYXRoIHx8ICh0aGlzLm9wdHMuanRkID8gXCJcIiA6IFwiI1wiKSxcbiAgICAgICAgZXJyb3JQYXRoOiAoMCwgY29kZWdlbl8xLl8pIGBcIlwiYCxcbiAgICAgICAgb3B0czogdGhpcy5vcHRzLFxuICAgICAgICBzZWxmOiB0aGlzLFxuICAgIH07XG4gICAgbGV0IHNvdXJjZUNvZGU7XG4gICAgdHJ5IHtcbiAgICAgICAgdGhpcy5fY29tcGlsYXRpb25zLmFkZChzY2gpO1xuICAgICAgICAoMCwgdmFsaWRhdGVfMS52YWxpZGF0ZUZ1bmN0aW9uQ29kZSkoc2NoZW1hQ3h0KTtcbiAgICAgICAgZ2VuLm9wdGltaXplKHRoaXMub3B0cy5jb2RlLm9wdGltaXplKTtcbiAgICAgICAgLy8gZ2VuLm9wdGltaXplKDEpXG4gICAgICAgIGNvbnN0IHZhbGlkYXRlQ29kZSA9IGdlbi50b1N0cmluZygpO1xuICAgICAgICBzb3VyY2VDb2RlID0gYCR7Z2VuLnNjb3BlUmVmcyhuYW1lc18xLmRlZmF1bHQuc2NvcGUpfXJldHVybiAke3ZhbGlkYXRlQ29kZX1gO1xuICAgICAgICAvLyBjb25zb2xlLmxvZygoY29kZVNpemUgKz0gc291cmNlQ29kZS5sZW5ndGgpLCAobm9kZUNvdW50ICs9IGdlbi5ub2RlQ291bnQpKVxuICAgICAgICBpZiAodGhpcy5vcHRzLmNvZGUucHJvY2VzcylcbiAgICAgICAgICAgIHNvdXJjZUNvZGUgPSB0aGlzLm9wdHMuY29kZS5wcm9jZXNzKHNvdXJjZUNvZGUsIHNjaCk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiXFxuXFxuXFxuICoqKiBcXG5cIiwgc291cmNlQ29kZSlcbiAgICAgICAgY29uc3QgbWFrZVZhbGlkYXRlID0gbmV3IEZ1bmN0aW9uKGAke25hbWVzXzEuZGVmYXVsdC5zZWxmfWAsIGAke25hbWVzXzEuZGVmYXVsdC5zY29wZX1gLCBzb3VyY2VDb2RlKTtcbiAgICAgICAgY29uc3QgdmFsaWRhdGUgPSBtYWtlVmFsaWRhdGUodGhpcywgdGhpcy5zY29wZS5nZXQoKSk7XG4gICAgICAgIHRoaXMuc2NvcGUudmFsdWUodmFsaWRhdGVOYW1lLCB7IHJlZjogdmFsaWRhdGUgfSk7XG4gICAgICAgIHZhbGlkYXRlLmVycm9ycyA9IG51bGw7XG4gICAgICAgIHZhbGlkYXRlLnNjaGVtYSA9IHNjaC5zY2hlbWE7XG4gICAgICAgIHZhbGlkYXRlLnNjaGVtYUVudiA9IHNjaDtcbiAgICAgICAgaWYgKHNjaC4kYXN5bmMpXG4gICAgICAgICAgICB2YWxpZGF0ZS4kYXN5bmMgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5vcHRzLmNvZGUuc291cmNlID09PSB0cnVlKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZS5zb3VyY2UgPSB7IHZhbGlkYXRlTmFtZSwgdmFsaWRhdGVDb2RlLCBzY29wZVZhbHVlczogZ2VuLl92YWx1ZXMgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRzLnVuZXZhbHVhdGVkKSB7XG4gICAgICAgICAgICBjb25zdCB7IHByb3BzLCBpdGVtcyB9ID0gc2NoZW1hQ3h0O1xuICAgICAgICAgICAgdmFsaWRhdGUuZXZhbHVhdGVkID0ge1xuICAgICAgICAgICAgICAgIHByb3BzOiBwcm9wcyBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lID8gdW5kZWZpbmVkIDogcHJvcHMsXG4gICAgICAgICAgICAgICAgaXRlbXM6IGl0ZW1zIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUgPyB1bmRlZmluZWQgOiBpdGVtcyxcbiAgICAgICAgICAgICAgICBkeW5hbWljUHJvcHM6IHByb3BzIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUsXG4gICAgICAgICAgICAgICAgZHluYW1pY0l0ZW1zOiBpdGVtcyBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh2YWxpZGF0ZS5zb3VyY2UpXG4gICAgICAgICAgICAgICAgdmFsaWRhdGUuc291cmNlLmV2YWx1YXRlZCA9ICgwLCBjb2RlZ2VuXzEuc3RyaW5naWZ5KSh2YWxpZGF0ZS5ldmFsdWF0ZWQpO1xuICAgICAgICB9XG4gICAgICAgIHNjaC52YWxpZGF0ZSA9IHZhbGlkYXRlO1xuICAgICAgICByZXR1cm4gc2NoO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBkZWxldGUgc2NoLnZhbGlkYXRlO1xuICAgICAgICBkZWxldGUgc2NoLnZhbGlkYXRlTmFtZTtcbiAgICAgICAgaWYgKHNvdXJjZUNvZGUpXG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIkVycm9yIGNvbXBpbGluZyBzY2hlbWEsIGZ1bmN0aW9uIGNvZGU6XCIsIHNvdXJjZUNvZGUpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIlxcblxcblxcbiAqKiogXFxuXCIsIHNvdXJjZUNvZGUsIHRoaXMub3B0cylcbiAgICAgICAgdGhyb3cgZTtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRoaXMuX2NvbXBpbGF0aW9ucy5kZWxldGUoc2NoKTtcbiAgICB9XG59XG5leHBvcnRzLmNvbXBpbGVTY2hlbWEgPSBjb21waWxlU2NoZW1hO1xuZnVuY3Rpb24gcmVzb2x2ZVJlZihyb290LCBiYXNlSWQsIHJlZikge1xuICAgIHZhciBfYTtcbiAgICByZWYgPSAoMCwgcmVzb2x2ZV8xLnJlc29sdmVVcmwpKHRoaXMub3B0cy51cmlSZXNvbHZlciwgYmFzZUlkLCByZWYpO1xuICAgIGNvbnN0IHNjaE9yRnVuYyA9IHJvb3QucmVmc1tyZWZdO1xuICAgIGlmIChzY2hPckZ1bmMpXG4gICAgICAgIHJldHVybiBzY2hPckZ1bmM7XG4gICAgbGV0IF9zY2ggPSByZXNvbHZlLmNhbGwodGhpcywgcm9vdCwgcmVmKTtcbiAgICBpZiAoX3NjaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHNjaGVtYSA9IChfYSA9IHJvb3QubG9jYWxSZWZzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbcmVmXTsgLy8gVE9ETyBtYXliZSBsb2NhbFJlZnMgc2hvdWxkIGhvbGQgU2NoZW1hRW52XG4gICAgICAgIGNvbnN0IHsgc2NoZW1hSWQgfSA9IHRoaXMub3B0cztcbiAgICAgICAgaWYgKHNjaGVtYSlcbiAgICAgICAgICAgIF9zY2ggPSBuZXcgU2NoZW1hRW52KHsgc2NoZW1hLCBzY2hlbWFJZCwgcm9vdCwgYmFzZUlkIH0pO1xuICAgIH1cbiAgICBpZiAoX3NjaCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm47XG4gICAgcmV0dXJuIChyb290LnJlZnNbcmVmXSA9IGlubGluZU9yQ29tcGlsZS5jYWxsKHRoaXMsIF9zY2gpKTtcbn1cbmV4cG9ydHMucmVzb2x2ZVJlZiA9IHJlc29sdmVSZWY7XG5mdW5jdGlvbiBpbmxpbmVPckNvbXBpbGUoc2NoKSB7XG4gICAgaWYgKCgwLCByZXNvbHZlXzEuaW5saW5lUmVmKShzY2guc2NoZW1hLCB0aGlzLm9wdHMuaW5saW5lUmVmcykpXG4gICAgICAgIHJldHVybiBzY2guc2NoZW1hO1xuICAgIHJldHVybiBzY2gudmFsaWRhdGUgPyBzY2ggOiBjb21waWxlU2NoZW1hLmNhbGwodGhpcywgc2NoKTtcbn1cbi8vIEluZGV4IG9mIHNjaGVtYSBjb21waWxhdGlvbiBpbiB0aGUgY3VycmVudGx5IGNvbXBpbGVkIGxpc3RcbmZ1bmN0aW9uIGdldENvbXBpbGluZ1NjaGVtYShzY2hFbnYpIHtcbiAgICBmb3IgKGNvbnN0IHNjaCBvZiB0aGlzLl9jb21waWxhdGlvbnMpIHtcbiAgICAgICAgaWYgKHNhbWVTY2hlbWFFbnYoc2NoLCBzY2hFbnYpKVxuICAgICAgICAgICAgcmV0dXJuIHNjaDtcbiAgICB9XG59XG5leHBvcnRzLmdldENvbXBpbGluZ1NjaGVtYSA9IGdldENvbXBpbGluZ1NjaGVtYTtcbmZ1bmN0aW9uIHNhbWVTY2hlbWFFbnYoczEsIHMyKSB7XG4gICAgcmV0dXJuIHMxLnNjaGVtYSA9PT0gczIuc2NoZW1hICYmIHMxLnJvb3QgPT09IHMyLnJvb3QgJiYgczEuYmFzZUlkID09PSBzMi5iYXNlSWQ7XG59XG4vLyByZXNvbHZlIGFuZCBjb21waWxlIHRoZSByZWZlcmVuY2VzICgkcmVmKVxuLy8gVE9ETyByZXR1cm5zIEFueVNjaGVtYU9iamVjdCAoaWYgdGhlIHNjaGVtYSBjYW4gYmUgaW5saW5lZCkgb3IgdmFsaWRhdGlvbiBmdW5jdGlvblxuZnVuY3Rpb24gcmVzb2x2ZShyb290LCAvLyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcm9vdCBzY2hlbWEgZm9yIHRoZSBjdXJyZW50IHNjaGVtYVxucmVmIC8vIHJlZmVyZW5jZSB0byByZXNvbHZlXG4pIHtcbiAgICBsZXQgc2NoO1xuICAgIHdoaWxlICh0eXBlb2YgKHNjaCA9IHRoaXMucmVmc1tyZWZdKSA9PSBcInN0cmluZ1wiKVxuICAgICAgICByZWYgPSBzY2g7XG4gICAgcmV0dXJuIHNjaCB8fCB0aGlzLnNjaGVtYXNbcmVmXSB8fCByZXNvbHZlU2NoZW1hLmNhbGwodGhpcywgcm9vdCwgcmVmKTtcbn1cbi8vIFJlc29sdmUgc2NoZW1hLCBpdHMgcm9vdCBhbmQgYmFzZUlkXG5mdW5jdGlvbiByZXNvbHZlU2NoZW1hKHJvb3QsIC8vIHJvb3Qgb2JqZWN0IHdpdGggcHJvcGVydGllcyBzY2hlbWEsIHJlZnMgVE9ETyBiZWxvdyBTY2hlbWFFbnYgaXMgYXNzaWduZWQgdG8gaXRcbnJlZiAvLyByZWZlcmVuY2UgdG8gcmVzb2x2ZVxuKSB7XG4gICAgY29uc3QgcCA9IHRoaXMub3B0cy51cmlSZXNvbHZlci5wYXJzZShyZWYpO1xuICAgIGNvbnN0IHJlZlBhdGggPSAoMCwgcmVzb2x2ZV8xLl9nZXRGdWxsUGF0aCkodGhpcy5vcHRzLnVyaVJlc29sdmVyLCBwKTtcbiAgICBsZXQgYmFzZUlkID0gKDAsIHJlc29sdmVfMS5nZXRGdWxsUGF0aCkodGhpcy5vcHRzLnVyaVJlc29sdmVyLCByb290LmJhc2VJZCwgdW5kZWZpbmVkKTtcbiAgICAvLyBUT0RPIGBPYmplY3Qua2V5cyhyb290LnNjaGVtYSkubGVuZ3RoID4gMGAgc2hvdWxkIG5vdCBiZSBuZWVkZWQgLSBidXQgcmVtb3ZpbmcgYnJlYWtzIDIgdGVzdHNcbiAgICBpZiAoT2JqZWN0LmtleXMocm9vdC5zY2hlbWEpLmxlbmd0aCA+IDAgJiYgcmVmUGF0aCA9PT0gYmFzZUlkKSB7XG4gICAgICAgIHJldHVybiBnZXRKc29uUG9pbnRlci5jYWxsKHRoaXMsIHAsIHJvb3QpO1xuICAgIH1cbiAgICBjb25zdCBpZCA9ICgwLCByZXNvbHZlXzEubm9ybWFsaXplSWQpKHJlZlBhdGgpO1xuICAgIGNvbnN0IHNjaE9yUmVmID0gdGhpcy5yZWZzW2lkXSB8fCB0aGlzLnNjaGVtYXNbaWRdO1xuICAgIGlmICh0eXBlb2Ygc2NoT3JSZWYgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCBzY2ggPSByZXNvbHZlU2NoZW1hLmNhbGwodGhpcywgcm9vdCwgc2NoT3JSZWYpO1xuICAgICAgICBpZiAodHlwZW9mIChzY2ggPT09IG51bGwgfHwgc2NoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY2guc2NoZW1hKSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcmV0dXJuIGdldEpzb25Qb2ludGVyLmNhbGwodGhpcywgcCwgc2NoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAoc2NoT3JSZWYgPT09IG51bGwgfHwgc2NoT3JSZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNjaE9yUmVmLnNjaGVtYSkgIT09IFwib2JqZWN0XCIpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoIXNjaE9yUmVmLnZhbGlkYXRlKVxuICAgICAgICBjb21waWxlU2NoZW1hLmNhbGwodGhpcywgc2NoT3JSZWYpO1xuICAgIGlmIChpZCA9PT0gKDAsIHJlc29sdmVfMS5ub3JtYWxpemVJZCkocmVmKSkge1xuICAgICAgICBjb25zdCB7IHNjaGVtYSB9ID0gc2NoT3JSZWY7XG4gICAgICAgIGNvbnN0IHsgc2NoZW1hSWQgfSA9IHRoaXMub3B0cztcbiAgICAgICAgY29uc3Qgc2NoSWQgPSBzY2hlbWFbc2NoZW1hSWRdO1xuICAgICAgICBpZiAoc2NoSWQpXG4gICAgICAgICAgICBiYXNlSWQgPSAoMCwgcmVzb2x2ZV8xLnJlc29sdmVVcmwpKHRoaXMub3B0cy51cmlSZXNvbHZlciwgYmFzZUlkLCBzY2hJZCk7XG4gICAgICAgIHJldHVybiBuZXcgU2NoZW1hRW52KHsgc2NoZW1hLCBzY2hlbWFJZCwgcm9vdCwgYmFzZUlkIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0SnNvblBvaW50ZXIuY2FsbCh0aGlzLCBwLCBzY2hPclJlZik7XG59XG5leHBvcnRzLnJlc29sdmVTY2hlbWEgPSByZXNvbHZlU2NoZW1hO1xuY29uc3QgUFJFVkVOVF9TQ09QRV9DSEFOR0UgPSBuZXcgU2V0KFtcbiAgICBcInByb3BlcnRpZXNcIixcbiAgICBcInBhdHRlcm5Qcm9wZXJ0aWVzXCIsXG4gICAgXCJlbnVtXCIsXG4gICAgXCJkZXBlbmRlbmNpZXNcIixcbiAgICBcImRlZmluaXRpb25zXCIsXG5dKTtcbmZ1bmN0aW9uIGdldEpzb25Qb2ludGVyKHBhcnNlZFJlZiwgeyBiYXNlSWQsIHNjaGVtYSwgcm9vdCB9KSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICgoKF9hID0gcGFyc2VkUmVmLmZyYWdtZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0pICE9PSBcIi9cIilcbiAgICAgICAgcmV0dXJuO1xuICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJzZWRSZWYuZnJhZ21lbnQuc2xpY2UoMSkuc3BsaXQoXCIvXCIpKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hID09PSBcImJvb2xlYW5cIilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgcGFydFNjaGVtYSA9IHNjaGVtYVsoMCwgdXRpbF8xLnVuZXNjYXBlRnJhZ21lbnQpKHBhcnQpXTtcbiAgICAgICAgaWYgKHBhcnRTY2hlbWEgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgc2NoZW1hID0gcGFydFNjaGVtYTtcbiAgICAgICAgLy8gVE9ETyBQUkVWRU5UX1NDT1BFX0NIQU5HRSBjb3VsZCBiZSBkZWZpbmVkIGluIGtleXdvcmQgZGVmP1xuICAgICAgICBjb25zdCBzY2hJZCA9IHR5cGVvZiBzY2hlbWEgPT09IFwib2JqZWN0XCIgJiYgc2NoZW1hW3RoaXMub3B0cy5zY2hlbWFJZF07XG4gICAgICAgIGlmICghUFJFVkVOVF9TQ09QRV9DSEFOR0UuaGFzKHBhcnQpICYmIHNjaElkKSB7XG4gICAgICAgICAgICBiYXNlSWQgPSAoMCwgcmVzb2x2ZV8xLnJlc29sdmVVcmwpKHRoaXMub3B0cy51cmlSZXNvbHZlciwgYmFzZUlkLCBzY2hJZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGVudjtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSAhPSBcImJvb2xlYW5cIiAmJiBzY2hlbWEuJHJlZiAmJiAhKDAsIHV0aWxfMS5zY2hlbWFIYXNSdWxlc0J1dFJlZikoc2NoZW1hLCB0aGlzLlJVTEVTKSkge1xuICAgICAgICBjb25zdCAkcmVmID0gKDAsIHJlc29sdmVfMS5yZXNvbHZlVXJsKSh0aGlzLm9wdHMudXJpUmVzb2x2ZXIsIGJhc2VJZCwgc2NoZW1hLiRyZWYpO1xuICAgICAgICBlbnYgPSByZXNvbHZlU2NoZW1hLmNhbGwodGhpcywgcm9vdCwgJHJlZik7XG4gICAgfVxuICAgIC8vIGV2ZW4gdGhvdWdoIHJlc29sdXRpb24gZmFpbGVkIHdlIG5lZWQgdG8gcmV0dXJuIFNjaGVtYUVudiB0byB0aHJvdyBleGNlcHRpb25cbiAgICAvLyBzbyB0aGF0IGNvbXBpbGVBc3luYyBsb2FkcyBtaXNzaW5nIHNjaGVtYS5cbiAgICBjb25zdCB7IHNjaGVtYUlkIH0gPSB0aGlzLm9wdHM7XG4gICAgZW52ID0gZW52IHx8IG5ldyBTY2hlbWFFbnYoeyBzY2hlbWEsIHNjaGVtYUlkLCByb290LCBiYXNlSWQgfSk7XG4gICAgaWYgKGVudi5zY2hlbWEgIT09IGVudi5yb290LnNjaGVtYSlcbiAgICAgICAgcmV0dXJuIGVudjtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwie1xuICBcIiRpZFwiOiBcImh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9hanYtdmFsaWRhdG9yL2Fqdi9tYXN0ZXIvbGliL3JlZnMvZGF0YS5qc29uI1wiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiTWV0YS1zY2hlbWEgZm9yICRkYXRhIHJlZmVyZW5jZSAoSlNPTiBBbnlTY2hlbWEgZXh0ZW5zaW9uIHByb3Bvc2FsKVwiLFxuICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgXCJyZXF1aXJlZFwiOiBbXCIkZGF0YVwiXSxcbiAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICBcIiRkYXRhXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJhbnlPZlwiOiBbe1wiZm9ybWF0XCI6IFwicmVsYXRpdmUtanNvbi1wb2ludGVyXCJ9LCB7XCJmb3JtYXRcIjogXCJqc29uLXBvaW50ZXJcIn1dXG4gICAgfVxuICB9LFxuICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IGZhbHNlXG59XG4iLCIndXNlIHN0cmljdCdcblxuLyoqIEB0eXBlIHsodmFsdWU6IHN0cmluZykgPT4gYm9vbGVhbn0gKi9cbmNvbnN0IGlzVVVJRCA9IFJlZ0V4cC5wcm90b3R5cGUudGVzdC5iaW5kKC9eW1xcZGEtZl17OH0tW1xcZGEtZl17NH0tW1xcZGEtZl17NH0tW1xcZGEtZl17NH0tW1xcZGEtZl17MTJ9JC9pdSlcblxuLyoqIEB0eXBlIHsodmFsdWU6IHN0cmluZykgPT4gYm9vbGVhbn0gKi9cbmNvbnN0IGlzSVB2NCA9IFJlZ0V4cC5wcm90b3R5cGUudGVzdC5iaW5kKC9eKD86KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZHsyfXxbMS05XVxcZHxcXGQpXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfDFcXGR7Mn18WzEtOV1cXGR8XFxkKSQvdSlcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGlucHV0XG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBzdHJpbmdBcnJheVRvSGV4U3RyaXBwZWQgKGlucHV0KSB7XG4gIGxldCBhY2MgPSAnJ1xuICBsZXQgY29kZSA9IDBcbiAgbGV0IGkgPSAwXG5cbiAgZm9yIChpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29kZSA9IGlucHV0W2ldLmNoYXJDb2RlQXQoMClcbiAgICBpZiAoY29kZSA9PT0gNDgpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmICghKChjb2RlID49IDQ4ICYmIGNvZGUgPD0gNTcpIHx8IChjb2RlID49IDY1ICYmIGNvZGUgPD0gNzApIHx8IChjb2RlID49IDk3ICYmIGNvZGUgPD0gMTAyKSkpIHtcbiAgICAgIHJldHVybiAnJ1xuICAgIH1cbiAgICBhY2MgKz0gaW5wdXRbaV1cbiAgICBicmVha1xuICB9XG5cbiAgZm9yIChpICs9IDE7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgIGNvZGUgPSBpbnB1dFtpXS5jaGFyQ29kZUF0KDApXG4gICAgaWYgKCEoKGNvZGUgPj0gNDggJiYgY29kZSA8PSA1NykgfHwgKGNvZGUgPj0gNjUgJiYgY29kZSA8PSA3MCkgfHwgKGNvZGUgPj0gOTcgJiYgY29kZSA8PSAxMDIpKSkge1xuICAgICAgcmV0dXJuICcnXG4gICAgfVxuICAgIGFjYyArPSBpbnB1dFtpXVxuICB9XG4gIHJldHVybiBhY2Ncbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBHZXRJUFY2UmVzdWx0XG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGVycm9yIC0gSW5kaWNhdGVzIGlmIHRoZXJlIHdhcyBhbiBlcnJvciBwYXJzaW5nIHRoZSBJUHY2IGFkZHJlc3MuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gYWRkcmVzcyAtIFRoZSBwYXJzZWQgSVB2NiBhZGRyZXNzLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt6b25lXSAtIFRoZSB6b25lIGlkZW50aWZpZXIsIGlmIHByZXNlbnQuXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5jb25zdCBub25TaW1wbGVEb21haW4gPSBSZWdFeHAucHJvdG90eXBlLnRlc3QuYmluZCgvW14hXCIkJicoKSorLFxcLS47PV9gYS16e31+XS91KVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gYnVmZmVyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gY29uc3VtZUlzWm9uZSAoYnVmZmVyKSB7XG4gIGJ1ZmZlci5sZW5ndGggPSAwXG4gIHJldHVybiB0cnVlXG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBidWZmZXJcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gYWRkcmVzc1xuICogQHBhcmFtIHtHZXRJUFY2UmVzdWx0fSBvdXRwdXRcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBjb25zdW1lSGV4dGV0cyAoYnVmZmVyLCBhZGRyZXNzLCBvdXRwdXQpIHtcbiAgaWYgKGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBjb25zdCBoZXggPSBzdHJpbmdBcnJheVRvSGV4U3RyaXBwZWQoYnVmZmVyKVxuICAgIGlmIChoZXggIT09ICcnKSB7XG4gICAgICBhZGRyZXNzLnB1c2goaGV4KVxuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQuZXJyb3IgPSB0cnVlXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgYnVmZmVyLmxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFxuICogQHJldHVybnMge0dldElQVjZSZXN1bHR9XG4gKi9cbmZ1bmN0aW9uIGdldElQVjYgKGlucHV0KSB7XG4gIGxldCB0b2tlbkNvdW50ID0gMFxuICBjb25zdCBvdXRwdXQgPSB7IGVycm9yOiBmYWxzZSwgYWRkcmVzczogJycsIHpvbmU6ICcnIH1cbiAgLyoqIEB0eXBlIHtBcnJheTxzdHJpbmc+fSAqL1xuICBjb25zdCBhZGRyZXNzID0gW11cbiAgLyoqIEB0eXBlIHtBcnJheTxzdHJpbmc+fSAqL1xuICBjb25zdCBidWZmZXIgPSBbXVxuICBsZXQgZW5kaXB2NkVuY291bnRlcmVkID0gZmFsc2VcbiAgbGV0IGVuZElwdjYgPSBmYWxzZVxuXG4gIGxldCBjb25zdW1lID0gY29uc3VtZUhleHRldHNcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY3Vyc29yID0gaW5wdXRbaV1cbiAgICBpZiAoY3Vyc29yID09PSAnWycgfHwgY3Vyc29yID09PSAnXScpIHsgY29udGludWUgfVxuICAgIGlmIChjdXJzb3IgPT09ICc6Jykge1xuICAgICAgaWYgKGVuZGlwdjZFbmNvdW50ZXJlZCA9PT0gdHJ1ZSkge1xuICAgICAgICBlbmRJcHY2ID0gdHJ1ZVxuICAgICAgfVxuICAgICAgaWYgKCFjb25zdW1lKGJ1ZmZlciwgYWRkcmVzcywgb3V0cHV0KSkgeyBicmVhayB9XG4gICAgICBpZiAoKyt0b2tlbkNvdW50ID4gNykge1xuICAgICAgICAvLyBub3QgdmFsaWRcbiAgICAgICAgb3V0cHV0LmVycm9yID0gdHJ1ZVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgaWYgKGkgPiAwICYmIGlucHV0W2kgLSAxXSA9PT0gJzonKSB7XG4gICAgICAgIGVuZGlwdjZFbmNvdW50ZXJlZCA9IHRydWVcbiAgICAgIH1cbiAgICAgIGFkZHJlc3MucHVzaCgnOicpXG4gICAgICBjb250aW51ZVxuICAgIH0gZWxzZSBpZiAoY3Vyc29yID09PSAnJScpIHtcbiAgICAgIGlmICghY29uc3VtZShidWZmZXIsIGFkZHJlc3MsIG91dHB1dCkpIHsgYnJlYWsgfVxuICAgICAgLy8gc3dpdGNoIHRvIHpvbmUgZGV0ZWN0aW9uXG4gICAgICBjb25zdW1lID0gY29uc3VtZUlzWm9uZVxuICAgIH0gZWxzZSB7XG4gICAgICBidWZmZXIucHVzaChjdXJzb3IpXG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgfVxuICBpZiAoYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChjb25zdW1lID09PSBjb25zdW1lSXNab25lKSB7XG4gICAgICBvdXRwdXQuem9uZSA9IGJ1ZmZlci5qb2luKCcnKVxuICAgIH0gZWxzZSBpZiAoZW5kSXB2Nikge1xuICAgICAgYWRkcmVzcy5wdXNoKGJ1ZmZlci5qb2luKCcnKSlcbiAgICB9IGVsc2Uge1xuICAgICAgYWRkcmVzcy5wdXNoKHN0cmluZ0FycmF5VG9IZXhTdHJpcHBlZChidWZmZXIpKVxuICAgIH1cbiAgfVxuICBvdXRwdXQuYWRkcmVzcyA9IGFkZHJlc3Muam9pbignJylcbiAgcmV0dXJuIG91dHB1dFxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE5vcm1hbGl6ZUlQdjZSZXN1bHRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBob3N0IC0gVGhlIG5vcm1hbGl6ZWQgaG9zdC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZXNjYXBlZEhvc3RdIC0gVGhlIGVzY2FwZWQgaG9zdC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNJUFY2IC0gSW5kaWNhdGVzIGlmIHRoZSBob3N0IGlzIGFuIElQdjYgYWRkcmVzcy5cbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBob3N0XG4gKiBAcmV0dXJucyB7Tm9ybWFsaXplSVB2NlJlc3VsdH1cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplSVB2NiAoaG9zdCkge1xuICBpZiAoZmluZFRva2VuKGhvc3QsICc6JykgPCAyKSB7IHJldHVybiB7IGhvc3QsIGlzSVBWNjogZmFsc2UgfSB9XG4gIGNvbnN0IGlwdjYgPSBnZXRJUFY2KGhvc3QpXG5cbiAgaWYgKCFpcHY2LmVycm9yKSB7XG4gICAgbGV0IG5ld0hvc3QgPSBpcHY2LmFkZHJlc3NcbiAgICBsZXQgZXNjYXBlZEhvc3QgPSBpcHY2LmFkZHJlc3NcbiAgICBpZiAoaXB2Ni56b25lKSB7XG4gICAgICBuZXdIb3N0ICs9ICclJyArIGlwdjYuem9uZVxuICAgICAgZXNjYXBlZEhvc3QgKz0gJyUyNScgKyBpcHY2LnpvbmVcbiAgICB9XG4gICAgcmV0dXJuIHsgaG9zdDogbmV3SG9zdCwgaXNJUFY2OiB0cnVlLCBlc2NhcGVkSG9zdCB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHsgaG9zdCwgaXNJUFY2OiBmYWxzZSB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9rZW5cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGZpbmRUb2tlbiAoc3RyLCB0b2tlbikge1xuICBsZXQgaW5kID0gMFxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChzdHJbaV0gPT09IHRva2VuKSBpbmQrK1xuICB9XG4gIHJldHVybiBpbmRcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aFxuICogQHJldHVybnMge3N0cmluZ31cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTUuMi40XG4gKi9cbmZ1bmN0aW9uIHJlbW92ZURvdFNlZ21lbnRzIChwYXRoKSB7XG4gIGxldCBpbnB1dCA9IHBhdGhcbiAgY29uc3Qgb3V0cHV0ID0gW11cbiAgbGV0IG5leHRTbGFzaCA9IC0xXG4gIGxldCBsZW4gPSAwXG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbmQtYXNzaWduXG4gIHdoaWxlIChsZW4gPSBpbnB1dC5sZW5ndGgpIHtcbiAgICBpZiAobGVuID09PSAxKSB7XG4gICAgICBpZiAoaW5wdXQgPT09ICcuJykge1xuICAgICAgICBicmVha1xuICAgICAgfSBlbHNlIGlmIChpbnB1dCA9PT0gJy8nKSB7XG4gICAgICAgIG91dHB1dC5wdXNoKCcvJylcbiAgICAgICAgYnJlYWtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dHB1dC5wdXNoKGlucHV0KVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobGVuID09PSAyKSB7XG4gICAgICBpZiAoaW5wdXRbMF0gPT09ICcuJykge1xuICAgICAgICBpZiAoaW5wdXRbMV0gPT09ICcuJykge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXRbMV0gPT09ICcvJykge1xuICAgICAgICAgIGlucHV0ID0gaW5wdXQuc2xpY2UoMilcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlucHV0WzBdID09PSAnLycpIHtcbiAgICAgICAgaWYgKGlucHV0WzFdID09PSAnLicgfHwgaW5wdXRbMV0gPT09ICcvJykge1xuICAgICAgICAgIG91dHB1dC5wdXNoKCcvJylcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsZW4gPT09IDMpIHtcbiAgICAgIGlmIChpbnB1dCA9PT0gJy8uLicpIHtcbiAgICAgICAgaWYgKG91dHB1dC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICBvdXRwdXQucG9wKClcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXQucHVzaCgnLycpXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpbnB1dFswXSA9PT0gJy4nKSB7XG4gICAgICBpZiAoaW5wdXRbMV0gPT09ICcuJykge1xuICAgICAgICBpZiAoaW5wdXRbMl0gPT09ICcvJykge1xuICAgICAgICAgIGlucHV0ID0gaW5wdXQuc2xpY2UoMylcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlucHV0WzFdID09PSAnLycpIHtcbiAgICAgICAgaW5wdXQgPSBpbnB1dC5zbGljZSgyKVxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaW5wdXRbMF0gPT09ICcvJykge1xuICAgICAgaWYgKGlucHV0WzFdID09PSAnLicpIHtcbiAgICAgICAgaWYgKGlucHV0WzJdID09PSAnLycpIHtcbiAgICAgICAgICBpbnB1dCA9IGlucHV0LnNsaWNlKDIpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dFsyXSA9PT0gJy4nKSB7XG4gICAgICAgICAgaWYgKGlucHV0WzNdID09PSAnLycpIHtcbiAgICAgICAgICAgIGlucHV0ID0gaW5wdXQuc2xpY2UoMylcbiAgICAgICAgICAgIGlmIChvdXRwdXQubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgIG91dHB1dC5wb3AoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSdWxlIDJFOiBNb3ZlIG5vcm1hbCBwYXRoIHNlZ21lbnQgdG8gb3V0cHV0XG4gICAgaWYgKChuZXh0U2xhc2ggPSBpbnB1dC5pbmRleE9mKCcvJywgMSkpID09PSAtMSkge1xuICAgICAgb3V0cHV0LnB1c2goaW5wdXQpXG4gICAgICBicmVha1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaChpbnB1dC5zbGljZSgwLCBuZXh0U2xhc2gpKVxuICAgICAgaW5wdXQgPSBpbnB1dC5zbGljZShuZXh0U2xhc2gpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi90eXBlcy9pbmRleCcpLlVSSUNvbXBvbmVudH0gY29tcG9uZW50XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGVzY1xuICogQHJldHVybnMge2ltcG9ydCgnLi4vdHlwZXMvaW5kZXgnKS5VUklDb21wb25lbnR9XG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nIChjb21wb25lbnQsIGVzYykge1xuICBjb25zdCBmdW5jID0gZXNjICE9PSB0cnVlID8gZXNjYXBlIDogdW5lc2NhcGVcbiAgaWYgKGNvbXBvbmVudC5zY2hlbWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbXBvbmVudC5zY2hlbWUgPSBmdW5jKGNvbXBvbmVudC5zY2hlbWUpXG4gIH1cbiAgaWYgKGNvbXBvbmVudC51c2VyaW5mbyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29tcG9uZW50LnVzZXJpbmZvID0gZnVuYyhjb21wb25lbnQudXNlcmluZm8pXG4gIH1cbiAgaWYgKGNvbXBvbmVudC5ob3N0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb21wb25lbnQuaG9zdCA9IGZ1bmMoY29tcG9uZW50Lmhvc3QpXG4gIH1cbiAgaWYgKGNvbXBvbmVudC5wYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb21wb25lbnQucGF0aCA9IGZ1bmMoY29tcG9uZW50LnBhdGgpXG4gIH1cbiAgaWYgKGNvbXBvbmVudC5xdWVyeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29tcG9uZW50LnF1ZXJ5ID0gZnVuYyhjb21wb25lbnQucXVlcnkpXG4gIH1cbiAgaWYgKGNvbXBvbmVudC5mcmFnbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29tcG9uZW50LmZyYWdtZW50ID0gZnVuYyhjb21wb25lbnQuZnJhZ21lbnQpXG4gIH1cbiAgcmV0dXJuIGNvbXBvbmVudFxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi90eXBlcy9pbmRleCcpLlVSSUNvbXBvbmVudH0gY29tcG9uZW50XG4gKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gcmVjb21wb3NlQXV0aG9yaXR5IChjb21wb25lbnQpIHtcbiAgY29uc3QgdXJpVG9rZW5zID0gW11cblxuICBpZiAoY29tcG9uZW50LnVzZXJpbmZvICE9PSB1bmRlZmluZWQpIHtcbiAgICB1cmlUb2tlbnMucHVzaChjb21wb25lbnQudXNlcmluZm8pXG4gICAgdXJpVG9rZW5zLnB1c2goJ0AnKVxuICB9XG5cbiAgaWYgKGNvbXBvbmVudC5ob3N0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBsZXQgaG9zdCA9IHVuZXNjYXBlKGNvbXBvbmVudC5ob3N0KVxuICAgIGlmICghaXNJUHY0KGhvc3QpKSB7XG4gICAgICBjb25zdCBpcFY2cmVzID0gbm9ybWFsaXplSVB2Nihob3N0KVxuICAgICAgaWYgKGlwVjZyZXMuaXNJUFY2ID09PSB0cnVlKSB7XG4gICAgICAgIGhvc3QgPSBgWyR7aXBWNnJlcy5lc2NhcGVkSG9zdH1dYFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaG9zdCA9IGNvbXBvbmVudC5ob3N0XG4gICAgICB9XG4gICAgfVxuICAgIHVyaVRva2Vucy5wdXNoKGhvc3QpXG4gIH1cblxuICBpZiAodHlwZW9mIGNvbXBvbmVudC5wb3J0ID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgY29tcG9uZW50LnBvcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgdXJpVG9rZW5zLnB1c2goJzonKVxuICAgIHVyaVRva2Vucy5wdXNoKFN0cmluZyhjb21wb25lbnQucG9ydCkpXG4gIH1cblxuICByZXR1cm4gdXJpVG9rZW5zLmxlbmd0aCA/IHVyaVRva2Vucy5qb2luKCcnKSA6IHVuZGVmaW5lZFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG5vblNpbXBsZURvbWFpbixcbiAgcmVjb21wb3NlQXV0aG9yaXR5LFxuICBub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyxcbiAgcmVtb3ZlRG90U2VnbWVudHMsXG4gIGlzSVB2NCxcbiAgaXNVVUlELFxuICBub3JtYWxpemVJUHY2LFxuICBzdHJpbmdBcnJheVRvSGV4U3RyaXBwZWRcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IGlzVVVJRCB9ID0gcmVxdWlyZSgnLi91dGlscycpXG5jb25zdCBVUk5fUkVHID0gLyhbXFxkYS16XVtcXGRcXC1hLXpdezAsMzF9KTooKD86W1xcdyEkJygpKissXFwtLjo7PUBdfCVbXFxkYS1mXXsyfSkrKS9pdVxuXG5jb25zdCBzdXBwb3J0ZWRTY2hlbWVOYW1lcyA9IC8qKiBAdHlwZSB7Y29uc3R9ICovIChbJ2h0dHAnLCAnaHR0cHMnLCAnd3MnLFxuICAnd3NzJywgJ3VybicsICd1cm46dXVpZCddKVxuXG4vKiogQHR5cGVkZWYge3N1cHBvcnRlZFNjaGVtZU5hbWVzW251bWJlcl19IFNjaGVtZU5hbWUgKi9cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybnMge25hbWUgaXMgU2NoZW1lTmFtZX1cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZFNjaGVtZU5hbWUgKG5hbWUpIHtcbiAgcmV0dXJuIHN1cHBvcnRlZFNjaGVtZU5hbWVzLmluZGV4T2YoLyoqIEB0eXBlIHsqfSAqLyAobmFtZSkpICE9PSAtMVxufVxuXG4vKipcbiAqIEBjYWxsYmFjayBTY2hlbWVGblxuICogQHBhcmFtIHtpbXBvcnQoJy4uL3R5cGVzL2luZGV4JykuVVJJQ29tcG9uZW50fSBjb21wb25lbnRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi90eXBlcy9pbmRleCcpLk9wdGlvbnN9IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4uL3R5cGVzL2luZGV4JykuVVJJQ29tcG9uZW50fVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gU2NoZW1lSGFuZGxlclxuICogQHByb3BlcnR5IHtTY2hlbWVOYW1lfSBzY2hlbWUgLSBUaGUgc2NoZW1lIG5hbWUuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtkb21haW5Ib3N0XSAtIEluZGljYXRlcyBpZiB0aGUgc2NoZW1lIHN1cHBvcnRzIGRvbWFpbiBob3N0cy5cbiAqIEBwcm9wZXJ0eSB7U2NoZW1lRm59IHBhcnNlIC0gRnVuY3Rpb24gdG8gcGFyc2UgdGhlIFVSSSBjb21wb25lbnQgZm9yIHRoaXMgc2NoZW1lLlxuICogQHByb3BlcnR5IHtTY2hlbWVGbn0gc2VyaWFsaXplIC0gRnVuY3Rpb24gdG8gc2VyaWFsaXplIHRoZSBVUkkgY29tcG9uZW50IGZvciB0aGlzIHNjaGVtZS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3NraXBOb3JtYWxpemVdIC0gSW5kaWNhdGVzIGlmIG5vcm1hbGl6YXRpb24gc2hvdWxkIGJlIHNraXBwZWQgZm9yIHRoaXMgc2NoZW1lLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbYWJzb2x1dGVQYXRoXSAtIEluZGljYXRlcyBpZiB0aGUgc2NoZW1lIHVzZXMgYWJzb2x1dGUgcGF0aHMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt1bmljb2RlU3VwcG9ydF0gLSBJbmRpY2F0ZXMgaWYgdGhlIHNjaGVtZSBzdXBwb3J0cyBVbmljb2RlLlxuICovXG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4uL3R5cGVzL2luZGV4JykuVVJJQ29tcG9uZW50fSB3c0NvbXBvbmVudFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIHdzSXNTZWN1cmUgKHdzQ29tcG9uZW50KSB7XG4gIGlmICh3c0NvbXBvbmVudC5zZWN1cmUgPT09IHRydWUpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9IGVsc2UgaWYgKHdzQ29tcG9uZW50LnNlY3VyZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGlmICh3c0NvbXBvbmVudC5zY2hlbWUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgd3NDb21wb25lbnQuc2NoZW1lLmxlbmd0aCA9PT0gMyAmJlxuICAgICAgKHdzQ29tcG9uZW50LnNjaGVtZVswXSA9PT0gJ3cnIHx8IHdzQ29tcG9uZW50LnNjaGVtZVswXSA9PT0gJ1cnKSAmJlxuICAgICAgKHdzQ29tcG9uZW50LnNjaGVtZVsxXSA9PT0gJ3MnIHx8IHdzQ29tcG9uZW50LnNjaGVtZVsxXSA9PT0gJ1MnKSAmJlxuICAgICAgKHdzQ29tcG9uZW50LnNjaGVtZVsyXSA9PT0gJ3MnIHx8IHdzQ29tcG9uZW50LnNjaGVtZVsyXSA9PT0gJ1MnKVxuICAgIClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG4vKiogQHR5cGUge1NjaGVtZUZufSAqL1xuZnVuY3Rpb24gaHR0cFBhcnNlIChjb21wb25lbnQpIHtcbiAgaWYgKCFjb21wb25lbnQuaG9zdCkge1xuICAgIGNvbXBvbmVudC5lcnJvciA9IGNvbXBvbmVudC5lcnJvciB8fCAnSFRUUCBVUklzIG11c3QgaGF2ZSBhIGhvc3QuJ1xuICB9XG5cbiAgcmV0dXJuIGNvbXBvbmVudFxufVxuXG4vKiogQHR5cGUge1NjaGVtZUZufSAqL1xuZnVuY3Rpb24gaHR0cFNlcmlhbGl6ZSAoY29tcG9uZW50KSB7XG4gIGNvbnN0IHNlY3VyZSA9IFN0cmluZyhjb21wb25lbnQuc2NoZW1lKS50b0xvd2VyQ2FzZSgpID09PSAnaHR0cHMnXG5cbiAgLy8gbm9ybWFsaXplIHRoZSBkZWZhdWx0IHBvcnRcbiAgaWYgKGNvbXBvbmVudC5wb3J0ID09PSAoc2VjdXJlID8gNDQzIDogODApIHx8IGNvbXBvbmVudC5wb3J0ID09PSAnJykge1xuICAgIGNvbXBvbmVudC5wb3J0ID0gdW5kZWZpbmVkXG4gIH1cblxuICAvLyBub3JtYWxpemUgdGhlIGVtcHR5IHBhdGhcbiAgaWYgKCFjb21wb25lbnQucGF0aCkge1xuICAgIGNvbXBvbmVudC5wYXRoID0gJy8nXG4gIH1cblxuICAvLyBOT1RFOiBXZSBkbyBub3QgcGFyc2UgcXVlcnkgc3RyaW5ncyBmb3IgSFRUUCBVUklzXG4gIC8vIGFzIFdXVyBGb3JtIFVybCBFbmNvZGVkIHF1ZXJ5IHN0cmluZ3MgYXJlIHBhcnQgb2YgdGhlIEhUTUw0KyBzcGVjLFxuICAvLyBhbmQgbm90IHRoZSBIVFRQIHNwZWMuXG5cbiAgcmV0dXJuIGNvbXBvbmVudFxufVxuXG4vKiogQHR5cGUge1NjaGVtZUZufSAqL1xuZnVuY3Rpb24gd3NQYXJzZSAod3NDb21wb25lbnQpIHtcbi8vIGluZGljYXRlIGlmIHRoZSBzZWN1cmUgZmxhZyBpcyBzZXRcbiAgd3NDb21wb25lbnQuc2VjdXJlID0gd3NJc1NlY3VyZSh3c0NvbXBvbmVudClcblxuICAvLyBjb25zdHJ1Y3QgcmVzb3VjZSBuYW1lXG4gIHdzQ29tcG9uZW50LnJlc291cmNlTmFtZSA9ICh3c0NvbXBvbmVudC5wYXRoIHx8ICcvJykgKyAod3NDb21wb25lbnQucXVlcnkgPyAnPycgKyB3c0NvbXBvbmVudC5xdWVyeSA6ICcnKVxuICB3c0NvbXBvbmVudC5wYXRoID0gdW5kZWZpbmVkXG4gIHdzQ29tcG9uZW50LnF1ZXJ5ID0gdW5kZWZpbmVkXG5cbiAgcmV0dXJuIHdzQ29tcG9uZW50XG59XG5cbi8qKiBAdHlwZSB7U2NoZW1lRm59ICovXG5mdW5jdGlvbiB3c1NlcmlhbGl6ZSAod3NDb21wb25lbnQpIHtcbi8vIG5vcm1hbGl6ZSB0aGUgZGVmYXVsdCBwb3J0XG4gIGlmICh3c0NvbXBvbmVudC5wb3J0ID09PSAod3NJc1NlY3VyZSh3c0NvbXBvbmVudCkgPyA0NDMgOiA4MCkgfHwgd3NDb21wb25lbnQucG9ydCA9PT0gJycpIHtcbiAgICB3c0NvbXBvbmVudC5wb3J0ID0gdW5kZWZpbmVkXG4gIH1cblxuICAvLyBlbnN1cmUgc2NoZW1lIG1hdGNoZXMgc2VjdXJlIGZsYWdcbiAgaWYgKHR5cGVvZiB3c0NvbXBvbmVudC5zZWN1cmUgPT09ICdib29sZWFuJykge1xuICAgIHdzQ29tcG9uZW50LnNjaGVtZSA9ICh3c0NvbXBvbmVudC5zZWN1cmUgPyAnd3NzJyA6ICd3cycpXG4gICAgd3NDb21wb25lbnQuc2VjdXJlID0gdW5kZWZpbmVkXG4gIH1cblxuICAvLyByZWNvbnN0cnVjdCBwYXRoIGZyb20gcmVzb3VyY2UgbmFtZVxuICBpZiAod3NDb21wb25lbnQucmVzb3VyY2VOYW1lKSB7XG4gICAgY29uc3QgW3BhdGgsIHF1ZXJ5XSA9IHdzQ29tcG9uZW50LnJlc291cmNlTmFtZS5zcGxpdCgnPycpXG4gICAgd3NDb21wb25lbnQucGF0aCA9IChwYXRoICYmIHBhdGggIT09ICcvJyA/IHBhdGggOiB1bmRlZmluZWQpXG4gICAgd3NDb21wb25lbnQucXVlcnkgPSBxdWVyeVxuICAgIHdzQ29tcG9uZW50LnJlc291cmNlTmFtZSA9IHVuZGVmaW5lZFxuICB9XG5cbiAgLy8gZm9yYmlkIGZyYWdtZW50IGNvbXBvbmVudFxuICB3c0NvbXBvbmVudC5mcmFnbWVudCA9IHVuZGVmaW5lZFxuXG4gIHJldHVybiB3c0NvbXBvbmVudFxufVxuXG4vKiogQHR5cGUge1NjaGVtZUZufSAqL1xuZnVuY3Rpb24gdXJuUGFyc2UgKHVybkNvbXBvbmVudCwgb3B0aW9ucykge1xuICBpZiAoIXVybkNvbXBvbmVudC5wYXRoKSB7XG4gICAgdXJuQ29tcG9uZW50LmVycm9yID0gJ1VSTiBjYW4gbm90IGJlIHBhcnNlZCdcbiAgICByZXR1cm4gdXJuQ29tcG9uZW50XG4gIH1cbiAgY29uc3QgbWF0Y2hlcyA9IHVybkNvbXBvbmVudC5wYXRoLm1hdGNoKFVSTl9SRUcpXG4gIGlmIChtYXRjaGVzKSB7XG4gICAgY29uc3Qgc2NoZW1lID0gb3B0aW9ucy5zY2hlbWUgfHwgdXJuQ29tcG9uZW50LnNjaGVtZSB8fCAndXJuJ1xuICAgIHVybkNvbXBvbmVudC5uaWQgPSBtYXRjaGVzWzFdLnRvTG93ZXJDYXNlKClcbiAgICB1cm5Db21wb25lbnQubnNzID0gbWF0Y2hlc1syXVxuICAgIGNvbnN0IHVyblNjaGVtZSA9IGAke3NjaGVtZX06JHtvcHRpb25zLm5pZCB8fCB1cm5Db21wb25lbnQubmlkfWBcbiAgICBjb25zdCBzY2hlbWVIYW5kbGVyID0gZ2V0U2NoZW1lSGFuZGxlcih1cm5TY2hlbWUpXG4gICAgdXJuQ29tcG9uZW50LnBhdGggPSB1bmRlZmluZWRcblxuICAgIGlmIChzY2hlbWVIYW5kbGVyKSB7XG4gICAgICB1cm5Db21wb25lbnQgPSBzY2hlbWVIYW5kbGVyLnBhcnNlKHVybkNvbXBvbmVudCwgb3B0aW9ucylcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdXJuQ29tcG9uZW50LmVycm9yID0gdXJuQ29tcG9uZW50LmVycm9yIHx8ICdVUk4gY2FuIG5vdCBiZSBwYXJzZWQuJ1xuICB9XG5cbiAgcmV0dXJuIHVybkNvbXBvbmVudFxufVxuXG4vKiogQHR5cGUge1NjaGVtZUZufSAqL1xuZnVuY3Rpb24gdXJuU2VyaWFsaXplICh1cm5Db21wb25lbnQsIG9wdGlvbnMpIHtcbiAgaWYgKHVybkNvbXBvbmVudC5uaWQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVVJOIHdpdGhvdXQgbmlkIGNhbm5vdCBiZSBzZXJpYWxpemVkJylcbiAgfVxuICBjb25zdCBzY2hlbWUgPSBvcHRpb25zLnNjaGVtZSB8fCB1cm5Db21wb25lbnQuc2NoZW1lIHx8ICd1cm4nXG4gIGNvbnN0IG5pZCA9IHVybkNvbXBvbmVudC5uaWQudG9Mb3dlckNhc2UoKVxuICBjb25zdCB1cm5TY2hlbWUgPSBgJHtzY2hlbWV9OiR7b3B0aW9ucy5uaWQgfHwgbmlkfWBcbiAgY29uc3Qgc2NoZW1lSGFuZGxlciA9IGdldFNjaGVtZUhhbmRsZXIodXJuU2NoZW1lKVxuXG4gIGlmIChzY2hlbWVIYW5kbGVyKSB7XG4gICAgdXJuQ29tcG9uZW50ID0gc2NoZW1lSGFuZGxlci5zZXJpYWxpemUodXJuQ29tcG9uZW50LCBvcHRpb25zKVxuICB9XG5cbiAgY29uc3QgdXJpQ29tcG9uZW50ID0gdXJuQ29tcG9uZW50XG4gIGNvbnN0IG5zcyA9IHVybkNvbXBvbmVudC5uc3NcbiAgdXJpQ29tcG9uZW50LnBhdGggPSBgJHtuaWQgfHwgb3B0aW9ucy5uaWR9OiR7bnNzfWBcblxuICBvcHRpb25zLnNraXBFc2NhcGUgPSB0cnVlXG4gIHJldHVybiB1cmlDb21wb25lbnRcbn1cblxuLyoqIEB0eXBlIHtTY2hlbWVGbn0gKi9cbmZ1bmN0aW9uIHVybnV1aWRQYXJzZSAodXJuQ29tcG9uZW50LCBvcHRpb25zKSB7XG4gIGNvbnN0IHV1aWRDb21wb25lbnQgPSB1cm5Db21wb25lbnRcbiAgdXVpZENvbXBvbmVudC51dWlkID0gdXVpZENvbXBvbmVudC5uc3NcbiAgdXVpZENvbXBvbmVudC5uc3MgPSB1bmRlZmluZWRcblxuICBpZiAoIW9wdGlvbnMudG9sZXJhbnQgJiYgKCF1dWlkQ29tcG9uZW50LnV1aWQgfHwgIWlzVVVJRCh1dWlkQ29tcG9uZW50LnV1aWQpKSkge1xuICAgIHV1aWRDb21wb25lbnQuZXJyb3IgPSB1dWlkQ29tcG9uZW50LmVycm9yIHx8ICdVVUlEIGlzIG5vdCB2YWxpZC4nXG4gIH1cblxuICByZXR1cm4gdXVpZENvbXBvbmVudFxufVxuXG4vKiogQHR5cGUge1NjaGVtZUZufSAqL1xuZnVuY3Rpb24gdXJudXVpZFNlcmlhbGl6ZSAodXVpZENvbXBvbmVudCkge1xuICBjb25zdCB1cm5Db21wb25lbnQgPSB1dWlkQ29tcG9uZW50XG4gIC8vIG5vcm1hbGl6ZSBVVUlEXG4gIHVybkNvbXBvbmVudC5uc3MgPSAodXVpZENvbXBvbmVudC51dWlkIHx8ICcnKS50b0xvd2VyQ2FzZSgpXG4gIHJldHVybiB1cm5Db21wb25lbnRcbn1cblxuY29uc3QgaHR0cCA9IC8qKiBAdHlwZSB7U2NoZW1lSGFuZGxlcn0gKi8gKHtcbiAgc2NoZW1lOiAnaHR0cCcsXG4gIGRvbWFpbkhvc3Q6IHRydWUsXG4gIHBhcnNlOiBodHRwUGFyc2UsXG4gIHNlcmlhbGl6ZTogaHR0cFNlcmlhbGl6ZVxufSlcblxuY29uc3QgaHR0cHMgPSAvKiogQHR5cGUge1NjaGVtZUhhbmRsZXJ9ICovICh7XG4gIHNjaGVtZTogJ2h0dHBzJyxcbiAgZG9tYWluSG9zdDogaHR0cC5kb21haW5Ib3N0LFxuICBwYXJzZTogaHR0cFBhcnNlLFxuICBzZXJpYWxpemU6IGh0dHBTZXJpYWxpemVcbn0pXG5cbmNvbnN0IHdzID0gLyoqIEB0eXBlIHtTY2hlbWVIYW5kbGVyfSAqLyAoe1xuICBzY2hlbWU6ICd3cycsXG4gIGRvbWFpbkhvc3Q6IHRydWUsXG4gIHBhcnNlOiB3c1BhcnNlLFxuICBzZXJpYWxpemU6IHdzU2VyaWFsaXplXG59KVxuXG5jb25zdCB3c3MgPSAvKiogQHR5cGUge1NjaGVtZUhhbmRsZXJ9ICovICh7XG4gIHNjaGVtZTogJ3dzcycsXG4gIGRvbWFpbkhvc3Q6IHdzLmRvbWFpbkhvc3QsXG4gIHBhcnNlOiB3cy5wYXJzZSxcbiAgc2VyaWFsaXplOiB3cy5zZXJpYWxpemVcbn0pXG5cbmNvbnN0IHVybiA9IC8qKiBAdHlwZSB7U2NoZW1lSGFuZGxlcn0gKi8gKHtcbiAgc2NoZW1lOiAndXJuJyxcbiAgcGFyc2U6IHVyblBhcnNlLFxuICBzZXJpYWxpemU6IHVyblNlcmlhbGl6ZSxcbiAgc2tpcE5vcm1hbGl6ZTogdHJ1ZVxufSlcblxuY29uc3QgdXJudXVpZCA9IC8qKiBAdHlwZSB7U2NoZW1lSGFuZGxlcn0gKi8gKHtcbiAgc2NoZW1lOiAndXJuOnV1aWQnLFxuICBwYXJzZTogdXJudXVpZFBhcnNlLFxuICBzZXJpYWxpemU6IHVybnV1aWRTZXJpYWxpemUsXG4gIHNraXBOb3JtYWxpemU6IHRydWVcbn0pXG5cbmNvbnN0IFNDSEVNRVMgPSAvKiogQHR5cGUge1JlY29yZDxTY2hlbWVOYW1lLCBTY2hlbWVIYW5kbGVyPn0gKi8gKHtcbiAgaHR0cCxcbiAgaHR0cHMsXG4gIHdzLFxuICB3c3MsXG4gIHVybixcbiAgJ3Vybjp1dWlkJzogdXJudXVpZFxufSlcblxuT2JqZWN0LnNldFByb3RvdHlwZU9mKFNDSEVNRVMsIG51bGwpXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8dW5kZWZpbmVkfSBzY2hlbWVcbiAqIEByZXR1cm5zIHtTY2hlbWVIYW5kbGVyfHVuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gZ2V0U2NoZW1lSGFuZGxlciAoc2NoZW1lKSB7XG4gIHJldHVybiAoXG4gICAgc2NoZW1lICYmIChcbiAgICAgIFNDSEVNRVNbLyoqIEB0eXBlIHtTY2hlbWVOYW1lfSAqLyAoc2NoZW1lKV0gfHxcbiAgICAgIFNDSEVNRVNbLyoqIEB0eXBlIHtTY2hlbWVOYW1lfSAqLyhzY2hlbWUudG9Mb3dlckNhc2UoKSldKVxuICApIHx8XG4gICAgdW5kZWZpbmVkXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB3c0lzU2VjdXJlLFxuICBTQ0hFTUVTLFxuICBpc1ZhbGlkU2NoZW1lTmFtZSxcbiAgZ2V0U2NoZW1lSGFuZGxlcixcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IG5vcm1hbGl6ZUlQdjYsIHJlbW92ZURvdFNlZ21lbnRzLCByZWNvbXBvc2VBdXRob3JpdHksIG5vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nLCBpc0lQdjQsIG5vblNpbXBsZURvbWFpbiB9ID0gcmVxdWlyZSgnLi9saWIvdXRpbHMnKVxuY29uc3QgeyBTQ0hFTUVTLCBnZXRTY2hlbWVIYW5kbGVyIH0gPSByZXF1aXJlKCcuL2xpYi9zY2hlbWVzJylcblxuLyoqXG4gKiBAdGVtcGxhdGUge2ltcG9ydCgnLi90eXBlcy9pbmRleCcpLlVSSUNvbXBvbmVudHxzdHJpbmd9IFRcbiAqIEBwYXJhbSB7VH0gdXJpXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi90eXBlcy9pbmRleCcpLk9wdGlvbnN9IFtvcHRpb25zXVxuICogQHJldHVybnMge1R9XG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZSAodXJpLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgdXJpID09PSAnc3RyaW5nJykge1xuICAgIHVyaSA9IC8qKiBAdHlwZSB7VH0gKi8gKHNlcmlhbGl6ZShwYXJzZSh1cmksIG9wdGlvbnMpLCBvcHRpb25zKSlcbiAgfSBlbHNlIGlmICh0eXBlb2YgdXJpID09PSAnb2JqZWN0Jykge1xuICAgIHVyaSA9IC8qKiBAdHlwZSB7VH0gKi8gKHBhcnNlKHNlcmlhbGl6ZSh1cmksIG9wdGlvbnMpLCBvcHRpb25zKSlcbiAgfVxuICByZXR1cm4gdXJpXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUklcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWxhdGl2ZVVSSVxuICogQHBhcmFtIHtpbXBvcnQoJy4vdHlwZXMvaW5kZXgnKS5PcHRpb25zfSBbb3B0aW9uc11cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHJlc29sdmUgKGJhc2VVUkksIHJlbGF0aXZlVVJJLCBvcHRpb25zKSB7XG4gIGNvbnN0IHNjaGVtZWxlc3NPcHRpb25zID0gb3B0aW9ucyA/IE9iamVjdC5hc3NpZ24oeyBzY2hlbWU6ICdudWxsJyB9LCBvcHRpb25zKSA6IHsgc2NoZW1lOiAnbnVsbCcgfVxuICBjb25zdCByZXNvbHZlZCA9IHJlc29sdmVDb21wb25lbnQocGFyc2UoYmFzZVVSSSwgc2NoZW1lbGVzc09wdGlvbnMpLCBwYXJzZShyZWxhdGl2ZVVSSSwgc2NoZW1lbGVzc09wdGlvbnMpLCBzY2hlbWVsZXNzT3B0aW9ucywgdHJ1ZSlcbiAgc2NoZW1lbGVzc09wdGlvbnMuc2tpcEVzY2FwZSA9IHRydWVcbiAgcmV0dXJuIHNlcmlhbGl6ZShyZXNvbHZlZCwgc2NoZW1lbGVzc09wdGlvbnMpXG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQgKCcuL3R5cGVzL2luZGV4JykuVVJJQ29tcG9uZW50fSBiYXNlXG4gKiBAcGFyYW0ge2ltcG9ydCAoJy4vdHlwZXMvaW5kZXgnKS5VUklDb21wb25lbnR9IHJlbGF0aXZlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi90eXBlcy9pbmRleCcpLk9wdGlvbnN9IFtvcHRpb25zXVxuICogQHBhcmFtIHtib29sZWFufSBbc2tpcE5vcm1hbGl6YXRpb249ZmFsc2VdXG4gKiBAcmV0dXJucyB7aW1wb3J0ICgnLi90eXBlcy9pbmRleCcpLlVSSUNvbXBvbmVudH1cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUNvbXBvbmVudCAoYmFzZSwgcmVsYXRpdmUsIG9wdGlvbnMsIHNraXBOb3JtYWxpemF0aW9uKSB7XG4gIC8qKiBAdHlwZSB7aW1wb3J0KCcuL3R5cGVzL2luZGV4JykuVVJJQ29tcG9uZW50fSAqL1xuICBjb25zdCB0YXJnZXQgPSB7fVxuICBpZiAoIXNraXBOb3JtYWxpemF0aW9uKSB7XG4gICAgYmFzZSA9IHBhcnNlKHNlcmlhbGl6ZShiYXNlLCBvcHRpb25zKSwgb3B0aW9ucykgLy8gbm9ybWFsaXplIGJhc2UgY29tcG9uZW50XG4gICAgcmVsYXRpdmUgPSBwYXJzZShzZXJpYWxpemUocmVsYXRpdmUsIG9wdGlvbnMpLCBvcHRpb25zKSAvLyBub3JtYWxpemUgcmVsYXRpdmUgY29tcG9uZW50XG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblxuICBpZiAoIW9wdGlvbnMudG9sZXJhbnQgJiYgcmVsYXRpdmUuc2NoZW1lKSB7XG4gICAgdGFyZ2V0LnNjaGVtZSA9IHJlbGF0aXZlLnNjaGVtZVxuICAgIC8vIHRhcmdldC5hdXRob3JpdHkgPSByZWxhdGl2ZS5hdXRob3JpdHk7XG4gICAgdGFyZ2V0LnVzZXJpbmZvID0gcmVsYXRpdmUudXNlcmluZm9cbiAgICB0YXJnZXQuaG9zdCA9IHJlbGF0aXZlLmhvc3RcbiAgICB0YXJnZXQucG9ydCA9IHJlbGF0aXZlLnBvcnRcbiAgICB0YXJnZXQucGF0aCA9IHJlbW92ZURvdFNlZ21lbnRzKHJlbGF0aXZlLnBhdGggfHwgJycpXG4gICAgdGFyZ2V0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnlcbiAgfSBlbHNlIHtcbiAgICBpZiAocmVsYXRpdmUudXNlcmluZm8gIT09IHVuZGVmaW5lZCB8fCByZWxhdGl2ZS5ob3N0ICE9PSB1bmRlZmluZWQgfHwgcmVsYXRpdmUucG9ydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyB0YXJnZXQuYXV0aG9yaXR5ID0gcmVsYXRpdmUuYXV0aG9yaXR5O1xuICAgICAgdGFyZ2V0LnVzZXJpbmZvID0gcmVsYXRpdmUudXNlcmluZm9cbiAgICAgIHRhcmdldC5ob3N0ID0gcmVsYXRpdmUuaG9zdFxuICAgICAgdGFyZ2V0LnBvcnQgPSByZWxhdGl2ZS5wb3J0XG4gICAgICB0YXJnZXQucGF0aCA9IHJlbW92ZURvdFNlZ21lbnRzKHJlbGF0aXZlLnBhdGggfHwgJycpXG4gICAgICB0YXJnZXQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXJlbGF0aXZlLnBhdGgpIHtcbiAgICAgICAgdGFyZ2V0LnBhdGggPSBiYXNlLnBhdGhcbiAgICAgICAgaWYgKHJlbGF0aXZlLnF1ZXJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0YXJnZXQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldC5xdWVyeSA9IGJhc2UucXVlcnlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHJlbGF0aXZlLnBhdGhbMF0gPT09ICcvJykge1xuICAgICAgICAgIHRhcmdldC5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHMocmVsYXRpdmUucGF0aClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoKGJhc2UudXNlcmluZm8gIT09IHVuZGVmaW5lZCB8fCBiYXNlLmhvc3QgIT09IHVuZGVmaW5lZCB8fCBiYXNlLnBvcnQgIT09IHVuZGVmaW5lZCkgJiYgIWJhc2UucGF0aCkge1xuICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSAnLycgKyByZWxhdGl2ZS5wYXRoXG4gICAgICAgICAgfSBlbHNlIGlmICghYmFzZS5wYXRoKSB7XG4gICAgICAgICAgICB0YXJnZXQucGF0aCA9IHJlbGF0aXZlLnBhdGhcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSBiYXNlLnBhdGguc2xpY2UoMCwgYmFzZS5wYXRoLmxhc3RJbmRleE9mKCcvJykgKyAxKSArIHJlbGF0aXZlLnBhdGhcbiAgICAgICAgICB9XG4gICAgICAgICAgdGFyZ2V0LnBhdGggPSByZW1vdmVEb3RTZWdtZW50cyh0YXJnZXQucGF0aClcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeVxuICAgICAgfVxuICAgICAgLy8gdGFyZ2V0LmF1dGhvcml0eSA9IGJhc2UuYXV0aG9yaXR5O1xuICAgICAgdGFyZ2V0LnVzZXJpbmZvID0gYmFzZS51c2VyaW5mb1xuICAgICAgdGFyZ2V0Lmhvc3QgPSBiYXNlLmhvc3RcbiAgICAgIHRhcmdldC5wb3J0ID0gYmFzZS5wb3J0XG4gICAgfVxuICAgIHRhcmdldC5zY2hlbWUgPSBiYXNlLnNjaGVtZVxuICB9XG5cbiAgdGFyZ2V0LmZyYWdtZW50ID0gcmVsYXRpdmUuZnJhZ21lbnRcblxuICByZXR1cm4gdGFyZ2V0XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQgKCcuL3R5cGVzL2luZGV4JykuVVJJQ29tcG9uZW50fHN0cmluZ30gdXJpQVxuICogQHBhcmFtIHtpbXBvcnQgKCcuL3R5cGVzL2luZGV4JykuVVJJQ29tcG9uZW50fHN0cmluZ30gdXJpQlxuICogQHBhcmFtIHtpbXBvcnQgKCcuL3R5cGVzL2luZGV4JykuT3B0aW9uc30gb3B0aW9uc1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGVxdWFsICh1cmlBLCB1cmlCLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgdXJpQSA9PT0gJ3N0cmluZycpIHtcbiAgICB1cmlBID0gdW5lc2NhcGUodXJpQSlcbiAgICB1cmlBID0gc2VyaWFsaXplKG5vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nKHBhcnNlKHVyaUEsIG9wdGlvbnMpLCB0cnVlKSwgeyAuLi5vcHRpb25zLCBza2lwRXNjYXBlOiB0cnVlIH0pXG4gIH0gZWxzZSBpZiAodHlwZW9mIHVyaUEgPT09ICdvYmplY3QnKSB7XG4gICAgdXJpQSA9IHNlcmlhbGl6ZShub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyh1cmlBLCB0cnVlKSwgeyAuLi5vcHRpb25zLCBza2lwRXNjYXBlOiB0cnVlIH0pXG4gIH1cblxuICBpZiAodHlwZW9mIHVyaUIgPT09ICdzdHJpbmcnKSB7XG4gICAgdXJpQiA9IHVuZXNjYXBlKHVyaUIpXG4gICAgdXJpQiA9IHNlcmlhbGl6ZShub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyhwYXJzZSh1cmlCLCBvcHRpb25zKSwgdHJ1ZSksIHsgLi4ub3B0aW9ucywgc2tpcEVzY2FwZTogdHJ1ZSB9KVxuICB9IGVsc2UgaWYgKHR5cGVvZiB1cmlCID09PSAnb2JqZWN0Jykge1xuICAgIHVyaUIgPSBzZXJpYWxpemUobm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcodXJpQiwgdHJ1ZSksIHsgLi4ub3B0aW9ucywgc2tpcEVzY2FwZTogdHJ1ZSB9KVxuICB9XG5cbiAgcmV0dXJuIHVyaUEudG9Mb3dlckNhc2UoKSA9PT0gdXJpQi50b0xvd2VyQ2FzZSgpXG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWFkb25seTxpbXBvcnQoJy4vdHlwZXMvaW5kZXgnKS5VUklDb21wb25lbnQ+fSBjbXB0c1xuICogQHBhcmFtIHtpbXBvcnQoJy4vdHlwZXMvaW5kZXgnKS5PcHRpb25zfSBbb3B0c11cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHNlcmlhbGl6ZSAoY21wdHMsIG9wdHMpIHtcbiAgY29uc3QgY29tcG9uZW50ID0ge1xuICAgIGhvc3Q6IGNtcHRzLmhvc3QsXG4gICAgc2NoZW1lOiBjbXB0cy5zY2hlbWUsXG4gICAgdXNlcmluZm86IGNtcHRzLnVzZXJpbmZvLFxuICAgIHBvcnQ6IGNtcHRzLnBvcnQsXG4gICAgcGF0aDogY21wdHMucGF0aCxcbiAgICBxdWVyeTogY21wdHMucXVlcnksXG4gICAgbmlkOiBjbXB0cy5uaWQsXG4gICAgbnNzOiBjbXB0cy5uc3MsXG4gICAgdXVpZDogY21wdHMudXVpZCxcbiAgICBmcmFnbWVudDogY21wdHMuZnJhZ21lbnQsXG4gICAgcmVmZXJlbmNlOiBjbXB0cy5yZWZlcmVuY2UsXG4gICAgcmVzb3VyY2VOYW1lOiBjbXB0cy5yZXNvdXJjZU5hbWUsXG4gICAgc2VjdXJlOiBjbXB0cy5zZWN1cmUsXG4gICAgZXJyb3I6ICcnXG4gIH1cbiAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdHMpXG4gIGNvbnN0IHVyaVRva2VucyA9IFtdXG5cbiAgLy8gZmluZCBzY2hlbWUgaGFuZGxlclxuICBjb25zdCBzY2hlbWVIYW5kbGVyID0gZ2V0U2NoZW1lSGFuZGxlcihvcHRpb25zLnNjaGVtZSB8fCBjb21wb25lbnQuc2NoZW1lKVxuXG4gIC8vIHBlcmZvcm0gc2NoZW1lIHNwZWNpZmljIHNlcmlhbGl6YXRpb25cbiAgaWYgKHNjaGVtZUhhbmRsZXIgJiYgc2NoZW1lSGFuZGxlci5zZXJpYWxpemUpIHNjaGVtZUhhbmRsZXIuc2VyaWFsaXplKGNvbXBvbmVudCwgb3B0aW9ucylcblxuICBpZiAoY29tcG9uZW50LnBhdGggIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICghb3B0aW9ucy5za2lwRXNjYXBlKSB7XG4gICAgICBjb21wb25lbnQucGF0aCA9IGVzY2FwZShjb21wb25lbnQucGF0aClcblxuICAgICAgaWYgKGNvbXBvbmVudC5zY2hlbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb21wb25lbnQucGF0aCA9IGNvbXBvbmVudC5wYXRoLnNwbGl0KCclM0EnKS5qb2luKCc6JylcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29tcG9uZW50LnBhdGggPSB1bmVzY2FwZShjb21wb25lbnQucGF0aClcbiAgICB9XG4gIH1cblxuICBpZiAob3B0aW9ucy5yZWZlcmVuY2UgIT09ICdzdWZmaXgnICYmIGNvbXBvbmVudC5zY2hlbWUpIHtcbiAgICB1cmlUb2tlbnMucHVzaChjb21wb25lbnQuc2NoZW1lLCAnOicpXG4gIH1cblxuICBjb25zdCBhdXRob3JpdHkgPSByZWNvbXBvc2VBdXRob3JpdHkoY29tcG9uZW50KVxuICBpZiAoYXV0aG9yaXR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAob3B0aW9ucy5yZWZlcmVuY2UgIT09ICdzdWZmaXgnKSB7XG4gICAgICB1cmlUb2tlbnMucHVzaCgnLy8nKVxuICAgIH1cblxuICAgIHVyaVRva2Vucy5wdXNoKGF1dGhvcml0eSlcblxuICAgIGlmIChjb21wb25lbnQucGF0aCAmJiBjb21wb25lbnQucGF0aFswXSAhPT0gJy8nKSB7XG4gICAgICB1cmlUb2tlbnMucHVzaCgnLycpXG4gICAgfVxuICB9XG4gIGlmIChjb21wb25lbnQucGF0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgbGV0IHMgPSBjb21wb25lbnQucGF0aFxuXG4gICAgaWYgKCFvcHRpb25zLmFic29sdXRlUGF0aCAmJiAoIXNjaGVtZUhhbmRsZXIgfHwgIXNjaGVtZUhhbmRsZXIuYWJzb2x1dGVQYXRoKSkge1xuICAgICAgcyA9IHJlbW92ZURvdFNlZ21lbnRzKHMpXG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgYXV0aG9yaXR5ID09PSB1bmRlZmluZWQgJiZcbiAgICAgIHNbMF0gPT09ICcvJyAmJlxuICAgICAgc1sxXSA9PT0gJy8nXG4gICAgKSB7XG4gICAgICAvLyBkb24ndCBhbGxvdyB0aGUgcGF0aCB0byBzdGFydCB3aXRoIFwiLy9cIlxuICAgICAgcyA9ICcvJTJGJyArIHMuc2xpY2UoMilcbiAgICB9XG5cbiAgICB1cmlUb2tlbnMucHVzaChzKVxuICB9XG5cbiAgaWYgKGNvbXBvbmVudC5xdWVyeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdXJpVG9rZW5zLnB1c2goJz8nLCBjb21wb25lbnQucXVlcnkpXG4gIH1cblxuICBpZiAoY29tcG9uZW50LmZyYWdtZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICB1cmlUb2tlbnMucHVzaCgnIycsIGNvbXBvbmVudC5mcmFnbWVudClcbiAgfVxuICByZXR1cm4gdXJpVG9rZW5zLmpvaW4oJycpXG59XG5cbmNvbnN0IFVSSV9QQVJTRSA9IC9eKD86KFteIy86P10rKTopPyg/OlxcL1xcLygoPzooW14jLz9AXSopQCk/KFxcW1teIy8/XFxdXStcXF18W14jLzo/XSopKD86OihcXGQqKSk/KSk/KFteIz9dKikoPzpcXD8oW14jXSopKT8oPzojKCg/Oi58W1xcblxccl0pKikpPy91XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHVyaVxuICogQHBhcmFtIHtpbXBvcnQoJy4vdHlwZXMvaW5kZXgnKS5PcHRpb25zfSBbb3B0c11cbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIHBhcnNlICh1cmksIG9wdHMpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdHMpXG4gIC8qKiBAdHlwZSB7aW1wb3J0KCcuL3R5cGVzL2luZGV4JykuVVJJQ29tcG9uZW50fSAqL1xuICBjb25zdCBwYXJzZWQgPSB7XG4gICAgc2NoZW1lOiB1bmRlZmluZWQsXG4gICAgdXNlcmluZm86IHVuZGVmaW5lZCxcbiAgICBob3N0OiAnJyxcbiAgICBwb3J0OiB1bmRlZmluZWQsXG4gICAgcGF0aDogJycsXG4gICAgcXVlcnk6IHVuZGVmaW5lZCxcbiAgICBmcmFnbWVudDogdW5kZWZpbmVkXG4gIH1cblxuICBsZXQgaXNJUCA9IGZhbHNlXG4gIGlmIChvcHRpb25zLnJlZmVyZW5jZSA9PT0gJ3N1ZmZpeCcpIHtcbiAgICBpZiAob3B0aW9ucy5zY2hlbWUpIHtcbiAgICAgIHVyaSA9IG9wdGlvbnMuc2NoZW1lICsgJzonICsgdXJpXG4gICAgfSBlbHNlIHtcbiAgICAgIHVyaSA9ICcvLycgKyB1cmlcbiAgICB9XG4gIH1cblxuICBjb25zdCBtYXRjaGVzID0gdXJpLm1hdGNoKFVSSV9QQVJTRSlcblxuICBpZiAobWF0Y2hlcykge1xuICAgIC8vIHN0b3JlIGVhY2ggY29tcG9uZW50XG4gICAgcGFyc2VkLnNjaGVtZSA9IG1hdGNoZXNbMV1cbiAgICBwYXJzZWQudXNlcmluZm8gPSBtYXRjaGVzWzNdXG4gICAgcGFyc2VkLmhvc3QgPSBtYXRjaGVzWzRdXG4gICAgcGFyc2VkLnBvcnQgPSBwYXJzZUludChtYXRjaGVzWzVdLCAxMClcbiAgICBwYXJzZWQucGF0aCA9IG1hdGNoZXNbNl0gfHwgJydcbiAgICBwYXJzZWQucXVlcnkgPSBtYXRjaGVzWzddXG4gICAgcGFyc2VkLmZyYWdtZW50ID0gbWF0Y2hlc1s4XVxuXG4gICAgLy8gZml4IHBvcnQgbnVtYmVyXG4gICAgaWYgKGlzTmFOKHBhcnNlZC5wb3J0KSkge1xuICAgICAgcGFyc2VkLnBvcnQgPSBtYXRjaGVzWzVdXG4gICAgfVxuICAgIGlmIChwYXJzZWQuaG9zdCkge1xuICAgICAgY29uc3QgaXB2NHJlc3VsdCA9IGlzSVB2NChwYXJzZWQuaG9zdClcbiAgICAgIGlmIChpcHY0cmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICBjb25zdCBpcHY2cmVzdWx0ID0gbm9ybWFsaXplSVB2NihwYXJzZWQuaG9zdClcbiAgICAgICAgcGFyc2VkLmhvc3QgPSBpcHY2cmVzdWx0Lmhvc3QudG9Mb3dlckNhc2UoKVxuICAgICAgICBpc0lQID0gaXB2NnJlc3VsdC5pc0lQVjZcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlzSVAgPSB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwYXJzZWQuc2NoZW1lID09PSB1bmRlZmluZWQgJiYgcGFyc2VkLnVzZXJpbmZvID09PSB1bmRlZmluZWQgJiYgcGFyc2VkLmhvc3QgPT09IHVuZGVmaW5lZCAmJiBwYXJzZWQucG9ydCA9PT0gdW5kZWZpbmVkICYmIHBhcnNlZC5xdWVyeSA9PT0gdW5kZWZpbmVkICYmICFwYXJzZWQucGF0aCkge1xuICAgICAgcGFyc2VkLnJlZmVyZW5jZSA9ICdzYW1lLWRvY3VtZW50J1xuICAgIH0gZWxzZSBpZiAocGFyc2VkLnNjaGVtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBwYXJzZWQucmVmZXJlbmNlID0gJ3JlbGF0aXZlJ1xuICAgIH0gZWxzZSBpZiAocGFyc2VkLmZyYWdtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHBhcnNlZC5yZWZlcmVuY2UgPSAnYWJzb2x1dGUnXG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnNlZC5yZWZlcmVuY2UgPSAndXJpJ1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGZvciByZWZlcmVuY2UgZXJyb3JzXG4gICAgaWYgKG9wdGlvbnMucmVmZXJlbmNlICYmIG9wdGlvbnMucmVmZXJlbmNlICE9PSAnc3VmZml4JyAmJiBvcHRpb25zLnJlZmVyZW5jZSAhPT0gcGFyc2VkLnJlZmVyZW5jZSkge1xuICAgICAgcGFyc2VkLmVycm9yID0gcGFyc2VkLmVycm9yIHx8ICdVUkkgaXMgbm90IGEgJyArIG9wdGlvbnMucmVmZXJlbmNlICsgJyByZWZlcmVuY2UuJ1xuICAgIH1cblxuICAgIC8vIGZpbmQgc2NoZW1lIGhhbmRsZXJcbiAgICBjb25zdCBzY2hlbWVIYW5kbGVyID0gZ2V0U2NoZW1lSGFuZGxlcihvcHRpb25zLnNjaGVtZSB8fCBwYXJzZWQuc2NoZW1lKVxuXG4gICAgLy8gY2hlY2sgaWYgc2NoZW1lIGNhbid0IGhhbmRsZSBJUklzXG4gICAgaWYgKCFvcHRpb25zLnVuaWNvZGVTdXBwb3J0ICYmICghc2NoZW1lSGFuZGxlciB8fCAhc2NoZW1lSGFuZGxlci51bmljb2RlU3VwcG9ydCkpIHtcbiAgICAgIC8vIGlmIGhvc3QgY29tcG9uZW50IGlzIGEgZG9tYWluIG5hbWVcbiAgICAgIGlmIChwYXJzZWQuaG9zdCAmJiAob3B0aW9ucy5kb21haW5Ib3N0IHx8IChzY2hlbWVIYW5kbGVyICYmIHNjaGVtZUhhbmRsZXIuZG9tYWluSG9zdCkpICYmIGlzSVAgPT09IGZhbHNlICYmIG5vblNpbXBsZURvbWFpbihwYXJzZWQuaG9zdCkpIHtcbiAgICAgICAgLy8gY29udmVydCBVbmljb2RlIElETiAtPiBBU0NJSSBJRE5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwYXJzZWQuaG9zdCA9IFVSTC5kb21haW5Ub0FTQ0lJKHBhcnNlZC5ob3N0LnRvTG93ZXJDYXNlKCkpXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBwYXJzZWQuZXJyb3IgPSBwYXJzZWQuZXJyb3IgfHwgXCJIb3N0J3MgZG9tYWluIG5hbWUgY2FuIG5vdCBiZSBjb252ZXJ0ZWQgdG8gQVNDSUk6IFwiICsgZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBjb252ZXJ0IElSSSAtPiBVUklcbiAgICB9XG5cbiAgICBpZiAoIXNjaGVtZUhhbmRsZXIgfHwgKHNjaGVtZUhhbmRsZXIgJiYgIXNjaGVtZUhhbmRsZXIuc2tpcE5vcm1hbGl6ZSkpIHtcbiAgICAgIGlmICh1cmkuaW5kZXhPZignJScpICE9PSAtMSkge1xuICAgICAgICBpZiAocGFyc2VkLnNjaGVtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcGFyc2VkLnNjaGVtZSA9IHVuZXNjYXBlKHBhcnNlZC5zY2hlbWUpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnNlZC5ob3N0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwYXJzZWQuaG9zdCA9IHVuZXNjYXBlKHBhcnNlZC5ob3N0KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocGFyc2VkLnBhdGgpIHtcbiAgICAgICAgcGFyc2VkLnBhdGggPSBlc2NhcGUodW5lc2NhcGUocGFyc2VkLnBhdGgpKVxuICAgICAgfVxuICAgICAgaWYgKHBhcnNlZC5mcmFnbWVudCkge1xuICAgICAgICBwYXJzZWQuZnJhZ21lbnQgPSBlbmNvZGVVUkkoZGVjb2RlVVJJQ29tcG9uZW50KHBhcnNlZC5mcmFnbWVudCkpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcGVyZm9ybSBzY2hlbWUgc3BlY2lmaWMgcGFyc2luZ1xuICAgIGlmIChzY2hlbWVIYW5kbGVyICYmIHNjaGVtZUhhbmRsZXIucGFyc2UpIHtcbiAgICAgIHNjaGVtZUhhbmRsZXIucGFyc2UocGFyc2VkLCBvcHRpb25zKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwYXJzZWQuZXJyb3IgPSBwYXJzZWQuZXJyb3IgfHwgJ1VSSSBjYW4gbm90IGJlIHBhcnNlZC4nXG4gIH1cbiAgcmV0dXJuIHBhcnNlZFxufVxuXG5jb25zdCBmYXN0VXJpID0ge1xuICBTQ0hFTUVTLFxuICBub3JtYWxpemUsXG4gIHJlc29sdmUsXG4gIHJlc29sdmVDb21wb25lbnQsXG4gIGVxdWFsLFxuICBzZXJpYWxpemUsXG4gIHBhcnNlXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmFzdFVyaVxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGZhc3RVcmlcbm1vZHVsZS5leHBvcnRzLmZhc3RVcmkgPSBmYXN0VXJpXG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHVyaSA9IHJlcXVpcmUoXCJmYXN0LXVyaVwiKTtcbnVyaS5jb2RlID0gJ3JlcXVpcmUoXCJhanYvZGlzdC9ydW50aW1lL3VyaVwiKS5kZWZhdWx0JztcbmV4cG9ydHMuZGVmYXVsdCA9IHVyaTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVyaS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29kZUdlbiA9IGV4cG9ydHMuTmFtZSA9IGV4cG9ydHMubmlsID0gZXhwb3J0cy5zdHJpbmdpZnkgPSBleHBvcnRzLnN0ciA9IGV4cG9ydHMuXyA9IGV4cG9ydHMuS2V5d29yZEN4dCA9IHZvaWQgMDtcbnZhciB2YWxpZGF0ZV8xID0gcmVxdWlyZShcIi4vY29tcGlsZS92YWxpZGF0ZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIktleXdvcmRDeHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbGlkYXRlXzEuS2V5d29yZEN4dDsgfSB9KTtcbnZhciBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi9jb21waWxlL2NvZGVnZW5cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuXzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0clwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLnN0cjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0cmluZ2lmeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLnN0cmluZ2lmeTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm5pbFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLm5pbDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5hbWVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVnZW5fMS5OYW1lOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29kZUdlblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLkNvZGVHZW47IH0gfSk7XG5jb25zdCB2YWxpZGF0aW9uX2Vycm9yXzEgPSByZXF1aXJlKFwiLi9ydW50aW1lL3ZhbGlkYXRpb25fZXJyb3JcIik7XG5jb25zdCByZWZfZXJyb3JfMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvcmVmX2Vycm9yXCIpO1xuY29uc3QgcnVsZXNfMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvcnVsZXNcIik7XG5jb25zdCBjb21waWxlXzEgPSByZXF1aXJlKFwiLi9jb21waWxlXCIpO1xuY29uc3QgY29kZWdlbl8yID0gcmVxdWlyZShcIi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgcmVzb2x2ZV8xID0gcmVxdWlyZShcIi4vY29tcGlsZS9yZXNvbHZlXCIpO1xuY29uc3QgZGF0YVR5cGVfMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvdmFsaWRhdGUvZGF0YVR5cGVcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCAkZGF0YVJlZlNjaGVtYSA9IHJlcXVpcmUoXCIuL3JlZnMvZGF0YS5qc29uXCIpO1xuY29uc3QgdXJpXzEgPSByZXF1aXJlKFwiLi9ydW50aW1lL3VyaVwiKTtcbmNvbnN0IGRlZmF1bHRSZWdFeHAgPSAoc3RyLCBmbGFncykgPT4gbmV3IFJlZ0V4cChzdHIsIGZsYWdzKTtcbmRlZmF1bHRSZWdFeHAuY29kZSA9IFwibmV3IFJlZ0V4cFwiO1xuY29uc3QgTUVUQV9JR05PUkVfT1BUSU9OUyA9IFtcInJlbW92ZUFkZGl0aW9uYWxcIiwgXCJ1c2VEZWZhdWx0c1wiLCBcImNvZXJjZVR5cGVzXCJdO1xuY29uc3QgRVhUX1NDT1BFX05BTUVTID0gbmV3IFNldChbXG4gICAgXCJ2YWxpZGF0ZVwiLFxuICAgIFwic2VyaWFsaXplXCIsXG4gICAgXCJwYXJzZVwiLFxuICAgIFwid3JhcHBlclwiLFxuICAgIFwicm9vdFwiLFxuICAgIFwic2NoZW1hXCIsXG4gICAgXCJrZXl3b3JkXCIsXG4gICAgXCJwYXR0ZXJuXCIsXG4gICAgXCJmb3JtYXRzXCIsXG4gICAgXCJ2YWxpZGF0ZSRkYXRhXCIsXG4gICAgXCJmdW5jXCIsXG4gICAgXCJvYmpcIixcbiAgICBcIkVycm9yXCIsXG5dKTtcbmNvbnN0IHJlbW92ZWRPcHRpb25zID0ge1xuICAgIGVycm9yRGF0YVBhdGg6IFwiXCIsXG4gICAgZm9ybWF0OiBcImB2YWxpZGF0ZUZvcm1hdHM6IGZhbHNlYCBjYW4gYmUgdXNlZCBpbnN0ZWFkLlwiLFxuICAgIG51bGxhYmxlOiAnXCJudWxsYWJsZVwiIGtleXdvcmQgaXMgc3VwcG9ydGVkIGJ5IGRlZmF1bHQuJyxcbiAgICBqc29uUG9pbnRlcnM6IFwiRGVwcmVjYXRlZCBqc1Byb3BlcnR5U3ludGF4IGNhbiBiZSB1c2VkIGluc3RlYWQuXCIsXG4gICAgZXh0ZW5kUmVmczogXCJEZXByZWNhdGVkIGlnbm9yZUtleXdvcmRzV2l0aFJlZiBjYW4gYmUgdXNlZCBpbnN0ZWFkLlwiLFxuICAgIG1pc3NpbmdSZWZzOiBcIlBhc3MgZW1wdHkgc2NoZW1hIHdpdGggJGlkIHRoYXQgc2hvdWxkIGJlIGlnbm9yZWQgdG8gYWp2LmFkZFNjaGVtYS5cIixcbiAgICBwcm9jZXNzQ29kZTogXCJVc2Ugb3B0aW9uIGBjb2RlOiB7cHJvY2VzczogKGNvZGUsIHNjaGVtYUVudjogb2JqZWN0KSA9PiBzdHJpbmd9YFwiLFxuICAgIHNvdXJjZUNvZGU6IFwiVXNlIG9wdGlvbiBgY29kZToge3NvdXJjZTogdHJ1ZX1gXCIsXG4gICAgc3RyaWN0RGVmYXVsdHM6IFwiSXQgaXMgZGVmYXVsdCBub3csIHNlZSBvcHRpb24gYHN0cmljdGAuXCIsXG4gICAgc3RyaWN0S2V5d29yZHM6IFwiSXQgaXMgZGVmYXVsdCBub3csIHNlZSBvcHRpb24gYHN0cmljdGAuXCIsXG4gICAgdW5pcXVlSXRlbXM6ICdcInVuaXF1ZUl0ZW1zXCIga2V5d29yZCBpcyBhbHdheXMgdmFsaWRhdGVkLicsXG4gICAgdW5rbm93bkZvcm1hdHM6IFwiRGlzYWJsZSBzdHJpY3QgbW9kZSBvciBwYXNzIGB0cnVlYCB0byBgYWp2LmFkZEZvcm1hdGAgKG9yIGBmb3JtYXRzYCBvcHRpb24pLlwiLFxuICAgIGNhY2hlOiBcIk1hcCBpcyB1c2VkIGFzIGNhY2hlLCBzY2hlbWEgb2JqZWN0IGFzIGtleS5cIixcbiAgICBzZXJpYWxpemU6IFwiTWFwIGlzIHVzZWQgYXMgY2FjaGUsIHNjaGVtYSBvYmplY3QgYXMga2V5LlwiLFxuICAgIGFqdkVycm9yczogXCJJdCBpcyBkZWZhdWx0IG5vdy5cIixcbn07XG5jb25zdCBkZXByZWNhdGVkT3B0aW9ucyA9IHtcbiAgICBpZ25vcmVLZXl3b3Jkc1dpdGhSZWY6IFwiXCIsXG4gICAganNQcm9wZXJ0eVN5bnRheDogXCJcIixcbiAgICB1bmljb2RlOiAnXCJtaW5MZW5ndGhcIi9cIm1heExlbmd0aFwiIGFjY291bnQgZm9yIHVuaWNvZGUgY2hhcmFjdGVycyBieSBkZWZhdWx0LicsXG59O1xuY29uc3QgTUFYX0VYUFJFU1NJT04gPSAyMDA7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZnVuY3Rpb24gcmVxdWlyZWRPcHRpb25zKG8pIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaiwgX2ssIF9sLCBfbSwgX28sIF9wLCBfcSwgX3IsIF9zLCBfdCwgX3UsIF92LCBfdywgX3gsIF95LCBfeiwgXzA7XG4gICAgY29uc3QgcyA9IG8uc3RyaWN0O1xuICAgIGNvbnN0IF9vcHR6ID0gKF9hID0gby5jb2RlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3B0aW1pemU7XG4gICAgY29uc3Qgb3B0aW1pemUgPSBfb3B0eiA9PT0gdHJ1ZSB8fCBfb3B0eiA9PT0gdW5kZWZpbmVkID8gMSA6IF9vcHR6IHx8IDA7XG4gICAgY29uc3QgcmVnRXhwID0gKF9jID0gKF9iID0gby5jb2RlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucmVnRXhwKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBkZWZhdWx0UmVnRXhwO1xuICAgIGNvbnN0IHVyaVJlc29sdmVyID0gKF9kID0gby51cmlSZXNvbHZlcikgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogdXJpXzEuZGVmYXVsdDtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdHJpY3RTY2hlbWE6IChfZiA9IChfZSA9IG8uc3RyaWN0U2NoZW1hKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiBzKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiB0cnVlLFxuICAgICAgICBzdHJpY3ROdW1iZXJzOiAoX2ggPSAoX2cgPSBvLnN0cmljdE51bWJlcnMpICE9PSBudWxsICYmIF9nICE9PSB2b2lkIDAgPyBfZyA6IHMpICE9PSBudWxsICYmIF9oICE9PSB2b2lkIDAgPyBfaCA6IHRydWUsXG4gICAgICAgIHN0cmljdFR5cGVzOiAoX2sgPSAoX2ogPSBvLnN0cmljdFR5cGVzKSAhPT0gbnVsbCAmJiBfaiAhPT0gdm9pZCAwID8gX2ogOiBzKSAhPT0gbnVsbCAmJiBfayAhPT0gdm9pZCAwID8gX2sgOiBcImxvZ1wiLFxuICAgICAgICBzdHJpY3RUdXBsZXM6IChfbSA9IChfbCA9IG8uc3RyaWN0VHVwbGVzKSAhPT0gbnVsbCAmJiBfbCAhPT0gdm9pZCAwID8gX2wgOiBzKSAhPT0gbnVsbCAmJiBfbSAhPT0gdm9pZCAwID8gX20gOiBcImxvZ1wiLFxuICAgICAgICBzdHJpY3RSZXF1aXJlZDogKF9wID0gKF9vID0gby5zdHJpY3RSZXF1aXJlZCkgIT09IG51bGwgJiYgX28gIT09IHZvaWQgMCA/IF9vIDogcykgIT09IG51bGwgJiYgX3AgIT09IHZvaWQgMCA/IF9wIDogZmFsc2UsXG4gICAgICAgIGNvZGU6IG8uY29kZSA/IHsgLi4uby5jb2RlLCBvcHRpbWl6ZSwgcmVnRXhwIH0gOiB7IG9wdGltaXplLCByZWdFeHAgfSxcbiAgICAgICAgbG9vcFJlcXVpcmVkOiAoX3EgPSBvLmxvb3BSZXF1aXJlZCkgIT09IG51bGwgJiYgX3EgIT09IHZvaWQgMCA/IF9xIDogTUFYX0VYUFJFU1NJT04sXG4gICAgICAgIGxvb3BFbnVtOiAoX3IgPSBvLmxvb3BFbnVtKSAhPT0gbnVsbCAmJiBfciAhPT0gdm9pZCAwID8gX3IgOiBNQVhfRVhQUkVTU0lPTixcbiAgICAgICAgbWV0YTogKF9zID0gby5tZXRhKSAhPT0gbnVsbCAmJiBfcyAhPT0gdm9pZCAwID8gX3MgOiB0cnVlLFxuICAgICAgICBtZXNzYWdlczogKF90ID0gby5tZXNzYWdlcykgIT09IG51bGwgJiYgX3QgIT09IHZvaWQgMCA/IF90IDogdHJ1ZSxcbiAgICAgICAgaW5saW5lUmVmczogKF91ID0gby5pbmxpbmVSZWZzKSAhPT0gbnVsbCAmJiBfdSAhPT0gdm9pZCAwID8gX3UgOiB0cnVlLFxuICAgICAgICBzY2hlbWFJZDogKF92ID0gby5zY2hlbWFJZCkgIT09IG51bGwgJiYgX3YgIT09IHZvaWQgMCA/IF92IDogXCIkaWRcIixcbiAgICAgICAgYWRkVXNlZFNjaGVtYTogKF93ID0gby5hZGRVc2VkU2NoZW1hKSAhPT0gbnVsbCAmJiBfdyAhPT0gdm9pZCAwID8gX3cgOiB0cnVlLFxuICAgICAgICB2YWxpZGF0ZVNjaGVtYTogKF94ID0gby52YWxpZGF0ZVNjaGVtYSkgIT09IG51bGwgJiYgX3ggIT09IHZvaWQgMCA/IF94IDogdHJ1ZSxcbiAgICAgICAgdmFsaWRhdGVGb3JtYXRzOiAoX3kgPSBvLnZhbGlkYXRlRm9ybWF0cykgIT09IG51bGwgJiYgX3kgIT09IHZvaWQgMCA/IF95IDogdHJ1ZSxcbiAgICAgICAgdW5pY29kZVJlZ0V4cDogKF96ID0gby51bmljb2RlUmVnRXhwKSAhPT0gbnVsbCAmJiBfeiAhPT0gdm9pZCAwID8gX3ogOiB0cnVlLFxuICAgICAgICBpbnQzMnJhbmdlOiAoXzAgPSBvLmludDMycmFuZ2UpICE9PSBudWxsICYmIF8wICE9PSB2b2lkIDAgPyBfMCA6IHRydWUsXG4gICAgICAgIHVyaVJlc29sdmVyOiB1cmlSZXNvbHZlcixcbiAgICB9O1xufVxuY2xhc3MgQWp2IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICAgICAgdGhpcy5zY2hlbWFzID0ge307XG4gICAgICAgIHRoaXMucmVmcyA9IHt9O1xuICAgICAgICB0aGlzLmZvcm1hdHMgPSB7fTtcbiAgICAgICAgdGhpcy5fY29tcGlsYXRpb25zID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLl9sb2FkaW5nID0ge307XG4gICAgICAgIHRoaXMuX2NhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICBvcHRzID0gdGhpcy5vcHRzID0geyAuLi5vcHRzLCAuLi5yZXF1aXJlZE9wdGlvbnMob3B0cykgfTtcbiAgICAgICAgY29uc3QgeyBlczUsIGxpbmVzIH0gPSB0aGlzLm9wdHMuY29kZTtcbiAgICAgICAgdGhpcy5zY29wZSA9IG5ldyBjb2RlZ2VuXzIuVmFsdWVTY29wZSh7IHNjb3BlOiB7fSwgcHJlZml4ZXM6IEVYVF9TQ09QRV9OQU1FUywgZXM1LCBsaW5lcyB9KTtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBnZXRMb2dnZXIob3B0cy5sb2dnZXIpO1xuICAgICAgICBjb25zdCBmb3JtYXRPcHQgPSBvcHRzLnZhbGlkYXRlRm9ybWF0cztcbiAgICAgICAgb3B0cy52YWxpZGF0ZUZvcm1hdHMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5SVUxFUyA9ICgwLCBydWxlc18xLmdldFJ1bGVzKSgpO1xuICAgICAgICBjaGVja09wdGlvbnMuY2FsbCh0aGlzLCByZW1vdmVkT3B0aW9ucywgb3B0cywgXCJOT1QgU1VQUE9SVEVEXCIpO1xuICAgICAgICBjaGVja09wdGlvbnMuY2FsbCh0aGlzLCBkZXByZWNhdGVkT3B0aW9ucywgb3B0cywgXCJERVBSRUNBVEVEXCIsIFwid2FyblwiKTtcbiAgICAgICAgdGhpcy5fbWV0YU9wdHMgPSBnZXRNZXRhU2NoZW1hT3B0aW9ucy5jYWxsKHRoaXMpO1xuICAgICAgICBpZiAob3B0cy5mb3JtYXRzKVxuICAgICAgICAgICAgYWRkSW5pdGlhbEZvcm1hdHMuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5fYWRkVm9jYWJ1bGFyaWVzKCk7XG4gICAgICAgIHRoaXMuX2FkZERlZmF1bHRNZXRhU2NoZW1hKCk7XG4gICAgICAgIGlmIChvcHRzLmtleXdvcmRzKVxuICAgICAgICAgICAgYWRkSW5pdGlhbEtleXdvcmRzLmNhbGwodGhpcywgb3B0cy5rZXl3b3Jkcyk7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0cy5tZXRhID09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICB0aGlzLmFkZE1ldGFTY2hlbWEob3B0cy5tZXRhKTtcbiAgICAgICAgYWRkSW5pdGlhbFNjaGVtYXMuY2FsbCh0aGlzKTtcbiAgICAgICAgb3B0cy52YWxpZGF0ZUZvcm1hdHMgPSBmb3JtYXRPcHQ7XG4gICAgfVxuICAgIF9hZGRWb2NhYnVsYXJpZXMoKSB7XG4gICAgICAgIHRoaXMuYWRkS2V5d29yZChcIiRhc3luY1wiKTtcbiAgICB9XG4gICAgX2FkZERlZmF1bHRNZXRhU2NoZW1hKCkge1xuICAgICAgICBjb25zdCB7ICRkYXRhLCBtZXRhLCBzY2hlbWFJZCB9ID0gdGhpcy5vcHRzO1xuICAgICAgICBsZXQgX2RhdGFSZWZTY2hlbWEgPSAkZGF0YVJlZlNjaGVtYTtcbiAgICAgICAgaWYgKHNjaGVtYUlkID09PSBcImlkXCIpIHtcbiAgICAgICAgICAgIF9kYXRhUmVmU2NoZW1hID0geyAuLi4kZGF0YVJlZlNjaGVtYSB9O1xuICAgICAgICAgICAgX2RhdGFSZWZTY2hlbWEuaWQgPSBfZGF0YVJlZlNjaGVtYS4kaWQ7XG4gICAgICAgICAgICBkZWxldGUgX2RhdGFSZWZTY2hlbWEuJGlkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhICYmICRkYXRhKVxuICAgICAgICAgICAgdGhpcy5hZGRNZXRhU2NoZW1hKF9kYXRhUmVmU2NoZW1hLCBfZGF0YVJlZlNjaGVtYVtzY2hlbWFJZF0sIGZhbHNlKTtcbiAgICB9XG4gICAgZGVmYXVsdE1ldGEoKSB7XG4gICAgICAgIGNvbnN0IHsgbWV0YSwgc2NoZW1hSWQgfSA9IHRoaXMub3B0cztcbiAgICAgICAgcmV0dXJuICh0aGlzLm9wdHMuZGVmYXVsdE1ldGEgPSB0eXBlb2YgbWV0YSA9PSBcIm9iamVjdFwiID8gbWV0YVtzY2hlbWFJZF0gfHwgbWV0YSA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIHZhbGlkYXRlKHNjaGVtYUtleVJlZiwgLy8ga2V5LCByZWYgb3Igc2NoZW1hIG9iamVjdFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVkdW5kYW50LXR5cGUtY29uc3RpdHVlbnRzXG4gICAgZGF0YSAvLyB0byBiZSB2YWxpZGF0ZWRcbiAgICApIHtcbiAgICAgICAgbGV0IHY7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hS2V5UmVmID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHYgPSB0aGlzLmdldFNjaGVtYShzY2hlbWFLZXlSZWYpO1xuICAgICAgICAgICAgaWYgKCF2KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbm8gc2NoZW1hIHdpdGgga2V5IG9yIHJlZiBcIiR7c2NoZW1hS2V5UmVmfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2ID0gdGhpcy5jb21waWxlKHNjaGVtYUtleVJlZik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsaWQgPSB2KGRhdGEpO1xuICAgICAgICBpZiAoIShcIiRhc3luY1wiIGluIHYpKVxuICAgICAgICAgICAgdGhpcy5lcnJvcnMgPSB2LmVycm9ycztcbiAgICAgICAgcmV0dXJuIHZhbGlkO1xuICAgIH1cbiAgICBjb21waWxlKHNjaGVtYSwgX21ldGEpIHtcbiAgICAgICAgY29uc3Qgc2NoID0gdGhpcy5fYWRkU2NoZW1hKHNjaGVtYSwgX21ldGEpO1xuICAgICAgICByZXR1cm4gKHNjaC52YWxpZGF0ZSB8fCB0aGlzLl9jb21waWxlU2NoZW1hRW52KHNjaCkpO1xuICAgIH1cbiAgICBjb21waWxlQXN5bmMoc2NoZW1hLCBtZXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRzLmxvYWRTY2hlbWEgIT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvcHRpb25zLmxvYWRTY2hlbWEgc2hvdWxkIGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBsb2FkU2NoZW1hIH0gPSB0aGlzLm9wdHM7XG4gICAgICAgIHJldHVybiBydW5Db21waWxlQXN5bmMuY2FsbCh0aGlzLCBzY2hlbWEsIG1ldGEpO1xuICAgICAgICBhc3luYyBmdW5jdGlvbiBydW5Db21waWxlQXN5bmMoX3NjaGVtYSwgX21ldGEpIHtcbiAgICAgICAgICAgIGF3YWl0IGxvYWRNZXRhU2NoZW1hLmNhbGwodGhpcywgX3NjaGVtYS4kc2NoZW1hKTtcbiAgICAgICAgICAgIGNvbnN0IHNjaCA9IHRoaXMuX2FkZFNjaGVtYShfc2NoZW1hLCBfbWV0YSk7XG4gICAgICAgICAgICByZXR1cm4gc2NoLnZhbGlkYXRlIHx8IF9jb21waWxlQXN5bmMuY2FsbCh0aGlzLCBzY2gpO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGxvYWRNZXRhU2NoZW1hKCRyZWYpIHtcbiAgICAgICAgICAgIGlmICgkcmVmICYmICF0aGlzLmdldFNjaGVtYSgkcmVmKSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHJ1bkNvbXBpbGVBc3luYy5jYWxsKHRoaXMsIHsgJHJlZiB9LCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhc3luYyBmdW5jdGlvbiBfY29tcGlsZUFzeW5jKHNjaCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY29tcGlsZVNjaGVtYUVudihzY2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShlIGluc3RhbmNlb2YgcmVmX2Vycm9yXzEuZGVmYXVsdCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgY2hlY2tMb2FkZWQuY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBsb2FkTWlzc2luZ1NjaGVtYS5jYWxsKHRoaXMsIGUubWlzc2luZ1NjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb21waWxlQXN5bmMuY2FsbCh0aGlzLCBzY2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrTG9hZGVkKHsgbWlzc2luZ1NjaGVtYTogcmVmLCBtaXNzaW5nUmVmIH0pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlZnNbcmVmXSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQW55U2NoZW1hICR7cmVmfSBpcyBsb2FkZWQgYnV0ICR7bWlzc2luZ1JlZn0gY2Fubm90IGJlIHJlc29sdmVkYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gbG9hZE1pc3NpbmdTY2hlbWEocmVmKSB7XG4gICAgICAgICAgICBjb25zdCBfc2NoZW1hID0gYXdhaXQgX2xvYWRTY2hlbWEuY2FsbCh0aGlzLCByZWYpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJlZnNbcmVmXSlcbiAgICAgICAgICAgICAgICBhd2FpdCBsb2FkTWV0YVNjaGVtYS5jYWxsKHRoaXMsIF9zY2hlbWEuJHNjaGVtYSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMucmVmc1tyZWZdKVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkU2NoZW1hKF9zY2hlbWEsIHJlZiwgbWV0YSk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gX2xvYWRTY2hlbWEocmVmKSB7XG4gICAgICAgICAgICBjb25zdCBwID0gdGhpcy5fbG9hZGluZ1tyZWZdO1xuICAgICAgICAgICAgaWYgKHApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCAodGhpcy5fbG9hZGluZ1tyZWZdID0gbG9hZFNjaGVtYShyZWYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9sb2FkaW5nW3JlZl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQWRkcyBzY2hlbWEgdG8gdGhlIGluc3RhbmNlXG4gICAgYWRkU2NoZW1hKHNjaGVtYSwgLy8gSWYgYXJyYXkgaXMgcGFzc2VkLCBga2V5YCB3aWxsIGJlIGlnbm9yZWRcbiAgICBrZXksIC8vIE9wdGlvbmFsIHNjaGVtYSBrZXkuIENhbiBiZSBwYXNzZWQgdG8gYHZhbGlkYXRlYCBtZXRob2QgaW5zdGVhZCBvZiBzY2hlbWEgb2JqZWN0IG9yIGlkL3JlZi4gT25lIHNjaGVtYSBwZXIgaW5zdGFuY2UgY2FuIGhhdmUgZW1wdHkgYGlkYCBhbmQgYGtleWAuXG4gICAgX21ldGEsIC8vIHRydWUgaWYgc2NoZW1hIGlzIGEgbWV0YS1zY2hlbWEuIFVzZWQgaW50ZXJuYWxseSwgYWRkTWV0YVNjaGVtYSBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxuICAgIF92YWxpZGF0ZVNjaGVtYSA9IHRoaXMub3B0cy52YWxpZGF0ZVNjaGVtYSAvLyBmYWxzZSB0byBza2lwIHNjaGVtYSB2YWxpZGF0aW9uLiBVc2VkIGludGVybmFsbHksIG9wdGlvbiB2YWxpZGF0ZVNjaGVtYSBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxuICAgICkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNjaCBvZiBzY2hlbWEpXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRTY2hlbWEoc2NoLCB1bmRlZmluZWQsIF9tZXRhLCBfdmFsaWRhdGVTY2hlbWEpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGlkO1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgY29uc3QgeyBzY2hlbWFJZCB9ID0gdGhpcy5vcHRzO1xuICAgICAgICAgICAgaWQgPSBzY2hlbWFbc2NoZW1hSWRdO1xuICAgICAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGlkICE9IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHNjaGVtYSAke3NjaGVtYUlkfSBtdXN0IGJlIHN0cmluZ2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGtleSA9ICgwLCByZXNvbHZlXzEubm9ybWFsaXplSWQpKGtleSB8fCBpZCk7XG4gICAgICAgIHRoaXMuX2NoZWNrVW5pcXVlKGtleSk7XG4gICAgICAgIHRoaXMuc2NoZW1hc1trZXldID0gdGhpcy5fYWRkU2NoZW1hKHNjaGVtYSwgX21ldGEsIGtleSwgX3ZhbGlkYXRlU2NoZW1hLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIEFkZCBzY2hlbWEgdGhhdCB3aWxsIGJlIHVzZWQgdG8gdmFsaWRhdGUgb3RoZXIgc2NoZW1hc1xuICAgIC8vIG9wdGlvbnMgaW4gTUVUQV9JR05PUkVfT1BUSU9OUyBhcmUgYWx3YXkgc2V0IHRvIGZhbHNlXG4gICAgYWRkTWV0YVNjaGVtYShzY2hlbWEsIGtleSwgLy8gc2NoZW1hIGtleVxuICAgIF92YWxpZGF0ZVNjaGVtYSA9IHRoaXMub3B0cy52YWxpZGF0ZVNjaGVtYSAvLyBmYWxzZSB0byBza2lwIHNjaGVtYSB2YWxpZGF0aW9uLCBjYW4gYmUgdXNlZCB0byBvdmVycmlkZSB2YWxpZGF0ZVNjaGVtYSBvcHRpb24gZm9yIG1ldGEtc2NoZW1hXG4gICAgKSB7XG4gICAgICAgIHRoaXMuYWRkU2NoZW1hKHNjaGVtYSwga2V5LCB0cnVlLCBfdmFsaWRhdGVTY2hlbWEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gIFZhbGlkYXRlIHNjaGVtYSBhZ2FpbnN0IGl0cyBtZXRhLXNjaGVtYVxuICAgIHZhbGlkYXRlU2NoZW1hKHNjaGVtYSwgdGhyb3dPckxvZ0Vycm9yKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGxldCAkc2NoZW1hO1xuICAgICAgICAkc2NoZW1hID0gc2NoZW1hLiRzY2hlbWE7XG4gICAgICAgIGlmICgkc2NoZW1hICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mICRzY2hlbWEgIT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJHNjaGVtYSBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuICAgICAgICB9XG4gICAgICAgICRzY2hlbWEgPSAkc2NoZW1hIHx8IHRoaXMub3B0cy5kZWZhdWx0TWV0YSB8fCB0aGlzLmRlZmF1bHRNZXRhKCk7XG4gICAgICAgIGlmICghJHNjaGVtYSkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIm1ldGEtc2NoZW1hIG5vdCBhdmFpbGFibGVcIik7XG4gICAgICAgICAgICB0aGlzLmVycm9ycyA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWxpZCA9IHRoaXMudmFsaWRhdGUoJHNjaGVtYSwgc2NoZW1hKTtcbiAgICAgICAgaWYgKCF2YWxpZCAmJiB0aHJvd09yTG9nRXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBcInNjaGVtYSBpcyBpbnZhbGlkOiBcIiArIHRoaXMuZXJyb3JzVGV4dCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0cy52YWxpZGF0ZVNjaGVtYSA9PT0gXCJsb2dcIilcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbGlkO1xuICAgIH1cbiAgICAvLyBHZXQgY29tcGlsZWQgc2NoZW1hIGJ5IGBrZXlgIG9yIGByZWZgLlxuICAgIC8vIChga2V5YCB0aGF0IHdhcyBwYXNzZWQgdG8gYGFkZFNjaGVtYWAgb3IgZnVsbCBzY2hlbWEgcmVmZXJlbmNlIC0gYHNjaGVtYS4kaWRgIG9yIHJlc29sdmVkIGlkKVxuICAgIGdldFNjaGVtYShrZXlSZWYpIHtcbiAgICAgICAgbGV0IHNjaDtcbiAgICAgICAgd2hpbGUgKHR5cGVvZiAoc2NoID0gZ2V0U2NoRW52LmNhbGwodGhpcywga2V5UmVmKSkgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIGtleVJlZiA9IHNjaDtcbiAgICAgICAgaWYgKHNjaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCB7IHNjaGVtYUlkIH0gPSB0aGlzLm9wdHM7XG4gICAgICAgICAgICBjb25zdCByb290ID0gbmV3IGNvbXBpbGVfMS5TY2hlbWFFbnYoeyBzY2hlbWE6IHt9LCBzY2hlbWFJZCB9KTtcbiAgICAgICAgICAgIHNjaCA9IGNvbXBpbGVfMS5yZXNvbHZlU2NoZW1hLmNhbGwodGhpcywgcm9vdCwga2V5UmVmKTtcbiAgICAgICAgICAgIGlmICghc2NoKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMucmVmc1trZXlSZWZdID0gc2NoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoc2NoLnZhbGlkYXRlIHx8IHRoaXMuX2NvbXBpbGVTY2hlbWFFbnYoc2NoKSk7XG4gICAgfVxuICAgIC8vIFJlbW92ZSBjYWNoZWQgc2NoZW1hKHMpLlxuICAgIC8vIElmIG5vIHBhcmFtZXRlciBpcyBwYXNzZWQgYWxsIHNjaGVtYXMgYnV0IG1ldGEtc2NoZW1hcyBhcmUgcmVtb3ZlZC5cbiAgICAvLyBJZiBSZWdFeHAgaXMgcGFzc2VkIGFsbCBzY2hlbWFzIHdpdGgga2V5L2lkIG1hdGNoaW5nIHBhdHRlcm4gYnV0IG1ldGEtc2NoZW1hcyBhcmUgcmVtb3ZlZC5cbiAgICAvLyBFdmVuIGlmIHNjaGVtYSBpcyByZWZlcmVuY2VkIGJ5IG90aGVyIHNjaGVtYXMgaXQgc3RpbGwgY2FuIGJlIHJlbW92ZWQgYXMgb3RoZXIgc2NoZW1hcyBoYXZlIGxvY2FsIHJlZmVyZW5jZXMuXG4gICAgcmVtb3ZlU2NoZW1hKHNjaGVtYUtleVJlZikge1xuICAgICAgICBpZiAoc2NoZW1hS2V5UmVmIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVBbGxTY2hlbWFzKHRoaXMuc2NoZW1hcywgc2NoZW1hS2V5UmVmKTtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZUFsbFNjaGVtYXModGhpcy5yZWZzLCBzY2hlbWFLZXlSZWYpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0eXBlb2Ygc2NoZW1hS2V5UmVmKSB7XG4gICAgICAgICAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlQWxsU2NoZW1hcyh0aGlzLnNjaGVtYXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUFsbFNjaGVtYXModGhpcy5yZWZzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZS5jbGVhcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoID0gZ2V0U2NoRW52LmNhbGwodGhpcywgc2NoZW1hS2V5UmVmKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNjaCA9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZS5kZWxldGUoc2NoLnNjaGVtYSk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuc2NoZW1hc1tzY2hlbWFLZXlSZWZdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnJlZnNbc2NoZW1hS2V5UmVmXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJvYmplY3RcIjoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gc2NoZW1hS2V5UmVmO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlLmRlbGV0ZShjYWNoZUtleSk7XG4gICAgICAgICAgICAgICAgbGV0IGlkID0gc2NoZW1hS2V5UmVmW3RoaXMub3B0cy5zY2hlbWFJZF07XG4gICAgICAgICAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlkID0gKDAsIHJlc29sdmVfMS5ub3JtYWxpemVJZCkoaWQpO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5zY2hlbWFzW2lkXTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMucmVmc1tpZF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhanYucmVtb3ZlU2NoZW1hOiBpbnZhbGlkIHBhcmFtZXRlclwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBhZGQgXCJ2b2NhYnVsYXJ5XCIgLSBhIGNvbGxlY3Rpb24gb2Yga2V5d29yZHNcbiAgICBhZGRWb2NhYnVsYXJ5KGRlZmluaXRpb25zKSB7XG4gICAgICAgIGZvciAoY29uc3QgZGVmIG9mIGRlZmluaXRpb25zKVxuICAgICAgICAgICAgdGhpcy5hZGRLZXl3b3JkKGRlZik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhZGRLZXl3b3JkKGt3ZE9yRGVmLCBkZWYgLy8gZGVwcmVjYXRlZFxuICAgICkge1xuICAgICAgICBsZXQga2V5d29yZDtcbiAgICAgICAgaWYgKHR5cGVvZiBrd2RPckRlZiA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBrZXl3b3JkID0ga3dkT3JEZWY7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRlZiA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcInRoZXNlIHBhcmFtZXRlcnMgYXJlIGRlcHJlY2F0ZWQsIHNlZSBkb2NzIGZvciBhZGRLZXl3b3JkXCIpO1xuICAgICAgICAgICAgICAgIGRlZi5rZXl3b3JkID0ga2V5d29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Yga3dkT3JEZWYgPT0gXCJvYmplY3RcIiAmJiBkZWYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGVmID0ga3dkT3JEZWY7XG4gICAgICAgICAgICBrZXl3b3JkID0gZGVmLmtleXdvcmQ7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShrZXl3b3JkKSAmJiAha2V5d29yZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhZGRLZXl3b3Jkczoga2V5d29yZCBtdXN0IGJlIHN0cmluZyBvciBub24tZW1wdHkgYXJyYXlcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGFkZEtleXdvcmRzIHBhcmFtZXRlcnNcIik7XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tLZXl3b3JkLmNhbGwodGhpcywga2V5d29yZCwgZGVmKTtcbiAgICAgICAgaWYgKCFkZWYpIHtcbiAgICAgICAgICAgICgwLCB1dGlsXzEuZWFjaEl0ZW0pKGtleXdvcmQsIChrd2QpID0+IGFkZFJ1bGUuY2FsbCh0aGlzLCBrd2QpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGtleXdvcmRNZXRhc2NoZW1hLmNhbGwodGhpcywgZGVmKTtcbiAgICAgICAgY29uc3QgZGVmaW5pdGlvbiA9IHtcbiAgICAgICAgICAgIC4uLmRlZixcbiAgICAgICAgICAgIHR5cGU6ICgwLCBkYXRhVHlwZV8xLmdldEpTT05UeXBlcykoZGVmLnR5cGUpLFxuICAgICAgICAgICAgc2NoZW1hVHlwZTogKDAsIGRhdGFUeXBlXzEuZ2V0SlNPTlR5cGVzKShkZWYuc2NoZW1hVHlwZSksXG4gICAgICAgIH07XG4gICAgICAgICgwLCB1dGlsXzEuZWFjaEl0ZW0pKGtleXdvcmQsIGRlZmluaXRpb24udHlwZS5sZW5ndGggPT09IDBcbiAgICAgICAgICAgID8gKGspID0+IGFkZFJ1bGUuY2FsbCh0aGlzLCBrLCBkZWZpbml0aW9uKVxuICAgICAgICAgICAgOiAoaykgPT4gZGVmaW5pdGlvbi50eXBlLmZvckVhY2goKHQpID0+IGFkZFJ1bGUuY2FsbCh0aGlzLCBrLCBkZWZpbml0aW9uLCB0KSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0S2V5d29yZChrZXl3b3JkKSB7XG4gICAgICAgIGNvbnN0IHJ1bGUgPSB0aGlzLlJVTEVTLmFsbFtrZXl3b3JkXTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBydWxlID09IFwib2JqZWN0XCIgPyBydWxlLmRlZmluaXRpb24gOiAhIXJ1bGU7XG4gICAgfVxuICAgIC8vIFJlbW92ZSBrZXl3b3JkXG4gICAgcmVtb3ZlS2V5d29yZChrZXl3b3JkKSB7XG4gICAgICAgIC8vIFRPRE8gcmV0dXJuIHR5cGUgc2hvdWxkIGJlIEFqdlxuICAgICAgICBjb25zdCB7IFJVTEVTIH0gPSB0aGlzO1xuICAgICAgICBkZWxldGUgUlVMRVMua2V5d29yZHNba2V5d29yZF07XG4gICAgICAgIGRlbGV0ZSBSVUxFUy5hbGxba2V5d29yZF07XG4gICAgICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgUlVMRVMucnVsZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGkgPSBncm91cC5ydWxlcy5maW5kSW5kZXgoKHJ1bGUpID0+IHJ1bGUua2V5d29yZCA9PT0ga2V5d29yZCk7XG4gICAgICAgICAgICBpZiAoaSA+PSAwKVxuICAgICAgICAgICAgICAgIGdyb3VwLnJ1bGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gQWRkIGZvcm1hdFxuICAgIGFkZEZvcm1hdChuYW1lLCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXQgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIGZvcm1hdCA9IG5ldyBSZWdFeHAoZm9ybWF0KTtcbiAgICAgICAgdGhpcy5mb3JtYXRzW25hbWVdID0gZm9ybWF0O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZXJyb3JzVGV4dChlcnJvcnMgPSB0aGlzLmVycm9ycywgLy8gb3B0aW9uYWwgYXJyYXkgb2YgdmFsaWRhdGlvbiBlcnJvcnNcbiAgICB7IHNlcGFyYXRvciA9IFwiLCBcIiwgZGF0YVZhciA9IFwiZGF0YVwiIH0gPSB7fSAvLyBvcHRpb25hbCBvcHRpb25zIHdpdGggcHJvcGVydGllcyBgc2VwYXJhdG9yYCBhbmQgYGRhdGFWYXJgXG4gICAgKSB7XG4gICAgICAgIGlmICghZXJyb3JzIHx8IGVycm9ycy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gXCJObyBlcnJvcnNcIjtcbiAgICAgICAgcmV0dXJuIGVycm9yc1xuICAgICAgICAgICAgLm1hcCgoZSkgPT4gYCR7ZGF0YVZhcn0ke2UuaW5zdGFuY2VQYXRofSAke2UubWVzc2FnZX1gKVxuICAgICAgICAgICAgLnJlZHVjZSgodGV4dCwgbXNnKSA9PiB0ZXh0ICsgc2VwYXJhdG9yICsgbXNnKTtcbiAgICB9XG4gICAgJGRhdGFNZXRhU2NoZW1hKG1ldGFTY2hlbWEsIGtleXdvcmRzSnNvblBvaW50ZXJzKSB7XG4gICAgICAgIGNvbnN0IHJ1bGVzID0gdGhpcy5SVUxFUy5hbGw7XG4gICAgICAgIG1ldGFTY2hlbWEgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG1ldGFTY2hlbWEpKTtcbiAgICAgICAgZm9yIChjb25zdCBqc29uUG9pbnRlciBvZiBrZXl3b3Jkc0pzb25Qb2ludGVycykge1xuICAgICAgICAgICAgY29uc3Qgc2VnbWVudHMgPSBqc29uUG9pbnRlci5zcGxpdChcIi9cIikuc2xpY2UoMSk7IC8vIGZpcnN0IHNlZ21lbnQgaXMgYW4gZW1wdHkgc3RyaW5nXG4gICAgICAgICAgICBsZXQga2V5d29yZHMgPSBtZXRhU2NoZW1hO1xuICAgICAgICAgICAgZm9yIChjb25zdCBzZWcgb2Ygc2VnbWVudHMpXG4gICAgICAgICAgICAgICAga2V5d29yZHMgPSBrZXl3b3Jkc1tzZWddO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcnVsZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBydWxlID0gcnVsZXNba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJ1bGUgIT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY29uc3QgeyAkZGF0YSB9ID0gcnVsZS5kZWZpbml0aW9uO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjaGVtYSA9IGtleXdvcmRzW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKCRkYXRhICYmIHNjaGVtYSlcbiAgICAgICAgICAgICAgICAgICAga2V5d29yZHNba2V5XSA9IHNjaGVtYU9yRGF0YShzY2hlbWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXRhU2NoZW1hO1xuICAgIH1cbiAgICBfcmVtb3ZlQWxsU2NoZW1hcyhzY2hlbWFzLCByZWdleCkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleVJlZiBpbiBzY2hlbWFzKSB7XG4gICAgICAgICAgICBjb25zdCBzY2ggPSBzY2hlbWFzW2tleVJlZl07XG4gICAgICAgICAgICBpZiAoIXJlZ2V4IHx8IHJlZ2V4LnRlc3Qoa2V5UmVmKSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNjaGVtYXNba2V5UmVmXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2NoICYmICFzY2gubWV0YSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZS5kZWxldGUoc2NoLnNjaGVtYSk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzY2hlbWFzW2tleVJlZl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF9hZGRTY2hlbWEoc2NoZW1hLCBtZXRhLCBiYXNlSWQsIHZhbGlkYXRlU2NoZW1hID0gdGhpcy5vcHRzLnZhbGlkYXRlU2NoZW1hLCBhZGRTY2hlbWEgPSB0aGlzLm9wdHMuYWRkVXNlZFNjaGVtYSkge1xuICAgICAgICBsZXQgaWQ7XG4gICAgICAgIGNvbnN0IHsgc2NoZW1hSWQgfSA9IHRoaXMub3B0cztcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgaWQgPSBzY2hlbWFbc2NoZW1hSWRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5qdGQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2NoZW1hIG11c3QgYmUgb2JqZWN0XCIpO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHNjaGVtYSAhPSBcImJvb2xlYW5cIilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzY2hlbWEgbXVzdCBiZSBvYmplY3Qgb3IgYm9vbGVhblwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2NoID0gdGhpcy5fY2FjaGUuZ2V0KHNjaGVtYSk7XG4gICAgICAgIGlmIChzY2ggIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiBzY2g7XG4gICAgICAgIGJhc2VJZCA9ICgwLCByZXNvbHZlXzEubm9ybWFsaXplSWQpKGlkIHx8IGJhc2VJZCk7XG4gICAgICAgIGNvbnN0IGxvY2FsUmVmcyA9IHJlc29sdmVfMS5nZXRTY2hlbWFSZWZzLmNhbGwodGhpcywgc2NoZW1hLCBiYXNlSWQpO1xuICAgICAgICBzY2ggPSBuZXcgY29tcGlsZV8xLlNjaGVtYUVudih7IHNjaGVtYSwgc2NoZW1hSWQsIG1ldGEsIGJhc2VJZCwgbG9jYWxSZWZzIH0pO1xuICAgICAgICB0aGlzLl9jYWNoZS5zZXQoc2NoLnNjaGVtYSwgc2NoKTtcbiAgICAgICAgaWYgKGFkZFNjaGVtYSAmJiAhYmFzZUlkLnN0YXJ0c1dpdGgoXCIjXCIpKSB7XG4gICAgICAgICAgICAvLyBUT0RPIGF0bSBpdCBpcyBhbGxvd2VkIHRvIG92ZXJ3cml0ZSBzY2hlbWFzIHdpdGhvdXQgaWQgKGluc3RlYWQgb2Ygbm90IGFkZGluZyB0aGVtKVxuICAgICAgICAgICAgaWYgKGJhc2VJZClcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGVja1VuaXF1ZShiYXNlSWQpO1xuICAgICAgICAgICAgdGhpcy5yZWZzW2Jhc2VJZF0gPSBzY2g7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbGlkYXRlU2NoZW1hKVxuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZVNjaGVtYShzY2hlbWEsIHRydWUpO1xuICAgICAgICByZXR1cm4gc2NoO1xuICAgIH1cbiAgICBfY2hlY2tVbmlxdWUoaWQpIHtcbiAgICAgICAgaWYgKHRoaXMuc2NoZW1hc1tpZF0gfHwgdGhpcy5yZWZzW2lkXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzY2hlbWEgd2l0aCBrZXkgb3IgaWQgXCIke2lkfVwiIGFscmVhZHkgZXhpc3RzYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2NvbXBpbGVTY2hlbWFFbnYoc2NoKSB7XG4gICAgICAgIGlmIChzY2gubWV0YSlcbiAgICAgICAgICAgIHRoaXMuX2NvbXBpbGVNZXRhU2NoZW1hKHNjaCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNvbXBpbGVfMS5jb21waWxlU2NoZW1hLmNhbGwodGhpcywgc2NoKTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghc2NoLnZhbGlkYXRlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgICAgICByZXR1cm4gc2NoLnZhbGlkYXRlO1xuICAgIH1cbiAgICBfY29tcGlsZU1ldGFTY2hlbWEoc2NoKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRPcHRzID0gdGhpcy5vcHRzO1xuICAgICAgICB0aGlzLm9wdHMgPSB0aGlzLl9tZXRhT3B0cztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbXBpbGVfMS5jb21waWxlU2NoZW1hLmNhbGwodGhpcywgc2NoKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMub3B0cyA9IGN1cnJlbnRPcHRzO1xuICAgICAgICB9XG4gICAgfVxufVxuQWp2LlZhbGlkYXRpb25FcnJvciA9IHZhbGlkYXRpb25fZXJyb3JfMS5kZWZhdWx0O1xuQWp2Lk1pc3NpbmdSZWZFcnJvciA9IHJlZl9lcnJvcl8xLmRlZmF1bHQ7XG5leHBvcnRzLmRlZmF1bHQgPSBBanY7XG5mdW5jdGlvbiBjaGVja09wdGlvbnMoY2hlY2tPcHRzLCBvcHRpb25zLCBtc2csIGxvZyA9IFwiZXJyb3JcIikge1xuICAgIGZvciAoY29uc3Qga2V5IGluIGNoZWNrT3B0cykge1xuICAgICAgICBjb25zdCBvcHQgPSBrZXk7XG4gICAgICAgIGlmIChvcHQgaW4gb3B0aW9ucylcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyW2xvZ10oYCR7bXNnfTogb3B0aW9uICR7a2V5fS4gJHtjaGVja09wdHNbb3B0XX1gKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRTY2hFbnYoa2V5UmVmKSB7XG4gICAga2V5UmVmID0gKDAsIHJlc29sdmVfMS5ub3JtYWxpemVJZCkoa2V5UmVmKTsgLy8gVE9ETyB0ZXN0cyBmYWlsIHdpdGhvdXQgdGhpcyBsaW5lXG4gICAgcmV0dXJuIHRoaXMuc2NoZW1hc1trZXlSZWZdIHx8IHRoaXMucmVmc1trZXlSZWZdO1xufVxuZnVuY3Rpb24gYWRkSW5pdGlhbFNjaGVtYXMoKSB7XG4gICAgY29uc3Qgb3B0c1NjaGVtYXMgPSB0aGlzLm9wdHMuc2NoZW1hcztcbiAgICBpZiAoIW9wdHNTY2hlbWFzKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0c1NjaGVtYXMpKVxuICAgICAgICB0aGlzLmFkZFNjaGVtYShvcHRzU2NoZW1hcyk7XG4gICAgZWxzZVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvcHRzU2NoZW1hcylcbiAgICAgICAgICAgIHRoaXMuYWRkU2NoZW1hKG9wdHNTY2hlbWFzW2tleV0sIGtleSk7XG59XG5mdW5jdGlvbiBhZGRJbml0aWFsRm9ybWF0cygpIHtcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdGhpcy5vcHRzLmZvcm1hdHMpIHtcbiAgICAgICAgY29uc3QgZm9ybWF0ID0gdGhpcy5vcHRzLmZvcm1hdHNbbmFtZV07XG4gICAgICAgIGlmIChmb3JtYXQpXG4gICAgICAgICAgICB0aGlzLmFkZEZvcm1hdChuYW1lLCBmb3JtYXQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZEluaXRpYWxLZXl3b3JkcyhkZWZzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGVmcykpIHtcbiAgICAgICAgdGhpcy5hZGRWb2NhYnVsYXJ5KGRlZnMpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubG9nZ2VyLndhcm4oXCJrZXl3b3JkcyBvcHRpb24gYXMgbWFwIGlzIGRlcHJlY2F0ZWQsIHBhc3MgYXJyYXlcIik7XG4gICAgZm9yIChjb25zdCBrZXl3b3JkIGluIGRlZnMpIHtcbiAgICAgICAgY29uc3QgZGVmID0gZGVmc1trZXl3b3JkXTtcbiAgICAgICAgaWYgKCFkZWYua2V5d29yZClcbiAgICAgICAgICAgIGRlZi5rZXl3b3JkID0ga2V5d29yZDtcbiAgICAgICAgdGhpcy5hZGRLZXl3b3JkKGRlZik7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0TWV0YVNjaGVtYU9wdGlvbnMoKSB7XG4gICAgY29uc3QgbWV0YU9wdHMgPSB7IC4uLnRoaXMub3B0cyB9O1xuICAgIGZvciAoY29uc3Qgb3B0IG9mIE1FVEFfSUdOT1JFX09QVElPTlMpXG4gICAgICAgIGRlbGV0ZSBtZXRhT3B0c1tvcHRdO1xuICAgIHJldHVybiBtZXRhT3B0cztcbn1cbmNvbnN0IG5vTG9ncyA9IHsgbG9nKCkgeyB9LCB3YXJuKCkgeyB9LCBlcnJvcigpIHsgfSB9O1xuZnVuY3Rpb24gZ2V0TG9nZ2VyKGxvZ2dlcikge1xuICAgIGlmIChsb2dnZXIgPT09IGZhbHNlKVxuICAgICAgICByZXR1cm4gbm9Mb2dzO1xuICAgIGlmIChsb2dnZXIgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIGNvbnNvbGU7XG4gICAgaWYgKGxvZ2dlci5sb2cgJiYgbG9nZ2VyLndhcm4gJiYgbG9nZ2VyLmVycm9yKVxuICAgICAgICByZXR1cm4gbG9nZ2VyO1xuICAgIHRocm93IG5ldyBFcnJvcihcImxvZ2dlciBtdXN0IGltcGxlbWVudCBsb2csIHdhcm4gYW5kIGVycm9yIG1ldGhvZHNcIik7XG59XG5jb25zdCBLRVlXT1JEX05BTUUgPSAvXlthLXpfJF1bYS16MC05XyQ6LV0qJC9pO1xuZnVuY3Rpb24gY2hlY2tLZXl3b3JkKGtleXdvcmQsIGRlZikge1xuICAgIGNvbnN0IHsgUlVMRVMgfSA9IHRoaXM7XG4gICAgKDAsIHV0aWxfMS5lYWNoSXRlbSkoa2V5d29yZCwgKGt3ZCkgPT4ge1xuICAgICAgICBpZiAoUlVMRVMua2V5d29yZHNba3dkXSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5d29yZCAke2t3ZH0gaXMgYWxyZWFkeSBkZWZpbmVkYCk7XG4gICAgICAgIGlmICghS0VZV09SRF9OQU1FLnRlc3Qoa3dkKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5d29yZCAke2t3ZH0gaGFzIGludmFsaWQgbmFtZWApO1xuICAgIH0pO1xuICAgIGlmICghZGVmKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKGRlZi4kZGF0YSAmJiAhKFwiY29kZVwiIGluIGRlZiB8fCBcInZhbGlkYXRlXCIgaW4gZGVmKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJyRkYXRhIGtleXdvcmQgbXVzdCBoYXZlIFwiY29kZVwiIG9yIFwidmFsaWRhdGVcIiBmdW5jdGlvbicpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZFJ1bGUoa2V5d29yZCwgZGVmaW5pdGlvbiwgZGF0YVR5cGUpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgcG9zdCA9IGRlZmluaXRpb24gPT09IG51bGwgfHwgZGVmaW5pdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVmaW5pdGlvbi5wb3N0O1xuICAgIGlmIChkYXRhVHlwZSAmJiBwb3N0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2tleXdvcmQgd2l0aCBcInBvc3RcIiBmbGFnIGNhbm5vdCBoYXZlIFwidHlwZVwiJyk7XG4gICAgY29uc3QgeyBSVUxFUyB9ID0gdGhpcztcbiAgICBsZXQgcnVsZUdyb3VwID0gcG9zdCA/IFJVTEVTLnBvc3QgOiBSVUxFUy5ydWxlcy5maW5kKCh7IHR5cGU6IHQgfSkgPT4gdCA9PT0gZGF0YVR5cGUpO1xuICAgIGlmICghcnVsZUdyb3VwKSB7XG4gICAgICAgIHJ1bGVHcm91cCA9IHsgdHlwZTogZGF0YVR5cGUsIHJ1bGVzOiBbXSB9O1xuICAgICAgICBSVUxFUy5ydWxlcy5wdXNoKHJ1bGVHcm91cCk7XG4gICAgfVxuICAgIFJVTEVTLmtleXdvcmRzW2tleXdvcmRdID0gdHJ1ZTtcbiAgICBpZiAoIWRlZmluaXRpb24pXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCBydWxlID0ge1xuICAgICAgICBrZXl3b3JkLFxuICAgICAgICBkZWZpbml0aW9uOiB7XG4gICAgICAgICAgICAuLi5kZWZpbml0aW9uLFxuICAgICAgICAgICAgdHlwZTogKDAsIGRhdGFUeXBlXzEuZ2V0SlNPTlR5cGVzKShkZWZpbml0aW9uLnR5cGUpLFxuICAgICAgICAgICAgc2NoZW1hVHlwZTogKDAsIGRhdGFUeXBlXzEuZ2V0SlNPTlR5cGVzKShkZWZpbml0aW9uLnNjaGVtYVR5cGUpLFxuICAgICAgICB9LFxuICAgIH07XG4gICAgaWYgKGRlZmluaXRpb24uYmVmb3JlKVxuICAgICAgICBhZGRCZWZvcmVSdWxlLmNhbGwodGhpcywgcnVsZUdyb3VwLCBydWxlLCBkZWZpbml0aW9uLmJlZm9yZSk7XG4gICAgZWxzZVxuICAgICAgICBydWxlR3JvdXAucnVsZXMucHVzaChydWxlKTtcbiAgICBSVUxFUy5hbGxba2V5d29yZF0gPSBydWxlO1xuICAgIChfYSA9IGRlZmluaXRpb24uaW1wbGVtZW50cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvckVhY2goKGt3ZCkgPT4gdGhpcy5hZGRLZXl3b3JkKGt3ZCkpO1xufVxuZnVuY3Rpb24gYWRkQmVmb3JlUnVsZShydWxlR3JvdXAsIHJ1bGUsIGJlZm9yZSkge1xuICAgIGNvbnN0IGkgPSBydWxlR3JvdXAucnVsZXMuZmluZEluZGV4KChfcnVsZSkgPT4gX3J1bGUua2V5d29yZCA9PT0gYmVmb3JlKTtcbiAgICBpZiAoaSA+PSAwKSB7XG4gICAgICAgIHJ1bGVHcm91cC5ydWxlcy5zcGxpY2UoaSwgMCwgcnVsZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBydWxlR3JvdXAucnVsZXMucHVzaChydWxlKTtcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybihgcnVsZSAke2JlZm9yZX0gaXMgbm90IGRlZmluZWRgKTtcbiAgICB9XG59XG5mdW5jdGlvbiBrZXl3b3JkTWV0YXNjaGVtYShkZWYpIHtcbiAgICBsZXQgeyBtZXRhU2NoZW1hIH0gPSBkZWY7XG4gICAgaWYgKG1ldGFTY2hlbWEgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmIChkZWYuJGRhdGEgJiYgdGhpcy5vcHRzLiRkYXRhKVxuICAgICAgICBtZXRhU2NoZW1hID0gc2NoZW1hT3JEYXRhKG1ldGFTY2hlbWEpO1xuICAgIGRlZi52YWxpZGF0ZVNjaGVtYSA9IHRoaXMuY29tcGlsZShtZXRhU2NoZW1hLCB0cnVlKTtcbn1cbmNvbnN0ICRkYXRhUmVmID0ge1xuICAgICRyZWY6IFwiaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2Fqdi12YWxpZGF0b3IvYWp2L21hc3Rlci9saWIvcmVmcy9kYXRhLmpzb24jXCIsXG59O1xuZnVuY3Rpb24gc2NoZW1hT3JEYXRhKHNjaGVtYSkge1xuICAgIHJldHVybiB7IGFueU9mOiBbc2NoZW1hLCAkZGF0YVJlZl0gfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvcmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJpZFwiLFxuICAgIGNvZGUoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTk9UIFNVUFBPUlRFRDoga2V5d29yZCBcImlkXCIsIHVzZSBcIiRpZFwiIGZvciBzY2hlbWEgSUQnKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jYWxsUmVmID0gZXhwb3J0cy5nZXRWYWxpZGF0ZSA9IHZvaWQgMDtcbmNvbnN0IHJlZl9lcnJvcl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvcmVmX2Vycm9yXCIpO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uL2NvZGVcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgbmFtZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL25hbWVzXCIpO1xuY29uc3QgY29tcGlsZV8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGVcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiJHJlZlwiLFxuICAgIHNjaGVtYVR5cGU6IFwic3RyaW5nXCIsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYTogJHJlZiwgaXQgfSA9IGN4dDtcbiAgICAgICAgY29uc3QgeyBiYXNlSWQsIHNjaGVtYUVudjogZW52LCB2YWxpZGF0ZU5hbWUsIG9wdHMsIHNlbGYgfSA9IGl0O1xuICAgICAgICBjb25zdCB7IHJvb3QgfSA9IGVudjtcbiAgICAgICAgaWYgKCgkcmVmID09PSBcIiNcIiB8fCAkcmVmID09PSBcIiMvXCIpICYmIGJhc2VJZCA9PT0gcm9vdC5iYXNlSWQpXG4gICAgICAgICAgICByZXR1cm4gY2FsbFJvb3RSZWYoKTtcbiAgICAgICAgY29uc3Qgc2NoT3JFbnYgPSBjb21waWxlXzEucmVzb2x2ZVJlZi5jYWxsKHNlbGYsIHJvb3QsIGJhc2VJZCwgJHJlZik7XG4gICAgICAgIGlmIChzY2hPckVudiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IHJlZl9lcnJvcl8xLmRlZmF1bHQoaXQub3B0cy51cmlSZXNvbHZlciwgYmFzZUlkLCAkcmVmKTtcbiAgICAgICAgaWYgKHNjaE9yRW52IGluc3RhbmNlb2YgY29tcGlsZV8xLlNjaGVtYUVudilcbiAgICAgICAgICAgIHJldHVybiBjYWxsVmFsaWRhdGUoc2NoT3JFbnYpO1xuICAgICAgICByZXR1cm4gaW5saW5lUmVmU2NoZW1hKHNjaE9yRW52KTtcbiAgICAgICAgZnVuY3Rpb24gY2FsbFJvb3RSZWYoKSB7XG4gICAgICAgICAgICBpZiAoZW52ID09PSByb290KVxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsUmVmKGN4dCwgdmFsaWRhdGVOYW1lLCBlbnYsIGVudi4kYXN5bmMpO1xuICAgICAgICAgICAgY29uc3Qgcm9vdE5hbWUgPSBnZW4uc2NvcGVWYWx1ZShcInJvb3RcIiwgeyByZWY6IHJvb3QgfSk7XG4gICAgICAgICAgICByZXR1cm4gY2FsbFJlZihjeHQsICgwLCBjb2RlZ2VuXzEuXykgYCR7cm9vdE5hbWV9LnZhbGlkYXRlYCwgcm9vdCwgcm9vdC4kYXN5bmMpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNhbGxWYWxpZGF0ZShzY2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSBnZXRWYWxpZGF0ZShjeHQsIHNjaCk7XG4gICAgICAgICAgICBjYWxsUmVmKGN4dCwgdiwgc2NoLCBzY2guJGFzeW5jKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpbmxpbmVSZWZTY2hlbWEoc2NoKSB7XG4gICAgICAgICAgICBjb25zdCBzY2hOYW1lID0gZ2VuLnNjb3BlVmFsdWUoXCJzY2hlbWFcIiwgb3B0cy5jb2RlLnNvdXJjZSA9PT0gdHJ1ZSA/IHsgcmVmOiBzY2gsIGNvZGU6ICgwLCBjb2RlZ2VuXzEuc3RyaW5naWZ5KShzY2gpIH0gOiB7IHJlZjogc2NoIH0pO1xuICAgICAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgICAgICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICAgICAgc2NoZW1hOiBzY2gsXG4gICAgICAgICAgICAgICAgZGF0YVR5cGVzOiBbXSxcbiAgICAgICAgICAgICAgICBzY2hlbWFQYXRoOiBjb2RlZ2VuXzEubmlsLFxuICAgICAgICAgICAgICAgIHRvcFNjaGVtYVJlZjogc2NoTmFtZSxcbiAgICAgICAgICAgICAgICBlcnJTY2hlbWFQYXRoOiAkcmVmLFxuICAgICAgICAgICAgfSwgdmFsaWQpO1xuICAgICAgICAgICAgY3h0Lm1lcmdlRXZhbHVhdGVkKHNjaEN4dCk7XG4gICAgICAgICAgICBjeHQub2sodmFsaWQpO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5mdW5jdGlvbiBnZXRWYWxpZGF0ZShjeHQsIHNjaCkge1xuICAgIGNvbnN0IHsgZ2VuIH0gPSBjeHQ7XG4gICAgcmV0dXJuIHNjaC52YWxpZGF0ZVxuICAgICAgICA/IGdlbi5zY29wZVZhbHVlKFwidmFsaWRhdGVcIiwgeyByZWY6IHNjaC52YWxpZGF0ZSB9KVxuICAgICAgICA6ICgwLCBjb2RlZ2VuXzEuXykgYCR7Z2VuLnNjb3BlVmFsdWUoXCJ3cmFwcGVyXCIsIHsgcmVmOiBzY2ggfSl9LnZhbGlkYXRlYDtcbn1cbmV4cG9ydHMuZ2V0VmFsaWRhdGUgPSBnZXRWYWxpZGF0ZTtcbmZ1bmN0aW9uIGNhbGxSZWYoY3h0LCB2LCBzY2gsICRhc3luYykge1xuICAgIGNvbnN0IHsgZ2VuLCBpdCB9ID0gY3h0O1xuICAgIGNvbnN0IHsgYWxsRXJyb3JzLCBzY2hlbWFFbnY6IGVudiwgb3B0cyB9ID0gaXQ7XG4gICAgY29uc3QgcGFzc0N4dCA9IG9wdHMucGFzc0NvbnRleHQgPyBuYW1lc18xLmRlZmF1bHQudGhpcyA6IGNvZGVnZW5fMS5uaWw7XG4gICAgaWYgKCRhc3luYylcbiAgICAgICAgY2FsbEFzeW5jUmVmKCk7XG4gICAgZWxzZVxuICAgICAgICBjYWxsU3luY1JlZigpO1xuICAgIGZ1bmN0aW9uIGNhbGxBc3luY1JlZigpIHtcbiAgICAgICAgaWYgKCFlbnYuJGFzeW5jKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXN5bmMgc2NoZW1hIHJlZmVyZW5jZWQgYnkgc3luYyBzY2hlbWFcIik7XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIpO1xuICAgICAgICBnZW4udHJ5KCgpID0+IHtcbiAgICAgICAgICAgIGdlbi5jb2RlKCgwLCBjb2RlZ2VuXzEuXykgYGF3YWl0ICR7KDAsIGNvZGVfMS5jYWxsVmFsaWRhdGVDb2RlKShjeHQsIHYsIHBhc3NDeHQpfWApO1xuICAgICAgICAgICAgYWRkRXZhbHVhdGVkRnJvbSh2KTsgLy8gVE9ETyB3aWxsIG5vdCB3b3JrIHdpdGggYXN5bmMsIGl0IGhhcyB0byBiZSByZXR1cm5lZCB3aXRoIHRoZSByZXN1bHRcbiAgICAgICAgICAgIGlmICghYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIHRydWUpO1xuICAgICAgICB9LCAoZSkgPT4ge1xuICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCEoJHtlfSBpbnN0YW5jZW9mICR7aXQuVmFsaWRhdGlvbkVycm9yfSlgLCAoKSA9PiBnZW4udGhyb3coZSkpO1xuICAgICAgICAgICAgYWRkRXJyb3JzRnJvbShlKTtcbiAgICAgICAgICAgIGlmICghYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhbGxTeW5jUmVmKCkge1xuICAgICAgICBjeHQucmVzdWx0KCgwLCBjb2RlXzEuY2FsbFZhbGlkYXRlQ29kZSkoY3h0LCB2LCBwYXNzQ3h0KSwgKCkgPT4gYWRkRXZhbHVhdGVkRnJvbSh2KSwgKCkgPT4gYWRkRXJyb3JzRnJvbSh2KSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZEVycm9yc0Zyb20oc291cmNlKSB7XG4gICAgICAgIGNvbnN0IGVycnMgPSAoMCwgY29kZWdlbl8xLl8pIGAke3NvdXJjZX0uZXJyb3JzYDtcbiAgICAgICAgZ2VuLmFzc2lnbihuYW1lc18xLmRlZmF1bHQudkVycm9ycywgKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30gPT09IG51bGwgPyAke2VycnN9IDogJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30uY29uY2F0KCR7ZXJyc30pYCk7IC8vIFRPRE8gdGFnZ2VkXG4gICAgICAgIGdlbi5hc3NpZ24obmFtZXNfMS5kZWZhdWx0LmVycm9ycywgKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30ubGVuZ3RoYCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZEV2YWx1YXRlZEZyb20oc291cmNlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCFpdC5vcHRzLnVuZXZhbHVhdGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBzY2hFdmFsdWF0ZWQgPSAoX2EgPSBzY2ggPT09IG51bGwgfHwgc2NoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY2gudmFsaWRhdGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ldmFsdWF0ZWQ7XG4gICAgICAgIC8vIFRPRE8gcmVmYWN0b3JcbiAgICAgICAgaWYgKGl0LnByb3BzICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBpZiAoc2NoRXZhbHVhdGVkICYmICFzY2hFdmFsdWF0ZWQuZHluYW1pY1Byb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNjaEV2YWx1YXRlZC5wcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0LnByb3BzID0gdXRpbF8xLm1lcmdlRXZhbHVhdGVkLnByb3BzKGdlbiwgc2NoRXZhbHVhdGVkLnByb3BzLCBpdC5wcm9wcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcHMgPSBnZW4udmFyKFwicHJvcHNcIiwgKDAsIGNvZGVnZW5fMS5fKSBgJHtzb3VyY2V9LmV2YWx1YXRlZC5wcm9wc2ApO1xuICAgICAgICAgICAgICAgIGl0LnByb3BzID0gdXRpbF8xLm1lcmdlRXZhbHVhdGVkLnByb3BzKGdlbiwgcHJvcHMsIGl0LnByb3BzLCBjb2RlZ2VuXzEuTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0Lml0ZW1zICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBpZiAoc2NoRXZhbHVhdGVkICYmICFzY2hFdmFsdWF0ZWQuZHluYW1pY0l0ZW1zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNjaEV2YWx1YXRlZC5pdGVtcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0Lml0ZW1zID0gdXRpbF8xLm1lcmdlRXZhbHVhdGVkLml0ZW1zKGdlbiwgc2NoRXZhbHVhdGVkLml0ZW1zLCBpdC5pdGVtcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbXMgPSBnZW4udmFyKFwiaXRlbXNcIiwgKDAsIGNvZGVnZW5fMS5fKSBgJHtzb3VyY2V9LmV2YWx1YXRlZC5pdGVtc2ApO1xuICAgICAgICAgICAgICAgIGl0Lml0ZW1zID0gdXRpbF8xLm1lcmdlRXZhbHVhdGVkLml0ZW1zKGdlbiwgaXRlbXMsIGl0Lml0ZW1zLCBjb2RlZ2VuXzEuTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmNhbGxSZWYgPSBjYWxsUmVmO1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVmLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgaWRfMSA9IHJlcXVpcmUoXCIuL2lkXCIpO1xuY29uc3QgcmVmXzEgPSByZXF1aXJlKFwiLi9yZWZcIik7XG5jb25zdCBjb3JlID0gW1xuICAgIFwiJHNjaGVtYVwiLFxuICAgIFwiJGlkXCIsXG4gICAgXCIkZGVmc1wiLFxuICAgIFwiJHZvY2FidWxhcnlcIixcbiAgICB7IGtleXdvcmQ6IFwiJGNvbW1lbnRcIiB9LFxuICAgIFwiZGVmaW5pdGlvbnNcIixcbiAgICBpZF8xLmRlZmF1bHQsXG4gICAgcmVmXzEuZGVmYXVsdCxcbl07XG5leHBvcnRzLmRlZmF1bHQgPSBjb3JlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3Qgb3BzID0gY29kZWdlbl8xLm9wZXJhdG9ycztcbmNvbnN0IEtXRHMgPSB7XG4gICAgbWF4aW11bTogeyBva1N0cjogXCI8PVwiLCBvazogb3BzLkxURSwgZmFpbDogb3BzLkdUIH0sXG4gICAgbWluaW11bTogeyBva1N0cjogXCI+PVwiLCBvazogb3BzLkdURSwgZmFpbDogb3BzLkxUIH0sXG4gICAgZXhjbHVzaXZlTWF4aW11bTogeyBva1N0cjogXCI8XCIsIG9rOiBvcHMuTFQsIGZhaWw6IG9wcy5HVEUgfSxcbiAgICBleGNsdXNpdmVNaW5pbXVtOiB7IG9rU3RyOiBcIj5cIiwgb2s6IG9wcy5HVCwgZmFpbDogb3BzLkxURSB9LFxufTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IGtleXdvcmQsIHNjaGVtYUNvZGUgfSkgPT4gKDAsIGNvZGVnZW5fMS5zdHIpIGBtdXN0IGJlICR7S1dEc1trZXl3b3JkXS5va1N0cn0gJHtzY2hlbWFDb2RlfWAsXG4gICAgcGFyYW1zOiAoeyBrZXl3b3JkLCBzY2hlbWFDb2RlIH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHtjb21wYXJpc29uOiAke0tXRHNba2V5d29yZF0ub2tTdHJ9LCBsaW1pdDogJHtzY2hlbWFDb2RlfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBPYmplY3Qua2V5cyhLV0RzKSxcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIHNjaGVtYVR5cGU6IFwibnVtYmVyXCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBrZXl3b3JkLCBkYXRhLCBzY2hlbWFDb2RlIH0gPSBjeHQ7XG4gICAgICAgIGN4dC5mYWlsJGRhdGEoKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfSAke0tXRHNba2V5d29yZF0uZmFpbH0gJHtzY2hlbWFDb2RlfSB8fCBpc05hTigke2RhdGF9KWApO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGltaXROdW1iZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsgc2NoZW1hQ29kZSB9KSA9PiAoMCwgY29kZWdlbl8xLnN0cikgYG11c3QgYmUgbXVsdGlwbGUgb2YgJHtzY2hlbWFDb2RlfWAsXG4gICAgcGFyYW1zOiAoeyBzY2hlbWFDb2RlIH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHttdWx0aXBsZU9mOiAke3NjaGVtYUNvZGV9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwibXVsdGlwbGVPZlwiLFxuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgc2NoZW1hVHlwZTogXCJudW1iZXJcIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgZGF0YSwgc2NoZW1hQ29kZSwgaXQgfSA9IGN4dDtcbiAgICAgICAgLy8gY29uc3QgYmR0ID0gYmFkJERhdGFUeXBlKHNjaGVtYUNvZGUsIDxzdHJpbmc+ZGVmLnNjaGVtYVR5cGUsICRkYXRhKVxuICAgICAgICBjb25zdCBwcmVjID0gaXQub3B0cy5tdWx0aXBsZU9mUHJlY2lzaW9uO1xuICAgICAgICBjb25zdCByZXMgPSBnZW4ubGV0KFwicmVzXCIpO1xuICAgICAgICBjb25zdCBpbnZhbGlkID0gcHJlY1xuICAgICAgICAgICAgPyAoMCwgY29kZWdlbl8xLl8pIGBNYXRoLmFicyhNYXRoLnJvdW5kKCR7cmVzfSkgLSAke3Jlc30pID4gMWUtJHtwcmVjfWBcbiAgICAgICAgICAgIDogKDAsIGNvZGVnZW5fMS5fKSBgJHtyZXN9ICE9PSBwYXJzZUludCgke3Jlc30pYDtcbiAgICAgICAgY3h0LmZhaWwkZGF0YSgoMCwgY29kZWdlbl8xLl8pIGAoJHtzY2hlbWFDb2RlfSA9PT0gMCB8fCAoJHtyZXN9ID0gJHtkYXRhfS8ke3NjaGVtYUNvZGV9LCAke2ludmFsaWR9KSlgKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW11bHRpcGxlT2YuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZ1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Jlc3RpZWpzL3B1bnljb2RlLmpzIC0gcHVueWNvZGUudWNzMi5kZWNvZGVcbmZ1bmN0aW9uIHVjczJsZW5ndGgoc3RyKSB7XG4gICAgY29uc3QgbGVuID0gc3RyLmxlbmd0aDtcbiAgICBsZXQgbGVuZ3RoID0gMDtcbiAgICBsZXQgcG9zID0gMDtcbiAgICBsZXQgdmFsdWU7XG4gICAgd2hpbGUgKHBvcyA8IGxlbikge1xuICAgICAgICBsZW5ndGgrKztcbiAgICAgICAgdmFsdWUgPSBzdHIuY2hhckNvZGVBdChwb3MrKyk7XG4gICAgICAgIGlmICh2YWx1ZSA+PSAweGQ4MDAgJiYgdmFsdWUgPD0gMHhkYmZmICYmIHBvcyA8IGxlbikge1xuICAgICAgICAgICAgLy8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG4gICAgICAgICAgICB2YWx1ZSA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgICAgICBpZiAoKHZhbHVlICYgMHhmYzAwKSA9PT0gMHhkYzAwKVxuICAgICAgICAgICAgICAgIHBvcysrOyAvLyBsb3cgc3Vycm9nYXRlXG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxlbmd0aDtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHVjczJsZW5ndGg7XG51Y3MybGVuZ3RoLmNvZGUgPSAncmVxdWlyZShcImFqdi9kaXN0L3J1bnRpbWUvdWNzMmxlbmd0aFwiKS5kZWZhdWx0Jztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVjczJsZW5ndGguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IHVjczJsZW5ndGhfMSA9IHJlcXVpcmUoXCIuLi8uLi9ydW50aW1lL3VjczJsZW5ndGhcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlKHsga2V5d29yZCwgc2NoZW1hQ29kZSB9KSB7XG4gICAgICAgIGNvbnN0IGNvbXAgPSBrZXl3b3JkID09PSBcIm1heExlbmd0aFwiID8gXCJtb3JlXCIgOiBcImZld2VyXCI7XG4gICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLnN0cikgYG11c3QgTk9UIGhhdmUgJHtjb21wfSB0aGFuICR7c2NoZW1hQ29kZX0gY2hhcmFjdGVyc2A7XG4gICAgfSxcbiAgICBwYXJhbXM6ICh7IHNjaGVtYUNvZGUgfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge2xpbWl0OiAke3NjaGVtYUNvZGV9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFtcIm1heExlbmd0aFwiLCBcIm1pbkxlbmd0aFwiXSxcbiAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgIHNjaGVtYVR5cGU6IFwibnVtYmVyXCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBrZXl3b3JkLCBkYXRhLCBzY2hlbWFDb2RlLCBpdCB9ID0gY3h0O1xuICAgICAgICBjb25zdCBvcCA9IGtleXdvcmQgPT09IFwibWF4TGVuZ3RoXCIgPyBjb2RlZ2VuXzEub3BlcmF0b3JzLkdUIDogY29kZWdlbl8xLm9wZXJhdG9ycy5MVDtcbiAgICAgICAgY29uc3QgbGVuID0gaXQub3B0cy51bmljb2RlID09PSBmYWxzZSA/ICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0ubGVuZ3RoYCA6ICgwLCBjb2RlZ2VuXzEuXykgYCR7KDAsIHV0aWxfMS51c2VGdW5jKShjeHQuZ2VuLCB1Y3MybGVuZ3RoXzEuZGVmYXVsdCl9KCR7ZGF0YX0pYDtcbiAgICAgICAgY3h0LmZhaWwkZGF0YSgoMCwgY29kZWdlbl8xLl8pIGAke2xlbn0gJHtvcH0gJHtzY2hlbWFDb2RlfWApO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGltaXRMZW5ndGguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi4vY29kZVwiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBzY2hlbWFDb2RlIH0pID0+ICgwLCBjb2RlZ2VuXzEuc3RyKSBgbXVzdCBtYXRjaCBwYXR0ZXJuIFwiJHtzY2hlbWFDb2RlfVwiYCxcbiAgICBwYXJhbXM6ICh7IHNjaGVtYUNvZGUgfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge3BhdHRlcm46ICR7c2NoZW1hQ29kZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJwYXR0ZXJuXCIsXG4gICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICBzY2hlbWFUeXBlOiBcInN0cmluZ1wiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZGF0YSwgJGRhdGEsIHNjaGVtYSwgc2NoZW1hQ29kZSwgaXQgfSA9IGN4dDtcbiAgICAgICAgLy8gVE9ETyByZWdleHAgc2hvdWxkIGJlIHdyYXBwZWQgaW4gdHJ5L2NhdGNoc1xuICAgICAgICBjb25zdCB1ID0gaXQub3B0cy51bmljb2RlUmVnRXhwID8gXCJ1XCIgOiBcIlwiO1xuICAgICAgICBjb25zdCByZWdFeHAgPSAkZGF0YSA/ICgwLCBjb2RlZ2VuXzEuXykgYChuZXcgUmVnRXhwKCR7c2NoZW1hQ29kZX0sICR7dX0pKWAgOiAoMCwgY29kZV8xLnVzZVBhdHRlcm4pKGN4dCwgc2NoZW1hKTtcbiAgICAgICAgY3h0LmZhaWwkZGF0YSgoMCwgY29kZWdlbl8xLl8pIGAhJHtyZWdFeHB9LnRlc3QoJHtkYXRhfSlgKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhdHRlcm4uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZSh7IGtleXdvcmQsIHNjaGVtYUNvZGUgfSkge1xuICAgICAgICBjb25zdCBjb21wID0ga2V5d29yZCA9PT0gXCJtYXhQcm9wZXJ0aWVzXCIgPyBcIm1vcmVcIiA6IFwiZmV3ZXJcIjtcbiAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuc3RyKSBgbXVzdCBOT1QgaGF2ZSAke2NvbXB9IHRoYW4gJHtzY2hlbWFDb2RlfSBwcm9wZXJ0aWVzYDtcbiAgICB9LFxuICAgIHBhcmFtczogKHsgc2NoZW1hQ29kZSB9KSA9PiAoMCwgY29kZWdlbl8xLl8pIGB7bGltaXQ6ICR7c2NoZW1hQ29kZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogW1wibWF4UHJvcGVydGllc1wiLCBcIm1pblByb3BlcnRpZXNcIl0sXG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICBzY2hlbWFUeXBlOiBcIm51bWJlclwiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsga2V5d29yZCwgZGF0YSwgc2NoZW1hQ29kZSB9ID0gY3h0O1xuICAgICAgICBjb25zdCBvcCA9IGtleXdvcmQgPT09IFwibWF4UHJvcGVydGllc1wiID8gY29kZWdlbl8xLm9wZXJhdG9ycy5HVCA6IGNvZGVnZW5fMS5vcGVyYXRvcnMuTFQ7XG4gICAgICAgIGN4dC5mYWlsJGRhdGEoKDAsIGNvZGVnZW5fMS5fKSBgT2JqZWN0LmtleXMoJHtkYXRhfSkubGVuZ3RoICR7b3B9ICR7c2NoZW1hQ29kZX1gKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpbWl0UHJvcGVydGllcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi9jb2RlXCIpO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBwYXJhbXM6IHsgbWlzc2luZ1Byb3BlcnR5IH0gfSkgPT4gKDAsIGNvZGVnZW5fMS5zdHIpIGBtdXN0IGhhdmUgcmVxdWlyZWQgcHJvcGVydHkgJyR7bWlzc2luZ1Byb3BlcnR5fSdgLFxuICAgIHBhcmFtczogKHsgcGFyYW1zOiB7IG1pc3NpbmdQcm9wZXJ0eSB9IH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHttaXNzaW5nUHJvcGVydHk6ICR7bWlzc2luZ1Byb3BlcnR5fX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcInJlcXVpcmVkXCIsXG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICBzY2hlbWFUeXBlOiBcImFycmF5XCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgc2NoZW1hQ29kZSwgZGF0YSwgJGRhdGEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGNvbnN0IHsgb3B0cyB9ID0gaXQ7XG4gICAgICAgIGlmICghJGRhdGEgJiYgc2NoZW1hLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgdXNlTG9vcCA9IHNjaGVtYS5sZW5ndGggPj0gb3B0cy5sb29wUmVxdWlyZWQ7XG4gICAgICAgIGlmIChpdC5hbGxFcnJvcnMpXG4gICAgICAgICAgICBhbGxFcnJvcnNNb2RlKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGV4aXRPbkVycm9yTW9kZSgpO1xuICAgICAgICBpZiAob3B0cy5zdHJpY3RSZXF1aXJlZCkge1xuICAgICAgICAgICAgY29uc3QgcHJvcHMgPSBjeHQucGFyZW50U2NoZW1hLnByb3BlcnRpZXM7XG4gICAgICAgICAgICBjb25zdCB7IGRlZmluZWRQcm9wZXJ0aWVzIH0gPSBjeHQuaXQ7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJlcXVpcmVkS2V5IG9mIHNjaGVtYSkge1xuICAgICAgICAgICAgICAgIGlmICgocHJvcHMgPT09IG51bGwgfHwgcHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb3BzW3JlcXVpcmVkS2V5XSkgPT09IHVuZGVmaW5lZCAmJiAhZGVmaW5lZFByb3BlcnRpZXMuaGFzKHJlcXVpcmVkS2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzY2hlbWFQYXRoID0gaXQuc2NoZW1hRW52LmJhc2VJZCArIGl0LmVyclNjaGVtYVBhdGg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1zZyA9IGByZXF1aXJlZCBwcm9wZXJ0eSBcIiR7cmVxdWlyZWRLZXl9XCIgaXMgbm90IGRlZmluZWQgYXQgXCIke3NjaGVtYVBhdGh9XCIgKHN0cmljdFJlcXVpcmVkKWA7XG4gICAgICAgICAgICAgICAgICAgICgwLCB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKShpdCwgbXNnLCBpdC5vcHRzLnN0cmljdFJlcXVpcmVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYWxsRXJyb3JzTW9kZSgpIHtcbiAgICAgICAgICAgIGlmICh1c2VMb29wIHx8ICRkYXRhKSB7XG4gICAgICAgICAgICAgICAgY3h0LmJsb2NrJGRhdGEoY29kZWdlbl8xLm5pbCwgbG9vcEFsbFJlcXVpcmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcCBvZiBzY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIGNvZGVfMS5jaGVja1JlcG9ydE1pc3NpbmdQcm9wKShjeHQsIHByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBleGl0T25FcnJvck1vZGUoKSB7XG4gICAgICAgICAgICBjb25zdCBtaXNzaW5nID0gZ2VuLmxldChcIm1pc3NpbmdcIik7XG4gICAgICAgICAgICBpZiAodXNlTG9vcCB8fCAkZGF0YSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIsIHRydWUpO1xuICAgICAgICAgICAgICAgIGN4dC5ibG9jayRkYXRhKHZhbGlkLCAoKSA9PiBsb29wVW50aWxNaXNzaW5nKG1pc3NpbmcsIHZhbGlkKSk7XG4gICAgICAgICAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZV8xLmNoZWNrTWlzc2luZ1Byb3ApKGN4dCwgc2NoZW1hLCBtaXNzaW5nKSk7XG4gICAgICAgICAgICAgICAgKDAsIGNvZGVfMS5yZXBvcnRNaXNzaW5nUHJvcCkoY3h0LCBtaXNzaW5nKTtcbiAgICAgICAgICAgICAgICBnZW4uZWxzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGxvb3BBbGxSZXF1aXJlZCgpIHtcbiAgICAgICAgICAgIGdlbi5mb3JPZihcInByb3BcIiwgc2NoZW1hQ29kZSwgKHByb3ApID0+IHtcbiAgICAgICAgICAgICAgICBjeHQuc2V0UGFyYW1zKHsgbWlzc2luZ1Byb3BlcnR5OiBwcm9wIH0pO1xuICAgICAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZV8xLm5vUHJvcGVydHlJbkRhdGEpKGdlbiwgZGF0YSwgcHJvcCwgb3B0cy5vd25Qcm9wZXJ0aWVzKSwgKCkgPT4gY3h0LmVycm9yKCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbG9vcFVudGlsTWlzc2luZyhtaXNzaW5nLCB2YWxpZCkge1xuICAgICAgICAgICAgY3h0LnNldFBhcmFtcyh7IG1pc3NpbmdQcm9wZXJ0eTogbWlzc2luZyB9KTtcbiAgICAgICAgICAgIGdlbi5mb3JPZihtaXNzaW5nLCBzY2hlbWFDb2RlLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgKDAsIGNvZGVfMS5wcm9wZXJ0eUluRGF0YSkoZ2VuLCBkYXRhLCBtaXNzaW5nLCBvcHRzLm93blByb3BlcnRpZXMpKTtcbiAgICAgICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5ub3QpKHZhbGlkKSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjeHQuZXJyb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmJyZWFrKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBjb2RlZ2VuXzEubmlsKTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVxdWlyZWQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZSh7IGtleXdvcmQsIHNjaGVtYUNvZGUgfSkge1xuICAgICAgICBjb25zdCBjb21wID0ga2V5d29yZCA9PT0gXCJtYXhJdGVtc1wiID8gXCJtb3JlXCIgOiBcImZld2VyXCI7XG4gICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLnN0cikgYG11c3QgTk9UIGhhdmUgJHtjb21wfSB0aGFuICR7c2NoZW1hQ29kZX0gaXRlbXNgO1xuICAgIH0sXG4gICAgcGFyYW1zOiAoeyBzY2hlbWFDb2RlIH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHtsaW1pdDogJHtzY2hlbWFDb2RlfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBbXCJtYXhJdGVtc1wiLCBcIm1pbkl0ZW1zXCJdLFxuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBzY2hlbWFUeXBlOiBcIm51bWJlclwiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsga2V5d29yZCwgZGF0YSwgc2NoZW1hQ29kZSB9ID0gY3h0O1xuICAgICAgICBjb25zdCBvcCA9IGtleXdvcmQgPT09IFwibWF4SXRlbXNcIiA/IGNvZGVnZW5fMS5vcGVyYXRvcnMuR1QgOiBjb2RlZ2VuXzEub3BlcmF0b3JzLkxUO1xuICAgICAgICBjeHQuZmFpbCRkYXRhKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0ubGVuZ3RoICR7b3B9ICR7c2NoZW1hQ29kZX1gKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpbWl0SXRlbXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vYWp2LXZhbGlkYXRvci9hanYvaXNzdWVzLzg4OVxuY29uc3QgZXF1YWwgPSByZXF1aXJlKFwiZmFzdC1kZWVwLWVxdWFsXCIpO1xuZXF1YWwuY29kZSA9ICdyZXF1aXJlKFwiYWp2L2Rpc3QvcnVudGltZS9lcXVhbFwiKS5kZWZhdWx0JztcbmV4cG9ydHMuZGVmYXVsdCA9IGVxdWFsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXF1YWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBkYXRhVHlwZV8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGUvZGF0YVR5cGVcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVxdWFsXzEgPSByZXF1aXJlKFwiLi4vLi4vcnVudGltZS9lcXVhbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHBhcmFtczogeyBpLCBqIH0gfSkgPT4gKDAsIGNvZGVnZW5fMS5zdHIpIGBtdXN0IE5PVCBoYXZlIGR1cGxpY2F0ZSBpdGVtcyAoaXRlbXMgIyMgJHtqfSBhbmQgJHtpfSBhcmUgaWRlbnRpY2FsKWAsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXM6IHsgaSwgaiB9IH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHtpOiAke2l9LCBqOiAke2p9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwidW5pcXVlSXRlbXNcIixcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgc2NoZW1hVHlwZTogXCJib29sZWFuXCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIGRhdGEsICRkYXRhLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgc2NoZW1hQ29kZSwgaXQgfSA9IGN4dDtcbiAgICAgICAgaWYgKCEkZGF0YSAmJiAhc2NoZW1hKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiKTtcbiAgICAgICAgY29uc3QgaXRlbVR5cGVzID0gcGFyZW50U2NoZW1hLml0ZW1zID8gKDAsIGRhdGFUeXBlXzEuZ2V0U2NoZW1hVHlwZXMpKHBhcmVudFNjaGVtYS5pdGVtcykgOiBbXTtcbiAgICAgICAgY3h0LmJsb2NrJGRhdGEodmFsaWQsIHZhbGlkYXRlVW5pcXVlSXRlbXMsICgwLCBjb2RlZ2VuXzEuXykgYCR7c2NoZW1hQ29kZX0gPT09IGZhbHNlYCk7XG4gICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlVW5pcXVlSXRlbXMoKSB7XG4gICAgICAgICAgICBjb25zdCBpID0gZ2VuLmxldChcImlcIiwgKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfS5sZW5ndGhgKTtcbiAgICAgICAgICAgIGNvbnN0IGogPSBnZW4ubGV0KFwialwiKTtcbiAgICAgICAgICAgIGN4dC5zZXRQYXJhbXMoeyBpLCBqIH0pO1xuICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSk7XG4gICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtpfSA+IDFgLCAoKSA9PiAoY2FuT3B0aW1pemUoKSA/IGxvb3BOIDogbG9vcE4yKShpLCBqKSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2FuT3B0aW1pemUoKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbVR5cGVzLmxlbmd0aCA+IDAgJiYgIWl0ZW1UeXBlcy5zb21lKCh0KSA9PiB0ID09PSBcIm9iamVjdFwiIHx8IHQgPT09IFwiYXJyYXlcIik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbG9vcE4oaSwgaikge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IGdlbi5uYW1lKFwiaXRlbVwiKTtcbiAgICAgICAgICAgIGNvbnN0IHdyb25nVHlwZSA9ICgwLCBkYXRhVHlwZV8xLmNoZWNrRGF0YVR5cGVzKShpdGVtVHlwZXMsIGl0ZW0sIGl0Lm9wdHMuc3RyaWN0TnVtYmVycywgZGF0YVR5cGVfMS5EYXRhVHlwZS5Xcm9uZyk7XG4gICAgICAgICAgICBjb25zdCBpbmRpY2VzID0gZ2VuLmNvbnN0KFwiaW5kaWNlc1wiLCAoMCwgY29kZWdlbl8xLl8pIGB7fWApO1xuICAgICAgICAgICAgZ2VuLmZvcigoMCwgY29kZWdlbl8xLl8pIGA7JHtpfS0tO2AsICgpID0+IHtcbiAgICAgICAgICAgICAgICBnZW4ubGV0KGl0ZW0sICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX1bJHtpfV1gKTtcbiAgICAgICAgICAgICAgICBnZW4uaWYod3JvbmdUeXBlLCAoMCwgY29kZWdlbl8xLl8pIGBjb250aW51ZWApO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtVHlwZXMubGVuZ3RoID4gMSlcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYHR5cGVvZiAke2l0ZW19ID09IFwic3RyaW5nXCJgLCAoMCwgY29kZWdlbl8xLl8pIGAke2l0ZW19ICs9IFwiX1wiYCk7XG4gICAgICAgICAgICAgICAgZ2VuXG4gICAgICAgICAgICAgICAgICAgIC5pZigoMCwgY29kZWdlbl8xLl8pIGB0eXBlb2YgJHtpbmRpY2VzfVske2l0ZW19XSA9PSBcIm51bWJlclwiYCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBnZW4uYXNzaWduKGosICgwLCBjb2RlZ2VuXzEuXykgYCR7aW5kaWNlc31bJHtpdGVtfV1gKTtcbiAgICAgICAgICAgICAgICAgICAgY3h0LmVycm9yKCk7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIGZhbHNlKS5icmVhaygpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5jb2RlKCgwLCBjb2RlZ2VuXzEuXykgYCR7aW5kaWNlc31bJHtpdGVtfV0gPSAke2l9YCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBsb29wTjIoaSwgaikge1xuICAgICAgICAgICAgY29uc3QgZXFsID0gKDAsIHV0aWxfMS51c2VGdW5jKShnZW4sIGVxdWFsXzEuZGVmYXVsdCk7XG4gICAgICAgICAgICBjb25zdCBvdXRlciA9IGdlbi5uYW1lKFwib3V0ZXJcIik7XG4gICAgICAgICAgICBnZW4ubGFiZWwob3V0ZXIpLmZvcigoMCwgY29kZWdlbl8xLl8pIGA7JHtpfS0tO2AsICgpID0+IGdlbi5mb3IoKDAsIGNvZGVnZW5fMS5fKSBgJHtqfSA9ICR7aX07ICR7an0tLTtgLCAoKSA9PiBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtlcWx9KCR7ZGF0YX1bJHtpfV0sICR7ZGF0YX1bJHtqfV0pYCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGN4dC5lcnJvcigpO1xuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIGZhbHNlKS5icmVhayhvdXRlcik7XG4gICAgICAgICAgICB9KSkpO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11bmlxdWVJdGVtcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZXF1YWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9ydW50aW1lL2VxdWFsXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogXCJtdXN0IGJlIGVxdWFsIHRvIGNvbnN0YW50XCIsXG4gICAgcGFyYW1zOiAoeyBzY2hlbWFDb2RlIH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHthbGxvd2VkVmFsdWU6ICR7c2NoZW1hQ29kZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJjb25zdFwiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCAkZGF0YSwgc2NoZW1hQ29kZSwgc2NoZW1hIH0gPSBjeHQ7XG4gICAgICAgIGlmICgkZGF0YSB8fCAoc2NoZW1hICYmIHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIikpIHtcbiAgICAgICAgICAgIGN4dC5mYWlsJGRhdGEoKDAsIGNvZGVnZW5fMS5fKSBgISR7KDAsIHV0aWxfMS51c2VGdW5jKShnZW4sIGVxdWFsXzEuZGVmYXVsdCl9KCR7ZGF0YX0sICR7c2NoZW1hQ29kZX0pYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjeHQuZmFpbCgoMCwgY29kZWdlbl8xLl8pIGAke3NjaGVtYX0gIT09ICR7ZGF0YX1gKTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVxdWFsXzEgPSByZXF1aXJlKFwiLi4vLi4vcnVudGltZS9lcXVhbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6IFwibXVzdCBiZSBlcXVhbCB0byBvbmUgb2YgdGhlIGFsbG93ZWQgdmFsdWVzXCIsXG4gICAgcGFyYW1zOiAoeyBzY2hlbWFDb2RlIH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHthbGxvd2VkVmFsdWVzOiAke3NjaGVtYUNvZGV9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiZW51bVwiLFxuICAgIHNjaGVtYVR5cGU6IFwiYXJyYXlcIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgZGF0YSwgJGRhdGEsIHNjaGVtYSwgc2NoZW1hQ29kZSwgaXQgfSA9IGN4dDtcbiAgICAgICAgaWYgKCEkZGF0YSAmJiBzY2hlbWEubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZW51bSBtdXN0IGhhdmUgbm9uLWVtcHR5IGFycmF5XCIpO1xuICAgICAgICBjb25zdCB1c2VMb29wID0gc2NoZW1hLmxlbmd0aCA+PSBpdC5vcHRzLmxvb3BFbnVtO1xuICAgICAgICBsZXQgZXFsO1xuICAgICAgICBjb25zdCBnZXRFcWwgPSAoKSA9PiAoZXFsICE9PSBudWxsICYmIGVxbCAhPT0gdm9pZCAwID8gZXFsIDogKGVxbCA9ICgwLCB1dGlsXzEudXNlRnVuYykoZ2VuLCBlcXVhbF8xLmRlZmF1bHQpKSk7XG4gICAgICAgIGxldCB2YWxpZDtcbiAgICAgICAgaWYgKHVzZUxvb3AgfHwgJGRhdGEpIHtcbiAgICAgICAgICAgIHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIpO1xuICAgICAgICAgICAgY3h0LmJsb2NrJGRhdGEodmFsaWQsIGxvb3BFbnVtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNjaGVtYSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgICAgICAgICAgY29uc3QgdlNjaGVtYSA9IGdlbi5jb25zdChcInZTY2hlbWFcIiwgc2NoZW1hQ29kZSk7XG4gICAgICAgICAgICB2YWxpZCA9ICgwLCBjb2RlZ2VuXzEub3IpKC4uLnNjaGVtYS5tYXAoKF94LCBpKSA9PiBlcXVhbENvZGUodlNjaGVtYSwgaSkpKTtcbiAgICAgICAgfVxuICAgICAgICBjeHQucGFzcyh2YWxpZCk7XG4gICAgICAgIGZ1bmN0aW9uIGxvb3BFbnVtKCkge1xuICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgZmFsc2UpO1xuICAgICAgICAgICAgZ2VuLmZvck9mKFwidlwiLCBzY2hlbWFDb2RlLCAodikgPT4gZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7Z2V0RXFsKCl9KCR7ZGF0YX0sICR7dn0pYCwgKCkgPT4gZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSkuYnJlYWsoKSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGVxdWFsQ29kZSh2U2NoZW1hLCBpKSB7XG4gICAgICAgICAgICBjb25zdCBzY2ggPSBzY2hlbWFbaV07XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHNjaCA9PT0gXCJvYmplY3RcIiAmJiBzY2ggIT09IG51bGxcbiAgICAgICAgICAgICAgICA/ICgwLCBjb2RlZ2VuXzEuXykgYCR7Z2V0RXFsKCl9KCR7ZGF0YX0sICR7dlNjaGVtYX1bJHtpfV0pYFxuICAgICAgICAgICAgICAgIDogKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfSA9PT0gJHtzY2h9YDtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW51bS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGxpbWl0TnVtYmVyXzEgPSByZXF1aXJlKFwiLi9saW1pdE51bWJlclwiKTtcbmNvbnN0IG11bHRpcGxlT2ZfMSA9IHJlcXVpcmUoXCIuL211bHRpcGxlT2ZcIik7XG5jb25zdCBsaW1pdExlbmd0aF8xID0gcmVxdWlyZShcIi4vbGltaXRMZW5ndGhcIik7XG5jb25zdCBwYXR0ZXJuXzEgPSByZXF1aXJlKFwiLi9wYXR0ZXJuXCIpO1xuY29uc3QgbGltaXRQcm9wZXJ0aWVzXzEgPSByZXF1aXJlKFwiLi9saW1pdFByb3BlcnRpZXNcIik7XG5jb25zdCByZXF1aXJlZF8xID0gcmVxdWlyZShcIi4vcmVxdWlyZWRcIik7XG5jb25zdCBsaW1pdEl0ZW1zXzEgPSByZXF1aXJlKFwiLi9saW1pdEl0ZW1zXCIpO1xuY29uc3QgdW5pcXVlSXRlbXNfMSA9IHJlcXVpcmUoXCIuL3VuaXF1ZUl0ZW1zXCIpO1xuY29uc3QgY29uc3RfMSA9IHJlcXVpcmUoXCIuL2NvbnN0XCIpO1xuY29uc3QgZW51bV8xID0gcmVxdWlyZShcIi4vZW51bVwiKTtcbmNvbnN0IHZhbGlkYXRpb24gPSBbXG4gICAgLy8gbnVtYmVyXG4gICAgbGltaXROdW1iZXJfMS5kZWZhdWx0LFxuICAgIG11bHRpcGxlT2ZfMS5kZWZhdWx0LFxuICAgIC8vIHN0cmluZ1xuICAgIGxpbWl0TGVuZ3RoXzEuZGVmYXVsdCxcbiAgICBwYXR0ZXJuXzEuZGVmYXVsdCxcbiAgICAvLyBvYmplY3RcbiAgICBsaW1pdFByb3BlcnRpZXNfMS5kZWZhdWx0LFxuICAgIHJlcXVpcmVkXzEuZGVmYXVsdCxcbiAgICAvLyBhcnJheVxuICAgIGxpbWl0SXRlbXNfMS5kZWZhdWx0LFxuICAgIHVuaXF1ZUl0ZW1zXzEuZGVmYXVsdCxcbiAgICAvLyBhbnlcbiAgICB7IGtleXdvcmQ6IFwidHlwZVwiLCBzY2hlbWFUeXBlOiBbXCJzdHJpbmdcIiwgXCJhcnJheVwiXSB9LFxuICAgIHsga2V5d29yZDogXCJudWxsYWJsZVwiLCBzY2hlbWFUeXBlOiBcImJvb2xlYW5cIiB9LFxuICAgIGNvbnN0XzEuZGVmYXVsdCxcbiAgICBlbnVtXzEuZGVmYXVsdCxcbl07XG5leHBvcnRzLmRlZmF1bHQgPSB2YWxpZGF0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlQWRkaXRpb25hbEl0ZW1zID0gdm9pZCAwO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBwYXJhbXM6IHsgbGVuIH0gfSkgPT4gKDAsIGNvZGVnZW5fMS5zdHIpIGBtdXN0IE5PVCBoYXZlIG1vcmUgdGhhbiAke2xlbn0gaXRlbXNgLFxuICAgIHBhcmFtczogKHsgcGFyYW1zOiB7IGxlbiB9IH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHtsaW1pdDogJHtsZW59fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiYWRkaXRpb25hbEl0ZW1zXCIsXG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHNjaGVtYVR5cGU6IFtcImJvb2xlYW5cIiwgXCJvYmplY3RcIl0sXG4gICAgYmVmb3JlOiBcInVuaXF1ZUl0ZW1zXCIsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBwYXJlbnRTY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGNvbnN0IHsgaXRlbXMgfSA9IHBhcmVudFNjaGVtYTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xuICAgICAgICAgICAgKDAsIHV0aWxfMS5jaGVja1N0cmljdE1vZGUpKGl0LCAnXCJhZGRpdGlvbmFsSXRlbXNcIiBpcyBpZ25vcmVkIHdoZW4gXCJpdGVtc1wiIGlzIG5vdCBhbiBhcnJheSBvZiBzY2hlbWFzJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFsaWRhdGVBZGRpdGlvbmFsSXRlbXMoY3h0LCBpdGVtcyk7XG4gICAgfSxcbn07XG5mdW5jdGlvbiB2YWxpZGF0ZUFkZGl0aW9uYWxJdGVtcyhjeHQsIGl0ZW1zKSB7XG4gICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgZGF0YSwga2V5d29yZCwgaXQgfSA9IGN4dDtcbiAgICBpdC5pdGVtcyA9IHRydWU7XG4gICAgY29uc3QgbGVuID0gZ2VuLmNvbnN0KFwibGVuXCIsICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0ubGVuZ3RoYCk7XG4gICAgaWYgKHNjaGVtYSA9PT0gZmFsc2UpIHtcbiAgICAgICAgY3h0LnNldFBhcmFtcyh7IGxlbjogaXRlbXMubGVuZ3RoIH0pO1xuICAgICAgICBjeHQucGFzcygoMCwgY29kZWdlbl8xLl8pIGAke2xlbn0gPD0gJHtpdGVtcy5sZW5ndGh9YCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIiAmJiAhKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaGVtYSkpIHtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4udmFyKFwidmFsaWRcIiwgKDAsIGNvZGVnZW5fMS5fKSBgJHtsZW59IDw9ICR7aXRlbXMubGVuZ3RofWApOyAvLyBUT0RPIHZhclxuICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5ub3QpKHZhbGlkKSwgKCkgPT4gdmFsaWRhdGVJdGVtcyh2YWxpZCkpO1xuICAgICAgICBjeHQub2sodmFsaWQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUl0ZW1zKHZhbGlkKSB7XG4gICAgICAgIGdlbi5mb3JSYW5nZShcImlcIiwgaXRlbXMubGVuZ3RoLCBsZW4sIChpKSA9PiB7XG4gICAgICAgICAgICBjeHQuc3Vic2NoZW1hKHsga2V5d29yZCwgZGF0YVByb3A6IGksIGRhdGFQcm9wVHlwZTogdXRpbF8xLlR5cGUuTnVtIH0sIHZhbGlkKTtcbiAgICAgICAgICAgIGlmICghaXQuYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLm5vdCkodmFsaWQpLCAoKSA9PiBnZW4uYnJlYWsoKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVBZGRpdGlvbmFsSXRlbXMgPSB2YWxpZGF0ZUFkZGl0aW9uYWxJdGVtcztcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkZGl0aW9uYWxJdGVtcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmFsaWRhdGVUdXBsZSA9IHZvaWQgMDtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uL2NvZGVcIik7XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJpdGVtc1wiLFxuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBzY2hlbWFUeXBlOiBbXCJvYmplY3RcIiwgXCJhcnJheVwiLCBcImJvb2xlYW5cIl0sXG4gICAgYmVmb3JlOiBcInVuaXF1ZUl0ZW1zXCIsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBzY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYSkpXG4gICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVUdXBsZShjeHQsIFwiYWRkaXRpb25hbEl0ZW1zXCIsIHNjaGVtYSk7XG4gICAgICAgIGl0Lml0ZW1zID0gdHJ1ZTtcbiAgICAgICAgaWYgKCgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2hlbWEpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjeHQub2soKDAsIGNvZGVfMS52YWxpZGF0ZUFycmF5KShjeHQpKTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIHZhbGlkYXRlVHVwbGUoY3h0LCBleHRyYUl0ZW1zLCBzY2hBcnIgPSBjeHQuc2NoZW1hKSB7XG4gICAgY29uc3QgeyBnZW4sIHBhcmVudFNjaGVtYSwgZGF0YSwga2V5d29yZCwgaXQgfSA9IGN4dDtcbiAgICBjaGVja1N0cmljdFR1cGxlKHBhcmVudFNjaGVtYSk7XG4gICAgaWYgKGl0Lm9wdHMudW5ldmFsdWF0ZWQgJiYgc2NoQXJyLmxlbmd0aCAmJiBpdC5pdGVtcyAhPT0gdHJ1ZSkge1xuICAgICAgICBpdC5pdGVtcyA9IHV0aWxfMS5tZXJnZUV2YWx1YXRlZC5pdGVtcyhnZW4sIHNjaEFyci5sZW5ndGgsIGl0Lml0ZW1zKTtcbiAgICB9XG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgIGNvbnN0IGxlbiA9IGdlbi5jb25zdChcImxlblwiLCAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9Lmxlbmd0aGApO1xuICAgIHNjaEFyci5mb3JFYWNoKChzY2gsIGkpID0+IHtcbiAgICAgICAgaWYgKCgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2gpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtsZW59ID4gJHtpfWAsICgpID0+IGN4dC5zdWJzY2hlbWEoe1xuICAgICAgICAgICAga2V5d29yZCxcbiAgICAgICAgICAgIHNjaGVtYVByb3A6IGksXG4gICAgICAgICAgICBkYXRhUHJvcDogaSxcbiAgICAgICAgfSwgdmFsaWQpKTtcbiAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBjaGVja1N0cmljdFR1cGxlKHNjaCkge1xuICAgICAgICBjb25zdCB7IG9wdHMsIGVyclNjaGVtYVBhdGggfSA9IGl0O1xuICAgICAgICBjb25zdCBsID0gc2NoQXJyLmxlbmd0aDtcbiAgICAgICAgY29uc3QgZnVsbFR1cGxlID0gbCA9PT0gc2NoLm1pbkl0ZW1zICYmIChsID09PSBzY2gubWF4SXRlbXMgfHwgc2NoW2V4dHJhSXRlbXNdID09PSBmYWxzZSk7XG4gICAgICAgIGlmIChvcHRzLnN0cmljdFR1cGxlcyAmJiAhZnVsbFR1cGxlKSB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSBgXCIke2tleXdvcmR9XCIgaXMgJHtsfS10dXBsZSwgYnV0IG1pbkl0ZW1zIG9yIG1heEl0ZW1zLyR7ZXh0cmFJdGVtc30gYXJlIG5vdCBzcGVjaWZpZWQgb3IgZGlmZmVyZW50IGF0IHBhdGggXCIke2VyclNjaGVtYVBhdGh9XCJgO1xuICAgICAgICAgICAgKDAsIHV0aWxfMS5jaGVja1N0cmljdE1vZGUpKGl0LCBtc2csIG9wdHMuc3RyaWN0VHVwbGVzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVUdXBsZSA9IHZhbGlkYXRlVHVwbGU7XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pdGVtcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGl0ZW1zXzEgPSByZXF1aXJlKFwiLi9pdGVtc1wiKTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcInByZWZpeEl0ZW1zXCIsXG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHNjaGVtYVR5cGU6IFtcImFycmF5XCJdLFxuICAgIGJlZm9yZTogXCJ1bmlxdWVJdGVtc1wiLFxuICAgIGNvZGU6IChjeHQpID0+ICgwLCBpdGVtc18xLnZhbGlkYXRlVHVwbGUpKGN4dCwgXCJpdGVtc1wiKSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcmVmaXhJdGVtcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uL2NvZGVcIik7XG5jb25zdCBhZGRpdGlvbmFsSXRlbXNfMSA9IHJlcXVpcmUoXCIuL2FkZGl0aW9uYWxJdGVtc1wiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHBhcmFtczogeyBsZW4gfSB9KSA9PiAoMCwgY29kZWdlbl8xLnN0cikgYG11c3QgTk9UIGhhdmUgbW9yZSB0aGFuICR7bGVufSBpdGVtc2AsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXM6IHsgbGVuIH0gfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge2xpbWl0OiAke2xlbn19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJpdGVtc1wiLFxuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBzY2hlbWFUeXBlOiBbXCJvYmplY3RcIiwgXCJib29sZWFuXCJdLFxuICAgIGJlZm9yZTogXCJ1bmlxdWVJdGVtc1wiLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4SXRlbXMgfSA9IHBhcmVudFNjaGVtYTtcbiAgICAgICAgaXQuaXRlbXMgPSB0cnVlO1xuICAgICAgICBpZiAoKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaGVtYSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChwcmVmaXhJdGVtcylcbiAgICAgICAgICAgICgwLCBhZGRpdGlvbmFsSXRlbXNfMS52YWxpZGF0ZUFkZGl0aW9uYWxJdGVtcykoY3h0LCBwcmVmaXhJdGVtcyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGN4dC5vaygoMCwgY29kZV8xLnZhbGlkYXRlQXJyYXkpKGN4dCkpO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXRlbXMyMDIwLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBwYXJhbXM6IHsgbWluLCBtYXggfSB9KSA9PiBtYXggPT09IHVuZGVmaW5lZFxuICAgICAgICA/ICgwLCBjb2RlZ2VuXzEuc3RyKSBgbXVzdCBjb250YWluIGF0IGxlYXN0ICR7bWlufSB2YWxpZCBpdGVtKHMpYFxuICAgICAgICA6ICgwLCBjb2RlZ2VuXzEuc3RyKSBgbXVzdCBjb250YWluIGF0IGxlYXN0ICR7bWlufSBhbmQgbm8gbW9yZSB0aGFuICR7bWF4fSB2YWxpZCBpdGVtKHMpYCxcbiAgICBwYXJhbXM6ICh7IHBhcmFtczogeyBtaW4sIG1heCB9IH0pID0+IG1heCA9PT0gdW5kZWZpbmVkID8gKDAsIGNvZGVnZW5fMS5fKSBge21pbkNvbnRhaW5zOiAke21pbn19YCA6ICgwLCBjb2RlZ2VuXzEuXykgYHttaW5Db250YWluczogJHttaW59LCBtYXhDb250YWluczogJHttYXh9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiY29udGFpbnNcIixcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgc2NoZW1hVHlwZTogW1wib2JqZWN0XCIsIFwiYm9vbGVhblwiXSxcbiAgICBiZWZvcmU6IFwidW5pcXVlSXRlbXNcIixcbiAgICB0cmFja0Vycm9yczogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGRhdGEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGxldCBtaW47XG4gICAgICAgIGxldCBtYXg7XG4gICAgICAgIGNvbnN0IHsgbWluQ29udGFpbnMsIG1heENvbnRhaW5zIH0gPSBwYXJlbnRTY2hlbWE7XG4gICAgICAgIGlmIChpdC5vcHRzLm5leHQpIHtcbiAgICAgICAgICAgIG1pbiA9IG1pbkNvbnRhaW5zID09PSB1bmRlZmluZWQgPyAxIDogbWluQ29udGFpbnM7XG4gICAgICAgICAgICBtYXggPSBtYXhDb250YWlucztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1pbiA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVuID0gZ2VuLmNvbnN0KFwibGVuXCIsICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0ubGVuZ3RoYCk7XG4gICAgICAgIGN4dC5zZXRQYXJhbXMoeyBtaW4sIG1heCB9KTtcbiAgICAgICAgaWYgKG1heCA9PT0gdW5kZWZpbmVkICYmIG1pbiA9PT0gMCkge1xuICAgICAgICAgICAgKDAsIHV0aWxfMS5jaGVja1N0cmljdE1vZGUpKGl0LCBgXCJtaW5Db250YWluc1wiID09IDAgd2l0aG91dCBcIm1heENvbnRhaW5zXCI6IFwiY29udGFpbnNcIiBrZXl3b3JkIGlnbm9yZWRgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF4ICE9PSB1bmRlZmluZWQgJiYgbWluID4gbWF4KSB7XG4gICAgICAgICAgICAoMCwgdXRpbF8xLmNoZWNrU3RyaWN0TW9kZSkoaXQsIGBcIm1pbkNvbnRhaW5zXCIgPiBcIm1heENvbnRhaW5zXCIgaXMgYWx3YXlzIGludmFsaWRgKTtcbiAgICAgICAgICAgIGN4dC5mYWlsKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2hlbWEpKSB7XG4gICAgICAgICAgICBsZXQgY29uZCA9ICgwLCBjb2RlZ2VuXzEuXykgYCR7bGVufSA+PSAke21pbn1gO1xuICAgICAgICAgICAgaWYgKG1heCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGNvbmQgPSAoMCwgY29kZWdlbl8xLl8pIGAke2NvbmR9ICYmICR7bGVufSA8PSAke21heH1gO1xuICAgICAgICAgICAgY3h0LnBhc3MoY29uZCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaXQuaXRlbXMgPSB0cnVlO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgICAgIGlmIChtYXggPT09IHVuZGVmaW5lZCAmJiBtaW4gPT09IDEpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlSXRlbXModmFsaWQsICgpID0+IGdlbi5pZih2YWxpZCwgKCkgPT4gZ2VuLmJyZWFrKCkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtaW4gPT09IDApIHtcbiAgICAgICAgICAgIGdlbi5sZXQodmFsaWQsIHRydWUpO1xuICAgICAgICAgICAgaWYgKG1heCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9Lmxlbmd0aCA+IDBgLCB2YWxpZGF0ZUl0ZW1zV2l0aENvdW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdlbi5sZXQodmFsaWQsIGZhbHNlKTtcbiAgICAgICAgICAgIHZhbGlkYXRlSXRlbXNXaXRoQ291bnQoKTtcbiAgICAgICAgfVxuICAgICAgICBjeHQucmVzdWx0KHZhbGlkLCAoKSA9PiBjeHQucmVzZXQoKSk7XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlSXRlbXNXaXRoQ291bnQoKSB7XG4gICAgICAgICAgICBjb25zdCBzY2hWYWxpZCA9IGdlbi5uYW1lKFwiX3ZhbGlkXCIpO1xuICAgICAgICAgICAgY29uc3QgY291bnQgPSBnZW4ubGV0KFwiY291bnRcIiwgMCk7XG4gICAgICAgICAgICB2YWxpZGF0ZUl0ZW1zKHNjaFZhbGlkLCAoKSA9PiBnZW4uaWYoc2NoVmFsaWQsICgpID0+IGNoZWNrTGltaXRzKGNvdW50KSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlSXRlbXMoX3ZhbGlkLCBibG9jaykge1xuICAgICAgICAgICAgZ2VuLmZvclJhbmdlKFwiaVwiLCAwLCBsZW4sIChpKSA9PiB7XG4gICAgICAgICAgICAgICAgY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICAgICAgICAgIGtleXdvcmQ6IFwiY29udGFpbnNcIixcbiAgICAgICAgICAgICAgICAgICAgZGF0YVByb3A6IGksXG4gICAgICAgICAgICAgICAgICAgIGRhdGFQcm9wVHlwZTogdXRpbF8xLlR5cGUuTnVtLFxuICAgICAgICAgICAgICAgICAgICBjb21wb3NpdGVSdWxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0sIF92YWxpZCk7XG4gICAgICAgICAgICAgICAgYmxvY2soKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrTGltaXRzKGNvdW50KSB7XG4gICAgICAgICAgICBnZW4uY29kZSgoMCwgY29kZWdlbl8xLl8pIGAke2NvdW50fSsrYCk7XG4gICAgICAgICAgICBpZiAobWF4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtjb3VudH0gPj0gJHttaW59YCwgKCkgPT4gZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSkuYnJlYWsoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtjb3VudH0gPiAke21heH1gLCAoKSA9PiBnZW4uYXNzaWduKHZhbGlkLCBmYWxzZSkuYnJlYWsoKSk7XG4gICAgICAgICAgICAgICAgaWYgKG1pbiA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtjb3VudH0gPj0gJHttaW59YCwgKCkgPT4gZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb250YWlucy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmFsaWRhdGVTY2hlbWFEZXBzID0gZXhwb3J0cy52YWxpZGF0ZVByb3BlcnR5RGVwcyA9IGV4cG9ydHMuZXJyb3IgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi9jb2RlXCIpO1xuZXhwb3J0cy5lcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBwYXJhbXM6IHsgcHJvcGVydHksIGRlcHNDb3VudCwgZGVwcyB9IH0pID0+IHtcbiAgICAgICAgY29uc3QgcHJvcGVydHlfaWVzID0gZGVwc0NvdW50ID09PSAxID8gXCJwcm9wZXJ0eVwiIDogXCJwcm9wZXJ0aWVzXCI7XG4gICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLnN0cikgYG11c3QgaGF2ZSAke3Byb3BlcnR5X2llc30gJHtkZXBzfSB3aGVuIHByb3BlcnR5ICR7cHJvcGVydHl9IGlzIHByZXNlbnRgO1xuICAgIH0sXG4gICAgcGFyYW1zOiAoeyBwYXJhbXM6IHsgcHJvcGVydHksIGRlcHNDb3VudCwgZGVwcywgbWlzc2luZ1Byb3BlcnR5IH0gfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge3Byb3BlcnR5OiAke3Byb3BlcnR5fSxcbiAgICBtaXNzaW5nUHJvcGVydHk6ICR7bWlzc2luZ1Byb3BlcnR5fSxcbiAgICBkZXBzQ291bnQ6ICR7ZGVwc0NvdW50fSxcbiAgICBkZXBzOiAke2RlcHN9fWAsIC8vIFRPRE8gY2hhbmdlIHRvIHJlZmVyZW5jZVxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImRlcGVuZGVuY2llc1wiLFxuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgc2NoZW1hVHlwZTogXCJvYmplY3RcIixcbiAgICBlcnJvcjogZXhwb3J0cy5lcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCBbcHJvcERlcHMsIHNjaERlcHNdID0gc3BsaXREZXBlbmRlbmNpZXMoY3h0KTtcbiAgICAgICAgdmFsaWRhdGVQcm9wZXJ0eURlcHMoY3h0LCBwcm9wRGVwcyk7XG4gICAgICAgIHZhbGlkYXRlU2NoZW1hRGVwcyhjeHQsIHNjaERlcHMpO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gc3BsaXREZXBlbmRlbmNpZXMoeyBzY2hlbWEgfSkge1xuICAgIGNvbnN0IHByb3BlcnR5RGVwcyA9IHt9O1xuICAgIGNvbnN0IHNjaGVtYURlcHMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gXCJfX3Byb3RvX19cIilcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBkZXBzID0gQXJyYXkuaXNBcnJheShzY2hlbWFba2V5XSkgPyBwcm9wZXJ0eURlcHMgOiBzY2hlbWFEZXBzO1xuICAgICAgICBkZXBzW2tleV0gPSBzY2hlbWFba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIFtwcm9wZXJ0eURlcHMsIHNjaGVtYURlcHNdO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0eURlcHMoY3h0LCBwcm9wZXJ0eURlcHMgPSBjeHQuc2NoZW1hKSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEsIGl0IH0gPSBjeHQ7XG4gICAgaWYgKE9iamVjdC5rZXlzKHByb3BlcnR5RGVwcykubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgbWlzc2luZyA9IGdlbi5sZXQoXCJtaXNzaW5nXCIpO1xuICAgIGZvciAoY29uc3QgcHJvcCBpbiBwcm9wZXJ0eURlcHMpIHtcbiAgICAgICAgY29uc3QgZGVwcyA9IHByb3BlcnR5RGVwc1twcm9wXTtcbiAgICAgICAgaWYgKGRlcHMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IGhhc1Byb3BlcnR5ID0gKDAsIGNvZGVfMS5wcm9wZXJ0eUluRGF0YSkoZ2VuLCBkYXRhLCBwcm9wLCBpdC5vcHRzLm93blByb3BlcnRpZXMpO1xuICAgICAgICBjeHQuc2V0UGFyYW1zKHtcbiAgICAgICAgICAgIHByb3BlcnR5OiBwcm9wLFxuICAgICAgICAgICAgZGVwc0NvdW50OiBkZXBzLmxlbmd0aCxcbiAgICAgICAgICAgIGRlcHM6IGRlcHMuam9pbihcIiwgXCIpLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGl0LmFsbEVycm9ycykge1xuICAgICAgICAgICAgZ2VuLmlmKGhhc1Byb3BlcnR5LCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBkZXBQcm9wIG9mIGRlcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIGNvZGVfMS5jaGVja1JlcG9ydE1pc3NpbmdQcm9wKShjeHQsIGRlcFByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7aGFzUHJvcGVydHl9ICYmICgkeygwLCBjb2RlXzEuY2hlY2tNaXNzaW5nUHJvcCkoY3h0LCBkZXBzLCBtaXNzaW5nKX0pYCk7XG4gICAgICAgICAgICAoMCwgY29kZV8xLnJlcG9ydE1pc3NpbmdQcm9wKShjeHQsIG1pc3NpbmcpO1xuICAgICAgICAgICAgZ2VuLmVsc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVQcm9wZXJ0eURlcHMgPSB2YWxpZGF0ZVByb3BlcnR5RGVwcztcbmZ1bmN0aW9uIHZhbGlkYXRlU2NoZW1hRGVwcyhjeHQsIHNjaGVtYURlcHMgPSBjeHQuc2NoZW1hKSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEsIGtleXdvcmQsIGl0IH0gPSBjeHQ7XG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgIGZvciAoY29uc3QgcHJvcCBpbiBzY2hlbWFEZXBzKSB7XG4gICAgICAgIGlmICgoMCwgdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKShpdCwgc2NoZW1hRGVwc1twcm9wXSkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgZ2VuLmlmKCgwLCBjb2RlXzEucHJvcGVydHlJbkRhdGEpKGdlbiwgZGF0YSwgcHJvcCwgaXQub3B0cy5vd25Qcm9wZXJ0aWVzKSwgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7IGtleXdvcmQsIHNjaGVtYVByb3A6IHByb3AgfSwgdmFsaWQpO1xuICAgICAgICAgICAgY3h0Lm1lcmdlVmFsaWRFdmFsdWF0ZWQoc2NoQ3h0LCB2YWxpZCk7XG4gICAgICAgIH0sICgpID0+IGdlbi52YXIodmFsaWQsIHRydWUpIC8vIFRPRE8gdmFyXG4gICAgICAgICk7XG4gICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZVNjaGVtYURlcHMgPSB2YWxpZGF0ZVNjaGVtYURlcHM7XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXBlbmRlbmNpZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6IFwicHJvcGVydHkgbmFtZSBtdXN0IGJlIHZhbGlkXCIsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXMgfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge3Byb3BlcnR5TmFtZTogJHtwYXJhbXMucHJvcGVydHlOYW1lfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcInByb3BlcnR5TmFtZXNcIixcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIHNjaGVtYVR5cGU6IFtcIm9iamVjdFwiLCBcImJvb2xlYW5cIl0sXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgZGF0YSwgaXQgfSA9IGN4dDtcbiAgICAgICAgaWYgKCgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2hlbWEpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgICAgIGdlbi5mb3JJbihcImtleVwiLCBkYXRhLCAoa2V5KSA9PiB7XG4gICAgICAgICAgICBjeHQuc2V0UGFyYW1zKHsgcHJvcGVydHlOYW1lOiBrZXkgfSk7XG4gICAgICAgICAgICBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgICAgICBrZXl3b3JkOiBcInByb3BlcnR5TmFtZXNcIixcbiAgICAgICAgICAgICAgICBkYXRhOiBrZXksXG4gICAgICAgICAgICAgICAgZGF0YVR5cGVzOiBbXCJzdHJpbmdcIl0sXG4gICAgICAgICAgICAgICAgcHJvcGVydHlOYW1lOiBrZXksXG4gICAgICAgICAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICAgICAgICAgIH0sIHZhbGlkKTtcbiAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLm5vdCkodmFsaWQpLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY3h0LmVycm9yKHRydWUpO1xuICAgICAgICAgICAgICAgIGlmICghaXQuYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgICAgICBnZW4uYnJlYWsoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3BlcnR5TmFtZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi4vY29kZVwiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBuYW1lc18xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvbmFtZXNcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogXCJtdXN0IE5PVCBoYXZlIGFkZGl0aW9uYWwgcHJvcGVydGllc1wiLFxuICAgIHBhcmFtczogKHsgcGFyYW1zIH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHthZGRpdGlvbmFsUHJvcGVydHk6ICR7cGFyYW1zLmFkZGl0aW9uYWxQcm9wZXJ0eX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiLFxuICAgIHR5cGU6IFtcIm9iamVjdFwiXSxcbiAgICBzY2hlbWFUeXBlOiBbXCJib29sZWFuXCIsIFwib2JqZWN0XCJdLFxuICAgIGFsbG93VW5kZWZpbmVkOiB0cnVlLFxuICAgIHRyYWNrRXJyb3JzOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgZGF0YSwgZXJyc0NvdW50LCBpdCB9ID0gY3h0O1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFlcnJzQ291bnQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIik7XG4gICAgICAgIGNvbnN0IHsgYWxsRXJyb3JzLCBvcHRzIH0gPSBpdDtcbiAgICAgICAgaXQucHJvcHMgPSB0cnVlO1xuICAgICAgICBpZiAob3B0cy5yZW1vdmVBZGRpdGlvbmFsICE9PSBcImFsbFwiICYmICgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2hlbWEpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBwcm9wcyA9ICgwLCBjb2RlXzEuYWxsU2NoZW1hUHJvcGVydGllcykocGFyZW50U2NoZW1hLnByb3BlcnRpZXMpO1xuICAgICAgICBjb25zdCBwYXRQcm9wcyA9ICgwLCBjb2RlXzEuYWxsU2NoZW1hUHJvcGVydGllcykocGFyZW50U2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzKTtcbiAgICAgICAgY2hlY2tBZGRpdGlvbmFsUHJvcGVydGllcygpO1xuICAgICAgICBjeHQub2soKDAsIGNvZGVnZW5fMS5fKSBgJHtlcnJzQ291bnR9ID09PSAke25hbWVzXzEuZGVmYXVsdC5lcnJvcnN9YCk7XG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrQWRkaXRpb25hbFByb3BlcnRpZXMoKSB7XG4gICAgICAgICAgICBnZW4uZm9ySW4oXCJrZXlcIiwgZGF0YSwgKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghcHJvcHMubGVuZ3RoICYmICFwYXRQcm9wcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0eUNvZGUoa2V5KTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGdlbi5pZihpc0FkZGl0aW9uYWwoa2V5KSwgKCkgPT4gYWRkaXRpb25hbFByb3BlcnR5Q29kZShrZXkpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzQWRkaXRpb25hbChrZXkpIHtcbiAgICAgICAgICAgIGxldCBkZWZpbmVkUHJvcDtcbiAgICAgICAgICAgIGlmIChwcm9wcy5sZW5ndGggPiA4KSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBtYXliZSBhbiBvcHRpb24gaW5zdGVhZCBvZiBoYXJkLWNvZGVkIDg/XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcHNTY2hlbWEgPSAoMCwgdXRpbF8xLnNjaGVtYVJlZk9yVmFsKShpdCwgcGFyZW50U2NoZW1hLnByb3BlcnRpZXMsIFwicHJvcGVydGllc1wiKTtcbiAgICAgICAgICAgICAgICBkZWZpbmVkUHJvcCA9ICgwLCBjb2RlXzEuaXNPd25Qcm9wZXJ0eSkoZ2VuLCBwcm9wc1NjaGVtYSwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByb3BzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGRlZmluZWRQcm9wID0gKDAsIGNvZGVnZW5fMS5vcikoLi4ucHJvcHMubWFwKChwKSA9PiAoMCwgY29kZWdlbl8xLl8pIGAke2tleX0gPT09ICR7cH1gKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVkUHJvcCA9IGNvZGVnZW5fMS5uaWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGF0UHJvcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZGVmaW5lZFByb3AgPSAoMCwgY29kZWdlbl8xLm9yKShkZWZpbmVkUHJvcCwgLi4ucGF0UHJvcHMubWFwKChwKSA9PiAoMCwgY29kZWdlbl8xLl8pIGAkeygwLCBjb2RlXzEudXNlUGF0dGVybikoY3h0LCBwKX0udGVzdCgke2tleX0pYCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEubm90KShkZWZpbmVkUHJvcCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZGVsZXRlQWRkaXRpb25hbChrZXkpIHtcbiAgICAgICAgICAgIGdlbi5jb2RlKCgwLCBjb2RlZ2VuXzEuXykgYGRlbGV0ZSAke2RhdGF9WyR7a2V5fV1gKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhZGRpdGlvbmFsUHJvcGVydHlDb2RlKGtleSkge1xuICAgICAgICAgICAgaWYgKG9wdHMucmVtb3ZlQWRkaXRpb25hbCA9PT0gXCJhbGxcIiB8fCAob3B0cy5yZW1vdmVBZGRpdGlvbmFsICYmIHNjaGVtYSA9PT0gZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlQWRkaXRpb25hbChrZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzY2hlbWEgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgY3h0LnNldFBhcmFtcyh7IGFkZGl0aW9uYWxQcm9wZXJ0eToga2V5IH0pO1xuICAgICAgICAgICAgICAgIGN4dC5lcnJvcigpO1xuICAgICAgICAgICAgICAgIGlmICghYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgICAgICBnZW4uYnJlYWsoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcIm9iamVjdFwiICYmICEoMCwgdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKShpdCwgc2NoZW1hKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICAgICAgICAgICAgICBpZiAob3B0cy5yZW1vdmVBZGRpdGlvbmFsID09PSBcImZhaWxpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBhcHBseUFkZGl0aW9uYWxTY2hlbWEoa2V5LCB2YWxpZCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5ub3QpKHZhbGlkKSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3h0LnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVBZGRpdGlvbmFsKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXBwbHlBZGRpdGlvbmFsU2NoZW1hKGtleSwgdmFsaWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWFsbEVycm9ycylcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLm5vdCkodmFsaWQpLCAoKSA9PiBnZW4uYnJlYWsoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFwcGx5QWRkaXRpb25hbFNjaGVtYShrZXksIHZhbGlkLCBlcnJvcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YnNjaGVtYSA9IHtcbiAgICAgICAgICAgICAgICBrZXl3b3JkOiBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCIsXG4gICAgICAgICAgICAgICAgZGF0YVByb3A6IGtleSxcbiAgICAgICAgICAgICAgICBkYXRhUHJvcFR5cGU6IHV0aWxfMS5UeXBlLlN0cixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoZXJyb3JzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oc3Vic2NoZW1hLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvc2l0ZVJ1bGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVycm9yczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGFsbEVycm9yczogZmFsc2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjeHQuc3Vic2NoZW1hKHN1YnNjaGVtYSwgdmFsaWQpO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRpdGlvbmFsUHJvcGVydGllcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHZhbGlkYXRlXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZVwiKTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi9jb2RlXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGFkZGl0aW9uYWxQcm9wZXJ0aWVzXzEgPSByZXF1aXJlKFwiLi9hZGRpdGlvbmFsUHJvcGVydGllc1wiKTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcInByb3BlcnRpZXNcIixcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIHNjaGVtYVR5cGU6IFwib2JqZWN0XCIsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBkYXRhLCBpdCB9ID0gY3h0O1xuICAgICAgICBpZiAoaXQub3B0cy5yZW1vdmVBZGRpdGlvbmFsID09PSBcImFsbFwiICYmIHBhcmVudFNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhZGRpdGlvbmFsUHJvcGVydGllc18xLmRlZmF1bHQuY29kZShuZXcgdmFsaWRhdGVfMS5LZXl3b3JkQ3h0KGl0LCBhZGRpdGlvbmFsUHJvcGVydGllc18xLmRlZmF1bHQsIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIikpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFsbFByb3BzID0gKDAsIGNvZGVfMS5hbGxTY2hlbWFQcm9wZXJ0aWVzKShzY2hlbWEpO1xuICAgICAgICBmb3IgKGNvbnN0IHByb3Agb2YgYWxsUHJvcHMpIHtcbiAgICAgICAgICAgIGl0LmRlZmluZWRQcm9wZXJ0aWVzLmFkZChwcm9wKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXQub3B0cy51bmV2YWx1YXRlZCAmJiBhbGxQcm9wcy5sZW5ndGggJiYgaXQucHJvcHMgIT09IHRydWUpIHtcbiAgICAgICAgICAgIGl0LnByb3BzID0gdXRpbF8xLm1lcmdlRXZhbHVhdGVkLnByb3BzKGdlbiwgKDAsIHV0aWxfMS50b0hhc2gpKGFsbFByb3BzKSwgaXQucHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBhbGxQcm9wcy5maWx0ZXIoKHApID0+ICEoMCwgdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKShpdCwgc2NoZW1hW3BdKSk7XG4gICAgICAgIGlmIChwcm9wZXJ0aWVzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgICAgICBmb3IgKGNvbnN0IHByb3Agb2YgcHJvcGVydGllcykge1xuICAgICAgICAgICAgaWYgKGhhc0RlZmF1bHQocHJvcCkpIHtcbiAgICAgICAgICAgICAgICBhcHBseVByb3BlcnR5U2NoZW1hKHByb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlXzEucHJvcGVydHlJbkRhdGEpKGdlbiwgZGF0YSwgcHJvcCwgaXQub3B0cy5vd25Qcm9wZXJ0aWVzKSk7XG4gICAgICAgICAgICAgICAgYXBwbHlQcm9wZXJ0eVNjaGVtYShwcm9wKTtcbiAgICAgICAgICAgICAgICBpZiAoIWl0LmFsbEVycm9ycylcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmVsc2UoKS52YXIodmFsaWQsIHRydWUpO1xuICAgICAgICAgICAgICAgIGdlbi5lbmRJZigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3h0Lml0LmRlZmluZWRQcm9wZXJ0aWVzLmFkZChwcm9wKTtcbiAgICAgICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaGFzRGVmYXVsdChwcm9wKSB7XG4gICAgICAgICAgICByZXR1cm4gaXQub3B0cy51c2VEZWZhdWx0cyAmJiAhaXQuY29tcG9zaXRlUnVsZSAmJiBzY2hlbWFbcHJvcF0uZGVmYXVsdCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFwcGx5UHJvcGVydHlTY2hlbWEocHJvcCkge1xuICAgICAgICAgICAgY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICAgICAga2V5d29yZDogXCJwcm9wZXJ0aWVzXCIsXG4gICAgICAgICAgICAgICAgc2NoZW1hUHJvcDogcHJvcCxcbiAgICAgICAgICAgICAgICBkYXRhUHJvcDogcHJvcCxcbiAgICAgICAgICAgIH0sIHZhbGlkKTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvcGVydGllcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi9jb2RlXCIpO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCB1dGlsXzIgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwicGF0dGVyblByb3BlcnRpZXNcIixcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIHNjaGVtYVR5cGU6IFwib2JqZWN0XCIsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgZGF0YSwgcGFyZW50U2NoZW1hLCBpdCB9ID0gY3h0O1xuICAgICAgICBjb25zdCB7IG9wdHMgfSA9IGl0O1xuICAgICAgICBjb25zdCBwYXR0ZXJucyA9ICgwLCBjb2RlXzEuYWxsU2NoZW1hUHJvcGVydGllcykoc2NoZW1hKTtcbiAgICAgICAgY29uc3QgYWx3YXlzVmFsaWRQYXR0ZXJucyA9IHBhdHRlcm5zLmZpbHRlcigocCkgPT4gKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaGVtYVtwXSkpO1xuICAgICAgICBpZiAocGF0dGVybnMubGVuZ3RoID09PSAwIHx8XG4gICAgICAgICAgICAoYWx3YXlzVmFsaWRQYXR0ZXJucy5sZW5ndGggPT09IHBhdHRlcm5zLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICghaXQub3B0cy51bmV2YWx1YXRlZCB8fCBpdC5wcm9wcyA9PT0gdHJ1ZSkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hlY2tQcm9wZXJ0aWVzID0gb3B0cy5zdHJpY3RTY2hlbWEgJiYgIW9wdHMuYWxsb3dNYXRjaGluZ1Byb3BlcnRpZXMgJiYgcGFyZW50U2NoZW1hLnByb3BlcnRpZXM7XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICAgICAgaWYgKGl0LnByb3BzICE9PSB0cnVlICYmICEoaXQucHJvcHMgaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSkpIHtcbiAgICAgICAgICAgIGl0LnByb3BzID0gKDAsIHV0aWxfMi5ldmFsdWF0ZWRQcm9wc1RvTmFtZSkoZ2VuLCBpdC5wcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gaXQ7XG4gICAgICAgIHZhbGlkYXRlUGF0dGVyblByb3BlcnRpZXMoKTtcbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVQYXR0ZXJuUHJvcGVydGllcygpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGF0IG9mIHBhdHRlcm5zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrUHJvcGVydGllcylcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tNYXRjaGluZ1Byb3BlcnRpZXMocGF0KTtcbiAgICAgICAgICAgICAgICBpZiAoaXQuYWxsRXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlUHJvcGVydGllcyhwYXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLnZhcih2YWxpZCwgdHJ1ZSk7IC8vIFRPRE8gdmFyXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlUHJvcGVydGllcyhwYXQpO1xuICAgICAgICAgICAgICAgICAgICBnZW4uaWYodmFsaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjaGVja01hdGNoaW5nUHJvcGVydGllcyhwYXQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBjaGVja1Byb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAobmV3IFJlZ0V4cChwYXQpLnRlc3QocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIHV0aWxfMS5jaGVja1N0cmljdE1vZGUpKGl0LCBgcHJvcGVydHkgJHtwcm9wfSBtYXRjaGVzIHBhdHRlcm4gJHtwYXR9ICh1c2UgYWxsb3dNYXRjaGluZ1Byb3BlcnRpZXMpYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyhwYXQpIHtcbiAgICAgICAgICAgIGdlbi5mb3JJbihcImtleVwiLCBkYXRhLCAoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7KDAsIGNvZGVfMS51c2VQYXR0ZXJuKShjeHQsIHBhdCl9LnRlc3QoJHtrZXl9KWAsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWx3YXlzVmFsaWQgPSBhbHdheXNWYWxpZFBhdHRlcm5zLmluY2x1ZGVzKHBhdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYWx3YXlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN4dC5zdWJzY2hlbWEoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleXdvcmQ6IFwicGF0dGVyblByb3BlcnRpZXNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2hlbWFQcm9wOiBwYXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVByb3A6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhUHJvcFR5cGU6IHV0aWxfMi5UeXBlLlN0cixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHZhbGlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXQub3B0cy51bmV2YWx1YXRlZCAmJiBwcm9wcyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbigoMCwgY29kZWdlbl8xLl8pIGAke3Byb3BzfVske2tleX1dYCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWFsd2F5c1ZhbGlkICYmICFpdC5hbGxFcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbiBzaG9ydC1jaXJjdWl0IGlmIGB1bmV2YWx1YXRlZFByb3BlcnRpZXNgIGlzIG5vdCBzdXBwb3J0ZWQgKG9wdHMubmV4dCA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvciBpZiBhbGwgcHJvcGVydGllcyB3ZXJlIGV2YWx1YXRlZCAocHJvcHMgPT09IHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5ub3QpKHZhbGlkKSwgKCkgPT4gZ2VuLmJyZWFrKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGF0dGVyblByb3BlcnRpZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwibm90XCIsXG4gICAgc2NoZW1hVHlwZTogW1wib2JqZWN0XCIsIFwiYm9vbGVhblwiXSxcbiAgICB0cmFja0Vycm9yczogdHJ1ZSxcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBpdCB9ID0gY3h0O1xuICAgICAgICBpZiAoKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaGVtYSkpIHtcbiAgICAgICAgICAgIGN4dC5mYWlsKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgICAgICBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgIGtleXdvcmQ6IFwibm90XCIsXG4gICAgICAgICAgICBjb21wb3NpdGVSdWxlOiB0cnVlLFxuICAgICAgICAgICAgY3JlYXRlRXJyb3JzOiBmYWxzZSxcbiAgICAgICAgICAgIGFsbEVycm9yczogZmFsc2UsXG4gICAgICAgIH0sIHZhbGlkKTtcbiAgICAgICAgY3h0LmZhaWxSZXN1bHQodmFsaWQsICgpID0+IGN4dC5yZXNldCgpLCAoKSA9PiBjeHQuZXJyb3IoKSk7XG4gICAgfSxcbiAgICBlcnJvcjogeyBtZXNzYWdlOiBcIm11c3QgTk9UIGJlIHZhbGlkXCIgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi4vY29kZVwiKTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImFueU9mXCIsXG4gICAgc2NoZW1hVHlwZTogXCJhcnJheVwiLFxuICAgIHRyYWNrRXJyb3JzOiB0cnVlLFxuICAgIGNvZGU6IGNvZGVfMS52YWxpZGF0ZVVuaW9uLFxuICAgIGVycm9yOiB7IG1lc3NhZ2U6IFwibXVzdCBtYXRjaCBhIHNjaGVtYSBpbiBhbnlPZlwiIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YW55T2YuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6IFwibXVzdCBtYXRjaCBleGFjdGx5IG9uZSBzY2hlbWEgaW4gb25lT2ZcIixcbiAgICBwYXJhbXM6ICh7IHBhcmFtcyB9KSA9PiAoMCwgY29kZWdlbl8xLl8pIGB7cGFzc2luZ1NjaGVtYXM6ICR7cGFyYW1zLnBhc3Npbmd9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwib25lT2ZcIixcbiAgICBzY2hlbWFUeXBlOiBcImFycmF5XCIsXG4gICAgdHJhY2tFcnJvcnM6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBpdCB9ID0gY3h0O1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNjaGVtYSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIik7XG4gICAgICAgIGlmIChpdC5vcHRzLmRpc2NyaW1pbmF0b3IgJiYgcGFyZW50U2NoZW1hLmRpc2NyaW1pbmF0b3IpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHNjaEFyciA9IHNjaGVtYTtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIiwgZmFsc2UpO1xuICAgICAgICBjb25zdCBwYXNzaW5nID0gZ2VuLmxldChcInBhc3NpbmdcIiwgbnVsbCk7XG4gICAgICAgIGNvbnN0IHNjaFZhbGlkID0gZ2VuLm5hbWUoXCJfdmFsaWRcIik7XG4gICAgICAgIGN4dC5zZXRQYXJhbXMoeyBwYXNzaW5nIH0pO1xuICAgICAgICAvLyBUT0RPIHBvc3NpYmx5IGZhaWwgc3RyYWlnaHQgYXdheSAod2l0aCB3YXJuaW5nIG9yIGV4Y2VwdGlvbikgaWYgdGhlcmUgYXJlIHR3byBlbXB0eSBhbHdheXMgdmFsaWQgc2NoZW1hc1xuICAgICAgICBnZW4uYmxvY2sodmFsaWRhdGVPbmVPZik7XG4gICAgICAgIGN4dC5yZXN1bHQodmFsaWQsICgpID0+IGN4dC5yZXNldCgpLCAoKSA9PiBjeHQuZXJyb3IodHJ1ZSkpO1xuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZU9uZU9mKCkge1xuICAgICAgICAgICAgc2NoQXJyLmZvckVhY2goKHNjaCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBzY2hDeHQ7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIGdlbi52YXIoc2NoVmFsaWQsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXl3b3JkOiBcIm9uZU9mXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzY2hlbWFQcm9wOiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSwgc2NoVmFsaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuXG4gICAgICAgICAgICAgICAgICAgICAgICAuaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtzY2hWYWxpZH0gJiYgJHt2YWxpZH1gKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFzc2lnbih2YWxpZCwgZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXNzaWduKHBhc3NpbmcsICgwLCBjb2RlZ2VuXzEuXykgYFske3Bhc3Npbmd9LCAke2l9XWApXG4gICAgICAgICAgICAgICAgICAgICAgICAuZWxzZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnZW4uaWYoc2NoVmFsaWQsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24ocGFzc2luZywgaSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY2hDeHQpXG4gICAgICAgICAgICAgICAgICAgICAgICBjeHQubWVyZ2VFdmFsdWF0ZWQoc2NoQ3h0LCBjb2RlZ2VuXzEuTmFtZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b25lT2YuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiYWxsT2ZcIixcbiAgICBzY2hlbWFUeXBlOiBcImFycmF5XCIsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgaXQgfSA9IGN4dDtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzY2hlbWEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgICAgIHNjaGVtYS5mb3JFYWNoKChzY2gsIGkpID0+IHtcbiAgICAgICAgICAgIGlmICgoMCwgdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKShpdCwgc2NoKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKHsga2V5d29yZDogXCJhbGxPZlwiLCBzY2hlbWFQcm9wOiBpIH0sIHZhbGlkKTtcbiAgICAgICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgICAgICAgICBjeHQubWVyZ2VFdmFsdWF0ZWQoc2NoQ3h0KTtcbiAgICAgICAgfSk7XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbGxPZi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsgcGFyYW1zIH0pID0+ICgwLCBjb2RlZ2VuXzEuc3RyKSBgbXVzdCBtYXRjaCBcIiR7cGFyYW1zLmlmQ2xhdXNlfVwiIHNjaGVtYWAsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXMgfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge2ZhaWxpbmdLZXl3b3JkOiAke3BhcmFtcy5pZkNsYXVzZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJpZlwiLFxuICAgIHNjaGVtYVR5cGU6IFtcIm9iamVjdFwiLCBcImJvb2xlYW5cIl0sXG4gICAgdHJhY2tFcnJvcnM6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHBhcmVudFNjaGVtYSwgaXQgfSA9IGN4dDtcbiAgICAgICAgaWYgKHBhcmVudFNjaGVtYS50aGVuID09PSB1bmRlZmluZWQgJiYgcGFyZW50U2NoZW1hLmVsc2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgKDAsIHV0aWxfMS5jaGVja1N0cmljdE1vZGUpKGl0LCAnXCJpZlwiIHdpdGhvdXQgXCJ0aGVuXCIgYW5kIFwiZWxzZVwiIGlzIGlnbm9yZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoYXNUaGVuID0gaGFzU2NoZW1hKGl0LCBcInRoZW5cIik7XG4gICAgICAgIGNvbnN0IGhhc0Vsc2UgPSBoYXNTY2hlbWEoaXQsIFwiZWxzZVwiKTtcbiAgICAgICAgaWYgKCFoYXNUaGVuICYmICFoYXNFbHNlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiLCB0cnVlKTtcbiAgICAgICAgY29uc3Qgc2NoVmFsaWQgPSBnZW4ubmFtZShcIl92YWxpZFwiKTtcbiAgICAgICAgdmFsaWRhdGVJZigpO1xuICAgICAgICBjeHQucmVzZXQoKTtcbiAgICAgICAgaWYgKGhhc1RoZW4gJiYgaGFzRWxzZSkge1xuICAgICAgICAgICAgY29uc3QgaWZDbGF1c2UgPSBnZW4ubGV0KFwiaWZDbGF1c2VcIik7XG4gICAgICAgICAgICBjeHQuc2V0UGFyYW1zKHsgaWZDbGF1c2UgfSk7XG4gICAgICAgICAgICBnZW4uaWYoc2NoVmFsaWQsIHZhbGlkYXRlQ2xhdXNlKFwidGhlblwiLCBpZkNsYXVzZSksIHZhbGlkYXRlQ2xhdXNlKFwiZWxzZVwiLCBpZkNsYXVzZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhhc1RoZW4pIHtcbiAgICAgICAgICAgIGdlbi5pZihzY2hWYWxpZCwgdmFsaWRhdGVDbGF1c2UoXCJ0aGVuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLm5vdCkoc2NoVmFsaWQpLCB2YWxpZGF0ZUNsYXVzZShcImVsc2VcIikpO1xuICAgICAgICB9XG4gICAgICAgIGN4dC5wYXNzKHZhbGlkLCAoKSA9PiBjeHQuZXJyb3IodHJ1ZSkpO1xuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZUlmKCkge1xuICAgICAgICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICAgICAga2V5d29yZDogXCJpZlwiLFxuICAgICAgICAgICAgICAgIGNvbXBvc2l0ZVJ1bGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY3JlYXRlRXJyb3JzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBhbGxFcnJvcnM6IGZhbHNlLFxuICAgICAgICAgICAgfSwgc2NoVmFsaWQpO1xuICAgICAgICAgICAgY3h0Lm1lcmdlRXZhbHVhdGVkKHNjaEN4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVDbGF1c2Uoa2V5d29yZCwgaWZDbGF1c2UpIHtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7IGtleXdvcmQgfSwgc2NoVmFsaWQpO1xuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIHNjaFZhbGlkKTtcbiAgICAgICAgICAgICAgICBjeHQubWVyZ2VWYWxpZEV2YWx1YXRlZChzY2hDeHQsIHZhbGlkKTtcbiAgICAgICAgICAgICAgICBpZiAoaWZDbGF1c2UpXG4gICAgICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24oaWZDbGF1c2UsICgwLCBjb2RlZ2VuXzEuXykgYCR7a2V5d29yZH1gKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGN4dC5zZXRQYXJhbXMoeyBpZkNsYXVzZToga2V5d29yZCB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmZ1bmN0aW9uIGhhc1NjaGVtYShpdCwga2V5d29yZCkge1xuICAgIGNvbnN0IHNjaGVtYSA9IGl0LnNjaGVtYVtrZXl3b3JkXTtcbiAgICByZXR1cm4gc2NoZW1hICE9PSB1bmRlZmluZWQgJiYgISgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2hlbWEpO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aWYuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFtcInRoZW5cIiwgXCJlbHNlXCJdLFxuICAgIHNjaGVtYVR5cGU6IFtcIm9iamVjdFwiLCBcImJvb2xlYW5cIl0sXG4gICAgY29kZSh7IGtleXdvcmQsIHBhcmVudFNjaGVtYSwgaXQgfSkge1xuICAgICAgICBpZiAocGFyZW50U2NoZW1hLmlmID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAoMCwgdXRpbF8xLmNoZWNrU3RyaWN0TW9kZSkoaXQsIGBcIiR7a2V5d29yZH1cIiB3aXRob3V0IFwiaWZcIiBpcyBpZ25vcmVkYCk7XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aGVuRWxzZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGFkZGl0aW9uYWxJdGVtc18xID0gcmVxdWlyZShcIi4vYWRkaXRpb25hbEl0ZW1zXCIpO1xuY29uc3QgcHJlZml4SXRlbXNfMSA9IHJlcXVpcmUoXCIuL3ByZWZpeEl0ZW1zXCIpO1xuY29uc3QgaXRlbXNfMSA9IHJlcXVpcmUoXCIuL2l0ZW1zXCIpO1xuY29uc3QgaXRlbXMyMDIwXzEgPSByZXF1aXJlKFwiLi9pdGVtczIwMjBcIik7XG5jb25zdCBjb250YWluc18xID0gcmVxdWlyZShcIi4vY29udGFpbnNcIik7XG5jb25zdCBkZXBlbmRlbmNpZXNfMSA9IHJlcXVpcmUoXCIuL2RlcGVuZGVuY2llc1wiKTtcbmNvbnN0IHByb3BlcnR5TmFtZXNfMSA9IHJlcXVpcmUoXCIuL3Byb3BlcnR5TmFtZXNcIik7XG5jb25zdCBhZGRpdGlvbmFsUHJvcGVydGllc18xID0gcmVxdWlyZShcIi4vYWRkaXRpb25hbFByb3BlcnRpZXNcIik7XG5jb25zdCBwcm9wZXJ0aWVzXzEgPSByZXF1aXJlKFwiLi9wcm9wZXJ0aWVzXCIpO1xuY29uc3QgcGF0dGVyblByb3BlcnRpZXNfMSA9IHJlcXVpcmUoXCIuL3BhdHRlcm5Qcm9wZXJ0aWVzXCIpO1xuY29uc3Qgbm90XzEgPSByZXF1aXJlKFwiLi9ub3RcIik7XG5jb25zdCBhbnlPZl8xID0gcmVxdWlyZShcIi4vYW55T2ZcIik7XG5jb25zdCBvbmVPZl8xID0gcmVxdWlyZShcIi4vb25lT2ZcIik7XG5jb25zdCBhbGxPZl8xID0gcmVxdWlyZShcIi4vYWxsT2ZcIik7XG5jb25zdCBpZl8xID0gcmVxdWlyZShcIi4vaWZcIik7XG5jb25zdCB0aGVuRWxzZV8xID0gcmVxdWlyZShcIi4vdGhlbkVsc2VcIik7XG5mdW5jdGlvbiBnZXRBcHBsaWNhdG9yKGRyYWZ0MjAyMCA9IGZhbHNlKSB7XG4gICAgY29uc3QgYXBwbGljYXRvciA9IFtcbiAgICAgICAgLy8gYW55XG4gICAgICAgIG5vdF8xLmRlZmF1bHQsXG4gICAgICAgIGFueU9mXzEuZGVmYXVsdCxcbiAgICAgICAgb25lT2ZfMS5kZWZhdWx0LFxuICAgICAgICBhbGxPZl8xLmRlZmF1bHQsXG4gICAgICAgIGlmXzEuZGVmYXVsdCxcbiAgICAgICAgdGhlbkVsc2VfMS5kZWZhdWx0LFxuICAgICAgICAvLyBvYmplY3RcbiAgICAgICAgcHJvcGVydHlOYW1lc18xLmRlZmF1bHQsXG4gICAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzXzEuZGVmYXVsdCxcbiAgICAgICAgZGVwZW5kZW5jaWVzXzEuZGVmYXVsdCxcbiAgICAgICAgcHJvcGVydGllc18xLmRlZmF1bHQsXG4gICAgICAgIHBhdHRlcm5Qcm9wZXJ0aWVzXzEuZGVmYXVsdCxcbiAgICBdO1xuICAgIC8vIGFycmF5XG4gICAgaWYgKGRyYWZ0MjAyMClcbiAgICAgICAgYXBwbGljYXRvci5wdXNoKHByZWZpeEl0ZW1zXzEuZGVmYXVsdCwgaXRlbXMyMDIwXzEuZGVmYXVsdCk7XG4gICAgZWxzZVxuICAgICAgICBhcHBsaWNhdG9yLnB1c2goYWRkaXRpb25hbEl0ZW1zXzEuZGVmYXVsdCwgaXRlbXNfMS5kZWZhdWx0KTtcbiAgICBhcHBsaWNhdG9yLnB1c2goY29udGFpbnNfMS5kZWZhdWx0KTtcbiAgICByZXR1cm4gYXBwbGljYXRvcjtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGdldEFwcGxpY2F0b3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBzY2hlbWFDb2RlIH0pID0+ICgwLCBjb2RlZ2VuXzEuc3RyKSBgbXVzdCBtYXRjaCBmb3JtYXQgXCIke3NjaGVtYUNvZGV9XCJgLFxuICAgIHBhcmFtczogKHsgc2NoZW1hQ29kZSB9KSA9PiAoMCwgY29kZWdlbl8xLl8pIGB7Zm9ybWF0OiAke3NjaGVtYUNvZGV9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiZm9ybWF0XCIsXG4gICAgdHlwZTogW1wibnVtYmVyXCIsIFwic3RyaW5nXCJdLFxuICAgIHNjaGVtYVR5cGU6IFwic3RyaW5nXCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQsIHJ1bGVUeXBlKSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCAkZGF0YSwgc2NoZW1hLCBzY2hlbWFDb2RlLCBpdCB9ID0gY3h0O1xuICAgICAgICBjb25zdCB7IG9wdHMsIGVyclNjaGVtYVBhdGgsIHNjaGVtYUVudiwgc2VsZiB9ID0gaXQ7XG4gICAgICAgIGlmICghb3B0cy52YWxpZGF0ZUZvcm1hdHMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICgkZGF0YSlcbiAgICAgICAgICAgIHZhbGlkYXRlJERhdGFGb3JtYXQoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdmFsaWRhdGVGb3JtYXQoKTtcbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGUkRGF0YUZvcm1hdCgpIHtcbiAgICAgICAgICAgIGNvbnN0IGZtdHMgPSBnZW4uc2NvcGVWYWx1ZShcImZvcm1hdHNcIiwge1xuICAgICAgICAgICAgICAgIHJlZjogc2VsZi5mb3JtYXRzLFxuICAgICAgICAgICAgICAgIGNvZGU6IG9wdHMuY29kZS5mb3JtYXRzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBmRGVmID0gZ2VuLmNvbnN0KFwiZkRlZlwiLCAoMCwgY29kZWdlbl8xLl8pIGAke2ZtdHN9WyR7c2NoZW1hQ29kZX1dYCk7XG4gICAgICAgICAgICBjb25zdCBmVHlwZSA9IGdlbi5sZXQoXCJmVHlwZVwiKTtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdCA9IGdlbi5sZXQoXCJmb3JtYXRcIik7XG4gICAgICAgICAgICAvLyBUT0RPIHNpbXBsaWZ5XG4gICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgdHlwZW9mICR7ZkRlZn0gPT0gXCJvYmplY3RcIiAmJiAhKCR7ZkRlZn0gaW5zdGFuY2VvZiBSZWdFeHApYCwgKCkgPT4gZ2VuLmFzc2lnbihmVHlwZSwgKDAsIGNvZGVnZW5fMS5fKSBgJHtmRGVmfS50eXBlIHx8IFwic3RyaW5nXCJgKS5hc3NpZ24oZm9ybWF0LCAoMCwgY29kZWdlbl8xLl8pIGAke2ZEZWZ9LnZhbGlkYXRlYCksICgpID0+IGdlbi5hc3NpZ24oZlR5cGUsICgwLCBjb2RlZ2VuXzEuXykgYFwic3RyaW5nXCJgKS5hc3NpZ24oZm9ybWF0LCBmRGVmKSk7XG4gICAgICAgICAgICBjeHQuZmFpbCRkYXRhKCgwLCBjb2RlZ2VuXzEub3IpKHVua25vd25GbXQoKSwgaW52YWxpZEZtdCgpKSk7XG4gICAgICAgICAgICBmdW5jdGlvbiB1bmtub3duRm10KCkge1xuICAgICAgICAgICAgICAgIGlmIChvcHRzLnN0cmljdFNjaGVtYSA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2RlZ2VuXzEubmlsO1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLl8pIGAke3NjaGVtYUNvZGV9ICYmICEke2Zvcm1hdH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gaW52YWxpZEZtdCgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYWxsRm9ybWF0ID0gc2NoZW1hRW52LiRhc3luY1xuICAgICAgICAgICAgICAgICAgICA/ICgwLCBjb2RlZ2VuXzEuXykgYCgke2ZEZWZ9LmFzeW5jID8gYXdhaXQgJHtmb3JtYXR9KCR7ZGF0YX0pIDogJHtmb3JtYXR9KCR7ZGF0YX0pKWBcbiAgICAgICAgICAgICAgICAgICAgOiAoMCwgY29kZWdlbl8xLl8pIGAke2Zvcm1hdH0oJHtkYXRhfSlgO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkRGF0YSA9ICgwLCBjb2RlZ2VuXzEuXykgYCh0eXBlb2YgJHtmb3JtYXR9ID09IFwiZnVuY3Rpb25cIiA/ICR7Y2FsbEZvcm1hdH0gOiAke2Zvcm1hdH0udGVzdCgke2RhdGF9KSlgO1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLl8pIGAke2Zvcm1hdH0gJiYgJHtmb3JtYXR9ICE9PSB0cnVlICYmICR7ZlR5cGV9ID09PSAke3J1bGVUeXBlfSAmJiAhJHt2YWxpZERhdGF9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdCgpIHtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdERlZiA9IHNlbGYuZm9ybWF0c1tzY2hlbWFdO1xuICAgICAgICAgICAgaWYgKCFmb3JtYXREZWYpIHtcbiAgICAgICAgICAgICAgICB1bmtub3duRm9ybWF0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvcm1hdERlZiA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBbZm10VHlwZSwgZm9ybWF0LCBmbXRSZWZdID0gZ2V0Rm9ybWF0KGZvcm1hdERlZik7XG4gICAgICAgICAgICBpZiAoZm10VHlwZSA9PT0gcnVsZVR5cGUpXG4gICAgICAgICAgICAgICAgY3h0LnBhc3ModmFsaWRDb25kaXRpb24oKSk7XG4gICAgICAgICAgICBmdW5jdGlvbiB1bmtub3duRm9ybWF0KCkge1xuICAgICAgICAgICAgICAgIGlmIChvcHRzLnN0cmljdFNjaGVtYSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5sb2dnZXIud2Fybih1bmtub3duTXNnKCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih1bmtub3duTXNnKCkpO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHVua25vd25Nc2coKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgdW5rbm93biBmb3JtYXQgXCIke3NjaGVtYX1cIiBpZ25vcmVkIGluIHNjaGVtYSBhdCBwYXRoIFwiJHtlcnJTY2hlbWFQYXRofVwiYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRGb3JtYXQoZm10RGVmKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IGZtdERlZiBpbnN0YW5jZW9mIFJlZ0V4cFxuICAgICAgICAgICAgICAgICAgICA/ICgwLCBjb2RlZ2VuXzEucmVnZXhwQ29kZSkoZm10RGVmKVxuICAgICAgICAgICAgICAgICAgICA6IG9wdHMuY29kZS5mb3JtYXRzXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICgwLCBjb2RlZ2VuXzEuXykgYCR7b3B0cy5jb2RlLmZvcm1hdHN9JHsoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KShzY2hlbWEpfWBcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZtdCA9IGdlbi5zY29wZVZhbHVlKFwiZm9ybWF0c1wiLCB7IGtleTogc2NoZW1hLCByZWY6IGZtdERlZiwgY29kZSB9KTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZtdERlZiA9PSBcIm9iamVjdFwiICYmICEoZm10RGVmIGluc3RhbmNlb2YgUmVnRXhwKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2ZtdERlZi50eXBlIHx8IFwic3RyaW5nXCIsIGZtdERlZi52YWxpZGF0ZSwgKDAsIGNvZGVnZW5fMS5fKSBgJHtmbXR9LnZhbGlkYXRlYF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbXCJzdHJpbmdcIiwgZm10RGVmLCBmbXRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gdmFsaWRDb25kaXRpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXREZWYgPT0gXCJvYmplY3RcIiAmJiAhKGZvcm1hdERlZiBpbnN0YW5jZW9mIFJlZ0V4cCkgJiYgZm9ybWF0RGVmLmFzeW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2NoZW1hRW52LiRhc3luYylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFzeW5jIGZvcm1hdCBpbiBzeW5jIHNjaGVtYVwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuXykgYGF3YWl0ICR7Zm10UmVmfSgke2RhdGF9KWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgZm9ybWF0ID09IFwiZnVuY3Rpb25cIiA/ICgwLCBjb2RlZ2VuXzEuXykgYCR7Zm10UmVmfSgke2RhdGF9KWAgOiAoMCwgY29kZWdlbl8xLl8pIGAke2ZtdFJlZn0udGVzdCgke2RhdGF9KWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvcm1hdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGZvcm1hdF8xID0gcmVxdWlyZShcIi4vZm9ybWF0XCIpO1xuY29uc3QgZm9ybWF0ID0gW2Zvcm1hdF8xLmRlZmF1bHRdO1xuZXhwb3J0cy5kZWZhdWx0ID0gZm9ybWF0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNvbnRlbnRWb2NhYnVsYXJ5ID0gZXhwb3J0cy5tZXRhZGF0YVZvY2FidWxhcnkgPSB2b2lkIDA7XG5leHBvcnRzLm1ldGFkYXRhVm9jYWJ1bGFyeSA9IFtcbiAgICBcInRpdGxlXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiLFxuICAgIFwiZGVmYXVsdFwiLFxuICAgIFwiZGVwcmVjYXRlZFwiLFxuICAgIFwicmVhZE9ubHlcIixcbiAgICBcIndyaXRlT25seVwiLFxuICAgIFwiZXhhbXBsZXNcIixcbl07XG5leHBvcnRzLmNvbnRlbnRWb2NhYnVsYXJ5ID0gW1xuICAgIFwiY29udGVudE1lZGlhVHlwZVwiLFxuICAgIFwiY29udGVudEVuY29kaW5nXCIsXG4gICAgXCJjb250ZW50U2NoZW1hXCIsXG5dO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWV0YWRhdGEuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb3JlXzEgPSByZXF1aXJlKFwiLi9jb3JlXCIpO1xuY29uc3QgdmFsaWRhdGlvbl8xID0gcmVxdWlyZShcIi4vdmFsaWRhdGlvblwiKTtcbmNvbnN0IGFwcGxpY2F0b3JfMSA9IHJlcXVpcmUoXCIuL2FwcGxpY2F0b3JcIik7XG5jb25zdCBmb3JtYXRfMSA9IHJlcXVpcmUoXCIuL2Zvcm1hdFwiKTtcbmNvbnN0IG1ldGFkYXRhXzEgPSByZXF1aXJlKFwiLi9tZXRhZGF0YVwiKTtcbmNvbnN0IGRyYWZ0N1ZvY2FidWxhcmllcyA9IFtcbiAgICBjb3JlXzEuZGVmYXVsdCxcbiAgICB2YWxpZGF0aW9uXzEuZGVmYXVsdCxcbiAgICAoMCwgYXBwbGljYXRvcl8xLmRlZmF1bHQpKCksXG4gICAgZm9ybWF0XzEuZGVmYXVsdCxcbiAgICBtZXRhZGF0YV8xLm1ldGFkYXRhVm9jYWJ1bGFyeSxcbiAgICBtZXRhZGF0YV8xLmNvbnRlbnRWb2NhYnVsYXJ5LFxuXTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRyYWZ0N1ZvY2FidWxhcmllcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRyYWZ0Ny5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRGlzY3JFcnJvciA9IHZvaWQgMDtcbnZhciBEaXNjckVycm9yO1xuKGZ1bmN0aW9uIChEaXNjckVycm9yKSB7XG4gICAgRGlzY3JFcnJvcltcIlRhZ1wiXSA9IFwidGFnXCI7XG4gICAgRGlzY3JFcnJvcltcIk1hcHBpbmdcIl0gPSBcIm1hcHBpbmdcIjtcbn0pKERpc2NyRXJyb3IgfHwgKGV4cG9ydHMuRGlzY3JFcnJvciA9IERpc2NyRXJyb3IgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCIuLi9kaXNjcmltaW5hdG9yL3R5cGVzXCIpO1xuY29uc3QgY29tcGlsZV8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGVcIik7XG5jb25zdCByZWZfZXJyb3JfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3JlZl9lcnJvclwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBwYXJhbXM6IHsgZGlzY3JFcnJvciwgdGFnTmFtZSB9IH0pID0+IGRpc2NyRXJyb3IgPT09IHR5cGVzXzEuRGlzY3JFcnJvci5UYWdcbiAgICAgICAgPyBgdGFnIFwiJHt0YWdOYW1lfVwiIG11c3QgYmUgc3RyaW5nYFxuICAgICAgICA6IGB2YWx1ZSBvZiB0YWcgXCIke3RhZ05hbWV9XCIgbXVzdCBiZSBpbiBvbmVPZmAsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXM6IHsgZGlzY3JFcnJvciwgdGFnLCB0YWdOYW1lIH0gfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge2Vycm9yOiAke2Rpc2NyRXJyb3J9LCB0YWc6ICR7dGFnTmFtZX0sIHRhZ1ZhbHVlOiAke3RhZ319YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJkaXNjcmltaW5hdG9yXCIsXG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICBzY2hlbWFUeXBlOiBcIm9iamVjdFwiLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgaXQgfSA9IGN4dDtcbiAgICAgICAgY29uc3QgeyBvbmVPZiB9ID0gcGFyZW50U2NoZW1hO1xuICAgICAgICBpZiAoIWl0Lm9wdHMuZGlzY3JpbWluYXRvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGlzY3JpbWluYXRvcjogcmVxdWlyZXMgZGlzY3JpbWluYXRvciBvcHRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFnTmFtZSA9IHNjaGVtYS5wcm9wZXJ0eU5hbWU7XG4gICAgICAgIGlmICh0eXBlb2YgdGFnTmFtZSAhPSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGlzY3JpbWluYXRvcjogcmVxdWlyZXMgcHJvcGVydHlOYW1lXCIpO1xuICAgICAgICBpZiAoc2NoZW1hLm1hcHBpbmcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkaXNjcmltaW5hdG9yOiBtYXBwaW5nIGlzIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgICAgIGlmICghb25lT2YpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkaXNjcmltaW5hdG9yOiByZXF1aXJlcyBvbmVPZiBrZXl3b3JkXCIpO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiLCBmYWxzZSk7XG4gICAgICAgIGNvbnN0IHRhZyA9IGdlbi5jb25zdChcInRhZ1wiLCAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9JHsoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KSh0YWdOYW1lKX1gKTtcbiAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYHR5cGVvZiAke3RhZ30gPT0gXCJzdHJpbmdcImAsICgpID0+IHZhbGlkYXRlTWFwcGluZygpLCAoKSA9PiBjeHQuZXJyb3IoZmFsc2UsIHsgZGlzY3JFcnJvcjogdHlwZXNfMS5EaXNjckVycm9yLlRhZywgdGFnLCB0YWdOYW1lIH0pKTtcbiAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVNYXBwaW5nKCkge1xuICAgICAgICAgICAgY29uc3QgbWFwcGluZyA9IGdldE1hcHBpbmcoKTtcbiAgICAgICAgICAgIGdlbi5pZihmYWxzZSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRhZ1ZhbHVlIGluIG1hcHBpbmcpIHtcbiAgICAgICAgICAgICAgICBnZW4uZWxzZUlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7dGFnfSA9PT0gJHt0YWdWYWx1ZX1gKTtcbiAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCBhcHBseVRhZ1NjaGVtYShtYXBwaW5nW3RhZ1ZhbHVlXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2VuLmVsc2UoKTtcbiAgICAgICAgICAgIGN4dC5lcnJvcihmYWxzZSwgeyBkaXNjckVycm9yOiB0eXBlc18xLkRpc2NyRXJyb3IuTWFwcGluZywgdGFnLCB0YWdOYW1lIH0pO1xuICAgICAgICAgICAgZ2VuLmVuZElmKCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYXBwbHlUYWdTY2hlbWEoc2NoZW1hUHJvcCkge1xuICAgICAgICAgICAgY29uc3QgX3ZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICAgICAgICAgIGNvbnN0IHNjaEN4dCA9IGN4dC5zdWJzY2hlbWEoeyBrZXl3b3JkOiBcIm9uZU9mXCIsIHNjaGVtYVByb3AgfSwgX3ZhbGlkKTtcbiAgICAgICAgICAgIGN4dC5tZXJnZUV2YWx1YXRlZChzY2hDeHQsIGNvZGVnZW5fMS5OYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBfdmFsaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0TWFwcGluZygpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IG9uZU9mTWFwcGluZyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgdG9wUmVxdWlyZWQgPSBoYXNSZXF1aXJlZChwYXJlbnRTY2hlbWEpO1xuICAgICAgICAgICAgbGV0IHRhZ1JlcXVpcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb25lT2YubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgc2NoID0gb25lT2ZbaV07XG4gICAgICAgICAgICAgICAgaWYgKChzY2ggPT09IG51bGwgfHwgc2NoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY2guJHJlZikgJiYgISgwLCB1dGlsXzEuc2NoZW1hSGFzUnVsZXNCdXRSZWYpKHNjaCwgaXQuc2VsZi5SVUxFUykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVmID0gc2NoLiRyZWY7XG4gICAgICAgICAgICAgICAgICAgIHNjaCA9IGNvbXBpbGVfMS5yZXNvbHZlUmVmLmNhbGwoaXQuc2VsZiwgaXQuc2NoZW1hRW52LnJvb3QsIGl0LmJhc2VJZCwgcmVmKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjaCBpbnN0YW5jZW9mIGNvbXBpbGVfMS5TY2hlbWFFbnYpXG4gICAgICAgICAgICAgICAgICAgICAgICBzY2ggPSBzY2guc2NoZW1hO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2NoID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgcmVmX2Vycm9yXzEuZGVmYXVsdChpdC5vcHRzLnVyaVJlc29sdmVyLCBpdC5iYXNlSWQsIHJlZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BTY2ggPSAoX2EgPSBzY2ggPT09IG51bGwgfHwgc2NoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY2gucHJvcGVydGllcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW3RhZ05hbWVdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcFNjaCAhPSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZGlzY3JpbWluYXRvcjogb25lT2Ygc3Vic2NoZW1hcyAob3IgcmVmZXJlbmNlZCBzY2hlbWFzKSBtdXN0IGhhdmUgXCJwcm9wZXJ0aWVzLyR7dGFnTmFtZX1cImApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0YWdSZXF1aXJlZCA9IHRhZ1JlcXVpcmVkICYmICh0b3BSZXF1aXJlZCB8fCBoYXNSZXF1aXJlZChzY2gpKTtcbiAgICAgICAgICAgICAgICBhZGRNYXBwaW5ncyhwcm9wU2NoLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGFnUmVxdWlyZWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkaXNjcmltaW5hdG9yOiBcIiR7dGFnTmFtZX1cIiBtdXN0IGJlIHJlcXVpcmVkYCk7XG4gICAgICAgICAgICByZXR1cm4gb25lT2ZNYXBwaW5nO1xuICAgICAgICAgICAgZnVuY3Rpb24gaGFzUmVxdWlyZWQoeyByZXF1aXJlZCB9KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkocmVxdWlyZWQpICYmIHJlcXVpcmVkLmluY2x1ZGVzKHRhZ05hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gYWRkTWFwcGluZ3Moc2NoLCBpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNjaC5jb25zdCkge1xuICAgICAgICAgICAgICAgICAgICBhZGRNYXBwaW5nKHNjaC5jb25zdCwgaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNjaC5lbnVtKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdGFnVmFsdWUgb2Ygc2NoLmVudW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZE1hcHBpbmcodGFnVmFsdWUsIGkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRpc2NyaW1pbmF0b3I6IFwicHJvcGVydGllcy8ke3RhZ05hbWV9XCIgbXVzdCBoYXZlIFwiY29uc3RcIiBvciBcImVudW1cImApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGFkZE1hcHBpbmcodGFnVmFsdWUsIGkpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRhZ1ZhbHVlICE9IFwic3RyaW5nXCIgfHwgdGFnVmFsdWUgaW4gb25lT2ZNYXBwaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZGlzY3JpbWluYXRvcjogXCIke3RhZ05hbWV9XCIgdmFsdWVzIG11c3QgYmUgdW5pcXVlIHN0cmluZ3NgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb25lT2ZNYXBwaW5nW3RhZ1ZhbHVlXSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIntcbiAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNy9zY2hlbWEjXCIsXG4gIFwiJGlkXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNy9zY2hlbWEjXCIsXG4gIFwidGl0bGVcIjogXCJDb3JlIHNjaGVtYSBtZXRhLXNjaGVtYVwiLFxuICBcImRlZmluaXRpb25zXCI6IHtcbiAgICBcInNjaGVtYUFycmF5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcIm1pbkl0ZW1zXCI6IDEsXG4gICAgICBcIml0ZW1zXCI6IHtcIiRyZWZcIjogXCIjXCJ9XG4gICAgfSxcbiAgICBcIm5vbk5lZ2F0aXZlSW50ZWdlclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCIsXG4gICAgICBcIm1pbmltdW1cIjogMFxuICAgIH0sXG4gICAgXCJub25OZWdhdGl2ZUludGVnZXJEZWZhdWx0MFwiOiB7XG4gICAgICBcImFsbE9mXCI6IFt7XCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9ub25OZWdhdGl2ZUludGVnZXJcIn0sIHtcImRlZmF1bHRcIjogMH1dXG4gICAgfSxcbiAgICBcInNpbXBsZVR5cGVzXCI6IHtcbiAgICAgIFwiZW51bVwiOiBbXCJhcnJheVwiLCBcImJvb2xlYW5cIiwgXCJpbnRlZ2VyXCIsIFwibnVsbFwiLCBcIm51bWJlclwiLCBcIm9iamVjdFwiLCBcInN0cmluZ1wiXVxuICAgIH0sXG4gICAgXCJzdHJpbmdBcnJheVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgXCJpdGVtc1wiOiB7XCJ0eXBlXCI6IFwic3RyaW5nXCJ9LFxuICAgICAgXCJ1bmlxdWVJdGVtc1wiOiB0cnVlLFxuICAgICAgXCJkZWZhdWx0XCI6IFtdXG4gICAgfVxuICB9LFxuICBcInR5cGVcIjogW1wib2JqZWN0XCIsIFwiYm9vbGVhblwiXSxcbiAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICBcIiRpZFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZm9ybWF0XCI6IFwidXJpLXJlZmVyZW5jZVwiXG4gICAgfSxcbiAgICBcIiRzY2hlbWFcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImZvcm1hdFwiOiBcInVyaVwiXG4gICAgfSxcbiAgICBcIiRyZWZcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImZvcm1hdFwiOiBcInVyaS1yZWZlcmVuY2VcIlxuICAgIH0sXG4gICAgXCIkY29tbWVudFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgIH0sXG4gICAgXCJ0aXRsZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgIH0sXG4gICAgXCJkZXNjcmlwdGlvblwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgIH0sXG4gICAgXCJkZWZhdWx0XCI6IHRydWUsXG4gICAgXCJyZWFkT25seVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICBcImRlZmF1bHRcIjogZmFsc2VcbiAgICB9LFxuICAgIFwiZXhhbXBsZXNcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwiaXRlbXNcIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJtdWx0aXBsZU9mXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJleGNsdXNpdmVNaW5pbXVtXCI6IDBcbiAgICB9LFxuICAgIFwibWF4aW11bVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIlxuICAgIH0sXG4gICAgXCJleGNsdXNpdmVNYXhpbXVtXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiXG4gICAgfSxcbiAgICBcIm1pbmltdW1cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCJcbiAgICB9LFxuICAgIFwiZXhjbHVzaXZlTWluaW11bVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIlxuICAgIH0sXG4gICAgXCJtYXhMZW5ndGhcIjoge1wiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvbm9uTmVnYXRpdmVJbnRlZ2VyXCJ9LFxuICAgIFwibWluTGVuZ3RoXCI6IHtcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL25vbk5lZ2F0aXZlSW50ZWdlckRlZmF1bHQwXCJ9LFxuICAgIFwicGF0dGVyblwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZm9ybWF0XCI6IFwicmVnZXhcIlxuICAgIH0sXG4gICAgXCJhZGRpdGlvbmFsSXRlbXNcIjoge1wiJHJlZlwiOiBcIiNcIn0sXG4gICAgXCJpdGVtc1wiOiB7XG4gICAgICBcImFueU9mXCI6IFt7XCIkcmVmXCI6IFwiI1wifSwge1wiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvc2NoZW1hQXJyYXlcIn1dLFxuICAgICAgXCJkZWZhdWx0XCI6IHRydWVcbiAgICB9LFxuICAgIFwibWF4SXRlbXNcIjoge1wiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvbm9uTmVnYXRpdmVJbnRlZ2VyXCJ9LFxuICAgIFwibWluSXRlbXNcIjoge1wiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvbm9uTmVnYXRpdmVJbnRlZ2VyRGVmYXVsdDBcIn0sXG4gICAgXCJ1bmlxdWVJdGVtc1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICBcImRlZmF1bHRcIjogZmFsc2VcbiAgICB9LFxuICAgIFwiY29udGFpbnNcIjoge1wiJHJlZlwiOiBcIiNcIn0sXG4gICAgXCJtYXhQcm9wZXJ0aWVzXCI6IHtcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL25vbk5lZ2F0aXZlSW50ZWdlclwifSxcbiAgICBcIm1pblByb3BlcnRpZXNcIjoge1wiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvbm9uTmVnYXRpdmVJbnRlZ2VyRGVmYXVsdDBcIn0sXG4gICAgXCJyZXF1aXJlZFwiOiB7XCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9zdHJpbmdBcnJheVwifSxcbiAgICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IHtcIiRyZWZcIjogXCIjXCJ9LFxuICAgIFwiZGVmaW5pdGlvbnNcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gICAgICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IHtcIiRyZWZcIjogXCIjXCJ9LFxuICAgICAgXCJkZWZhdWx0XCI6IHt9XG4gICAgfSxcbiAgICBcInByb3BlcnRpZXNcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gICAgICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IHtcIiRyZWZcIjogXCIjXCJ9LFxuICAgICAgXCJkZWZhdWx0XCI6IHt9XG4gICAgfSxcbiAgICBcInBhdHRlcm5Qcm9wZXJ0aWVzXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICAgICAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiB7XCIkcmVmXCI6IFwiI1wifSxcbiAgICAgIFwicHJvcGVydHlOYW1lc1wiOiB7XCJmb3JtYXRcIjogXCJyZWdleFwifSxcbiAgICAgIFwiZGVmYXVsdFwiOiB7fVxuICAgIH0sXG4gICAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gICAgICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IHtcbiAgICAgICAgXCJhbnlPZlwiOiBbe1wiJHJlZlwiOiBcIiNcIn0sIHtcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL3N0cmluZ0FycmF5XCJ9XVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eU5hbWVzXCI6IHtcIiRyZWZcIjogXCIjXCJ9LFxuICAgIFwiY29uc3RcIjogdHJ1ZSxcbiAgICBcImVudW1cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwiaXRlbXNcIjogdHJ1ZSxcbiAgICAgIFwibWluSXRlbXNcIjogMSxcbiAgICAgIFwidW5pcXVlSXRlbXNcIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJ0eXBlXCI6IHtcbiAgICAgIFwiYW55T2ZcIjogW1xuICAgICAgICB7XCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9zaW1wbGVUeXBlc1wifSxcbiAgICAgICAge1xuICAgICAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICAgICAgXCJpdGVtc1wiOiB7XCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9zaW1wbGVUeXBlc1wifSxcbiAgICAgICAgICBcIm1pbkl0ZW1zXCI6IDEsXG4gICAgICAgICAgXCJ1bmlxdWVJdGVtc1wiOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9LFxuICAgIFwiZm9ybWF0XCI6IHtcInR5cGVcIjogXCJzdHJpbmdcIn0sXG4gICAgXCJjb250ZW50TWVkaWFUeXBlXCI6IHtcInR5cGVcIjogXCJzdHJpbmdcIn0sXG4gICAgXCJjb250ZW50RW5jb2RpbmdcIjoge1widHlwZVwiOiBcInN0cmluZ1wifSxcbiAgICBcImlmXCI6IHtcIiRyZWZcIjogXCIjXCJ9LFxuICAgIFwidGhlblwiOiB7XCIkcmVmXCI6IFwiI1wifSxcbiAgICBcImVsc2VcIjoge1wiJHJlZlwiOiBcIiNcIn0sXG4gICAgXCJhbGxPZlwiOiB7XCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9zY2hlbWFBcnJheVwifSxcbiAgICBcImFueU9mXCI6IHtcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL3NjaGVtYUFycmF5XCJ9LFxuICAgIFwib25lT2ZcIjoge1wiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvc2NoZW1hQXJyYXlcIn0sXG4gICAgXCJub3RcIjoge1wiJHJlZlwiOiBcIiNcIn1cbiAgfSxcbiAgXCJkZWZhdWx0XCI6IHRydWVcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NaXNzaW5nUmVmRXJyb3IgPSBleHBvcnRzLlZhbGlkYXRpb25FcnJvciA9IGV4cG9ydHMuQ29kZUdlbiA9IGV4cG9ydHMuTmFtZSA9IGV4cG9ydHMubmlsID0gZXhwb3J0cy5zdHJpbmdpZnkgPSBleHBvcnRzLnN0ciA9IGV4cG9ydHMuXyA9IGV4cG9ydHMuS2V5d29yZEN4dCA9IGV4cG9ydHMuQWp2ID0gdm9pZCAwO1xuY29uc3QgY29yZV8xID0gcmVxdWlyZShcIi4vY29yZVwiKTtcbmNvbnN0IGRyYWZ0N18xID0gcmVxdWlyZShcIi4vdm9jYWJ1bGFyaWVzL2RyYWZ0N1wiKTtcbmNvbnN0IGRpc2NyaW1pbmF0b3JfMSA9IHJlcXVpcmUoXCIuL3ZvY2FidWxhcmllcy9kaXNjcmltaW5hdG9yXCIpO1xuY29uc3QgZHJhZnQ3TWV0YVNjaGVtYSA9IHJlcXVpcmUoXCIuL3JlZnMvanNvbi1zY2hlbWEtZHJhZnQtMDcuanNvblwiKTtcbmNvbnN0IE1FVEFfU1VQUE9SVF9EQVRBID0gW1wiL3Byb3BlcnRpZXNcIl07XG5jb25zdCBNRVRBX1NDSEVNQV9JRCA9IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNy9zY2hlbWFcIjtcbmNsYXNzIEFqdiBleHRlbmRzIGNvcmVfMS5kZWZhdWx0IHtcbiAgICBfYWRkVm9jYWJ1bGFyaWVzKCkge1xuICAgICAgICBzdXBlci5fYWRkVm9jYWJ1bGFyaWVzKCk7XG4gICAgICAgIGRyYWZ0N18xLmRlZmF1bHQuZm9yRWFjaCgodikgPT4gdGhpcy5hZGRWb2NhYnVsYXJ5KHYpKTtcbiAgICAgICAgaWYgKHRoaXMub3B0cy5kaXNjcmltaW5hdG9yKVxuICAgICAgICAgICAgdGhpcy5hZGRLZXl3b3JkKGRpc2NyaW1pbmF0b3JfMS5kZWZhdWx0KTtcbiAgICB9XG4gICAgX2FkZERlZmF1bHRNZXRhU2NoZW1hKCkge1xuICAgICAgICBzdXBlci5fYWRkRGVmYXVsdE1ldGFTY2hlbWEoKTtcbiAgICAgICAgaWYgKCF0aGlzLm9wdHMubWV0YSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgbWV0YVNjaGVtYSA9IHRoaXMub3B0cy4kZGF0YVxuICAgICAgICAgICAgPyB0aGlzLiRkYXRhTWV0YVNjaGVtYShkcmFmdDdNZXRhU2NoZW1hLCBNRVRBX1NVUFBPUlRfREFUQSlcbiAgICAgICAgICAgIDogZHJhZnQ3TWV0YVNjaGVtYTtcbiAgICAgICAgdGhpcy5hZGRNZXRhU2NoZW1hKG1ldGFTY2hlbWEsIE1FVEFfU0NIRU1BX0lELCBmYWxzZSk7XG4gICAgICAgIHRoaXMucmVmc1tcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvc2NoZW1hXCJdID0gTUVUQV9TQ0hFTUFfSUQ7XG4gICAgfVxuICAgIGRlZmF1bHRNZXRhKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMub3B0cy5kZWZhdWx0TWV0YSA9XG4gICAgICAgICAgICBzdXBlci5kZWZhdWx0TWV0YSgpIHx8ICh0aGlzLmdldFNjaGVtYShNRVRBX1NDSEVNQV9JRCkgPyBNRVRBX1NDSEVNQV9JRCA6IHVuZGVmaW5lZCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuQWp2ID0gQWp2O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gQWp2O1xubW9kdWxlLmV4cG9ydHMuQWp2ID0gQWp2O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gQWp2O1xudmFyIHZhbGlkYXRlXzEgPSByZXF1aXJlKFwiLi9jb21waWxlL3ZhbGlkYXRlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiS2V5d29yZEN4dFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsaWRhdGVfMS5LZXl3b3JkQ3h0OyB9IH0pO1xudmFyIGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvY29kZWdlblwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVnZW5fMS5fOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuc3RyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyaW5naWZ5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuc3RyaW5naWZ5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibmlsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEubmlsOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTmFtZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLk5hbWU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb2RlR2VuXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuQ29kZUdlbjsgfSB9KTtcbnZhciB2YWxpZGF0aW9uX2Vycm9yXzEgPSByZXF1aXJlKFwiLi9ydW50aW1lL3ZhbGlkYXRpb25fZXJyb3JcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJWYWxpZGF0aW9uRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbGlkYXRpb25fZXJyb3JfMS5kZWZhdWx0OyB9IH0pO1xudmFyIHJlZl9lcnJvcl8xID0gcmVxdWlyZShcIi4vY29tcGlsZS9yZWZfZXJyb3JcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNaXNzaW5nUmVmRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlZl9lcnJvcl8xLmRlZmF1bHQ7IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hanYuanMubWFwIiwidHlwZSBIYXNoID0gc3RyaW5nICYge2xlbmd0aDogMzJ9XG5cbmNvbnN0IEZOVl9PRkZTRVRfMSA9IDB4Y2JmMjljZTQ4NDIyMjMyNW47XG5jb25zdCBGTlZfT0ZGU0VUXzIgPSAweDg0MjIyMzI1Y2JmMjljZTRuO1xuY29uc3QgRk5WX1BSSU1FID0gMHgxMDAwMDAwMDFiM247XG5jb25zdCBNQVNLXzY0ID0gKDFuIDw8IDY0bikgLSAxbjtcblxuY29uc3QgaGFzaDY0ID0gKHZhbHVlOiBzdHJpbmcsIG9mZnNldDogYmlnaW50KTogYmlnaW50ID0+IHtcbiAgbGV0IGhhc2ggPSBvZmZzZXQ7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBoYXNoIF49IEJpZ0ludCh2YWx1ZS5jaGFyQ29kZUF0KGkpKTtcbiAgICBoYXNoID0gKGhhc2ggKiBGTlZfUFJJTUUpICYgTUFTS182NDtcbiAgfVxuICByZXR1cm4gaGFzaDtcbn07XG5cbmNvbnN0IHRvSGV4NjQgPSAodmFsdWU6IGJpZ2ludCkgPT4gdmFsdWUudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDE2LCBcIjBcIik7XG5cbmV4cG9ydCBjb25zdCBoYXNoMTI4ID0gKC4uLmRhdGE6YW55KTogSGFzaCA9PiB7XG4gIGNvbnN0IGlucHV0ID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gIGNvbnN0IGhpZ2ggPSBoYXNoNjQoaW5wdXQsIEZOVl9PRkZTRVRfMSk7XG4gIGNvbnN0IGxvdyA9IGhhc2g2NChpbnB1dCwgRk5WX09GRlNFVF8yKTtcbiAgcmV0dXJuIGAke3RvSGV4NjQoaGlnaCl9JHt0b0hleDY0KGxvdyl9YCBhcyBIYXNoO1xufTtcblxuXG5cbiIsImltcG9ydCBBanYgZnJvbSBcImFqdlwiXG5cbmltcG9ydCB7IGhhc2gxMjggfSBmcm9tIFwiLi9oYXNoXCJcblxuXG5jb25zdCBzdHJpbmcgPSB7dHlwZSA6IFwic3RyaW5nXCJ9XG5jb25zdCBudW1iZXIgPSB7dHlwZSA6IFwibnVtYmVyXCJ9XG5cbmV4cG9ydCB0eXBlIFNjaGVtYSA9IEpzb25hYmxlXG5jb25zdCBvYmplY3QgPSAocHJvcGVydGllczogUmVjb3JkPHN0cmluZywgYW55PiwgZXh0cmE6IGFueSA9IHt9KSA9PiAoe1xuICB0eXBlOiBcIm9iamVjdFwiLFxuICBwcm9wZXJ0aWVzLFxuICByZXF1aXJlZDogT2JqZWN0LmtleXMocHJvcGVydGllcyksXG4gIC4uLmV4dHJhLFxufSlcblxuY29uc3QgYXJyYXlUID0gKGl0ZW1zIDogU2NoZW1hKSA9PiAoe1xuICB0eXBlOlwiYXJyYXlcIixcbiAgaXRlbXNcbn0pXG5cbmV4cG9ydCB0eXBlIEpzb25hYmxlID0gc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IEpzb25hYmxlW10gfCB7W2tleTogc3RyaW5nXTogSnNvbmFibGV9XG5leHBvcnQgY29uc3QgdG9qc29uID0gKHg6IEpzb25hYmxlKT0+SlNPTi5zdHJpbmdpZnkoeCwgbnVsbCwgMilcbmV4cG9ydCBjb25zdCBmcm9tanNvbiA9ICh4OnN0cmluZyk6IEpzb25hYmxlID0+IEpTT04ucGFyc2UoeClcblxuZXhwb3J0IGNvbnN0IHZhbGlkYXRlID0gKGRhdGE6IEpzb25hYmxlLCBzY2hlbWE6IEpzb25hYmxlKSA9PiB7XG4gIGNvbnN0IHZhbGlkYXRlID0gbmV3IEFqdigpLmNvbXBpbGUoc2NoZW1hIGFzIGFueSk7XG4gIGlmICh2YWxpZGF0ZShkYXRhKSkgcmV0dXJuIHRydWU7XG4gIGVsc2UgdGhyb3cgbmV3IEVycm9yKHZhbGlkYXRlLmVycm9ycz8ubWFwKChlOiBhbnkpID0+IGUubWVzc2FnZSkuam9pbihcIiwgXCIpIHx8IFwiSW52YWxpZCBkYXRhXCIpO1xufVxuXG5leHBvcnQgdHlwZSBIYXNoID0gc3RyaW5nICYgeyBsZW5ndGg6IDMyIH1cbmV4cG9ydCB0eXBlIE5vdGUgPSB7IGRhdGE6IHN0cmluZywgaGFzaDogSGFzaCwgc2NoZW1hSGFzaDogSGFzaCB9XG5leHBvcnQgdHlwZSBOb3RlRGF0YSA9IHsgc2NoZW1hSGFzaDogSGFzaCwgZGF0YTogSnNvbmFibGUgfVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNoRGF0YSh7c2NoZW1hSGFzaCwgZGF0YX0gOiBOb3RlRGF0YSl7XG4gIGlmIChzY2hlbWFIYXNoID09PSBcIjBcIiAmJiB0b2pzb24oZGF0YSkgIT0gXCJ7fVwiKSB0aHJvdyBuZXcgRXJyb3IoXCJzY2hlbWEgaGFzaCBpcyAwIGJ1dCBkYXRhIGlzIG5vdCBlbXB0eSA6XCIgKyB0b2pzb24oZGF0YSkpXG4gIHJldHVybiBoYXNoMTI4KHNjaGVtYUhhc2gsIGRhdGEpIFxufVxuXG5leHBvcnQgZnVuY3Rpb24gTm90ZURhdGEodGl0bGU6c3RyaW5nLCBzY2hlbWE6IE5vdGVEYXRhLCBkYXRhOiBhbnkpOiBOb3RlRGF0YXtcbiAgcmV0dXJuIHtcbiAgICBzY2hlbWFIYXNoOiBoYXNoRGF0YShzY2hlbWEpLFxuICAgIGRhdGE6IHtcbiAgICAgIC4uLih0aXRsZT8ge3RpdGxlfSA6IHt9KSxcbiAgICAgIC4uLmRhdGFcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHRvcDogTm90ZURhdGEgPSB7c2NoZW1hSGFzaCA6IFwiMFwiIGFzIEhhc2gsIGRhdGE6IHt9fVxuXG5leHBvcnQgY29uc3Qgc2NyaXB0X3NjaGVtYSA9IE5vdGVEYXRhKFwic2NyaXB0X3NjaGVtYVwiLCB0b3AsIG9iamVjdCh7XG4gIHRpdGxlOiBzdHJpbmcsXG4gIGNvZGU6IHN0cmluZyxcbn0pKVxuXG5cbmV4cG9ydCBjb25zdCBzY3JpcHRfcmVzdWx0X3NjaGVtYSA9IE5vdGVEYXRhKFwic2NyaXB0X3Jlc3VsdF9zY2hlbWFcIiwgdG9wLCBvYmplY3Qoe1xuICB0aXRsZTogc3RyaW5nLFxuICBzY3JpcHQ6IFwiI1wiICsgaGFzaERhdGEoc2NyaXB0X3NjaGVtYSksXG4gIGNvbnRlbnQ6IHt9LFxufSwge1xuICB0aXRsZTogXCJzY3JpcHRfcmVzdWx0X3NjaGVtYVwiXG59KSlcblxuY29uc3QgdGl0bGVkX3NjaGVtYSA9IE5vdGVEYXRhKFwidGl0bGVkX3NjaGVtYVwiLCB0b3AsIG9iamVjdCh7dGl0bGU6IHN0cmluZ30pKVxuXG5jb25zdCBoYXNfdGl0bGVkX2NoaWxkID0gTm90ZURhdGEoXCJoYXNfdGl0bGVkX2NoaWxkXCIsIHRvcCwgb2JqZWN0KHtcImNoaWxkXCI6IG9iamVjdCh7dGl0bGU6c3RyaW5nfSl9KSlcblxuXG5jb25zdCB0aXRsZWQgPSBOb3RlRGF0YShcImEgdGl0bGVkXCIsIHRpdGxlZF9zY2hlbWEsIHt0aXRsZTogXCJpbSBjaGlsZFwifSlcbmNvbnN0IHRpdGxlZDEgPSBOb3RlRGF0YShcInRpdGxlZDFcIiwgaGFzX3RpdGxlZF9jaGlsZCwgeyBjaGlsZDogdGl0bGVkLmRhdGEgfSlcbmNvbnN0IHRpdGxlZDIgPSBOb3RlRGF0YShcInRpdGxlZDJcIiwgaGFzX3RpdGxlZF9jaGlsZCwge2NoaWxkOiBgIyR7aGFzaERhdGEodGl0bGVkKX1gfSk7XG5cblxuXG5leHBvcnQgY29uc3QgZnVuY3Rpb25fc2NoZW1hID0gTm90ZURhdGEoXCJmdW5jdGlvbiBzY2hlbWFcIiwgdG9wLCBvYmplY3Qoe1xuICB0aXRsZTogc3RyaW5nLFxuICBjb2RlOiBzdHJpbmcsXG59LCB7XG4gIHRpdGxlOiBcImZ1bmN0aW9uX3NjaGVtYVwiLFxuICByZXF1aXJlZDogW1wiY29kZVwiXVxufSkpXG5cblxuZXhwb3J0IGNvbnN0IHNlcnZlcl9mdW5jdGlvbiA9IE5vdGVEYXRhKFwiZnVuY3Rpb24gc2NoZW1hXCIsIHRvcCwgb2JqZWN0KHtcbiAgdGl0bGU6IHN0cmluZyxcbiAgY29kZTogc3RyaW5nLFxufSwge1xuICB0aXRsZTogXCJzZXJ2ZXJfZnVuY3Rpb25cIixcbiAgcmVxdWlyZWQ6IFtcImNvZGVcIl1cbn0pKVxuXG5cblxuXG5jb25zdCBleGFtcGxlX2Z1bmN0aW9uID0gTm90ZURhdGEoXCJleGFtcGxlIGZ1bmN0aW9uXCIsIGZ1bmN0aW9uX3NjaGVtYSwge1xuICB0aXRsZTogXCJleGFtcGxlIGZ1bmN0aW9uXCIsXG4gIGlucHV0czogW1wiYVwiLCBcImJcIl0sXG4gIGNvZGU6IFwicmV0dXJuIGEgKyBiXCIsXG59KVxuXG5cblxuZXhwb3J0IGNvbnN0IHNjaGVtYXMgOiBOb3RlRGF0YVtdID0gW1xuICBzY3JpcHRfc2NoZW1hLFxuICBzY3JpcHRfcmVzdWx0X3NjaGVtYSxcbiAgTm90ZURhdGEoXCJcIiwgdG9wLCBzdHJpbmcpLFxuICBOb3RlRGF0YShcIlwiLCB0b3AsIG51bWJlciksXG4gIHRpdGxlZF9zY2hlbWEsXG4gIGhhc190aXRsZWRfY2hpbGQsXG4gIHRpdGxlZCxcbiAgdGl0bGVkMSwgdGl0bGVkMixcbiAgZnVuY3Rpb25fc2NoZW1hLCBleGFtcGxlX2Z1bmN0aW9uLFxuICBzZXJ2ZXJfZnVuY3Rpb24sICBcbl1cblxuXG5leHBvcnQgY29uc3QgaXNSZWYgPSAodmFsdWU6IGFueSkgPT5cbiAgdHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIgJiYgL14jKFthLWYwLTldezMyfSkkLy5leGVjKHZhbHVlKSBhcyBSZWZbXSB8IG51bGw7XG5cbmV4cG9ydCBjb25zdCBleHBhbmRMaW5rc1N5bmMgPSAoXG4gIHZhbHVlOiBKc29uYWJsZSxcbiAgcmVzb2x2ZTogKHJlZjogUmVmKSA9PiBKc29uYWJsZSxcbik6IEpzb25hYmxlID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnN0IG1hdGNoID0gaXNSZWYodmFsdWUpO1xuICAgIGlmICghbWF0Y2gpIHJldHVybiB2YWx1ZTtcbiAgICBjb25zdCByZWYgPSBtYXRjaFsxXTtcbiAgICByZXR1cm4gZXhwYW5kTGlua3NTeW5jKHJlc29sdmUocmVmKSwgcmVzb2x2ZSk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSByZXR1cm4gdmFsdWUubWFwKCh2KSA9PiBleHBhbmRMaW5rc1N5bmModiwgcmVzb2x2ZSkpO1xuICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyh2YWx1ZSkubWFwKCAoW2ssIHZdKSA9PiBbaywgZXhwYW5kTGlua3NTeW5jKHYsIHJlc29sdmUpXSkpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn07XG5cblxuZXhwb3J0IGNvbnN0IGV4cGFuZExpbmtzID0gYXN5bmMgKFxuICB2YWx1ZTogSnNvbmFibGUsXG4gIHJlc29sdmU6IChyZWY6IFJlZiApID0+IFByb21pc2U8SnNvbmFibGU+LFxuKTogUHJvbWlzZTxKc29uYWJsZT4gPT4ge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBpc1JlZih2YWx1ZSk7XG4gICAgaWYgKCFtYXRjaCkgcmV0dXJuIHZhbHVlO1xuICAgIGNvbnN0IHJlZiA9IG1hdGNoWzFdO1xuICAgIHJldHVybiBleHBhbmRMaW5rcyhhd2FpdCByZXNvbHZlKHJlZiksIHJlc29sdmUpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkgcmV0dXJuIFByb21pc2UuYWxsKHZhbHVlLm1hcCgodikgPT4gZXhwYW5kTGlua3ModiwgcmVzb2x2ZSkpKTtcbiAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoYXdhaXQgUHJvbWlzZS5hbGwoT2JqZWN0LmVudHJpZXModmFsdWUpLm1hcChhc3luYyAoW2ssIHZdKSA9PiBbaywgYXdhaXQgZXhwYW5kTGlua3ModiwgcmVzb2x2ZSldKSkpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn07XG4vKioqIHJlcHJlc2VudHMgYSBub3RlIGhhc2ggKG9wdGlvbmFsbHkgcHJlZml4ZWQgd2l0aCAjKSAqKiovXG5leHBvcnQgdHlwZSBSZWYgPSBIYXNoIHwgYCMke0hhc2h9YFxuXG5leHBvcnQgY29uc3Qgbm9ybWFsaXplUmVmID0gKHJlZjogUmVmKTogSGFzaCA9PlxuICAocmVmWzBdID09PSBcIiNcIiA/IHJlZi5zbGljZSgxKSA6IHJlZikgYXMgSGFzaDtcbiIsInR5cGUgVG9rZW5UeXBlID1cbiAgfCBcIm51bWJlclwiXG4gIHwgXCJzdHJpbmdcIlxuICB8IFwiaWRlbnRpZmllclwiXG4gIHwgXCJrZXl3b3JkXCJcbiAgfCBcIm9wZXJhdG9yXCJcbiAgfCBcInB1bmN0XCJcbiAgfCBcImVvZlwiO1xuXG50eXBlIFRva2VuID0geyB0eXBlOiBUb2tlblR5cGU7IHZhbHVlOiBzdHJpbmc7IHBvczogbnVtYmVyIH07XG5cbmNvbnN0IGtleXdvcmRzID0gbmV3IFNldChbXG4gIFwiaWZcIixcbiAgXCJlbHNlXCIsXG4gIFwicmV0dXJuXCIsXG4gIFwibGV0XCIsXG4gIFwiY29uc3RcIixcbiAgXCJmb3JcIixcbiAgXCJ3aGlsZVwiLFxuICBcImluXCIsXG4gIFwib2ZcIixcbiAgXCJicmVha1wiLFxuICBcImNvbnRpbnVlXCIsXG4gIFwidHJ1ZVwiLFxuICBcImZhbHNlXCIsXG4gIFwibnVsbFwiLFxuXSk7XG5cbmNvbnN0IGlzSWRlbnRTdGFydCA9IChjOiBzdHJpbmcpID0+IC9bQS1aYS16XyRdLy50ZXN0KGMpO1xuY29uc3QgaXNJZGVudFBhcnQgPSAoYzogc3RyaW5nKSA9PiAvW0EtWmEtejAtOV8kXS8udGVzdChjKTtcbmNvbnN0IGlzRGlnaXQgPSAoYzogc3RyaW5nKSA9PiAvWzAtOV0vLnRlc3QoYyk7XG5cbmNvbnN0IHRva2VuaXplID0gKHNyYzogc3RyaW5nKTogVG9rZW5bXSA9PiB7XG4gIGNvbnN0IHRva2VuczogVG9rZW5bXSA9IFtdO1xuICBsZXQgaSA9IDA7XG4gIGNvbnN0IHB1c2ggPSAodHlwZTogVG9rZW5UeXBlLCB2YWx1ZTogc3RyaW5nLCBwb3M6IG51bWJlcikgPT4gdG9rZW5zLnB1c2goeyB0eXBlLCB2YWx1ZSwgcG9zIH0pO1xuICBjb25zdCBwZWVrID0gKCkgPT4gc3JjW2ldO1xuICBjb25zdCBuZXh0ID0gKCkgPT4gc3JjW2krK107XG5cbiAgd2hpbGUgKGkgPCBzcmMubGVuZ3RoKSB7XG4gICAgY29uc3QgYyA9IHBlZWsoKTtcbiAgICBpZiAoYyA9PT0gXCIgXCIgfHwgYyA9PT0gXCJcXG5cIiB8fCBjID09PSBcIlxcclwiIHx8IGMgPT09IFwiXFx0XCIpIHtcbiAgICAgIGkrKztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoYyA9PT0gXCIvXCIgJiYgc3JjW2kgKyAxXSA9PT0gXCIvXCIpIHtcbiAgICAgIGkgKz0gMjtcbiAgICAgIHdoaWxlIChpIDwgc3JjLmxlbmd0aCAmJiBzcmNbaV0gIT09IFwiXFxuXCIpIGkrKztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoYyA9PT0gXCIvXCIgJiYgc3JjW2kgKyAxXSA9PT0gXCIqXCIpIHtcbiAgICAgIGkgKz0gMjtcbiAgICAgIHdoaWxlIChpIDwgc3JjLmxlbmd0aCAmJiAhKHNyY1tpXSA9PT0gXCIqXCIgJiYgc3JjW2kgKyAxXSA9PT0gXCIvXCIpKSBpKys7XG4gICAgICBpICs9IDI7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGMgPT09IFwiJ1wiIHx8IGMgPT09IFwiXFxcIlwiKSB7XG4gICAgICBjb25zdCBxdW90ZSA9IG5leHQoKTtcbiAgICAgIGxldCBvdXQgPSBcIlwiO1xuICAgICAgY29uc3Qgc3RhcnQgPSBpIC0gMTtcbiAgICAgIHdoaWxlIChpIDwgc3JjLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBjaCA9IG5leHQoKTtcbiAgICAgICAgaWYgKGNoID09PSBcIlxcXFxcIikge1xuICAgICAgICAgIGNvbnN0IGVzYyA9IG5leHQoKTtcbiAgICAgICAgICBvdXQgKz0gZXNjO1xuICAgICAgICB9IGVsc2UgaWYgKGNoID09PSBxdW90ZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCArPSBjaDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcHVzaChcInN0cmluZ1wiLCBvdXQsIHN0YXJ0KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoaXNEaWdpdChjKSkge1xuICAgICAgY29uc3Qgc3RhcnQgPSBpO1xuICAgICAgbGV0IG51bSA9IFwiXCI7XG4gICAgICB3aGlsZSAoaSA8IHNyYy5sZW5ndGggJiYgaXNEaWdpdChwZWVrKCkpKSBudW0gKz0gbmV4dCgpO1xuICAgICAgaWYgKHBlZWsoKSA9PT0gXCIuXCIpIHtcbiAgICAgICAgbnVtICs9IG5leHQoKTtcbiAgICAgICAgd2hpbGUgKGkgPCBzcmMubGVuZ3RoICYmIGlzRGlnaXQocGVlaygpKSkgbnVtICs9IG5leHQoKTtcbiAgICAgIH1cbiAgICAgIHB1c2goXCJudW1iZXJcIiwgbnVtLCBzdGFydCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGlzSWRlbnRTdGFydChjKSkge1xuICAgICAgY29uc3Qgc3RhcnQgPSBpO1xuICAgICAgbGV0IGlkID0gXCJcIjtcbiAgICAgIHdoaWxlIChpIDwgc3JjLmxlbmd0aCAmJiBpc0lkZW50UGFydChwZWVrKCkpKSBpZCArPSBuZXh0KCk7XG4gICAgICBpZiAoa2V5d29yZHMuaGFzKGlkKSkgcHVzaChcImtleXdvcmRcIiwgaWQsIHN0YXJ0KTtcbiAgICAgIGVsc2UgcHVzaChcImlkZW50aWZpZXJcIiwgaWQsIHN0YXJ0KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBzdGFydCA9IGk7XG4gICAgY29uc3QgdHdvID0gc3JjLnNsaWNlKGksIGkgKyAyKTtcbiAgICBjb25zdCB0aHJlZSA9IHNyYy5zbGljZShpLCBpICsgMyk7XG4gICAgaWYgKHRocmVlID09PSBcIj09PVwiIHx8IHRocmVlID09PSBcIiE9PVwiKSB7XG4gICAgICBpICs9IDM7XG4gICAgICBwdXNoKFwib3BlcmF0b3JcIiwgdGhyZWUsIHN0YXJ0KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAodHdvID09PSBcIiYmXCIgfHwgdHdvID09PSBcInx8XCIgfHwgdHdvID09PSBcIj09XCIgfHwgdHdvID09PSBcIiE9XCIgfHwgdHdvID09PSBcIjw9XCIgfHwgdHdvID09PSBcIj49XCIgfHwgdHdvID09PSBcIj0+XCIgfHwgdHdvID09PSBcIis9XCIgfHwgdHdvID09PSBcIi09XCIgfHwgdHdvID09PSBcIio9XCIgfHwgdHdvID09PSBcIi89XCIgfHwgdHdvID09PSBcIiU9XCIgfHwgdHdvID09PSBcIisrXCIgfHwgdHdvID09PSBcIi0tXCIpIHtcbiAgICAgIGkgKz0gMjtcbiAgICAgIHB1c2goXCJvcGVyYXRvclwiLCB0d28sIHN0YXJ0KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoXCIrLSovJTw+PSEuLDs6Pygpe31bXVwiLmluY2x1ZGVzKGMpKSB7XG4gICAgICBpKys7XG4gICAgICBjb25zdCB0eXBlID0gXCIuOywoKXt9W11cIi5pbmNsdWRlcyhjKSA/IFwicHVuY3RcIiA6IFwib3BlcmF0b3JcIjtcbiAgICAgIHB1c2godHlwZSwgYywgc3RhcnQpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgJyR7Y30nIGF0ICR7aX1gKTtcbiAgfVxuICB0b2tlbnMucHVzaCh7IHR5cGU6IFwiZW9mXCIsIHZhbHVlOiBcIlwiLCBwb3M6IGkgfSk7XG4gIHJldHVybiB0b2tlbnM7XG59O1xuXG5leHBvcnQgdHlwZSBQcm9ncmFtID0geyB0eXBlOiBcIlByb2dyYW1cIjsgYm9keTogU3RtdFtdIH07XG5leHBvcnQgdHlwZSBCbG9ja1N0YXRlbWVudCA9IHsgdHlwZTogXCJCbG9ja1N0YXRlbWVudFwiOyBib2R5OiBTdG10W10gfTtcbmV4cG9ydCB0eXBlIFN0bXQgPVxuICB8IEJsb2NrU3RhdGVtZW50XG4gIHwgeyB0eXBlOiBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIjsgZXhwcmVzc2lvbjogRXhwciB9XG4gIHwgeyB0eXBlOiBcIklmU3RhdGVtZW50XCI7IHRlc3Q6IEV4cHI7IGNvbnNlcXVlbnQ6IFN0bXQ7IGFsdGVybmF0ZTogU3RtdCB8IG51bGwgfVxuICB8IHsgdHlwZTogXCJSZXR1cm5TdGF0ZW1lbnRcIjsgYXJndW1lbnQ6IEV4cHIgfCBudWxsIH1cbiAgfCB7IHR5cGU6IFwiVmFyaWFibGVEZWNsYXJhdGlvblwiOyBraW5kOiBcImxldFwiIHwgXCJjb25zdFwiOyBkZWNsYXJhdGlvbnM6IFZhckRlY2xbXSB9XG4gIHwgeyB0eXBlOiBcIkJyZWFrU3RhdGVtZW50XCIgfVxuICB8IHsgdHlwZTogXCJDb250aW51ZVN0YXRlbWVudFwiIH1cbiAgfCB7IHR5cGU6IFwiV2hpbGVTdGF0ZW1lbnRcIjsgdGVzdDogRXhwcjsgYm9keTogU3RtdCB9XG4gIHwge1xuICAgICAgdHlwZTogXCJGb3JTdGF0ZW1lbnRcIjtcbiAgICAgIGluaXQ6IFZhckRlY2xbXSB8IEV4cHIgfCBudWxsO1xuICAgICAgaW5pdEtpbmQ6IFwibGV0XCIgfCBcImNvbnN0XCIgfCBudWxsO1xuICAgICAgdGVzdDogRXhwciB8IG51bGw7XG4gICAgICB1cGRhdGU6IEV4cHIgfCBudWxsO1xuICAgICAgYm9keTogU3RtdDtcbiAgICB9XG4gIHwgeyB0eXBlOiBcIkZvckluU3RhdGVtZW50XCI7IGxlZnQ6IFZhckRlY2xbXSB8IEV4cHI7IGxlZnRLaW5kOiBcImxldFwiIHwgXCJjb25zdFwiIHwgbnVsbDsgcmlnaHQ6IEV4cHI7IGJvZHk6IFN0bXQgfVxuICB8IHsgdHlwZTogXCJGb3JPZlN0YXRlbWVudFwiOyBsZWZ0OiBWYXJEZWNsW10gfCBFeHByOyBsZWZ0S2luZDogXCJsZXRcIiB8IFwiY29uc3RcIiB8IG51bGw7IHJpZ2h0OiBFeHByOyBib2R5OiBTdG10IH07XG5leHBvcnQgdHlwZSBQYXR0ZXJuID1cbiAgfCBJZGVudGlmaWVyXG4gIHwgeyB0eXBlOiBcIkFycmF5UGF0dGVyblwiOyBlbGVtZW50czogSWRlbnRpZmllcltdIH1cbiAgfCB7IHR5cGU6IFwiT2JqZWN0UGF0dGVyblwiOyBwcm9wZXJ0aWVzOiBJZGVudGlmaWVyW10gfTtcblxuZXhwb3J0IHR5cGUgVmFyRGVjbCA9IHsgdHlwZTogXCJWYXJpYWJsZURlY2xhcmF0b3JcIjsgaWQ6IFBhdHRlcm47IGluaXQ6IEV4cHIgfCBudWxsIH07XG5cbmV4cG9ydCB0eXBlIEV4cHIgPVxuICB8IElkZW50aWZpZXJcbiAgfCBMaXRlcmFsXG4gIHwgeyB0eXBlOiBcIkFycmF5RXhwcmVzc2lvblwiOyBlbGVtZW50czogRXhwcltdIH1cbiAgfCB7IHR5cGU6IFwiT2JqZWN0RXhwcmVzc2lvblwiOyBwcm9wZXJ0aWVzOiBQcm9wZXJ0eVtdIH1cbiAgfCB7IHR5cGU6IFwiQ2FsbEV4cHJlc3Npb25cIjsgY2FsbGVlOiBFeHByOyBhcmd1bWVudHM6IEV4cHJbXSB9XG4gIHwgeyB0eXBlOiBcIk1lbWJlckV4cHJlc3Npb25cIjsgb2JqZWN0OiBFeHByOyBwcm9wZXJ0eTogRXhwcjsgY29tcHV0ZWQ6IGJvb2xlYW4gfVxuICB8IHsgdHlwZTogXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiOyBvcGVyYXRvcjogc3RyaW5nOyBsZWZ0OiBFeHByOyByaWdodDogRXhwciB9XG4gIHwgeyB0eXBlOiBcIlVwZGF0ZUV4cHJlc3Npb25cIjsgb3BlcmF0b3I6IFwiKytcIiB8IFwiLS1cIjsgYXJndW1lbnQ6IEV4cHI7IHByZWZpeDogYm9vbGVhbiB9XG4gIHwgeyB0eXBlOiBcIkJpbmFyeUV4cHJlc3Npb25cIjsgb3BlcmF0b3I6IHN0cmluZzsgbGVmdDogRXhwcjsgcmlnaHQ6IEV4cHIgfVxuICB8IHsgdHlwZTogXCJMb2dpY2FsRXhwcmVzc2lvblwiOyBvcGVyYXRvcjogc3RyaW5nOyBsZWZ0OiBFeHByOyByaWdodDogRXhwciB9XG4gIHwgeyB0eXBlOiBcIlVuYXJ5RXhwcmVzc2lvblwiOyBvcGVyYXRvcjogc3RyaW5nOyBhcmd1bWVudDogRXhwciB9XG4gIHwgeyB0eXBlOiBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiOyB0ZXN0OiBFeHByOyBjb25zZXF1ZW50OiBFeHByOyBhbHRlcm5hdGU6IEV4cHIgfVxuICB8IHsgdHlwZTogXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiOyBwYXJhbXM6IElkZW50aWZpZXJbXTsgYm9keTogRXhwciB8IEJsb2NrU3RhdGVtZW50IH07XG5cbmV4cG9ydCB0eXBlIElkZW50aWZpZXIgPSB7IHR5cGU6IFwiSWRlbnRpZmllclwiOyBuYW1lOiBzdHJpbmcgfTtcbmV4cG9ydCB0eXBlIExpdGVyYWwgPSB7IHR5cGU6IFwiTGl0ZXJhbFwiOyB2YWx1ZTogc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IG51bGwgfTtcbmV4cG9ydCB0eXBlIFByb3BlcnR5ID0geyB0eXBlOiBcIlByb3BlcnR5XCI7IGtleTogSWRlbnRpZmllciB8IExpdGVyYWw7IHZhbHVlOiBFeHByOyBzaG9ydGhhbmQ6IGJvb2xlYW4gfTtcblxuZXhwb3J0IGNvbnN0IHZhbGlkYXRlU2NvcGVzID0gKHByb2dyYW06IFByb2dyYW0sIGFsbG93ZWRHbG9iYWxzOiBzdHJpbmdbXSA9IFtdKSA9PiB7XG4gIGNvbnN0IGVycm9yczogc3RyaW5nW10gPSBbXTtcbiAgY29uc3QgZ2xvYmFscyA9IG5ldyBTZXQoYWxsb3dlZEdsb2JhbHMpO1xuICBjb25zdCBzY29wZXM6IEFycmF5PFNldDxzdHJpbmc+PiA9IFtuZXcgU2V0KCldO1xuXG4gIGNvbnN0IGRlY2xhcmUgPSAobmFtZTogc3RyaW5nKSA9PiBzY29wZXNbc2NvcGVzLmxlbmd0aCAtIDFdLmFkZChuYW1lKTtcbiAgY29uc3QgaXNEZWNsYXJlZCA9IChuYW1lOiBzdHJpbmcpID0+IHNjb3Blcy5zb21lKChzKSA9PiBzLmhhcyhuYW1lKSkgfHwgZ2xvYmFscy5oYXMobmFtZSk7XG4gIGNvbnN0IGVudGVyID0gKCkgPT4gc2NvcGVzLnB1c2gobmV3IFNldCgpKTtcbiAgY29uc3QgZXhpdCA9ICgpID0+IHsgc2NvcGVzLnBvcCgpOyB9O1xuICBjb25zdCBjaGVja0lkZW50ID0gKG5hbWU6IHN0cmluZykgPT4ge1xuICAgIGlmICghaXNEZWNsYXJlZChuYW1lKSkgZXJyb3JzLnB1c2goYHVuZGVjbGFyZWQ6ICR7bmFtZX1gKTtcbiAgfTtcblxuICBjb25zdCBkZWNsYXJlUGF0dGVybiA9IChwOiBQYXR0ZXJuKSA9PiB7XG4gICAgaWYgKHAudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIpIGRlY2xhcmUocC5uYW1lKTtcbiAgICBlbHNlIGlmIChwLnR5cGUgPT09IFwiQXJyYXlQYXR0ZXJuXCIpIHAuZWxlbWVudHMuZm9yRWFjaCgoZSkgPT4gZGVjbGFyZShlLm5hbWUpKTtcbiAgICBlbHNlIHAucHJvcGVydGllcy5mb3JFYWNoKChlKSA9PiBkZWNsYXJlKGUubmFtZSkpO1xuICB9O1xuXG4gIGNvbnN0IHZpc2l0RXhwciA9IChlOiBFeHByKTogdm9pZCA9PiB7XG4gICAgc3dpdGNoIChlLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJJZGVudGlmaWVyXCI6XG4gICAgICAgIGNoZWNrSWRlbnQoZS5uYW1lKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcIkxpdGVyYWxcIjpcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcIkFycmF5RXhwcmVzc2lvblwiOlxuICAgICAgICBlLmVsZW1lbnRzLmZvckVhY2godmlzaXRFeHByKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcIk9iamVjdEV4cHJlc3Npb25cIjpcbiAgICAgICAgZS5wcm9wZXJ0aWVzLmZvckVhY2goKHApID0+IHZpc2l0RXhwcihwLnZhbHVlKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJDYWxsRXhwcmVzc2lvblwiOlxuICAgICAgICB2aXNpdEV4cHIoZS5jYWxsZWUpO1xuICAgICAgICBlLmFyZ3VtZW50cy5mb3JFYWNoKHZpc2l0RXhwcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgICAgIHZpc2l0RXhwcihlLm9iamVjdCk7XG4gICAgICAgIGlmIChlLmNvbXB1dGVkKSB2aXNpdEV4cHIoZS5wcm9wZXJ0eSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiOlxuICAgICAgICB2aXNpdEV4cHIoZS5sZWZ0KTtcbiAgICAgICAgdmlzaXRFeHByKGUucmlnaHQpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiVXBkYXRlRXhwcmVzc2lvblwiOlxuICAgICAgICB2aXNpdEV4cHIoZS5hcmd1bWVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJCaW5hcnlFeHByZXNzaW9uXCI6XG4gICAgICBjYXNlIFwiTG9naWNhbEV4cHJlc3Npb25cIjpcbiAgICAgICAgdmlzaXRFeHByKGUubGVmdCk7XG4gICAgICAgIHZpc2l0RXhwcihlLnJpZ2h0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcIlVuYXJ5RXhwcmVzc2lvblwiOlxuICAgICAgICB2aXNpdEV4cHIoZS5hcmd1bWVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIjpcbiAgICAgICAgdmlzaXRFeHByKGUudGVzdCk7XG4gICAgICAgIHZpc2l0RXhwcihlLmNvbnNlcXVlbnQpO1xuICAgICAgICB2aXNpdEV4cHIoZS5hbHRlcm5hdGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIjpcbiAgICAgICAgZW50ZXIoKTtcbiAgICAgICAgZS5wYXJhbXMuZm9yRWFjaCgocCkgPT4gZGVjbGFyZShwLm5hbWUpKTtcbiAgICAgICAgaWYgKGUuYm9keS50eXBlID09PSBcIkJsb2NrU3RhdGVtZW50XCIpIHZpc2l0U3RtdChlLmJvZHkpO1xuICAgICAgICBlbHNlIHZpc2l0RXhwcihlLmJvZHkpO1xuICAgICAgICBleGl0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgdmlzaXRWYXJEZWNsID0gKGQ6IFZhckRlY2wpID0+IHtcbiAgICBkZWNsYXJlUGF0dGVybihkLmlkKTtcbiAgICBpZiAoZC5pbml0KSB2aXNpdEV4cHIoZC5pbml0KTtcbiAgfTtcblxuICBjb25zdCB2aXNpdFN0bXQgPSAoczogU3RtdCk6IHZvaWQgPT4ge1xuICAgIHN3aXRjaCAocy50eXBlKSB7XG4gICAgICBjYXNlIFwiQmxvY2tTdGF0ZW1lbnRcIjpcbiAgICAgICAgZW50ZXIoKTtcbiAgICAgICAgcy5ib2R5LmZvckVhY2godmlzaXRTdG10KTtcbiAgICAgICAgZXhpdCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiRXhwcmVzc2lvblN0YXRlbWVudFwiOlxuICAgICAgICB2aXNpdEV4cHIocy5leHByZXNzaW9uKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcIklmU3RhdGVtZW50XCI6XG4gICAgICAgIHZpc2l0RXhwcihzLnRlc3QpO1xuICAgICAgICB2aXNpdFN0bXQocy5jb25zZXF1ZW50KTtcbiAgICAgICAgaWYgKHMuYWx0ZXJuYXRlKSB2aXNpdFN0bXQocy5hbHRlcm5hdGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiUmV0dXJuU3RhdGVtZW50XCI6XG4gICAgICAgIGlmIChzLmFyZ3VtZW50KSB2aXNpdEV4cHIocy5hcmd1bWVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJWYXJpYWJsZURlY2xhcmF0aW9uXCI6XG4gICAgICAgIHMuZGVjbGFyYXRpb25zLmZvckVhY2godmlzaXRWYXJEZWNsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcIldoaWxlU3RhdGVtZW50XCI6XG4gICAgICAgIHZpc2l0RXhwcihzLnRlc3QpO1xuICAgICAgICB2aXNpdFN0bXQocy5ib2R5KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcIkZvclN0YXRlbWVudFwiOiB7XG4gICAgICAgIGVudGVyKCk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHMuaW5pdCkpIHMuaW5pdC5mb3JFYWNoKHZpc2l0VmFyRGVjbCk7XG4gICAgICAgIGVsc2UgaWYgKHMuaW5pdCkgdmlzaXRFeHByKHMuaW5pdCk7XG4gICAgICAgIGlmIChzLnRlc3QpIHZpc2l0RXhwcihzLnRlc3QpO1xuICAgICAgICBpZiAocy51cGRhdGUpIHZpc2l0RXhwcihzLnVwZGF0ZSk7XG4gICAgICAgIHZpc2l0U3RtdChzLmJvZHkpO1xuICAgICAgICBleGl0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJGb3JJblN0YXRlbWVudFwiOlxuICAgICAgY2FzZSBcIkZvck9mU3RhdGVtZW50XCI6IHtcbiAgICAgICAgZW50ZXIoKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocy5sZWZ0KSkgcy5sZWZ0LmZvckVhY2godmlzaXRWYXJEZWNsKTtcbiAgICAgICAgZWxzZSB2aXNpdEV4cHIocy5sZWZ0KTtcbiAgICAgICAgdmlzaXRFeHByKHMucmlnaHQpO1xuICAgICAgICB2aXNpdFN0bXQocy5ib2R5KTtcbiAgICAgICAgZXhpdCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjYXNlIFwiQnJlYWtTdGF0ZW1lbnRcIjpcbiAgICAgIGNhc2UgXCJDb250aW51ZVN0YXRlbWVudFwiOlxuICAgICAgICByZXR1cm47XG4gICAgfVxuICB9O1xuXG4gIHByb2dyYW0uYm9keS5mb3JFYWNoKHZpc2l0U3RtdCk7XG4gIHJldHVybiBlcnJvcnM7XG59O1xuXG5leHBvcnQgY29uc3QgdmFsaWRhdGVOb1Byb3RvdHlwZSA9IChwcm9ncmFtOiBQcm9ncmFtKSA9PiB7XG4gIGNvbnN0IGVycm9yczogc3RyaW5nW10gPSBbXTtcbiAgY29uc3QgdmlzaXRFeHByID0gKGU6IEV4cHIpOiB2b2lkID0+IHtcbiAgICBzd2l0Y2ggKGUudHlwZSkge1xuICAgICAgY2FzZSBcIk1lbWJlckV4cHJlc3Npb25cIjpcbiAgICAgICAgaWYgKCFlLmNvbXB1dGVkICYmIGUucHJvcGVydHkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgZS5wcm9wZXJ0eS5uYW1lID09PSBcInByb3RvdHlwZVwiKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goXCJwcm90b3R5cGUgYWNjZXNzXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlLmNvbXB1dGVkICYmIGUucHJvcGVydHkudHlwZSA9PT0gXCJMaXRlcmFsXCIgJiYgZS5wcm9wZXJ0eS52YWx1ZSA9PT0gXCJwcm90b3R5cGVcIikge1xuICAgICAgICAgIGVycm9ycy5wdXNoKFwicHJvdG90eXBlIGFjY2Vzc1wiKTtcbiAgICAgICAgfVxuICAgICAgICB2aXNpdEV4cHIoZS5vYmplY3QpO1xuICAgICAgICBpZiAoZS5jb21wdXRlZCkgdmlzaXRFeHByKGUucHJvcGVydHkpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiQ2FsbEV4cHJlc3Npb25cIjpcbiAgICAgICAgdmlzaXRFeHByKGUuY2FsbGVlKTtcbiAgICAgICAgZS5hcmd1bWVudHMuZm9yRWFjaCh2aXNpdEV4cHIpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiQXJyYXlFeHByZXNzaW9uXCI6XG4gICAgICAgIGUuZWxlbWVudHMuZm9yRWFjaCh2aXNpdEV4cHIpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiT2JqZWN0RXhwcmVzc2lvblwiOlxuICAgICAgICBlLnByb3BlcnRpZXMuZm9yRWFjaCgocCkgPT4gdmlzaXRFeHByKHAudmFsdWUpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCI6XG4gICAgICAgIHZpc2l0RXhwcihlLmxlZnQpO1xuICAgICAgICB2aXNpdEV4cHIoZS5yaWdodCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJVcGRhdGVFeHByZXNzaW9uXCI6XG4gICAgICAgIHZpc2l0RXhwcihlLmFyZ3VtZW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcIkJpbmFyeUV4cHJlc3Npb25cIjpcbiAgICAgIGNhc2UgXCJMb2dpY2FsRXhwcmVzc2lvblwiOlxuICAgICAgICB2aXNpdEV4cHIoZS5sZWZ0KTtcbiAgICAgICAgdmlzaXRFeHByKGUucmlnaHQpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiVW5hcnlFeHByZXNzaW9uXCI6XG4gICAgICAgIHZpc2l0RXhwcihlLmFyZ3VtZW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiOlxuICAgICAgICB2aXNpdEV4cHIoZS50ZXN0KTtcbiAgICAgICAgdmlzaXRFeHByKGUuY29uc2VxdWVudCk7XG4gICAgICAgIHZpc2l0RXhwcihlLmFsdGVybmF0ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiOlxuICAgICAgICBpZiAoZS5ib2R5LnR5cGUgPT09IFwiQmxvY2tTdGF0ZW1lbnRcIikgdmlzaXRTdG10KGUuYm9keSk7XG4gICAgICAgIGVsc2UgdmlzaXRFeHByKGUuYm9keSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJJZGVudGlmaWVyXCI6XG4gICAgICBjYXNlIFwiTGl0ZXJhbFwiOlxuICAgICAgICByZXR1cm47XG4gICAgfVxuICB9O1xuICBjb25zdCB2aXNpdFN0bXQgPSAoczogU3RtdCk6IHZvaWQgPT4ge1xuICAgIHN3aXRjaCAocy50eXBlKSB7XG4gICAgICBjYXNlIFwiQmxvY2tTdGF0ZW1lbnRcIjpcbiAgICAgICAgcy5ib2R5LmZvckVhY2godmlzaXRTdG10KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIjpcbiAgICAgICAgdmlzaXRFeHByKHMuZXhwcmVzc2lvbik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJJZlN0YXRlbWVudFwiOlxuICAgICAgICB2aXNpdEV4cHIocy50ZXN0KTtcbiAgICAgICAgdmlzaXRTdG10KHMuY29uc2VxdWVudCk7XG4gICAgICAgIGlmIChzLmFsdGVybmF0ZSkgdmlzaXRTdG10KHMuYWx0ZXJuYXRlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcIlJldHVyblN0YXRlbWVudFwiOlxuICAgICAgICBpZiAocy5hcmd1bWVudCkgdmlzaXRFeHByKHMuYXJndW1lbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiVmFyaWFibGVEZWNsYXJhdGlvblwiOlxuICAgICAgICBzLmRlY2xhcmF0aW9ucy5mb3JFYWNoKChkKSA9PiBkLmluaXQgJiYgdmlzaXRFeHByKGQuaW5pdCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiV2hpbGVTdGF0ZW1lbnRcIjpcbiAgICAgICAgdmlzaXRFeHByKHMudGVzdCk7XG4gICAgICAgIHZpc2l0U3RtdChzLmJvZHkpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiRm9yU3RhdGVtZW50XCI6XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHMuaW5pdCkpIHMuaW5pdC5mb3JFYWNoKChkKSA9PiBkLmluaXQgJiYgdmlzaXRFeHByKGQuaW5pdCkpO1xuICAgICAgICBlbHNlIGlmIChzLmluaXQpIHZpc2l0RXhwcihzLmluaXQpO1xuICAgICAgICBpZiAocy50ZXN0KSB2aXNpdEV4cHIocy50ZXN0KTtcbiAgICAgICAgaWYgKHMudXBkYXRlKSB2aXNpdEV4cHIocy51cGRhdGUpO1xuICAgICAgICB2aXNpdFN0bXQocy5ib2R5KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcIkZvckluU3RhdGVtZW50XCI6XG4gICAgICBjYXNlIFwiRm9yT2ZTdGF0ZW1lbnRcIjpcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocy5sZWZ0KSkgcy5sZWZ0LmZvckVhY2goKGQpID0+IGQuaW5pdCAmJiB2aXNpdEV4cHIoZC5pbml0KSk7XG4gICAgICAgIGVsc2UgdmlzaXRFeHByKHMubGVmdCk7XG4gICAgICAgIHZpc2l0RXhwcihzLnJpZ2h0KTtcbiAgICAgICAgdmlzaXRTdG10KHMuYm9keSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJCcmVha1N0YXRlbWVudFwiOlxuICAgICAgY2FzZSBcIkNvbnRpbnVlU3RhdGVtZW50XCI6XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gIH07XG4gIHByb2dyYW0uYm9keS5mb3JFYWNoKHZpc2l0U3RtdCk7XG4gIHJldHVybiBlcnJvcnM7XG59O1xuXG5jb25zdCByZW5kZXJMaXRlcmFsID0gKHY6IExpdGVyYWxbXCJ2YWx1ZVwiXSkgPT4ge1xuICBpZiAodiA9PT0gbnVsbCkgcmV0dXJuIFwibnVsbFwiO1xuICBpZiAodHlwZW9mIHYgPT09IFwic3RyaW5nXCIpIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcbiAgcmV0dXJuIFN0cmluZyh2KTtcbn07XG5cbmNvbnN0IHJlbmRlckV4cHIgPSAoZTogRXhwcik6IHN0cmluZyA9PiB7XG4gIHN3aXRjaCAoZS50eXBlKSB7XG4gICAgY2FzZSBcIklkZW50aWZpZXJcIjpcbiAgICAgIHJldHVybiBlLm5hbWU7XG4gICAgY2FzZSBcIkxpdGVyYWxcIjpcbiAgICAgIHJldHVybiByZW5kZXJMaXRlcmFsKGUudmFsdWUpO1xuICAgIGNhc2UgXCJBcnJheUV4cHJlc3Npb25cIjpcbiAgICAgIHJldHVybiBgWyR7ZS5lbGVtZW50cy5tYXAocmVuZGVyRXhwcikuam9pbihcIiwgXCIpfV1gO1xuICAgIGNhc2UgXCJPYmplY3RFeHByZXNzaW9uXCI6XG4gICAgICByZXR1cm4gYHske2UucHJvcGVydGllcy5tYXAocmVuZGVyUHJvcCkuam9pbihcIiwgXCIpfX1gO1xuICAgIGNhc2UgXCJDYWxsRXhwcmVzc2lvblwiOiB7XG4gICAgICBjb25zdCBjYWxsZWVTdHIgPSByZW5kZXJFeHByKGUuY2FsbGVlKTtcbiAgICAgIGNvbnN0IG5lZWRzUGFyZW5zID0gZS5jYWxsZWUudHlwZSA9PT0gXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiO1xuICAgICAgcmV0dXJuIGAke25lZWRzUGFyZW5zID8gXCIoXCIgOiBcIlwifSR7Y2FsbGVlU3RyfSR7bmVlZHNQYXJlbnMgPyBcIilcIiA6IFwiXCJ9KCR7ZS5hcmd1bWVudHMubWFwKHJlbmRlckV4cHIpLmpvaW4oXCIsIFwiKX0pYDtcbiAgICB9XG4gICAgY2FzZSBcIk1lbWJlckV4cHJlc3Npb25cIjpcbiAgICAgIHJldHVybiBlLmNvbXB1dGVkXG4gICAgICAgID8gYCR7cmVuZGVyRXhwcihlLm9iamVjdCl9WyR7cmVuZGVyRXhwcihlLnByb3BlcnR5KX1dYFxuICAgICAgICA6IGAke3JlbmRlckV4cHIoZS5vYmplY3QpfS4ke3JlbmRlckV4cHIoZS5wcm9wZXJ0eSl9YDtcbiAgICBjYXNlIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIjpcbiAgICAgIHJldHVybiBgJHtyZW5kZXJFeHByKGUubGVmdCl9ICR7ZS5vcGVyYXRvcn0gJHtyZW5kZXJFeHByKGUucmlnaHQpfWA7XG4gICAgY2FzZSBcIlVwZGF0ZUV4cHJlc3Npb25cIjpcbiAgICAgIHJldHVybiBlLnByZWZpeFxuICAgICAgICA/IGAke2Uub3BlcmF0b3J9JHtyZW5kZXJFeHByKGUuYXJndW1lbnQpfWBcbiAgICAgICAgOiBgJHtyZW5kZXJFeHByKGUuYXJndW1lbnQpfSR7ZS5vcGVyYXRvcn1gO1xuICAgIGNhc2UgXCJCaW5hcnlFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIkxvZ2ljYWxFeHByZXNzaW9uXCI6XG4gICAgICByZXR1cm4gYCgke3JlbmRlckV4cHIoZS5sZWZ0KX0gJHtlLm9wZXJhdG9yfSAke3JlbmRlckV4cHIoZS5yaWdodCl9KWA7XG4gICAgY2FzZSBcIlVuYXJ5RXhwcmVzc2lvblwiOlxuICAgICAgcmV0dXJuIGAoJHtlLm9wZXJhdG9yfSR7cmVuZGVyRXhwcihlLmFyZ3VtZW50KX0pYDtcbiAgICBjYXNlIFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCI6XG4gICAgICByZXR1cm4gYCgke3JlbmRlckV4cHIoZS50ZXN0KX0gPyAke3JlbmRlckV4cHIoZS5jb25zZXF1ZW50KX0gOiAke3JlbmRlckV4cHIoZS5hbHRlcm5hdGUpfSlgO1xuICAgIGNhc2UgXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiOlxuICAgICAgcmV0dXJuIHJlbmRlckFycm93KGUpO1xuICB9XG59O1xuXG5jb25zdCByZW5kZXJQcm9wID0gKHA6IFByb3BlcnR5KSA9PiB7XG4gIGNvbnN0IGtleSA9XG4gICAgcC5rZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgPyBwLmtleS5uYW1lIDogcmVuZGVyTGl0ZXJhbChwLmtleS52YWx1ZSk7XG4gIGlmIChwLnNob3J0aGFuZCAmJiBwLnZhbHVlLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIHAudmFsdWUubmFtZSA9PT0ga2V5KSByZXR1cm4ga2V5O1xuICByZXR1cm4gYCR7a2V5fTogJHtyZW5kZXJFeHByKHAudmFsdWUpfWA7XG59O1xuXG5jb25zdCByZW5kZXJBcnJvdyA9IChlOiBFeHRyYWN0PEV4cHIsIHsgdHlwZTogXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiIH0+KSA9PiB7XG4gIGNvbnN0IHBhcmFtcyA9IGAoJHtlLnBhcmFtcy5tYXAoKHApID0+IHAubmFtZSkuam9pbihcIiwgXCIpfSlgO1xuICBpZiAoZS5ib2R5LnR5cGUgPT09IFwiQmxvY2tTdGF0ZW1lbnRcIikge1xuICAgIHJldHVybiBgJHtwYXJhbXN9ID0+ICR7cmVuZGVyU3RtdChlLmJvZHksIHRydWUpfWA7XG4gIH1cbiAgcmV0dXJuIGAke3BhcmFtc30gPT4geyBfX2J1cm4oKTsgcmV0dXJuICR7cmVuZGVyRXhwcihlLmJvZHkpfTsgfWA7XG59O1xuXG5jb25zdCByZW5kZXJTdG10ID0gKHM6IFN0bXQsIGluRm4gPSBmYWxzZSk6IHN0cmluZyA9PiB7XG4gIGNvbnN0IGJ1cm4gPSBpbkZuID8gXCJfX2J1cm4oKTtcIiA6IFwiXCI7XG4gIGNvbnN0IHJlbmRlckxvb3BCb2R5ID0gKGJvZHk6IFN0bXQpID0+IHtcbiAgICBpZiAoYm9keS50eXBlID09PSBcIkJsb2NrU3RhdGVtZW50XCIpIHtcbiAgICAgIGNvbnN0IGlubmVyID0gYm9keS5ib2R5Lm1hcCgoYikgPT4gcmVuZGVyU3RtdChiLCBpbkZuKSkuam9pbihcIlwiKTtcbiAgICAgIHJldHVybiBge19fYnVybigpOyR7aW5uZXJ9fWA7XG4gICAgfVxuICAgIHJldHVybiBge19fYnVybigpOyR7cmVuZGVyU3RtdChib2R5LCBpbkZuKX19YDtcbiAgfTtcbiAgc3dpdGNoIChzLnR5cGUpIHtcbiAgICBjYXNlIFwiQmxvY2tTdGF0ZW1lbnRcIjpcbiAgICAgIHJldHVybiBgeyR7cy5ib2R5Lm1hcCgoYikgPT4gcmVuZGVyU3RtdChiLCBpbkZuKSkuam9pbihcIlwiKX19YDtcbiAgICBjYXNlIFwiRXhwcmVzc2lvblN0YXRlbWVudFwiOlxuICAgICAgcmV0dXJuIGAke2J1cm59JHtyZW5kZXJFeHByKHMuZXhwcmVzc2lvbil9O2A7XG4gICAgY2FzZSBcIklmU3RhdGVtZW50XCI6IHtcbiAgICAgIGNvbnN0IHdyYXAgPSAoc3RtdDogU3RtdCkgPT5cbiAgICAgICAgc3RtdC50eXBlID09PSBcIkJsb2NrU3RhdGVtZW50XCIgPyByZW5kZXJTdG10KHN0bXQsIGluRm4pIDogYHske3JlbmRlclN0bXQoc3RtdCwgaW5Gbil9fWA7XG4gICAgICByZXR1cm4gYCR7YnVybn1pZiAoJHtyZW5kZXJFeHByKHMudGVzdCl9KSAke3dyYXAocy5jb25zZXF1ZW50KX0ke3MuYWx0ZXJuYXRlID8gYCBlbHNlICR7d3JhcChzLmFsdGVybmF0ZSl9YCA6IFwiXCJ9YDtcbiAgICB9XG4gICAgY2FzZSBcIlJldHVyblN0YXRlbWVudFwiOlxuICAgICAgcmV0dXJuIGAke2J1cm59cmV0dXJuJHtzLmFyZ3VtZW50ID8gYCAke3JlbmRlckV4cHIocy5hcmd1bWVudCl9YCA6IFwiXCJ9O2A7XG4gICAgY2FzZSBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIjpcbiAgICAgIHJldHVybiBgJHtidXJufSR7cy5raW5kfSAke3MuZGVjbGFyYXRpb25zLm1hcChyZW5kZXJEZWNsKS5qb2luKFwiLCBcIil9O2A7XG4gICAgY2FzZSBcIkJyZWFrU3RhdGVtZW50XCI6XG4gICAgICByZXR1cm4gYCR7YnVybn1icmVhaztgO1xuICAgIGNhc2UgXCJDb250aW51ZVN0YXRlbWVudFwiOlxuICAgICAgcmV0dXJuIGAke2J1cm59Y29udGludWU7YDtcbiAgICBjYXNlIFwiV2hpbGVTdGF0ZW1lbnRcIjpcbiAgICAgIHJldHVybiBgJHtidXJufXdoaWxlICgke3JlbmRlckV4cHIocy50ZXN0KX0pICR7cmVuZGVyTG9vcEJvZHkocy5ib2R5KX1gO1xuICAgIGNhc2UgXCJGb3JTdGF0ZW1lbnRcIjoge1xuICAgICAgY29uc3QgaW5pdCA9XG4gICAgICAgIHMuaW5pdCA9PSBudWxsXG4gICAgICAgICAgPyBcIlwiXG4gICAgICAgICAgOiBBcnJheS5pc0FycmF5KHMuaW5pdClcbiAgICAgICAgICA/IGAke3MuaW5pdEtpbmR9ICR7cy5pbml0Lm1hcChyZW5kZXJEZWNsKS5qb2luKFwiLCBcIil9YFxuICAgICAgICAgIDogcmVuZGVyRXhwcihzLmluaXQpO1xuICAgICAgY29uc3QgdGVzdCA9IHMudGVzdCA/IHJlbmRlckV4cHIocy50ZXN0KSA6IFwiXCI7XG4gICAgICBjb25zdCB1cGRhdGUgPSBzLnVwZGF0ZSA/IHJlbmRlckV4cHIocy51cGRhdGUpIDogXCJcIjtcbiAgICAgIHJldHVybiBgJHtidXJufWZvciAoJHtpbml0fTsgJHt0ZXN0fTsgJHt1cGRhdGV9KSAke3JlbmRlckxvb3BCb2R5KHMuYm9keSl9YDtcbiAgICB9XG4gICAgY2FzZSBcIkZvckluU3RhdGVtZW50XCI6IHtcbiAgICAgIGNvbnN0IGxlZnQgPSBBcnJheS5pc0FycmF5KHMubGVmdClcbiAgICAgICAgPyBgJHtzLmxlZnRLaW5kfSAke3MubGVmdC5tYXAocmVuZGVyRGVjbCkuam9pbihcIiwgXCIpfWBcbiAgICAgICAgOiByZW5kZXJFeHByKHMubGVmdCk7XG4gICAgICByZXR1cm4gYCR7YnVybn1mb3IgKCR7bGVmdH0gaW4gJHtyZW5kZXJFeHByKHMucmlnaHQpfSkgJHtyZW5kZXJMb29wQm9keShzLmJvZHkpfWA7XG4gICAgfVxuICAgIGNhc2UgXCJGb3JPZlN0YXRlbWVudFwiOiB7XG4gICAgICBjb25zdCBsZWZ0ID0gQXJyYXkuaXNBcnJheShzLmxlZnQpXG4gICAgICAgID8gYCR7cy5sZWZ0S2luZH0gJHtzLmxlZnQubWFwKHJlbmRlckRlY2wpLmpvaW4oXCIsIFwiKX1gXG4gICAgICAgIDogcmVuZGVyRXhwcihzLmxlZnQpO1xuICAgICAgcmV0dXJuIGAke2J1cm59Zm9yICgke2xlZnR9IG9mICR7cmVuZGVyRXhwcihzLnJpZ2h0KX0pICR7cmVuZGVyTG9vcEJvZHkocy5ib2R5KX1gO1xuICAgIH1cbiAgfVxufTtcblxuY29uc3QgcmVuZGVyRGVjbCA9IChkOiBWYXJEZWNsKSA9PlxuICBgJHtyZW5kZXJQYXR0ZXJuKGQuaWQpfSR7ZC5pbml0ID8gYCA9ICR7cmVuZGVyRXhwcihkLmluaXQpfWAgOiBcIlwifWA7XG5cbmNvbnN0IHJlbmRlclBhdHRlcm4gPSAocDogUGF0dGVybik6IHN0cmluZyA9PiB7XG4gIGlmIChwLnR5cGUgPT09IFwiSWRlbnRpZmllclwiKSByZXR1cm4gcC5uYW1lO1xuICBpZiAocC50eXBlID09PSBcIkFycmF5UGF0dGVyblwiKSByZXR1cm4gYFske3AuZWxlbWVudHMubWFwKChlKSA9PiBlLm5hbWUpLmpvaW4oXCIsIFwiKX1dYDtcbiAgcmV0dXJuIGB7JHtwLnByb3BlcnRpZXMubWFwKChlKSA9PiBlLm5hbWUpLmpvaW4oXCIsIFwiKX19YDtcbn07XG5cbmV4cG9ydCBjb25zdCByZW5kZXJXaXRoRnVlbCA9IChwcm9ncmFtOiBQcm9ncmFtLCBmdWVsID0gMTAwMDApID0+IHtcbiAgY29uc3QgcHJlbHVkZSA9IGBsZXQgX19mdWVsID0gJHtmdWVsfTsgY29uc3QgX19idXJuID0gKCkgPT4geyBpZiAoLS1fX2Z1ZWwgPCAwKSB0aHJvdyBuZXcgRXJyb3IoXCJmdWVsIGV4aGF1c3RlZFwiKTsgfTtgO1xuICBjb25zdCBib2R5ID0gcHJvZ3JhbS5ib2R5Lm1hcCgocykgPT4gcmVuZGVyU3RtdChzLCB0cnVlKSkuam9pbihcIlwiKTtcbiAgcmV0dXJuIGAke3ByZWx1ZGV9JHtib2R5fWA7XG59O1xuXG5leHBvcnQgY29uc3QgcmVuZGVyUnVubmVyV2l0aEZ1ZWwgPSAocHJvZ3JhbTogUHJvZ3JhbSwgZnVlbCA9IDEwMDAwKSA9PiB7XG4gIGNvbnN0IHByZWx1ZGUgPSBgbGV0IF9fZnVlbCA9ICR7ZnVlbH07IGNvbnN0IF9fYnVybiA9ICgpID0+IHsgaWYgKC0tX19mdWVsIDwgMCkgdGhyb3cgbmV3IEVycm9yKFwiZnVlbCBleGhhdXN0ZWRcIik7IH07YDtcbiAgY29uc3QgYm9keSA9IHByb2dyYW0uYm9keS5tYXAoKHMpID0+IHJlbmRlclN0bXQocywgdHJ1ZSkpLmpvaW4oXCJcIik7XG4gIHJldHVybiBgJHtwcmVsdWRlfWNvbnN0IF9fcnVuID0gKCkgPT4geyR7Ym9keX19OyB0cnkgeyBjb25zdCBvayA9IF9fcnVuKCk7IHJldHVybiB7IG9rLCBmdWVsOiBfX2Z1ZWwgfTsgfSBjYXRjaCAoZXJyKSB7IHJldHVybiB7IGVycjogU3RyaW5nKGVyciksIGZ1ZWw6IF9fZnVlbCB9OyB9YDtcbn07XG5cbmV4cG9ydCBjb25zdCByZW5kZXJSdW5uZXJXaXRoRnVlbFNoYXJlZCA9IChwcm9ncmFtOiBQcm9ncmFtLCBmdWVsUmVmTmFtZSA9IFwiX19mdWVsXCIpID0+IHtcbiAgY29uc3QgcHJlbHVkZSA9IGBjb25zdCBfX2J1cm4gPSAoKSA9PiB7IGlmICgtLSR7ZnVlbFJlZk5hbWV9LnZhbHVlIDwgMCkgdGhyb3cgbmV3IEVycm9yKFwiZnVlbCBleGhhdXN0ZWRcIik7IH07YDtcbiAgY29uc3QgYm9keSA9IHByb2dyYW0uYm9keS5tYXAoKHMpID0+IHJlbmRlclN0bXQocywgdHJ1ZSkpLmpvaW4oXCJcIik7XG4gIHJldHVybiBgJHtwcmVsdWRlfWNvbnN0IF9fcnVuID0gKCkgPT4geyR7Ym9keX19OyB0cnkgeyBjb25zdCBvayA9IF9fcnVuKCk7IHJldHVybiB7IG9rLCBmdWVsOiAke2Z1ZWxSZWZOYW1lfS52YWx1ZSB9OyB9IGNhdGNoIChlcnIpIHsgcmV0dXJuIHsgZXJyOiBTdHJpbmcoZXJyKSwgZnVlbDogJHtmdWVsUmVmTmFtZX0udmFsdWUgfTsgfWA7XG59O1xuXG5leHBvcnQgY29uc3QgcmVuZGVyUnVubmVyV2l0aEZ1ZWxBc3luYyA9IChwcm9ncmFtOiBQcm9ncmFtLCBmdWVsID0gMTAwMDApID0+IHtcbiAgY29uc3QgcHJlbHVkZSA9IGBsZXQgX19mdWVsID0gJHtmdWVsfTsgY29uc3QgX19idXJuID0gKCkgPT4geyBpZiAoLS1fX2Z1ZWwgPCAwKSB0aHJvdyBuZXcgRXJyb3IoXCJmdWVsIGV4aGF1c3RlZFwiKTsgfTtgO1xuICBjb25zdCBib2R5ID0gcHJvZ3JhbS5ib2R5Lm1hcCgocykgPT4gcmVuZGVyU3RtdChzLCB0cnVlKSkuam9pbihcIlwiKTtcbiAgcmV0dXJuIGAke3ByZWx1ZGV9Y29uc3QgX19ydW4gPSBhc3luYyAoKSA9PiB7JHtib2R5fX07IHJldHVybiBfX3J1bigpLnRoZW4ob2sgPT4gKHsgb2ssIGZ1ZWw6IF9fZnVlbCB9KSkuY2F0Y2goZXJyID0+ICh7IGVycjogU3RyaW5nKGVyciksIGZ1ZWw6IF9fZnVlbCB9KSk7YDtcbn07XG5cbmV4cG9ydCB0eXBlIHJ1blJlcyA9IHsgb2s6IHVua25vd247IGZ1ZWw6IG51bWJlciB9IHwgeyBlcnI6IHN0cmluZzsgZnVlbDogbnVtYmVyIH07XG5cbmNvbnN0IHN0cmluZ2lmeUVycm9yID0gKGVycjogdW5rbm93bik6IHN0cmluZyA9PiB7XG4gIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIGNvbnN0IHN0YWNrID0gZXJyLnN0YWNrIHx8ICcnO1xuICAgIGNvbnN0IHByZWZpeCA9IGAke2Vyci5uYW1lfTogJHtlcnIubWVzc2FnZX1gO1xuICAgIGNvbnN0IGNsZWFuU3RhY2sgPSBzdGFja1xuICAgICAgLnJlcGxhY2UoL15bXlxcbl0qXFxuPy8sICcnKVxuICAgICAgLnJlcGxhY2UoL3NwYWNldGltZWRiX21vZHVsZTooXFxkKyk6KFxcZCspL2csICc8YnVuZGxlZDokMTokMj4nKTtcbiAgICByZXR1cm4gY2xlYW5TdGFjayA/IGAke3ByZWZpeH1cXG4ke2NsZWFuU3RhY2t9YCA6IHByZWZpeDtcbiAgfVxuICBpZiAodHlwZW9mIGVyciA9PT0gJ29iamVjdCcgJiYgZXJyICE9PSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShlcnIpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIFN0cmluZyhlcnIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gU3RyaW5nKGVycik7XG59O1xuXG5leHBvcnQgY29uc3QgcnVuV2l0aEZ1ZWwgPSAoXG4gIHNyYzogc3RyaW5nLFxuICBmdWVsID0gMTAwMDAsXG4gIGVudjogUmVjb3JkPHN0cmluZywgdW5rbm93bj4gPSB7fSxcbik6IHJ1blJlcyA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcHJvZ3JhbSA9IHBhcnNlKHNyYyk7XG4gICAgY29uc3QgcHJvdG9FcnJzID0gdmFsaWRhdGVOb1Byb3RvdHlwZShwcm9ncmFtKTtcbiAgICBpZiAocHJvdG9FcnJzLmxlbmd0aCkgcmV0dXJuIHsgZXJyOiBcInByb3RvdHlwZSBhY2Nlc3NcIiwgZnVlbCB9O1xuICAgIHJldHVybiAobmV3IEZ1bmN0aW9uKC4uLk9iamVjdC5rZXlzKGVudikscmVuZGVyUnVubmVyV2l0aEZ1ZWwocHJvZ3JhbSwgZnVlbCkpIGFzICguLi5hcmdzOnVua25vd25bXSkgPT4gcnVuUmVzKSguLi5PYmplY3QudmFsdWVzKGVudikpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmxvZyhcInJ1biB3aXRoIEZ1ZWwgZXJyb3I6IFwiLGVycilcbiAgICByZXR1cm4ge2Vycjogc3RyaW5naWZ5RXJyb3IoZXJyKSwgZnVlbCB9O1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgcnVuV2l0aEZ1ZWxTaGFyZWQgPSAoXG4gIHNyYzogc3RyaW5nLFxuICBmdWVsUmVmOiB7IHZhbHVlOiBudW1iZXIgfSxcbiAgZW52OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiA9IHt9LFxuICBmdWVsUmVmTmFtZSA9IFwiX19mdWVsXCJcbik6IHJ1blJlcyA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcHJvZ3JhbSA9IHBhcnNlKHNyYyk7XG4gICAgY29uc3QgcHJvdG9FcnJzID0gdmFsaWRhdGVOb1Byb3RvdHlwZShwcm9ncmFtKTtcbiAgICBpZiAocHJvdG9FcnJzLmxlbmd0aCkgcmV0dXJuIHsgZXJyOiBcInByb3RvdHlwZSBhY2Nlc3NcIiwgZnVlbDogZnVlbFJlZi52YWx1ZSB9O1xuICAgIGNvbnN0IGNvZGUgPSByZW5kZXJSdW5uZXJXaXRoRnVlbFNoYXJlZChwcm9ncmFtLCBmdWVsUmVmTmFtZSk7XG4gICAgY29uc3QgZnVsbEVudiA9IHsgLi4uZW52LCBbZnVlbFJlZk5hbWVdOiBmdWVsUmVmIH07XG4gICAgcmV0dXJuIChuZXcgRnVuY3Rpb24oLi4uT2JqZWN0LmtleXMoZnVsbEVudiksIGNvZGUpIGFzICguLi5hcmdzOnVua25vd25bXSkgPT4gcnVuUmVzKSguLi5PYmplY3QudmFsdWVzKGZ1bGxFbnYpKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIHsgZXJyOiBzdHJpbmdpZnlFcnJvcihlcnIpLCBmdWVsOiBmdWVsUmVmLnZhbHVlIH07XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBydW5XaXRoRnVlbEFzeW5jID0gYXN5bmMgKFxuICBzcmM6IHN0cmluZyxcbiAgZnVlbCA9IDEwMDAwLFxuICBlbnY6IFJlY29yZDxzdHJpbmcsIHVua25vd24+ID0ge31cbik6IFByb21pc2U8cnVuUmVzPiA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcHJvZ3JhbSA9IHBhcnNlKHNyYyk7XG4gICAgY29uc3QgcHJvdG9FcnJzID0gdmFsaWRhdGVOb1Byb3RvdHlwZShwcm9ncmFtKTtcbiAgICBpZiAocHJvdG9FcnJzLmxlbmd0aCkgcmV0dXJuIHsgZXJyOiBcInByb3RvdHlwZSBhY2Nlc3NcIiwgZnVlbCB9O1xuICAgIGNvbnN0IGNvZGUgPSByZW5kZXJSdW5uZXJXaXRoRnVlbEFzeW5jKHByb2dyYW0sIGZ1ZWwpO1xuICAgIGNvbnN0IGZuID0gbmV3IEZ1bmN0aW9uKC4uLk9iamVjdC5rZXlzKGVudiksIGNvZGUpIGFzICguLi5hcmdzOnVua25vd25bXSkgPT4gUHJvbWlzZTxydW5SZXM+O1xuICAgIHJldHVybiBhd2FpdCBmbiguLi5PYmplY3QudmFsdWVzKGVudikpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4geyBlcnI6IHN0cmluZ2lmeUVycm9yKGVyciksIGZ1ZWwgfTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlID0gKHNyYzogc3RyaW5nKTogUHJvZ3JhbSA9PiB7XG4gIGNvbnN0IHRva2VucyA9IHRva2VuaXplKHNyYyk7XG4gIGxldCBpID0gMDtcbiAgY29uc3QgcGVlayA9ICgpID0+IHRva2Vuc1tpXTtcbiAgY29uc3QgbmV4dCA9ICgpID0+IHRva2Vuc1tpKytdO1xuICBjb25zdCBlYXQgPSAodHlwZTogVG9rZW5UeXBlLCB2YWx1ZT86IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IHQgPSBwZWVrKCk7XG4gICAgaWYgKHQudHlwZSAhPT0gdHlwZSB8fCAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0LnZhbHVlICE9PSB2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgJHt2YWx1ZSA/PyB0eXBlfSBhdCAke3QucG9zfWApO1xuICAgIH1cbiAgICByZXR1cm4gbmV4dCgpO1xuICB9O1xuICBjb25zdCBtYXRjaCA9ICh0eXBlOiBUb2tlblR5cGUsIHZhbHVlPzogc3RyaW5nKSA9PiB7XG4gICAgY29uc3QgdCA9IHBlZWsoKTtcbiAgICByZXR1cm4gdC50eXBlID09PSB0eXBlICYmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHQudmFsdWUgPT09IHZhbHVlKTtcbiAgfTtcblxuICBjb25zdCBwYXJzZVByb2dyYW0gPSAoKTogUHJvZ3JhbSA9PiB7XG4gICAgY29uc3QgYm9keTogU3RtdFtdID0gW107XG4gICAgd2hpbGUgKCFtYXRjaChcImVvZlwiKSkgYm9keS5wdXNoKHBhcnNlU3RhdGVtZW50KCkpO1xuICAgIHJldHVybiB7IHR5cGU6IFwiUHJvZ3JhbVwiLCBib2R5IH07XG4gIH07XG5cbiAgY29uc3QgcGFyc2VTdGF0ZW1lbnQgPSAoKTogU3RtdCA9PiB7XG4gICAgaWYgKG1hdGNoKFwicHVuY3RcIiwgXCJ7XCIpKSByZXR1cm4gcGFyc2VCbG9jaygpO1xuICAgIGlmIChtYXRjaChcImtleXdvcmRcIiwgXCJpZlwiKSkgcmV0dXJuIHBhcnNlSWYoKTtcbiAgICBpZiAobWF0Y2goXCJrZXl3b3JkXCIsIFwid2hpbGVcIikpIHJldHVybiBwYXJzZVdoaWxlKCk7XG4gICAgaWYgKG1hdGNoKFwia2V5d29yZFwiLCBcImZvclwiKSkgcmV0dXJuIHBhcnNlRm9yKCk7XG4gICAgaWYgKG1hdGNoKFwia2V5d29yZFwiLCBcImJyZWFrXCIpKSB7IG5leHQoKTsgaWYgKG1hdGNoKFwicHVuY3RcIiwgXCI7XCIpKSBuZXh0KCk7IHJldHVybiB7IHR5cGU6IFwiQnJlYWtTdGF0ZW1lbnRcIiB9OyB9XG4gICAgaWYgKG1hdGNoKFwia2V5d29yZFwiLCBcImNvbnRpbnVlXCIpKSB7IG5leHQoKTsgaWYgKG1hdGNoKFwicHVuY3RcIiwgXCI7XCIpKSBuZXh0KCk7IHJldHVybiB7IHR5cGU6IFwiQ29udGludWVTdGF0ZW1lbnRcIiB9OyB9XG4gICAgaWYgKG1hdGNoKFwia2V5d29yZFwiLCBcInJldHVyblwiKSkgcmV0dXJuIHBhcnNlUmV0dXJuKCk7XG4gICAgaWYgKG1hdGNoKFwia2V5d29yZFwiLCBcImxldFwiKSB8fCBtYXRjaChcImtleXdvcmRcIiwgXCJjb25zdFwiKSkgcmV0dXJuIHBhcnNlVmFyRGVjbCgpO1xuICAgIGNvbnN0IGV4cHIgPSBwYXJzZUV4cHJlc3Npb24oKTtcbiAgICBpZiAobWF0Y2goXCJwdW5jdFwiLCBcIjtcIikpIG5leHQoKTtcbiAgICByZXR1cm4geyB0eXBlOiBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIiwgZXhwcmVzc2lvbjogZXhwciB9O1xuICB9O1xuXG4gIGNvbnN0IHBhcnNlQmxvY2sgPSAoKTogQmxvY2tTdGF0ZW1lbnQgPT4ge1xuICAgIGVhdChcInB1bmN0XCIsIFwie1wiKTtcbiAgICBjb25zdCBib2R5OiBTdG10W10gPSBbXTtcbiAgICB3aGlsZSAoIW1hdGNoKFwicHVuY3RcIiwgXCJ9XCIpKSBib2R5LnB1c2gocGFyc2VTdGF0ZW1lbnQoKSk7XG4gICAgZWF0KFwicHVuY3RcIiwgXCJ9XCIpO1xuICAgIHJldHVybiB7IHR5cGU6IFwiQmxvY2tTdGF0ZW1lbnRcIiwgYm9keSB9O1xuICB9O1xuXG4gIGNvbnN0IHBhcnNlSWYgPSAoKTogU3RtdCA9PiB7XG4gICAgZWF0KFwia2V5d29yZFwiLCBcImlmXCIpO1xuICAgIGVhdChcInB1bmN0XCIsIFwiKFwiKTtcbiAgICBjb25zdCB0ZXN0ID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgZWF0KFwicHVuY3RcIiwgXCIpXCIpO1xuICAgIGNvbnN0IGNvbnNlcXVlbnQgPSBwYXJzZVN0YXRlbWVudCgpO1xuICAgIGNvbnN0IGFsdGVybmF0ZSA9IG1hdGNoKFwia2V5d29yZFwiLCBcImVsc2VcIikgPyAobmV4dCgpLCBwYXJzZVN0YXRlbWVudCgpKSA6IG51bGw7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJJZlN0YXRlbWVudFwiLCB0ZXN0LCBjb25zZXF1ZW50LCBhbHRlcm5hdGUgfTtcbiAgfTtcblxuICBjb25zdCBwYXJzZVJldHVybiA9ICgpOiBTdG10ID0+IHtcbiAgICBlYXQoXCJrZXl3b3JkXCIsIFwicmV0dXJuXCIpO1xuICAgIGlmIChtYXRjaChcInB1bmN0XCIsIFwiO1wiKSkge1xuICAgICAgbmV4dCgpO1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJSZXR1cm5TdGF0ZW1lbnRcIiwgYXJndW1lbnQ6IG51bGwgfTtcbiAgICB9XG4gICAgY29uc3QgYXJndW1lbnQgPSBtYXRjaChcInB1bmN0XCIsIFwifVwiKSA/IG51bGwgOiBwYXJzZUV4cHJlc3Npb24oKTtcbiAgICBpZiAobWF0Y2goXCJwdW5jdFwiLCBcIjtcIikpIG5leHQoKTtcbiAgICByZXR1cm4geyB0eXBlOiBcIlJldHVyblN0YXRlbWVudFwiLCBhcmd1bWVudCB9O1xuICB9O1xuXG4gIGNvbnN0IHBhcnNlVmFyRGVjbENvcmUgPSAoY29uc3VtZVNlbWk6IGJvb2xlYW4pID0+IHtcbiAgICBjb25zdCBraW5kID0gbmV4dCgpLnZhbHVlIGFzIFwibGV0XCIgfCBcImNvbnN0XCI7XG4gICAgY29uc3QgZGVjbGFyYXRpb25zOiBWYXJEZWNsW10gPSBbXTtcbiAgICBkbyB7XG4gICAgICBjb25zdCBpZCA9IHBhcnNlUGF0dGVybigpO1xuICAgICAgY29uc3QgaW5pdCA9IG1hdGNoKFwib3BlcmF0b3JcIiwgXCI9XCIpID8gKG5leHQoKSwgcGFyc2VFeHByZXNzaW9uKCkpIDogbnVsbDtcbiAgICAgIGRlY2xhcmF0aW9ucy5wdXNoKHsgdHlwZTogXCJWYXJpYWJsZURlY2xhcmF0b3JcIiwgaWQsIGluaXQgfSk7XG4gICAgICBpZiAoIW1hdGNoKFwicHVuY3RcIiwgXCIsXCIpKSBicmVhaztcbiAgICAgIG5leHQoKTtcbiAgICB9IHdoaWxlICh0cnVlKTtcbiAgICBpZiAoY29uc3VtZVNlbWkgJiYgbWF0Y2goXCJwdW5jdFwiLCBcIjtcIikpIG5leHQoKTtcbiAgICByZXR1cm4geyBraW5kLCBkZWNsYXJhdGlvbnMgfTtcbiAgfTtcblxuICBjb25zdCBwYXJzZVZhckRlY2wgPSAoKTogU3RtdCA9PiB7XG4gICAgY29uc3QgeyBraW5kLCBkZWNsYXJhdGlvbnMgfSA9IHBhcnNlVmFyRGVjbENvcmUodHJ1ZSk7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIsIGtpbmQsIGRlY2xhcmF0aW9ucyB9O1xuICB9O1xuXG4gIGNvbnN0IHBhcnNlV2hpbGUgPSAoKTogU3RtdCA9PiB7XG4gICAgZWF0KFwia2V5d29yZFwiLCBcIndoaWxlXCIpO1xuICAgIGVhdChcInB1bmN0XCIsIFwiKFwiKTtcbiAgICBjb25zdCB0ZXN0ID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgZWF0KFwicHVuY3RcIiwgXCIpXCIpO1xuICAgIGNvbnN0IGJvZHkgPSBwYXJzZVN0YXRlbWVudCgpO1xuICAgIHJldHVybiB7IHR5cGU6IFwiV2hpbGVTdGF0ZW1lbnRcIiwgdGVzdCwgYm9keSB9O1xuICB9O1xuXG4gIGNvbnN0IHBhcnNlRm9yID0gKCk6IFN0bXQgPT4ge1xuICAgIGVhdChcImtleXdvcmRcIiwgXCJmb3JcIik7XG4gICAgZWF0KFwicHVuY3RcIiwgXCIoXCIpO1xuICAgIGxldCBpbml0OiBWYXJEZWNsW10gfCBFeHByIHwgbnVsbCA9IG51bGw7XG4gICAgbGV0IGluaXRLaW5kOiBcImxldFwiIHwgXCJjb25zdFwiIHwgbnVsbCA9IG51bGw7XG4gICAgaWYgKCFtYXRjaChcInB1bmN0XCIsIFwiO1wiKSkge1xuICAgICAgaWYgKG1hdGNoKFwia2V5d29yZFwiLCBcImxldFwiKSB8fCBtYXRjaChcImtleXdvcmRcIiwgXCJjb25zdFwiKSkge1xuICAgICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZVZhckRlY2xDb3JlKGZhbHNlKTtcbiAgICAgICAgaW5pdCA9IHBhcnNlZC5kZWNsYXJhdGlvbnM7XG4gICAgICAgIGluaXRLaW5kID0gcGFyc2VkLmtpbmQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbml0ID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtYXRjaChcImtleXdvcmRcIiwgXCJpblwiKSB8fCBtYXRjaChcImtleXdvcmRcIiwgXCJvZlwiKSkge1xuICAgICAgY29uc3Qga2luZCA9IG5leHQoKS52YWx1ZTtcbiAgICAgIGNvbnN0IHJpZ2h0ID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICBlYXQoXCJwdW5jdFwiLCBcIilcIik7XG4gICAgICBjb25zdCBib2R5ID0gcGFyc2VTdGF0ZW1lbnQoKTtcbiAgICAgIGlmICghaW5pdCkgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBpbml0aWFsaXplciBiZWZvcmUgJHtraW5kfSBhdCAke3BlZWsoKS5wb3N9YCk7XG4gICAgICByZXR1cm4ga2luZCA9PT0gXCJpblwiXG4gICAgICAgID8geyB0eXBlOiBcIkZvckluU3RhdGVtZW50XCIsIGxlZnQ6IGluaXQsIGxlZnRLaW5kOiBpbml0S2luZCwgcmlnaHQsIGJvZHkgfVxuICAgICAgICA6IHsgdHlwZTogXCJGb3JPZlN0YXRlbWVudFwiLCBsZWZ0OiBpbml0LCBsZWZ0S2luZDogaW5pdEtpbmQsIHJpZ2h0LCBib2R5IH07XG4gICAgfVxuICAgIGVhdChcInB1bmN0XCIsIFwiO1wiKTtcbiAgICBjb25zdCB0ZXN0ID0gbWF0Y2goXCJwdW5jdFwiLCBcIjtcIikgPyBudWxsIDogcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgZWF0KFwicHVuY3RcIiwgXCI7XCIpO1xuICAgIGNvbnN0IHVwZGF0ZSA9IG1hdGNoKFwicHVuY3RcIiwgXCIpXCIpID8gbnVsbCA6IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgIGVhdChcInB1bmN0XCIsIFwiKVwiKTtcbiAgICBjb25zdCBib2R5ID0gcGFyc2VTdGF0ZW1lbnQoKTtcbiAgICByZXR1cm4geyB0eXBlOiBcIkZvclN0YXRlbWVudFwiLCBpbml0LCBpbml0S2luZCwgdGVzdCwgdXBkYXRlLCBib2R5IH07XG4gIH07XG5cbiAgY29uc3QgcGFyc2VFeHByZXNzaW9uID0gKCk6IEV4cHIgPT4gcGFyc2VBc3NpZ25tZW50KCk7XG5cbiAgY29uc3QgcGFyc2VBc3NpZ25tZW50ID0gKCk6IEV4cHIgPT4ge1xuICAgIGNvbnN0IGxlZnQgPSBwYXJzZUNvbmRpdGlvbmFsKCk7XG4gICAgaWYgKG1hdGNoKFwib3BlcmF0b3JcIiwgXCI9XCIpIHx8IG1hdGNoKFwib3BlcmF0b3JcIiwgXCIrPVwiKSB8fCBtYXRjaChcIm9wZXJhdG9yXCIsIFwiLT1cIikgfHwgbWF0Y2goXCJvcGVyYXRvclwiLCBcIio9XCIpIHx8IG1hdGNoKFwib3BlcmF0b3JcIiwgXCIvPVwiKSB8fCBtYXRjaChcIm9wZXJhdG9yXCIsIFwiJT1cIikpIHtcbiAgICAgIGNvbnN0IG9wID0gbmV4dCgpLnZhbHVlO1xuICAgICAgY29uc3QgcmlnaHQgPSBwYXJzZUFzc2lnbm1lbnQoKTtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwiQXNzaWdubWVudEV4cHJlc3Npb25cIiwgb3BlcmF0b3I6IG9wLCBsZWZ0LCByaWdodCB9O1xuICAgIH1cbiAgICByZXR1cm4gbGVmdDtcbiAgfTtcblxuICBjb25zdCBwYXJzZUNvbmRpdGlvbmFsID0gKCk6IEV4cHIgPT4ge1xuICAgIGxldCB0ZXN0ID0gcGFyc2VMb2dpY2FsT3IoKTtcbiAgICBpZiAobWF0Y2goXCJvcGVyYXRvclwiLCBcIj9cIikpIHtcbiAgICAgIG5leHQoKTtcbiAgICAgIGNvbnN0IGNvbnNlcXVlbnQgPSBwYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgIGVhdChcIm9wZXJhdG9yXCIsIFwiOlwiKTtcbiAgICAgIGNvbnN0IGFsdGVybmF0ZSA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIiwgdGVzdCwgY29uc2VxdWVudCwgYWx0ZXJuYXRlIH07XG4gICAgfVxuICAgIHJldHVybiB0ZXN0O1xuICB9O1xuXG4gIGNvbnN0IHBhcnNlTG9naWNhbE9yID0gKCk6IEV4cHIgPT4ge1xuICAgIGxldCBsZWZ0ID0gcGFyc2VMb2dpY2FsQW5kKCk7XG4gICAgd2hpbGUgKG1hdGNoKFwib3BlcmF0b3JcIiwgXCJ8fFwiKSkge1xuICAgICAgY29uc3Qgb3AgPSBuZXh0KCkudmFsdWU7XG4gICAgICBjb25zdCByaWdodCA9IHBhcnNlTG9naWNhbEFuZCgpO1xuICAgICAgbGVmdCA9IHsgdHlwZTogXCJMb2dpY2FsRXhwcmVzc2lvblwiLCBvcGVyYXRvcjogb3AsIGxlZnQsIHJpZ2h0IH07XG4gICAgfVxuICAgIHJldHVybiBsZWZ0O1xuICB9O1xuXG4gIGNvbnN0IHBhcnNlTG9naWNhbEFuZCA9ICgpOiBFeHByID0+IHtcbiAgICBsZXQgbGVmdCA9IHBhcnNlRXF1YWxpdHkoKTtcbiAgICB3aGlsZSAobWF0Y2goXCJvcGVyYXRvclwiLCBcIiYmXCIpKSB7XG4gICAgICBjb25zdCBvcCA9IG5leHQoKS52YWx1ZTtcbiAgICAgIGNvbnN0IHJpZ2h0ID0gcGFyc2VFcXVhbGl0eSgpO1xuICAgICAgbGVmdCA9IHsgdHlwZTogXCJMb2dpY2FsRXhwcmVzc2lvblwiLCBvcGVyYXRvcjogb3AsIGxlZnQsIHJpZ2h0IH07XG4gICAgfVxuICAgIHJldHVybiBsZWZ0O1xuICB9O1xuXG4gIGNvbnN0IHBhcnNlRXF1YWxpdHkgPSAoKTogRXhwciA9PiB7XG4gICAgbGV0IGxlZnQgPSBwYXJzZVJlbGF0aW9uYWwoKTtcbiAgICB3aGlsZSAobWF0Y2goXCJvcGVyYXRvclwiLCBcIj09XCIpIHx8IG1hdGNoKFwib3BlcmF0b3JcIiwgXCIhPVwiKSB8fCBtYXRjaChcIm9wZXJhdG9yXCIsIFwiPT09XCIpIHx8IG1hdGNoKFwib3BlcmF0b3JcIiwgXCIhPT1cIikpIHtcbiAgICAgIGNvbnN0IG9wID0gbmV4dCgpLnZhbHVlO1xuICAgICAgY29uc3QgcmlnaHQgPSBwYXJzZVJlbGF0aW9uYWwoKTtcbiAgICAgIGxlZnQgPSB7IHR5cGU6IFwiQmluYXJ5RXhwcmVzc2lvblwiLCBvcGVyYXRvcjogb3AsIGxlZnQsIHJpZ2h0IH07XG4gICAgfVxuICAgIHJldHVybiBsZWZ0O1xuICB9O1xuXG4gIGNvbnN0IHBhcnNlUmVsYXRpb25hbCA9ICgpOiBFeHByID0+IHtcbiAgICBsZXQgbGVmdCA9IHBhcnNlQWRkaXRpdmUoKTtcbiAgICB3aGlsZSAobWF0Y2goXCJvcGVyYXRvclwiLCBcIjxcIikgfHwgbWF0Y2goXCJvcGVyYXRvclwiLCBcIjw9XCIpIHx8IG1hdGNoKFwib3BlcmF0b3JcIiwgXCI+XCIpIHx8IG1hdGNoKFwib3BlcmF0b3JcIiwgXCI+PVwiKSkge1xuICAgICAgY29uc3Qgb3AgPSBuZXh0KCkudmFsdWU7XG4gICAgICBjb25zdCByaWdodCA9IHBhcnNlQWRkaXRpdmUoKTtcbiAgICAgIGxlZnQgPSB7IHR5cGU6IFwiQmluYXJ5RXhwcmVzc2lvblwiLCBvcGVyYXRvcjogb3AsIGxlZnQsIHJpZ2h0IH07XG4gICAgfVxuICAgIHJldHVybiBsZWZ0O1xuICB9O1xuXG4gIGNvbnN0IHBhcnNlQWRkaXRpdmUgPSAoKTogRXhwciA9PiB7XG4gICAgbGV0IGxlZnQgPSBwYXJzZU11bHRpcGxpY2F0aXZlKCk7XG4gICAgd2hpbGUgKG1hdGNoKFwib3BlcmF0b3JcIiwgXCIrXCIpIHx8IG1hdGNoKFwib3BlcmF0b3JcIiwgXCItXCIpKSB7XG4gICAgICBjb25zdCBvcCA9IG5leHQoKS52YWx1ZTtcbiAgICAgIGNvbnN0IHJpZ2h0ID0gcGFyc2VNdWx0aXBsaWNhdGl2ZSgpO1xuICAgICAgbGVmdCA9IHsgdHlwZTogXCJCaW5hcnlFeHByZXNzaW9uXCIsIG9wZXJhdG9yOiBvcCwgbGVmdCwgcmlnaHQgfTtcbiAgICB9XG4gICAgcmV0dXJuIGxlZnQ7XG4gIH07XG5cbiAgY29uc3QgcGFyc2VNdWx0aXBsaWNhdGl2ZSA9ICgpOiBFeHByID0+IHtcbiAgICBsZXQgbGVmdCA9IHBhcnNlVW5hcnkoKTtcbiAgICB3aGlsZSAobWF0Y2goXCJvcGVyYXRvclwiLCBcIipcIikgfHwgbWF0Y2goXCJvcGVyYXRvclwiLCBcIi9cIikgfHwgbWF0Y2goXCJvcGVyYXRvclwiLCBcIiVcIikpIHtcbiAgICAgIGNvbnN0IG9wID0gbmV4dCgpLnZhbHVlO1xuICAgICAgY29uc3QgcmlnaHQgPSBwYXJzZVVuYXJ5KCk7XG4gICAgICBsZWZ0ID0geyB0eXBlOiBcIkJpbmFyeUV4cHJlc3Npb25cIiwgb3BlcmF0b3I6IG9wLCBsZWZ0LCByaWdodCB9O1xuICAgIH1cbiAgICByZXR1cm4gbGVmdDtcbiAgfTtcblxuICBjb25zdCBwYXJzZVVuYXJ5ID0gKCk6IEV4cHIgPT4ge1xuICAgIGlmIChtYXRjaChcIm9wZXJhdG9yXCIsIFwiKytcIikgfHwgbWF0Y2goXCJvcGVyYXRvclwiLCBcIi0tXCIpKSB7XG4gICAgICBjb25zdCBvcCA9IG5leHQoKS52YWx1ZSBhcyBcIisrXCIgfCBcIi0tXCI7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIlVwZGF0ZUV4cHJlc3Npb25cIiwgb3BlcmF0b3I6IG9wLCBhcmd1bWVudDogcGFyc2VVbmFyeSgpLCBwcmVmaXg6IHRydWUgfTtcbiAgICB9XG4gICAgaWYgKG1hdGNoKFwib3BlcmF0b3JcIiwgXCIhXCIpIHx8IG1hdGNoKFwib3BlcmF0b3JcIiwgXCItXCIpIHx8IG1hdGNoKFwib3BlcmF0b3JcIiwgXCIrXCIpKSB7XG4gICAgICBjb25zdCBvcCA9IG5leHQoKS52YWx1ZTtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwiVW5hcnlFeHByZXNzaW9uXCIsIG9wZXJhdG9yOiBvcCwgYXJndW1lbnQ6IHBhcnNlVW5hcnkoKSB9O1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VQb3N0Zml4KCk7XG4gIH07XG5cbiAgY29uc3QgcGFyc2VQb3N0Zml4ID0gKCk6IEV4cHIgPT4ge1xuICAgIGxldCBleHByID0gcGFyc2VBcnJvd09yUHJpbWFyeSgpO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAobWF0Y2goXCJvcGVyYXRvclwiLCBcIisrXCIpIHx8IG1hdGNoKFwib3BlcmF0b3JcIiwgXCItLVwiKSkge1xuICAgICAgICBjb25zdCBvcCA9IG5leHQoKS52YWx1ZSBhcyBcIisrXCIgfCBcIi0tXCI7XG4gICAgICAgIGV4cHIgPSB7IHR5cGU6IFwiVXBkYXRlRXhwcmVzc2lvblwiLCBvcGVyYXRvcjogb3AsIGFyZ3VtZW50OiBleHByLCBwcmVmaXg6IGZhbHNlIH07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKG1hdGNoKFwicHVuY3RcIiwgXCIoXCIpKSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBwYXJzZUFyZ3VtZW50cygpO1xuICAgICAgICBleHByID0geyB0eXBlOiBcIkNhbGxFeHByZXNzaW9uXCIsIGNhbGxlZTogZXhwciwgYXJndW1lbnRzOiBhcmdzIH07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKG1hdGNoKFwicHVuY3RcIiwgXCIuXCIpKSB7XG4gICAgICAgIG5leHQoKTtcbiAgICAgICAgY29uc3QgcHJvcCA9IHBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgICBleHByID0geyB0eXBlOiBcIk1lbWJlckV4cHJlc3Npb25cIiwgb2JqZWN0OiBleHByLCBwcm9wZXJ0eTogcHJvcCwgY29tcHV0ZWQ6IGZhbHNlIH07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKG1hdGNoKFwicHVuY3RcIiwgXCJbXCIpKSB7XG4gICAgICAgIG5leHQoKTtcbiAgICAgICAgY29uc3QgcHJvcCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICBlYXQoXCJwdW5jdFwiLCBcIl1cIik7XG4gICAgICAgIGV4cHIgPSB7IHR5cGU6IFwiTWVtYmVyRXhwcmVzc2lvblwiLCBvYmplY3Q6IGV4cHIsIHByb3BlcnR5OiBwcm9wLCBjb21wdXRlZDogdHJ1ZSB9O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gZXhwcjtcbiAgfTtcblxuICBjb25zdCBwYXJzZUFycm93T3JQcmltYXJ5ID0gKCk6IEV4cHIgPT4ge1xuICAgIGlmIChtYXRjaChcImlkZW50aWZpZXJcIikpIHtcbiAgICAgIGNvbnN0IGlkID0gcGFyc2VJZGVudGlmaWVyKCk7XG4gICAgICBpZiAobWF0Y2goXCJvcGVyYXRvclwiLCBcIj0+XCIpKSB7XG4gICAgICAgIG5leHQoKTtcbiAgICAgICAgY29uc3QgYm9keSA9IG1hdGNoKFwicHVuY3RcIiwgXCJ7XCIpID8gcGFyc2VCbG9jaygpIDogcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiwgcGFyYW1zOiBbaWRdLCBib2R5IH07XG4gICAgICB9XG4gICAgICByZXR1cm4gaWQ7XG4gICAgfVxuICAgIGlmIChtYXRjaChcInB1bmN0XCIsIFwiKFwiKSkge1xuICAgICAgY29uc3Qgc3RhcnQgPSBpO1xuICAgICAgbmV4dCgpO1xuICAgICAgY29uc3QgcGFyYW1zOiBJZGVudGlmaWVyW10gPSBbXTtcbiAgICAgIGxldCBpc1BhcmFtcyA9IHRydWU7XG4gICAgICBpZiAoIW1hdGNoKFwicHVuY3RcIiwgXCIpXCIpKSB7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBpZiAoIW1hdGNoKFwiaWRlbnRpZmllclwiKSkgeyBpc1BhcmFtcyA9IGZhbHNlOyBicmVhazsgfVxuICAgICAgICAgIHBhcmFtcy5wdXNoKHBhcnNlSWRlbnRpZmllcigpKTtcbiAgICAgICAgICBpZiAoIW1hdGNoKFwicHVuY3RcIiwgXCIsXCIpKSBicmVhaztcbiAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH0gd2hpbGUgKHRydWUpO1xuICAgICAgfVxuICAgICAgaWYgKGlzUGFyYW1zICYmIG1hdGNoKFwicHVuY3RcIiwgXCIpXCIpKSB7XG4gICAgICAgIG5leHQoKTtcbiAgICAgICAgaWYgKG1hdGNoKFwib3BlcmF0b3JcIiwgXCI9PlwiKSkge1xuICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICBjb25zdCBib2R5ID0gbWF0Y2goXCJwdW5jdFwiLCBcIntcIikgPyBwYXJzZUJsb2NrKCkgOiBwYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgICByZXR1cm4geyB0eXBlOiBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIsIHBhcmFtcywgYm9keSB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpID0gc3RhcnQ7XG4gICAgICBlYXQoXCJwdW5jdFwiLCBcIihcIik7XG4gICAgICBjb25zdCBleHByID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICBlYXQoXCJwdW5jdFwiLCBcIilcIik7XG4gICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlUHJpbWFyeSgpO1xuICB9O1xuXG4gIGNvbnN0IHBhcnNlUHJpbWFyeSA9ICgpOiBFeHByID0+IHtcbiAgICBpZiAobWF0Y2goXCJudW1iZXJcIikpIHJldHVybiB7IHR5cGU6IFwiTGl0ZXJhbFwiLCB2YWx1ZTogTnVtYmVyKG5leHQoKS52YWx1ZSkgfTtcbiAgICBpZiAobWF0Y2goXCJzdHJpbmdcIikpIHJldHVybiB7IHR5cGU6IFwiTGl0ZXJhbFwiLCB2YWx1ZTogbmV4dCgpLnZhbHVlIH07XG4gICAgaWYgKG1hdGNoKFwia2V5d29yZFwiLCBcInRydWVcIikpIHsgbmV4dCgpOyByZXR1cm4geyB0eXBlOiBcIkxpdGVyYWxcIiwgdmFsdWU6IHRydWUgfTsgfVxuICAgIGlmIChtYXRjaChcImtleXdvcmRcIiwgXCJmYWxzZVwiKSkgeyBuZXh0KCk7IHJldHVybiB7IHR5cGU6IFwiTGl0ZXJhbFwiLCB2YWx1ZTogZmFsc2UgfTsgfVxuICAgIGlmIChtYXRjaChcImtleXdvcmRcIiwgXCJudWxsXCIpKSB7IG5leHQoKTsgcmV0dXJuIHsgdHlwZTogXCJMaXRlcmFsXCIsIHZhbHVlOiBudWxsIH07IH1cbiAgICBpZiAobWF0Y2goXCJwdW5jdFwiLCBcIltcIikpIHJldHVybiBwYXJzZUFycmF5KCk7XG4gICAgaWYgKG1hdGNoKFwicHVuY3RcIiwgXCJ7XCIpKSByZXR1cm4gcGFyc2VPYmplY3QoKTtcbiAgICBpZiAobWF0Y2goXCJpZGVudGlmaWVyXCIpKSByZXR1cm4gcGFyc2VJZGVudGlmaWVyKCk7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIHRva2VuICR7cGVlaygpLnR5cGV9ICR7cGVlaygpLnZhbHVlfSBhdCAke3BlZWsoKS5wb3N9YCk7XG4gIH07XG5cbiAgY29uc3QgcGFyc2VBcnJheSA9ICgpOiBFeHByID0+IHtcbiAgICBlYXQoXCJwdW5jdFwiLCBcIltcIik7XG4gICAgY29uc3QgZWxlbWVudHM6IEV4cHJbXSA9IFtdO1xuICAgIGlmICghbWF0Y2goXCJwdW5jdFwiLCBcIl1cIikpIHtcbiAgICAgIGRvIHtcbiAgICAgICAgZWxlbWVudHMucHVzaChwYXJzZUV4cHJlc3Npb24oKSk7XG4gICAgICAgIGlmICghbWF0Y2goXCJwdW5jdFwiLCBcIixcIikpIGJyZWFrO1xuICAgICAgICBuZXh0KCk7XG4gICAgICB9IHdoaWxlICh0cnVlKTtcbiAgICB9XG4gICAgZWF0KFwicHVuY3RcIiwgXCJdXCIpO1xuICAgIHJldHVybiB7IHR5cGU6IFwiQXJyYXlFeHByZXNzaW9uXCIsIGVsZW1lbnRzIH07XG4gIH07XG5cbiAgY29uc3QgcGFyc2VPYmplY3QgPSAoKTogRXhwciA9PiB7XG4gICAgZWF0KFwicHVuY3RcIiwgXCJ7XCIpO1xuICAgIGNvbnN0IHByb3BlcnRpZXM6IFByb3BlcnR5W10gPSBbXTtcbiAgICBpZiAoIW1hdGNoKFwicHVuY3RcIiwgXCJ9XCIpKSB7XG4gICAgICBkbyB7XG4gICAgICAgIGxldCBrZXk6IElkZW50aWZpZXIgfCBMaXRlcmFsO1xuICAgICAgICBsZXQgc2hvcnRoYW5kID0gZmFsc2U7XG4gICAgICAgIGlmIChtYXRjaChcImlkZW50aWZpZXJcIikpIGtleSA9IHBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgICBlbHNlIGlmIChtYXRjaChcInN0cmluZ1wiKSkga2V5ID0geyB0eXBlOiBcIkxpdGVyYWxcIiwgdmFsdWU6IG5leHQoKS52YWx1ZSB9O1xuICAgICAgICBlbHNlIGlmIChtYXRjaChcIm51bWJlclwiKSkga2V5ID0geyB0eXBlOiBcIkxpdGVyYWxcIiwgdmFsdWU6IE51bWJlcihuZXh0KCkudmFsdWUpIH07XG4gICAgICAgIGVsc2UgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBvYmplY3Qga2V5IGF0ICR7cGVlaygpLnBvc31gKTtcbiAgICAgICAgbGV0IHZhbHVlOiBFeHByO1xuICAgICAgICBpZiAobWF0Y2goXCJvcGVyYXRvclwiLCBcIjpcIikpIHtcbiAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgdmFsdWUgPSBwYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoa2V5LnR5cGUgIT09IFwiSWRlbnRpZmllclwiKSB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkICc6JyBhZnRlciBrZXkgYXQgJHtwZWVrKCkucG9zfWApO1xuICAgICAgICAgIHZhbHVlID0ga2V5O1xuICAgICAgICAgIHNob3J0aGFuZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcHJvcGVydGllcy5wdXNoKHsgdHlwZTogXCJQcm9wZXJ0eVwiLCBrZXksIHZhbHVlLCBzaG9ydGhhbmQgfSk7XG4gICAgICAgIGlmICghbWF0Y2goXCJwdW5jdFwiLCBcIixcIikpIGJyZWFrO1xuICAgICAgICBuZXh0KCk7XG4gICAgICB9IHdoaWxlICh0cnVlKTtcbiAgICB9XG4gICAgZWF0KFwicHVuY3RcIiwgXCJ9XCIpO1xuICAgIHJldHVybiB7IHR5cGU6IFwiT2JqZWN0RXhwcmVzc2lvblwiLCBwcm9wZXJ0aWVzIH07XG4gIH07XG5cbiAgY29uc3QgcGFyc2VBcmd1bWVudHMgPSAoKTogRXhwcltdID0+IHtcbiAgICBlYXQoXCJwdW5jdFwiLCBcIihcIik7XG4gICAgY29uc3QgYXJnczogRXhwcltdID0gW107XG4gICAgaWYgKCFtYXRjaChcInB1bmN0XCIsIFwiKVwiKSkge1xuICAgICAgZG8ge1xuICAgICAgICBhcmdzLnB1c2gocGFyc2VFeHByZXNzaW9uKCkpO1xuICAgICAgICBpZiAoIW1hdGNoKFwicHVuY3RcIiwgXCIsXCIpKSBicmVhaztcbiAgICAgICAgbmV4dCgpO1xuICAgICAgfSB3aGlsZSAodHJ1ZSk7XG4gICAgfVxuICAgIGVhdChcInB1bmN0XCIsIFwiKVwiKTtcbiAgICByZXR1cm4gYXJncztcbiAgfTtcblxuICBjb25zdCBwYXJzZUlkZW50aWZpZXIgPSAoKTogSWRlbnRpZmllciA9PiB7XG4gICAgY29uc3QgdCA9IGVhdChcImlkZW50aWZpZXJcIik7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJJZGVudGlmaWVyXCIsIG5hbWU6IHQudmFsdWUgfTtcbiAgfTtcblxuICBjb25zdCBwYXJzZVBhdHRlcm4gPSAoKTogUGF0dGVybiA9PiB7XG4gICAgaWYgKG1hdGNoKFwicHVuY3RcIiwgXCJbXCIpKSB7XG4gICAgICBlYXQoXCJwdW5jdFwiLCBcIltcIik7XG4gICAgICBjb25zdCBlbGVtZW50czogSWRlbnRpZmllcltdID0gW107XG4gICAgICBpZiAoIW1hdGNoKFwicHVuY3RcIiwgXCJdXCIpKSB7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKHBhcnNlSWRlbnRpZmllcigpKTtcbiAgICAgICAgICBpZiAoIW1hdGNoKFwicHVuY3RcIiwgXCIsXCIpKSBicmVhaztcbiAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH0gd2hpbGUgKHRydWUpO1xuICAgICAgfVxuICAgICAgZWF0KFwicHVuY3RcIiwgXCJdXCIpO1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJBcnJheVBhdHRlcm5cIiwgZWxlbWVudHMgfTtcbiAgICB9XG4gICAgaWYgKG1hdGNoKFwicHVuY3RcIiwgXCJ7XCIpKSB7XG4gICAgICBlYXQoXCJwdW5jdFwiLCBcIntcIik7XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzOiBJZGVudGlmaWVyW10gPSBbXTtcbiAgICAgIGlmICghbWF0Y2goXCJwdW5jdFwiLCBcIn1cIikpIHtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIHByb3BlcnRpZXMucHVzaChwYXJzZUlkZW50aWZpZXIoKSk7XG4gICAgICAgICAgaWYgKCFtYXRjaChcInB1bmN0XCIsIFwiLFwiKSkgYnJlYWs7XG4gICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9IHdoaWxlICh0cnVlKTtcbiAgICAgIH1cbiAgICAgIGVhdChcInB1bmN0XCIsIFwifVwiKTtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwiT2JqZWN0UGF0dGVyblwiLCBwcm9wZXJ0aWVzIH07XG4gICAgfVxuICAgIHJldHVybiBwYXJzZUlkZW50aWZpZXIoKTtcbiAgfTtcblxuICByZXR1cm4gcGFyc2VQcm9ncmFtKCk7XG59O1xuIiwiaW1wb3J0IHsgc2NoZW1hLCB0YWJsZSwgdCwgU2VuZGVyRXJyb3IgfSBmcm9tICdzcGFjZXRpbWVkYi9zZXJ2ZXInO1xuaW1wb3J0IHsgaGFzaERhdGEsIHNjaGVtYXMsIHRvanNvbiwgdG9wLCB2YWxpZGF0ZSwgZXhwYW5kTGlua3NTeW5jLCBmcm9tanNvbiwgc2VydmVyX2Z1bmN0aW9uLCBub3JtYWxpemVSZWYgfSBmcm9tICcuL25vdGVzJztcbmltcG9ydCB0eXBlIHsgSGFzaCwgUmVmIH0gZnJvbSAnLi9ub3Rlcyc7XG5pbXBvcnQgeyBydW5XaXRoRnVlbFNoYXJlZCB9IGZyb20gJy4vcGFyc2VyJztcbmltcG9ydCB7IGhhc2gxMjggfSBmcm9tICcuL2hhc2gnO1xuXG5cbmNvbnN0IEpzb25Ob3RlcyA9IHRhYmxlKFxuICB7XG4gICAgbmFtZTogJ25vdGUnLFxuICAgIHB1YmxpYzogdHJ1ZSxcbiAgfSwge1xuICAgIGhhc2g6IHQuc3RyaW5nKCkucHJpbWFyeUtleSgpLFxuICAgIHNjaGVtYUhhc2g6IHQuc3RyaW5nKCksXG4gICAgZGF0YTogdC5zdHJpbmcoKSxcbiAgfVxuKTtcblxuY29uc3QgU3RvcmUgPSB0YWJsZShcbiAge1xuICAgIG5hbWU6ICdzdG9yZScsXG4gICAgcHVibGljOiBmYWxzZSxcbiAgfSwge1xuICAgIGtleTogdC5zdHJpbmcoKS5wcmltYXJ5S2V5KCksXG4gICAgdmFsdWU6IHQuc3RyaW5nKClcbiAgfVxuKVxuXG5jb25zdCBMaW5rcyA9IHRhYmxlKFxuICB7XG4gICAgbmFtZTogXCJsaW5rc1wiLFxuICAgIHB1YmxpYzogdHJ1ZVxuICB9LCB7XG4gICAgdG86IHQuc3RyaW5nKCkucHJpbWFyeUtleSgpLFxuICAgIGZyb206IHQuYXJyYXkodC5zdHJpbmcoKSksXG4gIH1cbilcblxuZXhwb3J0IGNvbnN0IHNwYWNldGltZWRiID0gc2NoZW1hKEpzb25Ob3RlcywgTGlua3MsIFN0b3JlKTtcblxuc3BhY2V0aW1lZGIudmlldyh7IG5hbWU6ICdub3RlX2NvdW50JywgcHVibGljOiB0cnVlIH0sIHQuYXJyYXkodC5vYmplY3QoJ05vdGVDb3VudFJvdycsIHsgY291bnQ6IHQudTY0KCkgfSkpLFxuICAoY3R4KSA9PiBbeyBjb3VudDogY3R4LmRiLm5vdGUuY291bnQoKSB9XVxuKTtcblxuXG5cblxuc3BhY2V0aW1lZGIucmVkdWNlcignYWRkX25vdGUnLCB7XG4gIHNjaGVtYUhhc2g6IHQuc3RyaW5nKCksXG4gIGRhdGE6IHQuc3RyaW5nKCksXG59LCAoY3R4LCB7IHNjaGVtYUhhc2gsIGRhdGEgfSApID0+IHtcblxuICBjb25zdCBzY2hlbWFSb3cgPSBjdHguZGIubm90ZS5oYXNoLmZpbmQoc2NoZW1hSGFzaCk7XG4gIGlmICghc2NoZW1hUm93KSB0aHJvdyBuZXcgU2VuZGVyRXJyb3IoJ1NjaGVtYSBub3QgZm91bmQnKTtcblxuICB0cnl7XG4gICAgY29uc3QgcmVzb2x2ZSA9IChyZWY6IFJlZikgPT4ge1xuICAgICAgY29uc3Qgbm90ZSA9IGN0eC5kYi5ub3RlLmhhc2guZmluZChub3JtYWxpemVSZWYocmVmKSk7XG4gICAgICBpZiAoIW5vdGUpIHRocm93IG5ldyBTZW5kZXJFcnJvcignTm90ZSBub3QgZm91bmQnKTtcbiAgICAgIHJldHVybiBmcm9tanNvbihub3RlLmRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBwYXJzZWQgPSBmcm9tanNvbihkYXRhKVxuICAgIGNvbnN0IGV4cGFuZGVkSnNvbiA9IGV4cGFuZExpbmtzU3luYyhwYXJzZWQsIHJlc29sdmUpO1xuICAgIGNvbnN0IGV4cGFuZGVkU2NoZW1hID0gZXhwYW5kTGlua3NTeW5jKGZyb21qc29uKHNjaGVtYVJvdy5kYXRhKSwgcmVzb2x2ZSk7XG4gICAgdmFsaWRhdGUoZXhwYW5kZWRKc29uLCBleHBhbmRlZFNjaGVtYSlcblxuICAgIGNvbnN0IGhhc2ggPSBoYXNoRGF0YSh7c2NoZW1hSGFzaDogc2NoZW1hSGFzaCBhcyBIYXNoLCBkYXRhOiBwYXJzZWR9KVxuXG4gICAgY29uc3QgZXhpc3RpbmcgPSBjdHguZGIubm90ZS5oYXNoLmZpbmQoaGFzaCk7XG4gICAgaWYgKGV4aXN0aW5nKSByZXR1cm47XG5cbiAgICBjdHguZGIubm90ZS5pbnNlcnQoeyBoYXNoLCBzY2hlbWFIYXNoLCBkYXRhIH0pXG5cbiAgICBjb25zdCB0YXJnZXRzID0gbmV3IFNldDxzdHJpbmc+KFtzY2hlbWFSb3cuaGFzaF0pO1xuICAgIGNvbnN0IHJlID0gLyMoW2EtZjAtOV17MzJ9KS9nO1xuICAgIGxldCBtYXRjaDogUmVnRXhwRXhlY0FycmF5IHwgbnVsbDtcbiAgICB3aGlsZSAoKG1hdGNoID0gcmUuZXhlYyhkYXRhKSkpIHtcbiAgICAgIHRhcmdldHMuYWRkKG1hdGNoWzFdKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCB0byBvZiB0YXJnZXRzKSB7XG4gICAgICBjb25zdCBleGlzdGluZyA9IGN0eC5kYi5saW5rcy50by5maW5kKHRvKTtcbiAgICAgIGlmICghZXhpc3RpbmcpIGN0eC5kYi5saW5rcy5pbnNlcnQoeyB0bywgZnJvbTogW2hhc2hdIH0pO1xuICAgICAgZWxzZSBpZiAoIWV4aXN0aW5nLmZyb20uc29tZSgoeCkgPT4geCA9PT0gaGFzaCkpIGN0eC5kYi5saW5rcy50by51cGRhdGUoeyAuLi5leGlzdGluZywgZnJvbTogWy4uLmV4aXN0aW5nLmZyb20sIGhhc2hdIH0pO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfWNhdGNoIChlKXtcbiAgICB0aHJvdyBuZXcgU2VuZGVyRXJyb3IoIFwiSU5TRVJUIEVSUk9SOiBcIitmcm9tanNvbihzY2hlbWFSb3cuZGF0YSkpXG4gIH1cbn0pO1xuXG5cbmNvbnN0IHNldHVwID0gc3BhY2V0aW1lZGIucmVkdWNlcignc2V0dXAnLCB7fSwgKGN0eCkgPT4ge1xuXG4gIHRyeXtcbiAgICBjdHguZGIubm90ZS5pbnNlcnQoeyBoYXNoOiBoYXNoRGF0YSh0b3ApLCBzY2hlbWFIYXNoOiB0b3Auc2NoZW1hSGFzaCwgZGF0YTogdG9qc29uKHRvcC5kYXRhKSB9KVxuICB9Y2F0Y2gge31cblxuICBmb3IgKGNvbnN0IG5vdGUgb2Ygc2NoZW1hcykge1xuICAgIGNvbnN0IGhhc2ggPSBoYXNoRGF0YShub3RlKTtcbiAgICBpZiAoY3R4LmRiLm5vdGUuaGFzaC5maW5kKGhhc2gpKSBjb250aW51ZTtcbiAgICBjdHguZGIubm90ZS5pbnNlcnQoe1xuICAgICAgaGFzaCxcbiAgICAgIHNjaGVtYUhhc2g6IG5vdGUuc2NoZW1hSGFzaCxcbiAgICAgIGRhdGE6IHRvanNvbihub3RlLmRhdGEpLFxuICAgIH0pO1xuICB9XG59KVxuXG5zcGFjZXRpbWVkYi5pbml0KHNldHVwKVxuXG4vKiB0aGlzIHdpbGwgb3V0c2lkZSBvZiB0cmFuc2FjdGlvbiBhbGxvd2luZyBmb3IgZmV0Y2ggcmVxdWVzdHMgKi9cbnNwYWNldGltZWRiLnByb2NlZHVyZSgncnVuX25vdGVfYXN5bmMnLCB7aGFzaDogdC5zdHJpbmcoKSwgYXJnOiB0LnN0cmluZygpfSwgdC5zdHJpbmcoKSwgKGN0eCwge2hhc2gsIGFyZ30pPT4ge1xuXG4gIGNvbnN0IGdldE5vdGUgPSAocmVmIDogUmVmKSA9PiBjdHgud2l0aFR4KGM9PiBjLmRiLm5vdGUuaGFzaC5maW5kKG5vcm1hbGl6ZVJlZihyZWYpKSlcbiAgY29uc3QgZnVlbFJlZiA9IHsgdmFsdWU6IDEwMDAwIH07XG4gIGNvbnN0IGZuU2NoZW1hSGFzaCA9IGhhc2hEYXRhKHNlcnZlcl9mdW5jdGlvbik7XG5cbiAgY29uc3QgY2FsbCA9IChyZWY6IFJlZiwgYXJnOnN0cmluZykgPT4ge1xuXG4gICAgY29uc3QgZm4gPSBnZXROb3RlKHJlZik7XG4gICAgaWYgKGZuID09IG51bGwpIHRocm93IG5ldyBTZW5kZXJFcnJvcihcImZuIG5vdCBmb3VuZFwiKVxuICAgIGlmIChmbi5zY2hlbWFIYXNoICE9IGZuU2NoZW1hSGFzaCkgdGhyb3cgbmV3IFNlbmRlckVycm9yKFwibm90IGEgc2VydmVyIGZ1bmN0aW9uXCIpXG5cbiAgICBjb25zdCBrZXlGb3IgPSAoa2V5OiBzdHJpbmcpID0+IGAke2ZuLmhhc2h9OiR7a2V5fWA7XG4gICAgY29uc3Qgc3RvcmFnZSA9IHtcbiAgICAgIGdldEl0ZW06IChrZXk6IHN0cmluZykgPT4gY3R4LndpdGhUeChjdHggPT4gY3R4LmRiLnN0b3JlLmtleS5maW5kKGtleUZvcihrZXkpKT8udmFsdWUgPz8gbnVsbCksXG4gICAgICBzZXRJdGVtOiAoa2V5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpID0+IGN0eC53aXRoVHgoY3R4ID0+IHtcbiAgICAgICAgY29uc3QgayA9IGtleUZvcihrZXkpO1xuICAgICAgICBpZiAoY3R4LmRiLnN0b3JlLmtleS5maW5kKGspKSBjdHguZGIuc3RvcmUua2V5LnVwZGF0ZSh7IGtleTogaywgdmFsdWUgfSk7XG4gICAgICAgIGVsc2UgY3R4LmRiLnN0b3JlLmluc2VydCh7IGtleTogaywgdmFsdWUgfSk7XG4gICAgICB9KVxuICAgIH07XG5cbiAgICBsZXQgcmV0ID0gcnVuV2l0aEZ1ZWxTaGFyZWQoYGxldCBhcmdzID0gJHthcmd9OyAkeyhmcm9tanNvbihmbi5kYXRhKSBhcyB7Y29kZTogc3RyaW5nfSkuY29kZX1gLCBmdWVsUmVmLCB7c3RvcmFnZSwgY2FsbCwgaGFzaDogaGFzaDEyOH0pXG4gICAgaWYgKFwiZXJyXCIgaW4gcmV0KSB0aHJvdyBuZXcgU2VuZGVyRXJyb3IoU3RyaW5nKHJldC5lcnIpKTtcbiAgICByZXR1cm4gKHJldCBhcyBhbnkpLm9rO1xuICB9XG5cbiAgcmV0dXJuIHRvanNvbihjYWxsKGhhc2ggYXMgSGFzaCwgYXJnKSlcblxufSlcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsSUFBSUEsYUFBVyxPQUFPO0FBQ3RCLElBQUlDLGNBQVksT0FBTztBQUN2QixJQUFJQyxxQkFBbUIsT0FBTztBQUM5QixJQUFJQyxzQkFBb0IsT0FBTztBQUMvQixJQUFJQyxpQkFBZSxPQUFPO0FB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